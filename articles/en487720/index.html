<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚Äçüßëüèº üöµüèæ üôåüèΩ On competitive corutinism (using reactive programming as an example) üç∞ üë©üèø‚Äçüíº ü§õ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introduction
 The competition for the minds, moods and aspirations of programmers is, as it seems to me, a modern trend in the development of progr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>On competitive corutinism (using reactive programming as an example)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487720/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The competition for the minds, moods and aspirations of programmers is, as it seems to me, a modern trend in the development of programming. When almost nothing is proposed, although under the slogan of the struggle for it. It is very, very difficult to recognize in the crush of software paradigms something new, which in fact often turns out to be quite well-known, and sometimes simply outdated. Everything is ‚Äúwashed away‚Äù by terminological delights, verbose analysis and multiline examples in many programming languages. At the same time, requests to open and / or consider the background of the solution, the essence of innovations are stubbornly avoided, the attempts to find out how much this is needed and what will give in the end, which qualitatively distinguishes the innovation from already known approaches and programming tools, are thwarted at the bud.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I appeared on Habr√©, as was aptly noticed in one of the discussions, after a certain freeze. I won‚Äôt even mind. At least, the impression, apparently, is just that. Therefore, I agree, I confess, although, if it‚Äôs my fault, it‚Äôs only partially. I admit, I live by the ideas about parallel programming, formed in the 80s of the last century. Antiquity? Maybe. But tell me what‚Äôs new, about which the science of [parallel] programming would not already be known then (see details [1]). At that time, parallel programs were divided into two classes - parallel-serial and asynchronous. If the former were already considered archaic, then the latter - advanced and truly parallel. Among the latter, programming with event control (or just event programming), stream control, and dynamic programming was singled out.That's all in general. Further details already.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And what does current programming offer in addition to what is already known at least 40 years ago? In my "frostbitten look" - nothing. Coroutines, as it turned out, are now called coroutines or even goroutines; the terms concurrency and competition enter into a stupor, it seems, not only translators. And there are no such examples. For example, what is the difference between reactive programming (RP) and event programming or streaming? Which of the known categories and / or classifications does it fall into? Nobody seems to be interested in this, and no one can clarify this. Or can you classify now by name? Then, indeed, coroutines and coroutines are different things, and parallel programming is simply obliged to differ from the competitive one. What about state machines? What kind of miracle technique is this?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The ‚Äúspaghetti‚Äù in the head arises from the oblivion of the theory where, when a new model is introduced, it is compared with already known and well-studied models. </font><font style="vertical-align: inherit;">Whether this will be done well, but at least you can figure it out, because the process is formalized. </font><font style="vertical-align: inherit;">But how to get to the bottom of it if you give the coroutines a new nickname and then pick the ‚Äúengine hood code‚Äù simultaneously in five languages, evaluating in addition the prospect of migration to streams. </font><font style="vertical-align: inherit;">And these are only coroutines, which, frankly, should already be forgotten because of their elementary nature and their small use (it‚Äôs, of course, about my experience).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Reactive programming and everything, everything, everything</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will not set ourselves the goal of thoroughly understanding the concept of ‚Äúreactive programming‚Äù, although we will take the ‚Äúreactive example‚Äù as the basis for further discussion. </font><font style="vertical-align: inherit;">His formal model will be created on the basis of the well-known formal model. </font><font style="vertical-align: inherit;">And this, I hope, will allow us to clearly, accurately, in detail understand the interpretation and operation of the original program. </font><font style="vertical-align: inherit;">But how much the created model and its implementation will be ‚Äúreactive‚Äù is up to the apologists of this type of programming to decide. </font><font style="vertical-align: inherit;">At the moment, it will be enough for now that the new model will have to implement / model all the nuances of the original example. </font><font style="vertical-align: inherit;">If something is not taken into account, then I hope there are those who correct me. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, in [2], an example of a reactive program was considered, the code of which is shown in Listing 1.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 1. Reactive program code</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">1. 1 = 2 <font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2 <font></font>
4.  1, 2, 3 <font></font>
5. 1 = 4 <font></font>
6.  1, 2, 3</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the world of reactive programming, the result of its work will be different from the result of a regular program of the same kind. This alone is bad, if not to say ugliness, because The result of the program should be unambiguous and not depend on implementation. But more confuses the other. Firstly, in appearance it is hardly possible to distinguish a regular similar code from a reactive one. Secondly, apparently, the author himself is not entirely sure of the work of the reactive program, speaking about the result ‚Äúmost likely‚Äù. And thirdly, which of the results is considered correct?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Such an ambiguity in the interpretation of the code has led to the fact that it is not immediately possible to ‚Äúcut into‚Äù it. </font><font style="vertical-align: inherit;">But then, as often happens, everything turned out to be much simpler than one might have expected. </font><font style="vertical-align: inherit;">Figure 1 shows two structural diagrams that, hopefully, correspond to the structure and explain the operation of the example. </font><font style="vertical-align: inherit;">In the upper diagram, blocks X1 and X2 organize data entry, signaling block X3 about their change. </font><font style="vertical-align: inherit;">The latter performs the summation and allows the Pr block to print the current values ‚Äã‚Äãof the variables. </font><font style="vertical-align: inherit;">Having printed, the Pr block signals to the X3 block, moreover, to him and only to him that he is ready to print new values.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">1. Two structural models of the example</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/tw/hs/rq/twhsrqxfdfuyxi4txtd9ciat6hs.jpeg" alt="image"><br>
</div></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second scheme, in comparison with the first, is quite elementary. As part of a single block, it enters data and implements sequentially: 1) calculating the sum of the input data and 2) printing them. The internal filling of the block at this level of presentation is not disclosed. Although it can be said that at the structural level it can be a "black box including a four-block scheme. But still, his [algorithmic] device is supposed to be different. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment. The approach to the program as a black box essentially reflects the attitude of the user towards it. The latter is not interested in its implementation, but in the result of the work. Whether it is a reactive program, an event program, or some other, but the result in accordance with the theory of algorithms should be unambiguous and predictable.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fig. </font><font style="vertical-align: inherit;">2 presents algorithmic models that clarify in detail the internal [algorithmic] structure of circuit blocks. </font><font style="vertical-align: inherit;">The upper model is represented by a network of automata, where each of the automata is an algorithmic model of a separate block. </font><font style="vertical-align: inherit;">The connections between the automata shown by dash-dotted arcs correspond to the connections of the circuit. </font><font style="vertical-align: inherit;">A single-automaton model describes the operation algorithm of a block diagram consisting of one block (see a separate Pr block in Fig. 1).</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">2. Algorithmic models for structural schemes</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/rj/4f/ds/rj4fdsx8kekihnbqqebmpji1y9e.jpeg" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The automata X1 and X2 (the names of the automata and blocks coincide with the names of their variables), detect the changes and, if the automaton X3 is ready to perform the addition operation (in the state ‚Äús0‚Äù), go into the state ‚Äús1‚Äù, remembering the current value of the variable. The X3 machine, having received permission to enter the state ‚Äús1‚Äù, performs the addition operation and, if necessary, waits for the completion of printing of the variables. ‚ÄúPrinting machine‚Äú Pr, having finished printing, returns to the initial state ‚Äúp0‚Äù, where it waits for the next command. Note that its state ‚Äúp1‚Äù starts a chain of reverse transitions - the automaton X3 to the state ‚Äús0‚Äù, and X1 and X2 to the state ‚Äús0‚Äù. After that, the analysis of the input data, then their summation and subsequent printing is repeated.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compared to the automaton network, the algorithm of a separate Pr automaton is quite simple, but, we note, it does the same job and maybe even faster. </font><font style="vertical-align: inherit;">Its predicates reveal a change in variables. </font><font style="vertical-align: inherit;">If this happens, then the transition to the state ‚Äúp1‚Äù is performed with the start of the action y1 (see Fig. 2), which sums up the current values ‚Äã‚Äãof the variables, while remembering them. </font><font style="vertical-align: inherit;">Then, on an unconditional transition from the state ‚Äúp1‚Äù to the state ‚Äúp0‚Äù, the action y2 prints the variables. </font><font style="vertical-align: inherit;">After that, the process returns to the analysis of the input data. </font><font style="vertical-align: inherit;">The implementation code for the latest model is shown in Listing 2.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 2. Implementation of the Pr automaton</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span>
<span class="hljs-keyword">extern</span> LArc TBL_PlusX3[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPlusX3</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FPlusX3(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FPlusX3(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_PlusX3, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarY;        		<span class="hljs-comment">// </span>
    CVar *pVarX1;        		<span class="hljs-comment">// </span>
    CVar *pVarX2;        		<span class="hljs-comment">// </span>
    CVar *pVarX3;        		<span class="hljs-comment">// </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//   X1</span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//   X2</span>
    CVar *pVarStrNameX3;		<span class="hljs-comment">//   X3</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };
    <span class="hljs-keyword">double</span> dSaveX1{<span class="hljs-number">0</span>};
    <span class="hljs-keyword">double</span> dSaveX2{<span class="hljs-number">0</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fplusx3.h"</span></span><font></font>
<font></font>
LArc TBL_PlusX3[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x2"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p1"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"--"</span>,  <span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FPlusX3::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"strY"</span>, CLocVar::vtString, <span class="hljs-string">"print of output string"</span>);			<span class="hljs-comment">//  </span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"dX1"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarX2 = CreateLocVar(<span class="hljs-string">"dX2"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarX3 = CreateLocVar(<span class="hljs-string">"dX3"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX3 = CreateLocVar(<span class="hljs-string">"strNameX3"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameX3-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX3 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPlusX3::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1-&gt;GetDataSrc() != dSaveX1; }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPlusX3::x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX2-&gt;GetDataSrc() != dSaveX2; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FPlusX3::y1</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// X3 = X1 + X2</span>
    <span class="hljs-keyword">double</span> dX1 = pVarX1-&gt;GetDataSrc(); <span class="hljs-keyword">double</span> dX2 = pVarX2-&gt;GetDataSrc();
    <span class="hljs-keyword">double</span> dX3 = dX1 + dX2;<font></font>
    pVarX3-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, dX3);<font></font>
    dSaveX1 = dX1; dSaveX2 = dX2;<font></font>
<span class="hljs-comment">//  1, 2, 3</span><font></font>
    QString strX1; strX1.setNum(dX1); QString strX2; strX2.setNum(dX2);<font></font>
    QString strX3; strX3.setNum(dX3);<font></font>
    QString qstr = <span class="hljs-string">"X1="</span> + strX1 + <span class="hljs-string">", X2="</span> + strX2 + <span class="hljs-string">", X3="</span> + strX3;<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, qstr.toStdString(), <span class="hljs-literal">nullptr</span>);<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The amount of code is clearly incomparably larger than the original example. But, note, not a single code. The new solution removes all the issues of functioning, not allowing to run into fantasies in the interpretation of the program. An example that looks compact and elegant, but about which you can say ‚Äúmost likely‚Äù, does not cause, let‚Äôs say, positive emotions and a desire to work with it. It should also be noted that it is necessary to compare actually with the action of the automaton y1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The rest of the code is related to the requirements of the "automatic environment", which, I note, is not spoken in the source code. So, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FCreationOfLinksForVariables</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method of the </font><font style="vertical-align: inherit;">base automaton class </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LFsaAppl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creates local variables for the machine and links to them when at the level of the VKPA environment symbolic names of the other environment variables associated with them are indicated. The first time it starts when creating an automaton, and then within the framework of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FInit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">(see step y12), because not all links are known when creating an object. The machine will be in the ‚Äúst‚Äù state until all the necessary links that the x12 predicate checks are initialized. A reference to a variable, if given its name, returns the GetAddressVar method.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To remove possible questions, we present the code of the automaton network. </font><font style="vertical-align: inherit;">It is shown in Listing 3 and includes the code for three automaton classes. </font><font style="vertical-align: inherit;">It is on their basis that many objects are created that correspond to the structural diagram of the network shown in Fig. </font><font style="vertical-align: inherit;">1. Note that the objects X1 and X2 are derived from the general class FSynch.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3. Automated network classes</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_Synch[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSynch</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dGetData</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX-&gt;GetDataSrc(); };
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FSynch(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FSynch(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Synch, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarX;			<span class="hljs-comment">// </span>
    CVar *pVarStrNameX;		<span class="hljs-comment">//   </span>
    CVar *pVarStrNameObject;<span class="hljs-comment">//  -</span>
    LFsaAppl *pL {<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX-&gt;GetDataSrc() != dSaveX; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pL-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pL != <span class="hljs-literal">nullptr</span>; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span> </span>{ dSaveX = pVarX-&gt;GetDataSrc(); }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };
    <span class="hljs-keyword">double</span> dSaveX{<span class="hljs-number">0</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
LArc TBL_Synch[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x2"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSynch::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX = CreateLocVar(<span class="hljs-string">"x"</span>, CLocVar::vtDouble, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameObject = CreateLocVar(<span class="hljs-string">"strNameObject"</span>, CLocVar::vtString, <span class="hljs-string">"name of function"</span>);                   <span class="hljs-comment">//  </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX) {<font></font>
        str = pVarStrNameX-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    str = pVarStrNameObject-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pL = FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_X1X2X3[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FX1X2X3</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dGetData</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX3-&gt;GetDataSrc(); };
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FX1X2X3(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FX1X2X3(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_X1X2X3, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarX1{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarX2{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarX3{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarStrNameFX1;		<span class="hljs-comment">//  X1</span>
    CVar *pVarStrNameFX2;		<span class="hljs-comment">//  X2</span>
    CVar *pVarStrNameFPr;		<span class="hljs-comment">//  Pr</span>
    CVar *pVarStrNameX3;		<span class="hljs-comment">//   </span>
    FSynch *pLX1 {<span class="hljs-literal">nullptr</span>};<font></font>
    FSynch *pLX2 {<span class="hljs-literal">nullptr</span>};<font></font>
    LFsaAppl *pLPr {<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX1-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX2-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x3</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLPr-&gt;FGetState() == <span class="hljs-string">"p1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLPr != <span class="hljs-literal">nullptr</span> &amp;&amp; pLX1 &amp;&amp; pLX2 &amp;&amp; pVarX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span> </span>{ pVarX3-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, pLX1-&gt;dGetData() + pLX2-&gt;dGetData()); }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fx1x2x3.h"</span></span><font></font>
<font></font>
LArc TBL_X1X2X3[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x2"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x3"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FX1X2X3::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX3 = CreateLocVar(<span class="hljs-string">"x"</span>, CLocVar::vtDouble, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameFX1 = CreateLocVar(<span class="hljs-string">"strNameFX1"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameFX2 = CreateLocVar(<span class="hljs-string">"strNameFX2"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameFPr = CreateLocVar(<span class="hljs-string">"strNameFPr"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameX3 = CreateLocVar(<span class="hljs-string">"strNameX3"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str; str = pVarStrNameFX1-&gt;strGetDataSrc();
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX1 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX2 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFPr-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLPr = FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_Print[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FX1X2X3</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPrint</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FPrint(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FPrint(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Print, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarY;        		<span class="hljs-comment">// </span>
    CVar *pVarStrNameFX1;		<span class="hljs-comment">//    X1</span>
    CVar *pVarStrNameFX2;		<span class="hljs-comment">//    X2</span>
    CVar *pVarStrNameFX3;		<span class="hljs-comment">//    X3</span>
    FSynch *pLX1 {<span class="hljs-literal">nullptr</span>};     <span class="hljs-comment">//    X1</span>
    FSynch *pLX2 {<span class="hljs-literal">nullptr</span>};     <span class="hljs-comment">//    X2</span>
    FX1X2X3 *pLX3 {<span class="hljs-literal">nullptr</span>};    <span class="hljs-comment">//    X3</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX3 != <span class="hljs-literal">nullptr</span> &amp;&amp; pLX1 &amp;&amp; pLX2 &amp;&amp; pLX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fprint.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fx1x2x3.h"</span></span><font></font>
<font></font>
LArc TBL_Print[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p1"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FPrint::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"strY"</span>, CLocVar::vtString, <span class="hljs-string">"print of output string"</span>);			<span class="hljs-comment">//  </span>
    pVarStrNameFX1 = CreateLocVar(<span class="hljs-string">"strNameFX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameFX2 = CreateLocVar(<span class="hljs-string">"strNameFX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameFX3 = CreateLocVar(<span class="hljs-string">"strNameFX3"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(pr)"</span>);			<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameFX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX1 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX2 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX3-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX3 = (FX1X2X3*)FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPrint::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX3-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FPrint::y1</span><span class="hljs-params">()</span> </span>{<font></font>
    QString strX1; strX1.setNum(pLX1-&gt;dGetData());<font></font>
    QString strX2; strX2.setNum(pLX2-&gt;dGetData());<font></font>
    QString strX3; strX3.setNum(pLX3-&gt;dGetData());<font></font>
    QString qstr = <span class="hljs-string">"X1="</span> + strX1 + <span class="hljs-string">", X2="</span> + strX2 + <span class="hljs-string">", X3="</span> + strX3;<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, qstr.toStdString(), <span class="hljs-literal">nullptr</span>);<font></font>
}<font></font>
</code></pre> <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This code is different from Listing 1, like a picture of an airplane from its design documentation. But, I think, we are primarily programmers, and, no offense will be told to them, some designers. Our "design code" should be easy to understand and unambiguously interpreted so that our "plane" does not crash on the first flight. And if such a misfortune happened, and with programs this happens more often than with airplanes, then the reason can be found easily and quickly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, considering Listing 3, you need to imagine that the number of classes is not directly related to the number of corresponding objects in the parallel program. The code does not reflect the relationship between objects, but contains the mechanisms that create them. So, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSynch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">contains a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pointer </font><font style="vertical-align: inherit;">to an object of type</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LFsaAppl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The name of this object is determined by a local variable, which in the VKPa environment will correspond to an automaton variable with the name </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strNameObject</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A pointer is necessary to use the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FGetState</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><i><font style="vertical-align: inherit;">to</font></i><font style="vertical-align: inherit;"> monitor the current state of an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSynch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> type automaton object </font><font style="vertical-align: inherit;">(see the predicate code x2). Similar pointers to objects, variables for specifying the names of objects, and predicates necessary for organizing relationships contain other classes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now a few words about the ‚Äúconstruction‚Äù of a parallel program in the VKPA environment. It is created during the loading of the program configuration. In this case, first objects are created on the basis of classes from thematic dynamic libraries of an automaton type (their set is determined by the configuration of the application / program). Created objects are identified by their names (let's call them </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">automatic variables</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Then, the necessary values ‚Äã‚Äãare written to the local variables of the automata. </font><font style="vertical-align: inherit;">In our case, variables with a string type are set to the variable names of other objects and / or the names of the objects. </font><font style="vertical-align: inherit;">In this way, connections between objects of a parallel automaton program are established (see Fig. 1). </font><font style="vertical-align: inherit;">Further, changing the values ‚Äã‚Äãof the input variables (using individual object control dialogs or the standard dialog / environment dialogs for setting values ‚Äã‚Äãfor environment variables), we fix the result. </font><font style="vertical-align: inherit;">It can be seen using a standard environment dialog to display the values ‚Äã‚Äãof variables.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. To the analysis of parallel programs</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the functioning of a parallel program, unless it is quite simple sequentially parallel, it is very, very difficult to say something concrete. The considered network of automata is no exception. Next, we will see this, understanding what can be expected from it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The resulting automaton and the network for which it is built are shown in Fig. </font><font style="vertical-align: inherit;">3. From the network in Fig. </font><font style="vertical-align: inherit;">2, in addition to renaming its elements - automata, input and output signals, it is distinguished by the absence of a ‚Äúprint machine‚Äù of variables. </font><font style="vertical-align: inherit;">The latter is not essential for the operation of the network, and renaming allows you to use the composition operation to build the resulting automaton. </font><font style="vertical-align: inherit;">In addition, to create shorter names, coding was introduced when, for example, the state ‚Äúa0‚Äù of the automaton A is represented by the symbol ‚Äú0‚Äù, and ‚Äúa1‚Äù by the symbol ‚Äú1‚Äù. </font><font style="vertical-align: inherit;">Similarly for other machines. </font><font style="vertical-align: inherit;">In this case, the component state of the network, for example, ‚Äúa1b0c1‚Äù, is assigned the name ‚Äú101‚Äù. </font><font style="vertical-align: inherit;">Similarly, names are formed for all component states of the network, the number of which is determined by the product of states of component automata.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">3. The resulting network automaton</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/a8/oc/9k/a8oc9kfwbbm3apemxhjzpbz5mxw.jpeg" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 The resulting automaton can, of course, be calculated in a purely formal way, but for this we need an appropriate ‚Äúcalculator‚Äù. But if it is not, then you can use a fairly simple intuitive algorithm. Within its framework, one or another component state of the network is recorded and then, sorting through all possible input situations, the target component states are determined by ‚Äúhandles‚Äù. So, having fixed the state ‚Äú000‚Äù corresponding to the current states of the component automata - ‚Äúa0‚Äù, ‚Äúb0‚Äù, ‚Äúc0‚Äù, transitions for the conjunctions of input variables ^ x1 ^ x2, ^ x1x2, x1 ^ x2, x1x2 are determined. We obtain the transitions respectively in states ‚Äúa0b0c0‚Äù, ‚Äúa0b1c0‚Äù, ‚Äúa1b0c0‚Äù, ‚Äúa1b1c0‚Äù, which are marked ‚Äú000‚Äù, ‚Äú010‚Äù, ‚Äú100‚Äù and ‚Äú110‚Äù on the resulting machine. You must repeat this operation sequentially for all reachable states. loopswhich are not loaded with actions can be excluded from the graph.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What we have "in the dry residue". We achieved the main thing - we received the resulting automaton, which accurately describes the operation of the network. We found out that out of eight possible network states, one is inaccessible (isolated) - state ‚Äú001‚Äù. This means that the summation operation will under no circumstances be triggered for input variables that have not changed the current value.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Which is disturbing, although testing did not reveal errors. On the graph of the resulting automaton, transitions conflicting in output actions were found. They are marked with a combination of the actions y1y3 and y2y3. Actions y1 and y2 are triggered when the input data changes, and then another action y3 computes the sum of the variables in parallel with them. What values ‚Äã‚Äãwill it operate on - old or just changed by new ones? To eliminate the ambiguity, you can simply change the actions of y3 and y4. In this case, their code will be as follows: X3 = X1Sav + X2Sav and print (X1Sav, X2Sav, X3).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So. </font><font style="vertical-align: inherit;">The construction of the resulting automaton revealed obvious problems in the created parallel model. </font><font style="vertical-align: inherit;">Whether they appear in the reactive program is a question. </font><font style="vertical-align: inherit;">Everything will, apparently, depend on the approach to the implementation of parallelism in the reactive paradigm. </font><font style="vertical-align: inherit;">In any case, such a dependence must be taken into account and somehow eliminated. </font><font style="vertical-align: inherit;">In the case of an automated network, it is easier to leave the changed version than to try to change the network. </font><font style="vertical-align: inherit;">It‚Äôs okay if the ‚Äúold‚Äù data that initiated the network‚Äôs operation is printed first, and then the current data is printed next.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Conclusions </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each of the solutions considered has its pros and cons. The initial one is very simple, the network is more complicated, and created on the basis of a single machine, it will start analyzing the input data only after its visualization. Due to its parallelism, the same automatic network will start the analysis of input data before the end of the printing procedure. And if the visualization time is long, but this will be the case against the summation operation, then the network will be faster from the point of view of input control. Those. an assessment based on an estimate of the amount of code in the case of parallel programs is not always objective. In simpler terms, the network is parallel, the one-component solution is largely sequential (its predicates and actions are parallel). And we, first of all, are talking about parallel programs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The network model is also an example of a flexible solution. First, components can be designed independently of one another. Secondly, any component can be replaced by another. And thirdly, any network component can be an element of a library of automatic processes and is used in another network solution. And these are just the most obvious benefits of a parallel solution.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But back to reactive programming. Does RP consider all program statements to be initially parallel? We can only assume that without this it is difficult to talk about a programming paradigm ‚Äúoriented towards data flows and the propagation of changes‚Äù (see the definition of reactive programming in [3]). But then what is its difference from programming with streaming control (for more details see [1])? So we return to where we started: how to classify reactive programming in the framework of well-known classifications? And, if RP is something special programming, then what is it different from the known programming paradigms?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, about the theory. Without it, the analysis of parallel algorithms would not just be difficult - impossible. The analysis process sometimes reveals problems that, even with a careful and thoughtful look at the program, as, incidentally, at the ‚Äúdesign document‚Äù, it is impossible to guess. In any case, I am for the fact that planes, both in a figurative and in any other sense, do not crash. This is me to the fact that, of course, you need to strive for simplicity and grace of form, but without loss of quality. We, programmers, do not just ‚Äúdraw‚Äù programs, but often control what is hidden there, including by airplanes!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yes, I almost forgot. I would classify automatic programming (AP) as programming with dynamic control. As for asynchrony - I bet. Given that the basis of the AP control model is a network in a single time, i.e. synchronous networks of automata, then it is synchronous. But since the VKPa environment also implements many networks through the concept of ‚Äúautomaton worlds,‚Äù it is completely asynchronous. In general, I am against any very rigid classification framework, but not for anarchy. In this sense, in VKPa, I hope a certain compromise has been reached between the rigidity of serial-parallel programming and a certain asynchronous anarchism. Given the fact that automatic programming also covers the class of event programs (see [4]), and stream programs are easily modeled within it,what programming can you still dream of? For sure - to me.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literature</font></font></b><div class="spoiler_text">1.   /.. , .. , .. , .. ;  . .. . ‚Äì .:   , 1983. ‚Äì 240.<br>
2.      . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">habr.com/ru/post/486632</a> . . . (  07.02.2020).<br>
3.  . . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">ru.wikipedia.org/wiki/_</a> . . . (  07.02.2020).<br>
4.  ‚Äî  ? [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">habr.com/ru/post/483610</a> . . . (  07.02.2020).<br>
</div></div></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en487698/index.html">Digital events in St. Petersburg from February 10 to 16</a></li>
<li><a href="../en487702/index.html">A selection of articles on machine learning: case studies, guides and research for January 2020</a></li>
<li><a href="../en487704/index.html">How we built dynamic reports at SSRS 2014</a></li>
<li><a href="../en487706/index.html">Service Discovery in distributed systems using the Consul example. Alexander Sigachev</a></li>
<li><a href="../en487716/index.html">Perfect SAST. Parser</a></li>
<li><a href="../en487724/index.html">BlazingPizza: Blazor app from start to finish. Part 2. Add a component</a></li>
<li><a href="../en487728/index.html">@Pythonetc compilation, January 2020</a></li>
<li><a href="../en487730/index.html">Natural Language Processing. Results 2019 and trends for 2020</a></li>
<li><a href="../en487734/index.html">Speeding up Entity Framework Core</a></li>
<li><a href="../en487738/index.html">Schema animation in SCADA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>