<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò≥ üî¢ ü§∂üèª SwiftUI nas prateleiras: Anima√ß√£o, parte 2 ü§© üëè üôé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta √© a segunda parte da hist√≥ria de anima√ß√£o no SwiftUI. No primeiro artigo, vimos exemplos simples para o b√°sico de como a anima√ß√£o funciona no Swi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI nas prateleiras: Anima√ß√£o, parte 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506672/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta √© a segunda parte da hist√≥ria de anima√ß√£o no SwiftUI. No primeiro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vimos exemplos simples para o b√°sico de como a anima√ß√£o funciona no SwiftUI. Nesta parte, iremos mais al√©m e analisaremos em detalhes o exemplo anunciado com anima√ß√£o em arco-√≠ris. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abaixo do corte, voc√™ encontrar√° uma an√°lise do tempo da anima√ß√£o, criando seu pr√≥prio mecanismo de curva de tempo para trabalhar em uma anima√ß√£o linear em loop, exemplos da implementa√ß√£o de diferentes gradientes e alguns truques interessantes que ajudar√£o voc√™ a entender como a anima√ß√£o funciona sob o cap√¥.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deixe-me lembr√°-lo de que espiei a ideia de implementar uma anima√ß√£o desse tipo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . L√°, os autores seguiram o caminho de menor resist√™ncia e implementaram a maneira mais √≥bvia de implementar esse conceito, animando a forma. O princ√≠pio √© simples: cada onda √© um contorno delineado por uma curva de Bezier, e o par√¢metro "time" afeta a posi√ß√£o do limite direito dessa onda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â assim que a anima√ß√£o final se parece: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para maior clareza, espalharei as ondas um pouco verticalmente. Isso √© f√°cil, acabei de adicionar no final do NotchWave, movendo todo o contorno at√© a altura da onda, de acordo com a fase atual da anima√ß√£o:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">return</span> p.applying(.<span class="hljs-keyword">init</span>(translationX: <span class="hljs-number">0</span>, y: height * <span class="hljs-keyword">self</span>.phase))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, e tamb√©m .drowingGroup () √© necess√°rio n√£o esquecer de desconectar - isso n√£o significa que a imagem ultrapasse as bordas do quadro fixo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z3/zv/bi/z3zvbiseywno8t1fnt-i0ugcqgm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A abordagem √© simples, produz o resultado desejado ... mas me pareceu muito chato. </font><font style="vertical-align: inherit;">Meu caminho acabou sendo muito mais longo, e eu n√£o diria que o resultado final seria pelo menos um pouco melhor, mas seria interessante ao longo do caminho. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ ainda n√£o conhece muito bem os princ√≠pios do trabalho de anima√ß√£o no SwiftUI, recomendo a leitura do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo anterior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">E eu quero me aprofundar no c√≥digo fonte no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabalhar com gradientes</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No come√ßo, eu escolhi uma abordagem diferente. Achei muito mais √∫til lidar com a anima√ß√£o do deslocamento de objetos do que com a anima√ß√£o das formas (eu ainda chamo de estrutura da forma). O deslocamento pode funcionar com qualquer coisa - v√°rias formas, imagens e outras visualiza√ß√µes. Como tarefa educacional, eu queria implementar uma transi√ß√£o suave de cores de uma onda para outra. No conceito original, algo assim era assim. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No total, o SwiftIUI oferece tr√™s usos poss√≠veis do gradiente - linear, circular e angular. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t7/o6/7d/t7o67dwcm_v5svufist7tfp0kwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No c√≥digo, isso parece algum tipo de construtor de blocos. Observe como toda a onda √© segmentada.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wa/af/el/waafeltt9cgiasfzxg1gjexwc8i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um gradiente linear √© caracterizado por um ponto inicial e final para o gradiente. </font><font style="vertical-align: inherit;">Estes n√£o s√£o pontos CGPoint com coordenadas absolutas (x: y :), mas pontos UnitPoint, ou seja, </font><font style="vertical-align: inherit;">coordenadas relativas, em que x: y: s√£o especificadas em fra√ß√µes da largura e altura da √°rea selecionada para esta Visualiza√ß√£o. </font><font style="vertical-align: inherit;">Tamb√©m existem pontos predefinidos correspondentes aos cantos (.topLeading, .bottomTrailing, etc.) e os pontos m√©dios dos lados (.top, .trailing, etc.).</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
    .fill(<span class="hljs-type">LinearGradient</span>(<font></font>
         gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
          startPoint: .leading,<font></font>
          endPoint: .trailing))<font></font>
    .frame(width: <span class="hljs-keyword">self</span>.gradientLength)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segmento de gradiente linear √© "borracha". </font><font style="vertical-align: inherit;">Tem uma largura fixa, mas sua altura n√£o √© especificada. </font><font style="vertical-align: inherit;">Assim, ele preencher√° o valor total fornecido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma hist√≥ria um pouco mais complicada, com um gradiente circular. </font><font style="vertical-align: inherit;">Indicamos o ponto - o centro do c√≠rculo, o raio do in√≠cio do gradiente e o raio do final do gradiente. </font><font style="vertical-align: inherit;">Os raios j√° est√£o em termos absolutos, ou seja, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pontos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O centro do c√≠rculo ainda est√° definido como UnitPoint.</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
     .fill(<span class="hljs-type">RadialGradient</span>(<font></font>
          gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">0</span>),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">1</span>)]),<font></font>
          center: .bottomTrailing,<font></font>
          startRadius: <span class="hljs-keyword">self</span>.topRadius,<font></font>
          endRadius: <span class="hljs-keyword">self</span>.topRadius + <span class="hljs-keyword">self</span>.gradientLength)<font></font>
                )<font></font>
    .frame(height: <span class="hljs-keyword">self</span>.topRadius)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma pe√ßa com uma circunfer√™ncia superior tem uma altura fixa, mas se estende na horizontal. Definimos raios fixos espec√≠ficos em pontos, para que n√£o seja necess√°rio colar um ret√¢ngulo de alongamento adicional da cor de base, como no caso de um gradiente linear. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mais dif√≠cil de aplicar √© um gradiente angular. √â dado pelo √¢ngulo inicial e final, bem como pela dire√ß√£o. Como voc√™ pode ver na lista de c√≥digos, trabalhar com cantos n√£o √© muito conveniente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ deve se lembrar do curso escolar de trigonometria para calcular o √¢ngulo necess√°rio, se precisar iniciar o gradiente angular em um ponto e terminar em outro.</font></font><br>
<br>
<pre><code class="swift hljs">       
<span class="hljs-type">Rectangle</span>()<font></font>
      .fill(<span class="hljs-type">AngularGradient</span>(<font></font>
            gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.angularGradientMiddleStop(blockWidth: geometry.size.width)),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
            center: .bottomLeading,<font></font>
            startAngle: <span class="hljs-keyword">self</span>.directionTo(gradientPart: <span class="hljs-keyword">self</span>.start, blockWidth: geometry.size.width),<font></font>
            endAngle: <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)))<font></font>
<font></font>
...<font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">directionTo</span><span class="hljs-params">(gradientPart: Color, blockWidth: CGFloat)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> angleOf = gradientAngles(blockWidth: blockWidth)
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>.zero
        <span class="hljs-keyword">switch</span> gradientPart{
            <span class="hljs-keyword">case</span> start: angle = angleOf.start
            <span class="hljs-keyword">case</span> middle: angle = angleOf.middle
            <span class="hljs-keyword">case</span> end: angle = angleOf.end
            <span class="hljs-keyword">default</span>: <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"there is no gradient stop with that color: \(gradientPart)"</span>)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gradientAngles</span><span class="hljs-params">(blockWidth: CGFloat)</span></span> -&gt; (start: <span class="hljs-type">Angle</span>, middle: <span class="hljs-type">Angle</span>, end: <span class="hljs-type">Angle</span>){
        <span class="hljs-keyword">let</span> blockHeight = <span class="hljs-keyword">self</span>.bottomRadius
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: blockHeight)
        <span class="hljs-keyword">let</span> topRight = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength)
        <span class="hljs-keyword">let</span> topGradientStarts = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength * (<span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop))
        <span class="hljs-keyword">let</span> startAngle = center.radialDirection(to: topRight)
        <span class="hljs-keyword">let</span> middleAngle = center.radialDirection(to: topGradientStarts)
        <span class="hljs-keyword">let</span> endAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)
        <span class="hljs-keyword">return</span> (start: startAngle, middle: middleAngle, end: endAngle)<font></font>
    }<font></font>
<font></font>
...<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">CGPoint</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">radialDirection</span><span class="hljs-params">(to point: CGPoint)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> deltaX =  point.x - <span class="hljs-keyword">self</span>.x
        <span class="hljs-keyword">let</span> deltaY =  point.y - <span class="hljs-keyword">self</span>.y
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> deltaX == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaY == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaX / -deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(-deltaX / deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O gradiente angular, que √© a cauda da onda, tamb√©m √© de borracha, mas j√° em largura - ocupa metade do tamanho restante. Na verdade, √© por isso que h√° tanta trigonometria. Conhe√ßo a posi√ß√£o de pontos espec√≠ficos na borda da tela onde uma determinada cor deve estar (desde que colo um gradiente circular com um angular). Al√©m disso, os valores dos √¢ngulos dependem n√£o apenas dos raios do gradiente inferior, mas tamb√©m da largura do pr√≥prio bloco com o gradiente. Pela primeira vez desde a escola, peguei um l√°pis e lembrei de √°lgebra :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas as tr√™s op√ß√µes usam uma √∫nica descri√ß√£o de cores no gradiente. </font><font style="vertical-align: inherit;">Esta √© uma lista simples de cores em uma matriz. </font><font style="vertical-align: inherit;">Sua distribui√ß√£o ser√° uniforme em um determinado segmento. </font><font style="vertical-align: inherit;">Voc√™ pode refinar a distribui√ß√£o usando uma matriz de elementos Stop. </font><font style="vertical-align: inherit;">De fato, essa √© a mesma enumera√ß√£o de cores, apenas para cada uma delas a coordenada em um √∫nico segmento em que estar√° localizada tamb√©m √© indicada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, criei uma onda aproximadamente da mesma forma que no conceito original. </font><font style="vertical-align: inherit;">No entanto, a transi√ß√£o de uma cor para outra agora n√£o √© n√≠tida, mas suavizada, o que potencialmente deve tornar a anima√ß√£o mais suave.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cor n√£o √© o que parece</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° um ponto relacionado √† cor. </font><font style="vertical-align: inherit;">Para criar o efeito de uma onda ondulante, decidi fazer a transi√ß√£o entre cores n√£o muito linear. </font><font style="vertical-align: inherit;">Se voc√™ observar atentamente, notar√° que o gradiente √© mais n√≠tido na borda e, quanto mais longe, mais suave flui para a cor principal. </font></font><br>
<img src="https://habrastorage.org/webt/hb/k-/f-/hbk-f-u1tcrri8furxdgeg8tx50.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consegui isso calculando a cor intermedi√°ria e criando um gradiente com esta distribui√ß√£o:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cor inicial - 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cor intermedi√°ria - 0,3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cor final - 1</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema surgiu com o c√°lculo da m√©dia de duas cores. SwiftUI significa usar o objeto Color para gradientes e fui seduzido. De fato, se voc√™ deseja trabalhar com cores como objetos RGB, use inicialmente o UIColor no seu modelo, porque o Color n√£o tem acesso direto √†s cores. Tamb√©m n√£o √© poss√≠vel convert√™-lo novamente para o UIColor. A √∫nica </font><font style="vertical-align: inherit;">solu√ß√£o </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(n√£o)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adequada que eu encontrei </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© obter a reflex√£o de espelho com uma an√°lise de sua representa√ß√£o de string. Tal clich√™, mas ainda n√£o h√° outras op√ß√µes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E isso n√£o √© um erro, n√£o √© uma omiss√£o. </font><font style="vertical-align: inherit;">O ponto √© que o SwiftUI no objeto Color n√£o duplica a funcionalidade do UIColor. </font><font style="vertical-align: inherit;">Se voc√™ precisar trabalhar com canais rgb - use-o. </font><font style="vertical-align: inherit;">A cor no SwiftUI √© uma tela com algumas cores b√°sicas, cujo valor espec√≠fico pode variar um pouco, dependendo da localiza√ß√£o das estrelas no c√©u - uma cor rgb espec√≠fica √© determinada apenas no momento do desenho na tela. </font><font style="vertical-align: inherit;">A documenta√ß√£o diz</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O SwiftUI o resolve apenas com um valor concreto antes de us√°-lo em um determinado ambiente.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas o que se entende por ambiente: a cor da parede atr√°s das costas do usu√°rio ou o tema do design do iOS n√£o √© claro. </font><font style="vertical-align: inherit;">Se isso n√£o lhe agradar, use o UIColor nativamente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anima√ß√£o sem fim</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A anima√ß√£o √© especificada pelo modificador .animation () e inicia depois que o View √© inicializado no modificador </font></font><code>.onAppear()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, alterando a </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vari√°vel. </font><font style="vertical-align: inherit;">Como resultado, o modificador se </font></font><code>.rotationEffect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inscreve para receber dados animativos no intervalo de "era" a "tornou-se", consistente com o cron√¥metro do sistema. </font><font style="vertical-align: inherit;">N√≥s conversamos sobre isso na √∫ltima parte.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
       <span class="hljs-keyword">return</span> <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>))
            <span class="hljs-type">Spacer</span>()<font></font>
       }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/fl/dw/_0/fldw_0xguydvz5fe_-2tpcp3qkm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao executar uma anima√ß√£o sem fim dessa maneira, voc√™ deve entender que qualquer altera√ß√£o subsequente nos modificadores animados a "interromper√°". </font><font style="vertical-align: inherit;">Por exemplo, se depois de iniciar, por algum motivo, voc√™ alterar o valor do √¢ngulo para 0, obter√° este efeito:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ad/vi/iv/adviivgxhwuw0rwwv1itknh2kie.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por qu√™? A resposta est√° no mecanismo de anima√ß√£o da transi√ß√£o de uma anima√ß√£o para outra. Em nosso exemplo, quando a primeira apari√ß√£o da tela foi exibida, iniciamos uma transi√ß√£o animada de 0 a 90. Na verdade, a tela armazena apenas o valor final de 90 e o valor original de 0 n√£o √© armazenado em nenhum lugar. O mecanismo de anima√ß√£o conhece a posi√ß√£o atual da hora e o valor atual de AnimatableData. No ponto 0.5, ser√° 45. O que acontece se, nesse momento, o usu√°rio alterar o valor para 0? Resposta: a anima√ß√£o de alterar o valor de 45 para 0. Tudo ainda est√° em loop. Mas apenas visualmente, o ciclo n√£o est√° fechado, mas quebrado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, h√° casos em que a anima√ß√£o tamb√©m "quebra" se o seu modo de exibi√ß√£o usa @ObservedObject ou outros par√¢metros que fazem com que o modo de exibi√ß√£o seja renderizado novamente. Para resolver esse problema, o modificador .animation possui um par√¢metro .animation (: value :). Passando o valor para l√°, indicamos ao representante que a reinicializa√ß√£o da anima√ß√£o √© necess√°ria apenas quando esse valor √© alterado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, vamos descobrir como parar a anima√ß√£o se n√£o precisarmos mais dela. Para fazer isso, voc√™ precisa fornecer duas coisas. Obviamente, devemos dizer ao SwiftUI que a anima√ß√£o sem fim n√£o √© mais necess√°ria, substituindo-a pela final habitual. Mas isto n√£o √© o suficiente. O modificador .animation () √© uma instru√ß√£o sobre quais hor√°rios usar, mas a rota√ß√£o em si √© descrita dentro do modificador .rotationEffect () e j√° est√° assinada para receber novos valores do √¢ngulo de rota√ß√£o pelo timer. Para interromper a rota√ß√£o, precisamos alterar seu valor tamb√©m.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animation)<font></font>
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.angle == <span class="hljs-number">90</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">self</span>.animation = .<span class="hljs-keyword">default</span>
                }<span class="hljs-keyword">else</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span>
                    <span class="hljs-keyword">self</span>.animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/-o/-d/ui/-o-dui_0ep12qm5zwovo2iedvjm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como antes, alterar o valor do √¢ngulo levou ao in√≠cio de uma nova anima√ß√£o (que parecia quebrada), essa altera√ß√£o tamb√©m ser√° animada, mas agora com o tempo da anima√ß√£o normal. Por isso, nosso quadrado para de girar n√£o instantaneamente, mas como se estivesse com uma desacelera√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mesmo pode ser escrito de forma um pouco mais sucinta, se voc√™ suspender toda a funcionalidade em uma </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vari√°vel do tipo ativado / desativado:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isStarted = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At√© esse momento, tudo era relativamente f√°cil. Mas observe que todos os eventos aqui s√£o gerados dentro da Visualiza√ß√£o. </font></font><code>.onAppear{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â chamado pelo sistema e </font></font><code>onTapGesture{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √© claro, pelo usu√°rio. No entanto, e se voc√™ quiser encapsular a anima√ß√£o inteira dentro de uma Visualiza√ß√£o, ativando / desativando-a apenas? O SwiftUI n√£o implica a possibilidade de nenhum m√©todo pai a partir da exibi√ß√£o pai. Teoricamente, voc√™ pode armazenar o filho View como uma estrutura e chamar seus m√©todos de muta√ß√£o, mas </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vari√°veis ‚Äã‚Äãdo filho View n√£o podem ser alteradas dessa maneira, eu tentei - ele n√£o funciona. A √∫nica maneira de fazer algo assim √© usar o PassthroughSubject do Combine, como voc√™ fez no artigo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, tudo √© muito mais simples. Se claramente colocado nas prateleiras da cabe√ßa, esse</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como esse √© o estado interno da visualiza√ß√£o, e n√£o tentando manipul√°-lo de fora, a solu√ß√£o correta ser√° muito simples:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButtonFromOutside</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectParentView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isOn = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">AnimatedRectStopButtonFromOutside</span>(isStarted: isOn)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isOn.toggle()<font></font>
            }<font></font>
        }.onAppear(){<font></font>
            <span class="hljs-keyword">self</span>.isOn = <span class="hljs-literal">true</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, n√£o precisamos de uma </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assinatura para atualizar a Visualiza√ß√£o dentro da visualiza√ß√£o filho - ela j√° √© atualizada como um todo quando o par√¢metro externo a ela √© alterado. </font><font style="vertical-align: inherit;">√Äs vezes n√£o √© conveniente. </font><font style="vertical-align: inherit;">√Äs vezes, n√£o queremos inicializar a exibi√ß√£o filho mais uma vez - por exemplo, para n√£o interromper a anima√ß√£o, ou no init () ocorrem alguns c√°lculos complexos e com muitos recursos (consultas, por exemplo). </font><font style="vertical-align: inherit;">Nesses casos, √© melhor usar entidades de objeto, cujas altera√ß√µes podem ser monitoradas usando o modificador onReceive.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modificando o estado durante a atualiza√ß√£o da visualiza√ß√£o</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° mais uma coisa digna de cobertura. Operamos com apenas dois valores de 0 e 90 graus. Desativar a anima√ß√£o redefine o √¢ngulo para 0. Mas √© poss√≠vel pausar a anima√ß√£o no momento em que clicamos no bot√£o e continu√°-la do mesmo local ao reiniciar? Vamos dar uma olhada no c√≥digo que permite isso:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRect</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> externalStarted = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(started externalStarted: <span class="hljs-type">Bool</span>){
        <span class="hljs-keyword">self</span>.externalStarted = externalStarted
        <span class="hljs-keyword">self</span>._internalStarted = <span class="hljs-type">State</span>(initialValue: !externalStarted)<span class="hljs-comment">//forse to start animation</span><font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-comment">//thats wrong. It just hiding a problem from SwiftUI not solving it</span>
        <span class="hljs-type">DispatchQueue</span>.main.async {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted == <span class="hljs-literal">false</span>{
                <span class="hljs-comment">// print("stop animation")</span>
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">false</span>
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted {
             <span class="hljs-comment">//    print("start animation")</span>
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">true</span>
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
       }<font></font>
         <font></font>
       <span class="hljs-keyword">return</span>  <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.red)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(internalStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e9/ci/ge/e9cigegcoxid1l9skuw2qxle238.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A id√©ia principal √© acompanhar o hor√°rio no in√≠cio da anima√ß√£o. Depois de algum tempo, quando tivermos que interromper a anima√ß√£o, poderemos verificar quantos ciclos completos de anima√ß√£o j√° passaram e assumir qual √¢ngulo de rota√ß√£o do quadrado estamos vendo no momento. Depois disso, podemos atribuir </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exatamente esse valor √† vari√°vel do √¢ngulo de rota√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que essa abordagem funcione, precisamos acompanhar o in√≠cio e o final da anima√ß√£o. Init () n√£o funcionar√°. N√£o podemos acessar os </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√¢metros </font><font style="vertical-align: inherit;">existentes </font><font style="vertical-align: inherit;">para obter a hora de in√≠cio anterior da anima√ß√£o. Este √© um token de </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vari√°veis. Dentro do init, voc√™ pode definir apenas o estado inicial dessa vari√°vel, mas no final da inicializa√ß√£o, se o View j√° existia antes do init (), o valor das </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vari√°veis ‚Äã‚Äãser√° restaurado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, aqui √© implementado o par√¢metro let externalStarted (que controlamos de fora) e o par√¢metro </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interno var internalStarted, com o qual controlamos diretamente a anima√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Havia apenas um ausente - algum modificador que verificaria sua conformidade e atualiza√ß√£o, se necess√°rio, como .onRecieve (), apenas para trabalhar com cada renderiza√ß√£o. </font><font style="vertical-align: inherit;">E ent√£o eu pensei - afinal, o corpo √© chamado para todos os desenhos; ent√£o, por que n√£o fazer isso diretamente? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verificou-se que o SwiftUI jura muito, se durante o processo de renderiza√ß√£o a View altera o valor das </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vari√°veis, fornece</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modificar o estado durante a atualiza√ß√£o da exibi√ß√£o, causa um comportamento indefinido.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e bloqueia essa mudan√ßa. Ent√£o eu fui para um hack sujo e usei DispatchQueue.main.async. Mas vamos ver por que isso √© um truque sujo e por que isso nunca deve ser feito? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este √© realmente o problema. Se escrevermos dentro do corpo alguma estupidez √≥bvia como i + = 1, onde i √© algum tipo de</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vari√°vel, obtemos um loop infinito. No momento da renderiza√ß√£o, tornamos a Visualiza√ß√£o na mem√≥ria n√£o relevante - porque alteramos os dados iniciais para renderiza√ß√£o. Isso significa que, imediatamente ap√≥s a conclus√£o da renderiza√ß√£o, nossa visualiza√ß√£o ser√° colocada na fila para nova renderiza√ß√£o, mas mesmo assim a tornaremos irrelevante novamente. Criamos um ciclo sem fim com nossas pr√≥prias m√£os. Uma chamada ass√≠ncrona nesse caso n√£o altera nada. Apenas muda ligeiramente o in√≠cio da pr√≥xima rodada para o momento "imediatamente ap√≥s a renderiza√ß√£o". Assim, uma chamada ass√≠ncrona n√£o resolve o problema, mas apenas o disfar√ßa, impedindo o SwiftUI de nos cutucar com o nariz. √â como em um carro a l√¢mpada "cheque motor" √© arrancada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por um lado, o que h√° de errado nisso? Em qualquer linguagem de programa√ß√£o, h√° v√°rias maneiras de dar um tiro no p√© se voc√™ n√£o entender o que est√° fazendo. Mas, por outro lado, essa abordagem n√£o √© de todo como o SwiftUI deve funcionar. Trabalhar com o View em tempo de execu√ß√£o √© ruim. Sim, voc√™ pode bater o p√© no peito, garantindo que voc√™ sempre escreva o c√≥digo certo que nunca terminar√° em um loop infinito ... Mas √© como com uma recupera√ß√£o insegura de uma op√ß√£o - √© apenas uma pr√°tica ruim. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como eu disse, nesses casos, voc√™ deve usar Combine, passando um novo valor usando PassthroughSubject. Mas voc√™ pode conviver com o ObservableObject usual, assinando o evento willChange.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandlerTest</span>
    <span class="hljs-keyword">let</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandlerTest</span>){
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)<font></font>
       }.onReceive(animationHandler.objectWillChange){<font></font>
            <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
            <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                withAnimation(.<span class="hljs-keyword">none</span>){<span class="hljs-comment">//not working:(((</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
                }<font></font>
            }<span class="hljs-keyword">else</span> {
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
        }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span>
            <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O ponto controverso aqui √© o uso dos valores do pr√≥prio objeto na assinatura da notifica√ß√£o de que o objeto s√≥ ser√° alterado. </font><font style="vertical-align: inherit;">At√© agora, nos meus exemplos, eu tenho um objeto j√° modificado. </font><font style="vertical-align: inherit;">Aparentemente, as notifica√ß√µes v√™m com algum atraso. </font><font style="vertical-align: inherit;">Mas n√£o posso garantir que esse seja sempre o caso, portanto, aconselho usar as notifica√ß√µes didChange feitas por conta pr√≥pria ou PassthroughSubject, passando o novo valor por ele.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wj/ou/nd/wjoundfihtxhnar7iucx7rrkvnm.gif"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anima√ß√£o Altera√ß√µes na anima√ß√£o</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como voc√™ pode ver no gif, a anima√ß√£o n√£o para instantaneamente. </font><font style="vertical-align: inherit;">Ela precisa de um tempo. </font><font style="vertical-align: inherit;">Isso ocorre porque, quando atribu√≠mos um valor intermedi√°rio ao √¢ngulo, tamb√©m usamos uma certa anima√ß√£o - a padr√£o.</font></font><br>
<br>
<pre><code class="swift hljs">.animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso leva a um comportamento incomum. </font><font style="vertical-align: inherit;">Apesar da relativa simplicidade de tudo o que descrevo, v√°rias nuances de intera√ß√£o permanecem ocultas, para que a imagem sempre pare√ßa suave, mesmo que o programador descuidado n√£o indique algo. </font><font style="vertical-align: inherit;">Portanto, a anima√ß√£o padr√£o √© primavera. </font><font style="vertical-align: inherit;">√â mais adequado para simular as leis da f√≠sica. </font><font style="vertical-align: inherit;">E esta √© uma anima√ß√£o bastante curta, cerca de 0,2 segundos. </font><font style="vertical-align: inherit;">Se a anima√ß√£o da transi√ß√£o para um novo estado (o √¢ngulo calculado e indicado por n√≥s) n√£o conseguir se encaixar perfeitamente nos 0,2 segundos padr√£o, a fim de alternar da velocidade atual da anima√ß√£o com uma bela desacelera√ß√£o para uma parada completa, o pr√≥prio SwiftUI adicionar√° outro loop de anima√ß√£o sem fim, reproduzido na vers√£o acelerada.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z0/b0/so/z0b0soljlzjqudxhek_irdxgyoy.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para evitar isso, basta n√£o usar a anima√ß√£o padr√£o. </font><font style="vertical-align: inherit;">Para o quadrado inferior, desativei a anima√ß√£o de parada de rota√ß√£o assim:</font></font><br>
<br>
<pre><code class="swift hljs">                
.animation(animationHandler.isStarted ? animation : <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou, voc√™ pode calcular com mais precis√£o o valor exigido do par√¢metro no momento da parada, mas para isso, voc√™ precisa n√£o apenas assumir aproximadamente o momento atual da anima√ß√£o, mas conhec√™-lo exatamente. </font><font style="vertical-align: inherit;">Vou mostrar abaixo como fazer isso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O movimento de v√°rias ondas em uma anima√ß√£o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De volta √† anima√ß√£o do arco-√≠ris. </font><font style="vertical-align: inherit;">Ent√£o, n√≥s temos as pr√≥prias ondas, vamos ensin√°-las a se mover. </font><font style="vertical-align: inherit;">A primeira coisa que gostaria de fazer √© executar uma anima√ß√£o sem fim. </font><font style="vertical-align: inherit;">Decidi faz√™-lo desta maneira: terei uma </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vari√°vel respons√°vel pela posi√ß√£o atual da anima√ß√£o. </font><font style="vertical-align: inherit;">No estado 0, a primeira onda estar√° no in√≠cio e a √∫ltima no final. </font><font style="vertical-align: inherit;">As pr√≥prias ondas se sobrep√µem. </font><font style="vertical-align: inherit;">Assim, o comprimento da parte vis√≠vel de cada onda depender√° do n√∫mero de ondas. </font><font style="vertical-align: inherit;">Eu implementei isso usando o ZStack, que lista todas as ondas, e meu pr√≥prio modificador .wavePosition, no qual calculo a posi√ß√£o atual de cada onda no momento da anima√ß√£o e a ordem em que elas se sobrep√µem.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muito c√≥digo</font></font></b>
                        <div class="spoiler_text"><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpWavePosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">let</span> wave: <span class="hljs-type">WaveDescription</span>
    <span class="hljs-keyword">let</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    <span class="hljs-keyword">var</span> time: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> currentPosition: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
                <span class="hljs-keyword">self</span>.time = newValue
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(wave: <span class="hljs-type">WaveDescription</span>, time: <span class="hljs-type">CGFloat</span>, animationHandler: <span class="hljs-type">AnimationHandler</span>){
        <span class="hljs-keyword">self</span>.wave = wave
        <span class="hljs-keyword">self</span>.time = time
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-number">0</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(forWave: Int, ofWaves: Int, overTime: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{<font></font>
<font></font>
        <span class="hljs-keyword">let</span> time = overTime - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(overTime))
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(ofWaves)
        <span class="hljs-keyword">let</span> initialPosition = oneWaveWidth * <span class="hljs-type">CGFloat</span>(forWave)
        <span class="hljs-keyword">let</span> currentPosition = initialPosition + time
        <span class="hljs-keyword">let</span> fullRounds = <span class="hljs-type">Int</span>(currentPosition)
        <span class="hljs-keyword">var</span> result = currentPosition - <span class="hljs-type">CGFloat</span>(fullRounds)
        <span class="hljs-keyword">if</span> fullRounds &gt; <span class="hljs-number">0</span> &amp;&amp; result == <span class="hljs-number">0</span>{
            <span class="hljs-comment">// at the end of the round it should be 1, not 0</span>
            result = <span class="hljs-number">1</span><font></font>
        }<font></font>
 <span class="hljs-comment">//       print("wave \(forWave) in time \(overTime) was at position \(result)")</span>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(wave.totalWavesCount)
        <span class="hljs-keyword">var</span> thisIsFirstWave = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> currentPosition &lt; oneWaveWidth{<font></font>
            thisIsFirstWave = <span class="hljs-literal">true</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span>
            <span class="hljs-type">Group</span>{<font></font>
                content<font></font>
                            .offset(x: -wave.width + currentPosition * (wave.width +  wave.gradientLength),<font></font>
                            <span class="hljs-comment">//to watch how waves move uncoment this</span>
                           <span class="hljs-comment">// y: CGFloat(self.waveInd * 20))</span>
                        y:<span class="hljs-number">0</span>)<font></font>
                    .zIndex(-<span class="hljs-type">Double</span>(currentPosition))<font></font>
                    .transition(.identity)<font></font>
                    .animation(<span class="hljs-literal">nil</span>)<font></font>
<font></font>
                <span class="hljs-keyword">if</span> thisIsFirstWave{<font></font>
                    content<font></font>
                        .offset(x: wave.gradientLength, y: <span class="hljs-number">0</span>)<font></font>
                        .zIndex(-<span class="hljs-number">2</span>)<font></font>
                        .transition(.identity)<font></font>
                        .animation(<span class="hljs-literal">nil</span>)<font></font>
                }<font></font>
            }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">positionOfSharp</span><span class="hljs-params">(wave: WaveDescription, inTime: CGFloat, animationHandler: AnimationHandler)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">SharpWavePosition</span>(wave: wave, time: inTime, animationHandler: animationHandler))<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpRainbowView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">let</span> waves: [<span class="hljs-type">SharpGradientBorder</span>]
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> rainbowPosition: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandler</span>,<font></font>
        backgroundColor: <span class="hljs-type">Color</span> = .clear<font></font>
    ){<font></font>
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">let</span> bottomRadius = animationHandler.waveGeometry.bottomRadius
        <span class="hljs-keyword">let</span> topRadius = animationHandler.waveGeometry.topRadius
        <span class="hljs-keyword">let</span> gradientLength = animationHandler.waveGeometry.gradientLength
        <span class="hljs-keyword">let</span> rainbowColors = animationHandler.rainbowColors
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">var</span> lastColor = rainbowColors.last <span class="hljs-keyword">else</span> {<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"no colors to display in rainbow"</span>)}
        <span class="hljs-keyword">var</span> allWaves = [<span class="hljs-type">SharpGradientBorder</span>]()
        <span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> rainbowColors{
            <span class="hljs-keyword">let</span> view = <span class="hljs-type">SharpGradientBorder</span>(start: color,<font></font>
                                      end: lastColor,<font></font>
                                      bottomRadius: bottomRadius,<font></font>
                                      topRadius: topRadius,<font></font>
                                      gradientLength: gradientLength)<font></font>
            allWaves.append(view)<font></font>
            lastColor = color<font></font>
        }<font></font>
        <span class="hljs-keyword">self</span>.waves = allWaves<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">VStack</span>{
                <span class="hljs-type">ZStack</span>{
                    <span class="hljs-type">ForEach</span>(<span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){ind <span class="hljs-keyword">in</span>
                        <span class="hljs-keyword">self</span>.waves[ind]<font></font>
                            .positionOfSharp(wave: <span class="hljs-type">WaveDescription</span>(ind: ind,<font></font>
                                                    totalWavesCount: <span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">count</span>,<font></font>
                                                    width: geometry.size.width,<font></font>
                                                    baseColor: <span class="hljs-keyword">self</span>.waves[ind].end,<font></font>
                                                    gradientLength: <span class="hljs-keyword">self</span>.waves[ind].bottomRadius + <span class="hljs-keyword">self</span>.waves[ind].topRadius),<font></font>
                                             inTime: <span class="hljs-keyword">self</span>.rainbowPosition,<font></font>
                                             animationHandler: <span class="hljs-keyword">self</span>.animationHandler)<font></font>
                            .animation(<span class="hljs-keyword">self</span>.animationHandler.isStarted ? <span class="hljs-keyword">self</span>.animation : .linear(duration: <span class="hljs-number">0</span>))<font></font>
                    }<font></font>
                }<font></font>
     <span class="hljs-comment">//           .clipped()</span><font></font>
            }<font></font>
<font></font>
        }<font></font>
        .onAppear(){<font></font>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.rainbowPosition = <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
        .onReceive(animationHandler.objectWillChange){<font></font>
             <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
             <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                <span class="hljs-keyword">let</span> newPosition = <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"animated from \(self.rainbowPosition - 1) to \(self.rainbowPosition) stopped at \(newPosition)"</span>)
                    <span class="hljs-keyword">self</span>.rainbowPosition = newPosition<font></font>
             }<span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">self</span>.rainbowPosition += <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
 </code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na primeira vez em que a tela √© exibida na tela, alteramos o estado de 0 para 1, o que, levando em considera√ß√£o a anima√ß√£o linear declarada, faz as ondas correrem infinitamente pela tela. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/vr/ym/bgvrymyoubpekjmpgnsrtxxgco8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando a borda da onda atingir a borda direita, sua pr√≥xima posi√ß√£o estar√° no in√≠cio, al√©m da borda da tela. Parece que simplesmente desaparecer√° do final da onda, expondo o substrato de fundo, o que gostar√≠amos de evitar. Para esse prop√≥sito, o bloco if {...} apareceu no modificador, na fun√ß√£o body (), na qual √© desenhada uma c√≥pia da primeira onda que falta na tela.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/6m/vt/si6mvtiimlv73kxy4c4imperxc4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que eu tive que transferir as caracter√≠sticas geom√©tricas de cada onda na forma de par√¢metros modificadores. </font><font style="vertical-align: inherit;">O problema era que eu precisava redefinir o √≠ndice z de cada onda com base na atual fase de anima√ß√£o. </font><font style="vertical-align: inherit;">Eu poderia extrair a largura da regi√£o vis√≠vel usando o modificador GeometryReader {} dentro, no entanto, me deparei com o fato de que ele bloqueia a altera√ß√£o da ordem da superposi√ß√£o de ondas. </font><font style="vertical-align: inherit;">O modificador .zIndex () funciona apenas no contexto do primeiro cont√™iner ZStack {} na hierarquia Exibir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GeometryReader corta essa conex√£o e zIndex () para de funcionar. </font><font style="vertical-align: inherit;">Se, at√© esse momento, voc√™ pensou que o GeometryReader √© uma maneira inofensiva de obter dados sobre o tamanho da Visualiza√ß√£o atual, isso n√£o √© totalmente verdade.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anima√ß√£o de fluxo</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro ponto importante √© entender a anima√ß√£o dos modificadores internos dentro de seus pr√≥prios modificadores. Em algum momento, cada onda se aproxima da borda da tela, obtendo o deslocamento horizontal m√°ximo e, em seguida, vai para a posi√ß√£o inicial, obtendo o deslocamento m√≠nimo. Essa √© a mesma altera√ß√£o que qualquer outra e √© animada, mesmo dentro da anima√ß√£o. Afinal, a anima√ß√£o √© apenas uma transfer√™ncia muito frequente de valores para o modificador, e tamb√©m ser√° executada com a anima√ß√£o, por mais estranha que pare√ßa. Acontece que dentro da anima√ß√£o, passando um novo valor dentro desse modificador, apenas alteramos o ponto final da anima√ß√£o em movimento atual. Acontece que cada onda, atingindo a borda da tela, vira e flutua para tr√°s. Mas tamb√©m n√£o chega ao in√≠cio, mas mais cedo ou mais tarde est√° alcan√ßando a posi√ß√£o necess√°ria,e depois come√ßa a se mover da esquerda para a direita novamente.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aj/xp/ky/ajxpkyp6nxn-e6ixzzrv7y-g-c4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ pode resolver esse problema inserindo o modificador .animation (nil). Assim, desativo a anima√ß√£o de todos os modificadores aplicados acima no texto. Essa √© a l√≥gica geral do trabalho de qualquer modificador: ele muda o que est√° em sua entrada e, na entrada, temos o resultado de todos os modificadores anteriores.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De um modo geral, uma hierarquia inteira de diferentes anima√ß√µes funciona aqui. O padr√£o √© aquele que ser√° usado para exibir altera√ß√µes em todos os modificadores, a menos que voc√™ especifique o contr√°rio para sua Visualiza√ß√£o. Temos um segmento de execu√ß√£o (digamos que isso seja principal), dentro do qual o corpo √© chamado. Supomos que ele tenha o par√¢metro .animation, que √© verificado toda vez que um modificador recebe um novo valor. Se o modificador suportar anima√ß√£o (em conformidade com o protocolo AnimatableModifier) ‚Äã‚Äãe a anima√ß√£o estiver ativada para o fluxo (alguma anima√ß√£o espec√≠fica √© usada, n√£o .nenhum ou nulo), a altera√ß√£o ser√° animada. √â isso que fazemos, incluindo algum c√≥digo para alterar </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√¢metros no bloco withAnimation {} - prescrevemos uma certa anima√ß√£o no segmento atual e, em seguida, fazemos algum tipo de altera√ß√£o</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vari√°vel. Nesse caso, comAnimation {}, esse √© um tipo de transa√ß√£o equivalente e todas as altera√ß√µes feitas nessa transa√ß√£o ser√£o animadas. Como resultado, dentro do mesmo fluxo, inicia um ciclo de convers√£o dessas altera√ß√µes em todas as visualiza√ß√µes dependentes, os modificadores dessas visualiza√ß√µes recebem um novo valor e se inscrevem para receber valores intermedi√°rios de AnimatableData. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, existem elementos na anima√ß√£o dos quais voc√™ n√£o pode influenciar. Por exemplo, a posi√ß√£o do controle deslizante √© animada por si s√≥, por mecanismos internos, e n√£o h√° nada a ser feito sobre isso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, withAnimation () √© uma maneira de iniciar a anima√ß√£o padr√£o para a a√ß√£o que est√° sendo executada. Mas, para determinadas Visualiza√ß√µes, voc√™ pode especificar explicitamente sua pr√≥pria anima√ß√£o usando o modificador .animation (). Nesse caso, os modificadores e formul√°rios que comp√µem o conte√∫do passado para .animation () (tudo o que est√° listado no c√≥digo antes de aplicar .animation ()) recebem o tempo que voc√™ descreve e ignora a anima√ß√£o do fluxo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No meu modificador WavePosition, uso .animation (nil) para me livrar da anima√ß√£o offset integrada, instruindo-me a ignorar a anima√ß√£o atual do fluxo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A mesma hist√≥ria com a tampa final. Deixe-me lembr√°-lo das conclus√µes do √∫ltimo artigo. De fato, temos estruturas modificadoras N WavePosition em nossa mem√≥ria, uma para cada onda. E todos eles obt√™m um novo valor de posi√ß√£o do timer do sistema, calculando a posi√ß√£o de cada onda em um determinado momento. Isso significa que tamb√©m temos N terminais para cada onda. S√≥ que apenas um deles √© exibido a qualquer momento, gra√ßas ao bloco if {}. No entanto, o mesmo bloco nos coloca um porco. O desaparecimento e a apar√™ncia da visualiza√ß√£o tamb√©m s√£o realizados com a anima√ß√£o do fluxo. Isso significa que o modificador .transition √© usado para animar a apar√™ncia e o desaparecimento da exibi√ß√£o ap√≥s alterar a condi√ß√£o. Normalmente, o .opacity √© usado por padr√£o, no entanto, por algum motivo, o .slide foi usado para mim. Nenhum deles combina comigo, ent√£o acabei de cancelar esta anima√ß√£o,usando .transition (.identity).</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">upd. </font><font style="vertical-align: inherit;">Enquanto eu preparava o artigo, saiu o Xcode 11.4, no qual, ao que parece, a transi√ß√£o foi reformulada por padr√£o. </font><font style="vertical-align: inherit;">Pelo menos agora comentei .transition (.identity) sem problemas e n√£o recebi o problema que me levou a adicion√°-lo.</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempos de anima√ß√£o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E agora finalmente chegamos √† pergunta mais interessante: como fazer as ondas se moverem aceleradas? </font><font style="vertical-align: inherit;">Como sempre, virei de longe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na verdade, Anima√ß√£o √© uma descri√ß√£o da velocidade de uma determinada anima√ß√£o. Podemos determinar a rota do ponto A ao ponto B dentro do pr√≥prio modificador, mas o SwiftUI decide quando e que tipo de valor AnimatableData deve passar para ele. Ele faz isso com uma curva de tempo. Suponha que tomemos o ponto A como origem e marcemos o ponto B como um ponto com coordenadas (1; 1). Na horizontal, marcaremos o tempo decorrido (o movimento do ponto A ao ponto B leva exatamente 1 unidade de tempo). Vertical - a dist√¢ncia percorrida em fra√ß√µes de uma unidade. Ao usar anima√ß√£o linear, somos diretos. Se queremos que o movimento seja um pouco semelhante ao presente, primeiro precisamos gastar um pouco de tempo na acelera√ß√£o e, no final, na frenagem. Bem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode brincar com op√ß√µes diferentes desenhando sua pr√≥pria curva e comparando sua anima√ß√£o em movimento com as padr√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No SwiftUI, as curvas de Bezier s√£o usadas para v√°rios tipos de anima√ß√£o. </font><font style="vertical-align: inherit;">De qualquer forma, deve come√ßar em (0; 0) e terminar em (1; 1). </font><font style="vertical-align: inherit;">A curvatura da linha √© determinada pelos pontos de controle.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curva de temporiza√ß√£o aninhada dentro da anima√ß√£o sem fim linear</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, o que precisamos fazer para alcan√ßar o movimento acelerado de cada onda (facilidadeIn) dentro de uma anima√ß√£o linear em loop? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A op√ß√£o mais detalhada que eu pude encontrar foi implementar minha pr√≥pria curva de tempo e converter com sua ajuda o fluxo linear de tempo em uma esp√©cie de .easeIn. </font><font style="vertical-align: inherit;">Com este exemplo, voc√™ pode entender muito bem como isso funciona.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A ideia √© simples. Criaremos nossa pr√≥pria classe, com base no caminho - a curva de Bezier com a qual determinaremos a dist√¢ncia do ponto A ao ponto B, que precisa ser mostrada em cada momento espec√≠fico. De fato, √© exatamente assim que a anima√ß√£o funciona no SwiftUI e em qualquer outra estrutura com funcionalidade semelhante. Usando uma curva de tempo, segundos e milissegundos reais (que geralmente fluem, no entanto, linearmente) s√£o convertidos em fra√ß√µes da dist√¢ncia (mais precisamente, fra√ß√µes do segmento animado - o vetor AnimatableData, que representa a altera√ß√£o realizada). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° minha primeira implementa√ß√£o:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getActualPosition</span><span class="hljs-params">(of position: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> correctPosition = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(position, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>) / duration
        <span class="hljs-keyword">let</span> trimmingCurve = <span class="hljs-type">TimingCurve</span>.superEaseInPath
        <span class="hljs-keyword">if</span> correctPosition &lt; <span class="hljs-number">0.0000001</span>{
            <span class="hljs-keyword">let</span> reversedCurve = <span class="hljs-type">Path</span>(<span class="hljs-type">UIBezierPath</span>(cgPath: trimmingCurve.cgPath).reversing().cgPath)
            <span class="hljs-comment">//trim to start point is impossible, so reverce the curve and get last point</span>
            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = reversedCurve.currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve start point"</span>)}
            <span class="hljs-keyword">return</span> point.y<font></font>
        }<font></font>
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = trimmingCurve.trimmedPath(from: <span class="hljs-number">0</span>, to: correctPosition).currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve point at \(position)"</span>)}
        <span class="hljs-keyword">return</span> point.y * <span class="hljs-keyword">self</span>.duration<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aparentemente, eu fui um pouco tolo. Por defini√ß√£o, tenho que encontrar um ponto na curva correspondente ao valor especificado de X e devolv√™-lo a Y. N√£o foi poss√≠vel encontrar algum m√©todo interno padr√£o para resolver esse problema, ou um padr√£o popular, por isso decidi adaptar o m√©todo de apara existente para esses fins ( ) Decidi que poderia muito bem reconsiderar a abordagem e obter o ponto desejado obtendo parte do caminho correspondente √† fra√ß√£o da dist√¢ncia percorrida. Para zero, esse m√©todo retornar√° 0, para 1 retornar√° 1, bem, no meio, provavelmente, tudo tamb√©m estar√° aproximadamente correto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu sabia que essa abordagem n√£o daria um resultado muito preciso, mas a gravidade do problema veio √† tona mais tarde, quando tentei reproduzir exatamente a mesma anima√ß√£o de maneira padr√£o. Fiquei surpreso com a diferen√ßa e decidi verificar no gr√°fico a que dist√¢ncia os pontos obtidos dessa maneira estar√£o da curva original. O resultado n√£o me agradou. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fl/ed/s-/fleds-cdj4f8ellnui32gn-kiyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os pontos n√£o est√£o apenas longe da curva desejada, mas a pr√≥pria natureza da curva est√° distorcida. H√° uma tor√ß√£o extra, da qual eu n√£o preciso. Como resultado, eu ainda tinha que encontrar uma maneira relativamente precisa de encontrar um ponto em uma curva de Bezier, conhecendo apenas uma coordenada:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu tive que armazenar na mem√≥ria muitos segmentos, cujas extremidades est√£o em uma determinada curva. Uma busca por Y por um dado X com essa abordagem √© uma busca pelo segmento correspondente, sua divis√£o ao meio, se necess√°rio, at√© que um dos limites de tal segmento esteja suficientemente pr√≥ximo do ponto desejado. Nesse caso, encontramos o ponto com a coordenada X necess√°ria sobre esse segmento e o retornamos Y. Se voc√™ conhece maneiras mais simples de encontrar um ponto em uma curva arbitr√°ria de Bezier, usando uma determinada coordenada, escreva nos coment√°rios. Eu acho que pode ser √∫til para muitos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, os pontos est√£o bem pr√≥ximos do gr√°fico:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/bk/qi/wxbkqitda0fmf516tl1vjarqgoq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fiz um objeto singlton para criar uma curva de tempo para pontos de controle e armazenar em cache a matriz de segmentos com a qual Y √© pesquisado. Portanto, tudo o que preciso para encontrar um ponto espec√≠fico na curva √© encontrar o segmento dentro do qual esse ponto se encontra, dividi-lo em duas partes at√© que uma das extremidades do segmento esteja pr√≥xima o suficiente desse ponto para cair em um determinado erro e, em seguida, interpole linearmente o valor de Y sobre o X fornecido, substituindo parte da curva por esse segmento. N√£o afirmo que seja o melhor caminho e que funcione em todos os casos. Novamente, escreva nos coment√°rios, se souber maneiras melhores.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com a ajuda dessa ferramenta, a transforma√ß√£o da anima√ß√£o linear em n√£o linear se torna simples. </font><font style="vertical-align: inherit;">Tudo o que √© necess√°rio √© descrever a curva por dois pontos de controle e recalcular a posi√ß√£o no segmento de acordo com essa curva. </font><font style="vertical-align: inherit;">Se for necess√°ria anima√ß√£o de v√°rias dura√ß√µes, ainda usaremos uma curva unit√°ria usando o coeficiente apropriado para a coordenada X.</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.timing = <span class="hljs-type">TimingCurve</span>.superEaseIn(duration: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> animatedPosition = timing.getY(onX: currentPosition)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â assim que a anima√ß√£o √©, junto com a nossa curva de tempo: para </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vf/f0/fe/vff0fe07bgvlvqhhuok5vy_w8ga.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
obter o c√≥digo completo, bem-vindo ao </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , assista ao arquivo TimingCurveView. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tendo entendido este exemplo, voc√™ entender√° 100% como os tempos de anima√ß√£o s√£o organizados. </font><font style="vertical-align: inherit;">A prop√≥sito, voc√™ pode usar esse conhecimento, porque o SwiftUI permite criar sua pr√≥pria curva de tempo para pontos de controle usando a fun√ß√£o timingCurve () e us√°-la como qualquer outra anima√ß√£o.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transi√ß√£o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, temos uma anima√ß√£o intermin√°vel toler√°vel. Resta apenas descobrir como deve ligar e desligar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A id√©ia de animar a apar√™ncia √© fazer com que o bloco de anima√ß√£o apare√ßa no local j√° ligado, mas a cortina seria puxada para tr√°s, como uma cortina no teatro. Se sincronizarmos a velocidade da cortina com a velocidade das ondas dentro da anima√ß√£o, e na pr√≥pria cortina fizer um gradiente da cor de fundo para a cor da atual onda incidente, obteremos um efeito visual, como se essa cortina fosse a primeira onda ondulada. Para sincronizar a velocidade do movimento, simplesmente usamos a mesma curva de tempo usada para animar o movimento da onda. Felizmente, agora sabemos como fazer isso.</font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.timingCurve(<span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.y),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.y),<font></font>
                                duration: <span class="hljs-number">1</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animation.timingCurve (x: y :) permite que voc√™ defina seu pr√≥prio tempo de anima√ß√£o com base nos pontos de controle das curvas de Bezier. </font><font style="vertical-align: inherit;">Na sa√≠da, obtemos um objeto de anima√ß√£o completo, como o familiar .linear (duration: 1), que pode ser usado sem restri√ß√µes. </font><font style="vertical-align: inherit;">E, considerando que eu uso exatamente os mesmos pontos de controle para a anima√ß√£o em ondas, a anima√ß√£o ser√° s√≠ncrona.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seria mais conveniente organizar o c√≥digo ...</font></font></b>
                        <div class="spoiler_text">   .<br>
<br>
 ,           ,    ,          ‚Ä¶     ,     ,     .  -  ,        ‚Äî    .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A desativa√ß√£o da anima√ß√£o pode ser feita da mesma maneira, apenas a cortina deve se infiltrar no bloco de anima√ß√£o, fechando-o gradualmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro problema surgiu no momento em que eu precisava obter o estado atual da anima√ß√£o para escolher a cor da cortina. </font><font style="vertical-align: inherit;">Para fazer isso, criei um ObservableObject, que passo dentro do modificador e que mudo dentro do setter AnimatableData. </font><font style="vertical-align: inherit;">√â importante entender aqui que alterar a propriedade @Published 60 vezes por segundo n√£o √© o que voc√™ precisa. </font><font style="vertical-align: inherit;">√â assim que se altera as </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vari√°veis ‚Äã‚Äãdentro de um bloco corporal. </font><font style="vertical-align: inherit;">N√£o precisamos iniciar nada quando o estado da anima√ß√£o muda. </font><font style="vertical-align: inherit;">Mas se precisarmos, podemos descobrir o estado da anima√ß√£o a qualquer momento.</font></font><br>
<br>
<pre><code class="swift hljs">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">if</span> animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.time = newValue
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.time != <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition{
                    <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition = <span class="hljs-keyword">self</span>.time<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)
            <span class="hljs-keyword">if</span> currentPosition &lt; <span class="hljs-number">0.01</span>{<font></font>
                animationHandler.currentWaveBaseColor = wave.baseColor<font></font>
            }<font></font>
        }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por isso, n√£o me inscrevi no SharpRainbowView para acompanhar as altera√ß√µes do AnimationHendler: </font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para ilustrar a opera√ß√£o dessas cortinas, ligarei a exibi√ß√£o do que est√° acontecendo fora da tela comentando .clipped (). Al√©m disso, moverei a cortina um pouco acima da anima√ß√£o, para maior clareza. Agora est√° mais claro, n√£o √©? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/uf/0k/6suf0klfghhgxj95qfnrxd29zpe.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As cortinas tinham que ser curtas para que o caminho percorrido por cada onda e cortina coincidisse (caso contr√°rio, seria uma anima√ß√£o ass√≠ncrona), mas, ao mesmo tempo, ela conseguiu desaparecer completamente da tela. Ao mesmo tempo, a cortina √© organizada como um gradiente de tr√™s cores. Isso √© claramente vis√≠vel na cortina de fechamento. Isso √© por causa das longas caudas que eu tanto gostei no come√ßo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O fato √© que a primeira onda √© o gradiente das √∫ltimas e primeiras cores da matriz transmitida. Nenhum deles pode corresponder √† cor do plano de fundo. Portanto, havia uma necessidade de cortinas em geral. Para fazer a cortina em dois tons, da cor de fundo √† cor de base da primeira onda, o comprimento da cortina me impediu. Simplesmente n√£o se sobrep√µe √† cauda longa da primeira onda, e uma borda de uma cor √© obtida e a cauda de outra. Portanto, eu tive que fazer a cortina em at√© tr√™s cores - primeiro do fundo at√© a cor da √∫ltima onda, e depois da cor da √∫ltima onda para a primeira. Ent√£o a cauda da primeira onda se encaixa bem com a borda da cortina.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pelas mesmas raz√µes, eles fizeram a cortina de fechamento tamb√©m tricolor. Caso contr√°rio, a fronteira n√£o parecia natural. Mas, como resultado, a primeira "onda" (e agora sabemos que essa √© realmente a cortina descrita em Transition.truncate) acabou sendo curta. E, embora se mova completamente de forma s√≠ncrona com a primeira onda, ou seja, acelerada e n√£o linear, sua largura n√£o muda com o tempo, embora a largura das ondas subsequentes aumente visualmente. Isso pode ser derrotado alterando dinamicamente a largura da cortina, mas eu era francamente pregui√ßoso. Vamos considerar isso como uma li√ß√£o de casa para quem deseja mergulhar nesses mecanismos e fumar um c√≥digo (pe√ßo desculpas a essas pessoas com anteced√™ncia, h√° muitos vest√≠gios de meus experimentos que podem confundi-lo).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° um problema. </font><font style="vertical-align: inherit;">Se voc√™ pressionar o bot√£o sem √™xito, a cortina de fechamento mal cobrir√° a pr√≥xima onda. </font><font style="vertical-align: inherit;">N√£o parece muito bom. </font><font style="vertical-align: inherit;">Voc√™ pode resolver o problema introduzindo um pequeno atraso para ocultar a exibi√ß√£o com anima√ß√£o. </font><font style="vertical-align: inherit;">Temos uma maneira de descobrir a posi√ß√£o atual da anima√ß√£o, s√≥ precisamos adiar um pouco o in√≠cio da transi√ß√£o, e a √∫ltima onda sempre ser√° totalmente exibida.</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle animation"</span>).onTapGesture {<font></font>
                withAnimation(){<font></font>
                    <span class="hljs-keyword">var</span> delay: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.isShown{
                        <span class="hljs-keyword">let</span> waveChangeTime: <span class="hljs-type">Double</span> = <span class="hljs-type">Double</span>(<span class="hljs-number">1</span>) /  <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.rainbowColors.<span class="hljs-built_in">count</span>)
                        <span class="hljs-keyword">let</span> currentTime = <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition)
                        <span class="hljs-keyword">let</span> wavesPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(currentTime / waveChangeTime))<font></font>
                        delay =  (wavesPassed + <span class="hljs-number">1</span>) * waveChangeTime - currentTime<font></font>
                        delay = <span class="hljs-built_in">max</span>(delay - <span class="hljs-number">0.05</span>, <span class="hljs-number">0</span>)
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"currentTime: \(currentTime); delay \(delay)"</span>)<font></font>
                    }<font></font>
                    <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + delay) {
                        <span class="hljs-keyword">self</span>.isShown.toggle()<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Claro, voc√™ tamb√©m pode fazer a cortina de largura vari√°vel para criar a ilus√£o de diferentes velocidades da borda entre o fundo e a cortina, e a cortina e a primeira onda, mas agora a primeira onda parece um pouco antinatural, mas j√° estou com pregui√ßa de me preocupar.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transi√ß√£o adora forrar um porco</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, anima√ß√µes de apar√™ncia e desaparecimento s√£o, para mim, uma ferramenta muito interessante. Mas parece que esse conceito √© novo e nem todas as ferramentas normalmente o tratam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, o modificador .rotation3DEffect () inverte com √™xito o View com algumas anima√ß√µes complexas, mas n√£o sabe como inverter a transi√ß√£o. Foi muito decepcionante escrever um c√≥digo conciso, ver como suas ondas se dispersam para longe do centro da tela e depois ver que as cortinas correm da esquerda para a direita na vista esquerda. Eu tive que escrever um monte de clich√™, para que o modificador de transi√ß√£o pudesse funcionar nas duas dire√ß√µes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/3c/fg/pn3cfg8f6zsersnfgdv5_ixrqu8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, o modificador drowingGroup (), com o qual voc√™ pode conectar o Metal para transferir para a GPU uma renderiza√ß√£o do ZStack com um grande n√∫mero de View aninhado, especialmente View com gradientes, n√£o sabe como fazer a transi√ß√£o. </font><font style="vertical-align: inherit;">Ele n√£o entende a anima√ß√£o de apar√™ncia e desaparecimento descrita por voc√™ e a substitui por uma parte dele.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas como ocultamos a barra de status?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muito simples. O SwiftUI possui o modificador .statisBar (hidden :). Aqui est√£o apenas as APIs para controlar a transi√ß√£o da barra de status que o SwiftUI n√£o fornece. Para fazer isso, teremos que tirar proveito dos recursos do UIKit. O arquivo SceneDelegate usa o UIHostingController para transformar o SwiftUI View em um UIKit ViewController. √â nesse est√°gio que √© mais conveniente usar algumas fun√ß√µes globais do UIKit, como trabalhar com a barra de status ou desativar os gestos do sistema associados √† borda da tela (preferidoScreenEdgesDeferringSystemGestures). Voc√™ pode herdar de UIHostingController substituindo os valores de algumas propriedades do sistema e usar esse descendente para passar seu modo de exibi√ß√£o para rootViewController. Infelizmente, apenas um n√∫mero limitado de transi√ß√µes pode aceitar uma barra de status: .fade, .slide e .none. O padr√£o √© fade,e se encaixa melhor aqui, ent√£o vamos deixar como est√£o. Vamos torcer para que essa funcionalidade ainda seja expandida.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para sincronizar a oculta√ß√£o e a apar√™ncia da barra de status com o movimento da onda, criei uma View separada, na qual altero o valor desse par√¢metro com uma pausa:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarHider</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isShown: <span class="hljs-type">Bool</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalIsShown = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">true</span>{
            <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">0.7</span>){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">false</span>{
            <span class="hljs-type">DispatchQueue</span>.main.async(){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-type">Spacer</span>()<font></font>
            .statusBar(hidden: internalIsShown)<font></font>
            .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0.3</span>))<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, um simples Spacer () √© formado aqui, o que eu j√° precisava, mas o modificador statusBar √© enrolado em cima dele. Em geral, √© claro, era il√≥gico a Apple enviar essa funcionalidade para modificadores, como isso n√£o se aplica √† visualiza√ß√£o espec√≠fica que voc√™ est√° modificando, mas aparentemente apenas n√£o descobriu como faz√™-lo melhor. Muito mais interessante √© outro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele usa o mesmo truque sujo que consideramos anteriormente: dentro do corpo, realizo algumas a√ß√µes em tempo de execu√ß√£o, enquanto altero o valor da </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vari√°vel. A l√≥gica como um todo √© a mesma, existe um par√¢metro de estrutura que √© transmitido de fora e uma </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vari√°vel que √© modificada ap√≥s algum tempo, fazendo com que a barra de status desapare√ßa ou apare√ßa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, eu precisava desse hack porque controlar a anima√ß√£o da barra de status √© uma funcionalidade do UIKit que ainda √© pouco desenvolvida no SwiftUI. </font><font style="vertical-align: inherit;">Em teoria, eu parafusaria a anima√ß√£o de in√≠cio atrasado no modificador .statusBar (hidden :), mas isso n√£o funciona. </font><font style="vertical-align: inherit;">A anima√ß√£o da oculta√ß√£o e a apar√™ncia da barra de status s√£o fixas e n√£o podem ser alteradas pelo SwiftUI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, nada me impediu de fazer a mesma altera√ß√£o de forma ass√≠ncrona com o atraso desejado, n√£o dentro desta Vista, mas no pai, mesmo quando o usu√°rio clicou no bot√£o - mas vamos deixar isso como um monumento √†s minhas tentativas de descobrir o que √© (e mais um motivo para dizer que isso n√£o deve ser feito).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E como o tamanho e a posi√ß√£o da barra de status foram inseridos no @Environment?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O @Environment (que n√£o deve ser confundido com @EnvironmentObject) √© um inv√≥lucro que d√° acesso a uma lista fixa de vari√°veis ‚Äã‚Äãque refletem o ambiente de nosso aplicativo. Por exemplo, orienta√ß√£o da tela ou tema de cores do SO. O mesmo wrapper permite que sua visualiza√ß√£o seja assinada para alterar esses par√¢metros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta lista pode ser expandida. Imaginei que ter o @Environment tivesse acesso ao tamanho e posi√ß√£o da barra de status seria o correto. Aqui est√° como eu fiz isso:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarFrame</span>: <span class="hljs-title">EnvironmentKey</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> defaultValue: <span class="hljs-type">CGRect</span> {
        <span class="hljs-type">CGRect</span>()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">EnvironmentValues</span> </span>{
    <span class="hljs-keyword">var</span> statusBarFrame: <span class="hljs-type">CGRect</span>{
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>]<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>] = newValue<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu criei uma estrutura com um valor padr√£o est√°tico. </font><font style="vertical-align: inherit;">Em seguida, expandi a estrutura do sistema SystemValues ‚Äã‚Äãadicionando minha pr√≥pria propriedade computada, cujo getter e setter se referem ao tipo que criei. </font><font style="vertical-align: inherit;">O tipo √© usado aqui, porque EnvironmentValues ‚Äã‚Äãimplementa um subscrito no qual voc√™ passa o tipo e obt√©m o valor armazenado correspondente a esse tipo. </font><font style="vertical-align: inherit;">N√£o √© o valor desse tipo, mas o valor armazenado no dicion√°rio condicional, em que o pr√≥prio tipo √© a chave. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O valor em @Environment √© acessado usando keyPath \ .statusBarFrame. </font><font style="vertical-align: inherit;">Por exemplo, para passar o valor do ambiente para todos, veja abaixo na hierarquia:</font></font><br>
<br>
<pre><code class="swift hljs">.environment(\.statusBarFrame, statusBarFrame) 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E na pr√≥pria exibi√ß√£o para recuperar o valor da loja:</font></font><br>
<br>
<pre><code class="swift hljs">@<span class="hljs-type">Environment</span>(\.statusBarFrame) <span class="hljs-keyword">var</span> statusBarframe: <span class="hljs-type">CGRect</span> 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A prop√≥sito, para trabalhar com a barra de status no objeto UIWindowScene no IOS 13, o atributo statusBarManager apareceu. </font><font style="vertical-align: inherit;">Alguns par√¢metros podem ser extra√≠dos dele. </font><font style="vertical-align: inherit;">Mas agora voc√™ n√£o pode gerenci√°-los. </font><font style="vertical-align: inherit;">Pelo que entendi, anteriormente era poss√≠vel acessar a barra de status do ViewController e adicionar um subView a ele. </font><font style="vertical-align: inherit;">Aparentemente, eles fecharam o banco. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De um modo geral, eu transferiria a funcionalidade do modificador .statusBar (hidden :) exatamente aqui, aqui seria mais apropriado quanto a mim. </font><font style="vertical-align: inherit;">Acho que mais cedo ou mais tarde, os desenvolvedores chegar√£o a esse ponto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclus√£o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, acho que neste exemplo fascinante, uma excurs√£o √† Anima√ß√£o usando as ferramentas SwiftUI pode ser considerada completa. Usando exemplos simples, falei sobre as principais ferramentas de anima√ß√£o, contei exatamente como elas funcionam sob o cap√¥, como devem ser usadas e por que exatamente. Usando exemplos mais complexos, mostrei dificuldades t√≠picas que voc√™ pode encontrar e maneiras de super√°-las.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meu c√≥digo, em compara√ß√£o com o exemplo do artigo acima, era mais limpo, mais claro, mais curto ou talvez fosse mais f√°cil de manter? Talvez n√£o. Consome menos recursos? Infelizmente, n√£o. Talvez minha abordagem seja mais universal, mas isso n√£o √© preciso. No entanto, h√° uma tarefa que ele definitivamente executa melhor. Isso ilustra muito mais profundamente a opera√ß√£o do SwiftUI sob o cap√¥. Com ele, voc√™ pode colocar a anima√ß√£o nas prateleiras da sua cabe√ßa e aplic√°-la livremente em seus aplicativos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUI est√° sendo ativamente serrado. </font><font style="vertical-align: inherit;">Mesmo agora, duas semanas depois de escrever o c√≥digo do primeiro artigo, agora, verificando o c√≥digo na vers√£o atual do Xcode, vejo como alguns bugs que eu tive que contornar j√° foram corrigidos. </font><font style="vertical-align: inherit;">Portanto, fiquei um pouco com o artigo. </font><font style="vertical-align: inherit;">Algo tinha que ser cortado por irrelev√¢ncia, e tudo mais - para checar. </font><font style="vertical-align: inherit;">E isso agrada. </font><font style="vertical-align: inherit;">O SwiftUI √© definitivamente o futuro do desenvolvimento nativo do iOS, e √© muito informativo para manter sua origem e observar como ele se desenvolve.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posf√°cio</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No processo de prepara√ß√£o dos materiais para este artigo, tamb√©m coloquei muitas coisas na minha cabe√ßa. </font><font style="vertical-align: inherit;">Eu descobri muitas nuances das quais eu n√£o fazia ideia quando comecei a escrever. </font><font style="vertical-align: inherit;">Portanto, pe√ßo a todos que j√° t√™m experi√™ncia no desenvolvimento do SwiftUI - n√£o seja t√≠mido, compartilhe sua experi√™ncia e conhecimento. </font><font style="vertical-align: inherit;">Isso √© muito √∫til tanto para a comunidade quanto para a integridade de seu pr√≥prio conhecimento. </font><font style="vertical-align: inherit;">Isso √© mais legal que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o m√©todo de patinho</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e tamb√©m √© necess√°rio formular a resposta. </font><font style="vertical-align: inherit;">O principal √© n√£o ter pregui√ßa de procurar essa resposta, para que n√£o seja constrangedor para os </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meninos mostrarem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt506644/index.html">Novos desafios para os gerentes no trabalho remoto. Parte 2</a></li>
<li><a href="../pt506648/index.html">Laravel Digest (8 a 14 de junho de 2020)</a></li>
<li><a href="../pt506662/index.html">Parti√ß√£o adaptativa das curvas de Bezier de 2¬™ e 3¬™ ordem</a></li>
<li><a href="../pt506664/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 419 (8-14 de junho de 2020)</a></li>
<li><a href="../pt506666/index.html">Texturas ORM, mas vale a pena?</a></li>
<li><a href="../pt506676/index.html">Catar: centro mundial de transplantes e cidade noturna</a></li>
<li><a href="../pt506680/index.html">.NET Core vs Node.js. Argumentos e fatos</a></li>
<li><a href="../pt506684/index.html">Como eu transferi o dedic.ru para as p√°ginas do github e fiquei satisfeito</a></li>
<li><a href="../pt506686/index.html">Eventos digitais em Moscou de 15 a 21 de junho</a></li>
<li><a href="../pt506688/index.html">Eventos digitais em S√£o Petersburgo, de 15 a 21 de junho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>