<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👩🏻 👇🏼 🕴️ Programmieren eines Spiels für ein eingebettetes Gerät auf ESP32 👉🏼 ♀️ 👉🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teil 0: Motivation
 Einführung
 Ich suchte nach einem Hobbyprojekt, an dem ich außerhalb meiner Hauptaufgaben arbeiten konnte, um der Situation in der...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programmieren eines Spiels für ein eingebettetes Gerät auf ESP32</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502528/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 0: Motivation</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich suchte nach einem Hobbyprojekt, an dem ich außerhalb meiner Hauptaufgaben arbeiten konnte, um der Situation in der Welt zu entkommen. </font><font style="vertical-align: inherit;">Ich interessiere mich hauptsächlich für Spieleprogrammierung, aber ich mag auch eingebettete Systeme. </font><font style="vertical-align: inherit;">Jetzt arbeite ich in einer Spielefirma, aber vorher beschäftigte ich mich hauptsächlich mit Mikrocontrollern. </font><font style="vertical-align: inherit;">Obwohl ich mich am Ende entschlossen habe, meinen Weg zu ändern und in die Spielebranche einzusteigen, experimentiere ich immer noch gerne mit ihnen. </font><font style="vertical-align: inherit;">Warum also nicht beide Hobbys kombinieren?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid gehen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hatte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid Go herumliegen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was interessant wäre, damit zu spielen. </font><font style="vertical-align: inherit;">Sein Kern ist ESP32 - ein sehr beliebter Mikrocontroller mit Standard-MK-Funktionalität (SPI, I2C, GPIO, Timer usw.), aber auch mit WiFi und Bluetooth, was ihn für die Erstellung von IoT-Geräten attraktiv macht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go ergänzt das ESP32 mit einer Reihe von Peripheriegeräten und verwandelt es in einen tragbaren Spielautomaten, der Gameboy Color ähnelt: ein LCD-Display, einen Lautsprecher, ein Steuerkreuz, zwei Haupt- und vier Hilfstasten, einen Akku und einen SD-Kartenleser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meistens kaufen Leute Odroid Go, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um Emulatoren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alter 8-Bit-Systeme </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">auszuführen</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn dieses Ding in der Lage ist, alte Spiele zu emulieren, wird es auch mit dem Start eines nativen Spiels fertig, das speziell für dieses Spiel entwickelt wurde.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/800/42e/44b80042e94aa2f2da9da2d2296461ad.jpg"></div><a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einschränkungen</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auflösung 320 x 240 Das</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Display hat eine Größe von nur 320 x 240, sodass die Menge der Informationen, die gleichzeitig auf dem Bildschirm angezeigt werden, sehr begrenzt ist. Wir müssen sorgfältig überlegen, welches Spiel wir machen und welche Ressourcen wir verwenden sollen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16-Bit-Farbe Das</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Display unterstützt 16-Bit-Farben pro Pixel: 5 Bit für Rot, 6 Bit für Grün und 5 Bit für Blau. Aus offensichtlichen Gründen wird eine solche Schaltung normalerweise als RGB565 bezeichnet. Grün hat ein bisschen mehr Rot und Blau, weil das menschliche Auge besser zwischen Abstufungen von Grün als Blau oder Rot unterscheidet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16-Bit-Farbe bedeutet, dass wir nur auf 65.000 Farben zugreifen können. Vergleichen Sie dies mit der Standardfarbe 24-Bit (8 Bit pro Farbe), die 16 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Millionen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Farben </font><font style="vertical-align: inherit;">liefert </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehlende GPU</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ohne eine GPU können wir keine API wie OpenGL verwenden. Heutzutage werden für das Rendern von 2D-Spielen normalerweise dieselben GPUs verwendet wie für 3D-Spiele. Anstelle von Objekten werden Vierecke gezeichnet, denen Bittexturen überlagert werden. Ohne GPU müssen wir jedes Pixel mit einer CPU rasteren, die langsamer, aber einfacher ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einer Bildschirmauflösung von 320 x 240 und 16-Bit-Farben beträgt die Gesamtgröße des Bildpuffers 153.600 Byte. Dies bedeutet, dass wir mindestens dreißig Mal pro Sekunde 153.600 Bytes an das Display senden müssen. Dies kann letztendlich zu Problemen führen, daher müssen wir beim Rendern des Bildschirms intelligenter sein. Sie können beispielsweise eine indizierte Farbe in eine Palette konvertieren, sodass Sie für jedes Pixel ein Byte speichern müssen, das als Index für eine 256-Farben-Palette verwendet wird.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 MB</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ESP32 verfügt über 520 KB internen RAM, während Odroid Go weitere 4 MB externen RAM hinzufügt. Dieser gesamte Speicher steht uns jedoch nicht zur Verfügung, da ein Teil vom ESP32-SDK verwendet wird (dazu später mehr). Nach dem Deaktivieren aller möglichen Fremdfunktionen und dem Eingeben meiner Hauptfunktion meldet ESP32, dass wir 4.494.848 Bytes verwenden können. Wenn wir in Zukunft mehr Speicher benötigen, können wir später wieder unnötige Funktionen kürzen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">80-240 MHz Prozessor</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die CPU ist mit drei möglichen Geschwindigkeiten konfiguriert: 80 MHz, 160 MHz und 240 MHz. Selbst ein Maximum von 240 MHz ist weit entfernt von der Leistung von mehr als drei Gigahertz moderner Computer, mit denen wir gewohnt sind zu arbeiten. Wir werden bei 80 MHz beginnen und sehen, wie weit wir gehen können. Wenn das Spiel mit Batteriestrom betrieben werden soll, sollte der Stromverbrauch niedrig sein. Dazu wäre es schön, die Frequenz zu senken. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlechtes Debuggen</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt Möglichkeiten, Debugger mit eingebetteten Geräten (JTAG) zu verwenden, aber leider bietet Odroid Go uns nicht die erforderlichen Kontakte, sodass wir den Code im Debugger nicht wie üblich durchgehen können. </font><font style="vertical-align: inherit;">Dies bedeutet, dass das Debuggen ein schwieriger Prozess sein kann, und wir müssen das Debuggen auf dem Bildschirm (unter Verwendung von Farben und Text) aktiv verwenden und auch Informationen an die Debugging-Konsole ausgeben (die glücklicherweise über USB UART leicht zugänglich ist).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum all die Schwierigkeiten?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum sollten Sie überhaupt versuchen, ein Spiel für dieses schwache Gerät mit allen oben aufgeführten Einschränkungen zu erstellen und nichts für einen Desktop-PC zu schreiben? Dafür gibt es zwei Gründe: </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einschränkungen fördern die Kreativität.</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn Sie mit einem System arbeiten, das über bestimmte Geräte verfügt, von denen jedes seine eigenen Einschränkungen hat, überlegen Sie, wie Sie die Vorteile dieser Einschränkungen am besten nutzen können. So kommen wir Spielentwicklern alter Systeme näher, zum Beispiel Super Nintendo (aber es ist für uns immer noch viel einfacher als für sie). </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Low-Level-Entwicklung macht Spaß</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ein Spiel für ein normales Desktop-System von Grund auf neu zu schreiben, müssen wir mit Standard-Low-Level-Engine-Konzepten arbeiten: Rendering, Physik, Kollisionserkennung. </font><font style="vertical-align: inherit;">Wenn wir all dies auf einem eingebetteten Gerät implementieren, müssen wir uns auch mit einfachen Computerkonzepten befassen, beispielsweise dem Schreiben eines LCD-Treibers.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie niedrig wird die Entwicklung sein?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn es um niedrige Ebenen und das Erstellen eines eigenen Codes geht, müssen Sie irgendwo einen Rahmen zeichnen. Wenn wir versuchen, ein Spiel ohne Bibliotheken für den Desktop zu schreiben, ist der Rand wahrscheinlich ein Betriebssystem oder eine plattformübergreifende API wie SDL. In meinem Projekt werde ich eine Grenze zum Schreiben von Dingen wie SPI-Treibern und Bootloadern ziehen. Mit ihnen viel mehr Qual als Spaß. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden also das ESP-IDF verwenden, das im Wesentlichen ein SDK für ESP32 ist. Wir können davon ausgehen, dass es uns einige Dienstprogramme zur Verfügung stellt, die das Betriebssystem normalerweise bereitstellt, aber das </font><font style="vertical-align: inherit;">Betriebssystem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktioniert nicht</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in ESP32 </font><font style="vertical-align: inherit;">. Genau genommen verwendet dieser MK FreeRTOS, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Echtzeitbetriebssystem</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist jedoch kein echtes Betriebssystem. </font><font style="vertical-align: inherit;">Dies ist nur ein Planer. </font><font style="vertical-align: inherit;">Höchstwahrscheinlich werden wir nicht damit interagieren, aber in seinem Kern verwendet ESP-IDF es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP-IDF bietet uns eine API für ESP32-Peripheriegeräte wie SPI, I2C und UART sowie eine C-Laufzeitbibliothek. Wenn wir also so etwas wie printf aufrufen, werden tatsächlich Bytes über UART übertragen, die auf dem seriellen Schnittstellenmonitor angezeigt werden. </font><font style="vertical-align: inherit;">Es verarbeitet auch den gesamten Startcode, der zur Vorbereitung der Maschine erforderlich ist, bevor der Startpunkt unseres Spiels aufgerufen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beitrag werde ich ein Entwicklungsmagazin führen, in dem ich über interessante Punkte spreche, die mir erschienen, und die schwierigsten Aspekte erläutere. </font><font style="vertical-align: inherit;">Ich habe keinen Plan und werde höchstwahrscheinlich viele Fehler machen. </font><font style="vertical-align: inherit;">All das erschaffe ich aus Interesse.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1: System erstellen</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir mit dem Schreiben von Code für Odroid Go beginnen können, müssen wir das ESP32-SDK konfigurieren. </font><font style="vertical-align: inherit;">Es enthält den Code, der ESP32 startet und unsere Hauptfunktion aufruft, sowie den Peripheriecode (z. B. SPI), den wir beim Schreiben des LCD-Treibers benötigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espressif nennt sein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SDK </font><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">Wir verwenden die neueste stabile Version </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v4.0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können das Repository entweder gemäß den Anweisungen (mit dem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rekursiven</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flag </font><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">klonen </font><font style="vertical-align: inherit;">oder einfach die Zip-Datei von der Release-Seite herunterladen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser erstes Ziel ist eine minimale Anwendung im Hello World-Stil, die auf Odroid Go installiert ist und die korrekte Einrichtung der Build-Umgebung beweist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C oder C ++</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP-IDF verwendet C99, daher werden wir es auch auswählen. </font><font style="vertical-align: inherit;">Falls gewünscht, könnten wir C ++ verwenden (es gibt einen C ++ - Compiler in der ESP32-Toolchain), aber im Moment bleiben wir bei C. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eigentlich mag ich C und seine Einfachheit. </font><font style="vertical-align: inherit;">Egal wie viel ich Code in C ++ schreibe, ich habe es nie geschafft, den Moment zu erreichen, in dem ich ihn genieße. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Person fasst meine Gedanken ziemlich gut zusammen. </font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus können wir bei Bedarf jederzeit zu C ++ wechseln.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimales Projekt</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDF verwendet CMake, um das Build-System zu verwalten. Es unterstützt auch Makefile, aber sie sind in Version 4.0 veraltet, daher verwenden wir nur CMake. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zumindest müssen wir eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datei </font><font style="vertical-align: inherit;">mit einer Beschreibung unseres Projektes, einem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauptordner</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der Quelldatei des Eintrittspunkt in das Spiel, und eine </font><font style="vertical-align: inherit;">andere </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datei </font><font style="vertical-align: inherit;">innerhalb </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haupt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die die Quelldateien auflistet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CMake muss auf Umgebungsvariablen verweisen, die angeben, wo nach IDF und Toolchain gesucht werden soll. Ich war verärgert, dass ich sie jedes Mal neu installieren musste, wenn ich eine neue Terminalsitzung startete, also schrieb ich das Skript </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">export.sh</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es setzt </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDF_PATH</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDF_TOOLS_PATH</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ist auch eine IDF-Exportquelle, die andere Umgebungsvariablen festlegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es reicht aus, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn der </font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skriptbenutzer die Variablen </font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">IDF_PATH</font></strong><font style="vertical-align: inherit;"> und </font><strong><font style="vertical-align: inherit;">IDF_TOOLS_PATH festlegt</font></strong><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="powershell hljs">IDF_PATH=<font></font>
IDF_TOOLS_PATH=<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">if</span> [ -<span class="hljs-type">z</span> <span class="hljs-string">"<span class="hljs-variable">$IDF_PATH</span>"</span> ]<font></font>
then<font></font>
	<span class="hljs-built_in">echo</span> <span class="hljs-string">"IDF_PATH not set"</span>
	<span class="hljs-keyword">return</span><font></font>
fi<font></font>
<font></font>
<span class="hljs-keyword">if</span> [ -<span class="hljs-type">z</span> <span class="hljs-string">"<span class="hljs-variable">$IDF_TOOLS_PATH</span>"</span> ]<font></font>
then<font></font>
	<span class="hljs-built_in">echo</span> <span class="hljs-string">"IDF_TOOLS_PATH not set"</span>
	<span class="hljs-keyword">return</span><font></font>
fi<font></font>
<font></font>
<font></font>
export IDF_PATH<font></font>
export IDF_TOOLS_PATH<font></font>
<font></font>
source <span class="hljs-variable">$IDF_PATH</span>/export.sh</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Stammverzeichnis:</font></font><br>
<br>
<pre><code class="cmake hljs"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<font></font>
<font></font>
<span class="hljs-keyword">set</span>(COMPONENTS <span class="hljs-string">"esptool_py main"</span>)<font></font>
<font></font>
<span class="hljs-keyword">include</span>($ENV{IDF_PATH}/tools/cmake/<span class="hljs-keyword">project</span>.cmake)<font></font>
<font></font>
<span class="hljs-keyword">project</span>(game)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standardmäßig erstellt das Build-System jede mögliche Komponente in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ ESP_IDF / components</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was zu einer </font><strong><font style="vertical-align: inherit;">längeren</font></strong><font style="vertical-align: inherit;"> Kompilierungszeit führt. </font><font style="vertical-align: inherit;">Wir möchten einen minimalen Satz von Komponenten kompilieren, um unsere Hauptfunktion aufzurufen, und später bei Bedarf weitere Komponenten verbinden. </font><font style="vertical-align: inherit;">Dafür ist die Variable </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COMPONENTS gedacht</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cmake hljs">idf_component_register(<font></font>
	SRCS <span class="hljs-string">"main.c"</span>
    INCLUDE_DIRS <span class="hljs-string">""</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles, was er tut - unendlich einmal pro Sekunde zeigt auf dem Monitor die serielle Schnittstelle "Hello World" an. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VTaskDelay</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet FreeRTOS </font><font style="vertical-align: inherit;">zum Verzögern </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datei </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist </font><font style="vertical-align: inherit;">sehr einfach:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;freertos/FreeRTOS.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;freertos/task.h&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">for</span> (;;)<font></font>
	{<font></font>
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World!\n"</span>);<font></font>
		vTaskDelay(<span class="hljs-number">1000</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Should never get here</span><font></font>
	esp_restart();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass unsere Funktion </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">app_main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> heißt </font><font style="vertical-align: inherit;">, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht </font></font></em> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauptfunktion</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durch die IDF für die notwendige Vorbereitung verwendet, und dann erzeugt es eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgabe</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit unserer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">app_main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">als Einstiegspunkt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Aufgabe ist nur ein ausführbarer Block, den FreeRTOS verwalten kann. Obwohl wir uns darüber keine Gedanken machen sollten (oder vielleicht gar nicht), ist es wichtig zu beachten, dass unser Spiel in einem Kern läuft (ESP32 hat zwei Kerne) und mit jeder Iteration der for-Schleife die Ausführung der Task um eine Sekunde verzögert. Während dieser Verzögerung kann der FreeRTOS-Scheduler anderen Code ausführen, der in der Schlange auf die Ausführung wartet (falls vorhanden).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können beide Kerne verwenden, aber jetzt beschränken wir uns auf einen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponenten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst wenn wir die Liste der Komponenten auf das für die Hello World-Anwendung erforderliche Minimum reduzieren ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esptool_py</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), werden aufgrund der Konfiguration der Abhängigkeitskette einige andere Komponenten erfasst, die wir nicht benötigen. </font><font style="vertical-align: inherit;">Es sammelt alle diese Komponenten:</font></font><br>
<br>
<pre><code class="cmake hljs">app_trace app_update bootloader bootloader_support cxx driver efuse esp32 esp_common esp_eth esp_event esp_ringbuf<font></font>
esp_rom esp_wifi espcoredump esptool_py freertos heap log lwip main mbedtls newlib nvs_flash partition_table pthread<font></font>
soc spi_flash tcpip_adapter vfs wpa_supplicant xtensa</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele von ihnen sind ziemlich logisch ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bootloader</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp32</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freertos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), aber es folgen unnötige Komponenten, da wir keine Netzwerkfunktionen verwenden: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_eth, esp_wifi, lwip, mbedtls, tcpip_adapter, wpa_supplicant</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Leider sind wir immer noch gezwungen, diese Komponenten zusammenzubauen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Glücklicherweise ist der Linker intelligent genug und fügt nicht verwendete Komponenten nicht in eine vorgefertigte Binärdatei des Spiels ein. </font><font style="vertical-align: inherit;">Wir können dies mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponenten der Größengröße</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> überprüfen </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code><pre>Total sizes:
 DRAM .data size:    8476 bytes
 DRAM .bss  size:    4144 bytes
Used static DRAM:   12620 bytes ( 168116 available, 7.0% used)
Used static IRAM:   56345 bytes (  74727 available, 43.0% used)
      Flash code:   95710 bytes
    Flash rodata:   40732 bytes
Total image size:~ 201263 bytes (.bin may be padded larger)
Per-archive contributions to ELF file:
            Archive File DRAM .data &amp; .bss   IRAM Flash code &amp; rodata   Total
                  libc.a        364      8   5975      63037     3833   73217
              libesp32.a       2110    151  15236      15415    21485   54397
           libfreertos.a       4148    776  14269          0     1972   21165
                libsoc.a        184      4   7909        875     4144   13116
          libspi_flash.a        714    294   5069       1320     1386    8783
                libvfs.a        308     48      0       5860      973    7189
         libesp_common.a         16   2240    521       1199     3060    7036
             libdriver.a         87     32      0       4335     2200    6654
               libheap.a        317      8   3150       1218      748    5441
             libnewlib.a        152    272    869        908       99    2300
        libesp_ringbuf.a          0      0    906          0      163    1069
                liblog.a          8    268    488         98        0     862
         libapp_update.a          0      4    127        159      486     776
 libbootloader_support.a          0      0      0        634        0     634
                libhal.a          0      0    519          0       32     551
            libpthread.a          8     12      0        288        0     308
             libxtensa.a          0      0    220          0        0     220
                libgcc.a          0      0      0          0      160     160
               libmain.a          0      0      0         22       13      35
                libcxx.a          0      0      0         11        0      11
                   (exe)          0      0      0          0        0       0
              libefuse.a          0      0      0          0        0       0
         libmbedcrypto.a          0      0      0          0        0       0
     libwpa_supplicant.a          0      0      0          0        0       0</pre></code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor allem beeinflusst libc die Größe der Binärdatei, und das ist in Ordnung.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projektkonfiguration</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit IDF können Sie Konfigurationsparameter zur Kompilierungszeit angeben, die während der Montage zum Aktivieren oder Deaktivieren verschiedener Funktionen verwendet werden. </font><font style="vertical-align: inherit;">Wir müssen Parameter festlegen, die es uns ermöglichen, die zusätzlichen Aspekte von Odroid Go zu nutzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst müssen Sie das Quellenskript von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">export.sh ausführen,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> damit CMake auf die erforderlichen Umgebungsvariablen zugreifen kann. </font><font style="vertical-align: inherit;">Wie bei allen CMake-Projekten müssen wir außerdem einen Assembly-Ordner erstellen und CMake von dort aus aufrufen.</font></font><br>
<br>
<pre><code class="cmake hljs">source <span class="hljs-keyword">export</span>.sh<font></font>
mkdir build<font></font>
cd build<font></font>
cmake ..</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make menuconfig ausführen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wird ein Fenster geöffnet, in dem Sie die Projekteinstellungen konfigurieren können.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweiterung des Flash-Speichers auf 16 MB</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go erweitert die Standardkapazität des Flash-Laufwerks auf 16 MB. </font><font style="vertical-align: inherit;">Sie können diese Funktion aktivieren, indem Sie zu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serial Flasher Config -&gt; Flash Size -&gt; 16MB gehen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schalten Sie den externen SPI-RAM ein</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben auch Zugriff auf weitere 4 MB externen RAM, der über SPI verbunden ist. </font><font style="vertical-align: inherit;">Sie können es aktivieren, indem Sie zu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponentenkonfiguration -&gt; ESP32-spezifisch -&gt; Unterstützung für externen, mit SPI verbundenen RAM gehen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die Leertaste drücken, um es zu aktivieren. </font><font style="vertical-align: inherit;">Wir möchten auch in der Lage sein, Speicher aus dem SPI-RAM explizit zuzuweisen. </font><font style="vertical-align: inherit;">Dies kann aktiviert werden, indem Sie zu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI RAM config -&gt; SPI RAM-Zugriffsmethode -&gt; RAM mit heap_caps_malloc zuweisbar machen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verringern Sie die Frequenz</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32 funktioniert standardmäßig mit einer Frequenz von 160 MHz. Verringern Sie die Frequenz jedoch auf 80 MHz, um zu sehen, wie weit Sie mit der niedrigsten Taktfrequenz gehen können. Wir möchten, dass das Spiel mit Batteriestrom arbeitet, und durch Verringern der Frequenz wird Strom gespart. Sie können dies ändern, indem Sie zu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponentenkonfiguration -&gt; ESP32-spezifisch -&gt; CPU-Frequenz -&gt; 80 MHz gehen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auswählen </font><font style="vertical-align: inherit;">, wird die Datei </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdkconfig</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Stammverzeichnis des Projektordners gespeichert </font><font style="vertical-align: inherit;">. Wir können diese Datei in git schreiben, aber sie enthält viele Parameter, die für uns nicht wichtig sind. Bisher sind wir mit den Standardparametern zufrieden, mit Ausnahme derjenigen, die wir gerade geändert haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können </font><strong><font style="vertical-align: inherit;">stattdessen</font></strong><font style="vertical-align: inherit;"> die Datei </font><strong><font style="vertical-align: inherit;">sdkconfig.defaults</font></strong><font style="vertical-align: inherit;"> erstellen</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">welches die oben geänderten Werte enthält. </font><font style="vertical-align: inherit;">Alles andere wird standardmäßig konfiguriert. </font><font style="vertical-align: inherit;">Während des </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Builds</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> liest die IDF </font><strong><font style="vertical-align: inherit;">sdkconfig.defaults</font></strong><font style="vertical-align: inherit;"> , überschreibt die von uns festgelegten Werte und verwendet den Standard für alle anderen Parameter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt </font><font style="vertical-align: inherit;">sieht </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdkconfig.defaults folgendermaßen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus:</font></font><br>
<br>
<pre><code class="cpp hljs"># Set flash size to <span class="hljs-number">16</span>MB<font></font>
CONFIG_ESPTOOLPY_FLASHSIZE_16MB=y<font></font>
<font></font>
# Set CPU frequency to <span class="hljs-number">80</span>MHz<font></font>
CONFIG_ESP32_DEFAULT_CPU_FREQ_80=y<font></font>
<font></font>
# Enable SPI RAM <span class="hljs-keyword">and</span> allocate with heap_caps_malloc()<font></font>
CONFIG_ESP32_SPIRAM_SUPPORT=y<font></font>
CONFIG_SPIRAM_USE_CAPS_ALLOC=y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen sieht die ursprüngliche Struktur des Spiels folgendermaßen aus:</font></font><br>
<br>
<code><pre>game
├── CMakeLists.txt
├── export.sh
├── main
│   ├── CMakeLists.txt
│   └── main.c
└── sdkconfig.defaults</pre></code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bauen und flashen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Montage- und Firmware-Prozess selbst ist recht einfach. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir führen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to compile aus (für paralleles Erstellen fügen Sie </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-j4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-j8 hinzu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">machen Flash</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um das Bild in Odroid Go zu schreiben, und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">machen Monitor</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Ausgabe der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anweisungen anzuzeigen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cmake hljs">make<font></font>
make flash<font></font>
make monitor</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können sie auch in einer Zeile ausführen.</font></font><br>
<br>
<pre><code class="cmake hljs">make flash monitor</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis ist nicht besonders beeindruckend, wird aber zur Grundlage für den Rest des Projekts.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c2/329/62f/3c232962f8e782c9220b25b7e3c0df5e.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF-Dokumentation: Build System</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FreeRTOS-Dokumentation: vTaskDelay</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 2: Eingabe</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir müssen in der Lage sein, die vom Spieler gedrückten Tasten und das Kreuz auf Odroid Go zu lesen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tasten</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/142/ca2/106142ca2250eb9301215015b6f0bbad.png"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPIO</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ODROID Go verfügt über </font><font style="vertical-align: inherit;">sechs Tasten: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Select</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menü</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lautstärke</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede der Tasten ist mit einem separaten </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPIO-Pin (General Purpose IO) verbunden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">GPIO-Pins können als Eingänge (zum Lesen) oder als Ausgänge (wir schreiben darauf) verwendet werden. </font><font style="vertical-align: inherit;">Bei Schaltflächen müssen wir lesen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst müssen Sie die Kontakte als Eingänge konfigurieren, danach können wir ihren Status lesen. </font><font style="vertical-align: inherit;">Die Kontakte im Inneren haben eine von zwei Spannungen (3,3 V oder 0 V), aber wenn sie mit der IDF-Funktion gelesen werden, werden sie in ganzzahlige Werte umgewandelt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elemente, die im Diagramm als </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> markiert </font><font style="vertical-align: inherit;">sind, sind die physischen Tasten selbst. Wenn nicht gedrückt, werden die ESP32-Kontakte ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO13</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usw.) an 3,3 V angeschlossen. d.h. 3,3 V bedeutet, dass die Taste </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht gedrückt wird</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die Logik hier ist das Gegenteil von dem, was erwartet wird. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO39</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> haben physikalische Widerstände auf der Platine. Wenn die Taste nicht gedrückt wird, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zieht der</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Widerstand </font><strong><font style="vertical-align: inherit;">die</font></strong><font style="vertical-align: inherit;"> Kontakte auf eine hohe Spannung. Wenn die Taste gedrückt wird, geht der durch die Kontakte </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fließende</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Strom stattdessen nach Masse, sodass die Spannung 0 von den Kontakten </font><strong><font style="vertical-align: inherit;">abgelesen</font></strong><font style="vertical-align: inherit;"> wird </font><font style="vertical-align: inherit;">. </font><strong><font style="vertical-align: inherit;">IO13</font></strong><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO27</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO32</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO33</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haben keine Widerstände, da der Kontakt am ESP32 interne Widerstände hat, die wir für den Pull-up-Modus konfiguriert haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Wissen können wir sechs Schaltflächen mithilfe der GPIO-API konfigurieren.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_A = GPIO_NUM_32;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_B = GPIO_NUM_33;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_START = GPIO_NUM_39;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_SELECT = GPIO_NUM_27;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_VOLUME = GPIO_NUM_0;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_MENU = GPIO_NUM_13;<font></font>
<font></font>
<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
gpioConfig.mode = GPIO_MODE_INPUT;<font></font>
gpioConfig.pull_up_en = GPIO_PULLUP_ENABLE;<font></font>
gpioConfig.pin_bit_mask =<font></font>
	  (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_A)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_B)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_START)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_SELECT)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_VOLUME)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_MENU);<font></font>
<font></font>
ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die am Anfang des Codes angegebenen Konstanten entsprechen jedem der Schaltungskontakte. Wir verwenden die Struktur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gpio_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">um jede der sechs Schaltflächen als Pull-up-Eingabe zu konfigurieren. Im Fall von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO13</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO27</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO32</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO33 müssen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir IDF bitten, die Pull-up-Widerstände dieser Kontakte </font><strong><font style="vertical-align: inherit;">einzuschalten</font></strong><font style="vertical-align: inherit;"> . Für </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO39 müssen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir dies nicht tun, da sie physikalische Widerstände haben, aber wir werden es trotzdem tun, um die Konfiguration schön zu machen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP_ERROR_CHECK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein </font><strong><font style="vertical-align: inherit;">Hilfsmakro</font></strong><font style="vertical-align: inherit;"> von IDF, das automatisch das Ergebnis aller Funktionen überprüft, die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_err_t zurückgeben</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(die meisten IDF) und behaupten, dass das Ergebnis nicht gleich </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP_OK ist</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dieses Makro ist praktisch für eine Funktion zu verwenden, wenn ihr Fehler kritisch ist und es keinen Sinn macht, die Ausführung fortzusetzen. </font><font style="vertical-align: inherit;">In diesem Spiel ist ein Spiel ohne Eingabe kein Spiel, daher ist diese Aussage wahr. </font><font style="vertical-align: inherit;">Wir werden dieses Makro oft verwenden.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tasten lesen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also haben wir alle Kontakte konfiguriert und können endlich die Werte lesen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zifferntasten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden von der Funktion </font><strong><font style="vertical-align: inherit;">gpio_get_level</font></strong><font style="vertical-align: inherit;"> gelesen </font><font style="vertical-align: inherit;">, aber wir müssen die empfangenen Werte invertieren, da die Kontakte hochgezogen werden, </font><strong><font style="vertical-align: inherit;">dh</font></strong><font style="vertical-align: inherit;"> ein hohes Signal bedeutet tatsächlich "nicht gedrückt" und ein niedriges Signal bedeutet "gedrückt". </font><font style="vertical-align: inherit;">Beim Invertieren bleibt die übliche Logik erhalten: 1 bedeutet "gedrückt", 0 - "nicht gedrückt".</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a = !gpio_get_level(BUTTON_PIN_A);
<span class="hljs-keyword">int</span> b = !gpio_get_level(BUTTON_PIN_B);
<span class="hljs-keyword">int</span> select = !gpio_get_level(BUTTON_PIN_SELECT);
<span class="hljs-keyword">int</span> start = !gpio_get_level(BUTTON_PIN_START);
<span class="hljs-keyword">int</span> menu = !gpio_get_level(BUTTON_PIN_MENU);
<span class="hljs-keyword">int</span> volume = !gpio_get_level(BUTTON_PIN_VOLUME);</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kreuzstück (D-Pad)</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e8/d9e/a73/1e8d9ea7303257afd45846771726a275.png"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADC</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Anschließen des Kreuzes unterscheidet sich vom Anschließen der Tasten. </font><font style="vertical-align: inherit;">Die Auf- und Ab-Tasten sind mit einem Pin eines </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analog-Digital-Wandlers (ADC) verbunden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und die linke und rechte Taste sind </font><font style="vertical-align: inherit;">mit </font><font style="vertical-align: inherit;">einem anderen ADC-Pin verbunden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zu den digitalen GPIO-Kontakten, aus denen wir einen von zwei Zuständen (hoch oder niedrig) lesen konnten, wandelt der ADC die kontinuierliche analoge Spannung (z. B. von 0 V bis 3,3 V) in einen diskreten numerischen Wert (z. B. von 0 bis 4095) um ) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich nehme an, Odroid Go-Designer haben es getan, um GPIO-Pins einzusparen (Sie benötigen nur zwei analoge Pins anstelle von vier digitalen Pins). </font><font style="vertical-align: inherit;">Wie auch immer, dies erschwert die Konfiguration und das Lesen dieser Kontakte geringfügig.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufbau</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Kontakt </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO35 ist</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der Y-Achse der </font><strong><font style="vertical-align: inherit;">Spinne verbunden</font></strong><font style="vertical-align: inherit;"> , und der Kontakt </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO34</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist </font><strong><font style="vertical-align: inherit;">mit</font></strong><font style="vertical-align: inherit;"> der X-Achse der </font><strong><font style="vertical-align: inherit;">Spinne verbunden</font></strong><font style="vertical-align: inherit;"> . Wir sehen, dass die Gelenke des Kreuzes etwas komplizierter sind als die Zifferntasten. Jede Achse verfügt über zwei Schalter ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für die Y-Achse, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für die X-Achse), die jeweils mit einem Satz von Widerständen ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R5</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) verbunden sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn weder "oben" noch "unten" gedrückt wird, wird der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO35-Stift</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> über </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf den Boden gezogen </font><font style="vertical-align: inherit;">, und wir betrachten den Wert 0 V. Wenn weder "links" noch "rechts" gedrückt wird, wenden Sie sich an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO34</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zieht durch </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R5</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf den Boden </font><font style="vertical-align: inherit;">und wir zählen den Wert bis 0 V. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gedrückt wird </font><strong><font style="vertical-align: inherit;">("up")</font></strong><font style="vertical-align: inherit;"> , dann </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zählen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir </font><font style="vertical-align: inherit;">mit </font><strong><font style="vertical-align: inherit;">IO35</font></strong><font style="vertical-align: inherit;"> 3,3 V. Wenn </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gedrückt wird </font><strong><font style="vertical-align: inherit;">("down")</font></strong><font style="vertical-align: inherit;"> , dann </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zählen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir </font><font style="vertical-align: inherit;">mit </font><strong><font style="vertical-align: inherit;">IO35</font></strong><font style="vertical-align: inherit;"> ungefähr 1, 65 V, da die Hälfte der Spannung am Widerstand </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abfällt </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW3 ("links")</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gedrückt wird </font><font style="vertical-align: inherit;">, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zählen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir </font><font style="vertical-align: inherit;">mit </font><strong><font style="vertical-align: inherit;">IO34</font></strong><font style="vertical-align: inherit;"> 3,3 V. Wenn </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW4 ("rechts")</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gedrückt wird </font><font style="vertical-align: inherit;">, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zählen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir </font><font style="vertical-align: inherit;">mit </font><strong><font style="vertical-align: inherit;">IO34</font></strong><font style="vertical-align: inherit;"> auch ungefähr 1,65 V, da die Hälfte der Spannung am Widerstand </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abfällt </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beide Fälle sind Beispiele für </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spannungsteiler.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn zwei Widerstände im Spannungsteiler den gleichen Widerstand haben (in unserem Fall - 100K), beträgt der Spannungsabfall die Hälfte der Eingangsspannung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir das wissen, können wir das Kreuzstück konfigurieren:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> DPAD_PIN_X_AXIS = ADC1_GPIO34_CHANNEL;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> DPAD_PIN_Y_AXIS = ADC1_GPIO35_CHANNEL;<font></font>
<font></font>
ESP_ERROR_CHECK(adc1_config_width(ADC_WIDTH_BIT_12));<font></font>
ESP_ERROR_CHECK(adc1_config_channel_atten(DPAD_PIN_X_AXIS,ADC_ATTEN_DB_11));<font></font>
ESP_ERROR_CHECK(adc1_config_channel_atten(DPAD_PIN_Y_AXIS,ADC_ATTEN_DB_11));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den ADC auf 12 Bit Breite eingestellt, so dass 0 V als 0 und 3,3 V als 4095 (2 ^ 12) gelesen wurden. </font><font style="vertical-align: inherit;">Die Dämpfung meldet, dass wir das Signal nicht dämpfen müssen, damit wir den vollen Spannungsbereich von 0 V bis 3,3 V erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei 12 Bit können wir erwarten, dass, wenn nichts gedrückt wird, 0 gelesen wird, wenn nach oben und links gedrückt wird - 4096 und Ungefähr 2048 werden gelesen, wenn nach unten und rechts gedrückt wird (weil Widerstände die Spannung um die Hälfte reduzieren).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kreuzlesen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Kreuz zu lesen ist schwieriger als Schaltflächen, da wir die Rohwerte (von 0 bis 4095) lesen und interpretieren müssen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> ADC_POSITIVE_LEVEL = <span class="hljs-number">3072</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> ADC_NEGATIVE_LEVEL = <span class="hljs-number">1024</span>;<font></font>
<font></font>
<span class="hljs-keyword">uint32_t</span> dpadX = adc1_get_raw(DPAD_PIN_X_AXIS);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (dpadX &gt; ADC_POSITIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Left pressed</span><font></font>
}<font></font>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dpadX &gt; ADC_NEGATIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Right pressed</span><font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">uint32_t</span> dpadY = adc1_get_raw(DPAD_PIN_Y_AXIS);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (dpadY &gt; ADC_POSITIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Up pressed</span><font></font>
}<font></font>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dpadY &gt; ADC_NEGATIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Down pressed</span>
}</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADC_POSITIVE_LEVEL</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADC_NEGATIVE_LEVEL</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind Werte mit einem Rand, um sicherzustellen, dass wir immer die richtigen Werte lesen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umfrage</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt zwei Möglichkeiten, um Schaltflächenwerte abzurufen: Abfragen oder Interrupts. Wir können Eingabeverarbeitungsfunktionen erstellen und IDF bitten, diese Funktionen aufzurufen, wenn Tasten gedrückt werden, oder den Status der Tasten manuell abfragen, wenn wir sie benötigen. Interrupt-gesteuertes Verhalten macht die Dinge komplizierter und schwieriger zu verstehen. Außerdem bemühe ich mich immer, alles so einfach wie möglich zu gestalten. Bei Bedarf können wir später Interrupts hinzufügen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden eine Struktur erstellen, die den Status von sechs Schaltflächen und vier Richtungen des Kreuzes speichert. Wir können eine Struktur mit 10 booleschen oder 10 int oder 10 vorzeichenlosen int erstellen. Stattdessen erstellen wir die Struktur jedoch mithilfe von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitfeldern</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	<span class="hljs-keyword">uint16_t</span> a : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> b : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> volume : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> menu : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> select : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> start : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> left : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> right : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> up : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> down : <span class="hljs-number">1</span>;<font></font>
} Odroid_Input;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Programmierung für Desktop-Systeme werden Bitfelder normalerweise vermieden, da sie schlecht auf verschiedene Computer portiert sind. Wir programmieren jedoch für einen bestimmten Computer und müssen uns darüber keine Gedanken machen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstelle von Feldern könnte eine Struktur mit 10 Booleschen Werten mit einer Gesamtgröße von 10 Bytes verwendet werden. </font><font style="vertical-align: inherit;">Eine weitere Option ist </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint16_t mit</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bitverschiebungs- und </font><strong><font style="vertical-align: inherit;">Bitmaskierungsmakros, mit denen</font></strong><font style="vertical-align: inherit;"> einzelne Bits gesetzt, </font><strong><font style="vertical-align: inherit;">gelöscht</font></strong><font style="vertical-align: inherit;"> und überprüft werden können. </font><font style="vertical-align: inherit;">Es wird funktionieren, aber es wird nicht sehr schön sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein einfaches Bitfeld ermöglicht es uns, beide Ansätze zu nutzen: zwei Datenbytes und benannte Felder.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können wir den Status der Eingaben in der Hauptschleife abfragen und das Ergebnis anzeigen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	Odroid_InitializeInput();<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (;;)<font></font>
	{<font></font>
		Odroid_Input input = Odroid_PollInput();<font></font>
<font></font>
		<span class="hljs-built_in">printf</span>(
			<span class="hljs-string">"\ra: %d  b: %d  start: %d  select: %d  vol: %d  menu: %d  up: %d  down: %d  left: %d  right: %d"</span>,<font></font>
			input.a, input.b, input.start, input.select, input.volume, input.menu,<font></font>
			input.up, input.down, input.left, input.right);<font></font>
<font></font>
		fflush(<span class="hljs-built_in">stdout</span>);<font></font>
<font></font>
		vTaskDelay(<span class="hljs-number">250</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Should never get here</span><font></font>
	esp_restart();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ r</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die vorherige Zeile zu überschreiben, anstatt eine neue hinzuzufügen. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fflush wird</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> benötigt, um eine Zeile anzuzeigen, da sie im Normalzustand durch das Zeilenumbruchzeichen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ n zurückgesetzt wird</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ihr Browser unterstützt kein HTML5-Video.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_2/media/input.mp4" type="video/mp4"></video></div></div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid gehen schematisch</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF-Dokumentation: ADC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF-Dokumentation: GPIO</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 3: Anzeige</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir müssen in der Lage sein, Pixel auf dem Odroid Go LCD zu rendern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Anzeigen von Farben auf dem Bildschirm ist schwieriger als das Lesen des Eingabestatus, da das LCD über ein Gehirn verfügt. </font><font style="vertical-align: inherit;">Der Bildschirm wird von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ILI9341</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gesteuert </font><font style="vertical-align: inherit;">- einem sehr beliebten TFT-LCD-Treiber auf einem einzelnen Chip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit anderen Worten, wir sprechen mit ILI9341, das auf unsere Befehle reagiert, indem es die Pixel auf dem LCD steuert. </font><font style="vertical-align: inherit;">Wenn ich in diesem Teil "Bildschirm" oder "Anzeige" sage, meine ich eigentlich ILI9341. </font><font style="vertical-align: inherit;">Wir haben es mit ILI9341 zu tun. </font><font style="vertical-align: inherit;">Es steuert das LCD.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das LCD ist über </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI (Serial Peripheral Interface)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dem ESP32 verbunden </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SPI ist ein Standardprotokoll zum Datenaustausch zwischen Geräten auf einer Leiterplatte. Es hat vier Signale: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOSI (Master Out Slave In)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MISO (Master In Slave Out)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCK (Clock)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CS (Chip Select)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein einzelnes Master-Gerät auf dem Bus koordiniert die Datenübertragung durch Steuern von SCK und CS. Es können mehrere Geräte an einem Bus vorhanden sein, von denen jedes seine eigenen CS-Signale hat. Wenn das CS-Signal dieses Geräts aktiviert ist, kann es Daten senden und empfangen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der ESP32 ist der SPI-Master (Master) und das LCD ist der Slave-SPI-Slave. </font><font style="vertical-align: inherit;">Wir müssen den SPI-Bus mit den erforderlichen Parametern konfigurieren und dem Bus eine LCD-Anzeige hinzufügen, indem wir die entsprechenden Kontakte konfigurieren.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/60e/18c/7bc60e18c1b066ba7c22756464f92512.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/463/615/f124636158029efeab3259f299a2af36.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Namen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VSPI.XXXX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind nur Beschriftungen für die Kontakte im Diagramm, aber wir können die Kontakte selbst durchgehen, indem wir uns die Teile der LCD- und ESP32-Diagramme ansehen.</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOSI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; VSPI.MOSI -&gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO23</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MISO</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; VSPI.MISO -&gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO19</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; VSPI.SCK -&gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO18</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CS0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; VSPI.CS0 -&gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO5</font></font></strong></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben auch </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO14</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , den GPIO-Pin, mit dem die Hintergrundbeleuchtung eingeschaltet wird, und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO21</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der mit dem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pin des </font><font style="vertical-align: inherit;">LCD verbunden ist. Dieser Kontakt steuert die Art der Informationen, die wir an das Display senden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konfigurieren Sie zunächst den SPI-Bus.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_MISO = GPIO_NUM_19;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_MOSI = GPIO_NUM_23;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_SCLK = GPIO_NUM_18;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_CS = GPIO_NUM_5;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_DC = GPIO_NUM_21;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_BACKLIGHT = GPIO_NUM_14;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LCD_WIDTH = <span class="hljs-number">320</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LCD_HEIGHT = <span class="hljs-number">240</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LCD_DEPTH = <span class="hljs-number">2</span>;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">spi_bus_config_t</span> spiBusConfig = {};<font></font>
spiBusConfig.miso_io_num = LCD_PIN_MISO;<font></font>
spiBusConfig.mosi_io_num = LCD_PIN_MOSI;<font></font>
spiBusConfig.sclk_io_num = LCD_PIN_SCLK;<font></font>
spiBusConfig.quadwp_io_num = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Unused</span>
spiBusConfig.quadhd_io_num = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Unused</span><font></font>
spiBusConfig.max_transfer_sz = LCD_WIDTH * LCD_HEIGHT * LCD_DEPTH;<font></font>
<font></font>
ESP_ERROR_CHECK(spi_bus_initialize(VSPI_HOST, &amp;spiBusConfig, <span class="hljs-number">1</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir konfigurieren den Bus mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spi_bus_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es ist notwendig, die von uns verwendeten Kontakte und die maximale Größe einer Datenübertragung mitzuteilen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Moment führen wir eine SPI-Übertragung für alle Bildpufferdaten durch, die der Breite des LCD (in Pixel) mal seiner Höhe (in Pixel) mal der Anzahl der Bytes pro Pixel entspricht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Breite beträgt 320, die Höhe 240 und die Farbtiefe 2 Byte (die Anzeige erwartet, dass die Pixelfarben 16 Bit tief sind).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">spi_handle_t</span> gSpiHandle;<font></font>
<font></font>
<span class="hljs-keyword">spi_device_interface_config_t</span> spiDeviceConfig = {};<font></font>
spiDeviceConfig.clock_speed_hz = SPI_MASTER_FREQ_40M;<font></font>
spiDeviceConfig.spics_io_num = LCD_PIN_CS;<font></font>
spiDeviceConfig.queue_size = <span class="hljs-number">1</span>;<font></font>
spiDeviceConfig.flags = SPI_DEVICE_NO_DUMMY;<font></font>
<font></font>
ESP_ERROR_CHECK(spi_bus_add_device(VSPI_HOST, &amp;spiDeviceConfig, &amp;gSpiHandle));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach der Initialisierung des Busses müssen wir dem Bus ein LCD-Gerät hinzufügen, damit wir mit ihm sprechen können.</font></font><br>
<br>
<ul>
<li><strong>clock_speed_hz</strong> —   - ,      SPI   40 ,     .        80 ,         .</li>
<li><strong>spics_io_num</strong> —    CS,  IDF     CS,        ( SD-     SPI).</li>
<li><strong>queue_size</strong> —     1,           (  ).</li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flags</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Der IDF-SPI-Treiber fügt normalerweise leere Bits in die Übertragung ein, um Zeitprobleme beim Lesen vom SPI-Gerät zu vermeiden. Wir führen jedoch eine Einwegübertragung durch (wir lesen nicht vom Display). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI_DEVICE_NO_DUMMY</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> meldet, dass wir diese </font><strong><font style="vertical-align: inherit;">Einwegübertragung</font></strong><font style="vertical-align: inherit;"> bestätigen und keine leeren Bits einfügen müssen.</font></font></li>
</ul><br>
<br>
<pre><code class="cpp hljs">gpio_set_direction(LCD_PIN_DC, GPIO_MODE_OUTPUT);<font></font>
gpio_set_direction(LCD_PIN_BACKLIGHT, GPIO_MODE_OUTPUT);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir müssen auch die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Hintergrundbeleuchtungsstifte als GPIO-Stifte </font><font style="vertical-align: inherit;">festlegen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nach dem Umschalten von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC ist die</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hintergrundbeleuchtung ständig eingeschaltet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teams</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Kommunikation mit dem LCD erfolgt in Form von Befehlen. </font><font style="vertical-align: inherit;">Zuerst übergeben wir ein Byte, das den Befehl angibt, den wir senden möchten, und dann übergeben wir die Befehlsparameter (falls vorhanden). </font><font style="vertical-align: inherit;">Die Anzeige versteht, dass das Byte ein Befehl ist, wenn das </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Signal niedrig ist. </font><font style="vertical-align: inherit;">Wenn das </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleichstromsignal</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hoch ist, werden die empfangenen Daten als Parameter des zuvor gesendeten Befehls betrachtet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen sieht der Stream folgendermaßen aus:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir geben </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein </font><font style="vertical-align: inherit;">niedriges Signal</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir senden ein Byte des Befehls</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir geben </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein </font><font style="vertical-align: inherit;">hohes Signal</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Senden Sie je nach den Anforderungen des Befehls null oder mehr Bytes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholen Sie die Schritte 1 bis 4</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist unser bester Freund </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die ILI9341-Spezifikation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es listet alle möglichen Befehle, ihre Parameter und deren Verwendung auf.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68d/8d8/09c/68d8d809ceb9446142cd5c77bb78d0e2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Beispiel für einen Befehl ohne Parameter ist </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anzeige EIN</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Das Befehlsbyte ist </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x29</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , es sind jedoch keine Parameter angegeben.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35a/4e0/446/35a4e04466c22aa6746fe441f345c02f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Beispiel für einen Befehl mit Parametern ist der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spaltenadressensatz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Das Befehlsbyte ist </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , es werden jedoch vier erforderliche Parameter angegeben. </font><font style="vertical-align: inherit;">Um den Befehl zu verwenden, müssen Sie ein </font><font style="vertical-align: inherit;">niedriges Signal </font><font style="vertical-align: inherit;">an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> senden, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> senden, ein </font><font style="vertical-align: inherit;">hohes Signal </font><font style="vertical-align: inherit;">an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> senden </font><font style="vertical-align: inherit;">und dann die Bytes von vier Parametern übertragen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Befehlscodes selbst werden in der Aufzählung angegeben.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span><font></font>
{<font></font>
	SOFTWARE_RESET = <span class="hljs-number">0x01</span>u,<font></font>
	SLEEP_OUT = <span class="hljs-number">0x11</span>u,<font></font>
	DISPLAY_ON = <span class="hljs-number">0x29</span>u,<font></font>
	COLUMN_ADDRESS_SET = <span class="hljs-number">0x2A</span>u,<font></font>
	PAGE_ADDRESS_SET = <span class="hljs-number">0x2B</span>u,<font></font>
	MEMORY_WRITE = <span class="hljs-number">0x2C</span>u,<font></font>
	MEMORY_ACCESS_CONTROL = <span class="hljs-number">0x36</span>u,<font></font>
	PIXEL_FORMAT_SET = <span class="hljs-number">0x3A</span>u,<font></font>
} CommandCode;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen könnten wir ein Makro verwenden ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#define SOFTWARE_RESET (0x01u)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), aber sie haben keine Symbole im Debugger und sie haben keinen Bereich. </font><font style="vertical-align: inherit;">Es wäre auch möglich, statische Ganzzahlkonstanten zu verwenden, wie wir es bei GPIO-Kontakten getan haben, aber dank enum können wir auf einen Blick verstehen, welche Daten an eine Funktion oder ein Mitglied der Struktur übergeben werden: Sie sind vom Typ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CommandCode</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Andernfalls könnte es roh </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t sein</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><strong><font style="vertical-align: inherit;">das</font></strong><font style="vertical-align: inherit;"> dem Programmierer, der den Code </font><strong><font style="vertical-align: inherit;">liest</font></strong><font style="vertical-align: inherit;"> , nichts </font><strong><font style="vertical-align: inherit;">sagt</font></strong><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während der Initialisierung können wir verschiedene Befehle übergeben, um etwas zeichnen zu können. </font><font style="vertical-align: inherit;">Jeder Befehl hat ein Befehlsbyte, das wir Befehlscode nennen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir definieren eine Struktur zum Speichern des Startbefehls, damit Sie deren Array angeben können.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span><font></font>
	CommandCode code;<font></font>
	<span class="hljs-keyword">uint8_t</span> parameters[<span class="hljs-number">15</span>];
	<span class="hljs-keyword">uint8_t</span> length;<font></font>
} StartupCommand;</code></pre><br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Befehlscode.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameters</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein Array von Befehlsparametern (falls vorhanden). </font><font style="vertical-align: inherit;">Dies ist ein statisches Array der Größe 15, da dies die maximale Anzahl von Parametern ist, die wir benötigen. </font><font style="vertical-align: inherit;">Aufgrund der statischen Natur des Arrays müssen wir uns nicht jedes Mal darum kümmern, jedem Befehl ein dynamisches Array zuzuweisen.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Länge</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die Anzahl der Parameter im </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameterarray</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Struktur können wir eine Liste von Startbefehlen angeben.</font></font><br>
<br>
<pre><code class="cpp hljs">StartupCommand gStartupCommands[] =<font></font>
{<font></font>
	<span class="hljs-comment">// Reset to defaults</span><font></font>
	{<font></font>
		SOFTWARE_RESET,<font></font>
		{},<font></font>
		<span class="hljs-number">0</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// Landscape Mode</span>
	<span class="hljs-comment">// Top-Left Origin</span>
	<span class="hljs-comment">// BGR Panel</span><font></font>
	{<font></font>
		MEMORY_ACCESS_CONTROL,<font></font>
		{<span class="hljs-number">0x20</span> | <span class="hljs-number">0xC0</span> | <span class="hljs-number">0x08</span>},
		<span class="hljs-number">1</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// 16 bits per pixel</span><font></font>
	{<font></font>
		PIXEL_FORMAT_SET,<font></font>
		{<span class="hljs-number">0x55</span>},
		<span class="hljs-number">1</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// Exit sleep mode</span><font></font>
	{<font></font>
		SLEEP_OUT,<font></font>
		{},<font></font>
		<span class="hljs-number">0</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// Turn on the display</span><font></font>
	{<font></font>
		DISPLAY_ON,<font></font>
		{},<font></font>
		<span class="hljs-number">0</span><font></font>
	},<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Befehle ohne Parameter, z. B. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOFTWARE_RESET</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , setzen die Initialisierungsliste auf </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als leer ( </font><strong><font style="vertical-align: inherit;">dh</font></strong><font style="vertical-align: inherit;"> mit einer Null) und Länge auf 0. Befehle mit Parametern füllen die Parameter aus und geben die Länge an. </font><font style="vertical-align: inherit;">Es wäre großartig, wenn wir die Länge automatisch einstellen und keine Zahlen schreiben könnten (falls wir einen Fehler machen oder die Parameter ändern), aber ich denke nicht, dass es die Mühe wert ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zweck der meisten Teams ergibt sich aus dem Namen, mit Ausnahme von zwei. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MEMORY_ACCESS_CONTROL</font></font></strong><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Querformat </font><strong><font style="vertical-align: inherit;">:</font></strong><font style="vertical-align: inherit;"> Standardmäßig verwendet das Display Hochformat (240 x 320), wir möchten jedoch Querformat (320 x 240) verwenden.</font></font></li>
<li><strong>Top-Left Origin:</strong>      (0,0)     ,    ( )         .</li>
<li><strong>BGR Panel:</strong>  ,        BGR.   ,    , ,   ,     .</li>
</ul><br>
<strong>PIXEL_FORMAT_SET</strong><br>
<br>
<ul>
<li><strong>16 bits per pixel:</strong>   16- .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt viele andere Befehle, die beim Start gesendet werden können, um verschiedene Aspekte wie Gamma zu steuern. Die erforderlichen Parameter sind in der Spezifikation des LCD selbst (und nicht des ILI9341-Controllers) beschrieben, auf die wir keinen Zugriff haben. Wenn wir diese Befehle nicht übertragen, werden die Standardanzeigeeinstellungen verwendet, die perfekt zu uns passen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir eine Reihe von Startbefehlen vorbereitet haben, können wir beginnen, sie auf die Anzeige zu übertragen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst benötigen wir eine Funktion, die ein Befehlsbyte an die Anzeige sendet. Vergessen Sie nicht, dass sich das Senden von Befehlen vom Senden von Parametern unterscheidet, da wir ein </font><font style="vertical-align: inherit;">niedriges Signal </font><font style="vertical-align: inherit;">an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> senden müssen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BYTES_TO_BITS(value) ( (value) * 8 )</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SendCommandCode</span><span class="hljs-params">(CommandCode code)</span>
</span>{
	<span class="hljs-keyword">spi_transaction_t</span> transaction = {};<font></font>
<font></font>
	transaction.length = BYTES_TO_BITS(<span class="hljs-number">1</span>);<font></font>
	transaction.tx_data[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">uint8_t</span>)code;<font></font>
	transaction.flags = SPI_TRANS_USE_TXDATA;<font></font>
<font></font>
	gpio_set_level(LCD_PIN_DC, <span class="hljs-number">0</span>);<font></font>
	spi_device_transmit(gSpiHandle, &amp;transaction);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die IDF hat eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spi_transaction_t-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><font style="vertical-align: inherit;">, die wir </font><strong><font style="vertical-align: inherit;">füllen</font></strong><font style="vertical-align: inherit;"> , wenn wir etwas über den SPI-Bus übertragen möchten. Wir wissen, wie viele Bits die Nutzlast ist und übertragen die Last selbst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können entweder einen Zeiger auf die Nutzdaten übergeben oder die interne Struktur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tx_data</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwenden, die nur vier Byte groß ist, aber dem Treiber den Zugriff auf externen Speicher erspart. Wenn wir </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tx_data verwenden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , müssen wir das Flag </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI_TRANS_USE_TXDATA setzen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor dem Übertragen von Daten senden wir ein </font><font style="vertical-align: inherit;">niedriges Signal </font><font style="vertical-align: inherit;">an den </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was darauf hinweist, dass dies ein Befehlscode ist.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SendCommandParameters</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* data, <span class="hljs-keyword">int</span> length)</span>
</span>{
	<span class="hljs-keyword">spi_transaction_t</span> transaction = {};<font></font>
<font></font>
	transaction.length = BYTES_TO_BITS(length);<font></font>
	transaction.tx_buffer = data;<font></font>
	transaction.flags = <span class="hljs-number">0</span>;<font></font>
<font></font>
	gpio_set_level(LCD_PIN_DC, <span class="hljs-number">1</span>);<font></font>
	spi_device_transmit(SPIHANDLE, &amp;transaction);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Übergeben von Parametern ähnelt dem Senden eines Befehls. Nur dieses Mal verwenden wir unseren eigenen Puffer ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und senden ein </font><font style="vertical-align: inherit;">hohes Signal </font><font style="vertical-align: inherit;">an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um der Anzeige mitzuteilen, dass die Parameter übertragen werden. </font><font style="vertical-align: inherit;">Außerdem setzen wir das </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI_TRANS_USE_TXDATA-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flag nicht, </font><font style="vertical-align: inherit;">da wir unseren eigenen Puffer übergeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann können Sie alle Startbefehle senden.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARRAY_COUNT(value) ( sizeof(value) / sizeof(value[0]) )</span><font></font>
<font></font>
<span class="hljs-keyword">int</span> commandCount = ARRAY_COUNT(gStartupCommands);<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> commandIndex = <span class="hljs-number">0</span>; commandIndex &lt; commandCount; ++commandIndex)<font></font>
{<font></font>
	StartupCommand* command = &amp;gStartupCommands[commandIndex];<font></font>
<font></font>
	SendCommandCode(command-&gt;code);<font></font>
<font></font>
	<span class="hljs-keyword">if</span> (command-&gt;length &gt; <span class="hljs-number">0</span>)<font></font>
	{<font></font>
		SendCommandData(command-&gt;parameters, command-&gt;length);<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir durchlaufen iterativ das Array der Startbefehle, indem wir zuerst den Befehlscode und dann die Parameter (falls vorhanden) übergeben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rahmenzeichnung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Initialisieren der Anzeige können Sie mit dem Zeichnen beginnen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UPPER_BYTE_16(value) ( (value) &gt;&gt; 8u )</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOWER_BYTE_16(value) ( (value) &amp; 0xFFu )</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_DrawFrame</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* buffer)</span>
</span>{
	<span class="hljs-comment">// Set drawing window width to (0, LCD_WIDTH)</span>
    <span class="hljs-keyword">uint8_t</span> drawWidth[] = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, UPPER_BYTE_16(LCD_WIDTH), LOWER_BYTE_16(LCD_WIDTH) };<font></font>
	SendCommandCode(COLUMN_ADDRESS_SET);<font></font>
	SendCommandParameters(drawWidth, ARRAY_COUNT(drawWidth));<font></font>
<font></font>
	<span class="hljs-comment">// Set drawing window height to (0, LCD_HEIGHT)</span>
    <span class="hljs-keyword">uint8_t</span> drawHeight[] = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, UPPER_BYTE_16(LCD_HEIGHT), LOWER_BYTE_16(LCD_HEIGHT) };<font></font>
	SendCommandCode(PAGE_ADDRESS_SET);<font></font>
	SendCommandParameters(drawHeight, ARRAY_COUNT(drawHeight));<font></font>
<font></font>
	<span class="hljs-comment">// Send the buffer to the display</span><font></font>
	SendCommandCode(MEMORY_WRITE);<font></font>
	SendCommandParameters(buffer, LCD_WIDTH * LCD_HEIGHT * LCD_DEPTH);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ILI9341 kann einzelne Teile des Bildschirms neu zeichnen. Dies kann in Zukunft nützlich sein, wenn wir einen Rückgang der Bildrate feststellen. In diesem Fall ist es möglich, nur die geänderten Teile des Bildschirms zu aktualisieren. Im Moment zeichnen wir jedoch einfach den gesamten Bildschirm erneut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Rendern eines Frames muss ein Renderfenster festgelegt werden. Senden Sie dazu den Befehl </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COLUMN_ADDRESS_SET</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der Fensterbreite und den Befehl </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAGE_ADDRESS_SET</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der Fensterhöhe. Jeder der Befehle benötigt vier Bytes des Parameters, der das Fenster beschreibt, in dem das Rendering durchgeführt wird. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPPER_BYTE_16</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LOWER_BYTE_16</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies sind Hilfsmakros zum Extrahieren der hohen und niedrigen Bytes aus einem 16-Bit-Wert. </font><font style="vertical-align: inherit;">Die Parameter dieser Befehle erfordern, dass wir den 16-Bit-Wert in zwei 8-Bit-Werte aufteilen, weshalb wir dies tun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Rendern wird durch den Befehl </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MEMORY_WRITE</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> initiiert </font><font style="vertical-align: inherit;">und alle </font><strong><font style="vertical-align: inherit;">153.600</font></strong><font style="vertical-align: inherit;"> Bytes des </font><strong><font style="vertical-align: inherit;">Bildpuffers gleichzeitig</font></strong><font style="vertical-align: inherit;"> an die Anzeige </font><strong><font style="vertical-align: inherit;">gesendet</font></strong><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt andere Möglichkeiten, den Bildspeicher auf die Anzeige zu übertragen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können eine weitere FreeRTOS-Aufgabe (Aufgabe) erstellen, die für die Koordination der SPI-Transaktionen verantwortlich ist.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können einen Frame nicht in einer, sondern in mehreren Transaktionen übertragen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können eine nicht blockierende Übertragung verwenden, bei der wir das Senden initiieren und dann weitere Vorgänge ausführen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können eine beliebige Kombination der oben genannten Methoden verwenden.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Moment verwenden wir den einfachsten Weg: die einzige blockierende Transaktion. </font><font style="vertical-align: inherit;">Wenn </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DrawFrame</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufgerufen wird, wird die </font><font style="vertical-align: inherit;">Übertragung zur Anzeige initiiert und unsere Aufgabe wird angehalten, bis die Übertragung abgeschlossen ist. </font><font style="vertical-align: inherit;">Wenn wir später feststellen, dass wir mit dieser Methode keine gute Bildrate erzielen können, werden wir auf dieses Problem zurückkommen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB565 und Bytereihenfolge</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein typisches Display (z. B. der Monitor Ihres Computers) hat eine Bittiefe von 24 Bit (1,6 Millionen Farben): 8 Bit pro Rot, Grün und Blau. Das Pixel wird als </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRRRRRRRGGGGGGGGBGBBBBBBBBB</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in den Speicher </font><strong><font style="vertical-align: inherit;">geschrieben</font></strong><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Odroid LCD hat eine Bittiefe von 16 Bit (65.000 Farben): 5 Bit Rot, 6 Bit Grün und 5 Bit Blau. Das Pixel wird als </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRRRRGGGGGGGBBBBB</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in den Speicher </font><strong><font style="vertical-align: inherit;">geschrieben</font></strong><font style="vertical-align: inherit;"> . Dieses Format heißt </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB565</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAP_ENDIAN_16(value) ( (((value) &amp; 0xFFu) <span class="hljs-meta-string">&lt;&lt; 8u) | ((value) &gt;&gt; 8u)  )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RGB565(red, green, blue) ( SWAP_ENDIAN_16( ((red) &lt;&lt; 11u) | ((green) &lt;&lt; 5u) | (blue) ) )</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Definieren Sie ein Makro, das eine Farbe im RGB565-Format erstellt. Wir werden ihm ein Byte Rot, ein Byte Grün und ein Byte Blau übergeben. Er wird die fünf wichtigsten roten Teile, die sechs wichtigsten grünen und die fünf wichtigsten blauen Teile nehmen. Wir haben hohe Bits gewählt, weil sie mehr Informationen enthalten als niedrige Bits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der ESP32 speichert die Daten jedoch in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Little Endian-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reihenfolge </font><font style="vertical-align: inherit;">, d. H. Das niedrigstwertige Byte wird in der unteren Speicheradresse gespeichert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispielsweise wird der 32-Bit-Wert </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0xDE 0xAD 0xBE 0xEF]</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0xEF 0xBE 0xAD </font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">0xDE]</font></strong><font style="vertical-align: inherit;"> im Speicher gespeichert </font><font style="vertical-align: inherit;">. Beim Übertragen von Daten zur Anzeige wird dies zu einem Problem, da das niedrigstwertige Byte zuerst gesendet wird und das LCD erwartet, zuerst das höchstwertige Byte zu empfangen. </font><strong><font style="vertical-align: inherit;">Setzen Sie das</font></strong></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Makro </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SWAP_ENDIAN_16</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um Bytes </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auszutauschen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und im </font><strong><font style="vertical-align: inherit;">RGB565-</font></strong><font style="vertical-align: inherit;"> Makro zu verwenden </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier erfahren Sie, wie jede der drei Primärfarben in RGB565 beschrieben wird und wie sie im ESP32-Speicher gespeichert werden, wenn Sie die Bytereihenfolge nicht ändern. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rot</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
11111 | 000000 | 00000? -&gt; 11111000 00000000 -&gt; 00000000 11111000 </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grün</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
00000 | 111111 | 00000? -&gt; 00000111 11100000 -&gt; 11100000 00000111 </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blau</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
00000 | 000000 | 11111? -&gt; 00000000 00011111 -&gt; 00011111 00000000</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können eine einfache Demo erstellen, um das LCD in Aktion zu sehen. </font><font style="vertical-align: inherit;">Zu Beginn des Frames wird der Frame-Puffer auf Schwarz geleert und ein 50x50-Quadrat gezeichnet. </font><font style="vertical-align: inherit;">Wir können das Quadrat mit einem Kreuz verschieben und seine Farbe mit den Schaltflächen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ändern </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	Odroid_InitializeInput();<font></font>
	Odroid_InitializeDisplay();<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Odroid initialization complete - entering main loop"</span>);<font></font>
<font></font>
	<span class="hljs-keyword">uint16_t</span>* framebuffer = (<span class="hljs-keyword">uint16_t</span>*)heap_caps_malloc(<span class="hljs-number">320</span> * <span class="hljs-number">240</span> * <span class="hljs-number">2</span>, MALLOC_CAP_DMA);<font></font>
	assert(framebuffer);<font></font>
<font></font>
	<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">uint16_t</span> color = <span class="hljs-number">0xffff</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (;;)<font></font>
	{<font></font>
		<span class="hljs-built_in">memset</span>(framebuffer, <span class="hljs-number">0</span>, <span class="hljs-number">320</span> * <span class="hljs-number">240</span> * <span class="hljs-number">2</span>);<font></font>
<font></font>
		Odroid_Input input = Odroid_PollInput();<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (input.left) { x -= <span class="hljs-number">10</span>; }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.right) { x += <span class="hljs-number">10</span>; }<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (input.up) { y -= <span class="hljs-number">10</span>; }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.down) { y += <span class="hljs-number">10</span>; }<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (input.a) { color = RGB565(<span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.b) { color = RGB565(<span class="hljs-number">0</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>); }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.start) { color = RGB565(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xff</span>); }<font></font>
<font></font>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = y; row &lt; y + <span class="hljs-number">50</span>; ++row)<font></font>
		{<font></font>
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = x; col &lt; x + <span class="hljs-number">50</span>; ++col)<font></font>
			{<font></font>
				framebuffer[<span class="hljs-number">320</span> * row + col] = color;<font></font>
			}<font></font>
		}<font></font>
<font></font>
		Odroid_DrawFrame(framebuffer);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Should never get here</span><font></font>
	esp_restart();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir ordnen den Bildpuffer entsprechend der vollen Größe der Anzeige zu: 320 x 240, zwei Bytes pro Pixel (16-Bit-Farbe). </font><font style="vertical-align: inherit;">Wir verwenden </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heap_caps_malloc,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> damit es im Speicher zugewiesen wird, der für SPI-Transaktionen mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direct Memory Access (DMA) verwendet werden kann</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mit DMA können SPI-Peripheriegeräte ohne CPU-Beteiligung auf den Frame-Puffer zugreifen. </font><font style="vertical-align: inherit;">Ohne DMA dauern SPI-Transaktionen viel länger. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir führen keine Überprüfungen durch, um sicherzustellen, dass das Rendern nicht außerhalb der Bildschirmränder erfolgt.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ihr Browser unterstützt kein HTML5-Video.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_3/media/demo.mp4" type="video/mp4"></video></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Starkes Reißen ist spürbar. In Desktop-Anwendungen werden standardmäßig mehrere Puffer verwendet, um ein Zerreißen zu vermeiden. Bei doppelter Pufferung gibt es beispielsweise zwei Puffer: vordere und hintere Puffer. Während der vordere Puffer angezeigt wird, erfolgt die Aufnahme </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
im hinteren Bereich. Dann wechseln sie die Plätze und der Vorgang wiederholt sich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32 verfügt nicht über genügend RAM mit DMA-Funktionen, um zwei Frame-Puffer zu speichern (4 MB externer SPI-RAM verfügen leider nicht über DMA-Funktionen), daher ist diese Option nicht geeignet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ILI9341 hat ein Signal ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TE</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), das Ihnen sagt, wann </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBLANK auftritt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><strong><font style="vertical-align: inherit;">damit</font></strong><font style="vertical-align: inherit;"> wir auf das Display schreiben können, bis es gezeichnet wird. Bei Odroid (oder dem Anzeigemodul) ist dieses Signal jedoch nicht angeschlossen, sodass wir nicht darauf zugreifen können.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht könnten wir einen anständigen Wert finden, aber im Moment werden wir es nicht tun, denn jetzt besteht unsere Aufgabe darin, einfach die Pixel auf dem Bildschirm anzuzeigen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Den gesamten Quellcode finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid gehen schematisch</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geh spielen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF-Dokumentation: SPI-Master</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LCD-Treiberdatenblatt</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502518/index.html">Wie man auf einen Baum klettert</a></li>
<li><a href="../de502520/index.html">Videoberichte von Mitap-Berichten zur Produktanalyse</a></li>
<li><a href="../de502522/index.html">Wir öffnen den galvanischen Isolationschip mit einem winzigen Transformator im Inneren</a></li>
<li><a href="../de502524/index.html">Psychos machen Zivilisation</a></li>
<li><a href="../de502526/index.html">JUG Ru Group # 2 Online Stream Woche</a></li>
<li><a href="../de502532/index.html">Die Revolution in der IT-Abteilung (Abteilung). Ist es nötig?</a></li>
<li><a href="../de502536/index.html">Erste Eindrücke und Hauptmerkmale von MIUI 12</a></li>
<li><a href="../de502538/index.html">So erstellen Sie eine alte Version von NGINX Ingress Controller und patchen sie</a></li>
<li><a href="../de502540/index.html">Alpine.js - weiterhin aus</a></li>
<li><a href="../de502542/index.html">Wie wir Yandex beibringen, Fragen zu beantworten und Benutzern 20.000 Stunden pro Tag zu sparen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>