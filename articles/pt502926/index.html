<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì∏ ü§πüèø üê∞ Paul Graham: Brevidade = For√ßa üë®üèø üßëüèø‚Äçü§ù‚Äçüßëüèæ üöÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje, no HackerNews, levantamos uma discuss√£o sobre o artigo de 2002 de Paul Graham e decidimos ressuscitar sua tradu√ß√£o da inexist√™ncia.
 
 
 
 "A qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Paul Graham: Brevidade = For√ßa</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillfactory/blog/502926/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hoje, no HackerNews, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">levantamos uma discuss√£o sobre o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> artigo de 2002 de Paul Graham e decidimos ressuscitar sua tradu√ß√£o da inexist√™ncia.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da8/643/390/da8643390d5501c1411a3ba972dbe2ac.jpg" alt="imagem"></div><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"A quantidade de significado compactada em um espa√ßo pequeno </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
por sinais alg√©bricos √© outra circunst√¢ncia que facilita </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
os racioc√≠nios que estamos acostumados a seguir com a ajuda deles". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - Charles Babbage (1791-1871)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Na discuss√£o em torno do artigo </font><font style="vertical-align: inherit;">LL1 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revenge</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na lista de discuss√£o LL1, Paul Prescod fez uma observa√ß√£o que n√£o estava fora de minha cabe√ßa.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O objetivo do Python √© regularidade e legibilidade, mas n√£o brevidade.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä primeira vista, uma linguagem de programa√ß√£o provavelmente n√£o deveria ser. </font><font style="vertical-align: inherit;">Pelo que entendi, concis√£o (concis√£o, concis√£o, compacidade) = for√ßa. </font><font style="vertical-align: inherit;">E se sim, ent√£o, fazendo uma substitui√ß√£o, obtemos:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O objetivo do Python √© regularidade e legibilidade, mas n√£o poder.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
que, por sua vez, n√£o √© um compromisso muito bom (se √© realmente um compromisso), que vale a pena fazer. </font><font style="vertical-align: inherit;">Parece que se voc√™ disser: o objetivo da linguagem Python n√£o √© ser uma linguagem de programa√ß√£o eficaz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Brevidade = for√ßa? </font><font style="vertical-align: inherit;">Essa parece ser uma pergunta importante, talvez a pergunta mais importante para os envolvidos no desenvolvimento de idiomas. </font><font style="vertical-align: inherit;">Ainda n√£o tenho certeza de que a resposta seja apenas "sim", mas, para come√ßar, essa √© uma boa hip√≥tese.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hip√≥tese</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Minha hip√≥tese √© que brevidade √© poder, ou eles s√£o t√£o pr√≥ximos que, com exce√ß√£o de casos patol√≥gicos, voc√™ pode aceit√°-los por algo id√™ntico.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece-me que a brevidade √© para que as linguagens de programa√ß√£o s√£o criadas. Os computadores ficariam igualmente felizes se recebessem instru√ß√µes diretamente em linguagem de m√°quina. Eu acho que a principal raz√£o pela qual vamos desenvolver linguagens de alto n√≠vel √© obter a vantagem de expressar (e mais importante, pensar) dez linhas em uma linguagem de alto n√≠vel, o que exigiria 1000 linhas de c√≥digo de m√°quina. Em outras palavras, o principal objetivo das linguagens de alto n√≠vel √© reduzir o c√≥digo-fonte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se o c√≥digo-fonte mais curto √© o objetivo das linguagens de alto n√≠vel, e a for√ßa de alguma coisa √© uma medida de qu√£o bem o objetivo √© alcan√ßado, a for√ßa da linguagem de programa√ß√£o √© o quanto isso reduz seus programas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por outro lado, uma linguagem que n√£o reduz seus programas faz um trabalho ruim de uma linguagem de programa√ß√£o, assim como uma faca que corta mal ou impress√£o ileg√≠vel.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©tricas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E em que sentido √© menor? </font><font style="vertical-align: inherit;">A medida mais comum do tamanho do c√≥digo-fonte √© o n√∫mero de linhas. </font><font style="vertical-align: inherit;">Mas essa medida √© comum apenas devido √† simplicidade da medi√ß√£o, e n√£o acho que algu√©m acredite que seja um bom teste do tamanho do programa. </font><font style="vertical-align: inherit;">Os idiomas t√™m conven√ß√µes diferentes sobre o que pode ser colocado em uma linha; </font><font style="vertical-align: inherit;">algumas linhas em C podem ter apenas um ou dois separadores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro teste simples √© o n√∫mero de caracteres no programa, mas este n√£o √© muito bom; </font><font style="vertical-align: inherit;">alguns idiomas (como Perl) t√™m identificadores mais curtos que outros.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu acho que a melhor medida do tamanho de um programa pode ser o n√∫mero de elementos, onde o elemento √© algo que pode se tornar um v√©rtice separado na √°rvore de origem. O nome de uma vari√°vel ou fun√ß√£o √© um elemento; um n√∫mero inteiro ou um n√∫mero real √© um elemento; um segmento literal de texto √© um elemento; um elemento de uma diretiva de padr√£o ou formato √© um elemento. Existem casos de fronteira ("-5" √© um elemento ou dois?), Mas acho que a maioria deles √© a mesma em todos os idiomas, portanto eles n√£o afetar√£o muito a compara√ß√£o.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa medida deve ser concretizada e pode exigir interpreta√ß√£o adicional no caso de algumas linguagens espec√≠ficas, mas parece-me que ela est√° tentando medir a coisa certa: o n√∫mero de partes do programa. </font><font style="vertical-align: inherit;">A √°rvore de origem √© o que voc√™ desenha em sua mente para representar o programa e, portanto, o tamanho dessa √°rvore √© proporcional √† quantidade de trabalho necess√°rio para escrev√™-lo ou l√™-lo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projeto</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa medida nos permitiria comparar diferentes idiomas, mas esse n√£o √©, pelo menos para mim, seu valor b√°sico. E o valor do teste de brevidade √© um guia para o design de idiomas. A compara√ß√£o de idioma mais √∫til √© comparar duas varia√ß√µes poss√≠veis do mesmo idioma. O que posso fazer no idioma para tornar os programas mais curtos? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se a carga conceitual de um programa √© proporcional √† sua complexidade, e um determinado programador pode suportar uma certa carga conceitual, √© o mesmo que perguntar: como ajudar os programadores a fazer mais? E isso, parece-me, √© o mesmo que perguntar: como criar uma boa linguagem?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(A prop√≥sito, a falsidade deste j√° barbudo ditado "todas as l√≠nguas s√£o equivalentes" √© mais claramente vista ao projetar l√≠nguas. Quando voc√™ cria uma nova linguagem, voc√™ constantemente compara duas l√≠nguas - uma na qual eu faria X e a outra na qual n√£o faria - para que decida o que √© melhor. Se fosse uma pergunta sem sentido, voc√™ tamb√©m poderia jogar uma moeda.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ter uma meta de brevidade parece uma boa maneira de encontrar novas id√©ias. </font><font style="vertical-align: inherit;">Se voc√™ encontrar uma maneira de tornar os programas mais curtos, isso n√£o √© coincid√™ncia: voc√™ provavelmente encontrou uma nova abstra√ß√£o √∫til. </font><font style="vertical-align: inherit;">Voc√™ pode at√© escrever um programa que buscaria peda√ßos repetidos no c√≥digo-fonte. </font><font style="vertical-align: inherit;">Novas id√©ias podem ser encontradas entre os idiomas que t√™m reputa√ß√£o de serem concisos: adiante, alegria, √≠cone.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compara√ß√£o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro a escrever sobre essas coisas foi, at√© onde eu sei, Fred Brooks com seu livro Mythical Man-Month. Ele escreveu que os programadores geram a mesma quantidade de c√≥digo, independentemente da linguagem. Quando li pela primeira vez aos 20 anos, foi uma grande surpresa e pareceu-me que isso tinha enormes consequ√™ncias. Isso significava que (a) a √∫nica maneira de escrever programas mais rapidamente √© usar uma linguagem mais curta e (b) quem se deu ao trabalho de fazer isso perguntaria aos concorrentes que n√£o o fizeram. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A conjectura de Brooks, se verdadeira, pode ser a pr√≥pria ess√™ncia do hacking. Desde ent√£o, ao longo dos anos, prestei aten√ß√£o a tudo o que seria relevante para a quest√£o: de estudos te√≥ricos a hist√≥rias sobre projetos individuais. N√£o vi nada que contradisse essa hip√≥tese.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas n√£o vi nenhuma evid√™ncia clara e n√£o espero v√™-las. Estudos como a compara√ß√£o das linguagens de programa√ß√£o Lutz Prekelt, embora produzam os resultados esperados, tendem a usar tarefas muito pequenas para um teste significativo. O melhor teste para um idioma √© o que acontece em programas escritos em um m√™s. E se voc√™ est√° convencido, como eu, de que o principal objetivo dos idiomas √© ser um bom idioma em que eles pensam (em vez de um idioma em que eles d√£o instru√ß√µes ao computador depois que voc√™ pensa sobre isso), o teste real para o idioma √© Que novidade voc√™ pode escrever sobre isso. Portanto, comparar idiomas com base em uma especifica√ß√£o predefinida est√° um pouco errado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O verdadeiro teste para o idioma √© como voc√™ pode encontrar e resolver novos problemas, mas n√£o as tarefas formuladas por outra pessoa. Estes s√£o crit√©rios diferentes. Na arte, ferramentas como bordado e mosaico funcionam bem se voc√™ sabe com anteced√™ncia o que deseja obter, mas absolutamente indecente se n√£o sabe. Se voc√™ quiser revelar uma imagem no processo de escrever uma imagem (o que voc√™ deve fazer ao revelar coisas complexas, como, por exemplo, a imagem de uma pessoa), use uma ferramenta mais flex√≠vel, como l√°pis, tinta ou √≥leo. Obviamente, tape√ßarias e mosaicos s√£o feitos assim: primeiro uma imagem √© criada e, em seguida, apenas √© copiada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso significa que √© improv√°vel que tenhamos uma compara√ß√£o adequada da for√ßa relativa das linguagens de programa√ß√£o. Teremos compara√ß√µes exatas, mas n√£o corretas. Em particular, estudos voltados explicitamente para compara√ß√µes de idiomas provavelmente usar√£o pequenas tarefas e necessariamente usar√£o um conjunto predefinido de tarefas e, portanto, tender√£o a subestimar as linguagens mais poderosas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os relat√≥rios nessa √°rea, embora sejam menos precisos que os estudos "cient√≠ficos", provavelmente ser√£o mais significativos. Por exemplo, Ulf Viger, da Ericsson, conduziu um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estudo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e chegou √† conclus√£o de que Erlang √© 4-10 vezes menor que o C ++, e a velocidade de desenvolvimento de software √© proporcionalmente maior:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A compara√ß√£o de projetos internos na Ericsson revela produtividade semelhante em linhas de c√≥digo por hora, incluindo todas as fases do desenvolvimento, independentemente da linguagem usada (Erlang, PLEX, C, C ++ ou Java). </font><font style="vertical-align: inherit;">Diferen√ßas nos idiomas - apenas na quantidade total de c√≥digo fonte.</font></font><br>
</blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este estudo tamb√©m indica claramente que n√£o aparece no livro de Brooks (uma vez que media apenas linhas de c√≥digo depurado): programas escritos em linguagens mais poderosas tendem a conter menos erros. </font><font style="vertical-align: inherit;">Isso j√° √© suficiente e, provavelmente, em tarefas como comutadores de rede, isso √© mais importante que o desempenho do programador.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gostos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No final, voc√™ pode confiar em seu instinto. O que √© programa√ß√£o nesta linguagem? Penso que, para criar uma linguagem melhor, voc√™ deve se tornar hipersens√≠vel ao qu√£o bem a linguagem permite que voc√™ pense nela, e depois escolher ou desenvolver uma linguagem que lhe pare√ßa mais adequada. Se alguma propriedade do idioma for inconveniente ou restritiva - n√£o se preocupe, voc√™ saber√° sobre isso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas essa hipersensibilidade resultar√° em idiomas desajeitados tornando-se insuport√°veis ‚Äã‚Äãpara voc√™. </font><font style="vertical-align: inherit;">Acho a programa√ß√£o em linguagens que n√£o possuem macros insuportavelmente restritivas, como se algu√©m acostumado √† digita√ß√£o din√¢mica considerasse insuportavelmente restritivo o retorno √†s linguagens, onde os tipos devem ser descritos para cada vari√°vel declarada e √© imposs√≠vel declarar uma lista composta por elementos tipos diferentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E eu n√£o estou sozinho. </font><font style="vertical-align: inherit;">Conhe√ßo muitos hackers Lisp com quem algo semelhante aconteceu. </font><font style="vertical-align: inherit;">De fato, a medida mais precisa da for√ßa relativa de uma linguagem de programa√ß√£o pode ser a propor√ß√£o de programadores que conhecem uma determinada linguagem que realizar√£o qualquer trabalho em que essa linguagem deva ser usada, independentemente da √°rea de assunto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limita√ß√µes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Provavelmente, muitos hackers sabem como √© quando o idioma parece restritivo. </font><font style="vertical-align: inherit;">Essa √© provavelmente a mesma sensa√ß√£o de quando voc√™ fica preso em um engarrafamento na rua que deseja dirigir e precisa fazer um longo desvio. </font><font style="vertical-align: inherit;">Voc√™ quer dizer algo e o idioma n√£o permite que voc√™ fa√ßa isso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, uma linguagem limitadora n√£o √© uma linguagem sucinta. </font><font style="vertical-align: inherit;">O problema n√£o √© que voc√™ n√£o possa expressar algo, mas que o desvio que essa linguagem o for√ßa a fazer √© muito longo. </font><font style="vertical-align: inherit;">Fa√ßa esse experimento: voc√™ deseja escrever algum tipo de programa, e a linguagem n√£o permite que voc√™ fa√ßa como planejado, mas, ao contr√°rio, diminui a dura√ß√£o. </font><font style="vertical-align: inherit;">Pelo menos para mim isso n√£o seria muito restritivo. </font><font style="vertical-align: inherit;">Como se um policial o direcionasse de um engarrafamento para uma estrada mais curta, em vez de um longo desvio. </font><font style="vertical-align: inherit;">Uau!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece-me que o sentimento de limita√ß√£o basicamente (em 90%?) Decorre do fato de voc√™ ser for√ßado a prolongar o programa no idioma em que est√° escrevendo, comparado com o idioma em que pensa. </font><font style="vertical-align: inherit;">A limita√ß√£o √© basicamente concis√£o insuficiente; portanto, quando um idioma parece ser limitador, significa que n√£o √© curto o suficiente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legibilidade</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A cita√ß√£o com a qual comecei tamb√©m menciona duas outras qualidades: regularidade e legibilidade. </font><font style="vertical-align: inherit;">Eu realmente n√£o entendo o que √© regularidade e quais s√£o os benef√≠cios do c√≥digo regular e leg√≠vel em compara√ß√£o com o c√≥digo leg√≠vel. </font><font style="vertical-align: inherit;">Mas acho que sei o que se entende por legibilidade, e tamb√©m me parece que isso tem a ver com brevidade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui, devemos ter cuidado com os conceitos de legibilidade de uma √∫nica linha de c√≥digo e a legibilidade do programa como um todo. </font><font style="vertical-align: inherit;">Somente o √∫ltimo √© importante. </font><font style="vertical-align: inherit;">Concordo que uma linha no BASIC provavelmente √© mais leg√≠vel do que uma linha no Lisp, mas um programa escrito no BASIC ter√° mais linhas do que o mesmo programa escrito no Lisp. </font><font style="vertical-align: inherit;">Ler o programa BASIC exigir√° mais esfor√ßo.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esfor√ßo total = esfor√ßo para ler uma linha * n√∫mero de linhas</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o tenho tanta certeza de que a legibilidade seja proporcional √† brevidade, mas definitivamente a brevidade √© um fator de legibilidade (veja a f√≥rmula acima). Portanto, n√£o faz sentido dizer que o objetivo da linguagem √© a legibilidade, mas n√£o a brevidade.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para um usu√°rio que v√™ um determinado idioma pela primeira vez, a legibilidade linha por linha significa que esse idioma parecer√° inofensivo para ele. Portanto, a legibilidade linha a linha pode ser uma boa decis√£o de marketing, embora seja uma m√° decis√£o de design. √â isom√≥rfico no que diz respeito ao m√©todo de pagamento parcelado: em vez de ser intimidado por um grande dep√≥sito, voc√™ oferece ao comprador um pequeno pagamento mensal. O pagamento em partes √©, em √∫ltima an√°lise, in√∫til para ele, assim como a legibilidade linha por linha - para o programador. O comprador deve fazer muitos pagamentos pequenos, assim como o programador deve ler muitas linhas leg√≠veis separadamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa propor√ß√£o existia mesmo antes do advento das linguagens de programa√ß√£o. </font><font style="vertical-align: inherit;">Se voc√™ l√™ romances e artigos de jornal, sua primeira experi√™ncia lendo um artigo em matem√°tica pode ser assustadora: ler uma p√°gina leva meia hora. </font><font style="vertical-align: inherit;">No entanto, tenho certeza de que o problema n√£o est√° na nota√ß√£o, como pode parecer √† primeira vista. </font><font style="vertical-align: inherit;">Um artigo em matem√°tica √© dif√≠cil de ler porque as id√©ias s√£o complexas. </font><font style="vertical-align: inherit;">Se voc√™ expressar as mesmas id√©ias em prosa (como os matem√°ticos fizeram antes de pensar em uma breve nota√ß√£o), n√£o seria mais f√°cil l√™-las, porque essa p√°gina √∫nica se tornaria um livro inteiro.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em que grau?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns discordaram da ideia de brevidade = for√ßa. Penso que, em vez de discutir se √© assim, seria mais √∫til perguntar at√© que ponto brevidade √© poder? Porque √© claro que a brevidade √© um dos principais objetivos das linguagens de programa√ß√£o. E se n√£o, qual √© o seu prop√≥sito e qual a import√¢ncia dessas outras fun√ß√µes? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proponho isso para n√£o tornar a discuss√£o mais civilizada. Eu realmente quero saber a resposta. Quando, se isso acontecer, o idioma se tornar√° conciso o suficiente?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A hip√≥tese com a qual comecei foi a de que, exceto em alguns casos patol√≥gicos, a brevidade √© id√™ntica √† for√ßa. </font><font style="vertical-align: inherit;">Eu quis dizer que eles ser√£o id√™nticos em qualquer idioma desenvolvido por algu√©m, mas se algu√©m quiser criar um idioma especificamente para refutar essa hip√≥tese, provavelmente isso funcionar√°. </font><font style="vertical-align: inherit;">Mas tamb√©m n√£o tenho muita certeza disso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programas, mas n√£o programas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deve ficar claro que estamos falando sobre a brevidade das linguagens, n√£o sobre programas individuais. Obviamente, alguns programas podem ser escritos com muita for√ßa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu escrevi sobre isso no livro ‚ÄúAbout Lisp‚Äù. Para que a macro se justifique, ela deve economizar muitas vezes mais espa√ßo em rela√ß√£o ao seu pr√≥prio comprimento. Se alguma macro volumosa salva dez linhas de c√≥digo toda vez que voc√™ a usa, e a pr√≥pria macro consiste em dez linhas, voc√™ obter√° economia de linhas se us√°-lo mais de duas vezes. Mas essa ainda √© uma p√©ssima jogada, pois as defini√ß√µes de macro s√£o mais dif√≠ceis de ler do que o c√≥digo comum. Pode ser necess√°rio usar a macro 10 ou 20 vezes antes que a legibilidade melhore.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estou certo de que, em qualquer idioma, esses compromissos s√£o poss√≠veis (embora eu suspeite que os riscos aumentem em idiomas fortes). Todo programador j√° viu um c√≥digo extremamente reduzido devido a t√©cnicas de programa√ß√£o duvidosas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, √© indiscut√≠vel - pelo menos para mim - que os programas podem ser concisos o suficiente. A quest√£o √©: os pr√≥prios idiomas podem ser curtos? As linguagens podem for√ßar os programadores a escrever brevemente (em elementos) ao custo da legibilidade?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma das raz√µes pelas quais √© dif√≠cil imaginar uma linguagem muito concisa √© que, se houver uma maneira excessivamente compacta de expressar algo, provavelmente haver√° uma maneira mais longa. Por exemplo, se lhe parecer que o uso de macros ou fun√ß√µes de alto n√≠vel no Lisp √© muito denso, voc√™ pode escrever um c√≥digo isom√≥rfico no Pascal. Se voc√™ n√£o deseja expressar o fatorial na linguagem do Arc como uma chamada para uma fun√ß√£o de alto n√≠vel, </font></font><br>
<br>
<code>(rec zero 1 * 1-)</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tamb√©m pode escrever uma defini√ß√£o recursiva: </font></font><br>
<br>
<code>(rfn fact (x) (if (zero x) 1 (* x (fact (1- x)))))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embora n√£o possa dar exemplos t√£o imediatamente, estou interessado na pergunta: a linguagem pode ser muito curta? Existem idiomas que for√ßam voc√™ a escrever c√≥digo ileg√≠vel? Se algu√©m tiver algum exemplo, eu ficaria feliz em v√™-los.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Lembre-se: estou interessado em programas que possuem alta densidade de acordo com a medida dos "elementos" descritos acima, mas n√£o em programas curtos apenas porque podem ser omitidos com separadores e tudo tem nomes com um caractere.) </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foi publicado pela primeira vez </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br>
<hr><br>
<br>
<img src="https://habrastorage.org/webt/nk/j2/oz/nkj2oztxanscb6lhq19l-dfv2z8.jpeg" alt="imagem" align="left"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aprenda os detalhes de como obter uma profiss√£o procurada desde o in√≠cio ou suba de n√≠vel em habilidades e sal√°rio fazendo cursos on-line SkillFactory:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profiss√£o Cientista de Dados (24 meses) </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Profiss√£o Data Analyst Course (18 meses)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curso Python para Desenvolvimento Web (9 meses)</font></font></a></li>
</ul> <br>
<br clear="left"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt502916/index.html">Testes de unidade para o c√≥digo RxSwift</a></li>
<li><a href="../pt502918/index.html">Erro com a diretiva #line no compilador Visual C ++</a></li>
<li><a href="../pt502920/index.html">Conforme testamos o desempenho de novos processadores na nuvem para 1C, de acordo com o teste de Gilyov</a></li>
<li><a href="../pt502922/index.html">Marketing de multid√µes como uma ferramenta para aumentar a vitalidade dos neg√≥cios</a></li>
<li><a href="../pt502924/index.html">Revis√£o do telefone IP Snom D735</a></li>
<li><a href="../pt502928/index.html">Mini-confer√™ncia "Trabalho seguro com servi√ßos em nuvem"</a></li>
<li><a href="../pt502930/index.html">DevOps do Azure e App Center em vez de farms de teste: simplifique e acelere o desenvolvimento m√≥vel com servi√ßos em nuvem</a></li>
<li><a href="../pt502932/index.html">Lei de Patrick Mackenzie: Economia de software √© mais do que voc√™ pensa, mesmo considerando a lei de Patrick Mackenzie</a></li>
<li><a href="../pt502934/index.html">Como reduzir os custos de publicidade no Yandex.Direct e no Google Ads: 9 hacks vital√≠cios</a></li>
<li><a href="../pt502940/index.html">Como n√£o transformar um boletim de not√≠cias em spam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>