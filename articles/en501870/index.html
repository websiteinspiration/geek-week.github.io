<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåê üë©‚Äçüîß üßöüèæ Maximum number of values ‚Äã‚Äãin enum Part II üë©üèª‚Äçüç≥ üíï üë¶üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part One, Theoretical ¬†|¬†Part two, practical
 
 
 We continue to search for the maximum possible number of values ‚Äã‚Äãin the enumeration. 
 This time we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Maximum number of values ‚Äã‚Äãin enum Part II</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501870/"><nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part One, Theoretical</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;|&nbsp;</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part two, practical</font></font></b></nobr><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We continue to search for the maximum possible number of values ‚Äã‚Äãin the enumeration. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This time we will focus on the practical side of the issue and see how the IDE, the compiler and the JVM will respond to our achievements.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content</font></font></h1><br>
‚ÄÉ‚ÄÉ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"></font></a><br>
‚ÄÉ‚ÄÉ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">Tools </font></a></font><br>
‚ÄÉ‚ÄÉ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extract method </font></font></a><br>
‚ÄÉ‚ÄÉ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic Class-File Constants </font></font></a><br>
‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sudden Difficulties </font></font></a><br>
‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bright Future </font></font></a><br>
‚ÄÉ‚ÄÉ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsafe </font></font></a><br>
‚ÄÉ‚ÄÉ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test </font></font></a><br>
‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac and Switch </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">Performance </font></a></font><br>
‚ÄÉ‚ÄÉ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion </font></font></a><br>
‚ÄÉ‚ÄÉ<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additional Resources</font></font></a><br>
<br>
<a name="Tools"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tools</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javac takes care of us: it </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuts out characters that it doesn‚Äôt like from identifiers</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and forbids inheriting from it </font></font><code>java.lang.Enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so for experiments we need other tools. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hypotheses using </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">asmtools</font></a><font style="vertical-align: inherit;"> - assembler and disassembler for JVM, and generate class-files on an industrial scale - using the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For simplicity of understanding, the essence of what is happening will be duplicated in a java-like pseudocode.</font></font><br>
<br>
<a name="Javac"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a starting point, it is logical to take the best result, achievable without tricks, with the help of only one </font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Everything is simple here - we create the source file with the enumeration and add elements to it until javac refuses to compile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with the ‚Äúcode too large‚Äù curse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quite a long time, since Java 1.7, this number has been kept at the level of 2_746 elements. </font><font style="vertical-align: inherit;">But somewhere after Java 11, there were changes in the algorithm for storing values ‚Äã‚Äãin the constant pool and the maximum number decreased to 2_743. </font><font style="vertical-align: inherit;">Yes, yes, just because of changing the order of the elements in the pool of constants! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will focus on the best of the values.</font></font><br>
<br>
<a name="ExtractMethod"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extract method</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since one of the limiting factors is related to the size of the bytecode in the static initialization block, we will try to make the latter as easy as possible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recall how it looks on the example of the enumeration </font></font><code>FizzBuzz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the first part. </font><font style="vertical-align: inherit;">Comments provide appropriate assembly instructions.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static {}</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Fizz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>);
    <span class="hljs-comment">//  0: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">//  3: dup</span>
    <span class="hljs-comment">//  4: ldc           #22                 // String Fizz</span>
    <span class="hljs-comment">//  6: iconst_0</span>
    <span class="hljs-comment">//  7: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 10: putstatic     #25                 // Field Fizz:LFizzBuzz;</span>
    Buzz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 13: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">// 16: dup</span>
    <span class="hljs-comment">// 17: ldc           #28                 // String Buzz</span>
    <span class="hljs-comment">// 19: iconst_1</span>
    <span class="hljs-comment">// 20: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 23: putstatic     #30                 // Field Buzz:LFizzBuzz;</span>
    FizzBuzz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>);
    <span class="hljs-comment">// 26: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">// 29: dup</span>
    <span class="hljs-comment">// 30: ldc           #32                 // String FizzBuzz</span>
    <span class="hljs-comment">// 32: iconst_2</span>
    <span class="hljs-comment">// 33: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 36: putstatic     #33                 // Field FizzBuzz:LFizzBuzz;</span><font></font>
<font></font>
    $VALUES = <span class="hljs-keyword">new</span> FizzBuzz[] {
    <span class="hljs-comment">// 39: iconst_3</span>
    <span class="hljs-comment">// 40: anewarray     #2                  // class FizzBuzz</span><font></font>
        Fizz, <font></font>
    <span class="hljs-comment">// 43: dup</span>
    <span class="hljs-comment">// 44: iconst_0</span>
    <span class="hljs-comment">// 45: getstatic     #25                 // Field Fizz:LFizzBuzz;</span>
    <span class="hljs-comment">// 48: aastore</span><font></font>
        Buzz, <font></font>
    <span class="hljs-comment">// 49: dup</span>
    <span class="hljs-comment">// 50: iconst_1</span>
    <span class="hljs-comment">// 51: getstatic     #30                 // Field Buzz:LFizzBuzz;</span>
    <span class="hljs-comment">// 54: aastore</span><font></font>
        FizzBuzz<font></font>
    <span class="hljs-comment">// 55: dup</span>
    <span class="hljs-comment">// 56: iconst_2</span>
    <span class="hljs-comment">// 57: getstatic     #33                 // Field FizzBuzz:LFizzBuzz;</span>
    <span class="hljs-comment">// 60: aastore</span><font></font>
    };<font></font>
    <span class="hljs-comment">// 61: putstatic     #1                  // Field $VALUES:[LFizzBuzz;</span>
    <span class="hljs-comment">// 64: return</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first thing that comes to mind is to put the creation and filling of the array </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">into a separate method.</font></font><br>
<br>
<pre><code class="java hljs">$VALUES = createValues();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Developing this idea, the creation of instances of enumeration elements can be transferred to the same method:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    FizzBuzz[] localValues = createValues();<font></font>
<font></font>
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<font></font>
    Fizz = localValues[index++];<font></font>
    Buzz = localValues[index++];<font></font>
    FizzBuzz = localValues[index++];<font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FizzBuzz[] {
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>), 
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>), 
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>)<font></font>
    };<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Already better, but each capture of an array element and the subsequent index increment cost 6 bytes, which is too expensive for us. </font><font style="vertical-align: inherit;">Put them out in a separate method.</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> valueIndex;<font></font>
<font></font>
<span class="hljs-keyword">static</span>  {<font></font>
    $VALUES = createValues();<font></font>
<font></font>
    valueIndex = <span class="hljs-number">0</span>;<font></font>
    Fizz = nextValue();<font></font>
    Buzz = nextValue();<font></font>
    FizzBuzz = nextValue();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz <span class="hljs-title">nextValue</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> $VALUES[valueIndex++];<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It </font><font style="vertical-align: inherit;">takes 11 bytes to </font><font style="vertical-align: inherit;">initialize </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>valueIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and return from the static initialization block </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">and 65_524 more bytes remain to initialize the fields. </font><font style="vertical-align: inherit;">Initialization of each field requires 6 bytes, which enables us to create an enumeration of 10_920 elements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Almost four times growth compared to javac must definitely be celebrated by code generation! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Generator source code: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExtractMethodHugeEnumGenerator.java Generated</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
class example: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExtractMethodHugeEnum.class</font></font></a><br>
<a name="ConDy"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic Class-File Constants</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It's time to remember about </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 309</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and its mysterious </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dynamic constants</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The essence of innovation in a nutshell: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To already existing types supported by a pool of constants added another one </font></font><code>CONSTANT_Dynamic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When loading a class, the type of such a constant is known, but its value is unknown. The first loading of a constant leads to a call to the bootstrap method specified in its declaration. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The result of this method becomes a constant value. There are no ways to change the value associated with an already initialized constant. Which is quite logical for a constant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you also thought of Singleton, then forget it immediately. </font><font style="vertical-align: inherit;">The specification separately emphasizes that there is no guarantee of thread safety in this case, and the initialization method in multi-threaded code can be called more than once. </font><font style="vertical-align: inherit;">It is only guaranteed that in the case of several calls to the bootstrap method for the same constant, the JVM will throw a coin and select one of the calculated values ‚Äã‚Äãfor the role of the constant value, and the others will be sacrificed to the garbage collector.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Behaviorally, a CONSTANT_Dynamic constant is resolved by executing its bootstrap method on the following parameters: </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a local Lookup object,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the String representing the name component of the constant,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Class representing the expected constant type, and</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">any remaining bootstrap arguments.</font></font></li>
</ol><br>
As with invokedynamic, multiple threads can race to resolve, but a unique winner will be chosen and any other contending answers discarded.<br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To load values ‚Äã‚Äãfrom the pool of constants in the bytecode, commands are provided </font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ldc_w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>ldc2_w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Of interest to us is the first of them - </font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It, unlike the others, is able to load values ‚Äã‚Äãonly from the first 255 slots of the constant pool, but it takes 1 byte less in bytecode. All this gives us savings of up to 255 bytes and an </font></font><code>255 + ((65_524 - (255 * 5)) / 6) = 10_963</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">element in the enumeration. This time the growth is not so impressive, but it is still there. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Armed with this knowledge, let's get started. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the static initialization block, instead of method calls, </font></font><code>nextValue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we will now load the value of the dynamic constant. The value of the </font></font><code>ordinal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordinal index of the enumeration element will be passed explicitly, thus getting rid of the field </font></font><code>valueIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the factory method</font></font><code>nextValue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and doubts about the thread safety of our implementation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a bootstrap method, we will use a special subtype of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHandle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that imitates the behavior of an operator </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Java. </font><font style="vertical-align: inherit;">The standard library provides a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHandles.Lookup :: findConstructor ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method for obtaining such a method handle </font><font style="vertical-align: inherit;">, but in our case, the JVM will take care of the construction of the necessary method handle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To use the constructor of our enumeration as a bootstrap method, it will have to be slightly modified by changing the signature. </font><font style="vertical-align: inherit;">The parameters required for the bootstrap method will be added to the traditional constructor of the name enumeration element and serial number:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; enumClass, <span class="hljs-keyword">int</span> ordinal)</span> </span>{
    <span class="hljs-keyword">super</span>(name, ordinal);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the form of pseudo-code, initialization will look like this:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Fizz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>);<font></font>
    Buzz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>);<font></font>
    FizzBuzz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>);<font></font>
<font></font>
    $VALUES = createValues();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the example above, the instructions are </font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">designated as method calls </font></font><code>JVM_ldc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in the bytecode in their place will be the corresponding JVM instructions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since now we have a separate constant for each element of the enumeration, the creation and filling of the array </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can also be implemented through a dynamic constant. </font><font style="vertical-align: inherit;">The bootstrap method is very simple:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; clazz, FizzBuzz... elements) {
    <span class="hljs-keyword">return</span> elements;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All the trick in the list of static parameters for this dynamic constant, there we will list all the elements that we want to put in </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BootstrapMethods:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1: # 54 REF_invokeStatic FizzBuzz.createValues: (Ljava / lang / invoke / MethodHandles $ Lookup; Ljava / lang / String; Ljava / lang / Class; [LFizzBuzz;) [LFizzBuzz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Method arguments:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      # 1 # 0: Fizz: LFizzBuzz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      # 2 # 0: Buzz: LFizzBuzz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      # 3 # 0: FizzBuzz: LFizzBuzz;</font></font><font></font>
</pre><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The JVM spoils the array from these static parameters and passes it to our bootstrap method as a vararg parameter </font></font><code>elements</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The maximum number of static parameters is traditional 65_535, so it is guaranteed to be enough for all elements of the enumeration, no matter how many there are. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For transfers with a large number of elements, this change will reduce the size of the resulting class file, and in the case when, due to the large number of elements, the method </font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">had to be split into several parts, it also saves slots in the constant pool. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And in the end, it's just beautiful.</font></font><br>
<br>
<a name="Surprise"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sudden difficulties</font></font></h1><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Which we heroically overcome by generating classes manually. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
High-level libraries provide a convenient interface in exchange for some restriction of freedom of action. </font><font style="vertical-align: inherit;">The ASM library we use to generate class files is no exception. </font><font style="vertical-align: inherit;">It does not provide mechanisms for directly controlling the contents of the pool of constants. </font><font style="vertical-align: inherit;">This is usually not very important, but not in our case. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you remember, we need the first 255 elements of the constant pool to save precious bytes in the static initialization block. </font><font style="vertical-align: inherit;">When dynamic constants are added in a standard way, they will be located at random indices and mixed with other elements that are not so critical for us. </font><font style="vertical-align: inherit;">This will prevent us from reaching the maximum.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment of a pool of constants formed in the traditional way</font></font></b>
                        <div class="spoiler_text"><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constant pool:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
   # 1 = Utf8 FizzBuzz</font></font><font></font>
   #2 = Class              #1             // FizzBuzz<font></font>
   #3 = Utf8               java/lang/Enum<font></font>
   #4 = Class              #3             // java/lang/Enum<font></font>
   #5 = Utf8               $VALUES<font></font>
   #6 = Utf8               [LFizzBuzz;<font></font>
   #7 = Utf8               valueIndex<font></font>
   #8 = Utf8               I<font></font>
   #9 = Utf8               Fizz<font></font>
  #10 = Utf8               LFizzBuzz;<font></font>
  #11 = Utf8               Buzz<font></font>
  #12 = Utf8               FizzBuzz<font></font>
  #13 = Utf8               values<font></font>
  #14 = Utf8               ()[LFizzBuzz;<font></font>
  #15 = NameAndType        #5:#6          // $VALUES:[LFizzBuzz;<font></font>
  #16 = Fieldref           #2.#15         // FizzBuzz.$VALUES:[LFizzBuzz;<font></font>
  #17 = Class              #6             // "[LFizzBuzz;"<font></font>
  #18 = Utf8               clone<font></font>
  #19 = Utf8               ()Ljava/lang/Object;<font></font>
  #20 = NameAndType        #18:#19        // clone:()Ljava/lang/Object;<font></font>
  #21 = Methodref          #17.#20        // "[LFizzBuzz;".clone:()Ljava/lang/Object;<font></font>
  ...<font></font>
  #40 = NameAndType        #9:#10         // Fizz:LFizzBuzz;<font></font>
  #41 = Dynamic            #0:#40         // #0:Fizz:LFizzBuzz;<font></font>
  #42 = Fieldref           #2.#40         // FizzBuzz.Fizz:LFizzBuzz;<font></font>
  #43 = NameAndType        #11:#10        // Buzz:LFizzBuzz;<font></font>
  #44 = Dynamic            #0:#43         // #0:Buzz:LFizzBuzz;<font></font>
  #45 = Fieldref           #2.#43         // FizzBuzz.Buzz:LFizzBuzz;<font></font>
  #46 = NameAndType        #12:#10        // FizzBuzz:LFizzBuzz;<font></font>
  #47 = Dynamic            #0:#46         // #0:FizzBuzz:LFizzBuzz;<font></font>
  #48 = Fieldref           #2.#46         // FizzBuzz.FizzBuzz:LFizzBuzz;<font></font>
</pre><br>
</blockquote><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, there is a workaround - when creating a class, you can specify a sample class from which a pool of constants and an attribute with a description of bootstrap methods will be copied. </font><font style="vertical-align: inherit;">Only now we have to generate it manually. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, it is not as difficult as it might seem at first glance. </font><font style="vertical-align: inherit;">The format of the class-file is quite simple and its manual generation is a somewhat tedious process, but not at all complicated. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most important thing here is a clear plan. </font><font style="vertical-align: inherit;">To enumerate from the </font></font><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elements we need:</font></font><br>
<br>
<ul>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type records </font></font><code>CONSTANT_Dynamic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- our dynamic constants</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type records </font></font><code>CONSTANT_NameAndType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- pairs of links to the name of the enumeration element and its type. </font><font style="vertical-align: inherit;">The type will be the same for everyone, this is the class type of our enumeration.</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type records </font></font><code>CONSTANT_Utf8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- directly the names of the enumeration elements</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">records of type </font></font><code>CONSTANT_Integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- serial numbers of enumeration elements passed to the constructor as a parameter value</font></font><code>ordinal</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">names of the current and base classes, attributes, method signatures and other boring implementation details. </font><font style="vertical-align: inherit;">Those interested can look in the source code of the generator.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are a lot of constituent elements in the pool of constants that refer to other elements of the pool by index, so all the indices we need should be calculated in advance, </font></font><code>elementNames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a list of the names of the elements of our enumeration:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">int</span> elementCount = elementNames.size();<font></font>
<font></font>
<span class="hljs-keyword">int</span> baseConDy = <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> baseNameAndType = baseConDy + elementCount;
<span class="hljs-keyword">int</span> baseUtf8 = baseNameAndType + elementCount;
<span class="hljs-keyword">int</span> baseInteger = baseUtf8 + elementCount;
<span class="hljs-keyword">int</span> indexThisClass = baseInteger + elementCount;
<span class="hljs-keyword">int</span> indexThisClassUtf8 = indexThisClass + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexSuperClass = indexThisClassUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexSuperClassUtf8 = indexSuperClass + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodsUtf8 = indexSuperClassUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexConDyDescriptorUtf8 = indexBootstrapMethodsUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodHandle = indexConDyDescriptorUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodRef = indexBootstrapMethodHandle + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodNameAndType = indexBootstrapMethodRef + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodName = indexBootstrapMethodNameAndType + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodDescriptor = indexBootstrapMethodName + <span class="hljs-number">1</span>;<font></font>
<font></font>
<span class="hljs-keyword">int</span> constantPoolSize = indexBootstrapMethodDescriptor + <span class="hljs-number">1</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After that, we begin to write. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the beginning - the signature of the class file, the four bytes known to everyone </font></font><nobr><code>0xCA 0xFE 0xBA 0xBE</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the file format version:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Class file header</span><font></font>
u4(CLASS_FILE_SIGNATURE);<font></font>
u4(version);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then - a pool of constants:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pool of constants</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment">// Constant pool</span><font></font>
u2(constantPoolSize);<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Dynamic</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1u2u2(CONSTANT_Dynamic, i, baseNameAndType + i);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_NameAndType</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1u2u2(CONSTANT_NameAndType, baseUtf8 + i, indexConDyDescriptorUtf8);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Utf8</span>
<span class="hljs-comment">//noinspection ForLoopReplaceableByForEach</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1(CONSTANT_Utf8);<font></font>
    utf8(elementNames.get(i));<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Integer</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1(CONSTANT_Integer);<font></font>
    u4(i);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ThisClass</span><font></font>
u1(CONSTANT_Class);<font></font>
u2(indexThisClassUtf8);<font></font>
<font></font>
<span class="hljs-comment">// ThisClassUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(enumClassName);<font></font>
<font></font>
<span class="hljs-comment">// SuperClass</span><font></font>
u1(CONSTANT_Class);<font></font>
u2(indexSuperClassUtf8);<font></font>
<font></font>
<span class="hljs-comment">// SuperClassUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(JAVA_LANG_ENUM);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodsUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(ATTRIBUTE_NAME_BOOTSTRAP_METHODS);<font></font>
<font></font>
<span class="hljs-comment">// ConDyDescriptorUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(binaryEnumClassName);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodHandle</span><font></font>
u1(CONSTANT_MethodHandle);<font></font>
u1(REF_newInvokeSpecial);<font></font>
u2(indexBootstrapMethodRef);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodRef</span><font></font>
u1u2u2(CONSTANT_Methodref, indexThisClass, indexBootstrapMethodNameAndType);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodNameAndType</span><font></font>
u1u2u2(CONSTANT_NameAndType, indexBootstrapMethodName, indexBootstrapMethodDescriptor);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodName</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(BOOTSTRAP_METHOD_NAME);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodDescriptor</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(BOOTSTRAP_METHOD_DESCRIPTOR);<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the pool constant talking about access modifiers and flags ( </font></font><code>public</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>enun</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and so on), the class name and its ancestor:</font></font><br>
<br>
<pre><code class="java hljs">u2(access);<font></font>
u2(indexThisClass);<font></font>
u2(indexSuperClass);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The dummy class we generated will have no interfaces, no fields, no methods, but there will be one attribute with a description of bootstrap methods:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Interfaces count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Fields count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Methods count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Attributes count</span>
u2(<span class="hljs-number">1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And here is the body of the attribute itself:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// BootstrapMethods attribute</span><font></font>
u2(indexBootstrapMethodsUtf8);<font></font>
<span class="hljs-comment">// BootstrapMethods attribute size</span>
u4(<span class="hljs-number">2</span> <span class="hljs-comment">/* num_bootstrap_methods */</span> + <span class="hljs-number">6</span> * elementCount);
<span class="hljs-comment">// Bootstrap method count</span><font></font>
u2(elementCount);<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {
    <span class="hljs-comment">// bootstrap_method_ref</span><font></font>
    u2(indexBootstrapMethodHandle);<font></font>
    <span class="hljs-comment">// num_bootstrap_arguments</span>
    u2(<span class="hljs-number">1</span>);
    <span class="hljs-comment">// bootstrap_arguments[1]</span><font></font>
    u2(baseInteger + i);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's all, the class is formed. </font><font style="vertical-align: inherit;">We take these bytes and create from them </font></font><code>ClassReader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> ClassReader <span class="hljs-title">getBootstrapClassReader</span><span class="hljs-params">(<span class="hljs-keyword">int</span> version, <span class="hljs-keyword">int</span> access, String enumClassName, List&lt;String&gt; elementNames)</span> </span>{
    <span class="hljs-keyword">byte</span>[] bootstrapClassBytes = <span class="hljs-keyword">new</span> ConDyBootstrapClassGenerator(<font></font>
        version,<font></font>
        access,<font></font>
        enumClassName,<font></font>
        elementNames<font></font>
    )<font></font>
    .generate();<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (bootstrapClassBytes == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClassReader(bootstrapClassBytes);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It was not so difficult. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Generator Source Code: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConDyBootstrapClassGenerator.java</font></font></a><br>
<a name="Future"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bright future</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We briefly digress from our listings:</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscoverConstantValueAttribute</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String STRING = <span class="hljs-string">"Habrahabr, world!"</span>;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object OBJECT = <span class="hljs-keyword">new</span> Object();<font></font>
<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the static initialization block of this class, there will suddenly be only one write operation, in the field </font></font><code>OBJECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">static</span> {<font></font>
    OBJECT = <span class="hljs-keyword">new</span> Object();
    <span class="hljs-comment">//  0: new           #2                  // class java/lang/Object</span>
    <span class="hljs-comment">//  3: dup</span>
    <span class="hljs-comment">//  4: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span>
    <span class="hljs-comment">//  7: putstatic     #7                  // Field OBJECT:Ljava/lang/Object;</span>
    <span class="hljs-comment">// 10: return</span><font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But what about </font></font><code>STRING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The team will help shed light on this riddle </font></font><nobr><code>javap -c -s -p -v DiscoverConstantValueAttribute.class</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, here is the fragment that interests us:</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.String STRING;<font></font>
  descriptor: Ljava/lang/String;<font></font>
  flags: (<span class="hljs-number">0x0019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL<font></font>
  ConstantValue: String Habrahabr, world!<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The value of the static final field has moved from the initialization block to a separate attribute </font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Here's what they write about this attribute in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMS11 ¬ß4.7.2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A ConstantValue attribute represents the value of a constant expression (JLS ¬ß15.28), and is used as follows:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the ACC_STATIC flag in the access_flags item of the field_info structure is set, then the field represented by the field_info structure is assigned the value represented by its ConstantValue attribute as part of the initialization of the class or interface declaring the field (¬ß5.5). </font><font style="vertical-align: inherit;">This occurs prior to the invocation of the class or interface initialization method of that class or interface (¬ß2.9.2).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otherwise, the Java Virtual Machine must silently ignore the attribute.</font></font></li>
</ul><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If such an attribute occurs at the same time </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(although the latter is not explicitly spelled out here) in a field, then such a field is initialized with the value from this attribute. </font><font style="vertical-align: inherit;">And this happens even before the static initialization method is called. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It would be tempting to use this attribute to initialize the elements of the enumeration, in our chapter before last there were just constants, albeit dynamic ones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And we are not the first to think in this direction, there is a mention in JEP 309 </font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Unfortunately, this mention is in the Future work chapter:</font></font><br>
<br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Future work</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Possible future extensions include: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attaching dynamic constants to the ConstantValue attribute of static fields</font></font></li>
</ul><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the meantime, we can only dream about the times when this feature will move from the ‚Äúgood to do‚Äù state to ‚Äúready‚Äù. </font><font style="vertical-align: inherit;">Then the restrictions on the size of the code in the initialization block will lose their influence and the maximum number of elements in the enumeration will determine the limitations of the constant pool. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
According to rough estimates, in this case we can hope for an </font></font><code>65&nbsp;489 / 4 = 16_372</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">element. </font><font style="vertical-align: inherit;">Here </font></font><code>65_489</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the number of unoccupied slots of the constant pool, 46 of the theoretically possible 65_535 went to overhead. </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the number of slots required for the declaration of one field and the corresponding dynamic constant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The exact number, of course, can be found out only after the release of the JDK version with support for this feature.</font></font><br>
<br>
<a name="Unsafe"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsafe</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our enemy is the linear growth of the initialization block with an increase in the number of enumeration elements. </font><font style="vertical-align: inherit;">If we had found a way to curtail initialization in a loop, thereby removing the relationship between the number of elements in the enumeration and the size of the initialization block, we would make another breakthrough. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, none of the standard public APIs allows writing to </font></font><code>static final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fields even inside a static initialization block. </font><font style="vertical-align: inherit;">Neither Reflection nor VarHandles will help here. </font><font style="vertical-align: inherit;">Our only hope is great and terrible </font></font><code>sun.misc.Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An unsafe execution of FizzBuzz might look something like this:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsafe FizzBuzz</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword">import</span> java.lang.reflect.Field;
<span class="hljs-keyword">import</span> sun.misc.Unsafe;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FizzBuzz {<font></font>
<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz[] $VALUES;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz Fizz;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz Buzz;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz FizzBuzz;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FizzBuzz[] values() {
        <span class="hljs-keyword">return</span> (FizzBuzz[]) $VALUES.clone();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FizzBuzz <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">return</span> (FizzBuzz) Enum.valueOf(FizzBuzz.class, name);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>{
        <span class="hljs-keyword">super</span>(name, ordinal);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FizzBuzz[] {<font></font>
            Fizz,<font></font>
            Buzz,<font></font>
            FizzBuzz<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span>  {<font></font>
        Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
        unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
        String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
            String fieldName = fieldNames[i];<font></font>
            Field field = FizzBuzz.class.getDeclaredField(fieldName);<font></font>
            <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
            unsafe.putObject(FizzBuzz.class, fieldOffset, <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i));<font></font>
        }<font></font>
<font></font>
        $VALUES = createValues();<font></font>
    }<font></font>
<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This approach allows us to create an enumeration with approximately 21 thousand elements; for more, the capacity of the pool of constants is not enough. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The documentation on </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enum :: ordinal ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requires that its value matches the sequence number of the corresponding element in the enumeration declaration, so you have to explicitly store the list of field names in the correct order, thereby almost doubling the size of the class file.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">public final int ordinal () </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Returns the ordinal of this enumeration constant (its position in its enum declaration, where the initial constant is assigned an ordinal of zero).</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here the public API to the contents of the pool of constants could help, we already know how to fill it in the order we need, but there is no such API and it is unlikely to ever be. The </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class :: getConstantPool ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method available in OpenJDK is </font><font style="vertical-align: inherit;">declared as package-private and it would be rash to rely on it in user code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The initialization block is now quite compact and almost independent of the number of elements in the enumeration, so you </font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can refuse it by embedding its body in the loop:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
    unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
    Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
    String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
    FizzBuzz[] localValues = <span class="hljs-keyword">new</span> FizzBuzz[fieldNames.length];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
        String fieldName = fieldNames[i];<font></font>
        Field field = FizzBuzz.class.getDeclaredField(fieldName);<font></font>
        <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
        unsafe.putObject(<font></font>
            FizzBuzz.class,<font></font>
            fieldOffset,<font></font>
            (localValues[i] = <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i))<font></font>
        );<font></font>
    }<font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here an avalanche-like process happens: along with the method </font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, instructions for reading fields of enumeration elements disappear, type records </font></font><code>Fieldref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for these fields </font><font style="vertical-align: inherit;">become unnecessary </font><font style="vertical-align: inherit;">, and therefore type </font></font><code>NameAndType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">records for type records </font></font><code>Fieldref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In the constant pool, </font></font><code>2 * &lt;   &gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slots are </font><font style="vertical-align: inherit;">freed up </font><font style="vertical-align: inherit;">that can be used to declare additional enumeration elements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But not everything is so rosy, tests show a significant performance drawdown: initializing an enumeration class with 65 thousand elements takes unthinkable one and a half minutes. As it turned out pretty quickly, "reflex slows down." </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The implementation of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class :: getDeclaredField ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in OpenJDK has a linear asymptotic behavior of the number of fields in the class, and our initialization block is quadratic because of this.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adding caching improves the situation somewhat, although it does not completely solve it:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
    unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
    Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
    String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
    Field[] fields = FizzBuzz.class.getDeclaredFields();<font></font>
    HashMap&lt;String, Field&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(fields.length);<font></font>
<font></font>
    <span class="hljs-keyword">for</span>(Field field : fields) {<font></font>
        cache.put(field.getName(), field);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
        String fieldName = fieldNames[i];<font></font>
        Field field = cache.get(fieldName);<font></font>
        <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
        unsafe.putObject(<font></font>
            FizzBuzz.class,<font></font>
            fieldOffset,<font></font>
            (localValues[i] = <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i))<font></font>
        );<font></font>
    }    <font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The unsafe approach described in this chapter allows you to create transfers with the number of elements up to 65_410, which is almost 24 times more than the result achievable with javac and is quite close to the theoretical limit of 65_505 elements calculated by us in the previous publication of the cycle.</font></font><br>
<br>
<a name="Testing"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Check performance</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For tests, we take the largest enumeration, generating it using the command </font></font><nobr><code>java -jar HugeEnumGen.jar -a Unsafe UnsafeHugeEnum</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As a result, we get a class file with a size of 2 megabytes and 65_410 elements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Create a new Java project in IDEA and add the generated class as an external library. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Almost immediately, it becomes apparent that IDEA is not ready for such a stress test: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m4/su/-6/m4su-6bvdkkqmf3pypqrmpzntnw.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auto-completion of an enumeration element takes tens of seconds both on the ancient mobile i5 and on the more modern i7 8700K. And if you try using quick fix to add the missing elements to the switch, then IDEA even stops redrawing the windows. I suspect that temporarily, but failed to wait for completion. Responsiveness during debugging also leaves much to be desired. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with a small number of elements in </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFew</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>{
        <span class="hljs-keyword">for</span>(String arg : args) {<font></font>
            System.out.print(arg + <span class="hljs-string">" : "</span>);<font></font>
<font></font>
            <span class="hljs-keyword">try</span> {<font></font>
                UnsafeHugeEnum value = UnsafeHugeEnum.valueOf(arg);<font></font>
<font></font>
                doSwitch(value);<font></font>
            } <span class="hljs-keyword">catch</span>(Throwable e) {<font></font>
                e.printStackTrace(System.out);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSwitch</span><span class="hljs-params">(UnsafeHugeEnum value)</span> </span>{
        <span class="hljs-keyword">switch</span>(value) {
            <span class="hljs-keyword">case</span> VALUE_00001:<font></font>
                System.out.println(<span class="hljs-string">"First"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> VALUE_31415:<font></font>
                System.out.println(<span class="hljs-string">"(int) (10_000 * Math.PI)"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> VALUE_65410:<font></font>
                System.out.println(<span class="hljs-string">"Last"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:<font></font>
                System.out.println(<span class="hljs-string">"Unexpected value: "</span> + value);
                <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
    }<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are no surprises here, compilation and launch are regular:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ java TestFew VALUE_00001 VALUE_00400 VALUE_31415 VALUE_65410<font></font>
VALUE_00001 : First<font></font>
VALUE_00400 : Unexpected value: VALUE_00400<font></font>
VALUE_31415 : (int) (10_000 * Math.PI)<font></font>
VALUE_65410 : Last<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What about more items in </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Can we, for example, process </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all of our 65 thousand elements </font><font style="vertical-align: inherit;">in one at </font><font style="vertical-align: inherit;">once?</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">switch</span>(value) {
    <span class="hljs-keyword">case</span> VALUE_00001:
    <span class="hljs-keyword">case</span> VALUE_00002:<font></font>
        ...<font></font>
    <span class="hljs-keyword">case</span> VALUE_65410:<font></font>
        System.out.println(<span class="hljs-string">"One of known values: "</span> + value);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:<font></font>
        System.out.println(<span class="hljs-string">"Unexpected value: "</span> + value);
        <span class="hljs-keyword">break</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alas, no. </font><font style="vertical-align: inherit;">When we try to compile, we get a whole bunch of error messages:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ javac -fullversion<font></font>
javac full version "14.0.1+7"<font></font>
<font></font>
$ javac TestAll.java<font></font>
TestAll.java:18: error: code too large for try statement<font></font>
        switch(value) {<font></font>
        ^<font></font>
TestAll.java:65433: error: too many constants<font></font>
                break;<font></font>
                ^<font></font>
TestAll.java:17: error: code too large<font></font>
    private static void doSwitch(UnsafeHugeEnum value) {<font></font>
                        ^<font></font>
TestAll.java:1: error: too many constants<font></font>
public class TestAll {<font></font>
       ^<font></font>
4 errors<font></font>
</code></pre><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testfew.java</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TestAll.java</font></font></a></li>
</ul><br>
<a name="JavacSwitchTranslation"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac and switch</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To understand what is happening, we have to figure out how the translation </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the elements of the enumeration </font><font style="vertical-align: inherit;">occurs </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The JVM specification has a separate chapter in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMS11 ¬ß3.10 Compiling Switches</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the recommendations of which boil down to </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">using one of the two bytecode instructions, </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>lookupswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will not find </font><font style="vertical-align: inherit;">any references </font><font style="vertical-align: inherit;">to strings or enumeration elements in this chapter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The best documentation is code, so it's time to dive into the source </font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The choice between </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>lookupswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">occurs in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gen :: visitSwitch ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and depends on the number of options in </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In most cases, wins </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Determine whether to issue a tableswitch or a lookupswitch</span>
<span class="hljs-comment">// instruction.</span>
<span class="hljs-keyword">long</span> table_space_cost = <span class="hljs-number">4</span> + ((<span class="hljs-keyword">long</span>) hi - lo + <span class="hljs-number">1</span>); <span class="hljs-comment">// words</span>
<span class="hljs-keyword">long</span> table_time_cost = <span class="hljs-number">3</span>; <span class="hljs-comment">// comparisons</span>
<span class="hljs-keyword">long</span> lookup_space_cost = <span class="hljs-number">3</span> + <span class="hljs-number">2</span> * (<span class="hljs-keyword">long</span>) nlabels;
<span class="hljs-keyword">long</span> lookup_time_cost = nlabels;
<span class="hljs-keyword">int</span> opcode =<font></font>
    nlabels &gt; <span class="hljs-number">0</span> &amp;&amp;<font></font>
    table_space_cost + <span class="hljs-number">3</span> * table_time_cost &lt;=<font></font>
    lookup_space_cost + <span class="hljs-number">3</span> * lookup_time_cost<font></font>
    ?<font></font>
    tableswitch : lookupswitch;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The header </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is approximately 16 bytes plus 4 bytes per value. </font><font style="vertical-align: inherit;">Thus, </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">under no circumstances can there be more </font></font><code>( 65_535 - 16 ) / 4 = 16_379</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indeed, after reducing the number of branches </font></font><code>case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the body </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to 16 thousand, there remains only one compilation error, the most mysterious:</font></font><br>
<br>
<pre><code class="plaintext hljs">TestAll.java:18: error: code too large for try statement<font></font>
        switch(value) {<font></font>
        ^<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In search of the source of the error, we will return a little earlier, to the stage of getting rid of syntactic sugar. </font><font style="vertical-align: inherit;">The </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">methods are responsible for the </font><font style="vertical-align: inherit;">translation </font></font><code>visitEnumSwitch()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>mapForEnum()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the class </font></font><code>EnumMapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lower.java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There we also find a small documentary comment:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EnumMapping JavaDoc</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment">/** This map gives a translation table to be used for enum
 *  switches.
 *
 *  &lt;p&gt;For each enum that appears as the type of a switch
 *  expression, we maintain an EnumMapping to assist in the
 *  translation, as exemplified by the following example:
 *
 *  &lt;p&gt;we translate
 *  &lt;pre&gt;
 *          switch(colorExpression) {
 *          case red: stmt1;
 *          case green: stmt2;
 *          }
 *  &lt;/pre&gt;
 *  into
 *  &lt;pre&gt;
 *          switch(Outer$0.$EnumMap$Color[colorExpression.ordinal()]) {
 *          case 1: stmt1;
 *          case 2: stmt2
 *          }
 *  &lt;/pre&gt;
 *  with the auxiliary table initialized as follows:
 *  &lt;pre&gt;
 *          class Outer$0 {
 *              synthetic final int[] $EnumMap$Color = new int[Color.values().length];
 *              static {
 *                  try { $EnumMap$Color[red.ordinal()] = 1; } catch (NoSuchFieldError ex) {}
 *                  try { $EnumMap$Color[green.ordinal()] = 2; } catch (NoSuchFieldError ex) {}
 *              }
 *          }
 *  &lt;/pre&gt;
 *  class EnumMapping provides mapping data and support methods for this translation.
 */</span>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The mysterious </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">turns out to be part of an automatically generated helper class </font></font><code>TestAll$0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Inside - a declaration of a static array and code to initialize it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The array fixes the correspondence between the names of the enumeration elements and the </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numerical values </font><font style="vertical-align: inherit;">assigned to them during compilation </font><font style="vertical-align: inherit;">, thereby protecting the compiled code from the harmful effects of refactoring. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When reordering, adding new ones, or deleting existing enumeration elements, some of them may change the value </font></font><code>ordinal()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and this is what an additional level of indirection protects from.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">try</span> {<font></font>
    $SwitchMap$UnsafeHugeEnum[UnsafeHugeEnum.VALUE_00001.ordinal()] = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//  9: getstatic     #2                  // Field $SwitchMap$UnsafeHugeEnum:[I</span>
    <span class="hljs-comment">// 12: getstatic     #3                  // Field UnsafeHugeEnum.VALUE_00001:LUnsafeHugeEnum;</span>
    <span class="hljs-comment">// 15: invokevirtual #4                  // Method UnsafeHugeEnum.ordinal:()I</span>
    <span class="hljs-comment">// 18: iconst_1</span>
    <span class="hljs-comment">// 19: iastore</span><font></font>
}<font></font>
<span class="hljs-comment">// 20: goto          24</span>
<span class="hljs-keyword">catch</span>(NoSuchFieldError e) { }
<span class="hljs-comment">// 23: astore_0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The initialization code is simple and consumes from 15 to 17 bytes per element. </font><font style="vertical-align: inherit;">As a result, the static initialization block accommodates the initialization of no more than 3_862 elements. </font><font style="vertical-align: inherit;">This number turns out to be the maximum number of enumeration elements that we can use in one </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the current implementation </font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="Conclusion"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We saw that the use of even such a simple technique as allocating the creation of enumeration elements and initializing an array </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">into a separate method allows you to increase the maximum number of elements in an enumeration from 2_746 to 10_920. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The constant dynamic results against the background of previous achievements do not look very impressive and allow you to get only 43 elements more, but with this approach it‚Äôs much more elegant to add new properties to the enumeration - just modify the constructor and pass it the necessary values ‚Äã‚Äãthrough the static parameters of the dynamic constant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If sometime in the future attribute </font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be taught to understand the dynamic constants, this number could rise to 10 thousand to 16. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Use</font></font><code>sun.misc.Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows you to make a giant leap and increase the maximum number of elements to 65_410. But do not forget that </font></font><code>Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is a proprietary API that may disappear over time and its use is a considerable risk, as javac directly warns:</font></font><br>
<br>
<pre><code class="plaintext hljs">Test.java:3: warning: Unsafe is internal proprietary API and may be removed in a future release<font></font>
import sun.misc.Unsafe;<font></font>
               ^<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But, as it turned out, it is not enough to generate a giant enumeration, you also need to be able to use it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Currently, there are problems with the support of such enumerations both from the IDE and at the Java compiler level. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A large number of fields in the class can degrade the responsiveness of the IDE both during editing and during debugging. </font><font style="vertical-align: inherit;">Sometimes up to a complete hang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The restrictions imposed by the class file format and implementation details of javac make it impossible to use </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">more than 3_862 elements </font><font style="vertical-align: inherit;">in the code </font><font style="vertical-align: inherit;">at the same time. </font><font style="vertical-align: inherit;">Of the positive aspects, it is worth mentioning that these can be arbitrary 3_862 elements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further improvement of the results is possible only through refinement of the Java compiler, but this is a completely different story.</font></font><br>
<br>
<a name="Appendix"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additional materials</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GitHub source code: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/Maccimo/HugeEnumGeneratorArticle</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Collected JAR file: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/Maccimo/HugeEnumGeneratorArticle/releases/tag/v1.0</font></font></a><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supported Startup Help</font></font></b>
                        <div class="spoiler_text"><pre><font></font>
Huge enumeration generator<font></font>
<font></font>
    https://github.com/Maccimo/HugeEnumGeneratorArticle<font></font>
<font></font>
Additional information (in Russian):<font></font>
<font></font>
    https://habr.com/ru/post/483392/<font></font>
    https://habr.com/ru/post/501870/<font></font>
<font></font>
Usage:<font></font>
    java -jar HugeEnumGen.jar [ &lt;options&gt; ] &lt;enum name&gt;<font></font>
<font></font>
    &lt;enum name&gt;<font></font>
        An enumeration class name.<font></font>
        Should be a valid Java identifier. May contain package name.<font></font>
<font></font>
Options:<font></font>
<font></font>
    -d &lt;directory&gt;<font></font>
        Output directory path.<font></font>
        Current working directory by default.<font></font>
<font></font>
    -e &lt;item list file&gt;<font></font>
        Path to UTF8-encoded text file with list of enumeration item names.<font></font>
        Item names will be autogenerated if absent.<font></font>
        Mutually exclusive with the -c option.<font></font>
<font></font>
    -c &lt;count&gt;<font></font>
        Count of autogenerated enumeration item names.<font></font>
        Mutually exclusive with the -e option.<font></font>
        Default value: Algorithm-depended<font></font>
<font></font>
    -a &lt;algorithm&gt;<font></font>
        Enumeration generation algorithm.<font></font>
        Supported algorithms:<font></font>
          ConDy          - Employ Constant Dynamic (JEP 309) for enum elements initialization<font></font>
          ExtractMethod  - Extract enum elements initialization code to separate method<font></font>
          Unsafe         - Employ sun.misc.Unsafe for enum elements initialization<font></font>
<font></font>
        Default algorithm: ExtractMethod<font></font>
<font></font>
    -h / -?<font></font>
        Show this help page.<font></font>
<font></font>
Example:<font></font>
<font></font>
    java -jar HugeEnumGen.jar -d ./bin -c 2020 com.habr.maccimo.HugeEnum2020<font></font>
<font></font>
</pre><br>
</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en501860/index.html">May 15 RU-Center may add you a paid service without your participation</a></li>
<li><a href="../en501862/index.html">Flutter under the hood</a></li>
<li><a href="../en501864/index.html">Assistant or inspector: for whom is the robot calling?</a></li>
<li><a href="../en501866/index.html">How many jobs robots will destroy</a></li>
<li><a href="../en501868/index.html">How not to let the accountant throw himself or We transfer 1C to the cloud. Step-by-step instruction</a></li>
<li><a href="../en501872/index.html">Place of study in cybernetic systems</a></li>
<li><a href="../en501874/index.html">Modern Front End Architectures (Part 2)</a></li>
<li><a href="../en501880/index.html">About the translation of "beginnings" and "beginnings" without begin, start and first</a></li>
<li><a href="../en501882/index.html">How we use computer vision algorithms: video processing in a mobile browser using OpenCV.js</a></li>
<li><a href="../en501884/index.html">How electronic medical information archives will help diagnose diseases more effectively</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>