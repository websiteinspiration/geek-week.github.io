<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚑 🈵 🐆 マルチキャストRxJSオペレーターを調査します 🤺 🚣🏼 🖌️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！Netanel Basalによる記事「Understanding RxJS Multicast Operators」の翻訳を紹介します。
 
 ブロードキャストまたはマルチキャストのオペレーターは、R​​xJSについて学ぶのが最も難しいトピックのように思われます。この記事では、す...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>マルチキャストRxJSオペレーターを調査します</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490988/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font><font style="vertical-align: inherit;">Netanel Basalによる</font><font style="vertical-align: inherit;">記事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Understanding RxJS Multicast Operators」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の翻訳を紹介します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロードキャストまたはマルチキャストのオペレーターは、R​​xJSについて学ぶのが最も難しいトピックのように思われます。</font><font style="vertical-align: inherit;">この記事では、すべてをわかりやすく説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチキャストオペレーターの内部構造と、オペレーターが解決するタスクについて検討します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、RxJSの基本的なビルディングブロックについて説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">観察可能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RxJSでは、監視可能なオブジェクト（以下、「ストリーム」と呼びます）は最初はコールドです。つまり、ストリームをサブスクライブするたびに、サブスクリプションのコールバックが実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理解を深めるために、次の実装を作成します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>{<font></font>
  <span class="hljs-keyword">constructor</span>(subscriptionFn) {<font></font>
    <span class="hljs-keyword">this</span>.subscriptionFn = subscriptionFn;<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.subscriptionFn(observer);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンストラクター</font></font><code>Observable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は単一のパラメーター（サブスクリプションのコールバック）を受け入れます</font></font><br>
 <code>subscriptionFn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ストリーム（</font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">をサブスクライブするたびに呼び出され</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">サブスクライバー（コード内のオブザーバーオブジェクト）の値も「生成」するため、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブスクリプションのコールバックも呼び出すことがあります</font></font><code>producer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッド</font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は入力を受け取ります</font></font><code>observer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、3つの独自のメソッドを持つオブジェクトです</font></font><code>next(), error(), complete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ライブRxJSでは、オブジェクトの代わりに3つの関数を渡すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッド</font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が呼び出されると、サブスクリプション関数が呼び出され、入力に渡されます</font></font><code>observer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今は方法については触れませんでした</font></font><code>unsubscribe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただし、各サブスクリプションはそれを破棄する方法を提供することを覚えておく必要があります。</font><font style="vertical-align: inherit;">ほとんどの場合、サブスクリプションは関数（または適切なメソッドを持つオブジェクト）を返し、その間にストリームとそのサブスクライバー間の接続は破棄されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはすべて非常に単純です。</font><font style="vertical-align: inherit;">今現実に近づきましょう。</font><font style="vertical-align: inherit;">たとえば、ネイティブXHR APIをストリームにラップします</font></font><br>
<br>
<pre><code class="javascript hljs"><font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">http</span>(<span class="hljs-params">url</span>) </span>{<font></font>
  <span class="hljs-comment">// This function will be called when we call http().subscribe()</span><font></font>
  <span class="hljs-keyword">const</span> subscriptionFn = <span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
    log(<span class="hljs-string">'Observable execution: http'</span>);<font></font>
    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<font></font>
    xhr.addEventListener(<span class="hljs-string">'load'</span>, () =&gt; {<font></font>
      <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>) {<font></font>
        observer.next(<span class="hljs-built_in">JSON</span>.parse(xhr.responseText));<font></font>
        observer.complete();<font></font>
      }<font></font>
    });<font></font>
    xhr.open(<span class="hljs-string">'GET'</span>, url);<font></font>
    xhr.send();<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> xhr.abort()<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(subscriptionFn);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">URLを受け取り、httpリクエストを実行し、受け取ったhttp応答を送信するストリームを返す</font><font style="vertical-align: inherit;">
関数を</font><font style="vertical-align: inherit;">記述しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、実装を見て、このストリームを2回サブスクライブするとどうなると思いますか？</font></font><br>
<br>
<pre><code class="javascript hljs"><font></font>
<span class="hljs-comment">// A small observer helper</span><font></font>
<span class="hljs-keyword">const</span> observer = <span class="hljs-function"><span class="hljs-params">tag</span> =&gt;</span> ({<font></font>
  next(value) {<font></font>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${tag}</span>:`</span>, value);<font></font>
  }<font></font>
});<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber-1'</span>));<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber-2'</span>));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正しくは、2つのhttpリクエストが実行されます。</font><font style="vertical-align: inherit;">Observableクラスの実装をもう一度見ると、なぜそうなのかがわかります。</font><font style="vertical-align: inherit;">各サブスクライバーはサブスクリプションコールバックを呼び出します。サブスクリプションコールバックは、毎回http要求を実行します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/by/ee/aybyeesbyfdzvcjcp3etc8jhfww.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーター</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演算子は、ストリームを入力として受け取り、任意のアクションを実行して、ストリームを返す関数です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の独自のオペレーターを作成します。</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">fn</span>) </span>{<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
      log(<span class="hljs-string">'Observable execution: map'</span>);<font></font>
      <span class="hljs-keyword">return</span> source.subscribe({<font></font>
        next(value) {<font></font>
          observer.next(fn(value));<font></font>
        }<font></font>
      });<font></font>
    });<font></font>
  };<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数</font></font><code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、元のストリームを受け入れる演算子を返し、渡されるすべての値が関数を介して渡されるストリームを返します</font></font><code>fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。</font><font style="vertical-align: inherit;">その中には常に入力ストリームへのサブスクリプションがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この新しい演算子を使用する前に、なんとかしてそれをストリームにアタッチする必要があります。</font><font style="vertical-align: inherit;">クラスを拡張</font></font><code>Observable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font></font><code>pipe()</code><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>{<font></font>
  <span class="hljs-keyword">constructor</span>(subscriptionFn) {<font></font>
    <span class="hljs-keyword">this</span>.subscriptionFn = subscriptionFn;<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.subscriptionFn(observer);<font></font>
  }<font></font>
<font></font>
  pipe(...operators) {<font></font>
    <span class="hljs-keyword">return</span> operators.reduce(<span class="hljs-function">(<span class="hljs-params">source, next</span>) =&gt;</span> next(source), <span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な方法、たった1行のコード。</font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子の配列を取り、それらを1つずつ呼び出し、各入力に前の入力の結果を渡します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演算子を使ってみましょう：</font></font><br>
<br>
<pre><code class="javascript hljs">http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]))<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber'</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
呼び出されると</font></font><code>subscribe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、出力ストリームへのサブスクリプションが実行され</font></font><code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次に</font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、元のストリームへのサブスクリプションが</font><font style="vertical-align: inherit;">内部</font><font style="vertical-align: inherit;">で実行さ</font><font style="vertical-align: inherit;">れ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
httpストリームは、それが該当する値を出力し</font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">次に、関数が実行され</font></font><code>fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、からのストリーム</font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が値を出力して最終サブスクリプションに送信します。</font></font><code>observable chain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドチェーンの</font><font style="vertical-align: inherit;">ように機能し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4a/ou/8r/4aou8rffl-aqkm6asdvs2224n84.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チェーンを2回サブスクライブすると、チェーンの各サブスクリプションが2回呼び出されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> firstUser$ = http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
    .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]));<font></font>
<font></font>
firstUser$.subscribe(observer(<span class="hljs-string">'subscriber-1'</span>));<font></font>
firstUser$.subscribe(observer(<span class="hljs-string">'subscriber-2'</span>));<font></font>
</code></pre><br>
<img src="https://habrastorage.org/webt/kg/c2/iw/kgc2iwjualmgnqh_kcaxfe4c45g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、この行動が私たちに合わない場合はどうなりますか？</font><font style="vertical-align: inherit;">サブスクリプション関数を1回だけ呼び出したい場合、サブスクリプションはいくつあるでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、1つのhttpリクエストを作成し、その結果をすべてのサブスクライバーに使用したい場合はどうでしょうか。</font><font style="vertical-align: inherit;">この場合、あなたは必要</font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">科目</font></font></h2><br>
<code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームとサブスクライバーの両方です。</font><font style="vertical-align: inherit;">フロー-メソッドがあるため</font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、サブスクライバー-サブスクライバーインターフェイスを実装するため-メソッド</font></font><code>next(), error(), complete().</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それを記述しましょう。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>{<font></font>
  <span class="hljs-keyword">constructor</span>() {<font></font>
    <span class="hljs-keyword">super</span>();<font></font>
    <span class="hljs-keyword">this</span>.observers = [];<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">this</span>.observers.push(observer);<font></font>
  }<font></font>
<font></font>
  next(value) {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.next(value));<font></font>
  }<font></font>
<font></font>
  error(error) {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.error(error));<font></font>
  }<font></font>
<font></font>
  complete() {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.complete());<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールドストリームと多くのサブスクライバー間の中間として機能できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を次のように変更します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> Subject();<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]))<font></font>
  .subscribe(subject);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
呼び出されると</font></font><code>subject.subscribe(someFn)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、1つの単純な操作（</font></font><code>subject.observers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">を配列に追加する）のみが実行され</font></font><code>someFn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、</font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブスクライバーとして</font><font style="vertical-align: inherit;">も</font><font style="vertical-align: inherit;">動作するので、元のストリームにサブスクライブできます。</font><font style="vertical-align: inherit;">元のスレッドが値を発行すると</font></font><code>subject.next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その</font><font style="vertical-align: inherit;">値が呼び出され</font><font style="vertical-align: inherit;">、この値が各サブスクライバーに転送されます</font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、サブスクリプションの元のコールバックが1回実行され、1つのhttp-requestのみが実行されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/8h/ld/hk8hld-xyjtum5d3srqpquhaqic.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パーティー遅刻者</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サインアップする前に元のストリームがすでに機能していた場合はどうなりますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の例ではこれを表示することはできません。httpは非同期であるため、直後にサブスクライブしても、値はサブスクリプションの後に続きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成関数を簡単に作成しましょう</font></font><code>of</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs"><font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">of</span>(<span class="hljs-params">...values</span>) </span>{<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
    log(<span class="hljs-string">'Observable execution: of'</span>);<font></font>
    values.forEach(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> observer.next(value));<font></font>
  });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手段によって作成されたストリーム</font></font><code>of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、値を同期して次々に放出します。</font><font style="vertical-align: inherit;">の登録が</font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完了してから登録を行います。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> Subject();<font></font>
<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).subscribe(subject);<font></font>
<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
購読者は何も受け取っていません。どうして？私たちの実装は「遅い」加入者をサポートしていません。からの元のストリーム</font></font><code>of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が値</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">発行する</font><font style="vertical-align: inherit;">とき</font><font style="vertical-align: inherit;">、サブスクライバーはまだ登録されていません。これらの値はどこにも行きません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angularの実際の例では、ソースストリームは機能している可能性がありますが、コンポーネントはまだページに存在していません。また、コンポーネントが表示されると、ソースにサブスクライブしますが、すでに渡された値を受け取りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題を解決する1つの方法はこれ</font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。私たちはそのバージョンの概要を示し、それがどのように機能するかを確認します。</font></font><br>
<br>
<pre><code class="javascript hljs"><font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplaySubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span> </span>{<font></font>
  <span class="hljs-keyword">constructor</span>(bufferSize) {<font></font>
    <span class="hljs-keyword">super</span>();<font></font>
    <span class="hljs-keyword">this</span>.observers = [];<font></font>
    <span class="hljs-keyword">this</span>.bufferSize = bufferSize;<font></font>
    <span class="hljs-keyword">this</span>.buffer = [];<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">this</span>.buffer.forEach(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> observer.next(val));<font></font>
    <span class="hljs-keyword">this</span>.observers.push(observer);<font></font>
  }<font></font>
<font></font>
  next(value) {<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.buffer.length === <span class="hljs-keyword">this</span>.bufferSize) {<font></font>
      <span class="hljs-keyword">this</span>.buffer.shift();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">this</span>.buffer.push(value);<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.next(value));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンセプトはシンプルです。名前が示すように、</font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは</font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古い値をすべての新しいサブスクライバーに再現できる</font><font style="vertical-align: inherit;">特別な</font><font style="vertical-align: inherit;">ものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リリースされた各値は現在のすべてのサブスクライバーに転送され、将来のサブスクライバーのために保存されます</font></font><code>bufferSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">バッファーサイズは</font><font style="vertical-align: inherit;">コンストラクターで設定されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の例をで書き換え</font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> ReplaySubject(<span class="hljs-number">3</span>);<font></font>
<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).subscribe(subject);<font></font>
<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果が変わりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブスクリプションが遅れたにもかかわらず、私たちはそれらすべてをキャッチしました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sg/xv/y1/sgxvy1flevy8totuzlejeiphvm0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要約すると、目的</font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はすべてのサブスクライバーに値を配布し、将来の「遅い」サブスクライバーのためにそれらをキャッシュすることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に進む前に、独自の実装を作成することをお勧めします</font></font><code>BehaviorSubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">完成したコードは記事の最後にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、いよいよマルチキャストオペレーターに移ります。</font><font style="vertical-align: inherit;">上記の例があなたがそれらをより速く理解するのに役立つことを願っています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチキャストオペレーター</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチキャストと接続</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オペレーター</font></font><code>multicast() </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、複数のサブスクライバーにソースストリームを発行</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">ために</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">します。</font></font><br>
<br>
<pre><code class="javascript hljs"><font></font>
<span class="hljs-keyword">import</span> { interval, Subject, ConnectableObservable } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;<font></font>
<span class="hljs-keyword">import</span> { multicast } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> Subject())<font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">const</span> observer1 = connectableObservable.subscribe(log);<font></font>
<span class="hljs-keyword">const</span> observer2 = connectableObservable.subscribe(log);<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableSubscription = (connectableObservable <span class="hljs-keyword">as</span> ConnectableObservable&lt;any&gt;)<font></font>
  .connect();<font></font>
</code></pre><br>
<code>multicast</code><font style="vertical-align: inherit;"></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを持つ</font><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">返します</font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">その目的は、受信したサブジェクトをソースストリームにサブスクライブすることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッド</font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">により、元のスレッドの実行をいつ開始するかを決定できます。</font><font style="vertical-align: inherit;">心に留めておくべき瞬間があります-あなたがする必要があるソースからの退会をするために：</font></font><br>
<br>
<pre><code class="javascript hljs">connectableSubscription.unsubscribe();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンプルに限らない</font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">代わりに、次のような派生クラスを使用できます</font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { interval, ReplaySubject, ConnectableObservable } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;<font></font>
<span class="hljs-keyword">import</span> { multicast } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> ReplaySubject(<span class="hljs-number">1</span>))<font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">const</span> observer1 = connectableObservable.subscribe(log);<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
  <span class="hljs-comment">// Late subscriber</span><font></font>
  connectableObservable.subscribe(log);<font></font>
}, <span class="hljs-number">3000</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectable = (connectableObservable <span class="hljs-keyword">as</span> ConnectableObservable&lt;any&gt;).connect();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードから、内部で何が起こるかを推測できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を使用すると</font></font><code>multicast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、を転送できるだけでなく</font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、毎回新しい関数を返すファクトリ関数も</font><font style="vertical-align: inherit;">転送でき</font><font style="vertical-align: inherit;">ます</font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再利用は既に完了しており</font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ファクトリー機能はこの問題を解決できません。</font></font><br>
<br>
<pre><code class="javascript hljs">interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> Subject())<font></font>
)<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再発見</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演算子を使用するときは</font><font style="vertical-align: inherit;">、元のオブザーバブルの実行を開始</font></font><code>multicast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する呼び出し</font></font><code>connect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">担当し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">さらに、メモリリークの可能性を監視し、から手動で登録解除する必要があり</font></font><code>ConnectableSubscription</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセスの自動化により、エラーが回避され、コードが簡素化されます。</font><font style="vertical-align: inherit;">親切なRxJS開発者は私たちのためにそれを考え、</font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーター</font><font style="vertical-align: inherit;">を作成しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブスクリプションをカウントし、最初のものが表示されると、を呼び出します</font></font><code>connect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">購読します。</font><font style="vertical-align: inherit;">減少してゼロに戻ると、応答が呼び出されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> Subject()),<font></font>
  refCount()<font></font>
)<font></font>
 <font></font>
<span class="hljs-comment">// refCount === 1 =&gt; source.subscribe();</span><font></font>
<span class="hljs-keyword">const</span> observer1 = source.subscribe(log);<font></font>
<font></font>
<span class="hljs-comment">// refCount === 2</span><font></font>
<span class="hljs-keyword">const</span> observer2 = source.subscribe(log);<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
  <span class="hljs-comment">// refCount - 1</span><font></font>
  observer1.unsubscribe();<font></font>
  <span class="hljs-comment">// refCount - 1</span><font></font>
  observer2.unsubscribe();<font></font>
  <span class="hljs-comment">// refCount === 0 =&gt; source.unsubcribe();</span><font></font>
}, <span class="hljs-number">3000</span>)<font></font>
</code></pre><br><font style="vertical-align: inherit;"></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常のオブザーバブルを取得した</font><font style="vertical-align: inherit;">
後で</font><font style="vertical-align: inherit;">はない</font><font style="vertical-align: inherit;">ことに注意してください</font></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公開とそのオプション</font></font></h3><br>
<code>multicast() + Subject + refCount()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはRxJSでのかなり典型的なケースであり、開発者はそれを単一のオペレーターに減らしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どんなオプションがあるか見てみましょう。</font></font><br>
<br>
<ul>
<li><code>publish()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 同等 </font></font><code>multicast(() =&gt; new Subject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publish()<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishBehavior()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 同等 </font></font><code>multicast(new BehaviorSubject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishBehavior(<span class="hljs-number">100</span>)<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishReplay()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 同等 </font></font><code>multicast(() =&gt; new ReplaySubject(x))</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishReplay(<span class="hljs-number">3</span>)<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishLast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 同等 </font></font><code>multicast(new AsyncSubject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  take(<span class="hljs-number">2</span>),<font></font>
  publishLast()<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>share()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 同等 </font></font><code>multicast(() =&gt; new Subject()) + refCount()</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  share()<font></font>
)<font></font>
</code></pre><br>
</li>
<li><code>shareReplay(bufferSize) </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはを使用するマルチキャストオペレータです</font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">彼には内部がなく</font></font><code>multicast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、彼の結果は観察できません</font></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それがあっても</font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なくて</font><font style="vertical-align: inherit;">も使用できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ここに両方の​​オプションがあります：</font></font><br>
<br>
<pre><code class="javascript hljs">interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay({ <span class="hljs-attr">refCount</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bufferSize</span>: <span class="hljs-number">1</span> })<font></font>
)<font></font>
<font></font>
interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay(<span class="hljs-number">1</span>)<font></font>
)<font></font>
</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
と</font></font><code>shareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼ばれる</font><font style="vertical-align: inherit;">とき</font></font><code>{ refCount: false }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はを呼ぶようなもの</font></font><code>shareReplay(x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、参照カウントはありません。</font><font style="vertical-align: inherit;">つまり、元のストリームが完了するまで、</font></font><code>shareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それ自体に最終的なサブスクライバーがあるかどうかに関係なく</font><font style="vertical-align: inherit;">、元のストリームが</font><font style="vertical-align: inherit;">サブスクライブされます。</font><font style="vertical-align: inherit;">すべての新しいサブスクライバーは、最後のx値を受け取ります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shareReplayとpublishReplay + refCount</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見</font><font style="vertical-align: inherit;">、それは</font></font><code>shareReplay({ refCount: true, bufferSize: X })</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じです</font></font><code>publishReplay(X) + refCount() </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、これは完全に真実ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
類似点と相違点を見てみましょう。</font><font style="vertical-align: inherit;">サブスクライバーの数に基づいて元のストリームをサブスクライブおよびサブスクライブ解除</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
するという同じ動作が</font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あります。</font><font style="vertical-align: inherit;">また、元のストリームが完了したときにも同じように反応します。すべての新しいサブスクライバーは、最後のX個の値を受け取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、元のストリームがまだファイナライズされていない場合、この場合は次のようになります</font></font><code>publishReplay(X) + refCount()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-すべての新しいサブスクライバーはバッファーからX値を受け取り、同じ値を使用して再署名され</font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、</font></font><code>shareReplay({ refCount: true, bufferSize: 1 })</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後のX値</font><font style="vertical-align: inherit;">を使用する</font><font style="vertical-align: inherit;">と、内部では</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値が作成され、</font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それを使用してソースを再サブスクライブするため、</font><font style="vertical-align: inherit;">X値を取得できません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを示す例：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishReplay(<span class="hljs-number">1</span>),<font></font>
  refCount()<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">const</span> one = source.subscribe(observer(<span class="hljs-string">'subcriber-1'</span>));<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
  one.unsubscribe();<font></font>
 <font></font>
  <span class="hljs-comment">// This subscriber will get the last emitted values from the source</span><font></font>
  <span class="hljs-keyword">const</span> two = source.subscribe(observer(<span class="hljs-string">'subcriber-2'</span>));<font></font>
}, <span class="hljs-number">3000</span>);</code></pre><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay({ <span class="hljs-attr">refCount</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bufferSize</span>: <span class="hljs-number">1</span> })<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">const</span> one = source.subscribe(observer(<span class="hljs-string">'subcriber-1'</span>));<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
  one.unsubscribe();<font></font>
  <font></font>
  <span class="hljs-comment">// This subscriber will NOT get the last emitted values from the source</span><font></font>
  <span class="hljs-keyword">const</span> two = source.subscribe(observer(<span class="hljs-string">'subcriber-2'</span>));<font></font>
}, <span class="hljs-number">3000</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/6i/j1/ih/6ij1ihusgtdo_avliuz4tk4gsca.png"><br>
<br>
<img src="https://habrastorage.org/webt/ew/nk/6q/ewnk6q0ems5ysw574aa7unvy2jc.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angularの実際の例</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
調査したマルチキャストオペレーターを戦闘条件で使用する方法を見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェアを使う</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元のストリームからのデータを必要とするコンポーネントがあるとします。</font><font style="vertical-align: inherit;">これは、http要求、状態、またはその他の可能性があります。</font><font style="vertical-align: inherit;">また、フィルタリング、ソートなどのデータ操作も必要です。</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({<font></font>
  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><font></font><span class="hljs-string">
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;</span><font></font><span class="hljs-string">
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{<font></font>
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、最初のユーザーのみを表示する別のコンポーネントが必要です。</font><font style="vertical-align: inherit;">ソースストリームをそのままサブスクライブすると、次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({<font></font>
  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><font></font><span class="hljs-string">
    &lt;user [user]="firstUser$ | async"&gt;&lt;/user&gt;</span><font></font><span class="hljs-string">
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;</span><font></font><span class="hljs-string">
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{<font></font>
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
  firstUser$: Observable&lt;User&gt;;<font></font>
  <font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
    );<font></font>
    <font></font>
    <span class="hljs-keyword">this</span>.firstUser$ = <span class="hljs-keyword">this</span>.allUsers$.pipe(map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users[<span class="hljs-number">0</span>]));<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで2つのhttpリクエストがあり、ソートまたはフィルタリング操作が2回実行されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
適用します</font></font><code>share</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({<font></font>
  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><font></font><span class="hljs-string">
    &lt;user [user]="firstUser$ | async"&gt;&lt;/user&gt;</span><font></font><span class="hljs-string">
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;</span><font></font><span class="hljs-string">
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{<font></font>
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
  firstUser$: Observable&lt;User&gt;;<font></font>
  <font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
      share()<font></font>
    );<font></font>
    <font></font>
    <span class="hljs-keyword">this</span>.firstUser$ = <span class="hljs-keyword">this</span>.allUsers$.pipe(map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users[<span class="hljs-number">0</span>]));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは彼が</font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースを購読</font><font style="vertical-align: inherit;">する新しい</font><font style="vertical-align: inherit;">もの</font><font style="vertical-align: inherit;">を作成することをすでに知っています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ソースが発信すると、サブジェクトはこの値をそのすべてのサブスクライバーに渡します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は解決され、</font></font><code>firstUser$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブスクライブする</font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、元のストリームを直接ではなく、</font><font style="vertical-align: inherit;">内部</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">サブスクライブしました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShareReplayの使用</font></font></h3><br>
<code>ShareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後のX値を放出、キャッシュ、および繰り返す必要がある場合に適用されます。</font><font style="vertical-align: inherit;">典型的な例は、httpリクエストを実行するシングルトンサービスです。</font></font><br>
<br>
<pre><code class="javascript hljs"><font></font>
@Injectable({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlogService</span> </span>{<font></font>
  posts$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://jsonplaceholder.typicode.com/posts'</span>)<font></font>
              .pipe(shareReplay(<span class="hljs-number">1</span>));<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在または将来データを要求するコンポーネントの数は関係ありません。http要求は1つだけであり、結果は内部バッファに保存され</font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブスクライバーがいないため、未完了のリクエストをキャンセルする必要がある場合があります</font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">その場合は、申請する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全なコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja490976/index.html">DUMP2020のフロントエンドセクション：フルハウスが再び存在することを先取りします。昨年のトップレポートとこれのトピック</a></li>
<li><a href="../ja490978/index.html">SecureCRTを使用して複数のデバイスに同時にコマンドを送信する</a></li>
<li><a href="../ja490982/index.html">雇用主への悪いアドバイス。開発者と「適切に」対話する方法</a></li>
<li><a href="../ja490984/index.html">Nizhny Novgorod Android mitapの資料。MotionLayout、Kotlin Coroutines、CI / CDインフラストラクチャおよび設計システム</a></li>
<li><a href="../ja490986/index.html">KOMPAS-3Dで動作するAMD Ryzenプロセッサーのテスト</a></li>
<li><a href="../ja490992/index.html">価格割引管理：例としてガソリンスタンドの効果を定量化するためのモデル</a></li>
<li><a href="../ja490996/index.html">レスキューをやめろ！「医療用マスク」の自己組み立ての手順</a></li>
<li><a href="../ja490998/index.html">SIBURでのハードウェアテスト</a></li>
<li><a href="../ja491000/index.html">JavaScriptを使用しないSelect-Optionのスタイル設定（ほとんど）</a></li>
<li><a href="../ja491006/index.html">Unity3DのパスとしてのIntel NUC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>