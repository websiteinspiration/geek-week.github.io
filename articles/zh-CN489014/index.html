<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚃 🦄 🛎️ 《完美算法》一书。贪婪算法和动态规划» 🐑 👇🏽 👩‍❤️‍👩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您好，habrozhiteli！在新书中，Tim Rafgarden讨论了贪婪算法（规划问题，最小生成树，聚类，霍夫曼代码）和动态编程（背包问题，序列比对，最短路径，最佳搜索树）。这篇文章摘录了“开发贪婪算法”，
 
 贪婪算法似乎非常适合计划工作的任务，从而最大程度地减少了完成时间的加权总和。输出...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>《完美算法》一书。贪婪算法和动态规划»</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489014/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/zt/4e/yp/zt4eypq-gybnz_assyf-7wpz3vu.jpeg" align="left" alt="图片"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您好，habrozhiteli！在新书中，Tim Rafgarden讨论了贪婪算法（规划问题，最小生成树，聚类，霍夫曼代码）和动态编程（背包问题，序列比对，最短路径，最佳搜索树）。这篇文章摘录了“开发贪婪算法”，</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
贪婪算法似乎非常适合计划工作的任务，从而最大程度地减少了完成时间的加权总和。输出具有迭代结构，其中一次处理一个工作。为什么不使用贪婪算法来迭代确定下一个工作？</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们计划的第一步是解决一般问题的两种特殊情况。</font><font style="vertical-align: inherit;">我们针对这些情况的解决方案将显示一般情况下贪婪算法的外观。</font><font style="vertical-align: inherit;">然后，我们将域缩小为一个候选算法，并证明正是该候选者才能正确解决问题。</font><font style="vertical-align: inherit;">我们记忆该算法的过程比记忆本身更重要。</font><font style="vertical-align: inherit;">此过程是可重复的，您可以在自己的应用程序中使用它。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13.3.1。</font><font style="vertical-align: inherit;">两种特殊情况</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们假设，对于最小化完成日期的加权总和的任务，实际上，有一个正确的贪婪算法。</font><font style="vertical-align: inherit;">如果我们假设所有作品的长度相同（但权重可能不同），或者相反，权重相同（但长度可能不同），会是什么样呢？</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">练习13.2 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（1）如果所有工作时间都相同，我们是否应该为体重减轻或增加的工作提前计划？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（2）如果所有工作权重都相同，我们应该早些计划更长或更短的工作吗？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
a）更多；</font><font style="vertical-align: inherit;">短</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b）较小；</font><font style="vertical-align: inherit;">短</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c）中放大; </font><font style="vertical-align: inherit;">长</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
d）少; </font><font style="vertical-align: inherit;">long </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（有关解决方案和解释，请参阅第13.3.3节。）</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13.3.2。</font><font style="vertical-align: inherit;">决斗贪婪</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，作品可能具有不同的权重和不同的长度。只要我们有两条经验法则（宁愿较短的工作和较高的权重的工作）有幸能同时完成几项工作，我们就会知道哪个计划最先（较高的权重较短）。但是，如果这两个规则给出了相互矛盾的建议怎么办？一件重量轻的短期作业和一件重量大的长期作业该怎么办？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以正常工作的最简单的贪婪算法是什么？每个工作都有两个参数，算法应同时考虑两个参数。最好的选择是制定一个公式，将每件作品的长度和重量汇总为一个标记（贡献），这样可以保证从最高标记到最低标记的规划工作将加权完成日期的数量减至最少。如果存在这样的公式，那么从我们的两种特殊情况来看，它必须具有两个属性：（i）保持固定的长度，它应该随着工作的重量而增加； （ii）保持重量不变，应从作品的长度开始减少（记得标记越高越好）。花一分钟的时间集思广益地讨论具有这两个属性的几个公式。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/-d/il/vm/-dilvmx9eulm9e96z9avlykyavg.jpeg" alt="图片"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它们之间的区别也许是最简单的功能，其重量增加而长度减小，它们之间的区别是：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作品标记的第1号提案。</font></font><img src="https://habrastorage.org/webt/rx/du/mi/rxdumiqofl604y3nzq_xoihf_su.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
标出的标记可以是负数，但这不会对从最高到最低标记的作品的连贯构造构成任何障碍。 。</font><font style="vertical-align: inherit;">但是，还有许多其他选择。</font><font style="vertical-align: inherit;">例如，两个参数的比率是另一个候选：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用于标记作品的第2号提案，</font></font><img src="https://habrastorage.org/webt/wc/es/rk/wcesrkmtu6wqde7gcbjhvqb3rts.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这两个用于计算标记的函数导致两种不同的贪婪算法。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GREEDY DIFFERENCE GREEDYDIFF </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
按降序计划工作</font></font><img src="https://habrastorage.org/webt/e-/r2/8x/e-r28xu0dqhniboc96n0xh7mui4.jpeg" alt="图片"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（任意破坏值的重合）。</font></font></blockquote><blockquote>  GREEDYRATIO<br>
<br>
     <img src="https://habrastorage.org/webt/ww/p_/vg/wwp_vgagganqj0q5ztncmnt-u04.jpeg" alt="图片"><br>
(   ).</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们的第一个案例研究已经说明了贪婪范式的第一个主题（第13.1.2节）：针对该任务提出几种竞争性贪婪算法通常并不困难。但是，两种算法中的哪一种（如果有）是正确的？排除其中一个的快速方法是找到一个实例，其中两个算法显示具有不同目标函数值的不同时间表。对于本示例中结果较差的任何算法，我们可以得出结论，它并不总是最优的。在两个具有相同重量或相同长度的特殊情况下，两种算法均能正确执行。排除其中一个最简单的例子可能是某项任务的实例，其中两件作品的权重和长度不同，结果，两种算法都计划以相反的顺序工作。也就是说，我们正在寻找两个作品，它们的顺序不同是相对于它们的顺序相反。例：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/bk/2e/i8/bk2ei8vmvkm0p-poglz62vgncbw.jpeg" alt="图片"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一件作品的比例较大，</font></font><img src="https://habrastorage.org/webt/mm/k-/fk/mmk-fksrqtkrdi-k3reiw6zqgwk.jpeg" alt="图片"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但差异较大（–2与–1）。</font><font style="vertical-align: inherit;">因此，算法首先</font></font><code>GreedyDiff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划第二项工作，而算法</font></font><code>GreedyRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">则相反。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">练习13.3 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分别由</font></font><code>GreedyDiff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">演算法推导出的时间表中加权完成日期的总和是</font></font><code>GreedyRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多少？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
a）22和23 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b）23和22 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c）17和17 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
d）17和11 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（有关解决方案和说明，请参阅第13.3.3节。）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过将算法排除在</font></font><code>GreedyDiff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进一步考虑</font><font style="vertical-align: inherit;">之外，我们向前迈进了</font><font style="vertical-align: inherit;">一步。但是，练习13.3的结果并不能直接导致该算法</font></font><code>GreedyRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">始终是最优的。据我们所知，在其他情况下该算法会产生非最佳计划。您应该始终对没有随附正确性证明的算法持怀疑态度，即使该算法在多个测试案例中做得正确，并且对贪婪算法也极为怀疑。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的案例中，</font></font><code>GreedyRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上可以保证</font><font style="vertical-align: inherit;">算法</font><font style="vertical-align: inherit;">将加权完成日期的数量减到最少。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定理13.1（算法的正确性</font></font><code>GreedyRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于每组正工作权重</font></font><img src="https://habrastorage.org/webt/x2/pm/zv/x2pmzvo-1kgq9_qmlmve49gp_e0.jpeg" alt="图片"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果作业长度为正数，则该</font></font><img src="https://habrastorage.org/webt/hb/ez/xz/hbezxznweju_oegojdnbertn1ag.jpeg" alt="图片"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法</font></font><code>GreedyRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会显示一个计划，该计划的加权完成日期的总和可能最小。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
这种逻辑上的陈述并不明显，在没有收到证据的情况下您不应该信任他。根据贪婪范式的第三个主题（第13.1.2节），该证明占据了下一部分的整个内容。</font></font><br>
<blockquote> ,   . .<br>
<br>
         .  —   ,      (         ).  —  ,       , ,   .    «» (       )    ,       .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
贪婪范例的其余主题是运行时分析的简便性（第13.1.2节）。</font><font style="vertical-align: inherit;">当然是这里。</font><font style="vertical-align: inherit;">GreedyRatio算法仅按关系对作业进行排序，这需要O（n log n）时间，其中n是输入中的作业数（请参阅第24页脚注1）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13.3.3。</font><font style="vertical-align: inherit;">练习题13.2–13.3</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">练习13.2的解决方案</font></font></b><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确答案是：（a）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。首先，假设所有n个工作都具有相同的长度（例如1）。然后每个时间表都具有完全相同的最后期限集-{1,2,3，...，n}-唯一的问题是得到什么样的工作完成日期和截止日期是什么？我们关于工作权重的语义当然意味着工作量更大的工作应获得更短的完成时间，这是事实。例如，您不想计划权重为10分之三（期限为3）的工作，而权重为20分之五（期限为5）的工作；您最好改变这两个作品的位置，这样可以将加权截止日期的总和减少20（如您所见）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二种情况是，所有作品的重量都相同，但略薄一些。在这里，您希望优先选择较短的工作。例如，考虑两个单位重量为1和2的作业。如果您首先计划一个较短的工作，那么完成期限将是1和3，总数为4。反之，期限是2和3，结果最差5。通常，计划的由于所有工作都必须等待第一项工作的完成，因此第一项工作对所有工作的完成时间都有贡献。在所有条件都相同的情况下，首先计划最短的工作可以最大程度地减少这种负面影响。</font><b><font style="vertical-align: inherit;">练习13.3的解决方案</font></b><font style="vertical-align: inherit;">第二工作对除第一工作之外的所有完成日期都有贡献，因此，第二最短的工作应在下一个计划中，依此类推。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确答案是：（b）。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该算法首先</font></font><code>GreedyDiff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划第二项工作。</font><font style="vertical-align: inherit;">完成这项工作</font></font><img src="https://habrastorage.org/webt/8g/bc/eb/8gbcebnbsfr9eofdsf1znkmtihs.jpeg" alt="图片"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的截止日期</font><font style="vertical-align: inherit;">是，</font><font style="vertical-align: inherit;">而完成另一项工作的截止日期是</font></font><img src="https://habrastorage.org/webt/om/qi/nm/omqinmdtfr7xnkccaazw3h63eb0.jpeg" alt="图片"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加权的完成截止时间之和</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/98/68/gz98683gqg4kf6uotkfcs0loxui.jpeg" alt="图片"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该算法</font></font><code>GreedyRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先计划第一个工作，从而导致最后期限</font></font><img src="https://habrastorage.org/webt/rl/5h/bw/rl5hbwytgo1arwgetzmxqavafw0.jpeg" alt="图片"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
和加权的最后期限之和等于</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ta/6f/qx/ta6fqxxmfcxvmhsyajnc_6tri0i.jpeg" alt="图片"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于该算法</font></font><code>GreedyDiff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无法</font><font style="vertical-align: inherit;">为该示例</font><font style="vertical-align: inherit;">计算最佳计划，因此它并不总是正确的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»有关这本书的更多信息，请</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问出版商的网站</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font><font style="vertical-align: inherit;">
Khabrozhiteley的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">节录</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优惠券可享受25％的折扣- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
支付纸质版本的费用后，就会通过电子邮件发送电子图书。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN489002/index.html">分布式轮对注册表：使用Hyperledger Fabric的经验</a></li>
<li><a href="../zh-CN489004/index.html">带有光盘拨号器的手机</a></li>
<li><a href="../zh-CN489008/index.html">使用Hobot框架在复杂的聊天机器人中进行路由</a></li>
<li><a href="../zh-CN489010/index.html">我们与语言学，个性化，peddesign，ML等项目共享俄罗斯最大的在线培训数据层</a></li>
<li><a href="../zh-CN489012/index.html">Google Cloud Spanner：好，坏，邪恶</a></li>
<li><a href="../zh-CN489016/index.html">德国格里夫·格里夫（German Gref）：“我们试图组织有关AGI的讨论，但没有一个自尊的科学家来参加”</a></li>
<li><a href="../zh-CN489020/index.html">一种恶意研究</a></li>
<li><a href="../zh-CN489022/index.html">将RabbitMQ与MonsterMQ结合使用第2部分</a></li>
<li><a href="../zh-CN489024/index.html">Webix JavaScript库通过初学者的眼光。第5部分。在用户端使用数据</a></li>
<li><a href="../zh-CN489026/index.html">更改Google AdSense算法可能会导致网站所有者和网站管理员</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>