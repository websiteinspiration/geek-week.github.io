<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📷 🤜🏿 🈁 在没有公共IP的情况下安全访问智能家居（第2部分） 🎅🏽 ☑️ 🌚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="介绍
 在第一部分中，我写了关于问题的陈述以及愿望清单的转变方式。最后，我决定使用OpenVPN，但是由于我决定在Docker容器中运行所有内容，事实证明并非如此简单。
 
 我必须立即说，以后我再次​​重做所有操作，结果我拒绝了外部VPS。但是，由于所有内容都在容器中，因此在此过程中，我遇到了许多...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>在没有公共IP的情况下安全访问智能家居（第2部分）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505412/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第一部分中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我写了关于问题的陈述以及愿望清单的转变方式。</font><font style="vertical-align: inherit;">最后，我决定使用OpenVPN，但是由于我决定在Docker容器中运行所有内容，事实证明并非如此简单。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我必须立即说，以后我再次​​重做所有操作，结果我拒绝了外部VPS。</font><font style="vertical-align: inherit;">但是，由于所有内容都在容器中，因此在此过程中，我遇到了许多有趣的功能，将对此进行讨论。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将仅描述关键点。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioBroker</font></font></h3><br>
<pre><code class="plaintext hljs">docker run -d --name iobhost  --net=host -v /opt/iobroker/:/opt/iobroker/ --device=/dev/ttyACM0 --env-file /opt/ioBroker_env.list --restart=always buanet/iobroker:latest
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我具有MiHome网关，因此已连接传感器，甚至还设置了一些我不想破坏的场景，因此我将ioBroker连接到了它。他看到了传感器，不必将它们重新绑定到Zigbee棒上（尽管也有，并且一些按钮已连接到它）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，为了使ioBroker与MiHome Gateway通信，并使用--net = host参数启动它。那些。它使用主机接口，无需指定要转发到容器的端口。没有这个，他就看不到网关，因为他通过组播工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
需要参数--device = / dev / ttyACM0才能将Zigbee USB记忆棒转发到容器。</font><font style="vertical-align: inherit;">同样在/opt/ioBroker_env.list中，我必须添加行USBDEVICES =“ / dev / ttyACM0”。</font><font style="vertical-align: inherit;">重要的是，在第一次启动容器时，当它看到一个空目录并开始其初始配置时，应该出现此行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，您可以稍后对其进行配置，但是您将不得不执行其他身体移动。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MQTT服务器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在一个外部VPS上，它发射了Eclipse蚊子。</font><font style="vertical-align: inherit;">首先，我通过发布“让我们加密”证书为他设置TLS。</font><font style="vertical-align: inherit;">然后他决定要求客户必须出示证书，然后再出示名称和密码（防止暴力破解）。</font><font style="vertical-align: inherit;">因此，我将其重新签名为自签名，以便客户端写出证书。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenVPN</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Docker Hub中使用了流行的图像。</font><font style="vertical-align: inherit;">对于服务器（VPS）kylemanna / openvpn。</font><font style="vertical-align: inherit;">对于客户端（安装ioBroker的家庭服务器）-ekristen / openvpn-client。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客制化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我不得不修补。</font><font style="vertical-align: inherit;">在此过程中，我觉得docker的网络方面很好，使用iptables，发现了一个新的方面，其中包括 </font><font style="vertical-align: inherit;">我以前没有业务的netplan。</font><font style="vertical-align: inherit;">因此，实际上，我决定写这篇文章。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPS服务器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过安装OpenVPN和配置，所有内容都是标准的，因为</font><font style="vertical-align: inherit;">它写</font><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://hub.docker.com/r/kylemanna/openvpn上</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我另外要做的是在VPS和家庭服务器上引起额外的环回。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/etc/netplan/01-netcfg.yaml</font></font></i><br>
<br>
<pre><code class="plaintext hljs">	# This file describes the network interfaces available on your system<font></font>
	# For more information, see netplan(5).<font></font>
	network:<font></font>
	  version: 2<font></font>
	  renderer: networkd<font></font>
	  &lt;b&gt;ethernets:<font></font>
	    lo:<font></font>
	      renderer: networkd<font></font>
	      match:<font></font>
	        name: lo<font></font>
	      addresses:<font></font>
        - 192.168.16.1/32&lt;/b&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
粗体突出显示“添加剂”。尽管空格非常重要，但似乎没有显示空格。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
示例中的地址将192.168.6.0用于家庭网络，并将192.168.16.0用于环回。我会尽量在任何地方都不会犯错。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">openvpn.conf中</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加</font></font><br>
<br>
<pre><code class="plaintext hljs">server 192.168.16.192 255.255.255.192<font></font>
push "dhcp-option DNS 192.168.16.6"<font></font>
push "route 192.168.16.0 255.255.255.128"<font></font>
client-to-client<font></font>
client-config-dir       /etc/openvpn/ccd/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我特意从192.168.16.0/25进行了环回，并从192.168.16.128/25向客户端提供了地址，以便随后可以使用单个网格192.168.16.0/24配置iptables中的解析规则。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，VPS的环回为192.168.16.1，上面有mqtt。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
家用服务器的地址为192.168.16.6。有iobroker，也称为dns，用于家庭客户端，并重新定义了用于从家庭网络或通过VPN连接的多个域名。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
到处都有从网络注册他的“真实” IP的想法。输入ccd / iobroker以指定</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iroute 192.168.6.6 255.255.255.255</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，显然，这是来自家用笔记本电脑WiFi接口上网络地址的事实，在许多情况下，它是默认网关，因此存在故障。包括智能手机。而且我希望家庭网络既可以与活跃的客户一起工作，也可以与他在一起。而且，我不必疯狂地断开客户端的连接，而回到家中就可以访问其他资源。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我将该服务器及其容器配置为始终与环回交互，而不管VPN是否处于活动状态。和相同的地址正在解决。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所以在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CCD / iobroker</font></font></i><br>
<br>
<pre><code class="plaintext hljs">iroute 192.168.16.6 255.255.255.255</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，所有VPN客户端都知道可以通过VPN访问192.168.16.0/24网络。如果他们将数据包发送到192.168.16.1（环回VPS），则数据包被加密，进入openvpn容器，解密，默认路由到达172.17.0.1（默认容器中的默认网关），它到达主机，一切都很好。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如何从VPS主机“ ping” VPN客户端或访问地址为192.168.16.6（而不是其在OpenVPN容器内部的VPN隧道中的临时IP）的家庭服务器？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
显然，必须将网格192.168.16.0路由到OpenVPN容器。当然，我可以看到它是172.17.0.3。但是有一天它可能会改变。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果将OpenVPN直接部署在服务器上，而不是直接部署在容器中，则一切都将自行运行。</font><font style="vertical-align: inherit;">然后我不得不狡猾地做。</font><font style="vertical-align: inherit;">我创建了一个脚本，该脚本由系统中的最新版本制定，并放入其中：</font></font><br>
<br>
<pre><code class="plaintext hljs">ipaddr=$(docker inspect -f '{{.NetworkSettings.IPAddress}}' vpn-client)<font></font>
route add -net 192.168.16.0/24 gw $ipaddr</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那些。</font><font style="vertical-align: inherit;">通过docker inspect，我找出了运行容器的IP地址，然后以通常的方式将网格路由到它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与通常的rc.local不同，我不得不用google搜索它，但是实际上如何使脚本最后运行。</font><font style="vertical-align: inherit;">这是一个简短的说明：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建文件</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/etc/systemd/system/custom.target</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">[Unit] <font></font>
Description=My Custom Target<font></font>
Requires=multi-user.target<font></font>
After=multi-user.target<font></font>
AllowIsolate=yes<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建文件</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/etc/systemd/system/last_command.service</font></font></i> <br>
<br>
<pre><code class="plaintext hljs">[Unit]<font></font>
Description=My custom command<font></font>
After=multi-user.target<font></font>
[Service]<font></font>
Type=simple<font></font>
ExecStart=/usr/local/bin/my_last_command.sh<font></font>
[Install]<font></font>
WantedBy=custom.target<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建目录</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/etc/systemd/system/custom.target.wants</font></font></i><br>
<br>
<pre><code class="plaintext hljs">ln -s /etc/systemd/system/last_command.service \   /etc/systemd/system/custom.target.wants/last_command.service<font></font>
systemctl daemon-reload<font></font>
systemctl set-default custom.target</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果要立即启动而不等待重新启动，请执行以下操作：systemctl孤立custom.target </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，在重新启动之后</font><font style="vertical-align: inherit;">，ExecStart中描述的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/usr/local/bin/my_last_command.sh</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件将是最后一个启动</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iptables</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在mqtt服务器上，我提出了2个端口：具有TLS和身份验证的8883，可从Internet访问以用于远程传感器。是的，我自己可以以某种方式连接MQTT Explorer并检查内容和方式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1883已经没有TLS，仅需要用户名和密码。需要家用Sonoff rfBridge，而TLS不知道如何。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这并不可怕，因为来自家庭的流量将通过iobroker进入服务器，该服务器是192.168.16.0的默认网关，它将把数据包转发到具有OpenVPN的容器等。但是，必须只允许从内部访问端口1883。那些。 iptables。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
标准方法是拒绝从任何地方访问此端口，然后遵循允许从内部网络访问的规则。</font></font><br>
<br>
<pre><code class="plaintext hljs">iptables -I INPUT -p tcp -m tcp --dport 1883 -j DROP<font></font>
iptables -I INPUT -s 172.17.0.0/24 -p tcp -m tcp --dport 1883 -j ACCEPT</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里的网格表示为172.17.0.0，因为从OpenVPN到“邻居”，我最终将其作为隐藏NAT（rfBridge来自WiFi网络的iobroker容器）而不是原始NAT。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样就可以了。</font><font style="vertical-align: inherit;">但是有细微差别。</font><font style="vertical-align: inherit;">我的端口1883被转发到mqtt容器。</font><font style="vertical-align: inherit;">而且，事实证明，iptables首先实现了DOCKER-USER链。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，使用此规则，允许访问端口1883成为阻止规则。</font><font style="vertical-align: inherit;">从Internet上，您也可以轻松连接到它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必须在DOCKER-USER链中创建一个阻止规则！</font></font><br>
<br>
<pre><code class="plaintext hljs">iptables -I DOCKR-USER -p tcp -m tcp --dport 1883 -j DROP<font></font>
iptables -I INPUT -s 172.17.0.0/24 -p tcp -m tcp --dport 1883 -j ACCEPT</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，由于某种原因允许较低级别的内部网络访问的较低层需要输入。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">家庭服务器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主要部分是相同的。</font><font style="vertical-align: inherit;">但是，尽管他是客户，但他必须将流量从WiFi网络（rfBridge）路由到VPS上的mqtt。</font><font style="vertical-align: inherit;">那些。</font><font style="vertical-align: inherit;">流量移动：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
rfBridge（192.168.6.8）-&gt; iobroker主机（192.168.6.6）-&gt; vpn-客户端容器（172.17.0。？）-&gt; VPS上的opevpn容器-&gt;回送VPS（192.168.16.1）-&gt; mqtt容器（端口1883）我们</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
允许带有客户端和环回的网格“转发”数据包：</font></font><br>
<br>
<pre><code class="plaintext hljs">iptables -A FORWARD -d 192.168.16.0/24 -j ACCEPT</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并转到容器详细信息。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任务1</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您还记得，我通过环回配置的子系统之间的交互。</font><font style="vertical-align: inherit;">那些。</font><font style="vertical-align: inherit;">必须将来自vpn-client的192.168.16.6上的数据包发送到主机（172.17.0.1），而不是VPN隧道。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您在正在运行的容器中运行此命令，则一切正常。</font><font style="vertical-align: inherit;">重新引导后，这将被忘记，但是您可以在iobroker.ovpn配置文件中指定</font></font><br>
<code>route 192.168.16.6 255.255.255.255 172.17.0.1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当容器启动时，openvpn将安装此路由。</font><font style="vertical-align: inherit;">这很容易以标准方式解决。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任务2</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
来自本地网络192.168.6.0的数据包（例如，来自rfBridge的数据包）将到达iobroker主机，然后转发到vpn-client容器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，我故意不在加密域中包括192.168.6.0网络，VPS上的OpenVPN容器不知道如何处理此网络。显而易见的解决方案是在vpn-client内部进行NAT，以便VPS上的数据包来自其地址。但是有细微差别。重新启动容器后如何保存所需的iptables命令？ iptables-persistent放置在那里并不容易。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，您可以组装带有添加剂的新容器。但是我不想，因为升级过程会变得更加复杂。与其“杀死并发射最新消息，而他从已安装的文件夹中拉出配置”，不如开始进行组装……不是我要与容器通信。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我决定“在容器启动之后，强制执行其中告诉iptables进行NAT的命令”。</font><font style="vertical-align: inherit;">我为此使用了团队</font></font><br>
<code>docker events --filter "container=vpn-client" --filter "event=start"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
她挂起并等待过滤器中指定的事件。</font><font style="vertical-align: inherit;">就我而言，启动容器。</font><font style="vertical-align: inherit;">之后，通过docker exec，我从其中的主机执行所需的命令。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，类似于VPS，我配置</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/usr/local/bin/my_last_command.sh</font></font></i><br>
<br>
<pre><code class="plaintext hljs">#!/bin/bash<font></font>
cont="vpn-client"<font></font>
ipaddr=$(docker inspect -f '{{.NetworkSettings.IPAddress}}' $cont)<font></font>
route add -net 192.168.16.0/24 gw $ipaddr<font></font>
for (( ; ; ))<font></font>
do<font></font>
  docker events --filter "container=$cont" --filter "event=start"<font></font>
  docker exec -it $cont iptables -t nat -I POSTROUTING -s 192.168.16.0/255.255.255.0 -j MASQUERADE<font></font>
  docker exec -it $cont iptables -t nat -I POSTROUTING -s 192.168.6.0/255.255.255.0 -j MASQUERADE<font></font>
done<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在某些示例中，将docker事件的输出传递到执行命令的awk输入。</font><font style="vertical-align: inherit;">但是对我来说，在事件发生之前“挂起”，执行命令并再次等待事件似乎更容易。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
老实说，我不想写这篇文章。我获得了一次有趣的经历，但结果却“不漂亮”，这太困难了，我不太喜欢。所以我再次重做了所有事情，总体上拒绝了VPS。但是，由于我答应了第二部分...此外，我对docker事件的方法印象深刻，因此我想与他人分享。我认为它将派上用场。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我决定这样做。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我无法通过反向代理发布vis，并且我可以轻松地从外部将mqtt作为服务使用，因此我不需要VPS来完成此任务。我也可以将固件用于OTA更新上载到主机，这也是有好处的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mqtt接受了wqtt.ru。</font><font style="vertical-align: inherit;">TLS是（密码以安全形式发送）。</font><font style="vertical-align: inherit;">速度非常好（mymqtthub为10ms而不是80ms）。</font><font style="vertical-align: inherit;">不需要重写为'$ device / &lt;crazy ID&gt; / events'的主题（如Yandex）。</font><font style="vertical-align: inherit;">那些。</font><font style="vertical-align: inherit;">在这种情况下，您可以轻松地跳到某个地方。</font><font style="vertical-align: inherit;">价格便宜（每年300卢布）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将OTA固件发布到现有的托管主机上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仍然可以通过Zerotier访问vis。</font><font style="vertical-align: inherit;">这是非常简单和方便的。</font><font style="vertical-align: inherit;">即使它们被打破，也不太可能为了我而看到我家的二氧化碳水平。</font><font style="vertical-align: inherit;">即使发生这种情况，也比他们个人打扰我快要成名了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切都很漂亮，可以正常运行，如果有必要，很容易进行更改，没有多余的服务器需要维护，我很满意。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN505394/index.html">上古：诺基亚E90，最新的传播者</a></li>
<li><a href="../zh-CN505398/index.html">Yandex工作的阴暗面</a></li>
<li><a href="../zh-CN505400/index.html">模型应该是什么样？</a></li>
<li><a href="../zh-CN505402/index.html">使用p5.js在3d对象上叠加2d纹理（第2部分-将图案应用于多维数据集）</a></li>
<li><a href="../zh-CN505404/index.html">用TED视频学习英语的最简单方法</a></li>
<li><a href="../zh-CN505416/index.html">中继器模式下的MikroTik-就像一二三三</a></li>
<li><a href="../zh-CN505418/index.html">[问题]您是否看到使用移动内容订阅的人？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>