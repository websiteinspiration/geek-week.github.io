<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèº üòô üë©üèº‚Äçüåæ √Årboles de expresi√≥n en C # usando un ejemplo de b√∫squeda de una derivada (Expression Tree Visitor vs Pattern match) üë´ üìü üë©üèø‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buen d√≠a. Los √°rboles de expresi√≥n, especialmente cuando se combinan con el patr√≥n Visitante, siempre han sido un tema bastante confuso. Por lo tanto,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>√Årboles de expresi√≥n en C # usando un ejemplo de b√∫squeda de una derivada (Expression Tree Visitor vs Pattern match)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486972/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buen d√≠a. </font><font style="vertical-align: inherit;">Los √°rboles de expresi√≥n, especialmente cuando se combinan con el patr√≥n Visitante, siempre han sido un tema bastante confuso. </font><font style="vertical-align: inherit;">Por lo tanto, mientras m√°s diversa informaci√≥n sobre este tema, m√°s ejemplos, m√°s f√°cil ser√° para aquellos interesados ‚Äã‚Äãen encontrar algo que sea claro y √∫til para ellos.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xt/6c/bf/xt6cbf1-gfkv4-64zs250n_-7pa.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El art√≠culo se construye como de costumbre: comienza con el marco conceptual y las definiciones y termina con ejemplos y formas de uso. </font><font style="vertical-align: inherit;">Tabla de contenido a continuaci√≥n. </font></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conceptos b√°sicos de los √°rboles de expresi√≥n </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaxis de los √°rboles de expresi√≥n </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipos de </font></font></a></b><font style="vertical-align: inherit;"><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">expresi√≥n </font></a></b></font><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coincidencia de </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">visitante Visitante ingenuo Visitante </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cl√°sico</font></font></a></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bueno, el objetivo no es imponer una soluci√≥n espec√≠fica o decir que una es mejor que la otra. </font><font style="vertical-align: inherit;">Propongo sacar conclusiones nosotros mismos, teniendo en cuenta todos los matices de su caso. </font><font style="vertical-align: inherit;">Expresar√© mi opini√≥n sobre mi ejemplo.</font></font><br>
<br>
<a name="basic"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Årboles de expresi√≥n</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los basicos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero debes lidiar con los √°rboles de expresi√≥n. Significan el tipo de expresi√≥n o cualquiera de sus herederos (se discutir√°n m√°s adelante). En el escenario habitual, las expresiones / algoritmos se presentan en forma de c√≥digo / instrucciones ejecutables con las que el usuario puede no tener mucho que hacer (principalmente ejecutar). El tipo de expresi√≥n le permite representar una expresi√≥n / algoritmo (generalmente lambdas, pero no necesario) como datos organizados en una estructura de √°rbol a la que el usuario tiene acceso. La forma de √°rbol de organizar la informaci√≥n sobre el algoritmo y el nombre de la clase nos da "√°rboles de expresi√≥n". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para mayor claridad, analizaremos un ejemplo simple. Supongamos que tenemos lambda </font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(x) =&gt; Console.WriteLine (x + 5)</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Esto se puede representar como el siguiente √°rbol</font></font><br>
<br>
<div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/yv/wy/sq/yvwysqugbtttw-gvz07tipuq-oy.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La ra√≠z del √°rbol es la parte superior de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodCall</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , los par√°metros del m√©todo tambi√©n son expresiones, por lo tanto, puede tener cualquier n√∫mero de hijos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestro caso, solo hay un descendiente: el pico de " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArithmeticOperation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". Contiene informaci√≥n sobre qu√© tipo de operaci√≥n es y los operandos izquierdo y derecho tambi√©n son expresiones. Tal v√©rtice siempre tendr√° 2 descendientes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los operandos est√°n representados por una constante ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constante</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) y un par√°metro ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par√°metro</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Tales expresiones no tienen descendientes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estos son ejemplos muy simplificados, pero reflejan completamente la esencia.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La caracter√≠stica principal de los √°rboles de expresi√≥n es que se pueden analizar y leer toda la informaci√≥n necesaria sobre lo que debe hacer el algoritmo. Desde alg√∫n punto de vista, esto es lo contrario de los atributos. Los atributos son un medio de descripci√≥n declarativa del comportamiento (muy condicional, pero el objetivo final es aproximadamente el mismo). Mientras que los √°rboles de expresi√≥n est√°n utilizando una funci√≥n / algoritmo para describir datos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se utilizan, por ejemplo, en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proveedores de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> marcos de entidades. La aplicaci√≥n es obvia: analizar el √°rbol de expresiones, comprender qu√© se debe ejecutar all√≠ y crear </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> partir de esta descripci√≥n </font><font style="vertical-align: inherit;">. Ejemplos menos conocidos son la biblioteca </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para moking </font><font style="vertical-align: inherit;">. Los √°rboles de expresi√≥n tambi√©n se usan en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DLR.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(tiempo de ejecuci√≥n din√°mico del lenguaje). </font><font style="vertical-align: inherit;">Los desarrolladores de compiladores los usan para garantizar la compatibilidad entre la naturaleza din√°mica y dotnet, en lugar de generar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSIL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n vale la pena mencionar que los √°rboles de expresi√≥n son inmutables.</font></font><br>
<a name="syn"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaxis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo siguiente que vale la pena discutir es la sintaxis. </font><font style="vertical-align: inherit;">Hay 2 formas principales:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crear √°rboles de expresi√≥n a trav√©s de m√©todos est√°ticos de la clase Expresi√≥n</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usar expresiones lambda compiladas en Expression</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todos Est√°ticos de la Clase de Expresi√≥n</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La creaci√≥n de √°rboles de expresi√≥n a trav√©s de m√©todos est√°ticos de la clase Expresi√≥n se usa con menos frecuencia (especialmente desde el punto de vista del usuario). Esto es engorroso, pero bastante simple, tenemos </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
muchos ladrillos b√°sicos </font><font style="vertical-align: inherit;">a nuestra </font><font style="vertical-align: inherit;">disposici√≥n, desde los cuales puede construir </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cosas </font><font style="vertical-align: inherit;">bastante complejas </font><font style="vertical-align: inherit;">. La creaci√≥n ocurre a trav√©s de m√©todos est√°ticos desde Los constructores de expresiones tienen un modificador </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interno</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Y esto no significa que deba descubrir la reflexi√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como ejemplo, crear√© una expresi√≥n a partir del ejemplo anterior: </font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(x) =&gt; Console.WriteLine (x + 5)</font></font></i></b><br>
<br>
<pre><code class="cs hljs">ParameterExpression parameter = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
ConstantExpression constant = Expression.Constant(<span class="hljs-number">5</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
BinaryExpression <span class="hljs-keyword">add</span> = Expression.Add(parameter, constant);<font></font>
MethodInfo writeLine = <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.WriteLine), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });<font></font>
MethodCallExpression methodCall = Expression.Call(<span class="hljs-literal">null</span>, writeLine, <span class="hljs-keyword">add</span>);<font></font>
Expression&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt; expressionlambda = Expression.Lambda&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt;(methodCall, parameter);<font></font>
Action&lt;<span class="hljs-keyword">double</span>&gt; delegateLambda = expressionlambda.Compile();<font></font>
delegateLambda(<span class="hljs-number">123321</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede que esta no sea una forma muy conveniente, pero refleja completamente la estructura interna de los √°rboles de expresi√≥n. </font><font style="vertical-align: inherit;">Adem√°s, este m√©todo proporciona m√°s caracter√≠sticas y caracter√≠sticas que se pueden usar en los √°rboles de expresi√≥n: desde bucles, condiciones, try-catch, goto, asignaci√≥n, terminando con bloques de falla, informaci√≥n de depuraci√≥n para puntos de interrupci√≥n, din√°mica, etc.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expresi√≥n lambda</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usar lambdas como expresiones es una forma m√°s frecuente. </font><font style="vertical-align: inherit;">Funciona de manera muy simple: el compilador inteligente en la etapa de compilaci√≥n analiza para qu√© se utiliza lambda. </font><font style="vertical-align: inherit;">Y lo compila en un delegado o en una expresi√≥n. </font><font style="vertical-align: inherit;">En un ejemplo ya dominado, se ve de la siguiente manera</font></font><br>
<br>
<pre><code class="cs hljs">Expression&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt; write =  =&gt; Console.WriteLine( + <span class="hljs-number">5</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vale la pena aclarar tal cosa: una expresi√≥n es una descripci√≥n exhaustiva. </font><font style="vertical-align: inherit;">Y es suficiente para </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
obtener el resultado. </font><font style="vertical-align: inherit;">Los √°rboles de expresi√≥n como LambdaExpression o sus descendientes se pueden </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
convertir en un IL ejecutable. </font><font style="vertical-align: inherit;">Los tipos restantes no se pueden convertir directamente a c√≥digo ejecutable (pero esto no tiene mucho sentido). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, si alguien es cr√≠tico con la compilaci√≥n r√°pida de una expresi√≥n, puede echar un vistazo a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proyecto de terceros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo contrario no es cierto en el caso general. </font><font style="vertical-align: inherit;">Un delegado no puede simplemente recogerlo y presentarse como una expresi√≥n (pero esto todav√≠a es posible). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No todas las lambdas se pueden convertir en √°rboles de expresi√≥n. </font><font style="vertical-align: inherit;">√âstas incluyen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operador de asignaci√≥n que contiene</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Din√°mica contribuyente</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asincr√≥nico</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con cuerpo (frenillos)</font></font></li>
</ul><br>
<pre><code class="cs hljs"><span class="hljs-keyword">double</span> variable;
<span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">dynamic</span>;<font></font>
Expression&lt;Action&gt; assignment = () =&gt; variable = <span class="hljs-number">5</span>; <span class="hljs-comment">//Compiler error: An expression tree may not contain an assignment operator</span>
Expression&lt;Func&lt;<span class="hljs-keyword">double</span>&gt;&gt; dynamically = () =&gt; <span class="hljs-keyword">dynamic</span>; <span class="hljs-comment">//Compiler error: An expression tree may not contain a dynamic operation</span>
Expression&lt;Func&lt;Task&gt;&gt; asynchon = <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">await</span> Task.CompletedTask; <span class="hljs-comment">//Compiler error: Async lambda cannot be converted to expresiion trees</span>
Expression&lt;Action&gt; body = () =&gt; { }; <span class="hljs-comment">//Compiler error: A lambda expression with a statement body cannot be converted to an expression tree</span>
</code></pre> <br>
<a name="types"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipos de expresiones</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sugiero un vistazo r√°pido a los tipos disponibles para representar las oportunidades que tenemos. </font><font style="vertical-align: inherit;">Todos ellos est√°n en el espacio de nombres </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Linq.Expressions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sugiero que primero se familiarice con varias caracter√≠sticas realmente interesantes e inusuales. </font><font style="vertical-align: inherit;">Los tipos m√°s simples de expresiones que re√∫no en una tableta con una breve descripci√≥n.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Din√°mica</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usando DynamicExpression es posible usar Dynamic y todas sus caracter√≠sticas en los √°rboles de expresi√≥n. </font><font style="vertical-align: inherit;">Hay una API bastante confusa, me sent√© en este ejemplo m√°s tiempo que en todos los dem√°s combinados. </font><font style="vertical-align: inherit;">Toda la confusi√≥n es proporcionada por un grupo de varias banderas. </font><font style="vertical-align: inherit;">Y algunos de ellos son similares a los que est√° buscando, pero no necesariamente. </font><font style="vertical-align: inherit;">Y cuando se trabaja con √°rboles din√°micos en expresi√≥n, es dif√≠cil obtener un error de conversaci√≥n. </font><font style="vertical-align: inherit;">Ejemplo:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> parameter1 = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), <span class="hljs-string">"name1"</span>);
<span class="hljs-keyword">var</span> parameter2 = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), <span class="hljs-string">"name2"</span>); 
<span class="hljs-keyword">var</span> dynamicParam1 = CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal">null</span>);
<span class="hljs-keyword">var</span> dynamicParam2 = CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal">null</span>);<font></font>
CallSiteBinder csb = Microsoft.CSharp.RuntimeBinder.Binder.BinaryOperation(CSharpBinderFlags.None, ExpressionType.Add, <span class="hljs-keyword">typeof</span>(Program), <span class="hljs-keyword">new</span>[] { dynamicParam1, dynamicParam2 });
<span class="hljs-keyword">var</span> dyno = Expression.Dynamic(csb, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), parameter1, parameter2);<font></font>
Expression&lt;Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt;&gt; expr = Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt;&gt;(dyno, <span class="hljs-keyword">new</span>[] { parameter1, parameter2 });<font></font>
Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt; action = expr.Compile();
<span class="hljs-keyword">var</span> res = action(<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>);<font></font>
Console.WriteLine(res); <span class="hljs-comment">//12</span>
res = action(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<font></font>
Console.WriteLine(res); <span class="hljs-comment">//3</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indiqu√© expl√≠citamente de d√≥nde viene el Binder para evitar confusiones con el Binder del System.Reflection. </font><font style="vertical-align: inherit;">De cosas interesantes, podemos hacer par√°metros de ref y out, par√°metros con nombre, operaciones unitarias y, en principio, todo lo que se puede hacer a trav√©s de la din√°mica, pero esto requerir√° algo de habilidad.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloques de captura de excepci√≥n</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La segunda cosa a la que prestar√© atenci√≥n es la funcionalidad de prueba / captura / finalmente / falla, o m√°s bien, el hecho de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
que tenemos acceso al bloque de falla. </font><font style="vertical-align: inherit;">No est√° disponible en C #, pero est√° en MSIL. Este es un tipo de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
finalmente anal√≥gico que se ejecutar√° en caso de cualquier excepci√≥n. </font><font style="vertical-align: inherit;">En el ejemplo a continuaci√≥n, se lanzar√° una excepci√≥n, despu√©s de lo cual se mostrar√° "Hola" y el programa esperar√° la entrada. </font><font style="vertical-align: inherit;">Solo despu√©s de eso caer√° por completo. </font><font style="vertical-align: inherit;">No recomiendo esta pr√°ctica para su uso.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> throwSmth = Expression.Throw(Expression.Constant(<span class="hljs-keyword">new</span> Exception(), <span class="hljs-keyword">typeof</span>(Exception)));
<span class="hljs-keyword">var</span> log = Expression.Call(<span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.WriteLine), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">string</span>) }), Expression.Constant(<span class="hljs-string">"Hi"</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">string</span>)));
<span class="hljs-keyword">var</span> read = Expression.Call(<span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.ReadLine)));
<span class="hljs-keyword">var</span> fault = Expression.TryFault(throwSmth, Expression.Block(<span class="hljs-keyword">new</span>[] { log, read }));<font></font>
Expression&lt;Action&gt; expr = Expression.Lambda&lt;Action&gt;(fault);<font></font>
Action compiledExpression = expr.Compile();<font></font>
compiledExpression();<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breve descripci√≥n de los tipos de √°rbol de expresi√≥n disponibles</font></font></b><div class="spoiler_text"><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesa</font></font></h4><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un tipo</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breve descripci√≥n</font></font></th>
</tr>
<tr>
<td colspan="2" align="center"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El principal</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expresi√≥n</font></font></td>
<td> ,      .     ,      </td>
</tr>
<tr>
<td>Expression&lt;TDelegate&gt;</td>
<td>    </td>
</tr>
<tr>
<td colspan="2" align="center"><b> </b></td>
</tr>
<tr>
<td>BinaryExpression</td>
<td>     (+, ‚Äî  )</td>
</tr>
<tr>
<td>UnaryExpression</td>
<td> (+, -),    throw</td>
</tr>
<tr>
<td>ConstantExpression</td>
<td> ‚Äî   </td>
</tr>
<tr>
<td>ParameterExpression</td>
<td> </td>
</tr>
<tr>
<td>MethodCallExpression</td>
<td>  ,  MethodInfo</td>
</tr>
<tr>
<td>IndexExpression</td>
<td></td>
</tr>
<tr>
<td>BlockExpression</td>
<td>,   .      </td>
</tr>
<tr>
<td colspan="2" align="center"><b>  </b></td>
</tr>
<tr>
<td>ConditionalExpression </td>
<td>   ‚Äî if-else</td>
</tr>
<tr>
<td>LabelTarget</td>
<td>   goto</td>
</tr>
<tr>
<td>LabelExpression</td>
<td> ,            .    LabelTarget.    ,    GotoExpression,    ‚Äî   .    void,    .</td>
</tr>
<tr>
<td>GotoExpression</td>
<td>  .    . ( .. ¬´break¬ª)</td>
</tr>
<tr>
<td>LoopExpression</td>
<td> ,    ¬´break¬ª</td>
</tr>
<tr>
<td>SwitchCase</td>
<td>    SwitchExpression</td>
</tr>
<tr>
<td>SwitchExpression</td>
<td>  switch/case</td>
</tr>
<tr>
<td>TryExpression</td>
<td>    try/catch/finally/fault </td>
</tr>
<tr>
<td>CatchBlock</td>
<td>,   ,    </td>
</tr>
<tr>
<td colspan="2" align="center"><b></b></td>
</tr>
<tr>
<td>ElementInit</td>
<td>    IEnumerable.   ListInitExpression</td>
</tr>
<tr>
<td>ListInitExpression</td>
<td>  +   </td>
</tr>
<tr>
<td>DefaultExpression</td>
<td>       </td>
</tr>
<tr>
<td>NewArrayExpression</td>
<td>   +  </td>
</tr>
<tr>
<td>NewExpression</td>
<td> </td>
</tr>
<tr>
<td colspan="2" align="center"><b>  /</b></td>
</tr>
<tr>
<td>MemberAssignment</td>
<td>    </td>
</tr>
<tr>
<td>MemberBinding</td>
<td>  ,    ,  ,        </td>
</tr>
<tr>
<td>MemberExpression</td>
<td>  /</td>
</tr>
<tr>
<td>MemberInitExpression</td>
<td>      </td>
</tr>
<tr>
<td>MemberListBinding</td>
<td> /  </td>
</tr>
<tr>
<td>MemberMemberBinding</td>
<td> / ,    /</td>
</tr>
<tr>
<td colspan="2" align="center"><b></b></td>
</tr>
<tr>
<td>LambdaExpression</td>
<td></td>
</tr>
<tr>
<td>InvocationExpression</td>
<td>   -    </td>
</tr>
<tr>
<td>DebugInfoExpression</td>
<td>       .         </td>
</tr>
<tr>
<td>SymbolDocumentInfo</td>
<td>       ,        .</td>
</tr>
<tr>
<td>DynamicExpression</td>
<td>   ( )</td>
</tr>
<tr>
<td>RuntimeVariablesExpression</td>
<td>   /    </td>
</tr>
<tr>
<td>TypeBinaryExpression</td>
<td>,      (is)</td>
</tr>
</tbody></table></div><br>
      <br>
<br>
<ul>
<li>ExpressionVisitor ‚Äî     .  .</li>
<li>DynamicExpressionVisitor ‚Äî      DynamicExpression ( VisitDynamic)</li>
</ul><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta informaci√≥n es suficiente para comenzar a comparar los m√©todos de trabajo con √°rboles de expresi√≥n. </font><font style="vertical-align: inherit;">Decid√≠ analizar todo esto con el ejemplo de encontrar la derivada. </font><font style="vertical-align: inherit;">No preve√≠a todas las opciones posibles, solo las b√°sicas. </font><font style="vertical-align: inherit;">Pero si por alguna raz√≥n alguien decide modificarlo y usarlo, estar√© encantado de compartir las mejoras a trav√©s de la solicitud en mi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositorio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="pm"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La coincidencia de patrones</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, la tarea es hacer un c√°lculo de derivados. </font><font style="vertical-align: inherit;">Puede estimar lo siguiente: hay un par de reglas para encontrar la derivada para diferentes tipos de operaciones: multiplicaci√≥n, divisi√≥n, etc. </font><font style="vertical-align: inherit;">Dependiendo de la operaci√≥n, debe seleccionar una f√≥rmula espec√≠fica. </font><font style="vertical-align: inherit;">En una formulaci√≥n tan banal, la tarea se coloca idealmente en el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interruptor / caja</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Y en la √∫ltima versi√≥n del lenguaje, se nos present√≥ el switch / case 2.0 o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la coincidencia de patrones</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es dif√≠cil discutir algo aqu√≠. </font><font style="vertical-align: inherit;">En un concentrador, tal cantidad de c√≥digo parece engorroso y mal le√≠do, por lo que sugiero mirar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Para un ejemplo de una derivada, result√≥ as√≠:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PatterntMatchingDerivative</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _one = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
		<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; ParseDerivative(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(ParseDerivative(function.Body), function.Parameters);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> Expression <span class="hljs-title">ParseDerivative</span>(<span class="hljs-params">Expression function</span>)</span> =&gt; function <span class="hljs-keyword">switch</span><font></font>
        {<font></font>
            BinaryExpression binaryExpr =&gt; function.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{	<font></font>
	  	    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression _) =&gt; constant,<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; constant,<font></font>
		    _ =&gt; Expression.Add(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right)))<font></font>
		},<font></font>
<font></font>
                ExpressionType.Divide =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{<font></font>
		    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression parameter) =&gt; Expression.Divide(constant, Expression.Multiply(parameter, parameter)),<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; Expression.Divide(_one, constant),<font></font>
		    _ =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right))<font></font>
	        },<font></font>
            },<font></font>
            MethodCallExpression methodCall <span class="hljs-keyword">when</span> methodCall.Method == _pow =&gt; (methodCall.Arguments[<span class="hljs-number">0</span>], methodCall.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(methodCall, Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, _pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(ParseDerivative(expression), methodCall), Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
             },<font></font>
             _ =&gt; function.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Constant =&gt; _zero,<font></font>
                ExpressionType.Parameter =&gt; _one,<font></font>
                _ =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryException(<span class="hljs-string">"Bitmap best practice"</span>)<font></font>
             }<font></font>
        };<font></font>
    }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece un poco inusual, pero interesante. </font><font style="vertical-align: inherit;">Fue un placer escribir esto: todas las condiciones se ajustan org√°nicamente en una l√≠nea. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El ejemplo habla por s√≠ mismo, no puedes describirlo mejor con palabras.</font></font><br>
<a name="nv"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visitante ingenuo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En tal tarea, un visitante del √°rbol de expresiones viene inmediatamente a la mente, lo que hace mucho ruido </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y un poco de p√°nico entre los aficionados para hablar √°gilmente en la cocina. </font><font style="vertical-align: inherit;">‚ÄúNo temas la ignorancia, sino el falso conocimiento. </font><font style="vertical-align: inherit;">Es mejor no saber nada que considerar la verdad como algo que no es verdad ". </font><font style="vertical-align: inherit;">Recordando esta maravillosa frase de Tolstoi, reconociendo la ignorancia y contando con el apoyo de Google, puede encontrar la siguiente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gu√≠a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tengo este enlace es el primero (despu√©s de Siberia en 1949) para la consulta "Visitante del √°rbol de expresi√≥n". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primera vista, esto es exactamente lo que necesitamos. </font><font style="vertical-align: inherit;">El t√≠tulo del art√≠culo se ajusta a lo que queremos hacer, y las clases en los ejemplos se nombran con el sufijo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visitor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de revisar el art√≠culo y hacer, por analog√≠a para nuestro ejemplo con derivados, obtenemos: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlace a github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomDerivativeExpressionTreeVisitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; Visit(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(Visitor.CreateFromExpression(function.Body).Visit(), function.Parameters);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> MethodInfo Pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> MethodInfo Log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> ConstantExpression Zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> ConstantExpression One = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Visitor <span class="hljs-title">CreateFromExpression</span>(<span class="hljs-params">Expression node</span>)</span>
            =&gt; node <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                BinaryExpression be =&gt; <span class="hljs-keyword">new</span> BinaryVisitor(be),<font></font>
                MethodCallExpression mce <span class="hljs-keyword">when</span> mce.Method == Pow =&gt; <span class="hljs-keyword">new</span> PowMethodCallVisitor(mce),<font></font>
                _ =&gt; <span class="hljs-keyword">new</span> SimpleVisitor(node),<font></font>
            };<font></font>
        <font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BinaryVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> BinaryExpression _node;<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinaryVisitor</span>(<span class="hljs-params">BinaryExpression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; _node.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{	<font></font>
	  	    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression _) =&gt; constant,<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; constant,<font></font>
		    _ =&gt; Expression.Add(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right)))<font></font>
		},<font></font>
<font></font>
                ExpressionType.Divide =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{<font></font>
		    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression parameter) =&gt; Expression.Divide(constant, Expression.Multiply(parameter, parameter)),<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; Expression.Divide(_one, constant),<font></font>
		    _ =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right))<font></font>
	        },<font></font>
            };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PowMethodCallVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodCallExpression _node;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PowMethodCallVisitor</span>(<span class="hljs-params">MethodCallExpression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; (_node.Arguments[<span class="hljs-number">0</span>], _node.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(_node, Expression.Call(<span class="hljs-literal">null</span>, Log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, Pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(CreateFromExpression(expression).Visit(), _node), Expression.Call(<span class="hljs-literal">null</span>, Log, constant)),<font></font>
            };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Expression _node;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleVisitor</span>(<span class="hljs-params">Expression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; _node.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Constant =&gt; Zero,<font></font>
                ExpressionType.Parameter =&gt; One,<font></font>
            };<font></font>
    }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, difundimos los casos de cambio para diferentes clases. </font><font style="vertical-align: inherit;">No hab√≠a menos de ellos, la magia no apareci√≥. </font><font style="vertical-align: inherit;">Todos los mismos casos, muchas m√°s l√≠neas. </font><font style="vertical-align: inherit;">¬øY d√≥nde est√° el prometido despacho de despacho doble?</font></font><br>
<a name="cv"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visitante cl√°sico y doble despacho</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ vale la pena contar acerca de la plantilla </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visitante en</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s√≠ </font><font style="vertical-align: inherit;">, tambi√©n es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visitante</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que es la base del </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">visitante del √°rbol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><i><font style="vertical-align: inherit;">Expresi√≥n</font></i><font style="vertical-align: inherit;"> . Analicemos solo en el ejemplo de los √°rboles de expresi√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por un segundo, supongamos que dise√±amos √°rboles de expresi√≥n. Queremos ofrecer a los usuarios la capacidad de iterar a trav√©s del √°rbol de expresi√≥n y, seg√∫n los tipos de nodos (tipos de expresi√≥n), realizar ciertas acciones. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera opci√≥n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es no hacer nada. Es decir, obligar a los usuarios a usar switch / case. Esta no es una mala opci√≥n. Pero aqu√≠ hay tal matiz: difundimos la l√≥gica responsable de un tipo particular. En pocas palabras, polimorfismo y desaf√≠os virtuales ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n conocido como enlace tard√≠o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) hacen posible cambiar la definici√≥n de tipo al tiempo de ejecuci√≥n y eliminar estas comprobaciones de nuestro c√≥digo. Es suficiente para nosotros tener una l√≥gica que cree una instancia del tipo deseado, luego todo lo har√° el tiempo de ejecuci√≥n por nosotros. </font></font><br>
 <br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La segunda opci√≥n.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La soluci√≥n obvia es llevar la l√≥gica a m√©todos virtuales. Al anular el m√©todo virtual en cada sucesor, podemos olvidarnos de cambiar / caso. El mecanismo de las llamadas polim√≥rficas decidir√° por nosotros. La tabla de m√©todos funcionar√° aqu√≠, los m√©todos ser√°n llamados por el desplazamiento en ella. Pero este es un tema para un art√≠culo completo, as√≠ que no nos dejemos llevar. Los m√©todos virtuales parecen resolver nuestro problema. Pero desafortunadamente, crean otro. Para nuestra tarea, podr√≠amos agregar el m√©todo GetDeriviative (). Pero ahora las clases de expresi√≥n se ven raras. Podr√≠amos agregar tales m√©todos para todas las ocasiones, pero no se ajustan a la l√≥gica general de la clase. Y todav√≠a no brindamos la oportunidad de hacer algo similar a los usuarios (de manera adecuada, por supuesto). Necesitamos dejar que el usuario defina la l√≥gica para cada tipo particular,pero mant√©n el polimorfismo (que est√° disponible para nosotros).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solo los esfuerzos del usuario para hacer esto no tendr√°n √©xito. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ es donde se encuentra el verdadero visitante. </font><font style="vertical-align: inherit;">En el tipo b√°sico de jerarqu√≠a (Expresi√≥n en nuestro caso), definimos un m√©todo de la forma</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">virtual</span> Expression <span class="hljs-title">Accept</span>(<span class="hljs-params">ExpressionVisitor visitor</span>)</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los herederos, este m√©todo ser√° anulado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ExpressionVisitor es una clase base que contiene un m√©todo virtual con la misma firma </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
para cada tipo de jerarqu√≠a. </font><font style="vertical-align: inherit;">Usando la clase ExpressionVisitor como ejemplo, VisitBinary (...), VisitMethodCall (...), VisitConstant (...), VisitParameter (...). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estos m√©todos se llaman en la clase correspondiente de nuestra jerarqu√≠a. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquellos. </font><font style="vertical-align: inherit;">El m√©todo Aceptar en la clase BinaryExpression se ver√° as√≠:</font></font><br>
<br>
<pre><code class="cs hljs">	
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">internal</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Accept</span>(<span class="hljs-params">ExpressionVisitor visitor</span>)</span><font></font>
{<font></font>
        <span class="hljs-keyword">return</span> visitor.VisitBinary(<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, para definir un nuevo comportamiento, el usuario solo necesita crear un heredero para la clase ExpressionVisitor, en el que se redefinir√°n los m√©todos correspondientes para resolver un problema. En nuestro caso, se crea un DerivativeExpressionVisitor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, tenemos algunos objetos de los sucesores de Expression, pero cu√°les son desconocidos, pero no necesarios.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llamamos al m√©todo de aceptaci√≥n virtual con la implementaci√≥n de ExpressionVisitor que necesitamos, es decir, con DerivativeExpressionVisitor. Gracias al despacho din√°mico, se llama a una implementaci√≥n anulada de Aceptar, como un tiempo de ejecuci√≥n, por ejemplo, BinaryExpression. En el cuerpo de este m√©todo, entendemos perfectamente que estamos en BinaryExpression, pero no sabemos qu√© sucesor de ExpressionVisitor vino a nosotros. Pero desde VisitBinary tambi√©n es virtual, no necesitamos saberlo. Nuevamente, simplemente llamamos por referencia a la clase base, la llamada se despacha din√°micamente (en tiempo de ejecuci√≥n) y se llama a una implementaci√≥n de VisitBinary anulada del tipo de tiempo de ejecuci√≥n. Esto en cuanto al doble despacho: ping-pong al estilo de "lo haces", "no, t√∫". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que nos da De hecho, esto hace posible "agregar" m√©todos virtuales desde afuera, no</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cambiando la clase </font><font style="vertical-align: inherit;">Suena genial, pero tiene sus desventajas:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algunos izquierdistas en la forma del m√©todo Aceptar, que es responsable de todo y de nada al mismo tiempo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El efecto domin√≥ de una buena funci√≥n hash es que cuando agrega solo un heredero a la jerarqu√≠a, en el peor de los casos, todos tendr√°n que finalizar sus visitas</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero la naturaleza de los √°rboles de expresi√≥n permite estos costos debido a los detalles de trabajar con expresiones, ya que este tipo de soluciones es una de sus principales caracter√≠sticas. </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede ver todos los m√©todos disponibles para sobrecargar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, veamos c√≥mo se ve al final. </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlace a github.</font></font></a><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BuildinExpressionTreeVisitor</span> : <span class="hljs-title">ExpressionVisitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _one = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; GetDerivative(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(Visit(function.Body), function.Parameters);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitBinary</span>(<span class="hljs-params">BinaryExpression binaryExpr</span>)</span>
            =&gt; binaryExpr.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(Visit(binaryExpr.Left), Visit(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(Visit(binaryExpr.Left), Visit(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; _zero,<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ParameterExpression =&gt; binaryExpr.Left,<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ParameterExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; binaryExpr.Right,<font></font>
                ExpressionType.Multiply =&gt; Expression.Add(Expression.Multiply(Visit(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, Visit(binaryExpr.Right))),<font></font>
<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; _zero,<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ParameterExpression =&gt; Expression.Divide(binaryExpr.Left, Expression.Multiply(binaryExpr.Right, binaryExpr.Right)),<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ParameterExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; Expression.Divide(_one, binaryExpr.Right),<font></font>
                ExpressionType.Divide =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(Visit(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, Visit(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right)),<font></font>
            };<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitMethodCall</span>(<span class="hljs-params">MethodCallExpression methodCall</span>)</span>
            =&gt; (methodCall.Arguments[<span class="hljs-number">0</span>], methodCall.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(methodCall, Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, _pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(Visit(expression), methodCall), Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
            };<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitConstant</span>(<span class="hljs-params">ConstantExpression _</span>)</span> =&gt; _zero;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitParameter</span>(<span class="hljs-params">ParameterExpression b</span>)</span> =&gt; _one;<font></font>
    }<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quiz√°s, como en la mayor√≠a de las tareas de programaci√≥n, no se puede dar una respuesta definitiva. </font><font style="vertical-align: inherit;">Todo, como siempre, depende de la situaci√≥n espec√≠fica. </font><font style="vertical-align: inherit;">Me gusta la coincidencia de patrones habitual para mi ejemplo, porque </font><font style="vertical-align: inherit;">No lo desarroll√© a la escala del desarrollo industrial. </font><font style="vertical-align: inherit;">Si esta expresi√≥n aumentara sin control, valdr√≠a la pena pensar en el visitante. </font><font style="vertical-align: inherit;">E incluso un visitante ingenuo tiene derecho a la vida; despu√©s de todo, esta es una buena manera de dispersar una gran cantidad de c√≥digo en las clases si la jerarqu√≠a no ha brindado apoyo por su parte. </font><font style="vertical-align: inherit;">E incluso aqu√≠ hay excepciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Del mismo modo, el apoyo del visitante desde la jerarqu√≠a es algo muy controvertido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero espero que la informaci√≥n proporcionada aqu√≠ sea suficiente para tomar la decisi√≥n correcta.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es486972/">https://habr.com/ru/post/es486972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es486948/index.html">¬øC√≥mo elegir un editor y por qu√© elegir NeoVim?</a></li>
<li><a href="../es486950/index.html">Antig√ºedades: la actualizaci√≥n despiadada de la computadora 386</a></li>
<li><a href="../es486962/index.html">Revisi√≥n de desarrollo de juegos HSE</a></li>
<li><a href="../es486964/index.html">Multitarea y curiosa. La campeona de Java Mitya Alexandrov sobre la creaci√≥n de la comunidad de TI, el "remoto" y la vida</a></li>
<li><a href="../es486966/index.html">¬øPor qu√© la conveniencia frente a la seguridad no es una compensaci√≥n?</a></li>
<li><a href="../es486974/index.html">Producci√≥n en masa de electr√≥nica en Rusia. Prueba de automatizaci√≥n</a></li>
<li><a href="../es486976/index.html">Problemas de la educaci√≥n en informaci√≥n rusa y sus posibles soluciones.</a></li>
<li><a href="../es486978/index.html">Notas de campo: una de las mayores conferencias de c√≥digo abierto FOSDEM 2020</a></li>
<li><a href="../es486980/index.html">Kim Dotcom: Atrapado, la persona m√°s buscada en l√≠nea. Parte 1</a></li>
<li><a href="../es486982/index.html">C√≥mo aprender el desarrollo front-end, encontrar tu primer trabajo y no recibir golpes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>