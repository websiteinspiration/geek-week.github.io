<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÉÔ∏è üìÜ üõ£Ô∏è Tri de la triche pour la science des donn√©es ‚òØÔ∏è ü§ü üßëüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le tri des donn√©es est une pr√©occupation majeure pour les scientifiques et ing√©nieurs des donn√©es. Les utilisateurs de Python peuvent choisir la plus ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Tri de la triche pour la science des donn√©es</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillfactory/blog/506888/"><img src="https://habrastorage.org/getpro/habr/post_images/4be/b00/dfb/4beb00dfb3cdb4f8665747189fa8910a.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tri des donn√©es est une pr√©occupation majeure pour les scientifiques et ing√©nieurs des donn√©es. Les utilisateurs de Python peuvent choisir la plus pratique parmi un certain nombre de biblioth√®ques avec des options de tri optimis√©es int√©gr√©es. Certains fonctionnent m√™me en parall√®le avec le GPU. √âtonnamment, certaines m√©thodes de tri n'utilisent pas ces types d'algorithmes, tandis que d'autres ne fonctionnent pas comme pr√©vu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le choix d'une biblioth√®que et du type d'algorithme de tri n'est pas toujours facile, et les innovations √©voluent rapidement. Pour le moment, la documentation Pandas ne correspond pas au code (bien que personnellement, ma mise √† jour PR des options de tri soit la derni√®re). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, je vais vous expliquer ce qui est quoi, je vais vous donner quelques conseils pour vous aider √† comprendre les m√©thodes et partager les r√©sultats du test de vitesse. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD 17 juillet 2019</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Les r√©sultats de l'√©valuation du test de vitesse incluent d√©sormais les impl√©mentations de GPU PyTorch et TensorFlow. </font><font style="vertical-align: inherit;">TensorFlow inclut √©galement les r√©sultats du processeur pour quand </font></font><code>tensorflow==2.0.0-beta1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et quand </font></font><code>tensorflow-gpu==2.0.0-beta1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Observations int√©ressantes: le GPU PyTorch vole litt√©ralement et le GPU TensorFlow est plus lent que le CPU TensorFlow.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le contexte</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe de nombreux algorithmes de tri de base. </font><font style="vertical-align: inherit;">Certains d'entre eux ont des performances √©lev√©es et prennent moins de place, d'autres fonctionnent bien avec de grandes quantit√©s de donn√©es. </font><font style="vertical-align: inherit;">Pour certains algorithmes, la position relative des √©l√©ments de donn√©es est importante. </font><font style="vertical-align: inherit;">Dans le diagramme au d√©but de l'article, vous pouvez voir la situation en temps et en volume pour les algorithmes les plus courants.</font></font><br>
 <a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, vous n'avez pas besoin d'√™tre un expert en d√©ploiements de base pour r√©soudre la plupart des probl√®mes de tri. </font><font style="vertical-align: inherit;">En fait, l'optimisation pr√©matur√©e est parfois consid√©r√©e comme la racine du mal. </font><font style="vertical-align: inherit;">Cependant, si vous devez trier plusieurs fois un grand nombre de donn√©es, il peut √™tre tr√®s utile de savoir √† l'avance quelle biblioth√®que et quels mots cl√©s sont les mieux utilis√©s. </font><font style="vertical-align: inherit;">Je vous pr√©sente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ma feuille de triche</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
 <br>
<img src="https://habrastorage.org/getpro/habr/post_images/67a/568/caa/67a568caa0670b09aaccb1efb4653bb1.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au fil des ans, les algorithmes de tri ont chang√© dans la plupart des biblioth√®ques. </font><font style="vertical-align: inherit;">Pour l'analyse dans cet article, j'ai pris les versions logicielles suivantes.</font></font><br>
 <br>
<pre><code class="plaintext hljs">python 3.6.8<font></font>
numpy 1.16.4<font></font>
pandas 0.24.2<font></font>
tensorflow==2.0.0-beta1  #tensorflow-gpu==2.0.0-beta1 slows sorting<font></font>
pytorch 1.1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commen√ßons par les bases.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python (vanille)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python a deux m√©thodes de tri int√©gr√©es.</font></font><br>
<br>
<ul>
<li><code>my_list.sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trie la liste en place, la liste d'origine √©tant remplac√©e par la liste tri√©e. </font></font><code>sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie Aucun.</font></font></li>
<li>sorted(my_list)      . <code> sorted()</code>   . <code>sort()</code>   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En th√©orie, cela </font></font><code>sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait √™tre plus rapide, car le tri a lieu sur place. √âtonnamment, il n'y a pas beaucoup de diff√©rence entre eux. En outre, </font></font><code>sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cela vaut la peine d'√™tre utilis√© avec soin, car il modifie les donn√©es d'origine sans les enregistrer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toutes les impl√©mentations de Vanilla Python que nous couvrirons dans cet article ont un ordre de tri par d√©faut croissant, du plus petit au plus grand. Cependant, la plupart des autres m√©thodes de tri utilisent une m√©thode descendante. Pas tr√®s pratique pour vous et votre t√™te, mais cette option varie pour chaque biblioth√®que. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour notre cas, pour changer l'ordre de tri en descendant en Vanilla Python, vous devez sp√©cifier </font></font><code>reverse=True</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut √™tre d√©clar√© mot cl√© pour vos crit√®res uniques. Par exemple,</font></font><code>sort(key=len)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trie les √©l√©ments de la liste en fonction de leur longueur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le seul algorithme de tri utilis√© dans Vanilla Python est Timsort. En utilisant cet algorithme, les donn√©es sont tri√©es selon leurs principaux crit√®res. Par exemple, si vous souhaitez trier une courte liste, le tri par insertion est utilis√©. Pour plus d'informations sur Timsort, voir le grand article de Brandon Skerritt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Timsort et, par cons√©quent, Vanilla Python, sont constants. Autrement dit, si les valeurs initiales sont les m√™mes, les valeurs trait√©es seront similaires et dispos√©es dans le m√™me ordre. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour rappeler la diff√©rence entre sort () et sorted (), je remarque juste que sorted () est une commande plus complexe que </font></font><code>sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et que</font></font><code> sorted()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela prendra objectivement plus de temps, car en m√™me temps, les donn√©es initiales et la copie sont enregistr√©es. </font><font style="vertical-align: inherit;">Et m√™me si les r√©sultats des tests sont ambigus, les mn√©moniques sont notre tout. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je propose maintenant d'envisager l'utilisation de Numpy.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numpy</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Numpy est la biblioth√®que Python fondamentale pour le calcul scientifique. </font><font style="vertical-align: inherit;">Comme Vanilla Python, il a deux options pour l'impl√©mentation: soit la copie ou la modification du tableau de donn√©es source:</font></font><br>
<br>
<ul>
<li><code>my_array.sort ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> change le tableau en place et retourne un tableau tri√©;</font></font></li>
<li><code>np.sort (my_array)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> renvoie une copie du tableau tri√©, sans modifier les donn√©es d'origine.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arguments utilis√©s en option:</font></font><br>
<br>
<ul>
<li><code>axis</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int, optionnel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - axe sur lequel le tri est effectu√©. </font><font style="vertical-align: inherit;">Par d√©faut -1 - tri par le dernier axe.</font></font></li>
<li><code>kind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{'quicksort', 'mergesort', 'heapsort', 'stable'}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - algorithme de tri. </font><font style="vertical-align: inherit;">Par d√©faut, ¬´quicksort¬ª est utilis√©. </font><font style="vertical-align: inherit;">Ensuite, je vais en parler plus en d√©tail.</font></font></li>
<li><code>order</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">str ou liste de str</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - quand a est un tableau avec des limites d√©finies, cet argument indique dans quel ordre ces limites sont compar√©es. </font><font style="vertical-align: inherit;">Un champ peut √™tre sp√©cifi√© sous forme de cha√Æne; d'autres champs peuvent ne pas √™tre sp√©cifi√©s. </font><font style="vertical-align: inherit;">Ils seront en tout cas utilis√©s en dtype pour les interruptions.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Franchement, pour le moment, les algorithmes de tri correspondent en fait √† leurs noms. </font><font style="vertical-align: inherit;">La commande </font></font><code> kind=quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">signifie litt√©ralement que le tri commence par un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tri introspectif</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Plus de d√©tails </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<blockquote> ,    ,     heapsort.         O(n* log (n)).<br>
<br>
stable      .  ,    ,       timsort  radix,     .   API       ,        .<br>
<br>
Timsort          .    timsort   mergesort.        ,       -   ,     ‚Ä¶ ¬´mergesort¬ª  ¬´stable¬ª      .<br>
 ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> Numpy</a> ‚Äî (   )</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'une des conclusions les plus importantes: Numpy vous permet de g√©rer les options de tri plus librement que Vanilla Python. </font><font style="vertical-align: inherit;">Deuxi√®me conclusion non moins importante: le mot-cl√© kind ne correspond pas n√©cessairement au type de tri utilis√©. </font><font style="vertical-align: inherit;">Et enfin, le r√©sultat final, si je puis dire, est que </font></font><code>mergesort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>stable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont certains de trier, et </font></font><code>quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>heapsort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- non. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Numpy est la seule m√©thode sur notre liste qui n'a pas de mot-cl√© pour changer l'ordre de tri. </font><font style="vertical-align: inherit;">Heureusement, il peut √™tre une sorte de tableau FLIP: </font></font><code>my_arr[::-1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toutes les fonctionnalit√©s de Numpy sont √©galement disponibles dans des pandas beaucoup plus conviviaux.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pandas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez trier dans Pandas DataFrame c </font></font><code>df.sort_values (by=my_column)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour plus de commodit√©, il existe plusieurs mots cl√©s.</font></font><br>
<br>
<ul>
<li><code>by</code>: <i>str  list of str</i> ‚Äî       .   = 0   ,      / .    1  ,       /  .</li>
<li><code>axis</code>: <i>{0  , 1  }</i>,   0 ‚Äî   .</li>
<li><code>ascending</code>: <i>bool   bool</i>,    True ‚Äî      .      .    ,     by.</li>
<li><code>inplace</code>: <i>bool,   False</i> ‚Äî   True,    .</li>
<li><code>kind</code>: <i>{quicksort, mergesort, heapsort  stable}</i>,   quicksort ‚Äî   .       <code>ndarray.np.sort</code>.  DataFrames           .</li>
<li><code>na_position</code>: <i>{¬´first¬ª, ¬´last¬ª}</i>,   ¬´last¬ª ‚Äî first  NaNs  , last  NaNs  .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La s√©rie Pandas est impl√©ment√©e avec la m√™me syntaxe. Dans Series, il n'y a pas besoin de mot-cl√© </font></font><code>by</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car il n'y a pas plusieurs colonnes avec des donn√©es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque Pandas est ¬´sous le capot¬ª - Numpy, vous avez les m√™mes options de tri optimis√©es √† port√©e de main. Cependant, l'utilisation de Pandas est un peu plus laborieuse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors du tri par une colonne dans Numpy, il est utilis√© par d√©faut </font></font><code>quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Comme vous vous en souvenez, </font></font><code>quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maintenant c'est en fait une introduction et va dans la pyramide si le processus de tri est lent. Les pandas affirment que le tri sur plusieurs colonnes utilise </font></font><code>mergesort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numpy. </font></font><code>mergesort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numpy utilise en fait des algorithmes de tri Timsort ou Radix. Ce sont des algorithmes de tri stables, qui sont n√©cessaires lors du tri sur plusieurs colonnes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les pandas doivent se rappeler plusieurs points cl√©s:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nom de la </font><font style="vertical-align: inherit;">fonction: </font></font><code>sort_values()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doit d√©clarer </font></font><code>by=column_name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou lister les noms des colonnes.</font></font></li>
<li><code>ascending</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Est le mot cl√© pour inverser.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour une utilisation stable du tri </font></font><code>mergesort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors du traitement analytique des donn√©es, je rencontre souvent des valeurs de sommation et de tri dans Pandas DataFrame avec </font></font><code>Series.value_counts()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Voici un extrait de code pour r√©sumer et trier les valeurs les plus courantes pour chaque colonne.</font></font><br>
 <br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> df.columns:<font></font>
    print(<span class="hljs-string">f"---- <span class="hljs-subst">{c}</span> ---"</span>)<font></font>
    print(df[c].value_counts().head())</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dask</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que les Pandas proposent pour travailler avec les m√©gadonn√©es, n'a pas encore d'impl√©mentation de tri parall√®le, mais ce </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">probl√®me est en discussion</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tri Pandas est un bon choix pour pr√©-trier de petites quantit√©s de donn√©es. </font><font style="vertical-align: inherit;">Si vous avez une grande quantit√© de donn√©es et que vous souhaitez travailler en parall√®le avec le GPU, vous devez faire attention √† TensorFlow ou PyTorch.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tensorflow</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TensorFlow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le support le plus populaire pour l'apprentissage en profondeur. </font><font style="vertical-align: inherit;">Vous pouvez en savoir plus sur l'apprentissage en profondeur dans mon article sur le lien </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Les informations suivantes sont pertinentes pour le GPU TensorFlow 2.0. </font></font><br>
<br>
<code>tf.sort(my_tensor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie une copie tri√©e du tenseur. </font><font style="vertical-align: inherit;">Arguments facultatifs:</font></font><br>
<br>
<ul>
<li><code>axis</code>: <i>{int}</i> ,    .    -1    .</li>
<li><code>direction</code>:<i> {ascending  descending}</i> ‚Äî   .</li>
<li><code>name</code>: <i>{str}</i> ‚Äî   .</li>
</ul><br>
<code>tf.sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilise essentiellement </font></font><code> top_k()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pour </font></font><code>top_k()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la biblioth√®que CUB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du GPU CUDA est utilis√©e, ce qui simplifie l'impl√©mentation parall√®le. La documentation indique que ¬´CUB fournit des composants logiciels modernes et reproductibles pour chaque niveau du mod√®le de programmation CUDA¬ª. TensorFlow utilise le tri GPU de base via le CUB ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">discussion</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des informations sur le GPU TensorFlow peuvent √™tre trouv√©es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pour activer le GPU avec TensorFlow 2.0, vous devez vous inscrire </font></font><code>!pip3 install tensorflow-gpu==2.0.0-beta1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. On verra ci-dessous que vous pouvez suivre le chemin </font></font><code>tensorflow==2.0.0-beta1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si vous ne triez que des donn√©es (ce qui est peu probable). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour v√©rifier le code sur le CPU et le GPU, utilisez la ligne suivante:</font></font><br>
<br>
<pre><code class="plaintext hljs">tf.debugging.set_log_device_placement(True)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour indiquer que vous souhaitez utiliser le GPU, vous devez utiliser ce bloc:</font></font><br>
<br>
<pre><code class="plaintext hljs">with tf.device('/GPU:0'):<font></font>
 %time tf.sort(my_tf_tensor)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour utiliser la CPU: </font></font><code>with tf.device('/CPU:0')</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>tf.sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit d'une m√©thode intuitive lorsque vous travaillez dans TensorFlow. </font><font style="vertical-align: inherit;">N'oubliez pas ce dont vous avez </font></font><code>direction=descending</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besoin pour modifier l'ordre de tri.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pytorch</font></font></h3><br>
<code>torch.sort(my_tensor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie une copie tri√©e du tenseur. </font><font style="vertical-align: inherit;">Arguments facultatifs:</font></font><br>
<br>
<ul>
<li><code>dim</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{int}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - tri du volume.</font></font></li>
<li><code>descending</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{bool}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - contr√¥le l'ordre de tri (croissant ou d√©croissant).</font></font></li>
<li><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{tuple}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - suivi de sortie (Tensor, LongTensor), qui peut √™tre utilis√© comme tampons de sortie.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous souhaitez utiliser le GPU pour le tri, attachez-le </font></font><code>.cuda ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la fin de votre tenseur.</font></font><br>
<br>
<pre><code class="plaintext hljs">gpu_tensor=my_pytorch_tensor.cuda()<font></font>
%time torch.sort(gpu_tensor)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des √©tudes ont montr√© que PyTorch utilise le tri parall√®le segment√© via </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thrust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si un ensemble de donn√©es de plus d'un million de lignes par 100 000 colonnes est tri√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, je n'avais pas assez de m√©moire lorsque j'ai essay√© de cr√©er des donn√©es arbitraires de 1,1 million pour 100 000 via Numpy dans Google Colab. </font><font style="vertical-align: inherit;">Apr√®s cela, j'ai essay√© GCP avec 416 Mo de RAM, et encore une fois j'ai manqu√© de m√©moire.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le tri segment√© et le tri par emplacement sont des options de tri par fusion hautes performances qui fonctionnent avec des donn√©es al√©atoires h√©t√©rog√®nes. </font><font style="vertical-align: inherit;">Le tri segment√© vous permet de trier plusieurs tableaux de longueur variable en parall√®le. </font><font style="vertical-align: inherit;">- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://moderngpu.github.io/segsort.html</font></font></a></blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thrust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une biblioth√®que d'algorithmes parall√®le qui offre une compatibilit√© entre les performances du GPU et les processeurs multic≈ìurs. Il fournit un cadre de tri qui s√©lectionne automatiquement la m√©thode d'impl√©mentation la plus efficace. La biblioth√®que CUB utilis√©e par TensorFlow all√®ge la charge. PyTorch et TensorFlow utilisent des algorithmes similaires pour trier les GPU, quelle que soit l'approche que vous utilisez. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme tensorflow, m√©thode de </font><font style="vertical-align: inherit;">tri dans PyTorch assez facile √† retenir: </font></font><code>torch.sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La seule chose √† retenir est la direction des valeurs tri√©es: TensorFlow utilise </font></font><code>direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et PyTorch utilise </font></font><code>descending</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Et n'oubliez pas de l'utiliser </font></font><code>.cuda()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour maximiser la vitesse lorsque vous travaillez avec de grandes quantit√©s de donn√©es.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien que le tri GPU puisse √™tre une bonne option pour les tr√®s grands ensembles de donn√©es, il est √©galement judicieux de trier les donn√©es directement en SQL.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tri en SQL est g√©n√©ralement tr√®s rapide, surtout si le tri a lieu directement en m√©moire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQL est une sp√©cification qui ne vous oblige pas √† utiliser un algorithme sp√©cifique. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postgres utilise</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le tri par fusion de disques, le tri pyramidal ou rapide, selon les circonstances. Si vous avez suffisamment de m√©moire, le tri peut y √™tre effectu√©, et beaucoup plus rapidement. Vous pouvez augmenter la m√©moire disponible pour le tri avec </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code> work_mem</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'autres options SQL utilisent diff√©rents algorithmes de tri. Par exemple, Google BigQuery utilise le tri interne avec quelques astuces, telles que celles pr√©sent√©es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la r√©ponse √† Stack Overflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tri en SQL se fait par la commande</font></font><code>ORDER BY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cette syntaxe est diff√©rente de Python, o√π ils pr√©f√®rent utiliser une forme de tri de mots. </font><font style="vertical-align: inherit;">Personnellement, je me souviens que ORDER BY est utilis√© dans la syntaxe SQL, car il est plut√¥t inhabituel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour trier les donn√©es par ordre d√©croissant, utilisez le mot cl√© DESC. </font><font style="vertical-align: inherit;">Ainsi, une demande de renvoi de donn√©es par ordre alphab√©tique du dernier au premier ressemblera √† ceci:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Names</span> <span class="hljs-keyword">FROM</span> Customers
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">Names</span> <span class="hljs-keyword">DESC</span>;
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparaison</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour chacune des biblioth√®ques Python ci-dessus, j'ai effectu√© une analyse en triant 1 000 000 points de donn√©es dans une seule colonne, un tableau ou une liste. </font><font style="vertical-align: inherit;">J'ai utilis√© un </font><font style="vertical-align: inherit;">ordinateur portable </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Colab Jupyter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec un GPU K80 et un processeur Intel Xeon √† 2,30 GHz.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/64c/2ea/636/64c2ea636ec6e3148fda501eb431729e.gif" alt="image"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observations</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PyTorch avec GPU est aussi rapide que possible.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour Numpy et Pandas, le tri sur place est g√©n√©ralement plus rapide que la copie de donn√©es.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pandas quicksort par d√©faut est assez rapide.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La plupart des fonctionnalit√©s Pandas sont relativement plus lentes que leurs homologues Numpy.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le processeur TensorFlow est assez rapide. </font><font style="vertical-align: inherit;">L'installation d'un GPU ralentit TensorFlow m√™me lorsque vous utilisez un processeur. </font><font style="vertical-align: inherit;">Le tri GPU est assez lent. </font><font style="vertical-align: inherit;">Cette option n'est pas tr√®s efficace.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans Vanilla Python, le tri sur place est √©tonnamment lent - presque 100 fois plus lent que le tri avec prise en charge du processeur graphique PyTorch. </font><font style="vertical-align: inherit;">J'ai construit l'exp√©rience plusieurs fois (avec des donn√©es diff√©rentes) pour v√©rifier que ce n'est pas une anomalie.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encore une fois, ce n'est qu'un petit test. </font><font style="vertical-align: inherit;">Ce n'est certainement pas le r√©sultat final.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©sumer</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En r√®gle g√©n√©rale, vous n'avez pas besoin de votre propre d√©veloppement d'options de tri. Les options toutes faites sont tout √† fait satisfaisantes et utilisent souvent plus d'une m√©thode de tri. Au lieu de cela, ils √©valuent d'abord les donn√©es, puis utilisent l'algorithme de tri √©prouv√©. Certaines versions modifient m√™me les algorithmes si le tri ralentit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, vous avez compris comment trier chaque √©l√©ment de donn√©es en Python et SQL. J'esp√®re que cela vous aidera √† l'avenir. Si vous en avez l'occasion, veuillez partager l'article sur vos r√©seaux sociaux pr√©f√©r√©s pour aider d'autres personnes √† le trouver. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous avez juste besoin de vous rappeler quelle option choisir et de l'appeler. Utilisez ma feuille de triche pour gagner du temps. Mes recommandations g√©n√©rales sont les suivantes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisez Pandas </font></font><code>sort_values()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par d√©faut pour explorer des ensembles de donn√©es relativement petits.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour les grands ensembles de donn√©es, ou lorsque la vitesse est suffisamment √©lev√©e, essayez le tri Numpy int√©gr√© en place, l'impl√©mentation parall√®le de PyTorch ou TensorFlow, ou du GPU SQL.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'ai pas trop √©crit sur le tri GPU. </font><font style="vertical-align: inherit;">C'est un domaine qui a m√ªri pour de nouveaux guides de recherche et d'√©tude. </font><font style="vertical-align: inherit;">Voici un article de recherche 2017 pour vous donner une id√©e des derni√®res </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recherches</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vous trouverez plus d'informations sur les algorithmes de tri GPU </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rd/kl/lr/rdkllrbtrth_kdpceb-vxzrxl1o.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apprenez en d√©tail comment obtenir une profession recherch√©e √† partir de z√©ro ou passer au niveau sup√©rieur en comp√©tences et en salaire en suivant des cours en ligne SkillFactory pay√©s:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cours d'apprentissage automatique (12 semaines)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cours Profession Data Scientist (24 mois) </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  ¬´ Data Analyst¬ª (18 )</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> ¬´Python  -¬ª (9 )</a></li>
</ul> <br>
<br clear="left">
<h3> </h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">450     </a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   Data Science  Harvard University</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">65    Machine Learning    </a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">30    -  </a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">     Data Science : Cambridge Analytica</a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr506870/index.html">Comment d√©sactiver l'avertissement sur les dangers d'une longue √©coute audio (Android)</a></li>
<li><a href="../fr506872/index.html">Livre Spring Boot 2: Meilleures pratiques pour les professionnels</a></li>
<li><a href="../fr506874/index.html">De la vie d'un programmeur: les gens d'affaires</a></li>
<li><a href="../fr506880/index.html">Joel Spolsky: comment l'√®re Stack Overflow a commenc√©</a></li>
<li><a href="../fr506886/index.html">Life hack for bits</a></li>
<li><a href="../fr506890/index.html">Oeuf de P√¢ques dans ionCube - une tentative des d√©veloppeurs de balayer les ordures sous le tapis?</a></li>
<li><a href="../fr506896/index.html">L'interpr√©tation la plus r√©aliste de la m√©canique quantique</a></li>
<li><a href="../fr506902/index.html">Maison intelligente dans une ville intelligente</a></li>
<li><a href="../fr506906/index.html">Les paradoxes du trou noir r√©v√®lent le lien fondamental entre l'√©nergie et l'ordre</a></li>
<li><a href="../fr506908/index.html">Top science. Mai dix m√©dias: d√©sespoir des poissons d'aquarium, voix des troubles mentaux et plusieurs fois COVID</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>