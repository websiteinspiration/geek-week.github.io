<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔣 ☔️ 🛁 Analyse des échappées par la mécanique du langage 👩🏾‍🎨 🌅 🤹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prélude
 Il s'agit du deuxième des quatre articles d'une série qui donnera un aperçu de la mécanique et de la conception des pointeurs, des piles, des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Analyse des échappées par la mécanique du langage</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497994/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prélude</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit du deuxième des quatre articles d'une série qui donnera un aperçu de la mécanique et de la conception des pointeurs, des piles, des tas, de l'analyse d'échappement et de la sémantique Go / Value. </font><font style="vertical-align: inherit;">Ce post est sur les tas et l'analyse des échappées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Table des matières:</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mécanique du langage sur piles et pointeurs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traduction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mécanique du langage sur l'analyse d'échappement</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mécanique du langage sur le profilage de la mémoire</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Philosophie de conception sur les données et la sémantique</font></font></a></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le premier article de cette série, j'ai parlé des bases de la mécanique des pointeurs en utilisant un exemple dans lequel la valeur est répartie sur la pile entre les goroutines. Je ne vous ai pas montré ce qui se passe lorsque vous divisez la valeur sur la pile. Pour comprendre cela, vous devez vous renseigner sur un autre domaine de la mémoire où les valeurs peuvent être: sur le «tas». Avec cette connaissance, vous pouvez commencer à étudier "l'analyse d'échappement".</font></font><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'analyse d'échappement est un processus que le compilateur utilise pour déterminer le placement des valeurs créées par votre programme. </font><font style="vertical-align: inherit;">En particulier, le compilateur effectue une analyse de code statique pour déterminer si la valeur peut être placée sur le cadre de pile pour la fonction qui la construit, ou si la valeur doit être "échappée" dans le tas. </font><font style="vertical-align: inherit;">Il n'y a pas un seul mot-clé ou fonction dans Go que vous pouvez utiliser pour indiquer au compilateur la décision à prendre. </font><font style="vertical-align: inherit;">Seule la façon dont vous écrivez votre code conditionnellement vous permet d'influencer cette décision.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des tas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un tas est une deuxième zone de mémoire, en plus de la pile, utilisée pour stocker des valeurs. Le tas n'est pas autonettoyant comme les piles, donc l'utilisation de cette mémoire est plus coûteuse. Tout d'abord, les coûts sont associés au ramasse-miettes (GC), qui doit garder cette zone propre. Lorsque le GC démarre, il utilise 25% de la puissance disponible de votre processeur. De plus, il peut potentiellement créer des microsecondes de retards «stop the world». L'avantage d'avoir un GC est que vous n'avez pas à vous soucier de la gestion de la mémoire de tas qui a toujours été complexe et sujette aux erreurs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les valeurs du tas provoquent des allocations de mémoire dans Go. </font><font style="vertical-align: inherit;">Ces allocations exercent une pression sur le GC, car chaque valeur du tas à laquelle le pointeur ne fait plus référence doit être supprimée. </font><font style="vertical-align: inherit;">Plus vous devez vérifier et supprimer de valeurs, plus le GC doit faire de travail à chaque démarrage. </font><font style="vertical-align: inherit;">Par conséquent, l'algorithme de stimulation travaille constamment pour équilibrer la taille du tas et la vitesse d'exécution.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partage de pile</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans Go, aucun goroutine n'est autorisé à avoir un pointeur pointant vers une mémoire sur la pile d'un autre goroutine. </font><font style="vertical-align: inherit;">Cela est dû au fait que la mémoire de la pile pour les goroutines peut être remplacée par un nouveau bloc de mémoire lorsque la pile doit augmenter ou diminuer. </font><font style="vertical-align: inherit;">Si au moment de l'exécution, vous deviez suivre les pointeurs vers la pile dans un autre goroutine, vous auriez à gérer trop, et le retard de "stop the world" lors de la mise à jour des pointeurs vers ces piles serait stupéfiant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un exemple d'une pile qui est remplacée plusieurs fois en raison de la croissance. </font><font style="vertical-align: inherit;">Regardez la sortie dans les lignes 2 et 6. Vous verrez deux fois les changements d'adresse de la valeur de chaîne à l'intérieur du cadre de pile principal. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/pxn5u4EBSI</font></font></a> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mécanique d'échappement</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque fois qu'une valeur est partagée en dehors de la région du cadre de pile d'une fonction, elle est placée (ou allouée) dans un segment de mémoire. La tâche des algorithmes d'analyse d'échappement est de trouver de telles situations et de maintenir le niveau d'intégrité dans le programme. L'intégrité consiste à garantir que l'accès à toute valeur est toujours précis, cohérent et efficace. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetez un œil à cet exemple pour apprendre les mécanismes de base de l'analyse d'échappement. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/Y_VZxYteKO</font></font></a> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Listing 1</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span> {
<span class="hljs-number">04</span>     name  <span class="hljs-keyword">string</span>
<span class="hljs-number">05</span>     email <span class="hljs-keyword">string</span>
<span class="hljs-number">06</span> }
<span class="hljs-number">07</span>
<span class="hljs-number">08</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">09</span>     u1 := createUserV1()
<span class="hljs-number">10</span>     u2 := createUserV2()
<span class="hljs-number">11</span>
<span class="hljs-number">12</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"u1"</span>, &amp;u1, <span class="hljs-string">"u2"</span>, &amp;u2)
<span class="hljs-number">13</span> }
<span class="hljs-number">14</span>
<span class="hljs-number">15</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }
<span class="hljs-number">25</span>
<span class="hljs-number">26</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'utilise la directive go: noinline pour que le compilateur n'incorpore pas de code pour ces fonctions directement dans main. L'incorporation supprimera les appels de fonction et compliquera cet exemple. Je parlerai des effets secondaires de l'intégration dans le prochain post.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Le listing 1 montre un programme avec deux fonctions différentes qui créent une valeur de type user et la renvoient à l'appelant. La première version de la fonction utilise la sémantique de la valeur lors du retour. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai dit que la fonction utilise la sémantique des valeurs lors du retour, car une valeur de type user créée par cette fonction est copiée et transmise à la pile des appels. Cela signifie que la fonction appelante reçoit une copie de la valeur elle-même.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Vous pouvez voir la création d'une valeur de type utilisateur, exécutée sur les lignes 17 à 20. Ensuite, sur la ligne 23, une copie de la valeur est transmise à la pile des appels et renvoyée à l'appelant. Après avoir renvoyé la fonction, la pile se présente comme suit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Image 1 </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hs/me/pj/hsmepjswe1d_ggonuc8jkwscyk8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la figure 1, vous pouvez voir qu'une valeur de type user existe dans les deux trames après avoir appelé createUserV1. Dans la deuxième version de la fonction, la sémantique du pointeur est utilisée pour retourner. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 3</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai dit qu'une fonction utilise la sémantique du pointeur lors du retour, car une valeur de type user créée par cette fonction est partagée par la pile d'appels. Cela signifie que la fonction appelante reçoit une copie de l'adresse où se trouvent les valeurs.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Vous pouvez voir le même littéral structurel qui est utilisé dans les lignes 28 à 31 pour créer une valeur de type utilisateur, mais à la ligne 34, le retour de la fonction est différent. Au lieu de transmettre une copie de la valeur à la pile d'appels, une copie de l'adresse de la valeur est transmise. Sur cette base, vous pourriez penser qu'après l'appel, la pile ressemble à ceci. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Image 2</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mu/ld/nh/muldnhq-xncjaz97pv-647tybme.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si ce que vous voyez sur la figure 2 se produit réellement, vous aurez un problème d'intégrité. </font><font style="vertical-align: inherit;">Un pointeur pointe vers une pile d'appels à la mémoire qui n'est plus valide. </font><font style="vertical-align: inherit;">La prochaine fois que la fonction sera appelée, la mémoire indiquée sera reformatée et réinitialisée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est là que l'analyse d'échappement commence à maintenir l'intégrité. </font><font style="vertical-align: inherit;">Dans ce cas, le compilateur déterminera qu'il n'est pas sûr de créer une valeur de type user dans le cadre de pile createUserV2, donc il créera à la place une valeur sur le tas. </font><font style="vertical-align: inherit;">Cela se produira immédiatement lors de la construction de la ligne 28.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lisibilité</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous l'avez appris dans un article précédent, une fonction a un accès direct à la mémoire à l'intérieur de son cadre via le pointeur de cadre, mais l'accès à la mémoire à l'extérieur du cadre nécessite un accès indirect. Cela signifie que l'accès aux valeurs qui tombent dans le tas doit également se faire indirectement via un pointeur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N'oubliez pas à quoi ressemble le code createUserV2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 4</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La syntaxe masque ce qui se passe réellement dans ce code. La variable u déclarée à la ligne 28 représente une valeur de type utilisateur. La construction dans Go ne vous indique pas exactement où la valeur est stockée en mémoire, donc avant l'instruction de retour à la ligne 34, vous ne savez pas que la valeur sera stockée. Cela signifie que bien que u représente une valeur de type utilisateur, l'accès à cette valeur doit se faire via un pointeur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez visualiser une pile qui ressemble à ceci après un appel de fonction. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Image 3</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5u/ya/sv/5uyasv63ozdef8jclixqpv4anx4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La variable u dans le cadre de pile pour createUserV2 représente la valeur sur le tas, pas sur la pile. </font><font style="vertical-align: inherit;">Cela signifie que l'utilisation de u pour accéder à une valeur nécessite l'accès à un pointeur, pas l'accès direct suggéré par la syntaxe. </font><font style="vertical-align: inherit;">Vous pourriez penser, pourquoi ne pas créer immédiatement un pointeur, car l'accès à la valeur qu'il représente nécessite toujours l'utilisation d'un pointeur? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 5</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := &amp;user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous le faites, vous perdrez la lisibilité, ce que vous ne pourriez pas perdre dans votre code. </font><font style="vertical-align: inherit;">Éloignez-vous du corps de fonction pendant une seconde et concentrez-vous uniquement sur le retour. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 6</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De quoi parle ce retour? </font><font style="vertical-align: inherit;">Tout ce qu'il dit, c'est qu'une copie de u est poussée sur la pile des appels. </font><font style="vertical-align: inherit;">En attendant, que vous indique return lorsque vous utilisez l'opérateur &amp;? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 7</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grâce à l'opérateur &amp; return, il vous indique maintenant que vous partagez la pile d'appels et par conséquent sortez dans le tas. N'oubliez pas que les pointeurs sont destinés à être utilisés ensemble et lors de la lecture du code, ils remplacent l'opérateur &amp; par la phrase «partage». Il est très puissant en termes de lisibilité. C'est quelque chose que je ne voudrais pas perdre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un autre exemple où la construction de valeurs à l'aide de la sémantique des pointeurs dégrade la lisibilité. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 8</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">var</span> u *user
<span class="hljs-number">02</span> err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(r), &amp;u)
<span class="hljs-number">03</span> <span class="hljs-keyword">return</span> u, err</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que ce code fonctionne, lorsque vous appelez json.Unmarshal à la ligne 02, vous devez passer un pointeur vers une variable de pointeur. Un appel json.Unmarshal créera une valeur de type user et assignera son adresse à une variable pointeur. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/koI8EjpeIx</font></font></a> </i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ce que dit ce code: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
01: Créez un pointeur de type utilisateur avec une valeur nulle. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
02: Partager la variable u avec la fonction json.Unmarshal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
03: Renvoyez une copie de la variable u à l'appelant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'est pas tout à fait évident qu'une valeur de type user créée par la fonction json.Unmarshal est passée à l'appelant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment la lisibilité change-t-elle lors de l'utilisation de la sémantique des valeurs lors de la déclaration des variables? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 9</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">var</span> u user
<span class="hljs-number">02</span> err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(r), &amp;u)
<span class="hljs-number">03</span> <span class="hljs-keyword">return</span> &amp;u, err</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce que dit ce code: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
01: Créez une valeur de type utilisateur avec une valeur nulle. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
02: Partager la variable u avec la fonction json.Unmarshal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
03: Partagez la variable u avec l'appelant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout est très clair. </font><font style="vertical-align: inherit;">La ligne 02 divise la valeur du type utilisateur dans la pile d'appels dans json.Unmarshal, et la ligne 03 divise la valeur de la pile d'appels vers l'appelant. </font><font style="vertical-align: inherit;">Ce partage entraînera le déplacement de la valeur vers le segment de mémoire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilisez la sémantique des valeurs lors de la création de valeurs et profitez de la lisibilité de l'opérateur &amp; pour clarifier comment les valeurs sont séparées.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rapports du compilateur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour voir les décisions prises par le compilateur, vous pouvez demander au compilateur de fournir un rapport. </font><font style="vertical-align: inherit;">Tout ce que vous avez à faire est d'utiliser le commutateur -gcflags avec l'option -m lors de l'appel à go build. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, vous pouvez utiliser 4 niveaux de -m, mais après 2 niveaux d'informations, cela devient trop. </font><font style="vertical-align: inherit;">J'utiliserai 2 niveaux -m. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 10</font></font><br>
<br>
<pre><code class="bash hljs">$ go build -gcflags <span class="hljs-string">"-m -m"</span><font></font>
./main.go:16: cannot inline createUserV1: marked go:noinline<font></font>
./main.go:27: cannot inline createUserV2: marked go:noinline<font></font>
./main.go:8: cannot inline main: non-leaf <span class="hljs-keyword">function</span><font></font>
./main.go:22: createUserV1 &amp;u does not escape<font></font>
./main.go:34: &amp;u escapes to heap<font></font>
./main.go:34:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34<font></font>
./main.go:31: moved to heap: u<font></font>
./main.go:33: createUserV2 &amp;u does not escape<font></font>
./main.go:12: main &amp;u1 does not escape<font></font>
./main.go:12: main &amp;u2 does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez voir que le compilateur signale les décisions de vider la valeur dans le tas. </font><font style="vertical-align: inherit;">Que dit le compilateur? </font><font style="vertical-align: inherit;">Tout d'abord, regardez à nouveau les fonctions createUserV1 et createUserV2 pour les actualiser en mémoire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 13</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }<font></font>
<font></font>
<span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par cette ligne dans le rapport. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 14</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:22: createUserV1 &amp;u does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela suggère que l'appel à la fonction println à l'intérieur de la fonction createUserV1 ne provoque pas de vidage du type utilisateur vers le tas. Ce cas a dû être vérifié car il est utilisé en conjonction avec la fonction println. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, regardez ces lignes dans le rapport. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 15</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:34: &amp;u escapes to heap<font></font>
./main.go:34:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34<font></font>
./main.go:31: moved to heap: u<font></font>
./main.go:33: createUserV2 &amp;u does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces lignes indiquent que la valeur du type d'utilisateur associé à la variable u, qui a le type d'utilisateur nommé et qui est créée sur la ligne 31, est transférée dans le tas en raison du retour sur la ligne 34. La dernière ligne dit la même chose que précédemment, println appelle sur la ligne 33 ne réinitialise pas le type d'utilisateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lecture de ces rapports peut prêter à confusion et peut varier légèrement selon que le type de la variable en question est basé sur un type nommé ou littéral. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modifiez la variable u pour être l'utilisateur de type littéral * au lieu de l'utilisateur de type nommé, comme c'était le cas auparavant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 16</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := &amp;user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exécutez à nouveau le rapport. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 17</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:30: &amp;user literal escapes to heap<font></font>
./main.go:30:     from u (assigned) at ./main.go:28<font></font>
./main.go:30:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le rapport indique maintenant que la valeur du type d'utilisateur référencé par la variable u, qui a le type littéral * utilisateur et créé sur la ligne 28, est transférée dans le tas en raison du retour sur la ligne 34.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La création d'une valeur ne détermine pas où elle se trouve. </font><font style="vertical-align: inherit;">Seule la façon dont la valeur est divisée déterminera ce que le compilateur fera de cette valeur. </font><font style="vertical-align: inherit;">Chaque fois que vous partagez une valeur dans la pile d'appels, elle est transférée dans le tas. </font><font style="vertical-align: inherit;">Il existe d'autres raisons pour lesquelles une valeur peut s'échapper de la pile. </font><font style="vertical-align: inherit;">J'en parlerai dans le prochain post.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le but de ces messages est de fournir des conseils sur le choix de l'utilisation de la sémantique des valeurs ou de la sémantique des pointeurs pour tout type donné. </font><font style="vertical-align: inherit;">Chaque sémantique est associée au profit et à la valeur. </font><font style="vertical-align: inherit;">La sémantique des valeurs stocke les valeurs sur la pile, ce qui réduit la charge sur le GC. </font><font style="vertical-align: inherit;">Cependant, il existe différentes copies de la même valeur qui doivent être stockées, suivies et conservées. </font><font style="vertical-align: inherit;">La sémantique du pointeur place les valeurs dans un tas, ce qui peut exercer une pression sur le GC. </font><font style="vertical-align: inherit;">Cependant, ils sont efficaces car il n'y a qu'une seule valeur qui doit être stockée, suivie et maintenue. </font><font style="vertical-align: inherit;">Le point clé est l'utilisation de chaque sémantique correctement, de manière cohérente et équilibrée.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr497982/index.html">Approche fonctionnelle et processus de la gestion. Comment et quoi gérer?</a></li>
<li><a href="../fr497984/index.html">Migration de reCAPTCHA vers hCaptcha dans Cloudflare</a></li>
<li><a href="../fr497986/index.html">Surveillance de toute la mémoire utilisée par une page Web: performance.measureMemory ()</a></li>
<li><a href="../fr497988/index.html">Profilage des performances des applications React</a></li>
<li><a href="../fr497990/index.html">PostgreSQL: Développement d'extensions (fonctions) en langage C</a></li>
<li><a href="../fr497996/index.html">Vous ne voulez pas renforcer l'immunité. Ou les extrêmes du corps humain</a></li>
<li><a href="../fr498000/index.html">Ce que j'aimerais savoir avant de développer mon propre jeu</a></li>
<li><a href="../fr498002/index.html">Guide de poche du Z3</a></li>
<li><a href="../fr498004/index.html">Station de travail dans un conteneur Docker</a></li>
<li><a href="../fr498006/index.html">Choisir un conseil en brevets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>