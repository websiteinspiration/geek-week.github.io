<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî£ ‚òîÔ∏è üõÅ Analyse des √©chapp√©es par la m√©canique du langage üë©üèæ‚Äçüé® üåÖ ü§π</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©lude
 Il s'agit du deuxi√®me des quatre articles d'une s√©rie qui donnera un aper√ßu de la m√©canique et de la conception des pointeurs, des piles, des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Analyse des √©chapp√©es par la m√©canique du langage</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497994/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√©lude</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit du deuxi√®me des quatre articles d'une s√©rie qui donnera un aper√ßu de la m√©canique et de la conception des pointeurs, des piles, des tas, de l'analyse d'√©chappement et de la s√©mantique Go / Value. </font><font style="vertical-align: inherit;">Ce post est sur les tas et l'analyse des √©chapp√©es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Table des mati√®res:</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©canique du langage sur piles et pointeurs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traduction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©canique du langage sur l'analyse d'√©chappement</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©canique du langage sur le profilage de la m√©moire</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Philosophie de conception sur les donn√©es et la s√©mantique</font></font></a></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le premier article de cette s√©rie, j'ai parl√© des bases de la m√©canique des pointeurs en utilisant un exemple dans lequel la valeur est r√©partie sur la pile entre les goroutines. Je ne vous ai pas montr√© ce qui se passe lorsque vous divisez la valeur sur la pile. Pour comprendre cela, vous devez vous renseigner sur un autre domaine de la m√©moire o√π les valeurs peuvent √™tre: sur le ¬´tas¬ª. Avec cette connaissance, vous pouvez commencer √† √©tudier "l'analyse d'√©chappement".</font></font><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'analyse d'√©chappement est un processus que le compilateur utilise pour d√©terminer le placement des valeurs cr√©√©es par votre programme. </font><font style="vertical-align: inherit;">En particulier, le compilateur effectue une analyse de code statique pour d√©terminer si la valeur peut √™tre plac√©e sur le cadre de pile pour la fonction qui la construit, ou si la valeur doit √™tre "√©chapp√©e" dans le tas. </font><font style="vertical-align: inherit;">Il n'y a pas un seul mot-cl√© ou fonction dans Go que vous pouvez utiliser pour indiquer au compilateur la d√©cision √† prendre. </font><font style="vertical-align: inherit;">Seule la fa√ßon dont vous √©crivez votre code conditionnellement vous permet d'influencer cette d√©cision.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des tas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un tas est une deuxi√®me zone de m√©moire, en plus de la pile, utilis√©e pour stocker des valeurs. Le tas n'est pas autonettoyant comme les piles, donc l'utilisation de cette m√©moire est plus co√ªteuse. Tout d'abord, les co√ªts sont associ√©s au ramasse-miettes (GC), qui doit garder cette zone propre. Lorsque le GC d√©marre, il utilise 25% de la puissance disponible de votre processeur. De plus, il peut potentiellement cr√©er des microsecondes de retards ¬´stop the world¬ª. L'avantage d'avoir un GC est que vous n'avez pas √† vous soucier de la gestion de la m√©moire de tas qui a toujours √©t√© complexe et sujette aux erreurs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les valeurs du tas provoquent des allocations de m√©moire dans Go. </font><font style="vertical-align: inherit;">Ces allocations exercent une pression sur le GC, car chaque valeur du tas √† laquelle le pointeur ne fait plus r√©f√©rence doit √™tre supprim√©e. </font><font style="vertical-align: inherit;">Plus vous devez v√©rifier et supprimer de valeurs, plus le GC doit faire de travail √† chaque d√©marrage. </font><font style="vertical-align: inherit;">Par cons√©quent, l'algorithme de stimulation travaille constamment pour √©quilibrer la taille du tas et la vitesse d'ex√©cution.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partage de pile</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans Go, aucun goroutine n'est autoris√© √† avoir un pointeur pointant vers une m√©moire sur la pile d'un autre goroutine. </font><font style="vertical-align: inherit;">Cela est d√ª au fait que la m√©moire de la pile pour les goroutines peut √™tre remplac√©e par un nouveau bloc de m√©moire lorsque la pile doit augmenter ou diminuer. </font><font style="vertical-align: inherit;">Si au moment de l'ex√©cution, vous deviez suivre les pointeurs vers la pile dans un autre goroutine, vous auriez √† g√©rer trop, et le retard de "stop the world" lors de la mise √† jour des pointeurs vers ces piles serait stup√©fiant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un exemple d'une pile qui est remplac√©e plusieurs fois en raison de la croissance. </font><font style="vertical-align: inherit;">Regardez la sortie dans les lignes 2 et 6. Vous verrez deux fois les changements d'adresse de la valeur de cha√Æne √† l'int√©rieur du cadre de pile principal. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/pxn5u4EBSI</font></font></a> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©canique d'√©chappement</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque fois qu'une valeur est partag√©e en dehors de la r√©gion du cadre de pile d'une fonction, elle est plac√©e (ou allou√©e) dans un segment de m√©moire. La t√¢che des algorithmes d'analyse d'√©chappement est de trouver de telles situations et de maintenir le niveau d'int√©grit√© dans le programme. L'int√©grit√© consiste √† garantir que l'acc√®s √† toute valeur est toujours pr√©cis, coh√©rent et efficace. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetez un ≈ìil √† cet exemple pour apprendre les m√©canismes de base de l'analyse d'√©chappement. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/Y_VZxYteKO</font></font></a> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Listing 1</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span> {
<span class="hljs-number">04</span>     name  <span class="hljs-keyword">string</span>
<span class="hljs-number">05</span>     email <span class="hljs-keyword">string</span>
<span class="hljs-number">06</span> }
<span class="hljs-number">07</span>
<span class="hljs-number">08</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">09</span>     u1 := createUserV1()
<span class="hljs-number">10</span>     u2 := createUserV2()
<span class="hljs-number">11</span>
<span class="hljs-number">12</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"u1"</span>, &amp;u1, <span class="hljs-string">"u2"</span>, &amp;u2)
<span class="hljs-number">13</span> }
<span class="hljs-number">14</span>
<span class="hljs-number">15</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }
<span class="hljs-number">25</span>
<span class="hljs-number">26</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'utilise la directive go: noinline pour que le compilateur n'incorpore pas de code pour ces fonctions directement dans main. L'incorporation supprimera les appels de fonction et compliquera cet exemple. Je parlerai des effets secondaires de l'int√©gration dans le prochain post.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Le listing 1 montre un programme avec deux fonctions diff√©rentes qui cr√©ent une valeur de type user et la renvoient √† l'appelant. La premi√®re version de la fonction utilise la s√©mantique de la valeur lors du retour. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai dit que la fonction utilise la s√©mantique des valeurs lors du retour, car une valeur de type user cr√©√©e par cette fonction est copi√©e et transmise √† la pile des appels. Cela signifie que la fonction appelante re√ßoit une copie de la valeur elle-m√™me.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Vous pouvez voir la cr√©ation d'une valeur de type utilisateur, ex√©cut√©e sur les lignes 17 √† 20. Ensuite, sur la ligne 23, une copie de la valeur est transmise √† la pile des appels et renvoy√©e √† l'appelant. Apr√®s avoir renvoy√© la fonction, la pile se pr√©sente comme suit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Image 1 </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hs/me/pj/hsmepjswe1d_ggonuc8jkwscyk8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la figure 1, vous pouvez voir qu'une valeur de type user existe dans les deux trames apr√®s avoir appel√© createUserV1. Dans la deuxi√®me version de la fonction, la s√©mantique du pointeur est utilis√©e pour retourner. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 3</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai dit qu'une fonction utilise la s√©mantique du pointeur lors du retour, car une valeur de type user cr√©√©e par cette fonction est partag√©e par la pile d'appels. Cela signifie que la fonction appelante re√ßoit une copie de l'adresse o√π se trouvent les valeurs.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Vous pouvez voir le m√™me litt√©ral structurel qui est utilis√© dans les lignes 28 √† 31 pour cr√©er une valeur de type utilisateur, mais √† la ligne 34, le retour de la fonction est diff√©rent. Au lieu de transmettre une copie de la valeur √† la pile d'appels, une copie de l'adresse de la valeur est transmise. Sur cette base, vous pourriez penser qu'apr√®s l'appel, la pile ressemble √† ceci. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Image 2</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mu/ld/nh/muldnhq-xncjaz97pv-647tybme.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si ce que vous voyez sur la figure 2 se produit r√©ellement, vous aurez un probl√®me d'int√©grit√©. </font><font style="vertical-align: inherit;">Un pointeur pointe vers une pile d'appels √† la m√©moire qui n'est plus valide. </font><font style="vertical-align: inherit;">La prochaine fois que la fonction sera appel√©e, la m√©moire indiqu√©e sera reformat√©e et r√©initialis√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est l√† que l'analyse d'√©chappement commence √† maintenir l'int√©grit√©. </font><font style="vertical-align: inherit;">Dans ce cas, le compilateur d√©terminera qu'il n'est pas s√ªr de cr√©er une valeur de type user dans le cadre de pile createUserV2, donc il cr√©era √† la place une valeur sur le tas. </font><font style="vertical-align: inherit;">Cela se produira imm√©diatement lors de la construction de la ligne 28.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lisibilit√©</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous l'avez appris dans un article pr√©c√©dent, une fonction a un acc√®s direct √† la m√©moire √† l'int√©rieur de son cadre via le pointeur de cadre, mais l'acc√®s √† la m√©moire √† l'ext√©rieur du cadre n√©cessite un acc√®s indirect. Cela signifie que l'acc√®s aux valeurs qui tombent dans le tas doit √©galement se faire indirectement via un pointeur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N'oubliez pas √† quoi ressemble le code createUserV2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 4</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La syntaxe masque ce qui se passe r√©ellement dans ce code. La variable u d√©clar√©e √† la ligne 28 repr√©sente une valeur de type utilisateur. La construction dans Go ne vous indique pas exactement o√π la valeur est stock√©e en m√©moire, donc avant l'instruction de retour √† la ligne 34, vous ne savez pas que la valeur sera stock√©e. Cela signifie que bien que u repr√©sente une valeur de type utilisateur, l'acc√®s √† cette valeur doit se faire via un pointeur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez visualiser une pile qui ressemble √† ceci apr√®s un appel de fonction. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Image 3</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5u/ya/sv/5uyasv63ozdef8jclixqpv4anx4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La variable u dans le cadre de pile pour createUserV2 repr√©sente la valeur sur le tas, pas sur la pile. </font><font style="vertical-align: inherit;">Cela signifie que l'utilisation de u pour acc√©der √† une valeur n√©cessite l'acc√®s √† un pointeur, pas l'acc√®s direct sugg√©r√© par la syntaxe. </font><font style="vertical-align: inherit;">Vous pourriez penser, pourquoi ne pas cr√©er imm√©diatement un pointeur, car l'acc√®s √† la valeur qu'il repr√©sente n√©cessite toujours l'utilisation d'un pointeur? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 5</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := &amp;user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous le faites, vous perdrez la lisibilit√©, ce que vous ne pourriez pas perdre dans votre code. </font><font style="vertical-align: inherit;">√âloignez-vous du corps de fonction pendant une seconde et concentrez-vous uniquement sur le retour. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 6</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De quoi parle ce retour? </font><font style="vertical-align: inherit;">Tout ce qu'il dit, c'est qu'une copie de u est pouss√©e sur la pile des appels. </font><font style="vertical-align: inherit;">En attendant, que vous indique return lorsque vous utilisez l'op√©rateur &amp;? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 7</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gr√¢ce √† l'op√©rateur &amp; return, il vous indique maintenant que vous partagez la pile d'appels et par cons√©quent sortez dans le tas. N'oubliez pas que les pointeurs sont destin√©s √† √™tre utilis√©s ensemble et lors de la lecture du code, ils remplacent l'op√©rateur &amp; par la phrase ¬´partage¬ª. Il est tr√®s puissant en termes de lisibilit√©. C'est quelque chose que je ne voudrais pas perdre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un autre exemple o√π la construction de valeurs √† l'aide de la s√©mantique des pointeurs d√©grade la lisibilit√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 8</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">var</span> u *user
<span class="hljs-number">02</span> err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(r), &amp;u)
<span class="hljs-number">03</span> <span class="hljs-keyword">return</span> u, err</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que ce code fonctionne, lorsque vous appelez json.Unmarshal √† la ligne 02, vous devez passer un pointeur vers une variable de pointeur. Un appel json.Unmarshal cr√©era une valeur de type user et assignera son adresse √† une variable pointeur. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/koI8EjpeIx</font></font></a> </i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ce que dit ce code: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
01: Cr√©ez un pointeur de type utilisateur avec une valeur nulle. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
02: Partager la variable u avec la fonction json.Unmarshal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
03: Renvoyez une copie de la variable u √† l'appelant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'est pas tout √† fait √©vident qu'une valeur de type user cr√©√©e par la fonction json.Unmarshal est pass√©e √† l'appelant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment la lisibilit√© change-t-elle lors de l'utilisation de la s√©mantique des valeurs lors de la d√©claration des variables? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 9</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">var</span> u user
<span class="hljs-number">02</span> err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(r), &amp;u)
<span class="hljs-number">03</span> <span class="hljs-keyword">return</span> &amp;u, err</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce que dit ce code: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
01: Cr√©ez une valeur de type utilisateur avec une valeur nulle. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
02: Partager la variable u avec la fonction json.Unmarshal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
03: Partagez la variable u avec l'appelant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout est tr√®s clair. </font><font style="vertical-align: inherit;">La ligne 02 divise la valeur du type utilisateur dans la pile d'appels dans json.Unmarshal, et la ligne 03 divise la valeur de la pile d'appels vers l'appelant. </font><font style="vertical-align: inherit;">Ce partage entra√Ænera le d√©placement de la valeur vers le segment de m√©moire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilisez la s√©mantique des valeurs lors de la cr√©ation de valeurs et profitez de la lisibilit√© de l'op√©rateur &amp; pour clarifier comment les valeurs sont s√©par√©es.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rapports du compilateur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour voir les d√©cisions prises par le compilateur, vous pouvez demander au compilateur de fournir un rapport. </font><font style="vertical-align: inherit;">Tout ce que vous avez √† faire est d'utiliser le commutateur -gcflags avec l'option -m lors de l'appel √† go build. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, vous pouvez utiliser 4 niveaux de -m, mais apr√®s 2 niveaux d'informations, cela devient trop. </font><font style="vertical-align: inherit;">J'utiliserai 2 niveaux -m. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 10</font></font><br>
<br>
<pre><code class="bash hljs">$ go build -gcflags <span class="hljs-string">"-m -m"</span><font></font>
./main.go:16: cannot inline createUserV1: marked go:noinline<font></font>
./main.go:27: cannot inline createUserV2: marked go:noinline<font></font>
./main.go:8: cannot inline main: non-leaf <span class="hljs-keyword">function</span><font></font>
./main.go:22: createUserV1 &amp;u does not escape<font></font>
./main.go:34: &amp;u escapes to heap<font></font>
./main.go:34:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34<font></font>
./main.go:31: moved to heap: u<font></font>
./main.go:33: createUserV2 &amp;u does not escape<font></font>
./main.go:12: main &amp;u1 does not escape<font></font>
./main.go:12: main &amp;u2 does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez voir que le compilateur signale les d√©cisions de vider la valeur dans le tas. </font><font style="vertical-align: inherit;">Que dit le compilateur? </font><font style="vertical-align: inherit;">Tout d'abord, regardez √† nouveau les fonctions createUserV1 et createUserV2 pour les actualiser en m√©moire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 13</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }<font></font>
<font></font>
<span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commen√ßons par cette ligne dans le rapport. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 14</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:22: createUserV1 &amp;u does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela sugg√®re que l'appel √† la fonction println √† l'int√©rieur de la fonction createUserV1 ne provoque pas de vidage du type utilisateur vers le tas. Ce cas a d√ª √™tre v√©rifi√© car il est utilis√© en conjonction avec la fonction println. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, regardez ces lignes dans le rapport. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 15</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:34: &amp;u escapes to heap<font></font>
./main.go:34:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34<font></font>
./main.go:31: moved to heap: u<font></font>
./main.go:33: createUserV2 &amp;u does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces lignes indiquent que la valeur du type d'utilisateur associ√© √† la variable u, qui a le type d'utilisateur nomm√© et qui est cr√©√©e sur la ligne 31, est transf√©r√©e dans le tas en raison du retour sur la ligne 34. La derni√®re ligne dit la m√™me chose que pr√©c√©demment, println appelle sur la ligne 33 ne r√©initialise pas le type d'utilisateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lecture de ces rapports peut pr√™ter √† confusion et peut varier l√©g√®rement selon que le type de la variable en question est bas√© sur un type nomm√© ou litt√©ral. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modifiez la variable u pour √™tre l'utilisateur de type litt√©ral * au lieu de l'utilisateur de type nomm√©, comme c'√©tait le cas auparavant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 16</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := &amp;user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ex√©cutez √† nouveau le rapport. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 17</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:30: &amp;user literal escapes to heap<font></font>
./main.go:30:     from u (assigned) at ./main.go:28<font></font>
./main.go:30:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le rapport indique maintenant que la valeur du type d'utilisateur r√©f√©renc√© par la variable u, qui a le type litt√©ral * utilisateur et cr√©√© sur la ligne 28, est transf√©r√©e dans le tas en raison du retour sur la ligne 34.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La cr√©ation d'une valeur ne d√©termine pas o√π elle se trouve. </font><font style="vertical-align: inherit;">Seule la fa√ßon dont la valeur est divis√©e d√©terminera ce que le compilateur fera de cette valeur. </font><font style="vertical-align: inherit;">Chaque fois que vous partagez une valeur dans la pile d'appels, elle est transf√©r√©e dans le tas. </font><font style="vertical-align: inherit;">Il existe d'autres raisons pour lesquelles une valeur peut s'√©chapper de la pile. </font><font style="vertical-align: inherit;">J'en parlerai dans le prochain post.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le but de ces messages est de fournir des conseils sur le choix de l'utilisation de la s√©mantique des valeurs ou de la s√©mantique des pointeurs pour tout type donn√©. </font><font style="vertical-align: inherit;">Chaque s√©mantique est associ√©e au profit et √† la valeur. </font><font style="vertical-align: inherit;">La s√©mantique des valeurs stocke les valeurs sur la pile, ce qui r√©duit la charge sur le GC. </font><font style="vertical-align: inherit;">Cependant, il existe diff√©rentes copies de la m√™me valeur qui doivent √™tre stock√©es, suivies et conserv√©es. </font><font style="vertical-align: inherit;">La s√©mantique du pointeur place les valeurs dans un tas, ce qui peut exercer une pression sur le GC. </font><font style="vertical-align: inherit;">Cependant, ils sont efficaces car il n'y a qu'une seule valeur qui doit √™tre stock√©e, suivie et maintenue. </font><font style="vertical-align: inherit;">Le point cl√© est l'utilisation de chaque s√©mantique correctement, de mani√®re coh√©rente et √©quilibr√©e.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr497982/index.html">Approche fonctionnelle et processus de la gestion. Comment et quoi g√©rer?</a></li>
<li><a href="../fr497984/index.html">Migration de reCAPTCHA vers hCaptcha dans Cloudflare</a></li>
<li><a href="../fr497986/index.html">Surveillance de toute la m√©moire utilis√©e par une page Web: performance.measureMemory ()</a></li>
<li><a href="../fr497988/index.html">Profilage des performances des applications React</a></li>
<li><a href="../fr497990/index.html">PostgreSQL: D√©veloppement d'extensions (fonctions) en langage C</a></li>
<li><a href="../fr497996/index.html">Vous ne voulez pas renforcer l'immunit√©. Ou les extr√™mes du corps humain</a></li>
<li><a href="../fr498000/index.html">Ce que j'aimerais savoir avant de d√©velopper mon propre jeu</a></li>
<li><a href="../fr498002/index.html">Guide de poche du Z3</a></li>
<li><a href="../fr498004/index.html">Station de travail dans un conteneur Docker</a></li>
<li><a href="../fr498006/index.html">Choisir un conseil en brevets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>