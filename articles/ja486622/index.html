<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍💻 ❄️ 👩‍💼 並列計算モデル 🐎 ⏏️ 👈🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1.はじめに。競争的コルチニズム
 自動プログラミングのトピックに関するこれまでの記事は単なる「花」でした。自動プログラミングの「ベリー」、つまりあなたがそれをする必要があるのは、状態機械モデルに基づく並列計算のモデルです。それでは、始めましょう... 
 
 C ++標準には、待望のマルチスレッド...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>並列計算モデル</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486622/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.はじめに。</font><font style="vertical-align: inherit;">競争的コルチニズム</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動プログラミングのトピックに関するこれまでの記事は単なる「花」でした。自動プログラミングの「ベリー」、つまりあなたがそれをする必要があるのは、状態機械モデルに基づく並列計算のモデルです。それでは、始めましょう... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++標準には、待望のマルチスレッド化サポートが含まれています[1]。しかし、私たちはそれを賞賛することも、この事実を批判することもしません。スレッドでの作業は、マルチスレッドの問題を明らかにする実際の例がなければ、マルチスレッドプログラミングの議論は急いでいるだけでなく、かなり偏ったものになるような非常に多くの条件、警告、および機能によって圧迫されます。したがって、以下では主にフローについてではなく、もちろん最初のものを念頭に置いて、オートマトンについて説明します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++言語は最初のものとはほど遠いものであり、並列処理構文によって補足されています。前世紀の60年代に戻って、N。ワースはALGOL言語の並行拡張を提案しました[2]。ただし、今後60年間は、並列アルゴリズムと見なすべきもの、および並列コンピューティングのモデルとすべきものを明確にしていません。どうやら、C ++言語のそのような遅れた拡張もこれに関連しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ALGOL言語の長年にわたる構成と、C ++言語でのより現代的な類似物は、並列アルゴリズムモデルを導入しない構造並列化メソッドのみを表しています。これを正当化するために、このような正式な計算モデルを作成するために過去に行われた試みは失敗したと言えます。同じペトリネットがそれらに課された高い希望を正当化しなかったと言うには十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、並列処理開発の「スパイラル」は、「用語開発」のみを経て、元に戻ったようです。</font><font style="vertical-align: inherit;">以前の自明なコルーチンは突然進歩した「コルーチン」（英語のコルーチンからのトレーシングペーパー）になり、並列プログラミングの英語セグメントで並列および並行の概念と混同すると、逆説的なことが発生することがあります。</font><font style="vertical-align: inherit;">たとえば、本の第1版[1]は第2版と異なり、「並列」という用語を「競争力のある」に、「マルチスレッド」という用語を「並列」に置き換えています。</font><font style="vertical-align: inherit;">したがって、「誰が誰であるか」という状況でこれを理解してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.計算の並列オートマトンモデル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、プログラミング開発の次の定性的なステップが並列計算モデルへの移行に関連していることに誰も異議を唱えることはないでしょう。しかし、これが既存の計算モデルの進化的発展の結果として起こるのか、それとも根本的に異なるモデルになるのかは、まだ議論されている問題です。そして理論家がまだ議論しているなら、プログラマーの実際に動機付けられた部分はすでにプログラムを並列化するための構造的方法を使用しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
職務の分離と生産性の向上が、同時実行性を使用する唯一の理由であると考えられています。少なくとも、それらまたはそれらの組み合わせに対して、最終的に他のすべてを削減するか、削減しようとします[1]。しかし、めったに話されない理由がありますが、そのため、一般的に並列プログラミングに取り組む価値があります。実際、純粋にハードウェアによる方法で速度を上げることができ、並列処理による職務の分離は、銀行の従業員の日常の仕事と同じように、その職務のリストと関連付けられています。そして、並列アルゴリズムのみが、タスクの複雑さを打ち破り、プログラムの信頼性を向上させる戦略です。そしてこれはすべて、並列プログラムを複雑で信頼性の低いソフトウェア製品に変えるマルチスレッドプログラミングに関する一般的な意見に反しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの並列機能でアクティブに相互作用するコンポーネント、オブジェクト、エージェントなどで構成される並列システムは、個々のコンポーネントのアルゴリズムではなく（もちろん、コンポーネントの数によって）数によって決定されるアルゴリズムを実装します。それらの間の一種の接続。この複雑さを制御し、並列システムのアルゴリズムを理解するためには、並列計算モデルだけでなく、とりわけ適切な理論を持つモデルが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「並列プログラムの方が理解が難しいことが多いので、エラーが増えている」というのは、控えめに言っても議論の余地があります。</font><font style="vertical-align: inherit;">はい、並列プログラムアルゴリズムは理解するのが非常に難しい場合がありますが、理論があれば、コンポーネントアルゴリズムを使用して正式に「計算」できます。</font><font style="vertical-align: inherit;">また、コンポーネントのアルゴリズムの設計、実装、保守の観点から見ると、システム全体のアルゴリズムよりもはるかに単純です。</font><font style="vertical-align: inherit;">より単純なコンポーネントを設計する場合、システムを1つに設計するよりも間違いを少なくすることができます。</font><font style="vertical-align: inherit;">さらに、デバッグされたコンポーネントは他のシステムの一部となり、複雑さを減らし、信頼性を高め、設計コストを最小限に抑えることができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.シリアル並行性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事[3]では、有限状態機械の別のモデルの並列性について説明しました。遷移の実行レベルでのチャネルは、それに関連する関数/メソッドの並列実行を指定します-述語とアクション。同時に、述語の並列処理に制限はありません。働くとき、それらは互いに衝突しません、なぜならメモリの内容には影響しません。並行して動作するアクションは、共通の入力データと出力データを持つことができ、それらを互いに独立して変更できます。そして、これらすべてが出力データの値の不確実性の原因になる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の状況でアクションを正しく操作すると、シャドウメモリが提供されます。</font><font style="vertical-align: inherit;">新しい値を格納することで、1つのアクション内で同じデータを入力と出力の両方として使用できます。</font><font style="vertical-align: inherit;">例は、y =！Yとして記述される矩形パルスジェネレーターのモデルです。ここで、yはジェネレーターの出力です。</font><font style="vertical-align: inherit;">VKPa環境でのC ++コードをリスト1に示し、プログラムの結果を図1に示します。</font><font style="vertical-align: inherit;">1。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト1.矩形パルス発生器</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSWGenerator</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FSWGenerator(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FSWGenerator(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FSWGenerator(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSWGenerator.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_SWGenerator[] = {<font></font>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FSWGenerator::FSWGenerator(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_SWGenerator, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{<font></font>
    pTAppCore = pInfo;<font></font>
}<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSWGenerator::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-comment">// setting output signals</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSWGenerator::y1</span><span class="hljs-params">()</span> </span>{<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, !<span class="hljs-keyword">bool</span>(pVarY-&gt;GetDataSrc()));<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
 <img src="https://habrastorage.org/webt/3f/ue/ni/3fueni68ys5fwldckqdbodllckm.jpeg" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 1. VKPAでの矩形パルスジェネレーターの動作のシミュレーション</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この場合、マシンには1つの状態があり、アクションy1でマークされたループの形で無条件遷移（入力条件の代わりにダッシュが付いた遷移）があり、出力変数の反転を実装し、ダイナミクスで矩形パルスを形成します。オートマトンモデルのフレームワーク内で、パルス信号の周波数は、オートマトンが読み込まれるオートマトン空間の離散時間のタクト値を設定することによって制御できます。</font></font><br>
<br>
<i> 1.          ,   .              .        .         .<br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オートマトンの離散時間と多くのオートマトン空間の存在を制御する機能は、VKPa環境の唯一の重要な特性ではありません。</font><font style="vertical-align: inherit;">それらを使用すると、並列プログラムのパフォーマンスを最適化できます。</font><font style="vertical-align: inherit;">たとえば、データの視覚化とユーザーダイアログを実装するマシンは、低速のオートマトンスペースに配置し、アプリケーションプロセスは、優先順位や希望する速度などに応じてオートマトンスペースに分散する必要があります。</font><font style="vertical-align: inherit;">等 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オートマトンモデルのフレームワーク内で、ジェネレーター出力の値はモデルの現在の状態に簡単に関連付けられます。</font><font style="vertical-align: inherit;">リスト2に、すでに2つの状態があり、それぞれがジェネレーターの出力の状態を反映しているジェネレーターモデルのコードを示します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト2.状態に関する方形波ジェネレーター</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_SWGenState[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSWGenState</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    FSWGenState(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_SWGenState, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) {};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSWGenState.h"</span></span>
<span class="hljs-comment">// state machine transition table</span><font></font>
LArc TBL_SWGenState[] = {<font></font>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいモデルでは、状態によって出力変数が置き換えられます。これにより、ご覧のように、ジェネレーターモデルが大幅に簡略化されました。</font><font style="vertical-align: inherit;">その結果、変換表でのみ表される「裸の」マシンが得られました。</font><font style="vertical-align: inherit;">VKPaで現在の状態「s1」を監視するために、SWGenStateという名前のfsa（状態）タイプの変数（S1）がSWGenStateという名前のマシン用に作成されました。</font><font style="vertical-align: inherit;">状態s1で真の値をとり、マシンが別の状態のときは偽をとります。</font><font style="vertical-align: inherit;">さらに、この変数は、VKPA環境のデータを表示するためにすでに使用されています（図2の信号の傾向を参照）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xv/it/jp/xvitjpkfffsmaodeyax2cmeotkq.jpeg" alt="画像"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">2.状態ジェネレーターのモデリング</font></font><br>
</i><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.並列計算制御モデル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、並列プロセスのモデルの作成に向けて、同時に機能し相互作用する多くの有限状態機械を使用することは論理的です。オートマトンのネットワーク。この場合、ネットワーク時間モデルを選択するという問題が発生します。これは、すべてのマシンで同じになる場合もあれば、それぞれのマシンで個別の場合もあります。 VKPaでは、選択は1回を優先して行われました（オートマトンの同期ネットワークの詳細については、[5]を参照してください）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単一の時間を選択することで、オートマトンの構成および分解の操作を持つオートマトンの代数を作成できます。最初のものを使用すると、結果として得られるオートマトンを見つけることができ、並列システムの動作の正確なアイデアを提供します。そしてここでは、並列プログラムの「理解の複雑さ」に関する上記の論文を思い出してみる価値があります。合成操作の存在により、並列プログラムの「理解の問題」を解決することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、多数のコンポーネントのネットワークに対して結果として得られるオートマトンは、非常に膨大になる可能性があります。しかし、幸いなことに、少数のコンポーネントのサブシステムまたはネットワークの動作を理解することがより頻繁に必要になります。そのため、結果のオートマトンを見つけても大きな問題は発生しません。次のRSフリップフロップモデルの例は、これを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RSトリガーモデルは、単純な並列システムの例です。クロスフィードバックがある場合は特に興味深いです。フィードバック、または別の方法では、循環チェーン、ループ、代数ループなど現在、並列システムの構造モデルにとって深刻な問題です。一般的なケースでは、メモリ要素のギャップループに導入することで許可されます。これは、オートマトンの理論によって提案された標準的なソリューションです[4]。同じ出力がMATLABの人に推奨されています。 VKPa環境は、ループの実装にそのような追加要素を導入する必要がないという点で異なります。これは非常に重要であり、実際の回路でも必要ありません（RSフリップフロップ回路を参照）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図では </font><font style="vertical-align: inherit;">図3は、RSトリガー回路で構成されるAND-NOT要素の最も単純なモデルを示しています。</font><font style="vertical-align: inherit;">要素の遅延とそのタイプ（輸送または慣性の遅延）は考慮されません。</font><font style="vertical-align: inherit;">ただし、それでも少なくとも1つの遅延ビートが含まれています。</font><font style="vertical-align: inherit;">これは、ある状態から別の状態に移行するときです。</font><font style="vertical-align: inherit;">リスト3はモデルのコードを示しています</font></font><br>
<br>
<img src="https://habrastorage.org/webt/os/8b/am/os8bam0skdc-jwtctewqmbwupci.jpeg" alt="画像"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">3.要素のモデルAND NOT</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト3.要素モデルAND NOT</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FIne</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FIne(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FIne(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FIne(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarX1;				<span class="hljs-comment">//  </span>
    CVar *pVarX2;				<span class="hljs-comment">//  </span>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameY;         <span class="hljs-comment">//   </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">bool</span> bX1, bX2, bY;<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FIne.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_Ine[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12^x1"</span>,	<span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12^x2"</span>,	<span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12x1x2"</span>,	<span class="hljs-string">"y2"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x1x2"</span>,   <span class="hljs-string">"y2"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"^x1"</span>,    <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"^x2"</span>,    <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FIne::FIne(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_Ine, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{ }<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FIne::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"x1"</span>, CLocVar::vtBool, <span class="hljs-string">" 1- "</span>);<font></font>
    pVarX2 = CreateLocVar(<span class="hljs-string">"x2"</span>, CLocVar::vtBool, <span class="hljs-string">" 2- "</span>);<font></font>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameY = CreateLocVar(<span class="hljs-string">"strNameY"</span>, CLocVar::vtString, <span class="hljs-string">"name of external output variable(y)"</span>);		<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX1) {<font></font>
        str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameX2) {<font></font>
        str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>); }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameY) {<font></font>
        str = pVarStrNameY-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>){pVarY = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);}<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">bool</span>(pVarX1-&gt;GetDataSrc()); }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">bool</span>(pVarX2-&gt;GetDataSrc()); }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarY; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y1</span><span class="hljs-params">()</span> </span>{ pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">1</span>); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y2</span><span class="hljs-params">()</span> </span>{ pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0.0</span>); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y12</span><span class="hljs-params">()</span> </span>{ FInit(); }
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図では図４は、有限状態機械の形態のＲＳフリップフロップおよびそのモデルの図を示す。モデルの矢印は、ネットワークのオートマトン間の接続を示します。ここで、モデルの状態は、要素の出力の状態を反映する一方で、並列プロセス間の情報リンクを編成するための信号としても使用されます。結果として得られるネットワークのオートマトンを非常に簡単に見つけることができるのは、この状態のモデル（状態による同期）です。それは図に示されています。 5（結果のオートマトンを見つける手順については、[6]を参照してください）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並列RSフリップフロッププログラムの[結果の]アルゴリズムと、個別のAND-NOT要素の演算アルゴリズムを比較します。違いは顕著です。この場合、コンポーネントアルゴリズムは「ハンドル」によって作成され、並列システムアルゴリズムはネットワークの「人工知能」によって暗黙的に作成されます。これは、並列プログラムと順次プログラムの定性的な違いです。通信のみ（少なくとも1つ）を変更すると、完全に異なる作業アルゴリズムが得られます。そしてそれは間違いなくもはやRSトリガーではありません。そして、ちなみに、別の結果としてのオートマトン。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/kb/zi/fc/kbzifcjk_ycehmabwwtsuh_gyfc.jpeg" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 4. RS-FFのスキームとネットワークモデル</font></font><br>
</i><br>
<img src="https://habrastorage.org/webt/_v/ht/2n/_vht2nka0gtsreim8qhjplh_njq.jpeg" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図5.結果のマシンネットワークモデルRSトリガー</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図の結果のオートマトンの分析。 5は、並列プログラム（もちろん、実際のトリガー）について次の「理解」を示します。まず、ある状態から別の状態に切り替えるとき、トリガーは必然的に出力の「禁止」状態を通過します（そして、教科書はこれについて何を言っていますか？）。第2に、トリガーが出力の単一の状態（「s1w1」の状態）に駆動され、2つのユニットが入力に供給されると、生成モードになります。状態「s1w1」と「s0w0」の間の周期的な切り替え（およびトリガー生成について聞いたことがありますか？）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際のトリガーでも禁止状態の遷移が発生しますが、実際の要素の遅延の違いにより生成モードは不可能です。図。図6は、トリガートリガーモデルの生成モードを示しています。これは、入力の単位が保存されている限り存在します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">備考2. RSトリガーの動作の一般的な説明は、圧倒的多数のケースで真理値表の形式で示されています。しかし、そうするためには、トリガーが順次スキームであることを理解することは、実際、このトピックを研究する人を故意に誤解させることになります。まあ、どのトリガーも「禁止状態」にすることはできません！しかし、何らかの理由で、この真実を発見し、特にその生成の問題について議論することを決定したのはごくわずかです（たとえば、[7]を参照）。</font></font><br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。図7は、トリガーモデルの安定状態間の切り替えを示しています。ここでは、トリガー入力の単一の状態がトリガー出力の現在の状態を保持し、これまたはその入力がゼロに設定されると、反対の状態に切り替わります。同時に、トリガーが切り替えられると、1つの離散メジャーに等しい瞬間のその出力は、同時に単一の（だれによって禁止されている？）状態になります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/fl/a0/csfla0xnbcpz0ngewn6izuj_cps.jpeg" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 6. RSトリガー生成モード</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/nc/w5/74/ncw574s_lxpj2qq4oh1krswiclk.jpeg" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図7.状態間のRSトリガーの切り替え</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つの状態と1つのアクションで構成される別のRSトリガーモデルについて考えてみましょう。</font><font style="vertical-align: inherit;">リスト1のモデルに似ています。そのコードをリスト4に示します。このモデルは、ジェネレーターモデルと同様に述語がなく、中間変換なしの信号値がアクションy1に入力されます。</font><font style="vertical-align: inherit;">これは良いですか悪いですか？</font><font style="vertical-align: inherit;">一方で、それは良いようです、なぜなら </font><font style="vertical-align: inherit;">コードはより単純になりましたが、その一方で...実際にはそうではありません。</font><font style="vertical-align: inherit;">そして今、その理由を理解します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト4. 1つのアクションからのNAND要素モデル</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FTwoOperators</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FTwoOperators(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FTwoOperators(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FTwoOperators(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarX1;				<span class="hljs-comment">//  </span>
    CVar *pVarX2;				<span class="hljs-comment">//  </span>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameY;         <span class="hljs-comment">//   </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">bool</span> bX1, bX2, bY;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FTwoOperators.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_TwoOperators[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12"</span>, <span class="hljs-string">"--"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,  <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FTwoOperators::FTwoOperators(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_TwoOperators, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{ }<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FTwoOperators::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"x1"</span>, CLocVar::vtBool, <span class="hljs-string">" 1- "</span>);<font></font>
    pVarX2 = CreateLocVar(<span class="hljs-string">"x2"</span>, CLocVar::vtBool, <span class="hljs-string">" 2- "</span>);<font></font>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameY = CreateLocVar(<span class="hljs-string">"strNameY"</span>, CLocVar::vtString, <span class="hljs-string">"name of external output variable(y)"</span>);		<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX1) {<font></font>
        str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameX2) {<font></font>
        str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>); }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameY) {<font></font>
        str = pVarStrNameY-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarY = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FTwoOperators::x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarY; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTwoOperators::y1</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// reading input signals</span>
    bX1 = <span class="hljs-keyword">bool</span>(pVarX1-&gt;GetDataSrc());<font></font>
    bX2 = <span class="hljs-keyword">bool</span>(pVarX2-&gt;GetDataSrc());
<span class="hljs-comment">// setting output signals</span><font></font>
    bY = !(bX1&amp;&amp;bX2);<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, bY);<font></font>
}<font></font>
<span class="hljs-comment">// initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTwoOperators::y12</span><span class="hljs-params">()</span> </span>{ FInit(); }
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいモデルを「シャドウメモリ」モードでテストすると、前のモデルとの動作に違いはありません。つまり、そして、切り替えて、禁止状態を通過し、定期的に生成モードに入ります。通常モードでデータを使用するように設定すると、図4に示す結果が得られます。 8と図9. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/mc/ib/tomcibxvaq2mae2kxxqc5clwits.jpeg" alt="画像"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図8. RSトリガーモデルの生成モードの失敗</font></font></i><br>
 <br>
<img src="https://habrastorage.org/webt/pu/qt/5y/puqt5yws1udobr_volkpcm7r4dm.jpeg" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 9. RSトリガー</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
モデル</font><i><font style="vertical-align: inherit;">による禁止状態のスキップ</font></i><font style="vertical-align: inherit;">メモリを使用するモードに関係なく、最初のモデルが安定した結果を示し、2番目のモデルが動作を変更するのはなぜですか？その理由は述語です。 2番目のモデルには述語がなく、これはその動作にとって重要です。しかし、どのようにそしてなぜ述語の有無が並列プログラム操作アルゴリズムに影響するのでしょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AND-NOT要素のプログラムモデルには、オートマトンプログラムと同様に、2つの入力チャネルと1つの出力チャネルがあります。 2つの述語と1つのアクションに一致する必要があります。最初のプログラムはこれと完全に一致しています。オートマトンの記述を解釈するVKPaカーネルは、最初に特定のオートマトンだけでなくオートマトン空間全体のすべての述語を実行し、その後すべてのアクションを開始します。この場合、どのようなシーケンスでアクションが実行され、並列処理をシミュレートし、メモリで動作したどのモードでも、オートマトンの現在のクロックサイクルの述語の結果はそれら（アクション）に依存しません。したがって、最初のプログラムは同じ結果になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のプログラムは、マシンの入力チャンネルで直接動作しますが、アクションの一部として入力信号を読み取ります。</font><font style="vertical-align: inherit;">シャドウメモリモードで入力データを処理するアクションは、シャドウメモリーに新しい値を書き込み、それにより、離散クロックサイクルの開始時に有効なデータを処理します。</font><font style="vertical-align: inherit;">通常のモードでは、彼らは彼らの変化の時に確立された瞬間的な値を「つかむ」ので、アルゴリズムは記憶の変化の瞬間に依存するようになります。</font><font style="vertical-align: inherit;">同様の依存関係が2番目のプログラムで示されています。</font><font style="vertical-align: inherit;">また、2番目のモデルに述語メソッドが導入された場合でも、これはその作業の結果に影響を与えません。</font><font style="vertical-align: inherit;">ここで重要なのは、述語メソッドが存在するという事実ではなく、オートマトンプログラミングモデルのフレームワークにおけるそれらの作業の特徴です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5。結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として並列RSトリガープログラムを使用して、並列プログラムに固有のいくつかのプロパティを調べました。</font><font style="vertical-align: inherit;">論理（デジタル）回路の例として、並列プログラムの機能の特定の一般的な側面を引き続き検討します。</font><font style="vertical-align: inherit;">ここでのデジタル回路のモデリングのトピックの選択は偶然ではありません。</font><font style="vertical-align: inherit;">実際、「洗練された形式」では、それらは並列プロセスの作業を表しています。</font><font style="vertical-align: inherit;">これにより、同時実行、競合、同期、行き止まりなどのニュアンスの分析が行われます。</font><font style="vertical-align: inherit;">など、透明、明確、シンプル。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、プログラミングを「競争的」または「並列」と呼ぶ場合でも、プログラミングに「コルーチン」、コルーチン、スレッド、またはマシンを使用しても、[並列]プログラムの結果はすべての実装で同じでなければなりません。</font><font style="vertical-align: inherit;">CPSUのフレームワーク内での並列プログラムの自動モデルは、この目標のみを追求します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VKPaの環境のオートマトンの解釈のコアの実装に関してどのような仮定が行われたとしても、これらはすべて「推測」です。自動プログラムの作業の結果は、計算モデルの実装と関連付けるべきではありません。ソフトウェア（現在のまま）またはハードウェア（将来的に希望）、1つのコアまたはそのセット、シングルスレッドバージョンまたはマルチスレッドバージョンなどで実装できます。等これらすべてが、並列自動プログラムの結果に影響を与えることはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、目標は達成されたようです。</font><font style="vertical-align: inherit;">可能なシステム並列処理テスト[8]の1つとしてのRSトリガーモデルは、このことを確信します。他のすべての並列プログラムは、環境が並列処理でRSトリガーテストを正常に実行し、正しく、信頼性が高く、安定して機能することを条件としています。 。</font><font style="vertical-align: inherit;">ちなみに、同じMATLABの「RSトリガーテスト」はパスせず、これはすでに多くのことを言っています...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文献</font></font></b><div class="spoiler_text">1.  .    ++  .    . .  .  .. – .:  , 2012. – 672 . <br>
2.  .    : .  . – .: , 1981. – 360 .<br>
3.    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">habr.com/ru/post/484588</a> . . . (  07.01.2020).<br>
4.  ..   . .: , 1962.<br>
5.  .., - ..    . – 2- ., .  . – .:  , 1988. – 480 .<br>
6.  ..    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">cloud.mail.ru/public/HwsK/T95PMM8Ed</a> . . . (  01.02.2020).<br>
7.  .    . 2-  . – .: , 2004. – 432.<br>
8.  ..   ? “ ”, №10/97, .116-119. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">www.osp.ru/pcworld/1997/10/158015</a> . . . (  01.02.2020).<br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja486598/index.html">Jupyter Notebookでのマイクロコントローラー実験</a></li>
<li><a href="../ja486602/index.html">Svelteコミュニティマテリアルダイジェスト（1月16日-2月1日）</a></li>
<li><a href="../ja486604/index.html">Нет, динамические системы типов по своей сути не более открыты</a></li>
<li><a href="../ja486608/index.html">世界で最も効果的なインテリジェンスサービスのインテリジェンスに不可欠なアシスタント（パート2）</a></li>
<li><a href="../ja486614/index.html">eSIMが必要な理由 それがどのように機能し、なぜ彼らがそれについてそんなに多く話すのか</a></li>
<li><a href="../ja486626/index.html">Svelte：アクションについて知る</a></li>
<li><a href="../ja486628/index.html">gnuplotの軸上のティック間の固定距離</a></li>
<li><a href="../ja486630/index.html">「目にちらつくことはありません」：電子リーダーの画面照明のテクノロジーの配置方法</a></li>
<li><a href="../ja486632/index.html">スーパーバイザ向けのメンタルリアクティブプログラミングモデル</a></li>
<li><a href="../ja486634/index.html">Visual Studio 2019バージョン16.3および16.4でのMSVCバックエンドの更新</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>