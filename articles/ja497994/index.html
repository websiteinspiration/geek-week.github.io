<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👪 🍨 👨‍👦‍👦 言語力学エスケープ分析 🙈 🛸 🔇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="プレリュード
 これは、ポインター、スタック、ヒープ、エスケープ分析、およびGo / Valueセマンティクスのメカニズムと設計に関する洞察を提供するシリーズの4つの記事の2番目です。この投稿は、ヒープとエスケープ分析についてです。
 
 目次：
 
 

1. スタックとポインタの言語力学（翻訳）...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>言語力学エスケープ分析</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497994/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレリュード</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ポインター、スタック、ヒープ、エスケープ分析、およびGo / Valueセマンティクスのメカニズムと設計に関する洞察を提供するシリーズの4つの記事の2番目です。</font><font style="vertical-align: inherit;">この投稿は、ヒープとエスケープ分析についてです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目次：</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックとポインタの言語力学</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エスケープ分析の言語力学</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記憶プロファイリングの言語力学</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データとセマンティクスに関する設計哲学</font></font></a></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシリーズの最初の投稿では、値がスタック間でゴルーチン間で分散される例を使用して、ポインターメカニズムの基本について説明しました。スタックで値を分割するとどうなるかは示しませんでした。これを理解するには、値が存在する可能性がある別のメモリ領域、つまり「ヒープ」について調べる必要があります。この知識があれば、「エスケープ分析」を学ぶことができます。</font></font><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エスケープ分析は、プログラムによって作成された値の配置を決定するためにコンパイラーが使用するプロセスです。</font><font style="vertical-align: inherit;">特に、コンパイラは静的コード分析を実行して、値を構築する関数のスタックフレームに値を配置できるかどうか、または値をヒープに「エスケープ」する必要があるかどうかを判断します。</font><font style="vertical-align: inherit;">Goには、どの決定を行うかをコンパイラーに指示するために使用できる単一のキーワードまたは関数はありません。</font><font style="vertical-align: inherit;">コードを条件付きで記述する方法でのみ、この決定に影響を与えることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒープ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒープは、スタックに加えて、値の格納に使用されるメモリの2番目の領域です。ヒープはスタックのような自動クリーニングではないため、このメモリを使用するとコストが高くなります。まず、コストはガベージコレクター（GC）に関連しています。GCはこの領域をクリーンに保つ必要があります。 GCが起動すると、プロセッサーの利用可能な電力の25％を使用します。さらに、「世界を止める」遅延のマイクロ秒を作成する可能性があります。 GCを使用する利点は、これまで複雑でエラーが発生しやすいヒープメモリの管理について心配する必要がないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒープ内の値は、Goのメモリ割り当てを引き起こします。</font><font style="vertical-align: inherit;">ポインタが参照しなくなったヒープ内のすべての値を削除する必要があるため、これらの割り当てはGCに圧力をかけます。</font><font style="vertical-align: inherit;">確認して削除する必要がある値が多いほど、GCが起動するたびに実行する必要のある作業が多くなります。</font><font style="vertical-align: inherit;">したがって、刺激アルゴリズムは、ヒープサイズと実行速度のバランスを取るために常に機能しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタック共有</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goでは、ゴルーチンが別のゴルーチンのスタック上のメモリを指すポインターを持つことはできません。</font><font style="vertical-align: inherit;">これは、スタックを増減する必要がある場合に、ゴルーチンのスタックメモリを新しいメモリブロックに置き換えることができるためです。</font><font style="vertical-align: inherit;">実行時に別のgoroutineでスタックポインターを追跡する必要がある場合、管理しすぎて、これらのスタックへのポインターを更新するときの「stop the world」の遅延は驚異的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、成長により数回交換されたスタックの例です。</font><font style="vertical-align: inherit;">2行目と6行目の出力を見てください。メインスタックフレーム内の文字列値のアドレス変更が2度表示されます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/pxn5u4EBSI</font></font></a> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脱出力学</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数のスタックフレームの領域外で値が共有されるたびに、その値はヒープに配置（または割り当て）されます。エスケープ分析アルゴリズムのタスクは、そのような状況を見つけて、プログラムの整合性レベルを維持することです。整合性とは、あらゆる値へのアクセスが常に正確で、一貫性があり、効率的であることを保証することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例を見て、エスケープ分析の基本的なメカニズムを学びましょう。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/Y_VZxYteKO</font></font></a> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
リスト1</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span> {
<span class="hljs-number">04</span>     name  <span class="hljs-keyword">string</span>
<span class="hljs-number">05</span>     email <span class="hljs-keyword">string</span>
<span class="hljs-number">06</span> }
<span class="hljs-number">07</span>
<span class="hljs-number">08</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">09</span>     u1 := createUserV1()
<span class="hljs-number">10</span>     u2 := createUserV2()
<span class="hljs-number">11</span>
<span class="hljs-number">12</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"u1"</span>, &amp;u1, <span class="hljs-string">"u2"</span>, &amp;u2)
<span class="hljs-number">13</span> }
<span class="hljs-number">14</span>
<span class="hljs-number">15</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }
<span class="hljs-number">25</span>
<span class="hljs-number">26</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">go：noinlineディレクティブを使用して、コンパイラーがこれらの関数のコードをメインに直接埋め込まないようにします。埋め込むと、関数呼び出しが削除され、この例が複雑になります。埋め込みの副作用については、次の投稿で説明します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
リスト1は、タイプがuserの値を作成し、それを呼び出し元に返す2つの異なる関数を持つプログラムを示しています。関数の最初のバージョンは、戻るときに値のセマンティクスを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト2</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この関数によって作成されたuser型の値がコピーされ、コールスタックに渡されるため、関数は戻り時に値のセマンティクスを使用すると述べました。これは、呼び出し元の関数が値自体のコピーを受け取ることを意味します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
17行目から20行目で実行された、userタイプの値の作成を確認できます。次に、23行目で、値のコピーが呼び出しスタックに渡され、呼び出し元に返されます。関数を返すと、スタックは次のようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像1 </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hs/me/pj/hsmepjswe1d_ggonuc8jkwscyk8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図1では、createUserV1を呼び出した後、userタイプの値が両方のフレームに存在することがわかります。関数の2番目のバージョンでは、ポインターのセマンティクスを使用して戻ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト3</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この関数によって作成されたタイプuserの値はコールスタックによって共有されるため、関数は戻るときにポインタセマンティクスを使用すると述べました。これは、呼び出し元の関数が、値が配置されているアドレスのコピーを受け取ることを意味します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
28行目から31行目でuserタイプの値を作成するために使用されているものと同じ構造リテラルを確認できますが、34行目では関数からの戻りが異なります。値のコピーを呼び出しスタックに渡す代わりに、値のアドレスのコピーが渡されます。これに基づいて、呼び出し後のスタックは次のようになると考えるかもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像2</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mu/ld/nh/muldnhq-xncjaz97pv-647tybme.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図2に示すものが実際に発生している場合は、整合性の問題があります。</font><font style="vertical-align: inherit;">ポインタは、無効になったメモリへの呼び出しのスタックを指し示します。</font><font style="vertical-align: inherit;">次に関数が呼び出されたときに、指定されたメモリが再フォーマットされ、再初期化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、エスケープ分析が整合性を維持し始める場所です。</font><font style="vertical-align: inherit;">この場合、コンパイラーは、createUserV2スタックフレーム内にuser型の値を作成するのは安全ではないと判断し、代わりにヒープに値を作成します。</font><font style="vertical-align: inherit;">これは、ライン28の建設中に直ちに発生します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読みやすさ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前の投稿から学んだように、関数はフレームポインターを介してフレーム内のメモリに直接アクセスできますが、フレーム外のメモリへのアクセスには間接アクセスが必要です。これは、ヒープに含まれる値へのアクセスも、ポインターを介して間接的に行う必要があることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
createUserV2コードがどのように見えるかを思い出してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト4</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構文は、このコードで実際に発生することを隠します。 28行目で宣言された変数uは、userタイプの値を表します。 Goの構成では、値がメモリのどこに格納されているかが正確にわかりません。そのため、34行目のreturnステートメントの前に、値がヒープされることを知りません。つまり、uはタイプuserの値を表しますが、この値へのアクセスはポインターを介して行う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数呼び出し後、このようなスタックを視覚化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像3</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5u/ya/sv/5uyasv63ozdef8jclixqpv4anx4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
createUserV2のスタックフレームのu変数は、スタックではなくヒープ上の値を表します。</font><font style="vertical-align: inherit;">つまり、uを使用して値にアクセスするには、構文で提案されている直接アクセスではなく、ポインタへのアクセスが必要です。</font><font style="vertical-align: inherit;">それが表す値にアクセスするには依然としてポインターを使用する必要があるため、すぐにポインターを作成しないのはなぜでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト5</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := &amp;user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そうすると、可読性が失われ、コードでは失われなくなります。</font><font style="vertical-align: inherit;">関数本体から少し離れて、戻りに集中してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト6</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このリターンは何について話しているのですか？</font><font style="vertical-align: inherit;">彼の言うことは、uのコピーが呼び出しスタックにプッシュされることだけです。</font><font style="vertical-align: inherit;">それまでの間、＆演算子を使用するとreturnは何を教えてくれますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト7</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
＆return演算子のおかげで、コールスタックを共有しているため、ヒープに入ることが通知されます。ポインターは一緒に使用することを目的としており、コードの読み取り中、＆演算子は「共有」というフレーズに置き換えられます。読みやすさの点で非常に強力です。これは私が失いたくないものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポインターのセマンティクスを使用して値を作成すると、読みやすさが低下する別の例を次に示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト8</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">var</span> u *user
<span class="hljs-number">02</span> err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(r), &amp;u)
<span class="hljs-number">03</span> <span class="hljs-keyword">return</span> u, err</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このコードが機能するためには、02行でjson.Unmarshalを呼び出すときに、ポインター変数にポインターを渡す必要があります。 json.Unmarshal呼び出しは、タイプuserの値を作成し、そのアドレスをポインター変数に割り当てます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">play.golang.org/p/koI8EjpeIx</font></font></a> </i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このコードの意味：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
01：null値を持つuser型のポインターを作成します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
02：j変数をjson.Unmarshal関数と共有します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
03：変数uのコピーを呼び出し元に返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
json.Unmarshal関数によって作成されたタイプuserの値が呼び出し元に渡されることは完全には明らかではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数宣言中に値のセマンティクスを使用すると、読みやすさがどのように変わりますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト9</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">var</span> u user
<span class="hljs-number">02</span> err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(r), &amp;u)
<span class="hljs-number">03</span> <span class="hljs-keyword">return</span> &amp;u, err</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードの内容：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
01：null値を持つタイプuserの値を作成します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
02：j変数をjson.Unmarshal関数と共有します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
03：変数uを呼び出し元と共有します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが非常に明確です。</font><font style="vertical-align: inherit;">行02は、タイプuserの値をjson.Unmarshalの呼び出しスタックに分割し、行03は呼び出しのスタックの値を呼び出し元に戻します。</font><font style="vertical-align: inherit;">この共有により、値がヒープに移動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値を作成するときに値のセマンティクスを使用し、＆演算子の読みやすさを利用して、値がどのように分離されるかを明確にします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラーの報告</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーによる決定を確認するには、コンパイラーにレポートの提供を依頼できます。</font><font style="vertical-align: inherit;">go buildを呼び出すときに、-gcflagsスイッチを-mオプションとともに使用するだけです。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際、4レベルの-mを使用できますが、2レベルの情報を入力すると、多すぎます。</font><font style="vertical-align: inherit;">2レベル-mを使用します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト10</font></font><br>
<br>
<pre><code class="bash hljs">$ go build -gcflags <span class="hljs-string">"-m -m"</span><font></font>
./main.go:16: cannot inline createUserV1: marked go:noinline<font></font>
./main.go:27: cannot inline createUserV2: marked go:noinline<font></font>
./main.go:8: cannot inline main: non-leaf <span class="hljs-keyword">function</span><font></font>
./main.go:22: createUserV1 &amp;u does not escape<font></font>
./main.go:34: &amp;u escapes to heap<font></font>
./main.go:34:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34<font></font>
./main.go:31: moved to heap: u<font></font>
./main.go:33: createUserV2 &amp;u does not escape<font></font>
./main.go:12: main &amp;u1 does not escape<font></font>
./main.go:12: main &amp;u2 does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラが値をヒープにダンプする決定を報告していることがわかります。</font><font style="vertical-align: inherit;">コンパイラは何と言っていますか？</font><font style="vertical-align: inherit;">最初に、createUserV1関数とcreateUserV2関数をもう一度見て、メモリ内で更新します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト13</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">16</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV1</span><span class="hljs-params">()</span> <span class="hljs-title">user</span></span> {
<span class="hljs-number">17</span>     u := user{
<span class="hljs-number">18</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">19</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">20</span>     }
<span class="hljs-number">21</span>
<span class="hljs-number">22</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V1"</span>, &amp;u)
<span class="hljs-number">23</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">24</span> }<font></font>
<font></font>
<span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, &amp;u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> &amp;u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レポートのこの行から始めましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト14</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:22: createUserV1 &amp;u does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、createUserV1関数内のprintln関数を呼び出しても、ユーザータイプがヒープにダンプされないことを示しています。このケースはprintln関数と組み合わせて使用​​されるため、チェックする必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、レポートのこれらの行を見てください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト15</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:34: &amp;u escapes to heap<font></font>
./main.go:34:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34<font></font>
./main.go:31: moved to heap: u<font></font>
./main.go:33: createUserV2 &amp;u does not escape</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの行は、変数uに関連付けられたユーザータイプの値で、名前付きのユーザータイプを持ち、行31で作成されていることを示しています。行34の戻りにより、ヒープにダンプされます。最後の行は以前と同じ、行のprintln呼び出し33はユーザータイプをリセットしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのレポートの読み取りは混乱を招く可能性があり、問題の変数のタイプが名前付きまたはリテラルタイプに基づいているかどうかによって若干異なる場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前のように、u変数を名前付きタイプのユーザーではなくリテラルタイプ*ユーザーに変更します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト16</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">27</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createUserV2</span><span class="hljs-params">()</span> *<span class="hljs-title">user</span></span> {
<span class="hljs-number">28</span>     u := &amp;user{
<span class="hljs-number">29</span>         name:  <span class="hljs-string">"Bill"</span>,
<span class="hljs-number">30</span>         email: <span class="hljs-string">"bill@ardanlabs.com"</span>,
<span class="hljs-number">31</span>     }
<span class="hljs-number">32</span>
<span class="hljs-number">33</span>     <span class="hljs-built_in">println</span>(<span class="hljs-string">"V2"</span>, u)
<span class="hljs-number">34</span>     <span class="hljs-keyword">return</span> u
<span class="hljs-number">35</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レポートを再度実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト17</font></font><br>
<br>
<pre><code class="bash hljs">./main.go:30: &amp;user literal escapes to heap<font></font>
./main.go:30:     from u (assigned) at ./main.go:28<font></font>
./main.go:30:     from ~r0 (<span class="hljs-built_in">return</span>) at ./main.go:34</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、レポートは、変数uによって参照されるユーザータイプの値（リテラルタイプ* userを持ち、28行目で作成された）が34行目の戻りのためにヒープにダンプされると述べています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値を作成しても、それがどこにあるかは判別されません。</font><font style="vertical-align: inherit;">値がどのように分割されるかによってのみ、コンパイラがこの値をどう処理するかが決まります。</font><font style="vertical-align: inherit;">呼び出しスタックで値を共有するたびに、その値はヒープにダンプされます。</font><font style="vertical-align: inherit;">値がスタックからエスケープする理由は他にもあります。</font><font style="vertical-align: inherit;">それらについては、次の投稿で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの投稿の目的は、特定の型に対して値のセマンティクスまたはポインターのセマンティクスの使用を選択する際のガイダンスを提供することです。</font><font style="vertical-align: inherit;">各セマンティクスは、利益と価値と対になっています。</font><font style="vertical-align: inherit;">値のセマンティクスは値をスタックに格納するため、GCの負荷が軽減されます。</font><font style="vertical-align: inherit;">ただし、同じ値のさまざまなコピーがあり、保存、追跡、および保守する必要があります。</font><font style="vertical-align: inherit;">ポインターのセマンティクスは値をヒープに入れ、GCに圧力をかける可能性があります。</font><font style="vertical-align: inherit;">ただし、保存、追跡、および保守が必要な値は1つしかないため、効果的です。</font><font style="vertical-align: inherit;">重要な点は、各セマンティクスを正しく、一貫してバランスよく使用することです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja497982/index.html">管理に対する機能的およびプロセス的アプローチ。どのように、そして何を管理すべきか？</a></li>
<li><a href="../ja497984/index.html">CloudflareでreCAPTCHAからhCaptchaに移行する</a></li>
<li><a href="../ja497986/index.html">Webページで使用されるすべてのメモリを監視する：performance.measureMemory（）</a></li>
<li><a href="../ja497988/index.html">React Application Performance Profiling</a></li>
<li><a href="../ja497990/index.html">PostgreSQL：C言語での拡張（関数）の開発</a></li>
<li><a href="../ja497996/index.html">免疫力を強化したくない。または人体の両極端</a></li>
<li><a href="../ja498000/index.html">自分のゲームを開発する前に知っておきたいこと</a></li>
<li><a href="../ja498002/index.html">Z3のポケットガイド</a></li>
<li><a href="../ja498004/index.html">Dockerコンテナー内のワークステーション</a></li>
<li><a href="../ja498006/index.html">弁理士の選択</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>