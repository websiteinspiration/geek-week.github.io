<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏼 ⏲️ 🔚 DEVOXX UK。本番環境でのKubernetes：青/緑のデプロイ、自動スケーリング、デプロイの自動化。パート2 🕺🏼 📝 📧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kubernetesは、クラスター化された本番環境でDockerコンテナーを実行するための優れたツールです。ただし、Kubernetesが解決できないタスクがあります。本番環境で頻繁にデプロイする場合、このプロセスでのダウンタイムを回避するために、完全に自動化されたBlue / Greenデプロイメ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>DEVOXX UK。本番環境でのKubernetes：青/緑のデプロイ、自動スケーリング、デプロイの自動化。パート2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/504672/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetesは、クラスター化された本番環境でDockerコンテナーを実行するための優れたツールです。ただし、Kubernetesが解決できないタスクがあります。本番環境で頻繁にデプロイする場合、このプロセスでのダウンタイムを回避するために、完全に自動化されたBlue / Greenデプロイメントが必要です。これには、外部HTTPリクエストとSSLアップロードも必要です。これには、ha-proxyなどのロードバランサーとの統合が必要です。もう1つのタスクは、クラウドで作業するときのKubernetesクラスター自体の半自動スケーリングです。たとえば、夜間のクラスタースケールの部分的な削減です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetesにはこれらの機能はそのままではありませんが、そのような問題を解決するために使用できるAPIを提供します。 Kubernetesクラスターの自動化された青/緑のデプロイとスケーリングツールは、Cloud RTIオープンソースプロジェクトの一部として開発されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このビデオのトランスクリプトは、Kubernetesを他のオープンソースコンポーネントとともに構成して、本番環境でのダウンタイムなしでgit commit change commitからコードを受け入れる本番環境に対応する環境を取得する方法について説明しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cy/4y/jm/cy4yjm9zwmpfpvtfwhwfigavpkw.jpeg"><a name="habracut"></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DEVOXX UK。本番環境でのKubernetes：青/緑のデプロイ、自動スケーリング、デプロイの自動化。パート1</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
したがって、外部からアプリケーションにアクセスした後、自動化を完全に構成し始めることができます。つまり、自動化をgit commitを実行できる段階に持ってきて、このgit commitが本番環境で終了することを確認します。当然、これらのステップの実装、デプロイメントの実装では、ダウンタイムに直面したくありません。したがって、Kubernetesの自動化はすべてAPIから始まります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5q/w4/ng/5qw4ngl2hrnecjzk4sfvhhepx_k.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetesは、「そのまま」生産的に使用できるツールではありません。もちろん、これを実行したり、kubectlを使用したりすることもできますが、このプラットフォームではAPIが最も面白くて便利です。 APIを機能セットとして使用すると、Kubernetesで実行したいほとんどすべての機能にアクセスできます。 Kubectl自体もREST APIを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはRESTなので、任意の言語とツールを使用してこのAPIを操作できますが、ユーザーライブラリを使用すると作業が大幅に容易になります。私のチームは2つのライブラリを作成しました。1つはJava / OSGi用、もう1つはGo用です。 2番目はあまり使用されませんが、いずれにしても、これらの便利なものは自由に使用できます。それらは部分的にライセンスされたオープンソースプロジェクトです。さまざまな言語用のライブラリが多数あるため、最適なライブラリを選択できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ej/bj/ey/ejbjeyepppr2tet3aupem789num.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、デプロイメントの自動化に着手する前に、このプロセスがダウンタイムの影響を受けないことを確認する必要があります。たとえば、私たちのチームは、人々がアプリケーションを最大限に活用する真昼間に本番環境の展開を行うため、このプロセスの遅延を回避することが非常に重要です。ダウンタイムを回避するために、2つの方法が使用されます：青/緑の展開またはローリング更新ローリング更新。後者の場合、アプリケーションの5つのレプリカが実行されていると、それらのレプリカは順次更新されます。この方法は適切に機能しますが、デプロイメントプロセス中に異なるバージョンのアプリケーションを同時に実行している場合は機能しません。この場合、バックエンドが古いバージョンで動作し、アプリケーションが動作しなくなる間、ユーザーインターフェイスを更新できます。したがって、プログラミングの観点から、そのような状況での作業はかなり困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが、ブルー/グリーン展開を使用してアプリケーションの展開を自動化することを好む理由の1つです。この方法では、特定の時点で、アプリケーションの1つのバージョンのみがアクティブであることを確認する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
青/緑の展開メカニズムは次のとおりです。アプリケーションのトラフィックはha-proxyを介して取得されます。ha-proxyは、同じバージョンの実行中のアプリケーションレプリカにトラフィックを送ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいデプロイメントが実行されると、新しいコンポーネントが提供されているDeployerを使用して、新しいバージョンをデプロイします。アプリケーションの新しいバージョンをデプロイすると、新しいレプリカのセットが「立ち上がり」、その後、新しいバージョンのこれらのレプリカが別の新しいポッドで起動されます。ただし、ha-proxyはそれらについて何も認識しておらず、これまでのところ、ワークロードを送信していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、最初に、レプリカが負荷を処理する準備ができていることを確認するために、新しいバージョンのヘルスチェックの状態をチェックする必要があります。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/dx/qk/vd/dxqkvdwkbon86_g0l0plg-dqezu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての展開コンポーネントは、何らかの形のヘルスチェックをサポートする必要があります。これは、ステータスが200のコードを受け取ったときの呼び出しによる非常に単純なHTTPチェック、またはデータベースと他のサービスとのレプリカの接続、動的環境の接続の安定性など、すべてが正常に起動して機能するかどうかをチェックする詳細なチェックです。このプロセスは非常に複雑になる可能性があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lr/9t/o4/lr9to4uiafxnxpjfbuyzd3ubtgo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更新されたすべてのレプリカが機能していることをシステムが確認した後、Deployerは構成を更新し、正しいconfdを渡します。これにより、ha-proxyが再構成されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kw/q1/s7/kwq1s7fkzffaby-ajt6jyrg2vra.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、トラフィックは新しいバージョンのレプリカでアンダーに送られ、古いバージョンは消えます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wa/q5/c6/waq5c6mmixf0j3twtrhetjjdvx0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメカニズムはKubernetesの機能ではありません。 Blue / Greenのデプロイメントコンセプトはかなり前からあり、ロードバランサーを常に使用しています。最初に、すべてのトラフィックを古いバージョンのアプリケーションに転送し、アップグレード後に完全に新しいバージョンに転送します。この原則は、Kubernetesだけで使用されるわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、新しいデプロイコンポーネントであるDeployerを紹介します。Deployerは、ヘルスチェックを実行したり、プロキシを再構成したりします。これは外界には当てはまらない概念であり、Kubernetes内に存在します。オープンソースツールを使用して独自のDeployerコンセプトを作成する方法を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Deployerが最初に行うことは、Kubernetes APIを使用してRCレプリケーションコントローラを作成することです。このAPIは、さらにデプロイするためのポッドとサービスを作成します。つまり、アプリケーションの完全に新しいクラスターを作成します。 RCは、レプリカが開始されたことを確認すると、それらのヘルスチェックをチェックします。これを行うには、DeployerはGET / healthコマンドを使用します。対応する検証コンポーネントを起動し、クラスターの動作を保証するすべての要素を検証します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/km/lr/8u/kmlr8uloqusoeejhd-7dquyzu7q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのポッドが「正常性」を報告した後、Deployerは新しい構成アイテムを作成します。これは、ロードバランサー構成の保存など、Kubernetes内部で使用される分散ストレージetcdです。 etcdにデータを書き込み、小さなツール、confd、新しいデータのetcdを監視します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期構成の変更を見つけた場合、彼は新しい設定ファイルを生成してha-proxyに渡します。この場合、ha-proxyは接続を失うことなく再起動し、アプリケーションの新しいバージョンを提供する新しいサービスで負荷に対処します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h2/1k/os/h21kosweevmblkultqa8kspeuri.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、コンポーネントが豊富であるにもかかわらず、複雑なものはありません。</font><font style="vertical-align: inherit;">APIとetcdにもっと注意を払う必要があるだけです。</font><font style="vertical-align: inherit;">私たち自身が使用しているオープンソースのデプロイヤーについてお話ししたいと思います。これはAmdatu Kubernetes Deployerです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ir/oj/vt/irojvt6tjy6vgckfsizgnycysdm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、次の機能を備えたKubernetesデプロイメントオーケストレーションツールです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブルー/グリーン展開</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外部ロードバランサーを設定します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デプロイメント記述子の管理</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際の展開管理</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">展開中のヘルスチェック</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポッドでの環境変数の実装。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このDeployerはKubernetes APIの上に作成され、記述子とデプロイメントを管理するためのREST APIと、デプロイメント中のストリームログ用のWebsocket APIを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロードバランサー構成データをetcdに配置するため、「そのまま」のサポートでha-proxyを使用することはできませんが、独自のバランサー構成ファイルを使用するのは簡単です。 Amdatu Deployerは、Kubernetes自体と同様にGoで記述され、Apacheによってライセンスされています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このバージョンのデプロイヤーを使用する前に、必要なパラメーターを指定する次のデプロイメント記述子を使用しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_p/fr/ht/_pfrhtrtusrz0ua6480jo3acqvo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードの重要なパラメータの1つは、「useHealthCheck」フラグを有効にすることです。展開プロセス中にヘルスチェックが必要であることを示す必要があります。検証する必要のないサードパーティのコンテナをデプロイメントで使用する場合、このオプションをオフにすることができます。この記述子は、ha-proxyが必要とするレプリカの数とフロントエンドURLも示します。最後にpodspecポッドの仕様フラグがあり、ポート構成、イメージなどの情報をKubernetesに呼び出します。これは、JSON形式のかなり単純な記述子です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Amdatuオープンソースプロジェクトの一部である別のツールは、Deploymentctlです。展開を構成するためのユーザーインターフェイスUIがあり、展開履歴を保存し、サードパーティのユーザーや開発者によるコールバック用のWebhookが含まれています。 Amdatu Deployer自体はREST APIであるため、UIを使用することはできませんが、このインターフェイスを使用すると、APIを使用せずに簡単にデプロイできます。 Deploymentctlは、Angular 2を使用してOSGi / Vertxで記述されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、既成の記録を使用して画面上で上記のデモを行うので、待つ必要はありません。シンプルなアプリケーションをGoにデプロイします。 Goに出会ったことがない場合、これは非常にシンプルなアプリケーションなので、心配しないでください。すべてを理解する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ad/rq/ih/adrqihjjsirswywycn8zcm_ypsy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、/ヘルスのみに応答するHTTPサーバーを作成します。したがって、このアプリケーションはヘルスチェックのみをチェックし、それ以外はチェックしません。チェックに合格すると、以下に示すJSON構造が呼び出されます。これには、デプロイヤーによってデプロイされるアプリケーションのバージョン、ファイルの上部に表示されるメッセージ、およびブール論理データタイプ（アプリケーションが機能しているかどうかに関係なく）が含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルの先頭に固定ブール値を配置したため、最後の行で少し浮気しました。これは、将来的には「不健全な」アプリケーションでもデプロイできるようになるためです。これについては後で扱います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは始めましょう。最初に、〜kubectl get podsコマンドを使用して実行中のポッドを確認し、フロントエンドURLから応答がない場合は、現在デプロイが実行されていないことを確認します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qa/vs/kx/qavskxpsjbdy93vis6wd4xp6tas.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、画面に、前述のDeploymentctlインターフェースが表示されます。ここでは、デプロイメントパラメータが設定されています。名前空間、アプリケーション名、デプロイメントバージョン、レプリカの数、フロントエンドURL、コンテナ名、イメージ、リソース制限、ヘルスチェックをチェックするためのポート番号などです。 。リソース制限は非常に重要です。これにより、「鉄」の最大量を使用できるようになります。展開ログ展開ログもここで確認できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/g_/fk/wb/g_fkwbqrgrbuaii4xmoqhmds3lu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで〜kubectl get podsコマンドを繰り返すと、システムが20秒間「フリーズ」し、その間にha-proxy再構成が行われていることがわかります。その後、それは下から始まり、レプリカがデプロイメントログに表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vm/eb/kb/vmebkbw-zpzs2yjjex70jyiz2gg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオから20秒の待機時間を切り取り、画面にアプリケーションの最初のバージョンがデプロイされていることがわかります。これはすべて、UIの助けを借りて行われました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bt/nw/dq/btnwdq4bpxvs3xloqvdfo01nwla.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、2番目のバージョンを試してみましょう。これを行うには、アプリケーションのメッセージを「Hello、Kubernetes！」に変更します。 「Hello、Deployer！」に変更すると、システムはこのイメージを作成してDockerレジストリに配置します。その後、Deploymentctlウィンドウの[Deploy]ボタンをもう一度クリックするだけです。この場合、アプリケーションの最初のバージョンがデプロイされたときと同じ方法で、デプロイメントログが自動的に起動されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7f/fb/hx/7ffbhx4jbq_bwxyxskyfbhqg0cy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
〜kubectl get podsコマンドは、アプリケーションの2つのバージョンが現在実行中であることを示していますが、フロントエンドは、バージョン1がまだ実行中であることを示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/xz/xg/guxzxgf4t6g8xxruexeuptcebze.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロードバランサーは、ヘルスチェックが実行されるまで待機してから、トラフィックを新しいバージョンにリダイレクトします。 20秒後、curlに切り替えて、アプリケーションのバージョン2をデプロイし、最初のアプリケーションが削除されていることを確認します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cq/jp/0k/cqjp0kwmkhlufezt-hzs-80fezq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、「正常な」-正常な-アプリケーションの展開でした。新しいバージョンのアプリケーションで、Healthyパラメーターの値をtrueからfalseに変更するとどうなるかを見てみましょう。つまり、ヘルスチェックに合格しなかった異常なアプリケーションをデプロイしようとします。これは、開発段階でアプリケーションで構成エラーが発生し、この形式で本番環境に入った場合に発生する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、デプロイは上記のすべてのステップを通過し、〜kubectl get podsは両方のポッドが実行されていることを示しています。ただし、以前の展開とは異なり、ログにはタイムアウトの状態が表示されます。つまり、ヘルスチェックに合格しなかったため、新しいバージョンのアプリケーションをデプロイできません。その結果、システムが古いバージョンのアプリケーションを使用するように戻り、新しいバージョンが単に削除されたことがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kq/iv/qz/kqivqzsf3ghxznqksadtfobhzfm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これの良い点は、アプリケーションに大量の同時リクエストが来たとしても、デプロイメント手順の実装中にダウンタイムに気付くことさえないということです。可能な最大数のリクエストを送信するガトリングフレームワークを使用してこのアプリケーションをテストする場合、これらのリクエストのいずれもドロップされません。これは、ユーザーがリアルタイムのバージョン更新に気付かないことを意味します。失敗した場合は古いバージョンで作業が続行され、成功した場合はユーザーが新しいバージョンに切り替えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
失敗につながる可能性があるのは1つだけです。ヘルスチェックが成功し、ワークロードを受信するとすぐにアプリケーションがクラッシュした場合、つまり、展開が完了した後にのみ、折りたたみが発生します。この場合、手動で古いバージョンにロールバックする必要があります。そこで、オープンソースツールでKubernetesを使用する方法を検討しました。これらのツールをビルド/デプロイパイプラインの作成/デプロイパイプラインに埋め込むと、デプロイプロセスがはるかに簡単になります。同時に、展開を開始するために、ユーザーインターフェイスを使用して、このプロセスを完全に自動化して、たとえば、マスターへのコミットを適用できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xp/4w/s6/xp4ws6tpk0katzykjamtvd1tuz8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Build Serverビルドサーバーは、Dockerイメージを作成し、それをDocker Hubまたは使用するその他のレジストリに貼り付けます。 Dockerハブはwebhookをサポートしているため、上記のようにDeployerを介してリモートデプロイメントを開始できます。したがって、潜在的な本番環境でのアプリケーションのデプロイメントを完全に自動化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のトピック、Kubernetesクラスターのスケーリングに移りましょう。 kubectlコマンドはスケーリングコマンドであることに注意してください。別の助けを借りて、クラスタ内のレプリカの数を簡単に増やすことができます。ただし、実際には、通常、ノードではなくノードの数を増やします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gh/za/t9/ghzat9sqpdai1jdgg3wabhrfeka.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、勤務時間中に、Amazonサービスのコストを削減するために、夜間にアプリケーションの実行中のインスタンスの数を減らす必要がある場合があります。これは、ポッドの数だけで十分にスケーリングされることを意味しません。ノードの1つがビジー状態でなくても、Amazonにそれを支払う必要があるためです。つまり、ハースのスケーリングとともに、使用するマシンの数をスケーリングする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Amazonを使用するか別のクラウドサービスを使用するかに関係なく、Kubernetesは使用するマシンの数について何も知らないため、これは注意が必要です。ノードのレベルでシステムをスケーリングできるツールがありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/6d/js/h86djs8fjx9qwpqos9lwpoknxno.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ノードとポッドを処理する必要があります。 AWS APIとスケーリンググループマシンを使用して新しいノードの起動を簡単にスケーリングし、Kubernetes作業ノードの数を構成できます。 cloud-initまたは同様のスクリプトを使用して、Kubernetesクラスターにノードを登録することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいマシンはScalingグループで起動し、それ自体をノードとして開始し、ウィザードのレジストリに登録して作業を開始します。その後、結果のノードで使用するレプリカの数を増やすことができます。 「不要な」マシンをオフにした後、そのようなステップが既に実行中のアプリケーションの破壊につながらないことを確認する必要があるため、規模を縮小するにはより多くの労力が必要です。このシナリオを回避するには、ノードを「スケジュールできない」状態にする必要があります。つまり、DaemonSetポッドをスケジュールするときのデフォルトのスケジューラーはこれらのノードを無視します。スケジューラーはこれらのサーバーから何も削除しませんが、そこに新しいコンテナーを起動しません。次のステップは、ドレインノードを移動することです。つまり、ドレインから別のマシン、またはこれに十分な容量がある他のノードに作業炉を転送します。これらのノードにコンテナがないことを確認したら、Kubernetesからコンテナを削除できます。その後、Kubernetesの場合、それらは単に存在しなくなります。次に、AWS APIを使用して、不要なノードまたはマシンを無効にする必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AWS APIに似た別のオープンソースのスケーリングツールであるAmdatu Scalerdを使用できます。クラスター内のノードを追加または削除するためのCLIを提供します。その興味深い機能は、次のjsonファイルを使用してスケジューラーを構成する機能です。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/0b/8z/e1/0b8ze13eeahulvu7j2cbuu2m8fe.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
示されているコードは、夜のクラスターの容量を半分にします。これは、使用可能なレプリカの数、およびAmazonクラスターの必要な容量として構成されます。このスケジューラーを使用すると、夜間は自動的にノード数が減り、朝は増えるため、Amazonなどのクラウドサービスのノードを使用するコストを節約できます。この機能はKubernetesに組み込まれていませんが、Scalerdを使用すると、このプラットフォームを好きなようにスケーリングできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの人々が私に言っているという事実にあなたの注意を向けたいです：「これはすべて良いですが、通常は静的な状態にある私のデータベースはどうですか？」 Kubernetesのような動的環境でこのようなものを実行するにはどうすればよいですか？私の意見では、これを行うべきではなく、Kubernetesのデータウェアハウスの運用を整理しようとするべきではありません。技術的には、これは可能であり、この主題に関するインターネット上のマニュアルがありますが、それはあなたの人生を非常に複雑にします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、永続ストレージの概念はKubernetesにあり、MongoやMySQLなどのデータウェアハウスを実行することもできますが、これはかなり時間がかかるタスクです。これは、データウェアハウスが動的環境との対話を完全にはサポートしていないためです。ほとんどのデータベースは、手動のクラスター調整を含む重要な調整を必要とし、自動スケーリングや他の同様のものは好きではありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Kubernetesでデータウェアハウスを起動しようとするときに、生活を複雑にしないでください。使い慣れたサービスを使用して従来の方法で作業を整理し、Kubernetesにそれらを使用する機会を与えるだけです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jt/ae/w4/jtaew4lftz8i845qgy8pa6bculm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トピックの最後に、私のチームが取り組んでいるKubernetesベースのCloud RTIプラットフォームを紹介します。一元化されたロギング、監視アプリケーション、およびクラスターを提供し、あなたに役立つ他の多くの便利な機能を備えています。 Grafanaなどのさまざまなオープンソースツールを使用して監視を表示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oo/uj/mz/ooujmzx3ukdhlcqyxxwqszgelts.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/ec/cd/5j/eccd5j4rch3uhdrqey516jdxnva.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜha-proxyロードバランサーをKubernetesで使用するのかという質問が出されました。現在、負荷分散には2つのレベルがあるため、良い質問です。 Kubernetesサービスは引き続き仮想IPアドレスに配置されます。 Amazonがクラウドホストを再起動するとアドレスが変更されるため、これらを外部ホストポートに使用することはできません。そのため、サービスの前にha-proxyサービスを配置し、Kubernetesとのシームレスなトラフィック相互作用のためのより静的な構造を作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの良い質問は、青/緑の展開中にデータベーススキーマを変更する方法を教えてください。</font><font style="vertical-align: inherit;">実際には、Kubernetesの使用に関係なく、データベーススキーマの変更は複雑な作業です。</font><font style="vertical-align: inherit;">古いスキームと新しいスキームの互換性を確保する必要があります。その後、データベースを更新してからアプリケーション自体を更新できます。</font><font style="vertical-align: inherit;">データベースをホットスワップしてから、アプリケーションをアップグレードできます。</font><font style="vertical-align: inherit;">新しいスキームで完全に新しいデータベースクラスターをダウンロードした人を知っています。これは、Mongoのようなスキームのないデータベースの場合のオプションですが、いずれの場合も簡単な作業ではありません。</font><font style="vertical-align: inherit;">他にご不明な点がございましたら、よろしくお願いいたします。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/-Ci4vd4rh4M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">広告のビット:)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いつもご利用いただきありがとうございます。私たちの記事は好きですか？もっと面白い資料を見たいですか？私たちが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発した</font></font></a><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エントリーレベルサーバーのユニークなアナログで</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">$ 4.99から</font></a><font style="vertical-align: inherit;">、注文またはお友達</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">への開発者向けクラウドベースVPSの開発者</font></a><font style="vertical-align: inherit;">への推奨によって私たちをサポートして</font><b><font style="vertical-align: inherit;">ください：</font></b></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPS（KVM）E5-2697 v3（6コア）10GB DDR4 480GB SSD 1Gbpsの真実19ドルから、またはサーバーを分割する方法？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（オプションは、RAID1およびRAID10、最大24コア、最大40GB DDR4で利用可能です）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xdは、アムステルダムのEquinix Tier IVデータセンターで2倍安いですか？</font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">オランダでは、</font></b><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">199ドルから、インテルTetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV</font></a></b><font style="vertical-align: inherit;">を</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">2台</font></a></b><font style="vertical-align: inherit;">だけ持ってい</font><b><font style="vertical-align: inherit;">ます！</font></b></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デルR420-2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB-$ 99から！</font></font></b></b><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">インフラストラクチャビルディングの構築方法</font></a><font style="vertical-align: inherit;">について</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">お</font></a><font style="vertical-align: inherit;">読みください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Dell R730xd E5-2650 v4サーバーを使用するクラスcは、1ペニーで9,000ユーロかかりますか？</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id505064/index.html">Mikrotik split-dns: mereka berhasil</a></li>
<li><a href="../id505070/index.html">Masturbasi intelektual tentang tulisan yang bagus</a></li>
<li><a href="../id505074/index.html">Hosting dan server khusus: jawab pertanyaan. Bagian 2. Mengapa Internet mahal di pusat data?</a></li>
<li><a href="../ja504668/index.html">モバイルデベロッパー向けの興味深い資料の要約＃346（5月25〜31日）</a></li>
<li><a href="../ja504670/index.html">コンピュータサイエンスまたは苦痛における統一国家試験</a></li>
<li><a href="../ja504674/index.html">CRUDジェネレーターを備えたLaravel + Vue + ElementUIの大規模モジュラーSPAの基礎</a></li>
<li><a href="../ja504676/index.html">ゲームにランダムなピンチを追加します</a></li>
<li><a href="../ja504678/index.html">ITMO Research_ポッドキャスト：スタジアム全体の規模でのショーとARコンテンツの同期化にアプローチする方法</a></li>
<li><a href="../ja504680/index.html">SpaLのNLPライブラリの概要</a></li>
<li><a href="../ja504682/index.html">ノスタルジアポスト：j2me、Gravity Defied、64kb</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>