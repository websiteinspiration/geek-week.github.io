<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèª üçõ ü§≥ Localization of a QR code is an important task, undeservedly deprived of attention üåè ü§∑ ‚ô†Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We are sure that today there is not a single Habr reader who would not be familiar with QR codes. These two-dimensional barcodes are everywhere. It is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Localization of a QR code is an important task, undeservedly deprived of attention</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/smartengines/blog/496528/"><img src="https://habrastorage.org/webt/5g/mo/eg/5gmoegkwyn0bmh_t_kewswuiboc.png" width="250" align="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We are sure that today there is not a single Habr reader who would not be familiar with QR codes. These two-dimensional barcodes are everywhere. It is logical that in the world there are many tools that allow to add QR codes to your project with some degree of efficiency. The whole point is that this mentioned efficiency directly depends on the quality of the tool that is used to recognize QR codes. And here comes the classic plug: you can solve the problem (very) well and (very) expensive, or you can for free and somehow. Is it possible to modify the free so that it nevertheless solves the problem well? If interested, look under the cat.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recognizing a QR code in a photograph is a well-posed task of machine vision. Firstly, in the task, an object is investigated, which was originally specially designed for ‚Äúconvenient‚Äù recognition. Secondly, the task itself is divided into several independent understandable subtasks: localization of the QR code, orientation of the QR code and directly decoding the QR code. It turned out that the public domain has long had good libraries that can solve the last two problems: orientation and decoding of a QR code. One problem: for high-quality decoding, such libraries expect a good binary image directly of the barcode to be input. Conversely, little attention is paid to the task of barcode localization in the image.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our experience, the more accurately you localize a recognition object, the easier it is to choose the right pre-processing tools and, in fact, recognize it. Therefore, if you want to improve the quality of recognition of QR codes in your project, then start with the modernization of methods for localizing QR codes. Indeed, even if you later need to binarize an image, it is much more efficient (both from a computational and qualitative point of view) to binarize a region with a barcode than the entire original image. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article, we will tell you how to easily improve the quality of localization of QR codes using classical image processing methods, as well as provide numerical characteristics of the effectiveness of the proposed algorithm.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will talk about the original way of localizing QR codes on images, using the modified Viola and Jones method as its basis.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Information note on the topic of the article</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this section, we describe the key features of the QR code that are used to construct the localization method, as well as a brief description of the original version of the Viola and Jones method.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QR code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The QR code (short for Quick Response Code) is a two-dimensional barcode that was developed in Japan in the mid-90s for the automotive industry. </font><font style="vertical-align: inherit;">Due to the ability to quickly read and larger capacity compared to linear barcodes, the QR-code system has become popular worldwide in various areas of life.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unlike standard linear barcodes, which are usually scanned by hardware, a QR code is often scanned by a camera. </font><font style="vertical-align: inherit;">The structure of the QR code is fully described in ISO / IEC 18004 (The ISO / IEC standard 18004). </font><font style="vertical-align: inherit;">To build a robust recognition algorithm for such images, the QR code has some reference points that form a function pattern: three squares in the corners of the barcode image (called finder patterns) and smaller synchronizing squares throughout the barcode image (called alignment patterns) . </font><font style="vertical-align: inherit;">Such points allow you to normalize the image size and its orientation.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qp/ut/kn/qputknsphjra1c0nwyoxpfnwniy.png"><br>
<p><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">QR code structure</font></font></i></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although visually all QR codes are similar to each other, different copies of QR codes, depending on the amount of encoded data, can have a different layout of internal elements. </font><font style="vertical-align: inherit;">In addition, the so-called designer QR codes are very popular, in which instead of the part of additional information that guarantees high-quality recognition of the barcode, third-party graphic elements are used (logos, emblems, inscriptions, etc.). </font><font style="vertical-align: inherit;">All these features of QR codes must be taken into account when constructing methods for localization and recognition of QR codes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1k/f2/f0/1kf2f024blycs3yruzzsk3cnxr0.png"><br>
<br>
<p><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">Different valid QR code options</font></font></i></p><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viola and Jones Method</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Only the lazy on Habr√© did not write about the method of Viola and Jones yet. Even we in our block did this several times (for example, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). And still, we consider it necessary to very briefly, literally in two paragraphs, tell what it is. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Viola and Jones object detection method was developed to search for faces in an image in real time. This method reduces the detection problem to the binary classification problem at each image point, i.e., for each rectangular image region taken with all kinds of shifts and scales, the hypothesis of the presence of the desired object in the region is checked using a pre-trained classifier.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a feature space, the Viola and Jones method uses Haar rectangular features, the value of which is calculated as the difference between the sums of the brightness of the pixels of the image areas inside adjacent rectangles. To effectively calculate the value of Haar features, an integrated image is used, which is also known in the literature under the term summed-area table. A binary ‚Äúweak‚Äù classifier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Œß</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Üí {-1, + 1}, usually presented as a recognition tree with one branch: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y7/ly/se/y7lyseencrhtwi3hefy1xsl3kya.png" width="237"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
where </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Œ∏</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the threshold value of the attribute and the parity of the classifier, respectively. </font><font style="vertical-align: inherit;">Next, using the AdaBoost machine learning method, a ‚Äústrong‚Äù classifier is constructed as a linear superposition of the above ‚Äúweak‚Äù classifiers. </font><font style="vertical-align: inherit;">The high speed of the Viola and Jones method is ensured through the use of a cascade of ‚Äústrong‚Äù classifiers, which allows localizing ‚Äúempty‚Äù (object-free) image regions in a small number of calculations.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QR code detection algorithm</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When constructing a method for localizing a QR code, we relied on the following features of the task. First, the developed method must have high performance for use in recognition systems operating in real time. Secondly, the method must be resistant to permissible distortion of the barcode in the image. Thirdly, the method should take into account all the existing variability of QR codes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As mentioned above, we have chosen the method of Viola and Jones as the fundamental method. This method has proven itself in various tasks of searching for rigid objects, while the method provides the required performance. But in the original version, the Viola and Jones method cannot be used for the following reasons:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the classical method of Viola and Jones, a family of Haar attributes is used that ‚Äúemphasize‚Äù the textural features of the object, and in our case, although the QR code consists of black and white barcels, their distribution is very different from the barcode to the barcode;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the classical Viola and Jones method is designed for the same type of detection of objects in a given orientation, which is also not observed in our task.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So that the Viola and Jones method can be applied to solve the problem, we use the original family of boundary features and a high-level classifier in the form of a decision tree. </font><font style="vertical-align: inherit;">The first modification will allow focusing on the boundary features of the studied object, and not on the texture. </font><font style="vertical-align: inherit;">The second modification will allow you to build a single classifier that can detect variable objects. </font><font style="vertical-align: inherit;">Next, we will tell you a little more about each modification.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gradient signs of Haar.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To build an effective detector of QR codes, we used a special family of gradient features [1]. </font><font style="vertical-align: inherit;">These signs are Haar rectangular signs, calculated on top of the map of directed boundaries, which can significantly improve their generalizing power. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The map of directional boundaries is an image of the gradient modulus, which additionally takes into account the preferred direction of the gradient at the point ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), defined as the discretization of the angle of the border into horizontal, vertical, + 45 ¬∞ and ‚Äì45 ¬∞ directions. </font><font style="vertical-align: inherit;">To build a QR-code detector, we used two types of directional boundary map: a straight boundary map and a diagonal face map. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let the original image </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Then you can calculate the approximate value of the derivative along the horizontal and vertical directions using the Sobel operator: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pf/yg/_p/pfyg_pwalnr_vdg6dm-fi_jnv9o.png" width="466"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, using </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g </font></font></i><sub><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g </font></font></i><sub><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></i></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , you can calculate the direction of the gradient at each point of the image: The </font></font><br>
<br>
<img src="https://habrastorage.org/webt/28/7w/w1/287ww1jnk9sr3fbrtgsr-q4ygoc.png" width="301"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
map of straight borders contains mainly horizontal and vertical borders and is calculated as follows: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vi/bj/ie/vibjieyjzpf4rmokqrwozdru7ba.png" width="328"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Map diagonal borders contains mainly borders along the diagonals and is calculated as follows: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kg/zy/zy/kgzyzyc1owgaxci7skuiotoirw4.png" width="405"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On top of the constructed map of directed borders (diagonal or straight), rectangular Haar signs are calculated. Unlike the classical Haar features, such boundary features generalize well objects containing a huge number of boundaries.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mv/mo/fd/mvmofd__pwr9myrhvp4xxh9-_gi.png"><br>
<br>
<p><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">Illustration of a map of directional borders: (a) the original image of a QR code, (b) a map of straight borders, (c) an image of a rotated QR code (d) a map of the diagonal borders of a rotated QR code</font></font></i></p><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The decisive tree of strong classifiers</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The tree of strong classifiers [2] is a kind of binary decision tree: the tree node is a strong classifier, on the right edge of which there are subwindows presumably containing the object, and on the left - those that were not recognized as an object, respectively. </font><font style="vertical-align: inherit;">The final answer is given only in leaves. </font><font style="vertical-align: inherit;">The classical cascade classifier described in the original work of Viola and Jones is, in fact, a tree classifier containing only one ‚Äúpositive‚Äù output (leaf) and many ‚Äúnegative‚Äù outputs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In [2] it is shown that any path from the root to the lowest node of the tree classifier can be represented as a cascade in which individual strong classifiers enter with an inverted answer. </font><font style="vertical-align: inherit;">Thanks to this, it is possible to construct a learning algorithm for the tree classifier, which uses the training procedure of the classical cascade classifier to teach individual paths. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The tree classifier allows you to train classifiers that are more effective in terms of completeness for variable objects as compared to classical cascading classifiers.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Experimental results</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As part of an experiment to evaluate the effectiveness of the barcode localization method proposed in this article, a set of barcode images consisting of 264 images was prepared. </font><font style="vertical-align: inherit;">The physical size of the images was about 1 MPix. </font><font style="vertical-align: inherit;">Each image contains only one QR code in an arbitrary orientation, the barcode area was at least 10% of the total image area. </font><font style="vertical-align: inherit;">The figure below shows examples of images from the assembled set.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rb/vv/bd/rbvvbdyp8t7mffaqa38b4olv-_m.png"><br>
<br>
<p><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">Examples of images from the assembled barcode image set</font></font></i></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The prepared set of images was divided into a training set and a test set. The size of the training sample was 88 images, the size of the test sample was 176 images. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The training set was used both for preparing positive examples and for preparing negative examples. Since the initial number of positive examples was small, we used data augmentation technology [3]. In particular, we applied rotation around the center of the barcode in increments of 15‚Å∞. After augmentation, the number of positive examples was 2088 examples.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using the same positive and negative examples, we trained three QR code detectors: a classic cascading classifier with standard Haar features, a classic cascading classifier with boundary features, and a tree classifier with boundary features. </font><font style="vertical-align: inherit;">The first cascade classifier consisted of 12 levels and contained a total of 58 attributes. </font><font style="vertical-align: inherit;">The second cascade classifier consisted of 8 levels and contained a total of 39 attributes. </font><font style="vertical-align: inherit;">The trained tree classifier consisted of 39 vertices, contained a total of 110 characters, and the maximum path from the top to the leaf was 9. Below is a diagram of the trained tree classifier.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0e/pp/rx/0epprxrwsrqho130ykkanqj_cs8.png"><br>
<br>
<p><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">Scheme of trained tree classifier</font></font></i></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To assess the quality of the constructed QR-code detectors, we used the barcode decoding module from the OpenCV open-source computer vision library. </font><font style="vertical-align: inherit;">On the prepared test set of images (which, as mentioned above, consisted of 176 images), we launched the decoding module without any special preprocessing, as well as after a preliminary search for QR codes using trained detectors. </font><font style="vertical-align: inherit;">Below are the barcode decoding results:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Experimental title</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decoded Image Count</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decoding quality</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Only OpenCV</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">104</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59.09%</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VJ (Grayscale Features, Cascade Classifier) ‚Äã‚Äã+ OpenCV</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">105</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59.66%</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VJ (Edge Features, Cascade Classifier) ‚Äã‚Äã+ OpenCV</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">123</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69.89%</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VJ (Edge Features, Tree Classifier) ‚Äã‚Äã+ OpenCV</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">136</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">77.27%</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The table shows that the preliminary localization of the QR code using the described method can significantly improve the quality of barcode decoding (the number of decoding errors decreased by 44%). In addition, the results also demonstrate that the application of the original Viola and Jones method (with classical Haar features and a cascading classifier) ‚Äã‚Äãis not effective in the task of localizing QR codes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's see how accurately each classifier localizes the barcode. </font><font style="vertical-align: inherit;">The figure from left to right shows the results of detecting the same barcode with a classic cascading classifier with standard Haar features, a classic cascading classifier with boundary features, and a tree classifier with boundary features. </font><font style="vertical-align: inherit;">It can be seen that the tree-classifier provides the best barcode localization accuracy by taking into account the variability of QR codes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/o-/um/wr/o-umwrnaxpniz5oziynxxm-bjja.png"><br>
<br>
<p><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">Illustration of the work of trained detectors on the same image</font></font></i></p><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Today, QR codes are used in various areas of life: in the advertising industry for encoding URLs, in the state segment as part of electronic services, etc. </font><font style="vertical-align: inherit;">Despite the extremely high distribution of such barcodes, the existing open source libraries focus on the decoding process, not the localization problem. </font><font style="vertical-align: inherit;">But to be honest, the true purpose of this article was not so much in describing an effective method of localizing QR codes, but rather in an attempt to tell you, dear reader, how, using scientific thinking and system analysis, understanding how to use classical digital image processing tools, you can free libraries bring to the actual industrial level. </font><font style="vertical-align: inherit;">Thank you for the attention.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List of sources used</font></font></b><div class="spoiler_text">[1] A.A. Kotov, S.A. Usilin, S.A. Gladilin, and D.P. Nikolaev, ‚ÄúConstruction of robust features for detection and classification of objects without characteristic brightness contrasts,‚Äù Journal of information technologies and computing systems, 1, 53-60, (2014).<br>
[2] A. Minkina, D. Nikolaev, S. Usilin, and V. Kozyrev, ‚ÄúGeneralization of the Viola-Jones method as a decision tree of strong classifiers for real-time object recognition in video stream,‚Äù in Seventh International Conference on Machine Vision (ICMV 2014), 9445, International Society for Optics and Photonics, (2015), doi:10.1117/12.2180941.<br>
[3] D. P. Matalov, S. A. Usilin, and V. V. Arlazarov, ‚ÄúModification of the viola-jones approach for the detection of the government seal stamp of the russian federation,‚Äù in Eleventh International Conference on Machine Vision (ICMV 2018), 11041, International Society for Optics and Photonics, (2019), doi:10.1117/12.2522793.</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en496510/index.html">How NOT to become a Game Designer</a></li>
<li><a href="../en496512/index.html"># 05 - And a whole byte is not enough ... | Anime</a></li>
<li><a href="../en496514/index.html">IPIP IPsec VPN tunnel between Linux machine and Mikrotik behind NAT provider</a></li>
<li><a href="../en496516/index.html">Telegram bot in python vs COVID-19</a></li>
<li><a href="../en496518/index.html">How did we get to the remote</a></li>
<li><a href="../en496532/index.html">We check on ourselves: how to deploy and how to administer 1C: Document flow within the 1C company</a></li>
<li><a href="../en496536/index.html">DeepCode: side view</a></li>
<li><a href="../en496538/index.html">Fractals in Python. Walkthrough</a></li>
<li><a href="../en496542/index.html">Internet traffic in Europe has grown one and a half times. Backbone providers record load records</a></li>
<li><a href="../en496544/index.html">Online hackathon of projects for self-employed: 500 thousand rubles for their ideas and support from the Federal Tax Service</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>