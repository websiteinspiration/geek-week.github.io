<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎹 🔔 👷🏼 Buat arsitektur yang skalabel dan tangguh dengan layanan microser dinamis 🏎️ 👡 👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo lagi. Seperti yang Anda ketahui, pada bulan Maret, OTUS meluncurkan kursus yang benar-benar baru tentang Pola Arsitektur dan Desain . Menjelang a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Buat arsitektur yang skalabel dan tangguh dengan layanan microser dinamis</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/492642/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo lagi. </font><font style="vertical-align: inherit;">Seperti yang Anda ketahui, pada bulan Maret, OTUS meluncurkan kursus yang benar-benar baru </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tentang Pola Arsitektur dan Desain</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Menjelang awal kursus, banyak materi telah diterjemahkan untuk Anda tentang Membuat arsitektur yang skalabel dan tangguh menggunakan microservices dinamis. </font><font style="vertical-align: inherit;">Selamat membaca!</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/aw/ws/kg/awwskgrciq1fkykr-snivzihfds.png"><br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anotasi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu tren paling penting dalam arsitektur industri adalah penggunaan layanan-layanan mikro yang merugikan arsitektur monolitik yang kehilangan popularitas. </font><font style="vertical-align: inherit;">Berkat arsitektur cloud, penyebaran sistem layanan-mikro lebih produktif, fleksibel, dan hemat biaya. </font><font style="vertical-align: inherit;">Meskipun demikian, banyak perusahaan sudah mulai bergerak dari satu jenis arsitektur ke yang lain, tetapi ini masih dalam masa pertumbuhan. </font><font style="vertical-align: inherit;">Dalam artikel ini, kami memecahkan masalah yang timbul dari kebutuhan untuk mengembangkan sistem yang dapat diskalakan dan toleran kesalahan berdasarkan pada layanan-layanan microser. </font><font style="vertical-align: inherit;">Dalam percobaan kami, kami mempertimbangkan dua jenis layanan mikro, sederhana dan canggih, dan menunjukkan bahwa solusi yang diajukan inovatif berdasarkan pada perilaku dinamisnya.</font></font><a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Perkenalan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam beberapa dekade terakhir, sejarah bahasa pemrograman dan paradigma ilmu komputer telah ditandai dengan meningkatnya perhatian terhadap distribusi dan modularisasi untuk meningkatkan penggunaan kembali dan keandalan kode.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada kebutuhan untuk meningkatkan kuantitas dan kualitas perangkat lunak [1]. Salah satu faktor kunci dalam mengklarifikasi berbagai ketidaksepakatan yang terkait dengan desain inovatif adalah kecukupan menggunakan berbagai alat untuk desain dan pengembangan sistem perangkat lunak yang lebih maju [2]. Keberhasilan besar dalam proses ini baru-baru ini ditunjukkan oleh sistem berbasis pada layanan mikro [3], yang merupakan paradigma arsitektur yang berfokus pada berbagai aplikasi (misalnya, untuk penyandang cacat) [3]. Di bawah naungan microservices, minat dalam arsitektur dan desain berkembang. Atribut kualitas (misalnya, skalabilitas, kinerja, dan toleransi kesalahan) atau pemilihan model, seperti "kontrak layanan" [5] atau API Gateway,tidak lagi melanggar prinsip YAGNI (“Anda tidak akan membutuhkannya” - “menderita kesalahan BDUF” (“Desain Besar di Depan” - “Desain skala besar lebih dulu”). Pertanyaan penelitian utama yang ingin dijawab oleh artikel ini adalah bagaimana kita dapat mengembangkan suatu sistem berbasis pada layanan-layanan mikro dengan kesederhanaan yang sama dengan sistem monolitik? Dan selanjutnya, mulai dari topik sebelumnya, bagaimana kita bisa menciptakan lingkungan yang menyediakan distribusi dinamis daya komputasi antara klien? Hipotesis penelitian kami menyarankan menggunakan arsitektur sistem server-klien yang menggabungkan komputasi terdistribusi dan layanan mikro untuk memecahkan masalah ini.Pertanyaan penelitian utama yang ingin dijawab oleh artikel ini adalah bagaimana kita dapat mengembangkan suatu sistem yang didasarkan pada layanan-layanan mikro dengan kesederhanaan yang sama dengan sistem monolitik? Dan selanjutnya, mulai dari topik sebelumnya, bagaimana kita bisa menciptakan lingkungan yang menyediakan distribusi dinamis daya komputasi antara klien? Hipotesis penelitian kami menyarankan menggunakan arsitektur sistem server-klien yang menggabungkan komputasi terdistribusi dan layanan mikro untuk memecahkan masalah ini.Pertanyaan penelitian utama yang ingin dijawab oleh artikel ini adalah bagaimana kita dapat mengembangkan suatu sistem yang didasarkan pada layanan-layanan mikro dengan kesederhanaan yang sama dengan sistem monolitik? Dan selanjutnya, mulai dari topik sebelumnya, bagaimana kita bisa menciptakan lingkungan yang menyediakan distribusi dinamis daya komputasi antara klien? Hipotesis penelitian kami menyarankan menggunakan arsitektur sistem server-klien yang menggabungkan komputasi terdistribusi dan layanan mikro untuk memecahkan masalah ini.yang menyediakan distribusi dinamis daya komputasi antara klien? Hipotesis penelitian kami menyarankan menggunakan arsitektur sistem server-klien yang menggabungkan komputasi terdistribusi dan layanan mikro untuk memecahkan masalah ini.yang menyediakan distribusi dinamis daya komputasi antara klien? Hipotesis penelitian kami menyarankan menggunakan arsitektur sistem server-klien yang menggabungkan komputasi terdistribusi dan layanan mikro untuk memecahkan masalah ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Struktur dokumen adalah sebagai berikut: bagian 2 memberikan tinjauan singkat dari literatur saat ini yang menjelaskan pentingnya layanan-mikro, termasuk dua layanan terkenal yang ditawarkan oleh Azure, dan bagian 3 membahas arsitektur yang diusulkan. </font><font style="vertical-align: inherit;">Bagian 4 membahas evaluasi sistem ini sebelum menarik kesimpulan pada bagian terakhir.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Tinjauan literatur layanan-layanan mikro</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berkat arsitektur cloud, penyebaran sistem layanan-mikro lebih produktif, fleksibel, dan hemat biaya [6]. Namun, Zimmermann mencatat bahwa layanan mikro adalah topik sensitif yang sedang dipelajari terutama di dunia akademis [7] dan industri. Istilah "layanan mikro" pertama kali dibahas pada seminar arsitek perangkat lunak di Italia pada Mei 2011 untuk menggambarkan apa yang dilihat oleh peserta sebagai gaya arsitektur umum yang baru-baru ini dieksplorasi oleh banyak dari mereka. Setahun kemudian, kelompok yang sama mengkonfirmasi bahwa istilah "layanan mikro" adalah nama yang paling tepat. Bahkan, layanan microser dikembangkan sebagai jawaban untuk masalah dalam aplikasi monolitik atau arsitektur berorientasi layanan yang memperumit skalabilitas, kompleksitas, dan ketergantungan aplikasi yang sedang dikembangkan,bersama dengan penggunaan mekanisme komunikasi ringan [8-9]. Karena monolith adalah aplikasi perangkat lunak yang modul-modulnya tidak dapat dieksekusi secara independen, kita harus mempertimbangkan solusi berdasarkan layanan-mikro, karena itu adalah satu-satunya yang mampu mengeksekusi instruksi yang terpisah satu sama lain [10-11]. Monolit besar menjadi bermasalah untuk dipertahankan seiring waktu dan sulit untuk dievaluasi karena kerumitannya, tetapi kelemahan utamanya adalah mereka membatasi skalabilitas produk. Masalah lain adalah bahwa mereka tidak memberikan toleransi kesalahan, dan tidak memungkinkan komponen individu dari sistem untuk bekerja ketika komponen lain tidak berfungsi, yang dimungkinkan dalam arsitektur berorientasi layanan-mikro.Karena monolith adalah aplikasi perangkat lunak yang modul-modulnya tidak dapat dieksekusi secara independen, kita harus mempertimbangkan solusi berdasarkan layanan-mikro, karena itu adalah satu-satunya yang mampu mengeksekusi instruksi yang terpisah satu sama lain [10-11]. Monolit besar menjadi bermasalah untuk dipertahankan seiring waktu dan sulit untuk dievaluasi karena kerumitannya, tetapi kelemahan utamanya adalah mereka membatasi skalabilitas produk. Masalah lain adalah bahwa mereka tidak memberikan toleransi kesalahan, dan tidak memungkinkan komponen individu dari sistem untuk bekerja ketika komponen lain tidak berfungsi, yang dimungkinkan dalam arsitektur berorientasi layanan-mikro.Karena monolith adalah aplikasi perangkat lunak yang modul-modulnya tidak dapat dieksekusi secara independen, kita harus mempertimbangkan solusi berdasarkan layanan-mikro, karena itu adalah satu-satunya yang mampu mengeksekusi instruksi yang terpisah satu sama lain [10-11]. Monolit besar menjadi bermasalah untuk dipertahankan seiring waktu dan sulit untuk dievaluasi karena kerumitannya, tetapi kelemahan utamanya adalah mereka membatasi skalabilitas produk. Masalah lain adalah bahwa mereka tidak memberikan toleransi kesalahan, dan tidak memungkinkan komponen individu dari sistem untuk bekerja ketika komponen lain tidak berfungsi, yang dimungkinkan dalam arsitektur berorientasi layanan-mikro.mampu melaksanakan instruksi secara independen satu sama lain [10-11]. Monolit besar menjadi bermasalah untuk dipertahankan seiring waktu dan sulit untuk dievaluasi karena kerumitannya, tetapi kelemahan utamanya adalah mereka membatasi skalabilitas produk. Masalah lain adalah bahwa mereka tidak memberikan toleransi kesalahan, dan tidak memungkinkan komponen individu dari sistem untuk bekerja ketika komponen lain tidak berfungsi, yang dimungkinkan dalam arsitektur berorientasi layanan-mikro.mampu melaksanakan instruksi secara independen satu sama lain [10-11] Monolit besar menjadi bermasalah untuk dipertahankan seiring waktu dan sulit untuk dievaluasi karena kerumitannya, tetapi kelemahan utamanya adalah mereka membatasi skalabilitas produk. Masalah lain adalah bahwa mereka tidak memberikan toleransi kesalahan, dan tidak memungkinkan komponen individu dari sistem untuk bekerja ketika komponen lain tidak berfungsi, yang dimungkinkan dalam arsitektur berorientasi layanan-mikro.dan mereka tidak memungkinkan komponen individual dari sistem untuk bekerja ketika komponen lain tidak berfungsi, yang dimungkinkan dalam arsitektur berorientasi layanan-mikro.dan mereka tidak memungkinkan komponen individual dari sistem untuk bekerja ketika komponen lain tidak berfungsi, yang dimungkinkan dalam arsitektur berorientasi layanan-mikro.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam SOA (Arsitektur Berorientasi Layanan), layanan utama dikoordinasikan menggunakan dua metode: orkestrasi (di mana ada layanan microser pusat yang akan mengirim permintaan ke layanan lain dan mengontrol seluruh proses dengan mengirim dan menerima tanggapan) dan koreografi (yang tidak melibatkan sentralisasi, tetapi setiap layanan tahu sebelumnya apa yang harus dilakukan) [1]. Seperti dalam kasus arsitektur monolitik dan arsitektur SOA, masalah yang paling sulit adalah pembagian sistem menjadi layanan [12]. Selain itu, Anda tidak boleh mengabaikan masalah penyediaan informasi rahasia melalui distribusi layanan yang tidak terkendali [13].</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arsitektur kami menggabungkan komputasi terdistribusi dengan layanan microser untuk menciptakan lingkungan yang memungkinkan distribusi komputasi dinamis antara klien. Dengan komputasi terdistribusi, maksud kami adalah ketersediaan pemrosesan dan penyimpanan data dalam jumlah besar di cloud, yang merupakan elemen kunci dalam industri modern baik di dalam maupun di luar bidang TI. Sistem penyimpanan terdistribusi dirancang untuk memenuhi persyaratan aplikasi terdistribusi dan canggih komputasi dengan penerapan yang luas, skalabilitas, dan kinerja tinggi. Solusi yang terkenal adalah MapReduce [14], yang mengatur perhitungan dengan menyortir server terdistribusi, sementara secara bersamaan mengelola berbagai tugas, semua komunikasi dan transfer data antara bagian-bagian sistem,memberikan redundansi dan toleransi kesalahan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Azure Batch adalah model pemrograman lain yang digunakan untuk menjalankan aplikasi terkomputerisasi secara efisien dalam mode paralel atau skala besar, tanpa konfigurasi manual atau manajemen infrastruktur, dengan kelompok komputasi kinerja tinggi yang lebih kuat (HPC - komputasi kinerja tinggi) [15]. Untuk mengilustrasikan ide-ide ini, kami mengingatkan Anda tentang SaaS (perangkat lunak sebagai layanan) atau aplikasi klien yang perlu dieksekusi secara luas [16]. Bahkan, berbagai perusahaan IT menunjukkan peningkatan minat pada SaaS, tertarik untuk menurunkan biaya operasional mereka, dan sebagai hasilnya, dalam meningkatkan fleksibilitas bisnis mereka [17]. Layanan lain yang ditawarkan oleh penyedia layanan cloud utama adalah Fungsi Azure,yang memungkinkan peluncuran sesuai permintaan tanpa perlu penyediaan eksplisit atau manajemen infrastruktur [18].</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini juga meningkatkan minat aplikasi dengan mudah meluncurkan potongan kecil kode atau "fungsi" di cloud. </font><font style="vertical-align: inherit;">Minat yang tumbuh di Internet of Things (IoT) membuat Fungsi Azure [19] solusi yang sangat baik untuk pemrosesan data, integrasi sistem dan penciptaan API sederhana dan layanan mikro.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Metodologi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sistem yang diusulkan secara struktural dapat dibagi menjadi 3 area berbeda: (1) klien - yang akan melakukan tugas yang diberikan oleh server; (2) server - antarmuka dengan klien, otak aplikasi monolitik; (3) area manajemen komunikasi klien-server yang merangkum semua detail yang terkait dengan transfer eksekusi dari server ke klien. Semua informasi yang dikirimkan melalui jaringan antara klien dan server dienkripsi menggunakan algoritma DES (Data Encryption Standard), dan kuncinya diubah menggunakan protokol Diffie-Hellman [20], yang, meskipun rentan dalam kondisi tertentu, belum diimplementasikan dalam berbagai solusi keamanan Internet. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1. Sistem arsitektur</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sistem kami sangat didasarkan pada arsitektur sistem microservice dinamis. Arsitektur mengambil sebagai basis klien-server, di mana server sesuai dengan jumlah klien yang lebih besar. Baik server dan klien melakukan microservices web, protokol komunikasi adalah HTTP, format data JSON. Arsitektur ini bermanfaat untuk mendistribusikan dan mendistribusikan secara dinamis sumber daya di antara klien. Model arsitektur semacam itu digunakan untuk membangun aplikasi yang besar, kompleks dan dapat diskalakan secara horizontal yang terdiri dari proses kecil, independen dan terpisah yang berinteraksi satu sama lain menggunakan API [21].</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam gbr. Gambar 1 menunjukkan bagaimana server mendistribusikan paket fungsionalitas untuk kliennya. Tergantung pada jumlah klien, mungkin ada instruksi yang tidak akan diberikan kepada klien mana pun, atau serangkaian instruksi yang sama ditugaskan untuk beberapa klien. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yd/-j/hk/yd-jhkvmw4m4mjb0lskder-k9bg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 1. Distribusi layanan kepada pelanggan.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Arsitektur aplikasi dibangun menggunakan kerangka kerja ASP.NET MVC dari Microsoft. Di bagian tengah, kita melihat server microservices di server itu sendiri, dan di sebelah kiri dan kanan ada banyak klien yang menunggu untuk memulai tugas dari server. Komponen layanan orkestrasi menyediakan, di satu sisi, komunikasi antara server dan klien, mengirim tugas ke klien, dan di sisi lain, memantau status permintaan ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arsitektur ini memungkinkan satu microservice untuk memanggil microservice lain (sehingga kami mendapatkan microservice yang diperluas (extended)) atau untuk memanggil satu sama lain, yang dapat menyebabkan ketergantungan melingkar, yang harus dicegah di tingkat pengguna. </font><font style="vertical-align: inherit;">Protokol komunikasi client-server dilakukan dalam langkah-langkah berikut:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klien terhubung ke server dan memulai protokol pertukaran kunci. </font><font style="vertical-align: inherit;">Ia juga akan memberikannya ke server dan port tempat mereka akan berkorespondensi.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Server memberi tahu klien tentang tugas berikutnya yang harus dilakukan (tugas tersebut diwakili oleh pasangan (layanan mikro, data input)).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klien menerima pekerjaan, dan kemudian memberi tahu server bahwa transfer dan unduhan telah berhasil atau tidak berhasil.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segera setelah koneksi antara dua objek dibuat, server mengirimkan data dalam format JSON, dienkripsi menggunakan DES, ke klien untuk diproses.</font></font></li>
<li>      ( ,       )    JSON,    DES.</li>
<li>      ,         .</li>
<li>         —            .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kasus khusus dari interaksi ini adalah skenario ketika klien melakukan tugas untuk hasil yang dibutuhkan oleh klien lain. </font><font style="vertical-align: inherit;">Untuk kasus ini, dua kemungkinan yang ada dievaluasi: orkestrasi dan koreografi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal koreografi, kami mengidentifikasi beberapa kendala: (a) daftar klien yang tersedia untuk melakukan tugas eksternal harus dikirim oleh server ke klien, dan mempertahankan daftar nilai yang diperbarui ini sering mengakibatkan peningkatan beban pada jaringan pertukaran informasi; </font><font style="vertical-align: inherit;">(B) komunikasi antara kedua klien rentan terhadap serangan. </font><font style="vertical-align: inherit;">Dua situasi diselesaikan melalui orkestrasi. </font><font style="vertical-align: inherit;">Faktanya, semua perawatan manajemen ada pada server, dan klien hanyalah objek sederhana yang mudah untuk dikerjakan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk opsi microservices yang diperluas, fase interaksi klien-klien adalah sebagai berikut:</font></font><br>
<br>
<ol>
<li>          .    ,     .      ,     DES.</li>
<li>  , ,   .   ,    ,  ,    ,         .     ,     (  . .).</li>
<li>      ,       (   ),   ,        .</li>
<li>        .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klien mendekripsi hasilnya dengan kata sandi satu kali dan melanjutkan eksekusi.</font></font></li>
</ol><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2. </font><font style="vertical-align: inherit;">Aplikasi</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Untuk menguji dan mengevaluasi arsitektur ini, kami menerapkan beberapa layanan microser yang kami menyerukan untuk apa yang ingin kami periksa pada suatu waktu. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_l/ye/uc/_lyeucntwjhoj0xlbenxz4nygjs.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. </font><font style="vertical-align: inherit;">2. Antarmuka. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam percobaan pertama, kami menggunakan 3 layanan microser sebagai berikut: (1) layanan microser yang melakukan operasi matematika pada dua angka (menggunakan LibraryMath), (2) layanan microser yang memberi tahu kami apakah angka tersebut positif (MasterOfNumber) dan (3) sebuah layanan Microsoft diperluas, yang akan memanggil microservice pertama ketika menerima dua angka, dan hasilnya akan dikirim ke microservice kedua untuk mengekstrak informasi tentang nomor ini (UniverseOfSuperMath).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gambar 2 menunjukkan bagaimana kita memperoleh perhitungan matematis menggunakan microservices yang disajikan. Pada level antarmuka, hanya hasil operasi matematis yang ditampilkan, sisa informasi dapat dilihat sebagai hasil dari server yang menerima panggilan AJAX dengan menekan tombol sama (keduanya hasilnya positif). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, kami akan mempertimbangkan fungsi utama aplikasi, yang berfokus pada apa yang terjadi ketika ada satu, dua atau lebih klien yang terhubung. Pada Gambar 3 kita melihat bagaimana dalam percobaan kami, kami meluncurkan lebih banyak klien di komputer lokal, menggunakan port yang berbeda untuk masing-masing. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/94/nq/a9/94nqa9rzhinodyiixedizjaul8m.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 3. Antarmuka.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memiliki 6 bidang: ClientToken - token unik yang terkait dengan masing-masing klien (saat panggilan lokal dan memiliki nilai host lokal); Tanggal - saat ketika permintaan diajukan; IP &amp; Port = Alamat IP klien dan port yang digunakan untuk melakukan komunikasi; Fungsi - nama fungsi yang dipanggil; Sukses - bendera boolean yang menunjukkan keberhasilan panggilan. Sebagai contoh, kami perhatikan bahwa pada panggilan pertama (h: 8:38:21 klien tidak terhubung ke server, prosesnya dilakukan oleh server). Pada panggilan kedua, kami mengamati perilaku dinamis sistem, salah satu tugas yang dilakukan oleh salah satu klien, dan dua lainnya dilakukan oleh server. Lebih khusus lagi, UniverserOfSuperMath disebut (secara lokal - klien tidak tersedia untuk tugas ini), yang, pada gilirannya, memanggil dua layanan mikro lainnya, satu lokal dan satu melalui klien yang didelegasikan untuk menggunakan instruksi spesifik, dll.d.</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toleransi kesalahan</font></font></b></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Fungsionalitas lain yang saya perhitungkan ketika membuat arsitektur ini terkait dengan toleransi kesalahan sistem. Berdasarkan skenario sebelumnya, kita dapat mengamati apa yang terjadi jika satu atau lebih klien memilih untuk meninggalkan sistem.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada Gambar 3 di sebelah kanan, panggilan di 8:46 menunjukkan skenario ini. Klien pada port 8390 dan 8827 memiliki masalah lokal atau jaringan atau cukup tutup koneksi ke server, dan server tidak menerima pemberitahuan pada waktunya untuk menghapusnya dari daftar. Server akan mencoba menghubungi klien dan menjalankan perintah, tetapi jika mereka tidak merespons secara tepat waktu, server mengambil tugas mereka dan mengembalikan hasil yang diminta. Untuk konfirmasi, pelanggan akan diminta lagi setelah beberapa saat, dan jika mereka terus tidak merespons, mereka akan dihapus dari daftar pelanggan yang tersedia. Panggilan selanjutnya (8:47) tidak akan lagi meminta klien yang tidak berguna, dan tugas yang dilewati oleh klien yang tersedia akan dilakukan oleh server. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keuntungan dan kerugian dari solusi yang diusulkan</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keuntungan dari arsitektur ini jelas: biaya hosting yang rendah, layanan microser yang ditawarkan dalam jaringan terdistribusi bersifat dinamis dan terukur secara otomatis (ketika pelanggan juga menawarkan daya komputasi saat mereka meningkat, daya komputasi sistem meningkat).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Batasan harus ditekankan secara merata: ketika kurva daya komputasi tidak sesuai dengan kurva daya pelanggan. Kami juga memiliki batasan pada kemampuan untuk menjalankan aplikasi ini di sistem operasi apa pun. Untuk melakukan ini, kami memutuskan untuk mengonversi solusi yang terjangkau dari .NET ke Java. Tetapi solusi ini memiliki beberapa kelemahan sehubungan dengan solusi asli (Java menawarkan kecepatan pemrosesan data yang lebih rendah dan transfer paket yang kurang dinamis daripada yang kami lakukan di .NET). Kami saat ini menggunakan solusi ini karena .Net Core yang ditawarkan oleh Microsoft untuk bekerja pada beberapa platform belum merupakan solusi yang matang dan tidak menawarkan semua fungsi platform standar .NET). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3. Komponen server klien </font></font></b><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3.1. Pelanggan</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam arsitektur ini, klien adalah aplikasi desktop Windows Presentation Foundation (WPF) yang dirancang khusus untuk berkomunikasi dengan server dan melakukan berbagai tugas yang diterima darinya. Karena aplikasi adalah file yang dapat dieksekusi yang tidak memerlukan instalasi, sistem operasi harus bekerja dengan .Net Framework. Pada dasarnya, layanan web mikro akan berinteraksi dengan layanan web mikro lainnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, klien memulai penjadwal tugas dalam utas paralel, yang setiap menit akan mencoba untuk memberi tahu server keberadaannya. Suatu tugas dapat mengambil dua status: (1) apakah ada tugas untuk dieksekusi (inisialisasi paket kode telah selesai) - dalam hal ini hanya memberi tahu server keberadaannya; (2) atau memerlukan inisialisasi dengan server.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inisialisasi dengan server mencakup, pertama-tama, pilihan kode dan port yang sewenang-wenang yang akan memulai server, yang pada gilirannya dikirim ke sana menggunakan protokol pertukaran kunci Diffie-Hellman (IKE). Segera setelah koneksi antara kedua objek dibuat, server akan memberi tahu klien dengan paket instruksi untuk instalasi. Peran utama klien adalah menerima paket instruksi dari server, memuatnya ke dalam memori, memproses informasi yang diterima dari server, dan kemudian mengembalikan hasil yang diperoleh dengan menjalankan paket instruksi ini. Langkah pertama yang dilakukan oleh klien adalah menghubungi server untuk paket instruksi. Paket instruksi ini datang sebagai arsip ZIP.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum mengekstrak paket ini, hapus direktori sebelumnya dengan instruksi dari folder "proses" (jika ada), kemudian ekstrak konten baru ke folder ini dan muat ke dalam memori. Pemuatan memori dimulai satu kali, terlepas dari berapa banyak panggilan yang diterima klien. Ini dimungkinkan karena tiga properti tetap tidak berubah di sesi: assembly, methodInfo, dan type. Majelis menyimpan tautan ke DLL yang dimuat, properti methodInfo berisi metode yang disebut dari DLL, dan tipe menjelaskan tipe DLL. File install.zip adalah paket instruksi yang diterima dari server yang berisi DLL, XML, gambar, file konfigurasi, dll., Dan semua kode yang dikompilasi yang akan dieksekusi dalam proses selanjutnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Langkah ini menandai awal komunikasi antara klien dan server untuk melakukan tugas tertentu. </font><font style="vertical-align: inherit;">Segera setelah klien berhasil diinisialisasi untuk melakukan tugas tertentu, server hanya akan mengirim paket data dalam bentuk terenkripsi, yang harus diproses, dan juga akan menunggu respons dalam bentuk terenkripsi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan mengeksekusi kode yang diterima dari server, sistem "terkunci", klien dapat terhubung ke database, memanggil API lain, khususnya, memanggil klien lain yang menjalankan instruksi yang sama atau berbeda. </font><font style="vertical-align: inherit;">Sambungan dibuat dalam sistem orkestrasi, di mana server mencari klien yang tersedia berikutnya, meminta hasilnya dan jawabannya dialihkan oleh server kembali ke klien. </font><font style="vertical-align: inherit;">Orkestrasi microservice ini disebut "ExtendedService", dan satu-satunya perbedaan di tingkat klien adalah enkripsi dioptimalkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah teknisnya adalah menginisialisasi ulang klien dengan paket instruksi lain untuk dieksekusi. Karena memuat memori bersifat statis dalam konteks khusus (server web), ini hanya dimungkinkan dengan memulai ulang seluruh proses untuk memproses DLL yang dimuat ke dalam memori. Untuk melakukan ini, kami membuat acara di Windows yang kami jalankan dari aplikasi web yang berjalan di aplikasi desktop. Ini perlu karena kita berurusan dengan dua konteks berbeda dalam dua utas eksekusi yang berbeda. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3.2. Server</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microservice tertanam memiliki antarmuka ILibraryMath, yang menyediakan metode SimpleMath, dan antarmuka diimplementasikan oleh kelas LibraryMath. Kelas LibraryMath memperluas kelas abstrak universal MicroCore, yang memiliki dua parameter yang sesuai untuk input dan output. Memperluas kelas abstrak ini, metode ProcessTask harus diimplementasikan di mana semua kode yang akan dieksekusi ditulis, dan fungsi Jalankan dipanggil dalam kelas abstrak yang diperluas untuk mengeksekusi kode ini dalam metode SimpleMath. Dengan demikian, dimungkinkan untuk mendefinisikan antarmuka dan metode, tidak terbatas pada nama spesifik apa pun, tetapi, dengan melewatkan kode melalui kelas abstrak, kita akan mendapatkan kontrol penuh atas kode, yang dapat kita distribusikan di antara klien yang berbeda. Di dalam kelas ini, kita dapat dengan mudah memiliki lebih banyak fungsi dan perpustakaan yang diimpor,jika mereka dikelompokkan dalam satu paket.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Langkah selanjutnya adalah menulis antarmuka ini ke SimpleInjector, perpustakaan yang memfasilitasi penyebaran pola injeksi ketergantungan dengan komponen yang digabungkan secara longgar. Selain merekam kelas yang disisipkan dalam wadah Simple Injector, untuk memutuskan ketergantungan antara level aplikasi (memperkenalkan dependensi templat), kita perlu mendaftarkan kelas dalam wadah penyimpanan layanan mikro, yang akan diskalakan oleh aplikasi. Setelah langkah ini, kita akan dapat menggunakan fungsi yang disediakan oleh antarmuka untuk tujuan yang dibuat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Service1 mengimplementasikan IService1 dan memperluas kelas MicroCore abstrak, dan kemudian mendaftar dengan MicroContainer.RegisterMicro dalam wadah ini. Perlu menyebutkan keberadaan API yang tersedia di localohst / DynamicMicros / {Service} di mana klien berkomunikasi dengan server. Tindakan penting yang tersedia melalui API ini: klien terhubung, klien memberi tahu server tentang aktivitasnya, perluasan layanan microser, dll. Selanjutnya, kami memperkenalkan kelas MicroCore dan MicroContainer, yang bersama-sama membentuk dasar aplikasi kami.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas MicroCore adalah kelas universal yang abstrak dan bertanggung jawab untuk memanggil kode dari metode virtual ProcessTask. </font><font style="vertical-align: inherit;">Ini dilakukan dengan memanggil metode Jalankan, yang pada gilirannya memanggil metode TaskManager publik. </font><font style="vertical-align: inherit;">Perhatikan bahwa layanan Microsoft, pada gilirannya, juga akan memanggil metode ini. </font><font style="vertical-align: inherit;">Ketika paket ZIP dikirim ke klien untuk memuat ke dalam memori dan eksekusi, itu dikirim dengan semua dependensinya, termasuk kelas ini, yang digunakan untuk mengelola layanan-mikro klien. </font><font style="vertical-align: inherit;">Kontrol pelaksanaan termasuk deserializing / serialisasi paket data untuk dikirim, memanggil kode itu sendiri, memanggil API lain, dan sebagainya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kembali ke sisi server, mengendalikan pelaksanaan kode terdiri dari langkah-langkah berikut:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika panggilan ExtendedService, server akan dipanggil untuk menjawab.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika klien tersedia untuk permintaan, itu akan dikirim kepadanya untuk memproses hasilnya; </font><font style="vertical-align: inherit;">dalam kasus negatif, server itu sendiri akan memproses data.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami meminta klien untuk memproses data. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika klien memiliki masalah, kami kembali meminta konfirmasi ketersediaan, tetapi mengirim respons server (untuk menghindari waktu henti dan waktu tunggu yang lama).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mendaftarkan aktivitas saat ini.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas MicroContainer adalah ruang manajemen untuk seluruh embedded microsystem. </font><font style="vertical-align: inherit;">Di sini, klien yang menghubungkan aplikasi (server) terhubung, dan ada panggilan fungsi yang memperluas kelas abstrak MicroCore untuk "layanan lanjutan". </font><font style="vertical-align: inherit;">Ini adalah kelas statis di mana daftar tugas dilakukan pada layanan microser, daftar klien yang terhubung dan daftar tugas klien yang melakukan tugas-tugas ini disimpan dalam kamus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika diluncurkan, kelas akan didaftarkan untuk integrasi ke dalam microservice menggunakan RegisterMicro. Ini akan terjadi hanya sekali selama inisialisasi. Metode AddNewClient memberi kami registrasi klien baru, pertukaran kunci, pendaftaran alamat IP server dan port tempat kerjanya. Token yang diterima oleh klien baru akan diperiksa sebelum dimasukkan ke dalam daftar klien untuk mengkonfirmasi keunikannya. Setelah koneksi dengan klien dibuat, server akan memanggil metode InstallService, yang mengemas data, mengirimkannya, dan setelah klien merespons, itu akan ditambahkan ke kamus untuk tugas ini. Waktu layanan yang akan dialokasikan untuk setiap pelanggan tergantung pada strategi yang digunakan. Ketika Anda memulai microservice MicroCore abstrak, yang disebut di server dan di klien (dengan ExtendedService),permintaan dibuat untuk klien yang tersedia untuk tugas yang diminta menggunakan fungsi GetNextClient. Operasi ini akan dilakukan sangat sering, dan kompleksitasnya akan secara langsung mempengaruhi waktu respons aplikasi. Itulah sebabnya pendekatan kami adalah memilih klien secara acak. Ini dilakukan dengan cepat dan dari percobaan kami memastikan pemerataan panggilan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opsi lain adalah menerapkan daftar round-robin - solusi yang memiliki kelemahan yang jika terjadi aliran I / O klien besar, memperbarui daftar round-robin akan membutuhkan lebih banyak waktu dan kompleksitas, yang kami coba hindari. Metode RecordClientError dipanggil ketika klien tidak menanggapi permintaan yang diterima. Setelah menjawab pertanyaan ini, keputusan dibuat untuk menyimpan atau menghapus klien ini. Klien secara unik diidentifikasi oleh kode token yang dikirim oleh klien selama inisialisasi, dan setiap layanan mikro diidentifikasi oleh namespace dan nama kelas. Semua sumber daya (klien, kode) dikelola melalui unit kesatuan ini, yang menyediakan dukungan untuk operasi yang diperlukan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengenai keamanan sistem, langkah-langkah telah diambil untuk mencegah serangan, intersepsi, dan perlindungan data. Semua pesan yang dikirim antara server dan klien dienkripsi menggunakan algoritma kunci DES simetris dan pertukaran kunci Diffie-Hellman antara klien dan server, yang terjadi selama inisialisasi klien. Klien dan program yang berjalan disimpan dalam memori server. Kami memilih solusi ini karena, menurut kami, itu adalah pilihan terbaik, karena memberikan akses kecepatan tinggi ke data, informasi dapat sangat sering berubah, dan area memori sangat sulit untuk diserang. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4. Perilaku dinamis dari sistem layanan-mikro</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama-tama, semua komputer tempat klien bekerja dapat berada di jaringan yang sama atau berbeda. Dua elemen dalam prioritas: (a) waktu yang dihabiskan untuk transfer data; dan (b) overhead yang ditambahkan oleh sistem untuk manajemen data (mis., pencarian pelanggan, enkripsi, dekripsi, penanganan kesalahan, dll.). Kami terutama tertarik pada perilaku sistem kami di jaringan lokal (LAN) dan global (WAN) (Gbr. 4). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1p/lc/fe/1plcfehcmqd4zkcgmuuuvd07cgq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 4. Rekam sistem yang bekerja di jaringan area lokal (kolom log pertama) dan global (kolom log kedua).</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kolom Nama tugas berisi semua pendaftaran yang dibuat oleh panggilan klien untuk setiap tugas, dan kolom Log adalah jam dan durasi dalam ms untuk setiap pemrosesan tugas (di sebelah kiri di jaringan lokal dan di sebelah kanan di jaringan global). Perhatikan bahwa tugas memiliki waktu respons terlama untuk panggilan pertama, setelah itu berkurang. Secara alami, karena semua unduhan memori, penyimpanan alamat, dll. Biasanya dilakukan pada panggilan pertama. Tiga tugas pertama adalah operasi matematika sederhana yang biasanya dilakukan dalam milidetik - waktu yang juga diperlukan untuk sistem kami.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk jaringan lokal, kami memiliki rata-rata 20-30 milidetik per tugas, yang berasal dari enkripsi, logging, dan transmisi melalui jaringan (bahkan jika itu lokal). Model komunikasi LAN ini juga digunakan di cloud, di mana komputer berada di tempat yang sama (pusat data), dan komunikasi di antara mereka adalah melalui serat optik, latensi jaringan minimal. Hasilnya ditunjukkan dalam gambar. 4 di kolom kiri log. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menguji aplikasi WAN kami, kami mengonfigurasi perute untuk merutekan panggilan dari port 80 ke:</font></font><code>http://192.168.1.160/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(alamat jaringan), dan IIS (Layanan Informasi Internet) meluncurkan aplikasi, dan itu dapat diakses dari mana saja di luar jaringan lokal. </font><font style="vertical-align: inherit;">Untuk menjalankan aplikasi di tingkat klien, diperlukan hak untuk menggunakan port 8000: 9000 (port arbitrary). </font><font style="vertical-align: inherit;">Klien diatur pada titik-titik yang sewenang-wenang, koneksi ke IP publik sudah dipastikan melalui API: </font></font><code>https://api.ipify.org/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hasilnya ditunjukkan dalam gambar. </font><font style="vertical-align: inherit;">4 di kolom log di sebelah kanan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hasil yang disajikan dalam gambar. </font><font style="vertical-align: inherit;">4, nilai-nilai di kolom kanan jurnal adalah 16-17% lebih tinggi dari nilai-nilai di kolom kiri jurnal untuk tiga tugas pertama (tanpa komunikasi dengan layanan microser lainnya) dan ± 10% untuk layanan microser yang mengunduh dokumen dari Internet atau berinteraksi dengan database di server spesifik.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Evaluasi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam studi ini, kami memantau perilaku sistem baik di jaringan lokal (menghubungkan 5 komputer melalui jaringan nirkabel) dan di jaringan global (menggunakan namespace </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mihaidm.ddns.net</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), membandingkan sistem kami dengan sistem monolitik, operasi ini dilakukan pada komputer (lihat tabel 1). </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabel 1. Peringkat sistem untuk jaringan.</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perhitungan (ms)</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tulis ke basis data (ms)</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pdf generation (ms)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">localhost</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.458</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.449</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lan</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.408</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16.415</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lemah</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">54</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.826</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">29.309</font></font></td>
</tr>
</tbody></table></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengujian dilakukan secara berurutan pada satu perangkat dengan 5 klien yang terhubung untuk pengujian jaringan. </font><font style="vertical-align: inherit;">Setiap tugas diselesaikan 100 kali, mengevaluasi jumlah total milidetik di semua panggilan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu adalah produk dari dua angka sebagai perhitungan numerik. Layanan microser tidak berinteraksi dengan layanan microser lainnya, jumlah informasi yang dikirim melalui jaringan kecil, dan kerumitan diminimalkan untuk secara ketat mempelajari waktu yang dihabiskan untuk tugas-tugas server, klien, dan manajemen jaringan. Jika perhitungan dilakukan oleh server (localhost), ini pertama kali diperiksa jika ada klien yang tersedia, dan karena klien tidak terhubung, server memproses hasilnya. Dalam kasus berikut, keberadaan klien di jaringan lokal menunjukkan penyelesaian tugas dalam kondisi operasi jaringan yang sangat cepat, dan dari sisi pemrosesan, enkripsi / dekripsi, menemukan respons klien. Untuk 100 eksekusi, waktu rata-rata yang diperlukan untuk menyelesaikan operasi adalah 25 ms, yang merupakan nilai yang menjanjikan mengingat rasio fleksibilitas / kecepatan. Dalam kasus WAN, waktunya dua kali lebih lamadaripada di jaringan lokal (54 ms), ini karena proses enkripsi, biaya transportasi, tetapi untuk pelaksanaan yang sebenarnya membutuhkan setengah milidetik.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tugas lain yang kami selidiki adalah menulis ke basis data. Secara khusus, kata yang akan ditulis ke database diambil sebagai parameter. Kami tertarik pada seberapa cepat klien akan menghubungi database yang terletak di luar area lokal (untuk penelitian ini, database tersebut berlokasi di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.my.gearhost.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Perhatikan bahwa nilai runtime pada LAN dan localhost sudah dekat. Dalam jaringan global, perbedaannya terlihat, karena memproses, mengelola data, dan klien tidak memakan waktu sebanyak rentang klien yang terhubung ke database untuk memasukkan nilainya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tugas terakhir yang dilakukan dalam penelitian ini adalah membuat file PDF, fokus kami adalah memperkirakan waktu transfer data dalam sistem. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kami mengunduh file PDF dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.pdf-archive.com/2018/05/14/diploma/diploma.pdf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang dimuat ke dalam memori. </font><font style="vertical-align: inherit;">Sistem akan menulis nama ke posisi tertentu dan mengembalikan hasilnya (dalam bentuk vektor byte) kembali ke server. </font><font style="vertical-align: inherit;">Untuk host lokal dan jaringan lokal, perbedaan sekitar 1000 ms mewakili waktu yang diperlukan untuk mengenkripsi dan mentransfer file PDF secara lokal. </font><font style="vertical-align: inherit;">Untuk WAN, nilai yang dihasilkan lebih tinggi karena biaya transmisi vektor byte sangat tinggi.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Kesimpulan dan pekerjaan di masa depan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sifat umum dan abstrak arsitektur sistem, disajikan dalam karya ini di sisi server, membuat desain menjadi sulit, karena kode yang sama dijalankan oleh server dan klien. Kita dapat berargumen bahwa arsitektur saat ini kompak, sederhana, mudah dimengerti dan diperluas; klien dapat melakukan tugas yang diberikan oleh server, server adalah antarmuka monolith dan klien.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arsitektur yang diusulkan membuatnya sangat mudah untuk membuat layanan microser baru, yang kemudian secara otomatis diintegrasikan ke dalam sistem embedded. Elemen inovatif dari arsitektur ini: dapat dengan mudah diskalakan, setiap klien baru menerima tugas dari server sesuai dengan strategi yang dikejar (tugas yang paling mahal, yang paling umum, kombinasi dari dua yang sebelumnya terdaftar atau murni hanya strategi sewenang-wenang). Faktanya, kami memiliki monolith dengan fleksibilitas sistem layanan-mikro. Server memproses distribusi dinamis tugas antara klien, memberikan penskalaan dinamis berdasarkan sejumlah parameter (jumlah panggilan ke tugas, waktu pelaksanaannya, atau kombinasi keduanya).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu arahan di masa depan memperhitungkan bahwa sistem ini dapat berhasil diintegrasikan ke dalam situs web atau sistem API dengan karakter aplikatif yang diucapkan. </font><font style="vertical-align: inherit;">Arsitektur yang diusulkan dapat ditingkatkan dan diperluas kapan saja karena ketersediaan untuk beberapa platform (misalnya, untuk ponsel). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arah lain di masa depan yang kami pertimbangkan dianggap sangat menarik saat ini - adalah bahwa pengguna memberikan daya komputasi sebagai imbalan dengan biaya (misalnya, sistem BITCOIN), aplikasi kami dikembangkan untuk menjalankan layanan-layanan microsoft pada komputer tertentu.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tautan Sumber</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Studi ini diterbitkan dengan dukungan program POC-A1-A1.2.3-G-2015, sebagai bagian dari proyek PrivateSky (P_40_371 / 13/01/01/2016) dan proyek README “Aplikasi interaktif dan inovatif untuk menilai keterbacaan teks-teks Rumania dan meningkatkan pengguna gaya penulisan ”, No. kontrak </font><font style="vertical-align: inherit;">114 / 09.15.2017, MySMIS 2014 kode 119286.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referensi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[1] Dragoni, N., Giallorenzo, S., Lluch-Lafuente, AL, Mazzara, M., Montesi, F., Mustafin, R. (2017a) "Layanan Mikro: Kemarin, Hari Ini, dan Besok." Mazzara M., Meyer B. (eds.), Sekarang dan Rekayasa Perangkat Lunak Tersembunyi. Peloncat </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[2] Mazzara, M., Khanda, K., Mustafin, R., Rivera, V., Safina, L. dan Silitti, A. (2018) "Ilmu dan Teknik Layanan Mikro". Dalam: P. Ciancarini, S. Litvinov, A. Messina, A., Sillitti, G. Succi (eds.) Prosiding Konferensi Internasional ke-5 dalam Rekayasa Perangkat Lunak untuk Aplikasi Pertahanan, SEDA 2016, Springer, 10-20.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[3] Dragoni, N., Lanese, I., Larsen, ST, Mazzara, M., Mustafin, R., dan Safina, L. (2017b) "Layanan Mikro: Cara Membuat Skala Aplikasi Anda". Dalam: Petrenko A., Voronkov A. (eds.) Perspektif Sistem Informatika. PSI 2017. Catatan Kuliah di Ilmu Komputer, 10742. Springer, Cham. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[4] Melis, A., Mirri, S., Prandi, C., Prandini, M., Salomoni, P., dan Callegati, F. (2016) “Kasus Penggunaan Arsitektur Layanan Mikro untuk Penyandang Cacat”. Pada Konferensi Internasional EAI ke-2 tentang Objek Cerdas dan Teknologi untuk Sosial, DOI: 10.1007 / 978-3-319-61949-1_5. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[5] Zimmermann, O. (2017) “Prinsip Microservices: Pendekatan Agile untuk Pengembangan dan Penerapan Layanan, Ilmu Komputer - Penelitian dan Pengembangan”, 32 (3-4): 301-310.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[6] Xia, C., Zhang, Y., Wang, L, Coleman, S., dan Liu, Y. (2018) “Sistem robotik cloud berbasis microservice untuk ruang cerdas”. Dalam: Sistem Robotika dan Otonomi 110, DOI: 10.1016 / j.robot.2018.10.001. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[7] Bogner, J., Fritzsch, J., Wagner, S., dan Zimmermann, A. (2019) "Layanan Mikro dalam Industri: Wawasan Teknologi, Karakteristik, dan Kualitas Perangkat Lunak". Pada Konferensi Internasional IEEE 2019 tentang Lokakarya Arsitektur Perangkat Lunak (ICSAW) Di: Hamburg, Jerman. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[8] Akentev, E., Tchitchigin, A., Safina, L., dan Mzzara, M. (2017) “Pemeriksa tipe terverifikasi untuk bahasa pemrograman Jolie”, https: // arXiv.org/pdf/1703.05186.pdf.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[9] Černý, T., Donahoo, MJ, dan Trnka, M. (2018) "Pemahaman kontekstual arsitektur layanan mikro: arah saat ini dan masa depan". ACM SIGAPP Ulasan Komputasi Terapan 17 (4): 29-45, DOI: 10.1145 / 3183628.3183631. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[10] Larucces, X., Santamaria, I., Colomo-Palacios, R., dan Ebert, C. (2018) “Layanan Mikro”. Dalam: Perangkat Lunak IEEE, 35/3: 96-100. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[11] Kalske, M. (2017) "Mengubah arsitektur monolitik menuju arsitektur layanan mikro". M.Sc. Tesis, Univ. dari Helsinki. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[12] Lenarduzzi, V., dan Taibi, D. (2016) “MVP Dijelaskan: Studi Pemetaan Sistematik tentang Definisi Produk yang Minimal Dapat Dimakan”. Pada Konferensi Euromicro ke-42 tentang Rekayasa Perangkat Lunak dan Aplikasi Lanjutan (SEAA), 112-119.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[13] Taibi, D., Lenarduzzi, V., Janes, A., Liukkunen, K., dan Ahmad, MO (2017) "Membandingkan Persyaratan Penguraian dalam Scrum, Scrum dengan Kanban, XP, dan Proses Pengembangan Pisang". Dalam: Baumeister H., Lichter H., Riebisch M. (eds.) Proses Agile dalam Rekayasa Perangkat Lunak dan Pemrograman Ekstrim. Catatan Kuliah dalam Pemrosesan Informasi Bisnis, 283. Springer, Cham. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[14] Gomez, A., Benelallam, A., dan Tisi, M. (2015) "Model Ketekunan Terdesentralisasi untuk Komputasi Terdistribusi". Pada Lokakarya BigMDE ke-3, L'Aquila, Italia. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[15] Kandave, KR (2018) "Komputasi kinerja tinggi pada Azure". Nanette Ray (ed.), AzureCAT, Microsoft Corporation.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[16] Sreenivas, V., SriHarsha, S., dan Narasimham, C. (2012) “Model Awan untuk Menerapkan SaaS”. Dalam: Penelitian Material Lanjutan 341-342, Trans Tech Publications, Swiss, 499-503. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[17] Badidi, E. (2013) "Kerangka Kerja untuk Seleksi dan Penyediaan Layanan-Sebagai-Layanan" Dalam: Jurnal Internasional Jaringan Komputer &amp; Komunikasi (IJCNC), 5 (3): 189-200. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[18] Lynn, T., Rosati, P., Lejeune, A., dan Emeakaroha, V. (2017) "Tinjauan Awal Platform Komputasi Cloud Tanpa Server Perusahaan (Functionas-a-Service)". Pada Konferensi Internasional ke-9 IEEE 2017 tentang Teknologi dan Ilmu Cloud Computing, 162-169. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[19] Adzic, G. dan Chatley, R. (2017) “Serverless Computing: Dampak Ekonomi dan Arsitektur.” Di: ESEC / FSE'17, 4-8 September 2017, Paderborn, Jerman, ACM.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[20] Diffie, W. dan Hellman, M. (1976) "Arah baru dalam kriptografi". </font><font style="vertical-align: inherit;">Dalam: Transaksi IEEE aktif, Teori Informasi, 22 (6): 644-654. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[21] Kratzke, N. (2015) “Tentang Microservices, Kontainer, dan Dampaknya yang Terlalu Rendah terhadap Kinerja Jaringan”. </font><font style="vertical-align: inherit;">Di CLOUD Comput. </font><font style="vertical-align: inherit;">2015, 180 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arxiv.org/abs/1710.04049</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelajari lebih lanjut tentang kursus</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id492616/index.html">Packer, Terraform dan Ansible: penyebaran cluster Kubernetes dalam satu jam</a></li>
<li><a href="../id492628/index.html">Interval kepercayaan untuk jumlah pasien dengan coronavirus (perhitungan kematian)</a></li>
<li><a href="../id492632/index.html">Usaha kecil yang dikarantina: panik adalah musuh akal</a></li>
<li><a href="../id492636/index.html">Apa artinya menjadi efektif?</a></li>
<li><a href="../id492638/index.html">Menskalakan aplikasi Redux dengan bebek</a></li>
<li><a href="../id492652/index.html">Permainan kartu "Bodoh" di dua M5Stack</a></li>
<li><a href="../id492658/index.html">Saya pergi ke remote control - meluncurkan podcast: apa yang harus dibaca untuk pemula - 5 buku yang terbukti</a></li>
<li><a href="../id492660/index.html">Seluruh dunia melawan coronavirus. Cerita Intel</a></li>
<li><a href="../id492662/index.html">Bagaimana saya pertama kali menyampaikan kuliah di universitas</a></li>
<li><a href="../id492666/index.html">Maltego Bagian 4. VK, Instagram, LinkedIN, dan makhluk-makhluk fantastis lainnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>