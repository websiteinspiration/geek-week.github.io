<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏽 ⛩️ 🎲 REPL tidak berguna. Laporan Yandex 👨🏼‍⚖️ 🕕 👂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="REPL (read-eval-print loop) tidak berguna dalam Python, bahkan jika itu IPython ajaib. Hari ini saya akan menawarkan salah satu solusi yang mungkin un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>REPL tidak berguna. Laporan Yandex</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/490788/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">REPL (read-eval-print loop) tidak berguna dalam Python, bahkan jika itu IPython ajaib. </font><font style="vertical-align: inherit;">Hari ini saya akan menawarkan salah satu solusi yang mungkin untuk masalah ini. </font><font style="vertical-align: inherit;">Pertama-tama, laporan dan ekstensi saya TheREPL akan bermanfaat bagi mereka yang tertarik dalam pengembangan yang lebih cepat dan lebih efisien, serta mereka yang menulis sistem stateful.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/w4zabj_GAhg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
- Nama saya Alexander, saya bekerja sebagai programmer di Yandex. Kami menulis di tim saya dengan Python, kami belum beralih ke Go. Tetapi di waktu senggang saya, anehnya, saya juga memprogram dan melakukannya dalam bahasa yang sangat dinamis - Common Lisp. Ini mungkin bahkan lebih dinamis daripada Python. Keunikannya terletak pada kenyataan bahwa proses pembangunan itu sendiri diatur agak berbeda. Ini lebih interaktif dan berulang, karena dalam REPL on Lisp Anda dapat melakukan segalanya: membuat modul baru dan menghapus modul lama, menambahkan metode, kelas dan menghapusnya, mendefinisikan kembali kelas, dll.</font></font><br>
<a name="habracut"></a><br>
<img src="https://habrastorage.org/webt/0p/ld/xo/0pldxop8ymqyuvlwarowoynh_44.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam Python, ini semakin sulit. Ini memiliki IPython. Tentu saja, IPython meningkatkan REPL dalam beberapa cara, menambahkan pelengkapan otomatis, dan memungkinkan menggunakan ekstensi yang berbeda. Tetapi untuk pengembangan berulang, itu tidak cocok dengan baik. Di dalamnya Anda dapat mengunduh kode, mengujinya sedikit dan hanya itu. Dan kadang-kadang dia menginginkan lebih banyak interaktivitas sehingga Anda benar-benar dapat menggunakan REPL ini dalam pengembangan, beralih antar modul, mengubah fungsi dan kelas di dalamnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu terjadi pada saya - Anda menjalankan, misalnya, IPython REPL di lingkungan produksi dan Anda mulai menjalankan beberapa perintah di sana, menyelidiki sesuatu, dan kemudian ternyata ada kesalahan dalam modul, dan Anda ingin memperbaikinya dengan cepat. Tetapi ini tidak berhasil, karena Anda perlu mengumpulkan gambar Docker baru, menggulungnya menjadi produksi, masuk ke REPL ini lagi, mencapai keadaan yang diinginkan di sana lagi, memulai semua yang jatuh di atasnya lagi. Dan idealnya, saya harus memperbaiki fungsinya, segera jalankan dan langsung dapatkan hasilnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang bisa dilakukan tentang ini? </font><font style="vertical-align: inherit;">Bagaimana saya bisa memuat ulang kode dalam IPython? </font><font style="vertical-align: inherit;">Saya mencoba menggunakan autoreload dan saya tidak menyukainya karena beberapa alasan. </font><font style="vertical-align: inherit;">Pertama-tama, ketika modul di-boot-ulang, ia kehilangan status yang ada di variabel global di dalam modul ini. </font><font style="vertical-align: inherit;">Dan mungkin ada nilai yang di-cache dengan hasil dari beberapa fungsi. </font><font style="vertical-align: inherit;">Atau saya bisa, misalnya, memuat data melalui jaringan di sana, sehingga nanti saya bisa bekerja dengannya lebih cepat. </font><font style="vertical-align: inherit;">Yaitu, autoreload kehilangan status. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena itu, sebagai percobaan, saya membuat ekstensi sederhana untuk IPython dan menamainya TheREPL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya datang kepada Anda dengan laporan ini sebagai gagasan tentang apa yang dapat dilakukan dengan REPL dengan Python. </font><font style="vertical-align: inherit;">Dan saya sangat berharap Anda akan menyukai ide ini, Anda akan melakukannya di kepala Anda dan akan terus menghasilkan hal-hal yang akan membuat Python semakin efisien dan nyaman.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa itu TheREPL? Ini adalah ekstensi yang Anda unduh, setelah itu konsep seperti namespace muncul di IPython, dan Anda dapat mengambil dan beralih ke modul Python apa pun, melihat variabel, fungsi, dan sebagainya apa yang ada. Dan yang lebih penting, Anda dapat langsung menulis def, nama fungsi, mendefinisikan kembali fungsi atau kelas, dan itu akan berubah di semua modul di mana itu diimpor. Tetapi pada saat yang sama, modul itu sendiri tidak me-restart, sehingga negara disimpan. Selain itu, TheREPL memungkinkan Anda untuk menghindari lebih banyak artefak yang ada dalam pengisian otomatis dan yang sekarang akan kita lihat.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h0/ob/lo/h0obloylvllg9wciqqyvg3yhqam.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, dalam autoreload, peningkatan kode hanya terjadi ketika file disimpan. Tetapi pada saat yang sama, Anda perlu memasukkan sesuatu ke dalam REPL itu sendiri, dan baru kemudian autoreload akan mengambil perubahan ini. Ini adalah masalah nomor 1. Artinya, jika Anda memiliki semacam proses latar belakang di utas terpisah (misalnya, server sedang berjalan), Anda tidak bisa hanya mengambil dan memperbaiki kode. Autoreload tidak akan menerapkan perubahan ini sampai Anda memasukkan sesuatu ke dalam IPython REPL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus ekstensi saya, Anda menekan pintasan tepat di editor, dan fungsi yang berada di bawah kursor segera diterapkan dan mulai berfungsi. Artinya, menggunakan TheREPL, Anda dapat mengubah kode lebih terperinci. Anda juga dapat menulis def di IPython.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8c/gf/5h/8cgf5hocolkvqgirby2kq730eus.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beralih antar modul, seperti yang saya katakan, pengisian otomatis tidak mendukung dengan cara apa pun. Anda hanya dapat menemukan file di sistem file, mengubahnya dan berharap bahwa autoreload akan menyelesaikan semua yang ada di sana. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/h-/4t/sr/h-4tsrp2ncyufazpguvh0qmjxum.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lebih jauh. Autoreload kehilangan variabel global, TheREPL menyimpan dan memungkinkan Anda untuk terus meneliti operasi aplikasi Anda, mengubah kode internalnya dan karenanya mengembangkannya dengan cepat.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tb/md/o_/tbmdo_pag196om9zw0heb1rtvy4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autoreload masih memiliki fitur ini. Dia dengan sangat licik menerapkan perubahan pada modul yang memuat ulang. Secara khusus, dia melakukan trik yang sangat menarik di sana. Jika fungsi dalam modul ini telah diperbarui, maka untuk mengubahnya di mana saja telah diimpor, ia menggunakan pengumpul sampah untuk menemukannya dan semua contoh fungsi ini dan mengubah kode di dalamnya. Lebih jauh kita akan melihat contoh bagaimana ini terjadi. Karena ini, kode fungsi berubah, bahkan jika itu masuk ke penutupan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apakah Anda tahu apa itu penutupan? Ini adalah hal yang sangat berguna. Pengembang JavaScript selalu menggunakan ini. Anda, kemungkinan besar, juga tidak pernah memperhatikan. Tetapi karena autoreload melakukan apa yang saya jelaskan di atas, Anda mungkin menemukan diri Anda dalam situasi di mana kode lama menggunakan kode baru yang mungkin bekerja secara berbeda. Misalnya, suatu fungsi dapat mengembalikan bukan hanya satu nilai, tetapi dua, tuple bukan string, dll. Kode lama akan merusak ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TheREPL tidak melakukan hal rumit seperti itu secara khusus untuk memastikan bahwa semuanya lebih konsisten. Yaitu, itu mengubah fungsi atau kelas dalam modul di mana ia didefinisikan. Temukan kelas ini di semua modul lain, dan ubah juga di sana. Setelah itu, semuanya bekerja dengan cara yang baru.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-j/fv/xo/-jfvxo93yhfdk69oyhb9xsybvom.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana cara mengganti fungsi yang dimuat secara otomatis? Kami memiliki dua fungsi, satu dan dua. Setiap fungsi memiliki seperangkat atribut: dokumentasi, kode, argumen, dll. Di sini, di slide adalah contoh mengganti atribut di mana bytecode disimpan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah autoreload mengubahnya, fungsi yang dipanggil mulai bekerja secara berbeda. Tapi ini adalah contoh sintetis yang baru saja saya ulangi dengan tangan saya sehingga Anda mengerti apa yang terjadi. Fungsi ini dipanggil dalam satu cara, tetapi kode di sana sebenarnya berbeda. Dan jika Anda membongkar, itu juga menunjukkan bahwa ia mengembalikan deuce. Apa yang menyebabkan ini? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bt/u7/qt/btu7qtygtpvagsnxat-tngwtvle.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah contoh penutupan. Pada baris kedua, kami membuat penutupan di mana kami menangkap fungsi foo. Penutupan itu sendiri mengharapkan bahwa fungsi yang kita lewati ini mengembalikan sebuah string, mengkodekannya dalam utf-8 dan semuanya berfungsi.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tu/mx/b8/tumxb8ifcxw_yh5o2veg8sfrtbw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi misalkan Anda mengubah modul di mana foo didefinisikan, dan memuat secara otomatis mengambil perubahan. Dan Anda mengubahnya sehingga tidak mengembalikan string, tetapi angka. Maka penutupan sudah akan bekerja secara salah, karena fungsi di dalamnya telah berubah di dalam, tetapi penutupan tidak mengharapkan ini, itu tidak berubah. Dan masalah dengan autoreload seperti itu dapat "menembak" di tempat yang tidak terduga. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ms/eq/k0/mseqk0r8rxsiji38ypx3drsloaw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana cara autoreload kelas pembaruan? Sangat sederhana. Ini memperbarui semua metode kelas dengan cara yang sama seperti fungsi, dan juga memperbarui atribut __class__ untuk semua contoh sehingga resolusi metode (menentukan metode mana yang harus dipanggil) mulai bekerja dengan cara baru.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya sedikit lebih rumit di TheREPL, karena ketika Anda memperbarui _class_, mungkin ternyata memiliki beberapa turunan, kelas anak, yang juga perlu diperbarui, karena ada sesuatu yang berubah dalam daftar kelas dasar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengatasi masalah ini, Anda dapat membangun kembali kelas. Tapi pertama mari kita lihat apa yang terjadi dengan autoreload ketika memuat ulang modul. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/p-/xc/jg/p-xcjggcwk7h30knymqvqsl9_ue.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah contoh yang bagus. Ada dua modul - a dan b. Dalam modul a, kelas induk didefinisikan, dalam modul b kelas anak, dan kami membuat turunan dari kelas anak. Dan baris 10 menunjukkan bahwa ya, ini adalah turunan dari kelas Foo, induknya. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nm/aj/gu/nmajgupfumnuw-igpxdk-_fbvlw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, kita ambil dan ganti modul a. Misalnya, tambahkan dokumentasi ke kelas Foo. Kemudian autoreload mengambil perubahan ini. Menurut Anda apa dalam hal ini ia akan kembali dari Bar?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3t/kz/iw/3tkziw2mnozaraudax0vm4ndzii.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan itu kembali salah, karena autoreload telah mengubah kelas Foo, dan sekarang ini adalah kelas yang sama sekali berbeda, bukan yang dari mana kelas Bar diwarisi. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jy/o5/mt/jyo5mtiwfcsw1vuvuegmz-ynxbm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan sebuah kejutan! Dalam dua modul a dan b, kelas Foo adalah kelas yang berbeda, dan Bar mewarisi dari salah satunya. Karena tiang tembok seperti itu, sangat sulit untuk memprediksi bagaimana kode Anda akan berfungsi setelah pengisian otomatis dilakukan sesuatu di dalamnya. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/g3/cj/3e/g3cj3enddiaxo02tzn5zr3jqaa8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sesuatu seperti ini, memperbarui kelas. Saya akan mengomentari gambar. Awalnya, kelas Foo diimpor ke modul b, dan tetap ada di sana. Saat mengganti pengisian otomatis, modul ini akan dipindahkan, dan kelas baru muncul di sana, dan di modul b tidak diperbarui.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ja/mg/pk/jamgpkvsohlnphdstlwz9_dbyig.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TheREPL memang sedikit berbeda. Dia menyuntikkan kelas yang dimodifikasi ke setiap modul tempat dia diimpor. Karena itu, semuanya bekerja dengan benar di sana. Apalagi, jika ada benda di kelas, mereka akan dilestarikan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/72/hk/cq/72hkcql64u5ap4p0dzhiwyoxicc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan inilah cara TheREPL memecahkan masalah dengan kelas anak. Yaitu, ketika kelas induk telah berubah, ia mendefinisikan daftar kelas dasar melalui mro atribut sulap (urutan resolusi metode). Atribut ini berisi daftar kelas dalam urutan di mana Anda ingin mencari metode atau atribut di dalamnya. Dan setiap kali Anda memanggil metode get_name pada objek Anda, misalnya, Python pertama-tama akan memeriksanya di kelas Bar, lalu di kelas Foo, lalu di kelas objek, jika tidak menemukannya. Kerjanya sesuai dengan prosedur urutan resolusi metode.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TheREPL menggunakan chip ini. </font><font style="vertical-align: inherit;">Dibutuhkan daftar kelas dasar, perubahan di sana kelas yang baru saja Anda ubah ke yang baru. </font><font style="vertical-align: inherit;">Menciptakan tipe anak baru, ini adalah langkah kedua. </font><font style="vertical-align: inherit;">Dengan fungsi type, Anda sebenarnya dapat membuat kelas. </font><font style="vertical-align: inherit;">Jika Anda belum pernah menggunakannya - cobalah, itu menyenangkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda hanya mengatakan nama kelas, katakan apa kelas dasarnya. </font><font style="vertical-align: inherit;">Dalam kasus paling sederhana, misalnya, objek. </font><font style="vertical-align: inherit;">Dan - kamus dengan metode dan atribut kelas. </font><font style="vertical-align: inherit;">Semuanya, Anda memiliki kelas baru yang dapat Anda instantiate, seperti biasa. </font><font style="vertical-align: inherit;">TheREPL memanfaatkan chip ini. </font><font style="vertical-align: inherit;">Ini menghasilkan kelas anak dan mengubah pointer ke dalamnya di semua objek dari kelas Bar lama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya masih punya demo, mari kita lihat cara kerjanya. </font><font style="vertical-align: inherit;">Pertama, mari kita lihat hal yang sangat sederhana.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo pertama</font></font></b><div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/w4zabj_GAhg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mengatakan bahwa Anda dapat mengubah kode di dalam modul. Misalkan kita memiliki server. Saya akan menjalankannya sekarang. Pada titik tertentu, kami menemukan bahwa karena alasan tertentu ia membuat direktori sementara. Atau dia mulai menciptakan, tetapi sebelum itu dia tidak menciptakan. Kemudian kita dapat terhubung ke server ini dan, menduga bahwa itu mungkin membuat direktori ini menggunakan fungsi mkdtemp dari modul file, Anda dapat langsung menuju ke modul Python ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lihat - di sudut nama modul saat ini telah berubah. Sekarang katanya tempfile. Dan saya bisa melihat fitur apa saja yang ada. Kami melihat mereka, dan kami dapat, penting, mendefinisikan kembali mereka. Saya telah menyiapkan pembungkus khusus yang memungkinkan Anda untuk menghias fungsi apa pun sehingga dengan semua panggilannya Anda dapat melihat jejak dari tempat namanya. Sekarang kita akan mengimpor dan menerapkannya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artinya, saya membungkus fungsi Python standar, bahkan tidak memiliki akses ke kode sumber untuk modul ini. </font><font style="vertical-align: inherit;">Saya bisa mengambil dan membungkusnya. </font><font style="vertical-align: inherit;">Dan pada output selanjutnya, kita akan melihat Traceback dan menemukan dari mana asalnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan cara yang sama, perubahan ini dapat diputar kembali sehingga tidak mengirim spam kepada kami. </font><font style="vertical-align: inherit;">Yaitu, kita melihat bahwa server ini di dalam pekerja pada baris kedelapan memanggil mkdtemp dan terus memproduksi direktori sementara untuk kita, mengacaukan sistem file. </font><font style="vertical-align: inherit;">Ini adalah satu aplikasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat contoh lain mengapa autoreload terkadang tidak bekerja dengan baik. </font><font style="vertical-align: inherit;">Saya memiliki bot telegram yang disiapkan:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo kedua</font></font></b><div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/w4zabj_GAhg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kami mengaktifkan pengisian otomatis dan melihat bagaimana ini membantu kami. Itu saja, sekarang Anda dapat memulai bot dan berbicara dengannya. Agar Anda dapat melihat dengan lebih baik, kami akan memulai dialog dengannya. Mengenal bot. Begitu. Ada semacam kesalahan. Kesalahan yang sama sekali berbeda dikandung, dan saya memutuskan untuk membuat perubahan pada saat terakhir. Tapi itu tidak masalah. Sekarang kita akan memperbaikinya, autoreload akan membantu kita dengan ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami beralih ke bot. Dan sekarang saya akan sementara mengomentari ini, jika demikian. Saya menyimpan file. autoreload, secara teori, harus menangkap perubahan ini. Mulai bot lagi. Bot mengenali saya. Mari kita bicara dengannya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kesalahan lain Dia sudah dikandung. Ayo kita perbaiki. Saya akan meninggalkan bot, itu akan bekerja di latar belakang, saya akan beralih ke editor, dan di editor kita akan menemukan kesalahan ini. Ini hanya kesalahan ketik, dan saya lupa bahwa variabel saya disebut user_name. Saya menyimpan file. autoreload seharusnya menangkapnya, dan sekarang kita akan melihatnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi autoreload, seperti yang sudah saya sebutkan, tidak tahu apa-apa tentang fakta bahwa file telah berubah sampai Anda memasukkan sesuatu ke dalamnya. Dengan proses yang panjang ... Itu perlu disela, dimulai kembali. Selesai Kembali ke bot kami, tulis padanya. Begini, bot itu lupa bahwa nama saya Sasha. Mengapa? autoreload membuatnya kembali karena memuat ulang seluruh modul sepenuhnya. Dan saya perlu menulis ke bot lagi, untuk memulihkan kondisinya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan jika Anda men-debug beberapa jenis kesalahan yang terjadi di negara tertentu, maka negara tidak dapat hilang, karena jika tidak, Anda akan menghabiskan banyak waktu lagi untuk mencapai keadaan ini. TheREPL membantu hanya dalam kasus-kasus seperti itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat bagaimana bot akan diperbarui jika menggunakan TheREPL. Untuk kemurnian percobaan, saya akan me-restart IPython dan kami akan mengulanginya lagi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan sekarang saya mengunduh TheREPL. Dia segera mulai mendengarkan pada port tertentu sehingga Anda dapat mengirim kode di dalamnya. By the way, ini dapat dilakukan bahkan jika IPython berjalan di suatu tempat di server dan editor berjalan secara lokal, yang juga dapat membantu Anda dalam beberapa kasus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mengimpor bot, memulainya, menulis lagi. Di sini jelas - kami memulai ulang Python, jadi ia tidak ingat siapa saya. Periksa apakah ada kesalahan di dalamnya. Ya, ada kesalahan. Baiklah, mari kita selesaikan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya beralih kembali ke editor, memperbaiki kesalahan. Kami bahkan tidak harus menyimpan file, saya tekan Ctrl-C, Ctrl-C, ini adalah jalan pintas yang digunakan Emacs untuk mengambil deskripsi fungsi saat ini yang berada tepat di bawah kursor dan mengirimkannya ke proses Python yang terhubung. Itu saja, sekarang kita bisa melihat dan memeriksa bagaimana bot kami menanggapi pesan saya di sana. Sekarang, dia ingat bahwa saya Sasha, dan dengan jujur ​​menjawab bahwa dia tidak tahu caranya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita coba tambahkan fungsionalitas baru secara langsung di sana. Untuk melakukan ini, kembali ke editor. Misalnya, tambahkan perintah bantuan. Untuk saat ini, biarkan dia menjawab bahwa dia tidak tahu apa-apa tentang bantuan. Sekali lagi, tekan Ctrl-C, Ctrl-C, kode diterapkan. Kami pergi ke bot. Lihat apakah dia mengerti perintah ini. Ya, tim telah mendaftar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ngomong-ngomong, dia masih memiliki hal seperti itu, sekarang kita akan melihat bagaimana kelas akan berubah. Dia memiliki perintah status, perintah debugging khusus untuk melihat status bot. Jadi, beberapa Oleg terhubung. Menarik.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika bot mengeksekusi perintah ini, ia memanggil reply untuk melihat representasi dari bot. Kita dapat pergi dan memperbaiki, misalnya, balasan ini dengan sesuatu yang lain. Misalnya, buat sedemikian rupa sehingga hanya nama yang dimasukkan. Anda bisa melakukannya. Kami kembali ke messenger kami, sekali lagi mengeksekusi negara. Dan itu saja. Sekarang balasan berfungsi dengan cara baru, tetapi objeknya sama, ia telah mempertahankan kondisinya, karena ia mengingat kita semua - Oleg, Sasha, kek dan "DROP TABLE Users, Alex"! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, Anda dapat menulis dan men-debug kode secara langsung, tanpa beralih ke siklus ini, ketika Anda perlu mengumpulkan paket, gulung di suatu tempat. Anda dapat dengan cepat menguji sesuatu, mengubah semua yang Anda butuhkan, dan hanya kemudian semua perubahan ini harus dikemas dengan benar dan digunakan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu, Anda tidak boleh melakukan ini dalam produksi nyata, karena dengan pendekatan ini masalah apa yang bisa terjadi. Anda mungkin lupa bahwa kode yang baru Anda mulai di server harus disimpan dan kemudian digunakan sebagaimana mestinya. Pendekatan ini membutuhkan disiplin. Tetapi dalam proses pengembangan dan debugging pada beberapa jenis pengujian, ini adalah hal yang hebat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pastikan untuk membuat plugin untuk PyCharm. Jika ada sukarelawan yang akan membantu saya dengan Kotlin dan plugin PyCharm, saya akan senang berbicara. Tulis saya </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam surat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">telegram</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* * * </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terhubung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk pengembangan TheREPL. </font><font style="vertical-align: inherit;">Ada banyak lagi chip yang bisa Anda pikirkan. </font><font style="vertical-align: inherit;">Sebagai contoh, Anda dapat menemukan cara untuk memperbarui instance kelas ketika mereka memutakhirkan, menambahkan atribut baru di sana atau memutakhirkan status mereka dengan cara apa pun. </font><font style="vertical-align: inherit;">Demikian pula, kami akan memutakhirkan basis data. </font><font style="vertical-align: inherit;">Sekarang ini bukan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat membuat kode hot-reload untuk produksi sehingga ketika perubahan baru datang kepada Anda, Anda tidak harus me-restart server. </font><font style="vertical-align: inherit;">Anda dapat menghasilkan lebih banyak. </font><font style="vertical-align: inherit;">Ini hanya sebuah ide, dan saya ingin Anda keluar dari sini. </font><font style="vertical-align: inherit;">Kita harus menyesuaikan semuanya untuk diri kita sendiri dan membuatnya nyaman. </font><font style="vertical-align: inherit;">Itu saja untuk saya.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id490778/index.html">Orang yang memahami pekerjaan seorang programmer dapat ditemukan di mana saja</a></li>
<li><a href="../id490780/index.html">Intel Xeon Scalable Gen2: Penjualan Besar Core</a></li>
<li><a href="../id490782/index.html">AnalogBytes Conference: Roskomnadzor, media, highload, dan semuanya</a></li>
<li><a href="../id490784/index.html">Saya seorang pengembang Android dan saya tidak ingin melakukan pekerjaan manual.</a></li>
<li><a href="../id490786/index.html">Analisis kebocoran urutan kedua: ketika bocor dari mereka yang mencuri data dari bank</a></li>
<li><a href="../id490790/index.html">File Zip: Sejarah, Penjelasan, dan Implementasi</a></li>
<li><a href="../id490792/index.html">VXLAN dalam NSX-V - Underlay Bermasalah</a></li>
<li><a href="../id490796/index.html">Cara mengotomatiskan keamanan wadah dengan gaya Kebijakan sebagai Kode menggunakan CRD</a></li>
<li><a href="../id490804/index.html">Bagaimana ibu seorang peretas masuk penjara dan menginfeksi komputer bos</a></li>
<li><a href="../id490808/index.html">Matematika dalam astronotika: mesin peledakan rotasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>