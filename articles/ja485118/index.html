<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏽 🧙🏽 💞 ロバートマーティンによる「クリーンコード」。概要。明確で美しいコードを書くには？ 🤧 👨🏻‍🎨 🕑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私は誰もが知っている本の大要を書くことにしました、そして著者はそれを「純粋なコード教師の学校」と呼んでいます。マーティンの視線は言うとおり
 
 です。クリーンなコードの原則に再び従わないのですか？」
 
 
 
 第1章クリーンなコード 
 簡潔に言うと、この最もクリーンなMartinバージョンの...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ロバートマーティンによる「クリーンコード」。概要。明確で美しいコードを書くには？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485118/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は誰もが知っている本の大要を書くことにしました、そして著者はそれを「純粋なコード教師の学校」と呼んでいます。</font><font style="vertical-align: inherit;">マーティンの視線は言うとおり</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
です。</font><font style="vertical-align: inherit;">クリーンなコードの原則に再び従わないのですか？」</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ef/iy/gk/efiygknwshp6q_5wtna1q_dewti.jpeg" alt="画像"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第1章クリーンなコード </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡潔に言うと、この最もクリーンなMartinバージョンのコードは何ですか？</font><font style="vertical-align: inherit;">これは重複のないコードで、エンティティの数は最小限で、読みやすく、シンプルです。</font><font style="vertical-align: inherit;">モットーとして、「明快さは何よりも重要です！」を選択できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第2章意味のある名前</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前はプログラマーの意図を伝える必要があります</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数、関数、またはクラスの名前は、この変数が存在する理由、その機能、およびその使用方法を示す必要があります。</font><font style="vertical-align: inherit;">名前に追加のコメントが必要な場合は、プログラマの意図を伝えません。</font><font style="vertical-align: inherit;">正確に何が測定され、どの単位で書かれるのが良いでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
適切な変数名の例：daysSinceCreation; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目的：非自明性を取り除く。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誤報を避ける</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
意図した以外の意味が隠されている単語は使用しないでください。</font><font style="vertical-align: inherit;">名前の微妙な違いに注意してください。</font><font style="vertical-align: inherit;">たとえば、XYZControllerForEfficientHandlingOfStringsやXYZControllerForEfficientStorageOfStringsなどです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数名、特に組み合わせで小文字の「L」と大文字の「O」を使用すると、誤解を招く名前の本当に恐ろしい例が見つかります。</font><font style="vertical-align: inherit;">当然、これらの文字がそれぞれ定数「1」および「0」とほとんど変わらないという事実により問題が発生します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意味のある違いを使う</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前が異なる場合、それらは異なる概念を意味するはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（a1、a2、... aN）という形式の「数値シリーズ」は、意識的なネーミングの反対です。</font><font style="vertical-align: inherit;">彼らは情報を伝えておらず、著者の意図についての考えを提供していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
意味のない単語は冗長です。</font><font style="vertical-align: inherit;">変数という単語は、変数名に使用しないでください。</font><font style="vertical-align: inherit;">テーブルという単語は、テーブル名に使用しないでください。</font><font style="vertical-align: inherit;">NameStringがNameより優れているのはなぜですか？</font><font style="vertical-align: inherit;">名前は、たとえば実数にすることができますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スペル名を使用する：generationTimestampはgenymdhmsよりもはるかに優れています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検索可能な名前を選択してください </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1文字の名前は、短いメソッドのローカル変数にのみ使用できます。 </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前のコード体系を避ける</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、コード化された名前は発音が不十分であり、タイプミスを簡単に作成できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェースと実装</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私（本の著者）は、インターフェース名をプレフィックスなしで残すことを好みます。</font><font style="vertical-align: inherit;">接頭辞Iは、古いコードでは非常に一般的であり、せいぜい気を散らし、最悪の場合、不必要な情報を伝えます。</font><font style="vertical-align: inherit;">ユーザーにインターフェースを扱っていることをユーザーに伝えるつもりはありません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス名</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラス名とオブジェクト名は名詞とその組み合わせである必要があります：Customer、WikiPage、Account、AddressParser。</font><font style="vertical-align: inherit;">クラス名にManager、Processor、Data、Infoなどの単語を使用しないでください。</font><font style="vertical-align: inherit;">クラス名は動詞であってはなりません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド名</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド名は動詞または動詞句です：postPayment、deletePage、saveなど。読み取り/書き込みメソッドと述語は、値と接頭辞get、setから形成され、Javabean標準に準拠しています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">駄洒落を控える</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
著者の仕事は、彼のコードをできるだけ明確にすることです。</font><font style="vertical-align: inherit;">コードは、注意深く調査することなく、一目でわかるはずです。</font><font style="vertical-align: inherit;">著者自身が自由に自分の考えを表現しなければならない人気文学のモデルに焦点を当てます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意味のあるコンテキストを追加します。</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレフィックスを使用してコンテキストを追加できます：addrFirstName、addrLastName、addrStateなど。少なくともコードリーダーは、変数がより大きな構造の一部であることを理解します。</font><font style="vertical-align: inherit;">もちろん、Addressと呼ばれるクラスを作成する方がより正しいので、コンパイラーでさえ変数が何かの一部であることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あいまいなコンテキストの変数：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printGuessStatistics</span><span class="hljs-params">(<span class="hljs-keyword">char</span> candidate, <span class="hljs-keyword">int</span> count)</span> </span>{<font></font>
    String number;<font></font>
    String verb;<font></font>
    String pluralModifier;<font></font>
    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) {<font></font>
      number = <span class="hljs-string">"no"</span>;<font></font>
      verb = <span class="hljs-string">"are"</span>;<font></font>
      pluralModifier = <span class="hljs-string">"s"</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) {<font></font>
      number = ~_~quotquot~_~;<font></font>
      verb = <span class="hljs-string">"is"</span>;<font></font>
      pluralModifier = <span class="hljs-string">""</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      number = Integer.toString(count);<font></font>
      verb = <span class="hljs-string">"are"</span>;<font></font>
      pluralModifier = <span class="hljs-string">"s"</span>;<font></font>
    }<font></font>
    String guessMessage = String.format(<font></font>
      <span class="hljs-string">"There %s %s %s%s"</span>, verb, number, candidate, pluralModifier<font></font>
    );<font></font>
    print(guessMessage);<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は少し長く、変数は全体を通して使用されます。</font><font style="vertical-align: inherit;">関数を小さなセマンティックフラグメントに分割するには、GuessStatisticsMessageクラスを作成し、3つの変数をこのクラスのフィールドにする必要があります。</font><font style="vertical-align: inherit;">このようにして、3つの変数の明白なコンテキストを提供します。これらの変数がGuessStatisticsMessageの一部であることは、今や明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテキストを持つ変数：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuessStatisticsMessage</span> </span>{
  <span class="hljs-keyword">private</span> String number;
  <span class="hljs-keyword">private</span> String verb;
  <span class="hljs-keyword">private</span> String pluralModifier;
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">make</span><span class="hljs-params">(<span class="hljs-keyword">char</span> candidate, <span class="hljs-keyword">int</span> count)</span> </span>{<font></font>
    createPluralDependentMessageParts(count);<font></font>
    <span class="hljs-keyword">return</span> String.format(
      <span class="hljs-string">"There %s %s %s%s"</span>, <font></font>
       verb, number, candidate, pluralModifier );<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createPluralDependentMessageParts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>{
    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) {<font></font>
      thereAreNoLetters();<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) {<font></font>
      thereIsOneLetter();<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      thereAreManyLetters(count);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thereAreManyLetters</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>{<font></font>
    number = Integer.toString(count);<font></font>
    verb = <span class="hljs-string">"are"</span>;<font></font>
    pluralModifier = <span class="hljs-string">"s"</span>;<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thereIsOneLetter</span><span class="hljs-params">()</span> </span>{<font></font>
    number = ~_~quotquot~_~;<font></font>
    verb = <span class="hljs-string">"is"</span>;<font></font>
    pluralModifier = <span class="hljs-string">""</span>;<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thereAreNoLetters</span><span class="hljs-params">()</span> </span>{<font></font>
    number = <span class="hljs-string">"no"</span>;<font></font>
    verb = <span class="hljs-string">"are"</span>;<font></font>
    pluralModifier = <span class="hljs-string">"s"</span>;<font></font>
  }<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">冗長なコンテキストを追加しないでください</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードリーダーにとって意味が明確である場合、通常、短い名前は長い名前よりも優れています。</font><font style="vertical-align: inherit;">名前に必要以上のコンテキストを含めないでください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3章関数</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパクト！</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のルール：関数はコンパクトでなければなりません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のルール：関数はさらにコンパクトにする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の実践的な経験から、（多くの試行錯誤を犠牲にして）関数は非常に小さくなければならないことがわかりました。</font><font style="vertical-align: inherit;">関数の長さは20行を超えないことが望ましい。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの操作のルール</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は1つの操作のみを実行する必要があります。</font><font style="vertical-align: inherit;">彼女はそれをうまく実行しなければならない。</font><font style="vertical-align: inherit;">そして彼女は他に何もすべきではありません。</font><font style="vertical-align: inherit;">関数が宣言された関数名の下で同じレベルにあるアクションのみを実行する場合、この関数は1つの操作を実行します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能セクション</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つの操作のみを実行する関数は、セクションに有意義に分割できません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数ごとに1レベルの抽象化</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数が「1つの操作のみ」を実行することを確認するには、関数のすべてのコマンドが同じ抽象化レベルにあることを確認する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数内で抽象化のレベルを混在させると、常に混乱が生じます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上から下へのコードの読み取り：ダウングレードルール</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードはストーリーのように上から下に読む必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各関数の後には、次のレベルの抽象化の関数が続きます。</font><font style="vertical-align: inherit;">これにより、コードを読み取ることができ、関数のリストを読みながら、抽象化のレベルを順に下っていきます。</font><font style="vertical-align: inherit;">このアプローチを「ダウングレードルール」と呼びます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スイッチコマンド</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパクトスイッチコマンドの記述は非常に困難です。 2つの条件のみを含むswitchコマンドでも、1つのブロックまたは関数が私のビューで占有する必要があるよりも多くのスペースを使用します。また、1つのことを実行するスイッチコマンドを作成することも困難です。本質的に、スイッチコマンドは常にN回の操作を実行します。残念ながら、コマンドの切り替えは常に可能であるとは限りませんが、少なくともこれらのコマンドが低レベルのクラスに隠されており、コード内で重複していないことを確認できます。そしてもちろん、ポリモーフィズムはこれに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、従業員のタイプに応じて、1つの操作のみを示しています。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Money <span class="hljs-title">calculatePay</span><span class="hljs-params">(Employee e)</span> 
<span class="hljs-keyword">throws</span> InvalidEmployeeType </span>{
    <span class="hljs-keyword">switch</span> (e.type) {
      <span class="hljs-keyword">case</span> COMMISSIONED:
        <span class="hljs-keyword">return</span> calculateCommissionedPay(e);
      <span class="hljs-keyword">case</span> HOURLY:
        <span class="hljs-keyword">return</span> calculateHourlyPay(e);
      <span class="hljs-keyword">case</span> SALARIED:
        <span class="hljs-keyword">return</span> calculateSalariedPay(e);
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidEmployeeType(e.type);<font></font>
    }<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機能にはいくつかの欠点があります。第一に、それは素晴らしいです、そして、新しいタイプの労働者の追加で、それは成長します。第二に、それは明らかに複数の操作を実行します。第3に、変更にはいくつかの理由が考えられるため、単一責任の原則に違反しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第4に、新しい型が追加されるたびに関数コードを変更する必要があるため、Open Closed Principleに違反します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、おそらく最も深刻な欠点は、プログラムは、たとえば、類似した構造を持つ他の機能を無制限に含めることができるということです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
isPayday（従業員E、日付の日付）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
deliverPay（従業員E、マネー有料）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ようにと。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの関数はすべて同じ欠陥のある構造になります。</font><font style="vertical-align: inherit;">この問題の解決策は、switchコマンドを抽象ファクトリーの基礎に埋め込み、誰にも見せないことです。</font><font style="vertical-align: inherit;">ファクトリーは、switchコマンドを使用してEmployeeの子孫の適切なインスタンスを作成し、関数calculatePay、isPayDay、deliverPayなどを呼び出して、ポリモーフィック転送をEmployeeインターフェースに渡します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPayday</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Money <span class="hljs-title">calculatePay</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deliverPay</span><span class="hljs-params">(Money pay)</span></span>;<font></font>
}<font></font>
-----------------<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EmployeeFactory</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> Employee <span class="hljs-title">makeEmployee</span><span class="hljs-params">(EmployeeRecord r)</span> <span class="hljs-keyword">throws</span> InvalidEmployeeType</span>;<font></font>
}<font></font>
-----------------<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeFactoryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EmployeeFactory</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> Employee <span class="hljs-title">makeEmployee</span><span class="hljs-params">(EmployeeRecord r)</span> <span class="hljs-keyword">throws</span> InvalidEmployeeType </span>{
    <span class="hljs-keyword">switch</span> (r.type) {
      <span class="hljs-keyword">case</span> COMMISSIONED:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommissionedEmployee(r) ;
      <span class="hljs-keyword">case</span> HOURLY:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HourlyEmployee(r);
      <span class="hljs-keyword">case</span> SALARIED:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SalariedEmploye(r);
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidEmployeeType(r.type);<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スイッチコマンドに関する私の一般的なルールは、これらのコマンドがプログラム内で1回発生した場合に有効であり、ポリモーフィックオブジェクトの作成に使用され、継承関係の背後に隠れて、システムの他の部分から見えないようにすることです。</font><font style="vertical-align: inherit;">もちろん、例外のないルールはなく、状況によっては、このルールの1つ以上の条件に違反する必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意味のある名前を使用する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この原則を実装するための努力の半分は、単一の操作を実行するコンパクト関数に適切な名前を選択することに帰着します。</font><font style="vertical-align: inherit;">関数が小さく、より専門的であるほど、意味のある名前を選択するのが簡単になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長い名前を使用することを恐れないでください。長い意味のある名前は、短いあいまいな名前よりも優れています。</font><font style="vertical-align: inherit;">関数名の単語が読みやすいスキームを選択し、これらの単語から関数の目的を説明する名前を作成します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の引数</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的なケースでは、関数の引数の数はゼロです。</font><font style="vertical-align: inherit;">以下は、1つの引数（単項）と2つの引数（二項）を持つ関数です。</font><font style="vertical-align: inherit;">3つの引数（3項）を持つ関数は、可能な限り避けてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力引数は、入力よりも速く状況を混乱させます。</font><font style="vertical-align: inherit;">通常、関数が引数で情報を返すことを期待する人は誰もいません。</font><font style="vertical-align: inherit;">引数なしでは対処できない場合は、少なくとも1つの入力引数に制限するようにしてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
戻り値の代わりに出力引数を使用する変換は、リーダーを混乱させます。</font><font style="vertical-align: inherit;">関数が入力引数を変換する場合、結果</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
は戻り値で渡される必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグの引数</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引数引数は醜いです。</font><font style="vertical-align: inherit;">関数の論理的な意味を渡すことは本当にひどい習慣です。</font><font style="vertical-align: inherit;">これはメソッドのシグネチャをすぐに複雑にし、関数が複数の操作を実行することを大声で宣言します。</font><font style="vertical-align: inherit;">フラグがtrueの場合、1つの操作が実行され、falseの場合、別の操作が実行されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリ関数</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの引数を持つ関数は、単項関数よりも理解が困難です。</font><font style="vertical-align: inherit;">もちろん、いくつかの状況では、2つの引数を持つフォームが適切です。</font><font style="vertical-align: inherit;">たとえば、Point p = new Point（0,0）;を呼び出します。</font><font style="vertical-align: inherit;">絶対に合理的です。</font><font style="vertical-align: inherit;">ただし、この場合の2つの引数は、同じ値の順序付けられたコンポーネントです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数としてのオブジェクト</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数が2つまたは3つ以上の引数を受け取る必要がある場合、これらの引数の一部を別のクラスにパッケージ化する必要がある可能性が高くなります。</font><font style="vertical-align: inherit;">次の2つの宣言を検討してください。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">Circle <span class="hljs-title">makeCircle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y, <span class="hljs-keyword">double</span> radius)</span></span>;
<span class="hljs-function">Circle <span class="hljs-title">makeCircle</span><span class="hljs-params">(Point center, <span class="hljs-keyword">double</span> radius)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数が全体として一緒に転送される場合（この例のx変数とy変数のように）、おそらく一緒になって、それら自体の名前に値する概念を形成します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動詞とキーワード</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の適切な名前を選択することで、関数の意味、および引数の順序と意味を大きく説明できます。</font><font style="vertical-align: inherit;">単項関数では、関数自体とその引数が自然な動詞/名詞のペアを形成する必要があります。</font><font style="vertical-align: inherit;">たとえば、write（name）という形式の呼び出しは非常に有益に見えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読者は、「名前」が何であっても、どこかに「書かれた」ことを理解しています。</font><font style="vertical-align: inherit;">さらに良いのは、「名前」が何らかの構造の「フィールド」に書き込まれたことを報告するwriteField（name）レコードです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のエントリは、関数名でのキーワードの使用例です。</font><font style="vertical-align: inherit;">この形式では、引数名は関数名にエンコードされます。</font><font style="vertical-align: inherit;">たとえば、assertEqualsはassertExpectedEqualsActual（expected、actual）として記述できます。</font><font style="vertical-align: inherit;">これにより、引数の順序を記憶する問題が大幅に解決されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンドとリクエストの分離</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は何かをするか、いくつかの質問に答える必要がありますが、同時にはできません。</font><font style="vertical-align: inherit;">関数はオブジェクトの状態を変更するか、このオブジェクトに関する情報を返します。</font><font style="vertical-align: inherit;">2つの操作を組み合わせると、混乱が生じることがよくあります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try / catchブロックを分離する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
try / catchブロックはかなり醜く見えます。</font><font style="vertical-align: inherit;">それらはコードの構造を混同し、エラー処理を通常の処理と混合します。</font><font style="vertical-align: inherit;">このため、tryブロックとcatchブロックの本体を別々の関数に分離することをお勧めします。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの操作としてのエラー処理</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は1つの操作を実行する必要があります。</font><font style="vertical-align: inherit;">エラー処理は1つの操作です。</font><font style="vertical-align: inherit;">つまり、エラーを処理する関数は他に何もすべきではありません。</font><font style="vertical-align: inherit;">したがって、関数にtryキーワードが存在する場合、それは関数の最初の単語でなければならず、catch / finallyブロックの後には何もないはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで第3章は終了です。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja485100/index.html">行く場所：モスクワの開発者向けの次の無料イベント（1月30日-2月15日）</a></li>
<li><a href="../ja485102/index.html">Topleaked：メモリリークキャッチツール</a></li>
<li><a href="../ja485104/index.html">インターホン用のユニバーサルRFIDキーの作成</a></li>
<li><a href="../ja485108/index.html">2020年1月10日のロシアのPMI認定スペシャリストの統計</a></li>
<li><a href="../ja485110/index.html">効果的なリモート作業の私の経験</a></li>
<li><a href="../ja485120/index.html">非常に高速なJSON APIをアプリケーションに追加します。</a></li>
<li><a href="../ja485122/index.html">「あなたのための記事を読む」という見出し。2019年10月〜12月</a></li>
<li><a href="../ja485124/index.html">PHPとPHPUnitでの純粋なテスト</a></li>
<li><a href="../ja485126/index.html">Mu-mu、woof-woof、quack-quack：音響通信の進化</a></li>
<li><a href="../ja485128/index.html">Mikrotik CHRライセンスを節約</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>