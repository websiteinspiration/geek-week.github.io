<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☂️ 👩🏾‍🌾 🏇🏾 LLVM IR and Go 🤴🏼 🤱🏾 👩🏾‍🤝‍👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、LLVM IRアセンブリ言語を使用してLLVMコンパイルフレームワークとやり取りするコンパイラーや静的アナライザーなどのGoプログラムを構築する方法について説明します。
 
 TL; DRは、純粋なGoでLLVM IRを操作するためのライブラリを作成しました。コードへのリンクとサンプル...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>LLVM IR and Go</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459704/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事では、LLVM IRアセンブリ言語を使用してLLVMコンパイルフレームワークとやり取りするコンパイラーや静的アナライザーなどのGoプログラムを構築する方法について説明します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TL; DR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、純粋なGoでLLVM IRを操作するためのライブラリを作成しました。コードへのリンクとサンプルプロジェクトを参照してください。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM IRの簡単な例</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（LLVM IRに詳しい方は、次のセクションにスキップできます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVM IRは、LLVMコンパイルフレームワークで使用される低レベルの中間表現です。</font><font style="vertical-align: inherit;">LLVM IRは、無数のローカルレジスタを持つプラットフォームに依存しないアセンブラと考えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーを設計する場合、ソース言語をターゲットアーキテクチャ（x86など）にコンパイルするのではなく、中間表現（IR、中間表現）にコンパイルすることには大きな利点があります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネタバレ</font></font></b><div class="spoiler_text">        . GCC  GIMPLE, Roslyn  CIL, LLVM  LLVM IR.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの最適化手法が一般的であるため（たとえば、未使用のコードの削除、定数の配布）、これらの最適化パスはIRレベルで直接実行でき、すべてのターゲットプラットフォームで使用できます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネタバレ</font></font></b><div class="spoiler_text">   (IR),  ,   ,   n    m   ()  n * m  n + m.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、コンパイラは、フロントエンド、ミドルランド、バックエンドの3つの部分で構成されることが多く、それぞれが独自のタスクを実行し、入力を受け入れたり、IR出力を提供したりします。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロントエンド：ソース言語をIRでコンパイルします</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ミドルランド：IRを最適化</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックエンド：IRをマシンコードにコンパイルします</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/i_/pc/q6/i_pcq6eyhimm7drjixdnwrkog60.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM IRサンプルアセンブリプログラム</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVM IRアセンブラがどのように見えるかを理解するために、次のプログラムを検討してください。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + <span class="hljs-number">2</span>*b;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> f(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Clangを使用して、上記のCコードをLLVM IRアセンブラーにコンパイルします。 </font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラン</font></font></b><div class="spoiler_text">clang -S -emit-llvm -o foo.ll foo.c. <br>
</div></div><br>
<pre><code class="cpp hljs">define i32 @f(i32 %a, i32 %b) {<font></font>
; &lt;label&gt;:<span class="hljs-number">0</span>
    %<span class="hljs-number">1</span> = mul i32 <span class="hljs-number">2</span>, %b<font></font>
    %<span class="hljs-number">2</span> = add i32 %a, %<span class="hljs-number">1</span>
    ret i32 %<span class="hljs-number">2</span><font></font>
}<font></font>
<font></font>
define i32 @main() {<font></font>
; &lt;label&gt;:<span class="hljs-number">0</span>
    %<span class="hljs-number">1</span> = call i32 @f(i32 <span class="hljs-number">10</span>, i32 <span class="hljs-number">20</span>)<font></font>
    ret i32 %<span class="hljs-number">1</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のLLVM IRアセンブラーコードを見ると、LLVM IRのいくつかの注目すべき機能に気づくことができます。つまり、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVM IRは静的に型指定されています（つまり、32ビット整数はi32型によって分割されます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ローカル変数は関数内にスコープがあります（つまり、関数内の％1</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メイン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数@fの％1とは異なります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前のない（一時的なレジスタ）は、関数ごとに昇順でローカル識別子（たとえば、％1、％2）を受け取ります。</font><font style="vertical-align: inherit;">各関数は、無限の数のレジスターを使用できます（32個の汎用レジスターに限定されません）。</font><font style="vertical-align: inherit;">グローバル識別子（@fなど）とローカル識別子（％a、％1など）は、接頭辞（@と％）で区別されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのコマンドは期待通りの動作をするので、mulは乗算や加算などを行います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コメントは、アセンブリ言語の慣習に従って、で始まります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLMV IRアセンブラーの構造</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVM IRアセンブリファイルの内容はモジュールです。</font><font style="vertical-align: inherit;">モジュールには、グローバル変数や関数などの高レベルの宣言が含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数宣言には基本ブロックが含まれていません。関数定義には1つ以上の基本ブロック（つまり、関数本体）が含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVM IRモジュールのより詳細な例を以下に示します。</font><font style="vertical-align: inherit;">グローバル変数@fooの定義と3つの基本ブロック（％エントリー、％block_1および％block_2）を含む@f関数の定義を含みます。</font></font><br>
<br>
<pre><code class="cpp hljs">;  ,  <span class="hljs-number">32</span>-  <span class="hljs-number">21</span>
@foo = global i32 <span class="hljs-number">21</span><font></font>
<font></font>
; f  <span class="hljs-number">42</span>,   cond ,  <span class="hljs-number">0</span>   <font></font>
define i32 @f(i1 %cond) {<font></font>
;       ,    <font></font>
;     <font></font>
entry:<font></font>
    ;     br    block_1,  %cond<font></font>
    ; ,   block_2   .<font></font>
    br i1 %cond, label %block_1, label %block_2<font></font>
<font></font>
;     ,    ,    <font></font>
block_1:<font></font>
    %tmp = load i32, i32* @foo<font></font>
    %result = mul i32 %tmp, <span class="hljs-number">2</span><font></font>
    ret i32 %result<font></font>
<font></font>
;     ,     ,    <font></font>
block_2:<font></font>
    ret i32 <span class="hljs-number">0</span>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本単位</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本単位は、遷移コマンド（終了コマンド）ではない一連のコマンドです。</font><font style="vertical-align: inherit;">ベースユニットの重要な考え方は、ベースユニットの1つのコマンドが実行されると、ベースユニットの他のすべてのコマンドが実行されるということです。</font><font style="vertical-align: inherit;">これにより、実行フローの分析が簡単になります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チーム</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジャンプコマンドではないコマンドは、通常、計算やメモリアクセス（たとえば、追加、ロード）を実行しますが、プログラムの制御フローは変更しません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">終了チーム</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
終了コマンドは、各ベースユニットの最後にあり、ベースユニットの最後でどこに移行するかを決定します。</font><font style="vertical-align: inherit;">たとえば、終了するretコマンドは呼び出し側関数の制御フローを返し、brは条件付きまたは無条件の遷移を実行します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSAフォーム</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVM IRの非常に重要な特性の1つは、SSA形式（静的単一割り当て）で書き込まれることです。これは、各レジスターが一度だけ割り当てられることを本質的に意味します。このプロパティは、データストリームの静的分析を簡素化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元のソースコードで複数回割り当てられた変数を処理するには、LLVM IRでphiコマンドを使用します。 phiコマンドは、コマンドが到達したパスに応じて、基本的に一連の入力値から単一の値を返します。したがって、各入力値は先行する入力ブロックに関連付けられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、次のLLVM IR関数を考えます。</font></font><br>
<br>
<pre><code class="cpp hljs">define i32 @f(i32 %a) {<font></font>
; &lt;label&gt;:<span class="hljs-number">0</span>
    <span class="hljs-keyword">switch</span> i32 %a, label %<span class="hljs-keyword">default</span> [<font></font>
        i32 <span class="hljs-number">42</span>, label %case1<font></font>
    ]<font></font>
<font></font>
case1:<font></font>
    %x<span class="hljs-number">.1</span> = mul i32 %a, <span class="hljs-number">2</span><font></font>
    br label %ret<font></font>
<font></font>
<span class="hljs-keyword">default</span>:<font></font>
    %x<span class="hljs-number">.2</span> = mul i32 %a, <span class="hljs-number">3</span><font></font>
    br label %ret<font></font>
<font></font>
ret:<font></font>
    %x<span class="hljs-number">.0</span> = phi i32 [ %x<span class="hljs-number">.2</span>, %<span class="hljs-keyword">default</span> ], [ %x<span class="hljs-number">.1</span>, %case1 ]<font></font>
    ret i32 %x<span class="hljs-number">.0</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例のphiコマンド（phiノードとも呼ばれる）は、実行スレッドの可能なパスごとに1つずつ、可能な入力値のセットを使用してさまざまな割り当てをシミュレートし、変数の割り当てにつながっています。たとえば、データストリーム内の対応するパスの1つは次のとおりです</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ng/zd/h3/ngzdh3seqkmiww9rsn9as7czeg4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。一般に、ソースコードをLLVM IRに変換するコンパイラが開発されると、アドレスが取得される変数を除いて、すべてのローカルソースコード変数をSSA形式に変換できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVMフロントエンドの実装を簡略化するために、ソース言語のローカル変数をメモリに割り当てられた変数として（allocaを使用して）モデル化し、ローカル変数への割り当てをメモリへの書き込みとしてシミュレートし、ローカル変数をメモリからの読み取りとして使用することをお勧めします。</font><font style="vertical-align: inherit;">その理由は、ソース言語をSSA形式のLLVM IRに直接翻訳するのは簡単な作業ではないからです。</font><font style="vertical-align: inherit;">メモリアクセスが特定のパターンに従う限り、LLVMの一部としてmem2reg最適化パスを利用して、メモリに割り当てられたローカル変数をSSA形式のレジスタに変換できます（必要に応じてphiノードを使用します）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">純粋なGo上のLLVM IRライブラリ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GoでLLVM IRを操作するための2つのメインライブラリがあり</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：//godoc.org/llvm.org/llvm/bindings/go/llvm：Go言語用の公式LLVMバインディング。</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/llir/llvm：LLVM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IRと対話するためのクリーンなGoライブラリ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go言語の公式LLVMバインディングはCgoを使用してLLVMコンパイラフレームワークの豊富で強力なAPIへのアクセスを提供しますが、llir / llvmプロジェクトは完全にGoで記述され、LLVM IRを使用してLLVMフレームワークと対話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事ではllir / llvmに焦点を当てていますが、他のライブラリと連携するように一般化することもできます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜ新しいライブラリを書くのですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVM IRとやり取りするためのクリーンなGoライブラリを開発する主な動機は、LLVM IRコンパイルフレームワークに基づくコンパイラーと静的分析ツールを作成することを、もっと楽しいタスクにすることでした。</font><font style="vertical-align: inherit;">また、Goとの公式のLLVMバインディングに基づくプロジェクトのコンパイル時間は非常に長くなる可能性があるという事実にも影響を受けました（TinyGoの作者である@aykevlのおかげで、LLVM 4の標準バージョンとは対照的に、動的リンクによりコンパイルを高速化できます）。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネタバレ</font></font></b><div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">github.com/aykevl/go-llvm</a>   Go     LLVM.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの大きな動機は、Go APIをゼロから開発することでした。 Goとllir / llvmのLLVMバインディングAPIの主な違いは、LLVM値のモデル化方法です。 GoのLLVMバインダーでは、LLVM値は具体的な構造タイプとしてモデル化され、本質的に、すべての可能なLLVM値に対して可能なすべてのメソッドが含まれています。このAPIを使用した私の個人的な経験では、特定の値を呼び出すことが許可されているメソッドのサブセットを知るのは難しいことが示唆されています。たとえば、命令のオペコードを取得するには、InstructionOpcodeメソッドを呼び出します。これは直感的です。ただし、代わりに定数式のオペコードを取得するように設計されているOpcodeメソッドを呼び出すと、ランタイムエラーが発生します：「互換性のない型のキャスト（）引数！」 （引数の互換性のない型への変換）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
llir / llvmライブラリは、コンパイル時に型をチェックし、Go型システムで正しく使用されるようにするために設計されました。</font><font style="vertical-align: inherit;">llir / llvmのLLVM値は、インターフェースタイプとしてモデル化されます。</font><font style="vertical-align: inherit;">このアプローチでは、最小限のメソッドセットのみが使用可能になり、すべての値で共有されます。特定のメソッドまたはフィールドにアクセスする場合は、タイプの切り替えを使用します（以下の例を参照）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用例</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、特定の使用例をいくつか見てみましょう。ライブラリを用意しましょうが、LLVM IRで何をすべきでしょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、ClangやオプティマイザLLVM optなどの別のツールによって生成されたLLVM IRを解析したい場合があります（以下のサンプル入力を参照）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、LLVM IRを処理して独自の分析を実行するか、独自の最適化パスを作成するか、インタープリターまたはJITコンパイラーを実装します（以下の分析例を参照）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目に、LLVM IRを生成したい場合があります。これは他の機器への入力になります。このアプローチは、新しいプログラミング言語のフロントエンドを開発している場合に選択できます（以下のサンプル出力コードを参照）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプル入力コード-LLVM IR解析</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//       LLVM IR,   </span>
<span class="hljs-comment">//    </span>
<span class="hljs-function">package main

<span class="hljs-title">import</span> <span class="hljs-params">(
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"github.com/llir/llvm/asm"</span>
)</span>

func <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">//    LLVM IR.</span>
    m, err := <span class="hljs-keyword">asm</span>.ParseFile(<span class="hljs-string">"foo.ll"</span>)
    <span class="hljs-keyword">if</span> err != nil {<font></font>
        panic(err)<font></font>
    }<font></font>
    <span class="hljs-comment">// ,    LLVM IR.</span><font></font>
<font></font>
    <span class="hljs-comment">// Print LLVM IR module.</span><font></font>
    fmt.Println(m)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分析例-LLVM IRの処理</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//      LLVM IR    </span>
<span class="hljs-comment">//  Graphviz DOT</span>
<span class="hljs-function">package main

<span class="hljs-title">import</span> <span class="hljs-params">(
    <span class="hljs-string">"bytes"</span>
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"io/ioutil"</span>
    <span class="hljs-string">"github.com/llir/llvm/asm"</span>
    <span class="hljs-string">"github.com/llir/llvm/ir"</span>
)</span>

func <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">//    LLVM IR.</span>
    m, err := <span class="hljs-keyword">asm</span>.ParseFile(<span class="hljs-string">"foo.ll"</span>)
    <span class="hljs-keyword">if</span> err != nil {<font></font>
        panic(err)<font></font>
    }<font></font>
    <span class="hljs-comment">//    .</span><font></font>
    callgraph := genCallgraph(m)<font></font>
    <span class="hljs-comment">//      Graphviz DOT.</span>
    <span class="hljs-keyword">if</span> err := ioutil.WriteFile(<span class="hljs-string">"callgraph.dot"</span>, callgraph, <span class="hljs-number">0644</span>); err != nil {<font></font>
        panic(err)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// genCallgraph      Graphviz DOT    LLVM IR</span><font></font>
func genCallgraph(m *ir.Module) []byte {<font></font>
    buf := &amp;bytes.Buffer{}<font></font>
    buf.WriteString(<span class="hljs-string">"digraph {\n"</span>)
    <span class="hljs-comment">//      </span>
    <span class="hljs-keyword">for</span> _, f := range m.Funcs {
        <span class="hljs-comment">//  </span><font></font>
        caller := f.Ident()<font></font>
        fmt.Fprintf(buf, <span class="hljs-string">"\t%q\n"</span>, caller)
        <span class="hljs-comment">//      </span>
        <span class="hljs-keyword">for</span> _, block := range f.Blocks {
            <span class="hljs-comment">//   ,       .</span>
            <span class="hljs-keyword">for</span> _, inst := range block.Insts {
                <span class="hljs-comment">//  .   call.</span>
                <span class="hljs-keyword">switch</span> inst := inst.(type) {
                <span class="hljs-keyword">case</span> *ir.InstCall:<font></font>
                    callee := inst.Callee.Ident()<font></font>
                    <span class="hljs-comment">//        .</span>
                    fmt.Fprintf(buf, <span class="hljs-string">"\t%q -&gt; %q\n"</span>, caller, callee)<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-comment">//    </span>
            <span class="hljs-keyword">switch</span> term := block.Term.(type) {
            <span class="hljs-keyword">case</span> *ir.TermRet:
                <span class="hljs-comment">//  -</span><font></font>
                _ = term<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    buf.WriteString(<span class="hljs-string">"}"</span>)
    <span class="hljs-keyword">return</span> buf.Bytes()<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプル出力コード-LLVM IR生成</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//     LLVM IR,    C, </span>
<span class="hljs-comment">//    .</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//    int abs(int x);</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//    int seed = 0;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//    // ref: https://en.wikipedia.org/wiki/Linear_congruential_generator</span>
<span class="hljs-comment">//    //    a = 0x15A4E35</span>
<span class="hljs-comment">//    //    c = 1</span>
<span class="hljs-comment">//    int rand(void) {</span>
<span class="hljs-comment">//       seed = seed*0x15A4E35 + 1;</span>
<span class="hljs-comment">//       return abs(seed);</span>
<span class="hljs-comment">//    }</span>
<span class="hljs-function">package main

<span class="hljs-title">import</span> <span class="hljs-params">(
    <span class="hljs-string">"fmt"</span>

    <span class="hljs-string">"github.com/llir/llvm/ir"</span>
    <span class="hljs-string">"github.com/llir/llvm/ir/constant"</span>
    <span class="hljs-string">"github.com/llir/llvm/ir/types"</span>
)</span>

func <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">//     </span><font></font>
    i32 := types.I32<font></font>
    zero := constant.NewInt(i32, <span class="hljs-number">0</span>)<font></font>
    a := constant.NewInt(i32, <span class="hljs-number">0x15A4E35</span>) <span class="hljs-comment">//  PRNG.</span>
    c := constant.NewInt(i32, <span class="hljs-number">1</span>)         <span class="hljs-comment">//  PRNG.</span><font></font>
<font></font>
    <span class="hljs-comment">//    LLVM IR.</span><font></font>
    m := ir.NewModule()<font></font>
<font></font>
    <span class="hljs-comment">//         .</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">//    int abs(int x);</span>
    <span class="hljs-built_in">abs</span> := m.NewFunc(<span class="hljs-string">"abs"</span>, i32, ir.NewParam(<span class="hljs-string">"x"</span>, i32))<font></font>
<font></font>
    <span class="hljs-comment">//         .</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">//    int seed = 0;</span>
    seed := m.NewGlobalDef(<span class="hljs-string">"seed"</span>, zero)<font></font>
<font></font>
    <span class="hljs-comment">//        .</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">//    int rand(void) { ... }</span>
    rand := m.NewFunc(<span class="hljs-string">"rand"</span>, i32)<font></font>
<font></font>
    <span class="hljs-comment">//           `rand`.</span>
    entry := rand.NewBlock(<span class="hljs-string">""</span>)<font></font>
<font></font>
    <span class="hljs-comment">//         .</span><font></font>
    tmp1 := entry.NewLoad(seed)<font></font>
    tmp2 := entry.NewMul(tmp1, a)<font></font>
    tmp3 := entry.NewAdd(tmp2, c)<font></font>
    entry.NewStore(tmp3, seed)<font></font>
    tmp4 := entry.NewCall(<span class="hljs-built_in">abs</span>, tmp3)<font></font>
    entry.NewRet(tmp4)<font></font>
<font></font>
    <span class="hljs-comment">//   LLVM IR  .</span><font></font>
    fmt.Println(m)<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
llir / llvmの開発と実装は、コードを書いただけでなく、ディスカッション、ペアプログラミングセッション、デバッグ、プロファイリングを行い、学習プロセスに好奇心を示した貢献者のコミュニティによって実施され、主導されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
llir / llvmプロジェクトの最も難しい部分の1つは、LLVM IRのEBNF文法の構築であり、バージョンLLVM 7.0までのLLVM IR言語全体をカバーしていました。</font><font style="vertical-align: inherit;">ここでの難しさはプロセス自体にあるのではなく、言語全体をカバーする公式に公開された文法がないという事実にあります。</font><font style="vertical-align: inherit;">いくつかのオープンソースコミュニティは、LLVMアセンブラの正式な文法を定義しようとしましたが、私たちが知る限り、言語のサブセットのみをカバーしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文法LLVM IRは、興味深いプロジェクトへの道を開きます。</font><font style="vertical-align: inherit;">たとえば、構文的に有効なLLVM IRアセンブラの生成は、LLVM IRを使用するさまざまなツールやライブラリに使用できます。GoSmithでも同様のアプローチが使用されています。</font><font style="vertical-align: inherit;">これは、他の言語で実装されたLLVMプロジェクトの相互検証、および脆弱性と実装のバグのチェックに使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
未来は素晴らしい、幸せなハッキングです！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. </font><font style="vertical-align: inherit;">LLVMに関する</font><font style="vertical-align: inherit;">非常によく書かれた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。本の「オープンソースアプリケーションのアーキテクチャ」で、初期のLLVMプロジェクトの作者であるChris Lattnerによって書かれました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVMで言語を実装するチュートリアル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -万華鏡言語ガイドとも呼ばれます-は、LLVM IRでコンパイルされた簡単なプログラミング言語を実装する方法を詳しく説明しています。この記事では、字句アナライザー、パーサー、コード生成など、フロントエンドを作成するすべての主要な段階について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.入力言語からLLVM IRへのコンパイラーの作成に興味がある人には、「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高水準構成をLLVM IRにマッピングする</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」という本</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">お勧め</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
素敵なスライドセット</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-LLVM、詳細</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、重要なLLVM IRの概念を説明し、LLVM C ++ APIの概要を説明し、非常に便利なLLVM最適化の節を説明しています。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVMの公式Goバインディングは</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、多くのプロジェクトに適しています。強力で安定したLLVM C APIを表します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
投稿への良い追加は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、GoでのLLVMの紹介です。</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja459684/index.html">Android向けモスクワメトロと全世界の地図</a></li>
<li><a href="../ja459688/index.html">中国のアーバニズム：流行に敏感でない、科学とITが多い</a></li>
<li><a href="../ja459692/index.html">確立された化学的原理に反する材料変更をどのように発見したか</a></li>
<li><a href="../ja459694/index.html">ミュージアムデータアート。Radio 86RKを開梱して起動する</a></li>
<li><a href="../ja459698/index.html">プログラマーが必要とするだけのセッション変数をOracle BI 12cに強制させる方法は？</a></li>
<li><a href="../ja459706/index.html">ReactアプリケーションでReduxを忘れるべき5つの理由</a></li>
<li><a href="../ja459708/index.html">ゲームインターフェイスデザイン。ブレントフォックス この本は何についてですか？</a></li>
<li><a href="../ja459710/index.html">正面衝突を乗り越えて、なぜ健忘症があなたが考えているものではないのか</a></li>
<li><a href="../ja459712/index.html">公式の仕事での「ママのハッカー」：ペンテスターは何をしますか</a></li>
<li><a href="../ja459714/index.html">ゲームを実行するESP8266上の仮想マシン</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>