<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚘 🤭 ❄️ Schneller POSTGRESQL COUNT machen (*) 👐🏾 🙎🏾 👨‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es wird oft beanstandet, dass count (*) in PostgreSQL sehr langsam ist. 
 
 In diesem Artikel möchte ich Optionen untersuchen, damit Sie das Ergebnis ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Schneller POSTGRESQL COUNT machen (*)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490320/"><img src="https://habrastorage.org/webt/gd/v7/vr/gdv7vrlvosn5rd46igghex_2ofe.png" height="60%" width="60%"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird oft beanstandet, dass count (*) in PostgreSQL sehr langsam ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel möchte ich Optionen untersuchen, damit Sie das Ergebnis so schnell wie möglich erhalten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum ist count (*) so langsam?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die meisten Menschen verstehen ohne Probleme, dass die folgende Anfrage langsam ausgeführt wird:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(*)
<span class="hljs-keyword">FROM</span> <span class="hljs-comment">/*   */</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist schließlich eine komplexe Abfrage, und PostgreSQL muss das Ergebnis berechnen, bevor es weiß, wie viele Zeilen es enthalten wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele Menschen sind jedoch schockiert, als sie feststellen, dass die folgende Abfrage langsam ist:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">FROM</span> large_table;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie jedoch noch einmal darüber nachdenken, gilt Folgendes: PostgreSQL muss die Ergebnismenge berechnen, bevor sie gezählt werden kann. </font><font style="vertical-align: inherit;">Da der „magische Zeilenzähler“ nicht in der Tabelle gespeichert ist (wie in MyISAM MySQL), können Sie die Zeilen nur zählen, indem Sie sie betrachten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher führt count (*) normalerweise sequentielle Tabellenscans durch, was sehr teuer sein kann.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist das "*" in count (*) ein Problem?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das "*" in SELECT * FROM ... gilt für alle Spalten. </font><font style="vertical-align: inherit;">Daher finden viele Leute, dass die Verwendung von count (*) ineffizient ist, und verwenden stattdessen count (id) oder count (1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber das "*" in count (*) ist völlig anders, es bedeutet einfach "string" und wird überhaupt nicht erweitert (tatsächlich ist es ein "Aggregat mit Null-Argument"). </font><font style="vertical-align: inherit;">Die Anzahl der Notationen (1) oder die Anzahl (id) ist tatsächlich langsamer als die Anzahl (*), da überprüft werden muss, ob das Argument NULL ist oder nicht (count ignoriert wie die meisten Aggregate die Argumente NULL). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden also nichts erreichen, wenn Sie das "*" vermeiden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Index nur scannen</font></font></i></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist verlockend, einen kleinen Index und nicht die gesamte Tabelle zu scannen, um die Anzahl der Zeilen zu zählen. Dies ist jedoch in PostgreSQL aufgrund der Multi-Version-Strategie für das Parallelitätsmanagement nicht so einfach. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Version der Zeile („Tupel“) enthält Informationen darüber, für welchen Datenbank-Snapshot sie sichtbar ist</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diese (redundanten) Informationen werden jedoch nicht in Indizes gespeichert. Daher reicht es normalerweise nicht aus, die Einträge im Index zu zählen, da PostgreSQL den Tabelleneintrag („Heap-Tupel“) überprüfen muss, um sicherzustellen, dass der Indexeintrag sichtbar ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dieses Problem zu beheben, hat PostgreSQL eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sichtbarkeitskarte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementiert </font><font style="vertical-align: inherit;">, eine Datenstruktur, in der Informationen darüber gespeichert werden, ob alle Tupel in einem Tabellenblock für alle sichtbar sind oder nicht.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die meisten Blöcke in der Tabelle vollständig sichtbar sind, erfordern Index-Scans keine häufigen Besuche einer Reihe von Tupeln, um die Sichtbarkeit zu bestimmen. </font><font style="vertical-align: inherit;">Ein solcher Index-Scan wird als "Nur-Index-Scan" bezeichnet, und es ist häufig schneller, einen Index zu scannen, um die Zeilen zu zählen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt unterstützt VACUUM die Sichtbarkeitskarte. Stellen Sie daher sicher, dass das automatische Vakuum häufig genug durchgeführt wird, wenn Sie einen kleinen Index verwenden möchten, um die Zählung zu beschleunigen (*).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pivot-Tabelle verwenden</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe oben geschrieben, dass PostgreSQL die Anzahl der Zeilen in einer Tabelle nicht speichert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Aufrechterhalten einer solchen Zeilenanzahl ist ein großer Aufwand, da dieses Ereignis bei jeder Datenänderung auftritt und sich nicht auszahlt. Das wäre ein schlechtes Geschäft. Da unterschiedliche Anforderungen unterschiedliche Versionen von Zeichenfolgen anzeigen können, muss der Zähler außerdem versioniert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nichts hindert Sie jedoch daran, einen solchen Zeilenzähler selbst zu implementieren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Sie möchten die Anzahl der Zeilen in einer mytable verfolgen. Sie können dies wie folgt tun:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<font></font>
 <font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> mytable_count(c <span class="hljs-built_in">bigint</span>);<font></font>
 <font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> mytable_count() <span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">trigger</span>
   <span class="hljs-keyword">LANGUAGE</span> plpgsql <span class="hljs-keyword">AS</span>
$$<span class="hljs-keyword">BEGIN</span>
   <span class="hljs-keyword">IF</span> TG_OP = <span class="hljs-string">'INSERT'</span> <span class="hljs-keyword">THEN</span>
      <span class="hljs-keyword">UPDATE</span> mytable_count <span class="hljs-keyword">SET</span> c = c + <span class="hljs-number">1</span>;<font></font>
 <font></font>
      RETURN NEW;<font></font>
   ELSIF TG_OP = '<span class="hljs-keyword">DELETE</span><span class="hljs-string">' THEN
      UPDATE mytable_count SET c = c - 1;
 
      RETURN OLD;
   ELSE
      UPDATE mytable_count SET c = 0;
 
      RETURN NULL;
   END IF;
END;$$;
 
CREATE CONSTRAINT TRIGGER mytable_count_mod
   AFTER INSERT OR DELETE ON mytable
   DEFERRABLE INITIALLY DEFERRED
   FOR EACH ROW EXECUTE PROCEDURE mytable_count();
 
-- TRUNCATE triggers must be FOR EACH STATEMENT
CREATE TRIGGER mytable_count_trunc AFTER TRUNCATE ON mytable
   FOR EACH STATEMENT EXECUTE PROCEDURE mytable_count();
 
-- initialize the counter table
INSERT INTO mytable_count
   SELECT count(*) FROM mytable;
 
COMMIT;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir machen alles in einer Transaktion, damit keine Datenänderungen bei gleichzeitigen Transaktionen aufgrund einer Ringbedingung „verloren gehen“ können. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies wird durch den Befehl CREATE TRIGGER garantiert, der die Tabelle im Modus SHARE ROW EXCLUSIVE sperrt, wodurch alle gleichzeitigen Änderungen verhindert werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Nachteil ist, dass alle parallelen Datenänderungen warten müssen, bis SELECT count (*) ausgeführt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies gibt uns eine sehr schnelle Alternative zu count (*), jedoch auf Kosten der Verlangsamung aller Datenänderungen in der Tabelle. Durch die Verwendung eines </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verzögerten Einschränkungstriggers wird</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sichergestellt, dass die Zeilensperre in mytable_count so kurz wie möglich ist, um die Parallelität zu verbessern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass diese Zählertabelle viele Aktualisierungen erhalten kann, besteht keine Gefahr</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt kein "Aufblähen der Tabelle"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , da dies alles "heiße" Updates (HOT-Updates) sind.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Du brauchst wirklich count (*)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal ist die beste Lösung, nach einer Alternative zu suchen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oft ist die Annäherung gut genug und Sie benötigen nicht die genaue Menge. </font><font style="vertical-align: inherit;">In diesem Fall können Sie die Punktzahl verwenden, die PostgreSQL zum Planen von Abfragen verwendet:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> reltuples::<span class="hljs-built_in">bigint</span>
<span class="hljs-keyword">FROM</span> pg_catalog.pg_class
<span class="hljs-keyword">WHERE</span> relname = <span class="hljs-string">'mytable'</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Wert wird sowohl durch Autovakuum als auch durch Autoanalyse aktualisiert und sollte daher niemals 10% überschreiten. </font><font style="vertical-align: inherit;">Sie können autovacuum_analyze_scale_factor für diese Tabelle reduzieren, damit die Autoanalyse dort häufiger ausgeführt wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schätzen der Anzahl der Abfrageergebnisse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisher haben wir untersucht, wie das Zählen von Tabellenzeilen beschleunigt werden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal müssen Sie jedoch wissen, wie viele Zeilen die SELECT-Anweisung zurückgibt, ohne die Abfrage tatsächlich auszuführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einzige Möglichkeit, eine genaue Antwort auf diese Frage zu erhalten, besteht darin, die Anfrage zu vervollständigen. </font><font style="vertical-align: inherit;">Wenn die Note jedoch gut genug ist, können Sie den PostgreSQL-Optimierer verwenden, um sie zu erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende einfache Funktion verwendet dynamisches SQL und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPLAIN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um den Abfrageausführungsplan als Argument zu übergeben, und gibt eine Schätzung der Anzahl der Zeilen zurück:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> row_estimator(<span class="hljs-keyword">query</span> <span class="hljs-built_in">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-built_in">bigint</span>
   <span class="hljs-keyword">LANGUAGE</span> plpgsql <span class="hljs-keyword">AS</span>
$$<span class="hljs-keyword">DECLARE</span><font></font>
   plan jsonb;<font></font>
<span class="hljs-keyword">BEGIN</span>
   <span class="hljs-keyword">EXECUTE</span> <span class="hljs-string">'EXPLAIN (FORMAT JSON) '</span> || <span class="hljs-keyword">query</span> <span class="hljs-keyword">INTO</span> plan;<font></font>
 <font></font>
   RETURN (plan-&gt;0-&gt;'Plan'-&gt;&gt;'Plan Rows')::bigint;<font></font>
<span class="hljs-keyword">END</span>;$$;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie diese Funktion nicht, um nicht vertrauenswürdige SQL-Anweisungen zu verarbeiten, da sie von Natur aus anfällig für SQL-Injection ist.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de490302/index.html">Lernen, Microservices bereitzustellen. Teil 3. Helm</a></li>
<li><a href="../de490306/index.html">Wie wir Weltraumtechnologie-Modelle für das Moscow Aviation Institute erstellt haben</a></li>
<li><a href="../de490310/index.html">Faradaysches Gesetz oder wie ein Magnet in einem Kupferrohr steckt</a></li>
<li><a href="../de490314/index.html">RE: 23 Minuten. Begründung des Langsamen</a></li>
<li><a href="../de490318/index.html">Bionische Prothesen heutzutage</a></li>
<li><a href="../de490322/index.html">Namibia: Infrastruktur und was Sie vor Reiseantritt wissen sollten</a></li>
<li><a href="../de490324/index.html">Wie finden wir nicht offensichtliche Fehler in den Online-Zuordnungsoberflächen für Kinder?</a></li>
<li><a href="../de490328/index.html">Beruf: Tester</a></li>
<li><a href="../de490332/index.html">Wir erstellen einen Klon des Lebensmittel-Lieferservices mit Nuxt.js, GraphQL, Strapi und Stripe. Teil 2/7</a></li>
<li><a href="../de490336/index.html">Kanalanatomie in Go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>