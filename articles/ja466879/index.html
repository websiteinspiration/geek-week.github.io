<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❌ ⚙️ 🔛 JavaScriptとNode.jsの最良のテスト手法 🐅 👩🏿‍🤝‍👨🏼 👨🏼‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="これは、JavaScriptとNode.jsに信頼性を提供するための包括的なガイドです。ここには数十の最高の投稿、本、ツールが集められています。
 
 まず、アプリケーションの基礎となる一般に受け入れられているテスト方法を扱います。そして、あなたはあなたに興味のある領域を掘り下げることができます：フ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>JavaScriptとNode.jsの最良のテスト手法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/466879/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/t2/fe/u-/t2feu-mapmlc7txb2ith9futkie.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、JavaScriptとNode.jsに信頼性を提供するための包括的なガイドです。</font><font style="vertical-align: inherit;">ここには数十の最高の投稿、本、ツールが集められています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、アプリケーションの基礎となる一般に受け入れられているテスト方法を扱います。</font><font style="vertical-align: inherit;">そして、あなたはあなたに興味のある領域を掘り下げることができます：フロントエンドとインターフェース、バックエンド、CI、または上記すべて。</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></h1><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクション0。ゴールデンルール。</font><font style="vertical-align: inherit;">他のすべてのアドバイスの背後にある原動力である1つのアドバイス（1つの特別な章）。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクション1.テストの構造。</font><font style="vertical-align: inherit;">基本：理解しやすいテストの作成（12章）。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクション2.バックエンド。</font><font style="vertical-align: inherit;">バックエンドとマイクロサービスのテストを効果的に記述します（8章）。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクション3.フロントエンド、インターフェース、E2E。</font><font style="vertical-align: inherit;">コンポーネントとE2Eテスト（11章）を含む、Webインターフェイスのテストを作成しています。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクション4.テストの有効性の測定。</font><font style="vertical-align: inherit;">オブザーバーの観察：テスト品質評価（4章）。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクション5.継続的インテグレーション。</font><font style="vertical-align: inherit;">JSの世界におけるCIの推奨事項（9章）。</font></font></a></li>
</ul><br>
<a name="1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクション0.ゴールデンルール</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.ゴールデンルール：リーンテストに固執する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストコードは実際に動作するものとは異なります。</font><font style="vertical-align: inherit;">可能な限りシンプルに、短く、抽象化を排除し、独身で、仕事で素晴らしく、倹約してください。</font><font style="vertical-align: inherit;">他の人はテストを見て、彼が何をしているかすぐに理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの頭は量産コードで忙しく、さらに複雑にするための空きスペースがありません。</font><font style="vertical-align: inherit;">複雑なコードの新しい部分を貧しい心に押し込むと、テストするために、チーム全体のタスクの作業が遅くなります。</font><font style="vertical-align: inherit;">実際、このため、多くのチームは単にテストを回避しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト-これは、フレンドリーで笑顔のアシスタントを獲得する機会です。一緒に仕事をするのはとても良いことであり、小さな投資に対して大きな利益をもたらします。科学者は、私たちの脳には2つのシステムがあると信じています。1つは空の道路を運転するなど、努力を必要としない動作用、もう1つは数式を解くなどの認識を必要とする複雑な操作用です。最初のシステム用のテストを作成します。コードを見ると、ソリューションではなくHTMLドキュメントの編集に匹敵する単純さを感じることができます</font></font><code>2X(17 × 24)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、テストの方法、ツール、および目標を慎重に選択することで実現でき、経済的で大きなROIが得られます。</font><font style="vertical-align: inherit;">必要なだけテストし、柔軟性を持たせてください。</font><font style="vertical-align: inherit;">場合によっては、速度とシンプルさのために、一部のテストを削除して信頼性を犠牲にする価値があります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f27/bc3/5f9/f27bc35f96e79037157cea807ac5be23.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の推奨事項のほとんどは、この原則に基づいています。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準備はいい？</font></font></b><br>
<br>
<a name="2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクション1.テストの構造</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1各テストの名前は3つの部分で構成される必要があります</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストレポートは、アプリケーションの現在のリビジョンが、コードに精通していない人々、つまりDevOpsエンジニアの配備に関与するテスターと2年間の自分の要件を満たしているかどうかを示す必要があります。</font><font style="vertical-align: inherit;">テストが要件の言語で情報を報告し、それらの名前が3つの部分で構成される場合が最善です。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正確には何がテストされていますか？</font><font style="vertical-align: inherit;">たとえば、メソッド</font></font><code>ProductsService.addNewProduct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのような状況とシナリオで？</font><font style="vertical-align: inherit;">たとえば、価格はメソッドに渡されません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">期待される結果は何ですか？</font><font style="vertical-align: inherit;">たとえば、新製品は承認されていません。</font></font></li>
</ol><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デプロイメントが失敗し、「製品の追加」と呼ばれるテストが失敗します。</font><font style="vertical-align: inherit;">正確に何がうまくいかないのか理解していますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">各章には、コード例があり、場合によってはイラストもあります。</font><font style="vertical-align: inherit;">スポイラーを参照してください。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  . </b>     .<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//1. unit under test</span>
describe(<span class="hljs-string">'Products Service'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<font></font>
  describe(<span class="hljs-string">'Add new product'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//2. scenario and 3. expectation</span>
    it(<span class="hljs-string">'When no price is specified, then the product status is pending approval'</span>, ()=&gt; {
      <span class="hljs-keyword">const</span> newProduct = <span class="hljs-keyword">new</span> ProductService().add(...);<font></font>
      expect(newProduct.status).to.equal(<span class="hljs-string">'pendingApproval'</span>);<font></font>
    });<font></font>
  });<font></font>
});</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2 AAAパターンに従ってテストを構成する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各テストは、3つの明確に分離されたセクションで構成する必要があります：配置（準備）、行為（アクション）、アサート（結果）。</font><font style="vertical-align: inherit;">このような構造に準拠することで、コードの読者がテストプランを理解するために脳プロセッサを使用する必要がなくなります。配置：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストシナリオに従ってシステムを状態にするすべてのコード。</font><font style="vertical-align: inherit;">これには、テストデザイナでのモジュールのインスタンスの作成、データベースへのレコードの追加、オブジェクトの代わりにスタブの作成、およびテスト実行のためにシステムを準備するその他のコードが含まれる場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行為：テストの一部としてのコード実行。</font><font style="vertical-align: inherit;">通常は1行だけです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アサート：結果の値が期待どおりであることを確認します。</font><font style="vertical-align: inherit;">通常は1行だけです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> メインコードの操作に長い時間を費やすだけでなく、簡単な仕事（テスト）によって脳も膨らみます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b> ,      AAA.<br>
<br>
<pre><code class="javascript hljs">describe.skip(<span class="hljs-string">'Customer classifier'</span>, () =&gt; {<font></font>
    test(<span class="hljs-string">'When customer spent more than 500$, should be classified as premium'</span>, () =&gt; {
        <span class="hljs-comment">//Arrange</span>
        <span class="hljs-keyword">const</span> customerToClassify = {<span class="hljs-attr">spent</span>:<span class="hljs-number">505</span>, <span class="hljs-attr">joined</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), <span class="hljs-attr">id</span>:<span class="hljs-number">1</span>}
        <span class="hljs-keyword">const</span> DBStub = sinon.stub(dataAccess, <span class="hljs-string">"getCustomer"</span>)<font></font>
            .reply({<span class="hljs-attr">id</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">classification</span>: <span class="hljs-string">'regular'</span>});<font></font>
<font></font>
        <span class="hljs-comment">//Act</span>
        <span class="hljs-keyword">const</span> receivedClassification = customerClassifier.classifyCustomer(customerToClassify);<font></font>
<font></font>
        <span class="hljs-comment">//Assert</span>
        expect(receivedClassification).toMatch(<span class="hljs-string">'premium'</span>);<font></font>
    });<font></font>
});<font></font>
</code></pre><br>
<b> .</b>  ,  ,  .<br>
<br>
<pre><code class="javascript hljs">test(<span class="hljs-string">'Should be classified as premium'</span>, () =&gt; {
        <span class="hljs-keyword">const</span> customerToClassify = {<span class="hljs-attr">spent</span>:<span class="hljs-number">505</span>, <span class="hljs-attr">joined</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), <span class="hljs-attr">id</span>:<span class="hljs-number">1</span>}
        <span class="hljs-keyword">const</span> DBStub = sinon.stub(dataAccess, <span class="hljs-string">"getCustomer"</span>)<font></font>
            .reply({<span class="hljs-attr">id</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">classification</span>: <span class="hljs-string">'regular'</span>});
        <span class="hljs-keyword">const</span> receivedClassification = customerClassifier.classifyCustomer(customerToClassify);<font></font>
        expect(receivedClassification).toMatch(<span class="hljs-string">'premium'</span>);<font></font>
    });</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3製品の言語で期待を説明する：BDDのスタイルで述べる</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣言型のテストをプログラミングすることで、ユーザーは1つの脳プロセッササイクルを費やすことなく、本質を即座に理解できます。</font><font style="vertical-align: inherit;">条件付きロジックでパックされた命令型コードを書くとき、読者は多くの努力をしなければなりません。</font><font style="vertical-align: inherit;">この観点から、カスタムコードを使用せず、expect / shouldを使用して宣言的なBDDスタイルで人間のような言語で期待を記述する必要があります。</font><font style="vertical-align: inherit;">ChaiとJestで必要なアサーションがない場合、これが繰り返されることが多い場合は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、マッチャーJestを拡張する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、独自のChai用プラグインを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チームはより少ないテストを記述し、迷惑なテストを飾ります</font></font><code>with .skip()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   Mocha</a>.<br>
<br>
<b> . </b>   ,        .<br>
<br>
<pre><code class="javascript hljs">it(<span class="hljs-string">"When asking for an admin, ensure only ordered admins in results"</span> , ()={
    <span class="hljs-comment">//assuming we've added here two admins "admin1", "admin2" and "user1"</span>
    <span class="hljs-keyword">const</span> allAdmins = getUsers({<span class="hljs-attr">adminOnly</span>:<span class="hljs-literal">true</span>});<font></font>
<font></font>
    <span class="hljs-keyword">const</span> admin1Found, adming2Found = <span class="hljs-literal">false</span>;<font></font>
<font></font>
    allAdmins.forEach(<span class="hljs-function"><span class="hljs-params">aSingleUser</span> =&gt;</span> {
        <span class="hljs-keyword">if</span>(aSingleUser === <span class="hljs-string">"user1"</span>){<font></font>
            assert.notEqual(aSingleUser, <span class="hljs-string">"user1"</span>, <span class="hljs-string">"A user was found and not admin"</span>);<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span>(aSingleUser===<span class="hljs-string">"admin1"</span>){<font></font>
            admin1Found = <span class="hljs-literal">true</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span>(aSingleUser===<span class="hljs-string">"admin2"</span>){<font></font>
            admin2Found = <span class="hljs-literal">true</span>;<font></font>
        }<font></font>
    });<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(!admin1Found || !admin2Found ){
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Not all admins were returned"</span>);<font></font>
    }<font></font>
});<font></font>
</code></pre><br>
<b>  .</b>       .<br>
<br>
<pre><code class="javascript hljs">it(<span class="hljs-string">"When asking for an admin, ensure only ordered admins in results"</span> , ()={
    <span class="hljs-comment">//assuming we've added here two admins</span>
    <span class="hljs-keyword">const</span> allAdmins = getUsers({<span class="hljs-attr">adminOnly</span>:<span class="hljs-literal">true</span>});<font></font>
<font></font>
    expect(allAdmins).to.include.ordered.members([<span class="hljs-string">"admin1"</span> , <span class="hljs-string">"admin2"</span>])<font></font>
  .but.not.include.ordered.members([<span class="hljs-string">"user1"</span>]);<font></font>
});</code></pre><br>
</div></div><br>
<h2>1.4     « »:    </h2><br>
<b> .</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部をテストすると、大きなオーバーヘッドが発生し、ほとんど何も得られません。コードまたはAPIが正しい結果を提供する場合、3時間かけて内部でどのように機能するかをテストしてから、これらの脆弱なテストをサポートする価値はありますか？パブリック動作をチェックするとき、同時に暗黙的に実装自体もチェックします。テストは、特定の問題（たとえば、誤った出力）がある場合にのみ失敗します。このアプローチは、行動テストとも呼ばれます。一方、内部（「ホワイトボックス」メソッド）をテストする場合は、コンポーネントの出力を計画するのではなく、細部に焦点を当てます。結果に問題がなくても、コードの小さな変更によりテストが失敗する場合があります。護衛ははるかに多くのリソースを必要とします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「狼」と叫ぶ少年の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ように動作し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます。</font></a><font style="vertical-align: inherit;">：誤検知を大声で報告します（たとえば、プライベート変数の名前の変更が原因でテストが失敗します）。</font><font style="vertical-align: inherit;">すぐに人々がCI通知を無視し始め、ある日、実際のバグを見逃すことは当然のことです...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b> .</b>     .<br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   Mocha</a>.<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductService</span></span>{
  <span class="hljs-comment">//this method is only used internally</span>
  <span class="hljs-comment">//Change this name will make the tests fail</span><font></font>
  calculateVAT(priceWithoutVAT){<font></font>
    <span class="hljs-keyword">return</span> {<span class="hljs-attr">finalPrice</span>: priceWithoutVAT * <span class="hljs-number">1.2</span>};
    <span class="hljs-comment">//Change the result format or key name above will make the tests fail</span><font></font>
  }<font></font>
  <span class="hljs-comment">//public method</span><font></font>
  getPrice(productId){<font></font>
    <span class="hljs-keyword">const</span> desiredProduct= DB.getProduct(productId);<font></font>
    finalPrice = <span class="hljs-keyword">this</span>.calculateVATAdd(desiredProduct.price).finalPrice;<font></font>
  }<font></font>
}<font></font>
<font></font>
<font></font>
it(<span class="hljs-string">"White-box test: When the internal methods get 0 vat, it return 0 response"</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">//There's no requirement to allow users to calculate the VAT, only show the final price. Nevertheless we falsely insist here to test the class internals</span>
    expect(<span class="hljs-keyword">new</span> ProductService().calculateVATAdd(<span class="hljs-number">0</span>).finalPrice).to.equal(<span class="hljs-number">0</span>);<font></font>
});</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.5模倣された正しい実装を選択する：スタブとスパイを優先する偽のオブジェクトを避ける</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シミュレートされた実装（テストダブル）は、アプリケーションの内部に関連付けられているため必要な悪であり、いくつかは非常に価値があります（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模倣された実装のメモリを更新します：偽オブジェクト（モック）、スタブ（スタブ）、スパイオブジェクト（スパイ））</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）ただし、すべての手法が同等であるとは限りません。スパイとスタブは要件をテストするように設計されていますが、避けられない副作用があります-それらは内部にもわずかに影響します。また、偽のオブジェクトは内部をテストするように設計されているため、1.4章で説明されているように、大きなオーバーヘッドが発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シミュレートされた実装を使用する前に、次の最も簡単な質問を自問してください。「これを使用して、ドキュメントに表示された、またはドキュメントに表示される可能性のある機能を、要件とともにテストするか？そうでなければ、それはホワイトボックステストのしるしです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、支払いサービスが利用できないときにアプリケーションが正常に動作するかどうかを確認する場合は、代わりにスタブを作成して「無応答」を返し、テスト対象のモジュールが正しい値を返すかどうかを確認できます。したがって、特定のシナリオでのアプリケーションの動作/応答/出力を確認できます。スパイの助けを借りて、サービスが利用できないときに手紙が送信されたことを確認することもできます。これは行動テストでもあり、要件を含むドキュメントに反映されています（「支払い情報を保存できない場合は手紙を送信する」）。同時に、偽の支払いサービスを作成し、それが正しいJSタイプを使用して呼び出されることを確認する場合、テストは、アプリケーションの機能に関連せず、頻繁に変更される可能性のある内部を対象としています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードのリファクタリングでは、コード内のすべての偽のオブジェクトを見つけて更新します。</font><font style="vertical-align: inherit;">アシスタントの友人からのテストは負担になります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b> .</b>     .<br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   Sinon</a>.<br>
<br>
<pre><code class="javascript hljs">it(<span class="hljs-string">"When a valid product is about to be deleted, ensure data access DAL was called once, with the right product and right config"</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">//Assume we already added a product</span>
    <span class="hljs-keyword">const</span> dataAccessMock = sinon.mock(DAL);
    <span class="hljs-comment">//hmmm BAD: testing the internals is actually our main goal here, not just a side-effect</span>
    dataAccessMock.expects(<span class="hljs-string">"deleteProduct"</span>).once().withArgs(DBConfig, theProductWeJustAdded, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">new</span> ProductService().deletePrice(theProductWeJustAdded);<font></font>
    mock.verify();<font></font>
});<font></font>
</code></pre><br>
<b>  .</b>     ,     —    .<br>
<br>
<pre><code class="javascript hljs">it(<span class="hljs-string">"When a valid product is about to be deleted, ensure an email is sent"</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">//Assume we already added here a product</span>
    <span class="hljs-keyword">const</span> spy = sinon.spy(Emailer.prototype, <span class="hljs-string">"sendEmail"</span>);
    <span class="hljs-keyword">new</span> ProductService().deletePrice(theProductWeJustAdded);
    <span class="hljs-comment">//hmmm OK: we deal with internals? Yes, but as a side effect of testing the requirements (sending an email)</span>
});</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.6「foo」を使用せず、現実的な入力を使用する</font></font></h2><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの場合、非常に具体的で意外な入力データで本番環境のバグが発生します。テスト中のデータが現実的であればあるほど、時間通りにバグをキャッチする可能性が高くなります。さまざまな種類の本番データをシミュレートする疑似リアルデータを生成するには、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faker</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの特別なライブラリを使用します</font><font style="vertical-align: inherit;">。このようなライブラリは、現実的な電話番号、ユーザーのニックネーム、銀行カード、会社名、さらには「lorem ipsum」というテキストを生成することができます。モジュールをテストに適合させるために偽のデータをランダム化するテストを（ユニットテストではなく、ユニットテストの上に）作成するか、実稼働環境から実際のデータをインポートすることもできます。さらに行きたいですか？次の章を読んでください（プロパティベースのテストについて）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発中のテストは、「Foo」などの合成入力を使用して成功したように見え、ハッカーがのようなトリッキーな行を送信すると、本番データが失敗する可能性があり</font></font><code>@3e2ddsf . ##’ 1 fdsfds . fds432 AAAA</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b> .</b>  ,    -   .<br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   Jest</a>.<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> addProduct = <span class="hljs-function">(<span class="hljs-params">name, price</span>) =&gt;</span>{
  <span class="hljs-keyword">const</span> productNameRegexNoSpace = <span class="hljs-regexp">/^\S*$/</span>;<span class="hljs-comment">//no white-space allowed</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(!productNameRegexNoSpace.test(name))
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//this path never reached due to dull input</span><font></font>
<font></font>
    <span class="hljs-comment">//some logic here</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
};<font></font>
<font></font>
test(<span class="hljs-string">"Wrong: When adding new product with valid properties, get successful confirmation"</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">//The string "Foo" which is used in all tests never triggers a false result</span>
    <span class="hljs-keyword">const</span> addProductResult = addProduct(<span class="hljs-string">"Foo"</span>, <span class="hljs-number">5</span>);<font></font>
    expect(addProductResult).to.be.true;<font></font>
    <span class="hljs-comment">//Positive-false: the operation succeeded because we never tried with long</span>
    <span class="hljs-comment">//product name including spaces</span><font></font>
});<font></font>
</code></pre><br>
<b>  .</b>    .<br>
<br>
<pre><code class="javascript hljs">it(<span class="hljs-string">"Better: When adding new valid product, get successful confirmation"</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> addProductResult = addProduct(faker.commerce.productName(), faker.random.number());
    <span class="hljs-comment">//Generated random input: {'Sleek Cotton Computer',  85481}</span><font></font>
    expect(addProductResult).to.be.true;<font></font>
    <span class="hljs-comment">//Test failed, the random input triggered some path we never planned for.</span>
    <span class="hljs-comment">//We discovered a bug early!</span>
});</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.7プロパティベースのテストを使用して複数の入力の組み合わせを検証する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常、各テストでは、入力データのいくつかのサンプルを選択します。</font><font style="vertical-align: inherit;">入力形式が実際のデータに類似している場合でも（「Doを使用しない」の章を参照）、入力データのいくつかの組み合わせ（メソッド</font></font><code>(‘’, true, 1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、メソッド</font></font><code>("string" , false" , 0)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">のみを取り上げ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">しかし、動作中、5つのパラメーターで呼び出されるAPIは、何千もの異なる組み合わせで呼び出すことができ、その1つがプロセスの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">クラッシュ</font></a><font style="vertical-align: inherit;">（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ファジング）に</font></a><font style="vertical-align: inherit;">つながる可能性があります</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">） 1つのテストを作成し、入力データの1000の組み合わせを自動的に送信して修正すると、どの組み合わせでコードが正しい答えを返さないのでしょうか。プロパティベースのテスト方法でも同じことが行われます。テスト対象のモジュールに入力データの可能なすべての組み合わせを送信することで、バグを検出する可能性が高くなります。たとえば、メソッドがあり</font></font><code>addNewProduct(id, name, isDiscount)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。彼のライブラリをサポートする多くの組み合わせでこのメソッドを呼び出します</font></font><code>(,  ,  )</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、例えば</font></font><code>(1, "iPhone", false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>(2, "Galaxy", true)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などお気に入りのテストランナー（Mocha、Jestなど）と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">js-verify</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">testcheck</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（はるかに優れたドキュメントが</font><font style="vertical-align: inherit;">あります）などのライブラリを使用して、プロパティに基づいてテストできます</font><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">高速チェックライブラリを試す</font></a><font style="vertical-align: inherit;">こともでき</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、追加機能を提供し、作者も積極的に同行します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">うまく機能しているコード実行パスのみをカバーするテスト用の入力データを不用意に選択しています。</font><font style="vertical-align: inherit;">残念ながら、これはエラーを検出する手段としてのテストの有効性を低下させます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b>      «mocha-testcheck».<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">require</span>(<span class="hljs-string">'mocha-testcheck'</span>).install();
<span class="hljs-keyword">const</span> {expect} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'chai'</span>);
<span class="hljs-keyword">const</span> faker = <span class="hljs-built_in">require</span>(<span class="hljs-string">'faker'</span>);<font></font>
<font></font>
describe(<span class="hljs-string">'Product service'</span>, () =&gt; {<font></font>
  describe(<span class="hljs-string">'Adding new'</span>, () =&gt; {
    <span class="hljs-comment">//this will run 100 times with different random properties</span>
    check.it(<span class="hljs-string">'Add new product with random yet valid properties, always successful'</span>,<font></font>
      gen.int, gen.string, (id, name) =&gt; {<font></font>
        expect(addNewProduct(id, name).status).to.equal(<span class="hljs-string">'approved'</span>);<font></font>
      });<font></font>
  })<font></font>
});</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.8必要に応じて、短いインラインショットのみを使用してください。</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スナップショット</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">基づい</font></a><font style="vertical-align: inherit;">て</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">テスト</font></a><font style="vertical-align: inherit;">する必要がある場合</font><font style="vertical-align: inherit;">は、外部ファイルとしてではなく</font><font style="vertical-align: inherit;">、テストの一部（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インラインスナップショット</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を含め、余分なもの（たとえば3〜7行）なしで短いスナップショットのみを使用してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この推奨に従うことで、テストが自明で信頼性が高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、「クラシックスナップショット」とツールキットのマニュアルでは、大きなファイル（たとえば、レンダリングコンポーネントのマークアップやJSON APIの結果）を外部メディアに保存し、テストを実行するたびにその結果を保存されたバージョンと比較するように促されています。たとえば、テストの作成者が予期していなかったことを見たことがない、3000の値を含む1000行にテストを暗黙的に関連付けることができます。なぜそれが悪いのですか？テストが失敗する理由は1000あるからです。 1行でもスナップショットが無効になる可能性があり、これは頻繁に発生する可能性があります。いくら？ CSSまたはHTMLの各スペース、コメント、またはマイナー変更の後。さらに、テストの名前は、失敗については通知しません。これは、1000行が変更されていないことを確認するだけであり、テストの作成者が必要に応じて長いドキュメントをとるように促すためです。彼はそれを分析して検証することができませんでした。これらはすべて、明確なタスクがなく、あまりにも多くを達成しようとしている、あいまいで性急なテストの症状です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データではなくスキームを確認する場合（値を抽出してフィールドに焦点を当てる場合など）、または受信したドキュメントがめったに変更されない場合など、長い外部イメージを使用することが許容される状況がいくつかあることに注意してください。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UIテストは失敗します。</font><font style="vertical-align: inherit;">コードは正常に見え、理想的なピクセルが画面に表示されるので、どうなりますか？</font><font style="vertical-align: inherit;">スナップショットを使用したテストで、元のドキュメントと受け取ったばかりのドキュメントの違いが明らかになりました-1つのスペース文字がマークアップに追加されました...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b> .</b>    -  2000  .<br>
<br>
<pre><code class="javascript hljs">it(<span class="hljs-string">'TestJavaScript.com is renderd correctly'</span>, ()  =&gt; {<font></font>
<font></font>
<span class="hljs-comment">//Arrange</span><font></font>
<font></font>
<span class="hljs-comment">//Act</span>
<span class="hljs-keyword">const</span> receivedPage = renderer<font></font>
.create(  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DisplayPage</span> <span class="hljs-attr">page</span>  =  <span class="hljs-string">"http://www.testjavascript.com"</span>  &gt;</span> Test JavaScript <span class="hljs-tag">&lt; /<span class="hljs-attr">DisplayPage</span>&gt;</span></span>)<font></font>
.toJSON();<font></font>
<font></font>
<span class="hljs-comment">//Assert</span><font></font>
expect(receivedPage).toMatchSnapshot();<font></font>
<span class="hljs-comment">//We now implicitly maintain a 2000 lines long document</span>
<span class="hljs-comment">//every additional line break or comment - will break this test</span><font></font>
<font></font>
});<font></font>
</code></pre><br>
<b>  .</b>       .<br>
<br>
<pre><code class="javascript hljs">it(<span class="hljs-string">'When visiting TestJavaScript.com home page, a menu is displayed'</span>, () =&gt; {
<span class="hljs-comment">//Arrange</span><font></font>
<font></font>
<span class="hljs-comment">//Act</span><font></font>
receivedPage tree = renderer<font></font>
.create(  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DisplayPage</span> <span class="hljs-attr">page</span>  =  <span class="hljs-string">"http://www.testjavascript.com"</span>  &gt;</span> Test JavaScript <span class="hljs-tag">&lt; /<span class="hljs-attr">DisplayPage</span>&gt;</span></span>)<font></font>
.toJSON();<font></font>
<font></font>
<span class="hljs-comment">//Assert</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> menu = receivedPage.content.menu;<font></font>
expect(menu).toMatchInlineSnapshot(<span class="hljs-string">`
&lt;ul&gt;
&lt;li&gt;Home&lt;/li&gt;
&lt;li&gt; About &lt;/li&gt;
&lt;li&gt; Contact &lt;/li&gt;
&lt;/ul&gt;
`</span>);<font></font>
});</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.9グローバルなテストベンチと初期データを避け、各テストに個別にデータを追加する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゴールデンルール（チャプター0）によると、各テストは、バインディングを回避するためにデータベース内の独自の行セット内で追加および機能する必要があり、ユーザーがテストを理解しやすくなりました。実際には、テスターはデータベースを初期データ（シード）で満たすテストを実行する前に、このルールに違反することがよくあります（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">「テストベンチ」とも呼ばれます</font></a><font style="vertical-align: inherit;">）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）生産性を向上させるため。</font><font style="vertical-align: inherit;">また、パフォーマンスは本当に重要なタスクですが、低下する可能性があります（「コンポーネントのテスト」の章を参照）。ただし、テストの複雑さははるかに有害であり、多くの場合、決定を管理する必要があります。</font><font style="vertical-align: inherit;">ほとんどすべてのテストケースで、必要なレコードを明示的にデータベースに追加し、それらのみを操作する必要があります。</font><font style="vertical-align: inherit;">パフォーマンスが重要な場合は、妥協案として、情報を変更しないテスト（クエリなど）のみを初期データに入力できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかのテストが失敗し、展開が中止されました。チームは貴重な時間を費やしますが、バグはありますか？</font><font style="vertical-align: inherit;">見てみましょう、くそー、2つのテストが同じ初期データを変更したようです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b> .</b>       -        .<br>
<br>
<pre><code class="javascript hljs">before(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">//adding sites and admins data to our DB. Where is the data? outside. At some external json or migration framework</span>
  <span class="hljs-keyword">await</span> DB.AddSeedDataFromJson(<span class="hljs-string">'seed.json'</span>);<font></font>
});<font></font>
it(<span class="hljs-string">"When updating site name, get successful confirmation"</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">//I know that site name "portal" exists - I saw it in the seed files</span>
  <span class="hljs-keyword">const</span> siteToUpdate = <span class="hljs-keyword">await</span> SiteService.getSiteByName(<span class="hljs-string">"Portal"</span>);
  <span class="hljs-keyword">const</span> updateNameResult = <span class="hljs-keyword">await</span> SiteService.changeName(siteToUpdate, <span class="hljs-string">"newName"</span>);<font></font>
  expect(updateNameResult).to.be(<span class="hljs-literal">true</span>);<font></font>
});<font></font>
it(<span class="hljs-string">"When querying by site name, get the right site"</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">//I know that site name "portal" exists - I saw it in the seed files</span>
  <span class="hljs-keyword">const</span> siteToCheck = <span class="hljs-keyword">await</span> SiteService.getSiteByName(<span class="hljs-string">"Portal"</span>);<font></font>
  expect(siteToCheck.name).to.be.equal(<span class="hljs-string">"Portal"</span>); <span class="hljs-comment">//Failure! The previous test change the name :[</span><font></font>
});<font></font>
</code></pre><br>
<b>  .</b>     ,       .<br>
<br>
<pre><code class="javascript hljs">it(<span class="hljs-string">"When updating site name, get successful confirmation"</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">//test is adding a fresh new records and acting on the records only</span>
  <span class="hljs-keyword">const</span> siteUnderTest = <span class="hljs-keyword">await</span> SiteService.addSite({
    <span class="hljs-attr">name</span>: <span class="hljs-string">"siteForUpdateTest"</span><font></font>
  });<font></font>
  <span class="hljs-keyword">const</span> updateNameResult = <span class="hljs-keyword">await</span> SiteService.changeName(siteUnderTest, <span class="hljs-string">"newName"</span>);<font></font>
  expect(updateNameResult).to.be(<span class="hljs-literal">true</span>);<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.10エラーを捕まえないが、期待する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部の入力がエラーにつながることを確認したい場合は、try-catch-finallyを使用して、エラーをキャッチするための条件が導入されたことを証明できます。</font><font style="vertical-align: inherit;">結果は見苦しく面倒なテスト（以下の例）であり、結果を確認して待機するという単純な意図が隠されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
よりエレガントな解決策は、Chai：（</font></font><code>expect(method).to.throw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはJest :) </font><font style="vertical-align: inherit;">の単一行チェックを使用すること</font></font><code>expect(method).toThrow()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">また、例外にエラーの種類を特定できるプロパティが含まれていることを確認することも絶対に必要です。</font><font style="vertical-align: inherit;">それ以外の場合、特定の一般的なエラーが発生すると、アプリケーションはユーザーに迷惑なメッセージのみを表示できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストレポート（CIレポートなど）から、何が問題だったかを理解することは困難です。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b> .</b>   ,     try-catch   .<br>
<br>
<pre><code class="javascript hljs">/it(<span class="hljs-string">"When no product name, it throws error 400"</span>, <span class="hljs-keyword">async</span>() =&gt; {
<span class="hljs-keyword">let</span> errorWeExceptFor = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> addNewProduct({<span class="hljs-attr">name</span>:<span class="hljs-string">'nest'</span>});}
<span class="hljs-keyword">catch</span> (error) {<font></font>
  expect(error.code).to.equal(<span class="hljs-string">'InvalidInput'</span>);<font></font>
  errorWeExceptFor = error;<font></font>
}<font></font>
expect(errorWeExceptFor).not.to.be.null;<font></font>
<span class="hljs-comment">//if this assertion fails, the tests results/reports will only show</span>
<span class="hljs-comment">//that some value is null, there won't be a word about a missing Exception</span><font></font>
});<font></font>
</code></pre><br>
<b>  .</b>     ,   , ,   QA    .<br>
<br>
<pre><code class="javascript hljs">it.only(<span class="hljs-string">"When no product name, it throws error 400"</span>, <span class="hljs-keyword">async</span>() =&gt; {<font></font>
  expect(addNewProduct)).to.eventually.throw(AppError).with.property(<span class="hljs-string">'code'</span>, <span class="hljs-string">"InvalidInput"</span>);<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.11テストにマークを付ける</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シナリオごとに異なるテストを実行する必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クイック煙テスト</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOなし、 </font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発者がファイルを保存またはコミットするときに実行する必要があるテスト、</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいプルリクエストを送信するときに通常実行される完全なエンドツーエンドのテストなど。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、たとえば#cold #api #sanityなどのキーワードでテストをマークすると実現できます。</font><font style="vertical-align: inherit;">次に、テストツールを取得して、目的のテストスイートを呼び出すことができます。</font><font style="vertical-align: inherit;">たとえば、このメソッドは、Mochaテストグループの操作を引き起こす可能性があります</font></font><code>mocha — grep ‘sanity’</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発者が行った最小限の変更でさえ、何十ものデータベースクエリを実行するものを含むすべてのテストを実行すると、ワークフローが大幅に遅くなり、開発者はテストを回避しようとします。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b>   ‘#cold-test’      (Cold=== ,     -    ,     ).<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//this test is fast (no DB) and we're tagging it correspondingly</span>
<span class="hljs-comment">//now the user/CI can run it frequently</span>
describe(<span class="hljs-string">'Order service'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<font></font>
  describe(<span class="hljs-string">'Add new order #cold-test #sanity'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<font></font>
    it(<span class="hljs-string">'Scenario - no currency was supplied. Expectation - Use the default currency #sanity'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-comment">//code logic here</span><font></font>
    });<font></font>
  });<font></font>
});</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.12その他の一般的な衛生試験規則</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事では、Node.jsに関連する、またはNode.jsで説明できるヒントに焦点を当てています。この章では、Nodeに関連しないよく知られたヒントについて説明します。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">TDDの原則を</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
学び、適用します</font><font style="vertical-align: inherit;">。それらは多くの人にとって非常に便利ですが、あなたのスタイルに合わない場合でも落胆しないでください。あなたはこれに最初に遭遇するわけではありません。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">赤緑のリファクタリング</font></a><font style="vertical-align: inherit;">コードを書く前にテストを書いてみてください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後、各テストは1つだけをチェックします。</font><font style="vertical-align: inherit;">バグを見つけたら、修正する前に、将来このバグを特定するテストを作成します。</font><font style="vertical-align: inherit;">バグを修正する前に、テストが少なくとも1回失敗することを許可します。</font><font style="vertical-align: inherit;">テストを満たす単純化されたコードをすばやく作成してモジュールを開始し、次に徐々にリファクタリングして運用レベルにし、環境（パス、OSなど）への依存を回避します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何十年にもわたってプログラマーが蓄積してきた知恵を失うことになります。</font></font><br>
<br>
<a name="3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクション2：バックエンドテスト</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">️2.1テストの武器を拡張する：単体テストとテストピラミッドに制限されない</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストピラミッドの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンセプトは</font><font style="vertical-align: inherit;">10年前</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">から存在</font></a><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">ていますが</font><font style="vertical-align: inherit;">、この美しく最新のモデルは3種類のテストを提供し、ほとんどの開発者のテスト戦略に影響を与えます。しかし、ピラミッドの陰で他の多くの注目すべき技術が開発されました。過去10年間に見られた劇的な変化（マイクロサービス、クラウド、オフサーバーデータ処理）を考えると、1つの非常に古いモデルだけが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプのアプリケーション</font><font style="vertical-align: inherit;">を満たすこと</font><font style="vertical-align: inherit;">ができるのでしょうか？テスターコミュニティは新しいテスト手法を歓迎すべきですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誤解しないでください。2019年でも、テストピラミッド、TDD、ユニットテストは強力な手法であり、多くのアプリケーションに最適です。</font><font style="vertical-align: inherit;">しかし、他のモデルと同様に、その利点に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">も</font></a><font style="vertical-align: inherit;">かかわらず、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時には間違っている可能性があります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">多くのイベントをKafkaやRabbitMQなどのメッセージバスに転送するIoTアプリケーションを取り、それがリポジトリに送信され、最後にある種の分析インターフェースがそれらを要求します。</font><font style="vertical-align: inherit;">統合のために強化され、ほとんどロジックを含まないアプリケーションをテストする単体テストの作成に、テスト予算の半分を費やすことをお勧めしますか？</font><font style="vertical-align: inherit;">アプリケーションの種類（ボット、暗号化、音声アシスタント）の種類が多いほど、テストピラミッドがあまり適していないシナリオに遭遇する可能性が高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストの武器を拡張し、新しいタイプのテスト（以下にいくつかのアイデアを提供します）とピラミッドのようなモデルについて理解し、さらに、テストのタイプをあなたの前に発生する実際の問題と比較します（「APIを壊しました。クライアントが管理する契約のテストを書いてみましょう。 ！”（消費者主導の契約））。投資家がリスク分析に基づいてポートフォリオを作成するように、テストを多様化します。問題が発生する可能性のある場所を評価し、リスクを削減できる対策を決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：ソフトウェアの世界でのTDDに関する議論は、典型的な偽の二分イメージを引き受けます。 TDDの使用を普遍的に説く人もいれば、悪魔の策略だと考える人もいます。絶対主義的な見方をするすべての人は間違っています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fuzz、Linting、Mutationsなど、10分でその価値を証明する優れたROIツールを見逃してしまいます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b> Cindy Sridharan        ‘Testing Microservices — the sane way’<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/375/7ab/6f0/3757ab6f02f3bad93c7235ad2ee0ad95.png"><br>
<br>
:<br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/-2zP494wdUY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2コンポーネントテストが最良のソリューションである</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各単体テストはアプリケーションのごく一部をカバーしており、全体をカバーすることは困難です。</font><font style="vertical-align: inherit;">同時に、エンドツーエンドのテストはほとんどのアプリケーションをカバーしますが、速度が遅く、より不安定です。</font><font style="vertical-align: inherit;">妥協案を見つけて、モジュラーより大きく、エンドツーエンドよりも小さいテストを書いてみませんか？</font><font style="vertical-align: inherit;">コンポーネントテストは過小評価されたダイヤモンドです。</font><font style="vertical-align: inherit;">これらのテストは、適切なパフォーマンスとTDDパターンを使用できること、および幅広いテストカバレッジという2つの世界からすべてを最大限に活用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントテストはマイクロサービスの「モジュール」に焦点を当てており、APIを介して機能し、マイクロサービス自体に属しているもの（たとえば、実際のデータベース、または少なくともそのインメモリバージョン）をシミュレートしませんが、外部、たとえば他からの呼び出しすべてに対してスタブを作成しますmicroseries。</font><font style="vertical-align: inherit;">したがって、導入したものをテストし、「外部から内部へ」という原則に基づいてアプリケーションを操作し、妥当な時間内に製品の品質に対する信頼を獲得します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニットテストの作成に何日も費やすと、システムカバレッジがわずか20％に達したことがわかります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b>     Express API   (     ).<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/625/d5d/7c1/625d5d7c195e640bacb1b4f50d8a0cdc.png"><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.3新しいリリースがAPIの使用を妨げないことを確認する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロサービスには多くのクライアントがあり、互換性のために多くのバージョンを起動します（みんなが幸せになるように）。フィールドを変更したら、強打します。 -この分野が重要な役割を果たす重要な顧客の1人が怒りました。これは</font><font style="vertical-align: inherit;">統合の世界で</font><font style="vertical-align: inherit;">は「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trick-22</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」です。サーバー側では、サーバーがリリース日を管理しているため、クライアントがテストを実行できない一方で、多数のクライアントのすべての期待を考慮することは非常に困難です。非常に破壊的なアプローチを使用してこのプロセスを形式化するために、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顧客主導の契約とPACTフレームワークを考案しました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：サーバーのテスト計画は彼ではなく顧客によって決定されます！</font><font style="vertical-align: inherit;">PACTはクライアントの期待を記録し、共通のリポジトリー「ブローカー」に格納できます。サーバーはそこから取得し、ビルドごとに実行できます。</font><font style="vertical-align: inherit;">PACTライブラリを使用して、サーバーは終了した契約を判別できます-契約は顧客の期待に応えませんでした。</font><font style="vertical-align: inherit;">したがって、サーバーとクライアント間のすべてのAPIの不一致は、ビルドまたはCIの初期段階で検出されるため、多くのフラストレーションからあなたを救うことができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わりの方法は、手作業によるテストの厳しさや、導入の恐れです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/308/385/2ff/3083852ffe6faa62f826bc9c131027d7.png"><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4ミドルウェアを分離してテストする</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ミドルウェアはシステムのごく一部であり、実行中のExpressサーバーを必要とするため、多くの人がミドルウェアのテストを避けています。これらはすべて誤解です。ミドルウェアは小さいですが、すべてまたはほとんどのクエリに影響し、JSオブジェクト{req、res}を受け取る純粋な関数として簡単にテストできます。このような中間関数をテストするには、それを呼び出して（たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して</font><font style="vertical-align: inherit;">）{req、res}オブジェクトとの相互作用を</font><font style="vertical-align: inherit;">追跡</font><font style="vertical-align: inherit;">し、それらがすべてを正しく実行していることを確認する必要があります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://www.npmjs.com/package/node-mocks-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node-mock-http</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリ</font><font style="vertical-align: inherit;">はさらに進んで、動作を追跡しながら{req、res}オブジェクトにインデックスを付けます。たとえば、彼女はresオブジェクトに割り当てられたHTTPステータスが期待に応えているかどうかを確認できます（以下の例を参照）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Expressソフトウェアのバグ===すべてのリクエストまたはそのほとんどのバグ。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b>    ,         Express-.<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//the middleware we want to test</span>
<span class="hljs-keyword">const</span> unitUnderTest = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./middleware'</span>)
<span class="hljs-keyword">const</span> httpMocks = <span class="hljs-built_in">require</span>(<span class="hljs-string">'node-mocks-http'</span>);
<span class="hljs-comment">//Jest syntax, equivalent to describe() &amp; it() in Mocha</span>
test(<span class="hljs-string">'A request without authentication header, should return http status 403'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> request = httpMocks.createRequest({
    <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
    <span class="hljs-attr">url</span>: <span class="hljs-string">'/user/42'</span>,
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-attr">authentication</span>: <span class="hljs-string">''</span><font></font>
    }<font></font>
  });<font></font>
  <span class="hljs-keyword">const</span> response = httpMocks.createResponse();<font></font>
  unitUnderTest(request, response);<font></font>
  expect(response.statusCode).toBe(<span class="hljs-number">403</span>);<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.5静的分析ツールを使用した評価とリファクタリング</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的分析ツールを使用すると、コードの品質を改善する客観的な方法が提供され、メンテナンスに適した形式でコードを維持できます。静的分析ツールをCIアセンブリに追加して、コードの欠陥が検出されたときに機能しないようにすることができます。従来のリンティングに対するそのようなツールの主な利点は、多数のファイルの観点から品質を評価し（たとえば、重複を判断する）、複雑な分析を実行し（たとえば、コードの複雑さを評価する）、コードの問題の履歴と問題の進展を追跡できることです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sonarqube</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2600以上の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">星</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code Climate</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1500以上の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">星</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">をお勧めし</font><font style="vertical-align: inherit;">ます。投稿者：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キースホリデイ</font></font></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">貧弱なコードを使用すると、スマートな新しいライブラリや最高の機能でも解決できないバグやパフォーマンスの問題が常に発生します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b>   CodeClimate,    :<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c63/a0c/6d2/c63a0c6d207ab1fc67f540db7b2d6259.png"><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.6ノードカオスの準備ができているか確認する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">奇妙なことに、ほとんどのソフトウェアテストはロジックとデータのみに関係しています。ただし、最悪の問題（最小化するのは非常に難しい）がインフラストラクチャで発生します。たとえば、プロセスメモリが過負荷になったときに何が起こるかを確認したことがありますか？またはサーバーまたはプロセスが停止したとき？監視システムは、APIが50％遅く動作し始めたことを理解できますか？このような問題をチェックして最小限に抑えるために、Netflixはカオスエンジニアリング（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaos Engineering</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">概念を開発しました</font><font style="vertical-align: inherit;">。その目的：意識を確実にするとともに、混沌とした状況に対するアプリケーションの安定性をテストするためのフレームワークとツールを提供すること。たとえば、有名なNetflixツールの1つである</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaos monkey</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、サーバーをランダムに強制終了して、サービスが引き続きユーザーにサービスを提供しているかどうかを確認し、1つのサーバーに依存しません（</font><font style="vertical-align: inherit;">ポッドを強制終了する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kube-monkey</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるバージョンのKubernetesもあります</font><font style="vertical-align: inherit;">）。これらのツールはすべてホスティングレベルまたはプラットフォームレベルで機能しますが、純粋なカオスを生成してテストすることもできます。たとえば、ノードプロセスがキャッチされていないエラー、未処理のpromiseエラー、1.7 GBの制限でオーバーロードされたv8メモリを処理する方法を確認するには、またはイベントループが頻繁にブロックされている場合、UXは満足ですか？</font><font style="vertical-align: inherit;">Nodeに関連するすべての無秩序な問題をテストするのに役立つ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node-chaos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（アルファ版）</font><font style="vertical-align: inherit;">を書きました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> マーフィーの法則から身を隠す方法はありません。彼は同情なくあなたを本番で罰します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b> Node-chaos     ,   Node.js,          .<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/39d/46d/fc1/39d46dfc17d7bc4a6d50735681bd1025.png"><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.7グローバルなテストベンチと初期データを避け、各テストに個別にデータを追加する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゴールデンルール（チャプター0）によると、各テストはバインディングを回避するためにデータベース内の独自の行セット内で追加および機能する必要があり、テストを理解しやすくなりました。</font><font style="vertical-align: inherit;">実際には、テスターはしばしばデータベースに初期データ（シード）を入力するテストを実行する前に、このルールに違反します（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">「テストベンチ」とも呼ばれます</font></a><font style="vertical-align: inherit;">）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）生産性を向上させるため。</font><font style="vertical-align: inherit;">また、パフォーマンスは非常に重要なタスクですが、低下する可能性があります（「コンポーネントのテスト」の章を参照）。ただし、テストの複雑さははるかに有害であり、決定を管理する必要がある場合がほとんどです。</font><font style="vertical-align: inherit;">ほとんどすべてのテストケースで、必要なレコードを明示的にデータベースに追加し、それらのみを操作する必要があります。</font><font style="vertical-align: inherit;">パフォーマンスが重要な場合は、妥協案として、情報を変更しないテスト（クエリなど）のみを初期データに入力できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかのテストが失敗し、展開が中止されました。チームは貴重な時間を費やしますが、バグはありますか？</font><font style="vertical-align: inherit;">見てみましょう、くそー、2つのテストが同じ初期データを変更したようです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b> .</b>       -        .<br>
<br>
<pre><code class="javascript hljs">before(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">//adding sites and admins data to our DB. Where is the data? outside. At some external json or migration framework</span>
  <span class="hljs-keyword">await</span> DB.AddSeedDataFromJson(<span class="hljs-string">'seed.json'</span>);<font></font>
});<font></font>
it(<span class="hljs-string">"When updating site name, get successful confirmation"</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">//I know that site name "portal" exists - I saw it in the seed files</span>
  <span class="hljs-keyword">const</span> siteToUpdate = <span class="hljs-keyword">await</span> SiteService.getSiteByName(<span class="hljs-string">"Portal"</span>);
  <span class="hljs-keyword">const</span> updateNameResult = <span class="hljs-keyword">await</span> SiteService.changeName(siteToUpdate, <span class="hljs-string">"newName"</span>);<font></font>
  expect(updateNameResult).to.be(<span class="hljs-literal">true</span>);<font></font>
});<font></font>
it(<span class="hljs-string">"When querying by site name, get the right site"</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">//I know that site name "portal" exists - I saw it in the seed files</span>
  <span class="hljs-keyword">const</span> siteToCheck = <span class="hljs-keyword">await</span> SiteService.getSiteByName(<span class="hljs-string">"Portal"</span>);<font></font>
  expect(siteToCheck.name).to.be.equal(<span class="hljs-string">"Portal"</span>); <span class="hljs-comment">//Failure! The previous test change the name :[</span><font></font>
});<font></font>
</code></pre><br>
<b>  .</b>     ,       .<br>
<br>
<pre><code class="javascript hljs">it(<span class="hljs-string">"When updating site name, get successful confirmation"</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">//test is adding a fresh new records and acting on the records only</span>
  <span class="hljs-keyword">const</span> siteUnderTest = <span class="hljs-keyword">await</span> SiteService.addSite({
    <span class="hljs-attr">name</span>: <span class="hljs-string">"siteForUpdateTest"</span><font></font>
  });<font></font>
  <span class="hljs-keyword">const</span> updateNameResult = <span class="hljs-keyword">await</span> SiteService.changeName(siteUnderTest, <span class="hljs-string">"newName"</span>);<font></font>
  expect(updateNameResult).to.be(<span class="hljs-literal">true</span>);<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<a name="4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクション3：フロントエンドテスト</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1。</font><font style="vertical-align: inherit;">UIを機能から分離</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントロジックのテストに焦点を当てると、ユーザーインターフェイスの詳細がノイズになり、クリーンなデータでテストを実行できるように、削除する必要があります。マークアップから必要なデータを抽出して抽象化し、グラフィック実装との関連性が高すぎないようにし、HTMLとCSSの内部ではなく純粋な情報のみに焦点を当て、干渉するアニメーションをオフにします。インターフェースのレンダリングを避け、ユーザーインターフェースのサーバー側（サービス、アクション、ストレージなど）のみをテストしたくなるかもしれませんが、これは現実を反映しない人工的なテストにつながり、必要なデータが単に到着しない状況を明らかにしませんユーザーインターフェイスに。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> クリーンに処理されたテストデータは10ミリ秒で準備できますが、奇妙で不必要なアニメーションのため、テスト全体は500ミリ秒（100テスト= 1分）続きます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b>    .<br>
<br>
<pre><code class="javascript hljs">test(<span class="hljs-string">'When users-list is flagged to show only VIP, should display only VIP members'</span>, () =&gt; {
  <span class="hljs-comment">// Arrange</span>
  <span class="hljs-keyword">const</span> allUsers = [<font></font>
   { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Yoni Goldberg'</span>, <span class="hljs-attr">vip</span>: <span class="hljs-literal">false</span> }, <font></font>
   { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'John Doe'</span>, <span class="hljs-attr">vip</span>: <span class="hljs-literal">true</span> }<font></font>
  ];<font></font>
<font></font>
  <span class="hljs-comment">// Act</span>
  <span class="hljs-keyword">const</span> { getAllByTestId } = render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UsersList</span> <span class="hljs-attr">users</span>=<span class="hljs-string">{allUsers}</span> <span class="hljs-attr">showOnlyVIP</span>=<span class="hljs-string">{true}/</span>&gt;</span></span>);<font></font>
<font></font>
  <span class="hljs-comment">// Assert - Extract the data from the UI first</span>
  <span class="hljs-keyword">const</span> allRenderedUsers = getAllByTestId(<span class="hljs-string">'user'</span>).map(<span class="hljs-function"><span class="hljs-params">uiElement</span> =&gt;</span> uiElement.textContent);
  <span class="hljs-keyword">const</span> allRealVIPUsers = allUsers.filter(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.vip).map(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.name);<font></font>
  expect(allRenderedUsers).toEqual(allRealVIPUsers); <span class="hljs-comment">//compare data with data, no UI here</span><font></font>
});<font></font>
</code></pre><br>
<b><b> .</b>     UI  .</b><br>
<pre><code class="javascript hljs">test(<span class="hljs-string">'When flagging to show only VIP, should display only VIP members'</span>, () =&gt; {
  <span class="hljs-comment">// Arrange</span>
  <span class="hljs-keyword">const</span> allUsers = [<font></font>
   {<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Yoni Goldberg'</span>, <span class="hljs-attr">vip</span>: <span class="hljs-literal">false</span> }, <font></font>
   {<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'John Doe'</span>, <span class="hljs-attr">vip</span>: <span class="hljs-literal">true</span> }<font></font>
  ];<font></font>
<font></font>
  <span class="hljs-comment">// Act</span>
  <span class="hljs-keyword">const</span> { getAllByTestId } = render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UsersList</span> <span class="hljs-attr">users</span>=<span class="hljs-string">{allUsers}</span> <span class="hljs-attr">showOnlyVIP</span>=<span class="hljs-string">{true}/</span>&gt;</span></span>);<font></font>
<font></font>
  <span class="hljs-comment">// Assert - Mix UI &amp; data in assertion</span>
  expect(getAllByTestId(<span class="hljs-string">'user'</span>)).toEqual(<span class="hljs-string">'[&lt;li data-testid="user"&gt;John Doe&lt;/li&gt;]'</span>);<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2変更される可能性が低い属性を持つHTML要素を要求する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラフィックの変更に耐えられる可能性が高い属性を持つHTML要素をリクエストします。</font><font style="vertical-align: inherit;">たとえば、CSSセレクタではなくフォームラベル。</font><font style="vertical-align: inherit;">要素にそのような属性がない場合は、「test-id-submit-button」などの個別のテスト属性を作成します。</font><font style="vertical-align: inherit;">このアプローチは、設計変更の結果としての失敗からロジックおよび機能テストを保護します。</font><font style="vertical-align: inherit;">さらに、この要素と属性がテストで使用され、削除できないことは、チーム全体にとって明らかです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くのコンポーネント、ロジック、サービスをカバーするログイン機能をテストしたいとします。</font><font style="vertical-align: inherit;">すべてが完全にセットアップされています-スタブ、スパイ、Ajax呼び出しは分離されています。</font><font style="vertical-align: inherit;">すべてが完璧に思えます。</font><font style="vertical-align: inherit;">そして、デザイナーがCSSクラスを「太いボーダー」から「細いボーダー」に変更したため、テストは失敗しました</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b>     ,    .<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// the markup code (part of React component)</span><font></font>
&lt;b&gt;<font></font>
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Badge</span> <span class="hljs-attr">pill</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"fixed_badge"</span> <span class="hljs-attr">variant</span>=<span class="hljs-string">"dark"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">data-testid</span>=<span class="hljs-string">"errorsLabel"</span>&gt;</span>{value}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-comment">&lt;!-- note the attribute data-testid --&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Badge</span>&gt;</span></span><font></font>
&lt;/b&gt;<font></font>
<span class="hljs-comment">// this example is using react-testing-library</span>
  test(<span class="hljs-string">'Whenever no data is passed to metric, show 0 as default'</span>, () =&gt; {
    <span class="hljs-comment">// Arrange</span>
    <span class="hljs-keyword">const</span> metricValue = <span class="hljs-literal">undefined</span>;<font></font>
<font></font>
    <span class="hljs-comment">// Act</span>
    <span class="hljs-keyword">const</span> { getByTestId } = render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dashboardMetric</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{undefined}/</span>&gt;</span></span>);    <font></font>
    <font></font>
    expect(getByTestId(<span class="hljs-string">'errorsLabel'</span>)).text()).toBe(<span class="hljs-string">"0"</span>);<font></font>
  });<font></font>
</code></pre><br>
<b> .</b>   CSS-.<br>
<br>
<pre><code class="javascript hljs">&lt;!-- the markup code (part <span class="hljs-keyword">of</span> React component) --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"metric"</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"d-flex-column"</span>&gt;</span>{value}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span> &lt;!-- what <span class="hljs-keyword">if</span> the designer changes the classs? --&gt;
<span class="hljs-comment">// this exammple is using enzyme</span>
test(<span class="hljs-string">'Whenever no data is passed, error metric shows zero'</span>, () =&gt; {
    <span class="hljs-comment">// ...</span><font></font>
    <font></font>
    expect(wrapper.find(<span class="hljs-string">"[className='d-flex-column']"</span>).text()).toBe(<span class="hljs-string">"0"</span>);<font></font>
  });<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3可能な限り、実際の完全にレンダリングされたコンポーネントでテストする</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズが許容できる場合は、ユーザーが行うように、コンポーネントを外側からテストします。</font><font style="vertical-align: inherit;">インターフェイスを完全に描画し、使用して、期待どおりに動作することを確認します。</font><font style="vertical-align: inherit;">スタブ、部分的または簡略化されたレンダリングは避けてください。そうでなければ、詳細が不足しているため、テストは内部と混合されるため、バグをスキップし、メンテナンスを複雑にします（「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブラックボックステストの遵守</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」の章を参照</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">子コンポーネント（アニメーションなど）の1つがシステムの速度を大幅に低下させるか複雑にする場合は、明示的にスタブに置き換えてみてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記を踏まえて、私はあなたに警告したいと思います：このテクニックは、許容できるサイズの子コンポーネントを含む中小規模のコンポーネントに適しています。</font><font style="vertical-align: inherit;">多数の子コンポーネントを含む完全にレンダリングされたコンポーネントは、テストの失敗（根本原因の分析）の評価を困難にし、動作が遅すぎる可能性があります。</font><font style="vertical-align: inherit;">そのような場合は、そのような厚い親コンポーネントに対していくつかのテストを記述し、その子コンポーネントに対してより多くのテストを記述します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プライベートメソッドを呼び出して内部状態をチェックすることでコンポーネントの内部を調べる場合、コンポーネントの実装をリファクタリングするときに、すべてのテストをリファクタリングする必要があります。</font><font style="vertical-align: inherit;">これには本当に時間とエネルギーがありますか？</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b>        .<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calendar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">static</span> defaultProps = {<span class="hljs-attr">showFilters</span>: <span class="hljs-literal">false</span>}<font></font>
  <font></font>
  render() {<font></font>
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        A filters panel with a button to hide/show filters
        <span class="hljs-tag">&lt;<span class="hljs-name">FiltersPanel</span> <span class="hljs-attr">showFilter</span>=<span class="hljs-string">{showFilters}</span> <span class="hljs-attr">title</span>=<span class="hljs-string">'Choose Filters'</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
    )<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//Examples use React &amp; Enzyme</span>
test(<span class="hljs-string">'Realistic approach: When clicked to show filters, filters are displayed'</span>, () =&gt; {
    <span class="hljs-comment">// Arrange</span>
    <span class="hljs-keyword">const</span> wrapper = mount(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Calendar</span> <span class="hljs-attr">showFilters</span>=<span class="hljs-string">{false}</span> /&gt;</span></span>)<font></font>
<font></font>
    <span class="hljs-comment">// Act</span>
    wrapper.find(<span class="hljs-string">'button'</span>).simulate(<span class="hljs-string">'click'</span>);<font></font>
<font></font>
    <span class="hljs-comment">// Assert</span>
    expect(wrapper.text().includes(<span class="hljs-string">'Choose Filter'</span>));
    <span class="hljs-comment">// This is how the user will approach this element: by text</span><font></font>
})<font></font>
</code></pre><br>
<b> .</b>      .<br>
<br>
<pre><code class="javascript hljs">test(<span class="hljs-string">'Shallow/mocked approach: When clicked to show filters, filters are displayed'</span>, () =&gt; {
    <span class="hljs-comment">// Arrange</span>
    <span class="hljs-keyword">const</span> wrapper = shallow(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Calendar</span> <span class="hljs-attr">showFilters</span>=<span class="hljs-string">{false}</span> <span class="hljs-attr">title</span>=<span class="hljs-string">'Choose Filter'</span>/&gt;</span></span>)<font></font>
<font></font>
    <span class="hljs-comment">// Act</span>
    wrapper.find(<span class="hljs-string">'filtersPanel'</span>).instance().showFilters();
    <span class="hljs-comment">// Tap into the internals, bypass the UI and invoke a method. White-box approach</span><font></font>
<font></font>
    <span class="hljs-comment">// Assert</span>
    expect(wrapper.find(<span class="hljs-string">'Filter'</span>).props()).toEqual({<span class="hljs-attr">title</span>: <span class="hljs-string">'Choose Filter'</span>});
    <span class="hljs-comment">// what if we change the prop name or don't pass anything relevant?</span><font></font>
})<font></font>
</code></pre><br>
</div></div><br>
<h2>3.4          .    </h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどの場合、テストの完了時間は不明です（たとえば、アニメーションにより要素の外観が遅れます）。そのような場合は、眠りに落ちないようにし（たとえば</font></font><code>setTimeOut</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、ほとんどのプラットフォームで提供されているより確定的な方法を使用します。一部のライブラリでは、操作の完了を待機できます（たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cypress cy.request（ 'url'）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。他の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリは、@ Testing-library / DOMのwait（expect（element））メソッド</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、待機</font></a><font style="vertical-align: inherit;">用のAPIを提供します</font><font style="vertical-align: inherit;">。同じAPIのように、遅いリソースのスタブを作成した方がよい場合もあり、応答の瞬間が確定的になったときに、コンポーネントを明示的に再描画できます。眠りに落ちる可能性のある外部コンポーネントに依存している場合は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、時計</font></a><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">早める</font></a><font style="vertical-align: inherit;">ように注意してください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">スリープは、テストの速度を低下させるか、テストを疑わしいものにする（短すぎる期間の完了を待つ必要がある場合）ため、避けるべきパターンです。</font><font style="vertical-align: inherit;">眠りに落ちてポーリングすることを避けられず、テストフレームワークから助けを得られない場合は、たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wait-for-expect</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの半確定的なソリューションを備えたnpmライブラリが役立ちます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">夢が長いと、テストは1桁遅くなります。</font><font style="vertical-align: inherit;">短時間眠りにつくと、テストしたモジュールがタイムリーに応答しなかった場合、テストに合格しません。</font><font style="vertical-align: inherit;">したがって、すべては、脆弱性とパフォーマンスの低下の間の妥協に帰着します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b> E2E API       (Cypress).<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// using Cypress</span>
cy.get(<span class="hljs-string">'#show-products'</span>).click()<span class="hljs-comment">// navigate</span>
cy.wait(<span class="hljs-string">'@products'</span>)<span class="hljs-comment">// wait for route to appear</span>
<span class="hljs-comment">// this line will get executed only when the route is ready</span>
</code></pre><br>
<b>  .  ,  DOM- (@testing-library/dom).</b><br>
<pre><code class="javascript hljs"><span class="hljs-comment">// @testing-library/dom</span>
test(<span class="hljs-string">'movie title appears'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// element is initially not present...</span><font></font>
<font></font>
    <span class="hljs-comment">// wait for appearance</span>
    <span class="hljs-keyword">await</span> wait(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
        expect(getByText(<span class="hljs-string">'the lion king'</span>)).toBeInTheDocument()<font></font>
    })<font></font>
<font></font>
    <span class="hljs-comment">// wait for appearance and return the element</span>
    <span class="hljs-keyword">const</span> movie = <span class="hljs-keyword">await</span> waitForElement(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> getByText(<span class="hljs-string">'the lion king'</span>))<font></font>
})<font></font>
</code></pre><br>
<b> .</b>    .<br>
<br>
<pre><code class="javascript hljs">test(<span class="hljs-string">'movie title appears'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// element is initially not present...</span><font></font>
<font></font>
    <span class="hljs-comment">// custom wait logic (caution: simplistic, no timeout)</span>
    <span class="hljs-keyword">const</span> interval = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> found = getByText(<span class="hljs-string">'the lion king'</span>);
        <span class="hljs-keyword">if</span>(found){<font></font>
            clearInterval(interval);<font></font>
            expect(getByText(<span class="hljs-string">'the lion king'</span>)).toBeInTheDocument();<font></font>
        }<font></font>
        <font></font>
    }, <span class="hljs-number">100</span>);<font></font>
<font></font>
    <span class="hljs-comment">// wait for appearance and return the element</span>
    <span class="hljs-keyword">const</span> movie = <span class="hljs-keyword">await</span> waitForElement(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> getByText(<span class="hljs-string">'the lion king'</span>))<font></font>
})<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.5。</font><font style="vertical-align: inherit;">ネットワークデータ転送の追跡</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何らかのアクティブな監視を使用して、実際のネットワークでのページの読み込みが最適化されていることを確認します。これには、読み込みの遅さや情報のないバンドルなど、ユーザーエクスペリエンスに関連するすべてのタスクが含まれます。市場には十分な適切なツールがあります</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。pingdom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、AWS CloudWatch、または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gcp StackDriver</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの基本的なツール</font><font style="vertical-align: inherit;">は、サーバーが</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">稼働</font></a><font style="vertical-align: inherit;">していて許容可能なSLAレベルで応答しているかどうかを監視するように簡単に設定できます。しかし、この方法では、発生する問題に関する情報がほとんど得られないため、フロントエンド用に設計されたツール（たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lighthouse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">pagespeed）</font></a><font style="vertical-align: inherit;">を見つけることをお勧めします</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、より詳細に分析します。症状に焦点をあてて-直接ユーザエクスペリエンスに影響を与える評価指標：ページの読み込みの期間と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要最小限のデータをレンダリングし</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同様のページが（TTI）対話形式になりどのように迅速として</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。さらに、データ圧縮、最初のバイトを受信するまでの時間、画像の最適化、許容できるDOMサイズ、SSLなどの技術的な理由を追跡したい場合があります。開発では、CIの一部として、およびバトルサーバーとCDNの24時間365日のモードで、広範な監視を使用することをお勧めします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> インターフェイスを開発し、機能テストと複雑なパッケージングに完全に合格した後、CDNの構成に問題があり、ユーザーエクスペリエンスがひどく遅くなっていることがわかったときがっかりします。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b>  Lighthouse   .<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/857/732/c2c/857732c2c3976c167757a9da12d81e05.png"><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.6バックエンドAPIのような制御されていない遅いリソースの代わりにスタブを実行する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（E2Eではなく）基本的なテストを作成するときは、自分が責任を負わないリソース、または制御できないリソースの使用を避け、代わりにスタブを使用します（つまり、模倣します）。</font><font style="vertical-align: inherit;">実際のネットワークAPI呼び出しの代わりに、シミュレーションライブラリを使用します（例：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test doubles）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）API応答をシミュレートします。</font><font style="vertical-align: inherit;">このアプローチの主な利点は、制御不能を取り除くことです。</font><font style="vertical-align: inherit;">API自体のテストまたはステージングは​​非常に安定しておらず、コンポーネントの完全な動作でテストが失敗する場合があります（動作環境はテスト用に設計されておらず、通常はリクエストを抑制します）。</font><font style="vertical-align: inherit;">これにより、コンポーネントの動作が依存するさまざまなAPI動作をシミュレートできます。</font><font style="vertical-align: inherit;">たとえば、目的のデータが見つからない場合や、APIがエラーをスローした場合などです。</font><font style="vertical-align: inherit;">最後に重要なことですが、ネットワーク呼び出しはテストを大幅に遅くします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平均的なテストは数ミリ秒以内に実行され、一般的なAPI呼び出しは100ミリ秒、つまり約20倍続きます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b>    API-.<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// unit under test</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ProductsList</span>(<span class="hljs-params"></span>) </span>{ 
    <span class="hljs-keyword">const</span> [products, setProducts] = useState(<span class="hljs-literal">false</span>)<font></font>
<font></font>
    <span class="hljs-keyword">const</span> fetchProducts = <span class="hljs-keyword">async</span>() =&gt; {
      <span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> axios.get(<span class="hljs-string">'api/products'</span>)<font></font>
      setProducts(products);<font></font>
    }<font></font>
<font></font>
    useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
      fetchProducts();<font></font>
    }, []);<font></font>
<font></font>
  <span class="hljs-keyword">return</span> products ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{products}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-testid</span>=<span class="hljs-string">'no-products-message'</span>&gt;</span>No products<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// test</span>
test(<span class="hljs-string">'When no products exist, show the appropriate message'</span>, () =&gt; {
    <span class="hljs-comment">// Arrange</span>
    nock(<span class="hljs-string">"api"</span>)<font></font>
            .get(<span class="hljs-string">`/products`</span>)<font></font>
            .reply(<span class="hljs-number">404</span>);<font></font>
<font></font>
    <span class="hljs-comment">// Act</span>
    <span class="hljs-keyword">const</span> {getByTestId} = render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductsList</span>/&gt;</span></span>);<font></font>
<font></font>
    <span class="hljs-comment">// Assert</span>
    expect(getByTestId(<span class="hljs-string">'no-products-message'</span>)).toBeTruthy();<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.7システム全体をカバーするエンドツーエンドのテストをほとんど使用しない</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E2E（エンドツーエンド、エンドツーエンドのテスト）には通常、ブラウザのUIを介したテストのみが含まれます（3.6章を参照）。他のケースでは、バックエンドを含むシステム全体をカバーするテストについて話している。 2番目の種類のテストは、データ交換スキームの誤解が原因で発生する可能性があるフロントエンドとバックエンド間の統合バグをカバーするため、非常に重要です。さらに、このようなテストは、バックエンド間の統合の問題（たとえば、マイクロサービスAが誤ったメッセージをマイクロサービスBに送信するなど）を特定し、デプロイメントの障害を検出するための効果的な方法です。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cypress</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Pupeteerの</font></a><font style="vertical-align: inherit;">ようなUIフレームワークほど便利で高度なエンドツーエンドのテストフレームワークは</font><font style="vertical-align: inherit;">あり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このようなテストの欠点は、多くのコンポーネントを含む環境を構成するコストが高く、その脆弱性です。50個のマイクロサービスがあり、そのうちの1つが失敗すると、エンドツーエンドのテスト全体が失敗します。したがって、この手法に関与せずに、そのようなテストを10個まで適用してください。それにもかかわらず、少数のエンドツーエンドのテストでさえ、おそらくそれらが意図する問題、つまりデプロイメントと統合のエラーが明らかになるでしょう。本番環境と同様のステージング環境でテストを実行することをお勧めします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UIは、バックエンドによって返されるペイロード（UIが機能するデータスキーム）が期待されるものと非常に異なることが判明するのが遅すぎるまで、その機能のテストに多くの労力を費やすことができます。</font></font><br>
<br>
<h2>3.8           </h2><br>
<b> .</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックエンドをカバーし、API呼び出しに有効なユーザートークンを使用するエンドツーエンドのテストでは、要求ごとにユーザーが作成されてログインするレベルでテストを分離する必要はありません。代わりに、テストを実行する前に（一度だけ）1回だけログインし、トークンをローカルストレージに保存して、後続のリクエストで使用します。一見すると、これはテストの重要な原則の1つに違反します。リソースに縛られずにテストの自律性を維持することです。これは正当な懸念事項ですが、エンドツーエンドテストの主な問題はパフォーマンスです。各テストの開始前に1つまたは3つのAPIリクエストを作成すると、実行時間が大幅に増加する可能性があります。資格情報を再利用しても、同じユーザーアカウントで作業する必要があるわけではありません。ユーザーレコードに依存している場合（たとえば、支払い履歴をテストする場合）、レコードの生成がテストの一部であることを確認し、それらを他のテストと共有しないでください。また、バックエンドをシミュレートできることも覚えておいてください。テストがフロントエンド向けに設計されている場合は、それらを分離してバックエンドAPIをシミュレートすることをお勧めします（3.6章を参照）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200個のテストスクリプトがあり、ログイン手順に100ミリ秒かかるとすると、ログインに20秒しかかかりません。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b>      (before-all),       (before-each) (,   Cypress).<br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   Cypress</a>.<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> authenticationToken;<font></font>
<font></font>
<span class="hljs-comment">// happens before ALL tests run</span>
before(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
  cy.request(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'http://localhost:3000/login'</span>, {
    <span class="hljs-attr">username</span>: Cypress.env(<span class="hljs-string">'username'</span>),
    <span class="hljs-attr">password</span>: Cypress.env(<span class="hljs-string">'password'</span>),<font></font>
  })<font></font>
  .its(<span class="hljs-string">'body'</span>)<font></font>
  .then(<span class="hljs-function">(<span class="hljs-params">responseFromLogin</span>) =&gt;</span> {<font></font>
    authenticationToken = responseFromLogin.token;<font></font>
  })<font></font>
})<font></font>
<font></font>
<span class="hljs-comment">// happens before EACH test</span>
beforeEach(<span class="hljs-function"><span class="hljs-params">setUser</span> =&gt;</span> () {<font></font>
  cy.visit(<span class="hljs-string">'/home'</span>, {<font></font>
    onBeforeLoad (win) {<font></font>
      win.localStorage.setItem(<span class="hljs-string">'token'</span>, <span class="hljs-built_in">JSON</span>.stringify(authenticationToken))<font></font>
    },<font></font>
  })<font></font>
})<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.9サイトのレイアウトに単純に合格する1つのエンドツーエンドの煙テストを使用する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発中の本番環境の監視とパフォーマンスの監視には、すべてまたはほとんどのページで実行される1つのエンドツーエンドのテストを使用して、すべてが機能することを確認します。このようなテストは、作成と保守が非常に簡単なため非常に便利ですが、機能やネットワークの障害などの障害や、展開中の問題を検出できます。他の種類の煙のテストとヘルスチェックはそれほど信頼でき、包括的ではありません。一部の運用チームは、本番環境のメインページにpingを送信するだけであり、多くの統合テストを実行する開発者は、パッケージとブラウザに問題を見つけません。もちろん、煙のテストは機能テストに代わるものではなく、高速の煙検知器としてのみ機能します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてが完璧に見える可能性があり、すべてのテストに合格し、本番環境でのステータスチェックも肯定的です。</font><font style="vertical-align: inherit;">また、支払いコンポーネントにはパッケージに問題があり、/支払いルートのみがレンダリングされません。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b> Smoke-    .<br>
<br>
<pre><code class="javascript hljs">it(<span class="hljs-string">'When doing smoke testing over all page, should load them all successfully'</span>, () =&gt; {
    <span class="hljs-comment">// exemplified using Cypress but can be implemented easily</span>
    <span class="hljs-comment">// using any E2E suite</span>
    cy.visit(<span class="hljs-string">'https://mysite.com/home'</span>);<font></font>
    cy.contains(<span class="hljs-string">'Home'</span>);<font></font>
    cy.contains(<span class="hljs-string">'https://mysite.com/Login'</span>);<font></font>
    cy.contains(<span class="hljs-string">'Login'</span>);<font></font>
    cy.contains(<span class="hljs-string">'https://mysite.com/About'</span>);<font></font>
    cy.contains(<span class="hljs-string">'About'</span>);<font></font>
  })<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.10共有ライブドキュメントとしてテストを開く</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションの信頼性を高めることに加えて、テストはライブドキュメントの役割を果たします。テストは、技術的ではない言語で意図的に「話す」ため、適切なツールを使用して製品とユーザーエクスペリエンスに近いため、開発者と顧客間のコミュニケーション手段としてテストを使用できます。たとえば、一部のフレームワークでは、プロセスと期待（つまり、テスト計画）を人間が読める言語で記述できるため、プロダクトマネージャーを含むすべての関心のある参加者は、実際の技術タスクに変わるテストを読み取り、承認し、共同作業できます。この手法は、顧客が共通言語で適合基準を定義できるため、受け入れテストとして知られています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行動テスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も純粋な形で。</font><font style="vertical-align: inherit;">人気のフレームワークの1つである、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptのテイストを備えたCucumberで使用できます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">また、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StoryBookを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用すると、UIコンポーネントをグラフィックカタログの形式で表示して、各コンポーネントのさまざまな状態を確認し（たとえば、グリッドをフィルターありとなしで表示、グリッドを複数行ありとなしで表示など）、理解することができます。これらの条件を開始する方法。</font><font style="vertical-align: inherit;">製品エンジニアにとっても興味深いかもしれませんが、基本的にフレームワークは、これらのコンポーネントを使用する開発者向けのライブドキュメントとして機能します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストに多大な労力を費やしたので、大きな反響が得られなかったのは残念です。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b>        cucumber-js.<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// this is how one can describe tests using cucumber: plain language that allows anyone to understand and collaborate</span><font></font>
<font></font>
<span class="hljs-attr">Feature</span>: Twitter <span class="hljs-keyword">new</span> tweet<font></font>
 <font></font>
  I want to tweet something <span class="hljs-keyword">in</span> Twitter<font></font>
  <font></font>
  @focus<font></font>
  <span class="hljs-attr">Scenario</span>: Tweeting <span class="hljs-keyword">from</span> the home page<font></font>
    Given I open Twitter home<font></font>
    Given I click on <span class="hljs-string">"New tweet"</span> button<font></font>
    Given I type <span class="hljs-string">"Hello followers!"</span> <span class="hljs-keyword">in</span> the textbox <font></font>
    Given I click on <span class="hljs-string">"Submit"</span> button<font></font>
    Then I see message <span class="hljs-string">"Tweet saved"</span>
</code></pre><br>
<b>  .</b>   Storybook  ,      .<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/135/d4c/6c5/135d4c6c5dcf2758cfd90bc20dbad939.png"><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.11自動ツールで視覚的な問題を特定する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーインターフェースを変更するたびにスクリーンショットを撮る自動ツールを設定し、コンテンツの重複やシフトなどの視覚的な問題を特定します。したがって、必要なデータを準備するだけでなく、それらを適切に表示することもできます。この手法はめったに使用されず、機能テストを行う傾向があります。ただし、ユーザーは主に視覚的に、さまざまなデバイスで製品を評価するため、インターフェイスの醜いバグを見逃しがちです。一部の無料ツールでは、スクリーンショットを簡単に生成して保存できるため、後で人が表示できます。小規模なアプリケーションの場合はこれで十分ですが、他の手動テストと同様に、プロジェクトの変更ごとに人間の介入が必要です。一方、明確な定義がないため、インターフェースの問題を自動的に特定することは非常に困難です。古いバージョンのUIと最新の変更を比較する問題を解決し、相違点を検索すると、「視覚的な回帰」に役立ちます。フリーまたはオープンソースのツール（たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、PhantomCSS）が、それはそれらを設定するのに長い時間がかかることがあります。</font><font style="vertical-align: inherit;">商用ツール（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Applitools</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perci.ioなど</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の方が設定が便利であり、インターフェース、アラート、「ビジュアルノイズ」を抑制したスマートキャプチャ（バナー、アニメーション）、さらにはDOM / CSSの変更を分析するための機能を備えています。問題。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優れたコンテンツを表示し、すべてのテストに合格したページをすぐに読み込んでも、コンテンツ領域の半分が非表示になっているページはどの程度優れていますか？</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b> .</b>   :  ,   .<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b00/b82/ad7/b00b82ad77c637eb6e00742f38780216.png"><br>
<br>
<b>  </b>.  wraith      UI.<br>
<br>
<pre><code class="javascript hljs">​# Add <span class="hljs-keyword">as</span> many domains <span class="hljs-keyword">as</span> necessary. Key will act <span class="hljs-keyword">as</span> a label​<font></font>
<font></font>
<span class="hljs-attr">domains</span>:<font></font>
  english: <span class="hljs-string">"http://www.mysite.com"</span>​<font></font>
<font></font>
​# Type screen widths below, here are a couple <span class="hljs-keyword">of</span> examples​<font></font>
<font></font>
<span class="hljs-attr">screen_widths</span>:<font></font>
<font></font>
  - <span class="hljs-number">600</span>​<font></font>
  - <span class="hljs-number">768</span>​<font></font>
  - <span class="hljs-number">1024</span>​<font></font>
  - <span class="hljs-number">1280</span>​<font></font>
<font></font>
<font></font>
​# Type page URL paths below, here are a couple <span class="hljs-keyword">of</span> examples​
<span class="hljs-attr">paths</span>:<font></font>
  about:<font></font>
    path: /about<font></font>
    <span class="hljs-attr">selector</span>: <span class="hljs-string">'.about'</span>​
  <span class="hljs-attr">subscribe</span>:<font></font>
      selector: <span class="hljs-string">'.subscribe'</span>​
    <span class="hljs-attr">path</span>: /subscribe
</code></pre><br>
</div></div><br>
<a name="5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクション4：テストパフォーマンス評価</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1品質を確保するために十分なカバレッジ（〜80％）を提供する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストの目的は、迅速に開発するための十分な自信を得ることです。テストするコードが多いほど、チームは自信を持ちます。カバレッジは、テストに使用できるコードの行数（ブランチ、式など）です。どの範囲が十分と見なされますか？明らかに、10〜30％は小さすぎてアセンブリを正しくできません。 100％は高すぎるだけでなく、注意をコードの重要な部分からそのエキゾチックなセクションに移す可能性があります。コーティングの適切性は多くの要因に依存します。たとえば、アプリケーションのタイプに応じて、新世代のエアバス定期旅客機用のソフトウェアを作成する場合は、100％のカバー率が必要です。漫画会社のサイトの場合、50％は多すぎます。ほとんどのテスト愛好家は、必要な適用範囲はコンテキストに依存すると信じていますが、それらの多くは、経験的な数を80％と呼んでいます（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファウラー：「80年代または90年代後半」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、ほとんどのアプリケーションに適していると思われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒント：カバレッジしきい値（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jest</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">に達するように継続的インテグレーション（CI）を構成</font><font style="vertical-align: inherit;">し、この標準を満たさないアセンブリでの作業を停止できます。以下に示すように、各コンポーネントのしきい値を設定することもできます。また、ビルドカバレッジの減少を決定することを検討してください（新しいコードのカバレッジが低い場合）。これにより、開発者はテストするコードの量を増やすか、少なくとも維持する必要があります。一般的に、カバレッジは数値的な指標にすぎず、テストの信頼性を評価するにはそれだけでは十分ではありません。以下に示すように、このメトリックは混乱する可能性があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信頼と数字は密接に関連しています。</font><font style="vertical-align: inherit;">ほとんどのシステムをテストしたかどうかわからない場合は、心配することになります。</font><font style="vertical-align: inherit;">そして恐れはあなたの仕事を遅くします。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>    .</b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d94/db1/8bf/d94db18bf89f833800bf8234c40f095c.png"><br>
<br>
<b>  </b>.       (  Jest).<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b97/d73/d8b/b97d73d8b66e627b8fee40d9fa940d7f.png"><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2カバレッジレポートを分析して、未テストの領域やその他の奇妙な要素を特定する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかの問題は気付かれず、従来のツールでは特定するのが困難です。</font><font style="vertical-align: inherit;">これらはバグではなく、アプリケーションの異常な動作であり、望ましくない影響を与える可能性があります。</font><font style="vertical-align: inherit;">たとえば、コードの一部の領域が呼び出されない、またはめったに呼び出されないことがよくあります。</font><font style="vertical-align: inherit;">クラスだと思った</font></font><code>PricingCalculator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは常に商品の価格を設定しますが、データベースに10,000の商品があり、販売数が多い場合はまったく呼び出されないことがわかります。カバレッジレポートは、アプリケーションが意図したとおりに動作するかどうかを理解するのに役立ちます。</font><font style="vertical-align: inherit;">さらに、レポートは、テストされていないコードのセクションを識別するのに役立ちます。</font><font style="vertical-align: inherit;">80％のカバレッジの知識は、重要な領域がカバーされているかどうかを示しません。</font><font style="vertical-align: inherit;">レポートの生成は簡単です。本番環境でのテストの追跡またはテスト実行中にアプリケーションを開始するだけで、各コードが呼び出された頻度を示す多色レポートをお楽しみいただけます。</font><font style="vertical-align: inherit;">そして、時間をかけて分析すれば、興味深いものを見つけることができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストされていないコードの部分がわからない場合、問題が発生する可能性のある場所がわかりません。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b> .</b>      ?   ,        QA       . :     , -   . ,   -    API  .</div></div><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/18e/7d7/2dc/18e7d72dcf5440fe964269002529b69c.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3変異テストを使用した論理カバレッジの測定</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの場合、カバレッジの従来の測定基準は誤りです。100％のカバレッジを示すことができますが、単一の関数では正しい答えが得られません。</font><font style="vertical-align: inherit;">どうして？</font><font style="vertical-align: inherit;">指標はテストでアクセスされたコードの行数を測定するだけで、実際にテストされたかどうかはチェックしません。</font><font style="vertical-align: inherit;">つまり、メトリックは回答の正確さをチェックしません。</font><font style="vertical-align: inherit;">まるで、誰かが出張に行き、帰国時にパスポートにスタンプを見せたかのようです。タスクが完了したことを証明するのではなく、その人が複数の空港やホテルを訪れたことを証明するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変異テストは、単にVISITEDではなく、実際にテストされたコードの量を評価するのに役立ちます。</font><font style="vertical-align: inherit;">これを行うには、非常に便利に実装された</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stryker</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> JavaScriptライブラリが役立ちます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼女は意図的にコードを変更し、「バグを挿入」します。</font><font style="vertical-align: inherit;">たとえば、コード</font></font><code>newOrder.price===0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はに変わり</font></font><code>newOrder.price!=0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">このような「バグ」は突然変異と呼ばれます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、ライブラリがテストを実行し、テストが成功した場合は問題があります。テストはバグを検出する機能を実行せず、変異は残りました。</font><font style="vertical-align: inherit;">テストが失敗した場合、すべてが正常であり、突然変異は破壊されました。</font></font><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての突然変異が破壊されていることがわかっている場合は、従来の報道に自信が持て、同じ時間を費やすことになります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">85％のカバレッジとは、コード内のバグの85％がテストによって検出されることを誤解しているでしょう。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b> .</b>  100 %,  0 %.<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addNewOrder</span>(<span class="hljs-params">newOrder</span>) </span>{<font></font>
    logger.log(<span class="hljs-string">`Adding new order <span class="hljs-subst">${newOrder}</span>`</span>);<font></font>
    DB.save(newOrder);<font></font>
    Mailer.sendMail(newOrder.assignee, <span class="hljs-string">`A new order was places <span class="hljs-subst">${newOrder}</span>`</span>);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> {<span class="hljs-attr">approved</span>: <span class="hljs-literal">true</span>};<font></font>
}<font></font>
<font></font>
it(<span class="hljs-string">"Test addNewOrder, don't use such test names"</span>, () =&gt; {<font></font>
    addNewOrder({<span class="hljs-attr">asignee</span>: <span class="hljs-string">"John@mailer.com"</span>,<span class="hljs-attr">price</span>: <span class="hljs-number">120</span>});<font></font>
});<span class="hljs-comment">//Triggers 100% code coverage, but it doesn't check anything</span>
</code></pre><br>
<b>  .</b> Stryker reports,   ,       ().<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/880/047/5ed/8800475ed27d8c632aa2fb7a0372da68.png"><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4テストリンターによるテスト問題の防止</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードテストパターンを分析し、問題を特定するために、ESLintプラグインのセットが作成されました。</font><font style="vertical-align: inherit;">たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eslint-plugin-mochaは</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、テストが（式の子ではなく）グローバルレベルで動作する</font></font><code>describe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、または</font><font style="vertical-align: inherit;">すべてのテストが正常にパスするという誤った保証につながる可能性がある何かを</font><font style="vertical-align: inherit;">テストが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見逃した</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合に警告します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eslint-plugin-jest</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、テストで何も確認されなかった場合（つまり、何も確認されなかった場合）に警告することができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">90％のカバレッジとすべてのグリーンテストを見ると、多くのテストでは何も確認されないか、まったく見落とされていることに気付くまで、幅広く笑顔になります。</font><font style="vertical-align: inherit;">そのような誤ったテストの後、あなたは何も運用に入れなかったことを望みます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b> .</b>    ,  ,   .<br>
<br>
<pre><code class="javascript hljs">describe(<span class="hljs-string">"Too short description"</span>, () =&gt; {
  <span class="hljs-keyword">const</span> userToken = userService.getDefaultToken() <span class="hljs-comment">// *error:no-setup-in-describe, use hooks (sparingly) instead</span>
  it(<span class="hljs-string">"Some description"</span>, () =&gt; {});<span class="hljs-comment">//* error: valid-test-description. Must include the word "Should" + at least 5 words</span><font></font>
});<font></font>
<font></font>
it.skip(<span class="hljs-string">"Test name"</span>, () =&gt; {<span class="hljs-comment">// *error:no-skipped-tests, error:error:no-global-tests. Put tests only under describe or suite</span>
  expect(<span class="hljs-string">"somevalue"</span>); <span class="hljs-comment">// error:no-assert</span><font></font>
});<font></font>
<font></font>
it(<span class="hljs-string">"Test name"</span>, () =&gt; {*<span class="hljs-comment">//error:no-identical-title. Assign unique titles to tests</span><font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<a name="6"></a><h1> 5: CI    </h1><br>
<h2>5.1      ,     </h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンターは無料のランチです。 5分間のセットアップ後、コードを保護し、コードを入力すると重大な問題を特定する無料のオートパイロットが手に入ります。リンティングが（セミコロンではなく）一種の美容上の改善だった時代は終わりました。今日、リンターはシステムによって正しく発行されなかったエラーをキャッチして情報を失う可能性があります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESLint標準</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Airbnbスタイル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの基本ルールセットに</font><font style="vertical-align: inherit;">、専用のリンターを追加できます。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eslint-plugin-chai-expect</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、何も失敗しないテストを定義できます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eslint-plugin-promise</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は未解決の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">プロミス</font></a><font style="vertical-align: inherit;">を判別でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">（コードは実行を継続しません）。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eslint-plugin-security</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DOS攻撃で使用できる貪欲な正規表現を検出できます。</font><font style="vertical-align: inherit;">また、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eslint-plugin-you-dont-need-lodash-underscore</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、V8のメインメソッドの一部であるライブラリのメソッドをコードが使用している場合などに警告することができ</font></font><code>Lodash._map(…)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バトルサーバーが落ちる雨の日を想像してください。ログにはエラーがありません。</font><font style="vertical-align: inherit;">何が起こっていますか？</font><font style="vertical-align: inherit;">エラーではないオブジェクトがコードによってスローされ、スタックトレースが失われただけです。</font><font style="vertical-align: inherit;">壁に頭をぶつけるのにふさわしい理由です。</font><font style="vertical-align: inherit;">そして、そのようなタイプミスを決定するリンターのセットアップに5分間費やした場合、1日で節約できます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b> .</b>   ,        .  , ESLint   production-.<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2ec/386/b94/2ec386b943b21f0dee093e6c50e5ae75.png"><br>
</div></div><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2開発者向けのローカル継続的統合によりフィードバックループを短縮する</font></font></h1><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト、リンティング、脆弱性テストなどの形で徹底した品質分析と組み合わせてCIを使用していますか？開発者がこのパイプラインをローカルで実行して、フィードバックをすぐに受け取り</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、サイクル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を短縮できるように支援</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">します</font></a><font style="vertical-align: inherit;">。何のために？効果的なテストプロセスは、（1）試行-&gt;（2）フィードバック-&gt;（3）リファクタリングという多くの反復サイクルで構成されます。フィードバックが高速であるほど、開発者が実行できる各モジュールの改善の反復が多くなり、結果が向上します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィードバックが遅れて1日で改善できる数が少ない場合、チームは別のトピック、タスク、またはモジュールに移動し、フィードバックが最終的に到着したモジュールを完成させる準備ができていない可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のCIベンダー（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CircleCIローカルCLIなど</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）では、上記のパイプラインをローカルで実行できます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wallaby</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの一部の商用ツール</font><font style="vertical-align: inherit;">は、開発プロトタイプの形で（所属なしで）貴重な開発データを提供します。または、npmスクリプトをpackage.jsonに追加して、品質管理に関連するすべてのコマンド（たとえば、テスト、lint、脆弱性）を実行することもできます。ツールの1つに障害が発生した場合にゼロ以外の終了コードを並列化するには、のようなツールを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同時に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用できます</font><font style="vertical-align: inherit;">。開発者がすぐにフィードバックを得るには、1つのコマンドを呼び出すだけです。</font></font><code>npm run quality</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">品質管理に失敗した場合は、githookでコミットをキャンセルすることを検討してください（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハスキーが役立ちます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを受け取った翌日に品質管理の結果が出ると、テストは開発プロセスの不可欠な部分でなくなり、形式に変わります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b> Npm-,   ,  ,        .<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"inspect:sanity-testing"</span>: <span class="hljs-string">"mocha **/**--test.js --grep \"sanity\""</span>,
    <span class="hljs-string">"inspect:lint"</span>: <span class="hljs-string">"eslint ."</span>,
    <span class="hljs-string">"inspect:vulnerabilities"</span>: <span class="hljs-string">"npm audit"</span>,
    <span class="hljs-string">"inspect:license"</span>: <span class="hljs-string">"license-checker --failOn GPLv2"</span>,
    <span class="hljs-string">"inspect:complexity"</span>: <span class="hljs-string">"plato ."</span>,<font></font>
<font></font>
    <span class="hljs-string">"inspect:all"</span>: <span class="hljs-string">"concurrently -c \"bgBlue.bold,bgMagenta.bold,yellow\" \"npm:inspect:quick-testing\" \"npm:inspect:lint\" \"npm:inspect:vulnerabilities\" \"npm:inspect:license\""</span><font></font>
  },<font></font>
  <span class="hljs-string">"husky"</span>: {
    <span class="hljs-string">"hooks"</span>: {
      <span class="hljs-string">"precommit"</span>: <span class="hljs-string">"npm run inspect:all"</span>,
      <span class="hljs-string">"prepush"</span>: <span class="hljs-string">"npm run inspect:all"</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3本番ミラーでエンドツーエンドのテストを実行する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンドツーエンドのテストは、CIパイプラインの主な問題です。関連するすべてのクラウドサービスを使用して、同一の短期ミラーをオンザフライで作成することは、面倒で費用がかかる場合があります。最善の妥協</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-Docker-compose</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、単純なテキストを使用して、同じコンテナーで隔離された環境を作成できます。同時に、サーバーテクノロジ（ネットワーク、展開モデル）は実際の運用環境とは異なります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AWSローカル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">追加して</font><font style="vertical-align: inherit;">、実際のAWSサービスのスタブを操作できます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非サーバーモード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で複数のフレームワーク</font><font style="vertical-align: inherit;">を実行する場合</font><font style="vertical-align: inherit;">、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">サーバー</font></a><font style="vertical-align: inherit;">レスと</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AWS SAM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して、</font><font style="vertical-align: inherit;">ローカルでFaasコードを呼び出すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの新しいソリューションがすでに市場に出回っていますが、巨大なKubernetesエコシステムは、ローカルおよびCIミラーを作成するための標準的な便利なツールをまだ選択していません。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minikube</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroK8s</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などのツールを使用して「最小化されたKubernetes」を実行できます。</font><font style="vertical-align: inherit;">これらの</font><font style="vertical-align: inherit;">ツールは、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">実際の</font></a><font style="vertical-align: inherit;">ツール</font><font style="vertical-align: inherit;">と似ており、オーバーヘッドが少なくて済みます。または、リモートの「実際のKubernetes」を使用してテストできます。一部のCIプロバイダー（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codefreshなど</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は、Kubernetes環境とネイティブに統合されているため、実際のシステムでCIパイプラインを簡単に実行できます。その他のプロバイダーでは、リモート環境でスクリプトを実行できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 製品とテストで異なるテクノロジーを使用するには、2つの展開モデルのサポートが必要であり、開発チームと運用チームの分離につながります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b></b>: CI-,     Kubernetes- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">(Dynamic-environments Kubernetes</a>)<br>
<br>
<pre><code class="javascript hljs">deploy:<font></font>
stage: deploy<font></font>
<span class="hljs-attr">image</span>: registry.gitlab.com/gitlab-examples/kubernetes-deploy
<span class="hljs-attr">script</span>:<font></font>
- ./configureCluster.sh $KUBE_CA_PEM_FILE $KUBE_URL $KUBE_TOKEN<font></font>
- kubectl create ns $NAMESPACE<font></font>
- kubectl create secret -n $NAMESPACE docker-registry gitlab-registry --docker-server=<span class="hljs-string">"$CI_REGISTRY"</span> --docker-username=<span class="hljs-string">"$CI_REGISTRY_USER"</span> --docker-password=<span class="hljs-string">"$CI_REGISTRY_PASSWORD"</span> --docker-email=<span class="hljs-string">"$GITLAB_USER_EMAIL"</span><font></font>
- mkdir .generated<font></font>
- echo <span class="hljs-string">"$CI_BUILD_REF_NAME-$CI_BUILD_REF"</span>
- sed -e <span class="hljs-string">"s/TAG/$CI_BUILD_REF_NAME-$CI_BUILD_REF/g"</span> templates/deals.yaml | tee <span class="hljs-string">".generated/deals.yaml"</span><font></font>
- kubectl apply --namespace $NAMESPACE -f .generated/deals.yaml<font></font>
- kubectl apply --namespace $NAMESPACE -f templates/my-sock-shop.yaml<font></font>
<span class="hljs-attr">environment</span>:<font></font>
name: test-<span class="hljs-keyword">for</span>-ci
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.4テスト実行の並列化</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてが正しく行われていれば、テストは24時間体制の友人になり、ほぼ即座にフィードバックを提供します。</font><font style="vertical-align: inherit;">実際には、1つのスレッドでプロセッサによって制限された500ユニットテストの実行には、非常に時間がかかる場合があります。</font><font style="vertical-align: inherit;">幸いなことに、現代のテストランナーとCIのプラットフォーム（のような</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">冗談</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVA、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モカの拡張機能</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）複数のプロセスにわたってテストを並列化できるため、フィードバックを大幅に高速化できます。</font><font style="vertical-align: inherit;">一部のCIベンダーは、コンテナー全体でテストを並列化します（！）。これにより、フィードバックループがさらに短縮されます。</font><font style="vertical-align: inherit;">複数のプロセス間でローカルに並列化するか、複数のマシンを使用するクラウドベースのCLIで並列化するかは関係ありません。これらはすべて異なるプロセスで実行できるため、テストの自律性が必要です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストの関連性を減らすための優れた方法は、次の機能のプログラミングをすでに開始しているときに、新しいコードを送信してから1時間後にテスト結果を取得することです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b> Mocha parallel  Jest    Mocha    (<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">JavaScript Test-Runners Benchmark</a>)<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d87/ff4/d2e/d87ff4d2e1664df527d8a69d4403e8e9.png"><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.5ライセンスと盗用をチェックして法的な問題を回避する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おそらく、ライセンスと盗用に関する問題は、現在のあなたにはあまり関係ありません。</font><font style="vertical-align: inherit;">しかし、この質問を10分以内に閉じないでください。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライセンスチェック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">盗用チェック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（無料プランで商用）の</font><font style="vertical-align: inherit;">ような一連のnpmパッケージをCIコンテナーに簡単に埋め込んで、</font><font style="vertical-align: inherit;">制限付きライセンスの依存関係や、Stackoveflowから引き裂かれ、著作権を明らかに侵害しているコードの有無を分析できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残念ながら、開発者は不適切なライセンスのパッケージを使用したり、商用コードをコピーしたりできます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>  .</b><br>
<pre><code class="javascript hljs"><span class="hljs-comment">//install license-checker in your CI environment or also locally</span><font></font>
npm install -g license-checker<font></font>
<font></font>
<span class="hljs-comment">//ask it to scan all licenses and fail with exit code other than 0 if it found unauthorized license. The CI system should catch this failure and stop the build</span><font></font>
license-checker --summary --failOn BSD<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/09b/b9b/2ad/09bb9b2ad230b17b0006bd137f480606.png"><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.6脆弱性のある依存関係を常に監視する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expressなどの最も尊敬される依存関係でさえ、既知の脆弱性があります。</font><font style="vertical-align: inherit;">これは、コミュニティが作成した</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">npm audit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などのツールや、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">snyk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの商用ツールを使用して</font><font style="vertical-align: inherit;">簡単に処理できます</font><font style="vertical-align: inherit;">（コミュニティの無料バージョンもあります）。</font><font style="vertical-align: inherit;">ビルドするたびにCIから呼び出すことができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特殊なツールを使用せずにコードをクリーンに保つには、新しい脅威に関する公開を常に監視する必要があります。</font><font style="vertical-align: inherit;">これはとても疲れます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>:</b>   NPM Audit<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a89/b1a/ed3/a89b1aed3ab2301c3f4d077e0a259c60.png"><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.7依存関係の更新を自動化する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yarnとnpmのpackage-lock.jsonには大きな困難が伴います（地獄への道は意図的です）：デフォルトでは、パッケージは更新を受け取りません。チームが</font></font><code>npm install</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">コマンドを使用して多くの新しいデプロイメントを起動し</font></font><code>npm update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ても、更新はありません。最良のケースでは、無関係なバージョンのパッケージがあり、最悪の場合はコードの脆弱性です。チームは現在、package.jsonを手動で更新したり、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ncu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などのツールを実行したりする開発者の好意と記憶に依存してい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
依存関係の最も信頼できるバージョンの取得を自動化することをお勧めしますが、理想的なソリューションはありません。 2つの可能なアプローチがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CIは、のようなツール使用して、絶対依存関係を持つアセンブリ元に戻すことができ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、NPM古い</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはNPM-チェックインのアップデート（NCU）を。</font><font style="vertical-align: inherit;">これにより、開発者は依存関係を更新する必要があります。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードをスキャンして、更新された依存関係を持つプル要求を自動的に送信する商用ツールを使用できます。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、問題は残っています：依存関係更新ポリシーはどうあるべきですか？</font><font style="vertical-align: inherit;">各パッチで更新するのはコストがかかりすぎ、メジャーリリースで更新すると不安定なバージョンが生成される可能性があります（多くのパッケージでは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eslint-scopeインシデントの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例にあるように、リリース後の最初の日に依存関係が見つかります</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">効果的なアップグレードポリシーには、「移行期間」が必要な場合があります。いくつかのバージョンのコードが遅れるようにします</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最新</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローカルコピーが古いと判断する前（たとえば、ローカルバージョンは1.3.1で、リポジトリ内のバージョンは1.3.8です）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">著者によってリスクのあるものとして明確にマークされているパッケージは、本番稼働中です。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b></b>:  ,       ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">ncu</a>     CI-.<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c09/9c2/640/c099c264012f534b4bf8dc8ef83d2f4b.png"><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.8ノード以外のCIに関するその他のヒント</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事は、Nodeに関連する、またはNodeで示されるテストのヒントについてです。</font><font style="vertical-align: inherit;">この章では、いくつかの注目すべきノードのヒントを紹介します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣言的な構文を使用します。</font><font style="vertical-align: inherit;">ほとんどのベンダーにとって、これが唯一のオプションですが、古いバージョンのJenkinsではコードまたはインターフェースを使用できます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネイティブのDockerサポートを備えたベンダーを選択してください。</font></font><br>
</li>
<li>    ,  .     .   smoke-,       (, ,  )       .<br>
</li>
<li> ,       ,    ,   ,   ,    .<br>
</li>
<li>       ,      . ,            -.           -  (       ).<br>
</li>
<li>       .        .<br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブリのバージョンを明示的に変更するか、少なくとも開発者がバージョンを変更したことを確認してください。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1回だけ収集し、1つのアセンブリアーティファクト（たとえば、Dockerイメージ）のすべてのチェックを実行します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態がアセンブリ間で変化しない短期間の環境でテストします。</font><font style="vertical-align: inherit;">唯一の例外はキャッシュ</font></font><code>node_modules</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
</li>
</ol><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何世代にもわたるプログラマーによって蓄積された知恵を奪うでしょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.9アセンブリマトリックス：異なるバージョンのノードを使用して同じCI手順を実行する</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">品質管理には直感が必要であり、それを実行すればするほど、問題を事前に特定することに成功します。 CIの一部として、再利用可能なパッケージを開発したり、構成やノードバージョンが異なるマルチユーザー製品を試運転したりする場合は、すべての構成バリエーションに対してテストパイプラインを実行する必要があります。一部のユーザーにMySQLを使用し、他のユーザーにPostgresを使用するとします。一部のCIベンダーは、MySQl、Postgres、および異なるバージョンのノードのすべてのバリエーションに対してテストスイートを実行できる「マトリックス」と呼ばれる機能をサポートしています。これは、構成の助けを借りてのみ行われ、追加の作業は必要ありません（テストやその他の品質チェックを実施する場合）。また、マトリックスをサポートしないCIには、対応する拡張機能または改善機能がある場合があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さもないと。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストを作成するためのすべての努力の後に、構成の問題によってのみエラーが気付かれないようにすることは可能ですか？</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><b>:</b>   Travis ( CI)             Node.<br>
<br>
<pre><code class="javascript hljs">language: node_js
<span class="hljs-attr">node_js</span>:<font></font>
 - <span class="hljs-string">"7"</span>
 - <span class="hljs-string">"6"</span>
 - <span class="hljs-string">"5"</span>
 - <span class="hljs-string">"4"</span>
<span class="hljs-attr">install</span>:<font></font>
 - npm install<font></font>
<span class="hljs-attr">script</span>:<font></font>
 - npm run test</code></pre><br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja466863/index.html">漸近線のセットアップ</a></li>
<li><a href="../ja466865/index.html">11月1日を待つ：暗号通貨の禁止または合法化</a></li>
<li><a href="../ja466873/index.html">JavaScriptの新機能で理解できない5つのこと</a></li>
<li><a href="../ja466875/index.html">Visual C ++でのUnicode文字のprintf関数形式指定子の悲しい運命</a></li>
<li><a href="../ja466877/index.html">Malicious Sustesが更新され、Eximの脆弱性（CVE-2019-10149）を介して拡散している</a></li>
<li><a href="../ja466881/index.html">イヴァン・シャマトフ：お金の書き方</a></li>
<li><a href="../ja466887/index.html">ただの除算、または数学理論を作成し、それに40万ドルを稼ぐ方法</a></li>
<li><a href="../ja466889/index.html">2019年8月のバルト海ドメインゾーンのステータス</a></li>
<li><a href="../ja466899/index.html">なぜすべてを落として、今すぐSwiftとKotlinを学ぶのか</a></li>
<li><a href="../ja466903/index.html">常に作品を発表する</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>