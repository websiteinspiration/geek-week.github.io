<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜí ‚èπÔ∏è üë©‚Äçüé® Invert Sort üßëüèº‚Äçü§ù‚Äçüßëüèº ü¶É üèÇüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A programmer from India clearly shows Zig-Zag, Zig-Zig and Zig used in the SplaySort algorithm:
 
 
 This season we are exploring a variety of heaps a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Invert Sort</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/504012/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A programmer from India clearly shows Zig-Zag, Zig-Zig and Zig used in the SplaySort algorithm:</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><div style="text-align:center;"><img width="780" height="590" src="https://habrastorage.org/webt/0j/qa/l0/0jqal0merugvc0u93nolsk_l0i0.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This season we are exploring a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variety of heaps and how they can be used for sorting</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">However, this time we will take a step away from the main theme. </font><font style="vertical-align: inherit;">Today's structure - splay tree - is not a bunch. </font><font style="vertical-align: inherit;">But we need it to mentally prepare for the study of the next pile - next week there will be a lecture on sorting by a Cartesian tree.</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" title="EDISON Software - web-development"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - web-development"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This article was prepared with the support of EDISON. </font><font style="vertical-align: inherit;">
One of the directions of our activity is </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">automation of measurements and expert systems</font></a><font style="vertical-align: inherit;"> , due to which we carry out high-tech projects using a strict scientific approach. </font><font style="vertical-align: inherit;">
We love computer science! </font><font style="vertical-align: inherit;">;-)</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img align="right" width="340" height="228" src="https://habrastorage.org/webt/y8/hs/tt/y8hsttfexnxawirmy1ysw7rg-3q.png"></a><br clear="left"><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><div style="text-align:center;"><img width="770" height="1" src="https://habrastorage.org/webt/mw/wy/cu/mwwycuqpta7m96dxifyx9if7mu8.gif"></div></blockquote><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binary search tree sort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Splay tree is an improved binary search tree. </font><font style="vertical-align: inherit;">First, let's remember how to sort using the usual ‚Äúunimproved‚Äù binary tree. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you well know, in a binary tree, any left child is less than the parent, any right child is no less (i.e. greater or equal) than the parent.</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="511" src="https://habrastorage.org/webt/2e/ie/2b/2eie2b53zaztn8ixd0wgqf5hlqu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sorting is generally straightforward:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stage 1. Based on the array, build a binary search tree. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We put the first element of the array to the root, compare the remaining elements first with the root, then, depending on the comparison, move down the left or right branches (and along the way we compare the array element with the existing tree nodes). </font><font style="vertical-align: inherit;">In the end, the next element reaches the end of a branch and becomes a node itself.</font></font></li>
<li><b> 2.         .</b>   ,      (    ,       )            .          .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Building a tree is quite tolerable in terms of algorithmic complexity - on average, inserting a new node costs </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so the time complexity of the first stage is </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But in the second stage, not everything is so rosy. </font><font style="vertical-align: inherit;">A recursive tree walk can easily become a long journey through an extremely winding maze, and the time complexity often degrades to </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></b><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Splay tree</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To solve this problem, only some 35-37 years ago, two Scientist scientists Robert Tarjan and Daniel Slitor developed this tree structure. They suggested that for any operations (insert, search, delete) with any tree node, immediately rebalance the tree, making the node the root of the entire structure.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><div style="text-align:center;"><img width="780" height="313" src="https://habrastorage.org/webt/8s/vj/ac/8svjacb-n4jgxpjbbaxjv-fh-h0.jpeg"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the left photo is Robert Tarjan (first row, second right) in the company of the Matrix Architect and inventor of Pascal. </font><font style="vertical-align: inherit;">In the right photo is Daniel Slitor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Clicking on the image will open a full-format version. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Russian, the unsuccessful name "expanding tree" stuck, less often - "oblique tree". </font><font style="vertical-align: inherit;">Although if it were simply literally translated, then the ‚Äúexpanded tree‚Äù (or, even better, ‚Äúturned‚Äù) sounds good and more accurately reflects the essence of this algorithmic structure. </font><font style="vertical-align: inherit;">But that is. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to push the node to the root, special simple operations are used, the so-called turns:</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zig Turn</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the element you want to make a root is on the second level of nesting, then everything is extremely simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We denote this element like </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and its parent (which is also the root of the tree) - as the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are subtrees. How much is there in these subtrees nodes does not matter, only interested in the roots of these subtrees that have relations "parent-child" with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If any of the subtrees are missing (that is, if </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do not have any descendants), then this does not affect the order of actions.</font></font><br>
<br>
<div style="text-align:center;"><img width="450" height="208" src="https://habrastorage.org/webt/v3/kg/i0/v3kgi01dbf_nluirdgnsaylmn6y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To make </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> root of the tree, you need to reverse the parent-child relationship between </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and also outweigh the subtree </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - it was the right descendant of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , became the left descendant of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><font style="vertical-align: inherit;">you don‚Äôt need to do anything </font><font style="vertical-align: inherit;">with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">And it's all! </font><font style="vertical-align: inherit;">As a result of these simple manipulations, the structure, as it was a binary search tree, remained the same - the principle ‚Äúthe left child is less than the parent, the right child is greater or equal than the parent‚Äù will not be violated anywhere. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The previous image </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a left descendant of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was a right descendant, you just need to mirror the situation: </font></font><br>
<br>
<div style="text-align:center;"><img width="450" height="208" src="https://habrastorage.org/webt/em/n6/z9/emn6z9kik0em1i03xpc5k7egrkq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has not the second level of difficulty, but the third, then everything is more complicated, but not by much. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has a parent </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which in turn has a parent </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then we have only two different situations: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) if </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descendant</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font></b><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">on the same side</font></i><font style="vertical-align: inherit;"> as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) if </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versatile descendants</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for their parents. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, consider the first case.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZigZig Turn</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> be the left descendant for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> left descendant for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (the option when </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are simultaneously right descendants is solved similarly).</font></font><br>
<br>
<div style="text-align:center;"><img width="770" height="251" src="https://habrastorage.org/webt/sh/f3/ev/shf3evyiypukr9y08kvtiidhrvy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, it is necessary to change the relationship between </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as well as properly outweigh subtrees </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">And our binary search tree will not suffer from this.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZigZag Turn</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X is the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> right descendant, and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> left (or </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> left, and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> right, not the essence), then I hope you already understand everything from this picture:</font></font><br>
<br>
<div style="text-align:center;"><img width="642" height="251" src="https://habrastorage.org/webt/rz/v1/p2/rzv1p25jwly-sz6lrv_o2alzlyc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the tree is still at a lower level of nesting, then to raise it, you need to apply ZigZig or ZigZag (if necessary, do it several times) to that parent up the branch, which is at the third level of nesting.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Invert Sort :: Splay sort</font></font></h2><img align="right" width="396" height="590" src="https://habrastorage.org/webt/ig/xb/3c/igxb3c-v8_la--ej_irmsze7dai.gif"><br clear="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actually, here we perform the same points as in tree sorting - first we build a binary sort tree, then we go around it. But every time we insert a new knot into the tree - using ridges and zags, we make it the root. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the first stage of winning, this does not give, inserting one node (taking into account that you have to zigzag to make it a root) costs on average </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - and thus the complexity of this stage is </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, as a result, amazing transformations take place with the tree - it straightens and is kept in such a straightened state all the time. And this decisively accelerates the second stage (tree traversal), since the resulting final ladder is processed with O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">complexity </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, the total complexity of the algorithm (worst, medium, best) in time is </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In practice, this sorting is slower than MergeSort, QuickSort and other HeapSort, but it clearly demonstrates how you can speed up operations with binary search tree.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The moral of this fable is this: if you have to deal with a binary search tree - if possible, make it self-balancing. </font><font style="vertical-align: inherit;">As a possible option - work with it as with a splay tree, i.e. </font><font style="vertical-align: inherit;">in any action with any node in the tree, make this node the root. </font><font style="vertical-align: inherit;">Of course, there are other alternative self-balancing search trees (red-black tree, AVL tree, etc.), which may be more preferable.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C code</font></font></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not to look nervous</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">/*
 *------------------------------------------------------------
 *
 *      File..........: $RCSfile: splaysort.c,v $
 *      Revision......: $Revision: 1.2 $
 *      Author........: Gary Eddy (gary@cs.mu.OZ.AU)
 *			Alistair Moffat (alistair@cs.mu.OZ.AU)
 *      Date..........: $Date: 1995/09/07 06:19:17 $
 *
 *	Description:
 *		Sorts by repeated insertion into a splay tree.
 *		Insertions are done top down
 *
 *------------------------------------------------------------
 */</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>	<span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>	<span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>	<span class="hljs-meta-string">&lt;malloc.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>	<span class="hljs-meta-string">&lt;alloca.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">char</span>	*sort_name = <span class="hljs-string">"Splaysort"</span>;
<span class="hljs-keyword">char</span>	*sort_version = <span class="hljs-string">"$Revision: 1.2 $"</span>;<font></font>
<font></font>
<span class="hljs-comment">/*
** Define DATAPTR for the 12 byte per record version of the program.
** Otherwise only 8 extra bytes per record are used and data
** references are done by indexing the data array.
** Different compiler/architecture combinations can cause wild
** variation in the ratio of speeds between these variations.
*/</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DATAPTR</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DATAPTR</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DATA(p) ((p)-&gt;data)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DATA(p) (A+size*(p-T))</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-comment">/*
** With the fast copy option enabled a more intelligent copy is used
** depending on the size of the items being copied.
** This approach adopted from the nqsort program of Bentley and McIlroy,
** see Software Practice and Experience, v23, n11, November 1993, 1249-65.
*/</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTCOPY</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> FASTCOPY</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> COPYCODE(TYPE, parmi, parmj, n) { \
        long i = (n) / sizeof (TYPE); \
        register TYPE *pi = (TYPE *) (parmi); \
        register TYPE *pj = (TYPE *) (parmj); \
        do { \
                *pi++ = *pj++;                    \
        } while (--i &gt; 0);      \
}</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">copyfunc</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *d, <span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> copytype)</span>
</span>{
        <span class="hljs-keyword">if</span>(copytype &lt;= <span class="hljs-number">1</span>)<font></font>
                COPYCODE(<span class="hljs-keyword">long</span>, d, s, size)
        <span class="hljs-keyword">else</span>
                COPYCODE(<span class="hljs-keyword">char</span>, d, s, size)
	<span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> COPY(d,s,size) \
        <span class="hljs-meta-keyword">if</span> (copytype == 0) { \
                *(long *)(d) = *(long *)(s); \
        } <span class="hljs-meta-keyword">else</span> \
                copyfunc(d, s, size, copytype)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> COPY(d,s,size)	memcpy(d,s,size)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">node_rec</span> <span class="hljs-title">node</span>;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span>	<span class="hljs-title">node_rec</span> {</span><font></font>
	node	*left, *rght;<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DATAPTR</span>
	<span class="hljs-keyword">char</span>	*data;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/*
 *	sort():
 *		The entire sort code 
 *
 *	Accesses outside variables:	none
 *
 *	Return value...:		none
 */</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *A, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> (*cmp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *))</span>
</span>{
	<span class="hljs-keyword">register</span> node *next, *curr, *prnt;
	<span class="hljs-keyword">char</span> 	*item;<font></font>
	node	*l, *r, *ch;<font></font>
	node	root, *T, *<span class="hljs-keyword">new</span>, *end, *move;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DATAPTR</span>
	<span class="hljs-keyword">char</span>	*p;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-comment">/*
** Determine which copying method will be used.
*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> FASTCOPY</span>
	<span class="hljs-keyword">int</span>	copytype=((<span class="hljs-keyword">char</span> *)A - (<span class="hljs-keyword">char</span> *)<span class="hljs-number">0</span>) % <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>) ||<font></font>
		size % <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>) ? <span class="hljs-number">2</span> : size == <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>)
		<span class="hljs-keyword">return</span>;
	<span class="hljs-keyword">if</span>((T = <span class="hljs-keyword">new</span> = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*T)*n)) == <span class="hljs-literal">NULL</span>) {
		<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't allocate space for structure\n"</span>);<font></font>
	}<font></font>
	<span class="hljs-comment">/* 
	** Do the first insertion manually to avoid the empty tree
	** case in the main loop.
	*/</span>
	curr = <span class="hljs-keyword">new</span>++;<font></font>
	item = A;<font></font>
	curr-&gt;left = curr-&gt;rght = <span class="hljs-literal">NULL</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DATAPTR</span><font></font>
	curr-&gt;data = item;<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
	item += size;<font></font>
	end = T+n;<font></font>
	<span class="hljs-comment">/*
	** For each item move down the tree dividing it into
	** two subtrees, one containing items less than the new
	** element and the other those which are greater.
	** The pointers l and r refer to the greatest element in the
	** smaller subtree and the smallest element in the large
	** subtree respectively. During the splitting of the tree
	** l and r retain children that may be incorrect in the final
	** tree but these false links are cut at the end of the
	** insertion.
	*/</span><font></font>
<font></font>
	<span class="hljs-keyword">for</span>( ; <span class="hljs-keyword">new</span>&lt;end; ) {<font></font>
		l = r = &amp;root;<font></font>
		<span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">NULL</span>) {
			<span class="hljs-keyword">if</span>(cmp(item, DATA(curr)) &lt; <span class="hljs-number">0</span>) {
				<span class="hljs-comment">/* Left root case */</span>
				<span class="hljs-keyword">if</span>((ch = curr-&gt;left) == <span class="hljs-literal">NULL</span>) {<font></font>
					r = r-&gt;left = curr;<font></font>
					<span class="hljs-keyword">break</span>;<font></font>
				}<font></font>
				<span class="hljs-comment">/* Left zig-zig */</span>
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp(item, DATA(ch)) &lt; <span class="hljs-number">0</span>) {<font></font>
					curr-&gt;left = ch-&gt;rght;<font></font>
					ch-&gt;rght = curr;<font></font>
					r = r-&gt;left = ch;<font></font>
					curr = ch-&gt;left;<font></font>
				}<font></font>
				<span class="hljs-comment">/* Left zig-zag */</span>
				<span class="hljs-keyword">else</span> {<font></font>
					r = r-&gt;left = curr;<font></font>
					l = l-&gt;rght = ch;<font></font>
					curr = ch-&gt;rght;<font></font>
				}<font></font>
			}<font></font>
			<span class="hljs-keyword">else</span> {
				<span class="hljs-comment">/* Right root case */</span>
				<span class="hljs-keyword">if</span>((ch = curr-&gt;rght) == <span class="hljs-literal">NULL</span>) {<font></font>
					l = l-&gt;rght = curr;<font></font>
					<span class="hljs-keyword">break</span>;<font></font>
				}<font></font>
				<span class="hljs-comment">/* Right zig-zag */</span>
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp(item, DATA(ch)) &lt; <span class="hljs-number">0</span>) {<font></font>
					l = l-&gt;rght = curr;<font></font>
					r = r-&gt;left = ch;<font></font>
					curr = ch-&gt;left;<font></font>
				}<font></font>
				<span class="hljs-comment">/* Right zig-zig */</span>
				<span class="hljs-keyword">else</span> {<font></font>
					curr-&gt;rght = ch-&gt;left;<font></font>
					ch-&gt;left = curr;<font></font>
					l = l-&gt;rght = ch;<font></font>
					curr = ch-&gt;rght;<font></font>
				}<font></font>
			}<font></font>
		}<font></font>
		<span class="hljs-comment">/* Cut false links */</span>
		r-&gt;left = l-&gt;rght = <span class="hljs-literal">NULL</span>;
		<span class="hljs-keyword">new</span>-&gt;rght = root.left;
		<span class="hljs-keyword">new</span>-&gt;left = root.rght;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DATAPTR</span>
		<span class="hljs-keyword">new</span>-&gt;data = item;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
		curr = <span class="hljs-keyword">new</span>++;<font></font>
		item += size;<font></font>
	}<font></font>
	<span class="hljs-comment">/* Now copy all of the data back into the input array.
	** Uses an iterative destructive inorder traversal.
	** Last item inserted is the current root.
	*/</span>
	prnt = <span class="hljs-literal">NULL</span>;<font></font>
	move = T;<font></font>
	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
		<span class="hljs-keyword">if</span> ((next = curr-&gt;left) != <span class="hljs-literal">NULL</span>) {
			<span class="hljs-comment">/* left subtree exists */</span><font></font>
			curr-&gt;left = prnt;<font></font>
			prnt = curr;<font></font>
			curr = next;<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span> {<font></font>
			next = curr-&gt;rght;<font></font>
			curr-&gt;rght = move++;<font></font>
			<span class="hljs-keyword">if</span> (next != <span class="hljs-literal">NULL</span>) {
				<span class="hljs-comment">/* and arrange for a visit */</span>
				<span class="hljs-keyword">if</span>((curr = next-&gt;left) != <span class="hljs-literal">NULL</span>) {<font></font>
					next-&gt;left = prnt;<font></font>
					prnt = next;<font></font>
					<span class="hljs-keyword">continue</span>;<font></font>
				}<font></font>
				<span class="hljs-keyword">else</span> {<font></font>
					curr = next;<font></font>
					<span class="hljs-keyword">continue</span>;<font></font>
				}<font></font>
			}<font></font>
			<span class="hljs-comment">/* no right subtree either, turn around*/</span>
			<span class="hljs-keyword">if</span> (prnt != <span class="hljs-literal">NULL</span>) {<font></font>
				curr = prnt;<font></font>
				prnt = prnt-&gt;left;<font></font>
				curr-&gt;left = <span class="hljs-literal">NULL</span>;
				<span class="hljs-keyword">continue</span>;<font></font>
			}<font></font>
			<span class="hljs-comment">/* nothing left to be done */</span>
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
	}<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DATAPTR</span>
	<span class="hljs-comment">/*
	** Change the goes-to array in rght to a comes_from in left.
	** Note the kludge on pointers, where left points into the 
	** character array containing the elements.
	*/</span>
	<span class="hljs-keyword">for</span>(next = T, p = A; next &lt; end; p += size, next++)<font></font>
		next-&gt;rght-&gt;left = (node *)p;<font></font>
	<span class="hljs-comment">/* and use the `comes from' array to unscramble the permutation */</span>
	item = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(size);
        <span class="hljs-keyword">for</span> (next=T; next&lt;end; next++) {
                <span class="hljs-keyword">char</span> *datacurr, *dataleftcurr, *<span class="hljs-keyword">final</span>;
                <span class="hljs-keyword">if</span> (next-&gt;left == <span class="hljs-literal">NULL</span>)
                        <span class="hljs-keyword">continue</span>;<font></font>
                curr = next;<font></font>
                <span class="hljs-keyword">final</span> = datacurr = DATA(curr);<font></font>
                COPY(item, datacurr, size);<font></font>
                <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">char</span> *)(curr-&gt;left) != <span class="hljs-keyword">final</span>) {<font></font>
                        dataleftcurr = (<span class="hljs-keyword">char</span> *)(curr-&gt;left);<font></font>
                        COPY(datacurr, dataleftcurr, size);<font></font>
                        prnt = curr;<font></font>
                        curr = T + (((<span class="hljs-keyword">char</span> *)(curr-&gt;left)-A)/size);<font></font>
                        prnt-&gt;left = <span class="hljs-literal">NULL</span>;<font></font>
                        datacurr = dataleftcurr;<font></font>
                }<font></font>
                COPY(datacurr, item, size);<font></font>
                curr-&gt;left = <span class="hljs-literal">NULL</span>;<font></font>
        }<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
	<span class="hljs-comment">/* Change the goes-to array in rght to a comes_from in left */</span>
	<span class="hljs-keyword">for</span>(next = T; next &lt; end; next++)<font></font>
		next-&gt;rght-&gt;left = next;<font></font>
	<span class="hljs-comment">/* and use the `comes from' array to unscramble the permutation */</span>
	<span class="hljs-comment">/*
	** This 12 byte version uses the presence of the data pointer
	** by making it the flag for already placed items. This means
	** that left pointers can point to nodes, eliminating the
	** calculation to find the next node.
	*/</span>
	item = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(size);
	<span class="hljs-keyword">for</span> (next=T; next&lt;end; next++) {
		<span class="hljs-keyword">char</span> *datacurr, *dataleftcurr, *<span class="hljs-keyword">final</span>;
		<span class="hljs-comment">/* second condition guarantees at least one iteration
		** of while loop.
		*/</span>
		<span class="hljs-keyword">if</span> (DATA(next) == (<span class="hljs-keyword">char</span> *) <span class="hljs-literal">NULL</span> || next-&gt;left == next)
			<span class="hljs-keyword">continue</span>;
		<span class="hljs-keyword">final</span> = datacurr = DATA(next);<font></font>
		curr = next-&gt;left;<font></font>
		COPY(item, datacurr, size);<font></font>
		<span class="hljs-keyword">while</span> ((dataleftcurr = DATA(curr)) != <span class="hljs-keyword">final</span>) {<font></font>
			COPY(datacurr, dataleftcurr, size);<font></font>
			prnt = curr;<font></font>
			curr = curr-&gt;left;<font></font>
			DATA(prnt) = (<span class="hljs-keyword">char</span> *) <span class="hljs-literal">NULL</span>;<font></font>
			datacurr = dataleftcurr;<font></font>
		}<font></font>
		COPY(datacurr, item, size);<font></font>
		DATA(curr) = (<span class="hljs-keyword">char</span> *) <span class="hljs-literal">NULL</span>;<font></font>
	}<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	<span class="hljs-built_in">free</span>(item);
	<span class="hljs-built_in">free</span>(T);<font></font>
} <span class="hljs-comment">/* sort() */</span></code></pre></div>
                    </div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next Series Trailer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And we return to the heaps. </font><font style="vertical-align: inherit;">The next little thing will be more interesting than the one that we examined today. </font><font style="vertical-align: inherit;">This hybrid is a tree-like data structure that is both a heap and a binary search tree.</font></font><br>
<br>
<img height="498" src="https://habrastorage.org/webt/gf/96/5w/gf965wv0ih9ugz1ur98ywqe4oaq.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References</font></font></h2><br>
 <img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binary search tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Splay tree </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/jw/w-/qu/jww-queszzqnwmoa2hm-kfwu-9o.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Splay trees</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Series Articles:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel application AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exchange Sorts</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insertion Sorts</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Librarian Sort</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solitaire Sort</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sort "Tower of Hanoi"</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Invert Sort</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Young table sorting</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sort by selection</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merge Sorts</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sort by distribution</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybrid Sorting</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sort added to AlgoLab. </font><font style="vertical-align: inherit;">So, if you update the Excel file with macros, you can personally upset the binary search tree.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en503998/index.html">Data from all countries, do not unite</a></li>
<li><a href="../en504000/index.html">Mikrosha. Chapter Two ROM and BSVV</a></li>
<li><a href="../en504002/index.html">How to use Yandex.Wordstat for contextual advertising [detailed guide]</a></li>
<li><a href="../en504006/index.html">6 ways to significantly speed up pandas with a couple of lines of code. Part 2</a></li>
<li><a href="../en504008/index.html">What is an algorithm ?! Part one</a></li>
<li><a href="../en504014/index.html">Anglicisms capture the Russian language: why this happens</a></li>
<li><a href="../en504016/index.html">The appeal of stoicism to the rich and influential</a></li>
<li><a href="../en504022/index.html">Information Security Specialist. What does and how much does it earn</a></li>
<li><a href="../en504026/index.html">Why is Silicon Valley so obsessed with the virtue of suffering?</a></li>
<li><a href="../en504030/index.html">The Tale of How I Configured Azure AD B2C on React and React Native Part 2 (Tutorial)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>