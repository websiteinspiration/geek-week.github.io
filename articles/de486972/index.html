<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏿 🦇 🤙🏽 Expressionsbäume in C # anhand eines Beispiels zum Auffinden eines Derivats (Expression Tree Visitor vs Pattern Matching) ☀️ 🤴 😱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schönen Tag. Ausdrucksbäume waren, besonders wenn sie mit dem Besuchermuster kombiniert wurden, immer ein ziemlich verwirrendes Thema. Je vielfältiger...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Expressionsbäume in C # anhand eines Beispiels zum Auffinden eines Derivats (Expression Tree Visitor vs Pattern Matching)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486972/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schönen Tag. </font><font style="vertical-align: inherit;">Ausdrucksbäume waren, besonders wenn sie mit dem Besuchermuster kombiniert wurden, immer ein ziemlich verwirrendes Thema. </font><font style="vertical-align: inherit;">Je vielfältiger die Informationen zu diesem Thema sind, desto mehr Beispiele, desto einfacher wird es für diejenigen, die interessiert sind, etwas zu finden, das für sie klar und nützlich ist.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xt/6c/bf/xt6cbf1-gfkv4-64zs250n_-7pa.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel ist wie gewohnt aufgebaut - er beginnt mit dem konzeptionellen Rahmen und den Definitionen und endet mit Beispielen und Verwendungsmöglichkeiten. </font><font style="vertical-align: inherit;">Inhaltsverzeichnis unten. </font></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundlagen der Expression Trees </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax von Expression Trees Expression </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typen </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pattern Matching </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naive Besucher </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassische Besucher</font></font></a></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nun, das </font><font style="vertical-align: inherit;">ist das Ziel nicht eine bestimmte Lösung aufzuzwingen oder sagen , </font><font style="vertical-align: inherit;">dass man besser ist als die andere. </font><font style="vertical-align: inherit;">Ich schlage vor, selbst Schlussfolgerungen zu ziehen und dabei alle Nuancen in Ihrem Fall zu berücksichtigen. </font><font style="vertical-align: inherit;">Ich werde meine Meinung zu meinem Beispiel äußern.</font></font><br>
<br>
<a name="basic"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausdrucksbäume</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Grundlagen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst müssen Sie sich mit Ausdrucksbäumen befassen. Sie bedeuten die Art des Ausdrucks oder einen seiner Erben (sie werden später besprochen). Im üblichen Szenario werden die Ausdrücke / Algorithmen in Form von ausführbarem Code / ausführbaren Anweisungen dargestellt, mit denen der Benutzer möglicherweise nicht viel zu tun hat (hauptsächlich ausführen). Mit dem Ausdruckstyp können Sie einen Ausdruck / Algorithmus (normalerweise Lambdas, aber nicht unbedingt) als Daten darstellen, die in einer Baumstruktur organisiert sind, auf die der Benutzer Zugriff hat. Die baumartige Art, Informationen über den Algorithmus und den Namen der Klasse zu organisieren, gibt uns "Ausdrucksbäume". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Verdeutlichung werden wir ein einfaches Beispiel analysieren. Angenommen, wir haben Lambda </font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(x) =&gt; Console.WriteLine (x + 5)</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dies kann als der folgende Baum dargestellt werden</font></font><br>
<br>
<div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/yv/wy/sq/yvwysqugbtttw-gvz07tipuq-oy.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Wurzel des Baums ist die Spitze des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodCall</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die Parameter der Methode sind ebenfalls Ausdrücke, daher kann sie eine beliebige Anzahl von </font><b><font style="vertical-align: inherit;">untergeordneten Elementen</font></b><font style="vertical-align: inherit;"> haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall gibt es nur einen Nachkommen - den Peak von " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArithmeticOperation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". Es enthält Informationen darüber, um welche Art von Operation es sich handelt, und der linke und der rechte Operand sind ebenfalls Ausdrücke. Ein solcher Scheitelpunkt hat immer 2 Nachkommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Operanden werden durch eine Konstante ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstante</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und einen Parameter ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dargestellt. Solche Ausdrücke haben keine Nachkommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies sind sehr vereinfachte Beispiele, die jedoch die Essenz vollständig widerspiegeln.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Hauptmerkmal von Ausdrucksbäumen ist, dass sie analysiert werden können und alle erforderlichen Informationen darüber lesen, was der Algorithmus tun soll. In gewisser Hinsicht ist dies das Gegenteil von Attributen. Attribute sind ein Mittel zur deklarativen Beschreibung des Verhaltens (sehr bedingt, aber das endgültige Ziel ist ungefähr dasselbe). Während Ausdrucksbäume eine Funktion / einen Algorithmus verwenden, um Daten zu beschreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden beispielsweise in </font><font style="vertical-align: inherit;">Entity-Framework- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anbietern verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die Anwendung liegt auf der Hand - den Ausdrucksbaum zu analysieren, zu verstehen, was dort ausgeführt werden soll, und aus dieser Beschreibung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL zu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellen </font><font style="vertical-align: inherit;">. Weniger bekannte Beispiele sind die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moq-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliotheken zum Rauchen </font><font style="vertical-align: inherit;">. Ausdrucksbäume werden auch im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DLR verwendet.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dynamische Sprachlaufzeit). </font><font style="vertical-align: inherit;">Compiler-Entwickler verwenden sie, um die Kompatibilität zwischen der dynamischen Natur und Dotnet sicherzustellen, anstatt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSIL zu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generieren </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erwähnenswert ist auch, dass Ausdrucksbäume unveränderlich sind.</font></font><br>
<a name="syn"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das nächste, was es wert ist, besprochen zu werden, ist die Syntax. </font><font style="vertical-align: inherit;">Es gibt zwei Hauptwege:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen von Ausdrucksbäumen mit statischen Methoden der Expression-Klasse</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden von in Expression kompilierten Lambda-Ausdrücken</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statische Methoden der Ausdrucksklasse</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erstellen von Ausdrucksbäumen mit statischen Methoden der Ausdrucksklasse wird seltener verwendet (insbesondere aus Benutzersicht). Dies ist umständlich, aber recht einfach. Wir verfügen über </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
viele Grundbausteine, aus denen Sie recht komplexe </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dinge </font><font style="vertical-align: inherit;">bauen können </font><font style="vertical-align: inherit;">. Die Erstellung erfolgt seitdem durch statische Methoden Ausdruckskonstruktoren haben einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">internen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modifikator </font><font style="vertical-align: inherit;">. Und das bedeutet nicht, dass Sie Reflexion aufdecken müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Beispiel werde ich einen Ausdruck aus dem obigen Beispiel erstellen: </font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(x) =&gt; Console.WriteLine (x + 5)</font></font></i></b><br>
<br>
<pre><code class="cs hljs">ParameterExpression parameter = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
ConstantExpression constant = Expression.Constant(<span class="hljs-number">5</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
BinaryExpression <span class="hljs-keyword">add</span> = Expression.Add(parameter, constant);<font></font>
MethodInfo writeLine = <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.WriteLine), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });<font></font>
MethodCallExpression methodCall = Expression.Call(<span class="hljs-literal">null</span>, writeLine, <span class="hljs-keyword">add</span>);<font></font>
Expression&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt; expressionlambda = Expression.Lambda&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt;(methodCall, parameter);<font></font>
Action&lt;<span class="hljs-keyword">double</span>&gt; delegateLambda = expressionlambda.Compile();<font></font>
delegateLambda(<span class="hljs-number">123321</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist möglicherweise kein sehr bequemer Weg, spiegelt jedoch die interne Struktur von Ausdrucksbäumen vollständig wider. </font><font style="vertical-align: inherit;">Darüber hinaus bietet diese Methode weitere Funktionen, die in Ausdrucksbäumen verwendet werden können: Ausgehend von Schleifen, Bedingungen, Try-Catch, Goto, Zuweisung, Beenden mit Fehlerblöcken, Debuggen von Informationen für Haltepunkte, Dynamisch usw.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lambda-Ausdruck</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verwendung von Lambdas als Ausdruck ist häufiger. </font><font style="vertical-align: inherit;">Es funktioniert sehr einfach - der Smart Compiler in der Kompilierungsphase untersucht, wofür Lambda verwendet wird. </font><font style="vertical-align: inherit;">Und kompiliert es entweder zu einem Delegaten oder zu einem Ausdruck. </font><font style="vertical-align: inherit;">In einem bereits gemasterten Beispiel sieht es wie folgt aus</font></font><br>
<br>
<pre><code class="cs hljs">Expression&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt; write =  =&gt; Console.WriteLine( + <span class="hljs-number">5</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es lohnt sich, so etwas zu klären - ein Ausdruck ist eine erschöpfende Beschreibung. </font><font style="vertical-align: inherit;">Und es reicht aus, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
um das Ergebnis zu erhalten. </font><font style="vertical-align: inherit;">Ausdrucksbäume wie LambdaExpression oder seine Nachkommen können </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
in eine ausführbare IL konvertiert werden. </font><font style="vertical-align: inherit;">Die verbleibenden Typen können nicht direkt in ausführbaren Code konvertiert werden (dies ist jedoch nicht sehr sinnvoll). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Übrigens, wenn jemand die schnelle Kompilierung eines Ausdrucks kritisiert, können Sie sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projekt </font><font style="vertical-align: inherit;">eines </font><font style="vertical-align: inherit;">Drittanbieters </font><font style="vertical-align: inherit;">ansehen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Gegenteil ist im allgemeinen Fall nicht der Fall. </font><font style="vertical-align: inherit;">Ein Delegierter kann es nicht einfach aufgreifen und sich als Ausdruck vorstellen (aber das ist immer noch möglich). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nicht alle Lambdas können in Ausdrucksbäume umgewandelt werden. </font><font style="vertical-align: inherit;">Diese beinhalten:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enthält Zuweisungsoperator</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamisch beitragen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchron</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Körper (Zahnspange)</font></font></li>
</ul><br>
<pre><code class="cs hljs"><span class="hljs-keyword">double</span> variable;
<span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">dynamic</span>;<font></font>
Expression&lt;Action&gt; assignment = () =&gt; variable = <span class="hljs-number">5</span>; <span class="hljs-comment">//Compiler error: An expression tree may not contain an assignment operator</span>
Expression&lt;Func&lt;<span class="hljs-keyword">double</span>&gt;&gt; dynamically = () =&gt; <span class="hljs-keyword">dynamic</span>; <span class="hljs-comment">//Compiler error: An expression tree may not contain a dynamic operation</span>
Expression&lt;Func&lt;Task&gt;&gt; asynchon = <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">await</span> Task.CompletedTask; <span class="hljs-comment">//Compiler error: Async lambda cannot be converted to expresiion trees</span>
Expression&lt;Action&gt; body = () =&gt; { }; <span class="hljs-comment">//Compiler error: A lambda expression with a statement body cannot be converted to an expression tree</span>
</code></pre> <br>
<a name="types"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arten von Ausdrücken</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich schlage einen kurzen Blick auf die verfügbaren Typen vor, um darzustellen, welche Möglichkeiten wir haben. </font><font style="vertical-align: inherit;">Alle befinden sich im Namespace </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Linq.Expressions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich schlage vor, dass Sie sich zuerst mit einigen wirklich interessanten und ungewöhnlichen Funktionen vertraut machen. </font><font style="vertical-align: inherit;">Die einfacheren Arten von Ausdrücken habe ich in einem Tablet mit einer kurzen Beschreibung zusammengestellt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamisch</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit DynamicExpression können Sie Dynamic und alle seine Funktionen in Ausdrucksbäumen verwenden. </font><font style="vertical-align: inherit;">Es gibt eine ziemlich verwirrende API, ich habe länger an diesem Beispiel gesessen als an allen anderen zusammen. </font><font style="vertical-align: inherit;">Die ganze Verwirrung wird durch eine Reihe verschiedener Flaggen verursacht. </font><font style="vertical-align: inherit;">Und einige von ihnen ähneln denen, die Sie suchen, aber sie sind nicht unbedingt. </font><font style="vertical-align: inherit;">Und wenn Sie mit dynamischen Ausdrucksbäumen arbeiten, ist es schwierig, einen Sprechfehler zu erhalten. </font><font style="vertical-align: inherit;">Beispiel:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> parameter1 = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), <span class="hljs-string">"name1"</span>);
<span class="hljs-keyword">var</span> parameter2 = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), <span class="hljs-string">"name2"</span>); 
<span class="hljs-keyword">var</span> dynamicParam1 = CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal">null</span>);
<span class="hljs-keyword">var</span> dynamicParam2 = CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal">null</span>);<font></font>
CallSiteBinder csb = Microsoft.CSharp.RuntimeBinder.Binder.BinaryOperation(CSharpBinderFlags.None, ExpressionType.Add, <span class="hljs-keyword">typeof</span>(Program), <span class="hljs-keyword">new</span>[] { dynamicParam1, dynamicParam2 });
<span class="hljs-keyword">var</span> dyno = Expression.Dynamic(csb, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), parameter1, parameter2);<font></font>
Expression&lt;Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt;&gt; expr = Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt;&gt;(dyno, <span class="hljs-keyword">new</span>[] { parameter1, parameter2 });<font></font>
Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt; action = expr.Compile();
<span class="hljs-keyword">var</span> res = action(<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>);<font></font>
Console.WriteLine(res); <span class="hljs-comment">//12</span>
res = action(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<font></font>
Console.WriteLine(res); <span class="hljs-comment">//3</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe ausdrücklich angegeben, woher der Binder stammt, um Verwechslungen mit dem Binder von System.Reflection zu vermeiden. </font><font style="vertical-align: inherit;">Von interessanten Dingen können wir ref- und out-Parameter, benannte Parameter, unäre Operationen und im Prinzip alles tun, was durch Dynamik möglich ist, aber dies erfordert einige Fähigkeiten.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmefangblöcke</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite, worauf ich achten werde, ist die Funktion try / catch / finally / error oder vielmehr die Tatsache, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dass wir Zugriff auf den Fehlerblock haben. </font><font style="vertical-align: inherit;">Es ist nicht in C # verfügbar, aber in MSIL. Dies ist eine Art </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
endgültiges Analogon, das im Falle einer Ausnahme ausgeführt wird. </font><font style="vertical-align: inherit;">Im folgenden Beispiel wird eine Ausnahme ausgelöst, wonach "Hi" angezeigt wird und das Programm auf die Eingabe wartet. </font><font style="vertical-align: inherit;">Erst danach wird es vollständig fallen. </font><font style="vertical-align: inherit;">Ich empfehle diese Praxis nicht zur Verwendung.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> throwSmth = Expression.Throw(Expression.Constant(<span class="hljs-keyword">new</span> Exception(), <span class="hljs-keyword">typeof</span>(Exception)));
<span class="hljs-keyword">var</span> log = Expression.Call(<span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.WriteLine), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">string</span>) }), Expression.Constant(<span class="hljs-string">"Hi"</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">string</span>)));
<span class="hljs-keyword">var</span> read = Expression.Call(<span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.ReadLine)));
<span class="hljs-keyword">var</span> fault = Expression.TryFault(throwSmth, Expression.Block(<span class="hljs-keyword">new</span>[] { log, read }));<font></font>
Expression&lt;Action&gt; expr = Expression.Lambda&lt;Action&gt;(fault);<font></font>
Action compiledExpression = expr.Compile();<font></font>
compiledExpression();<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurze Beschreibung der verfügbaren Ausdrucksbaumtypen</font></font></b><div class="spoiler_text"><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabelle</font></font></h4><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Art</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurzbeschreibung</font></font></th>
</tr>
<tr>
<td colspan="2" align="center"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Haupt</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausdruck</font></font></td>
<td> ,      .     ,      </td>
</tr>
<tr>
<td>Expression&lt;TDelegate&gt;</td>
<td>    </td>
</tr>
<tr>
<td colspan="2" align="center"><b> </b></td>
</tr>
<tr>
<td>BinaryExpression</td>
<td>     (+, —  )</td>
</tr>
<tr>
<td>UnaryExpression</td>
<td> (+, -),    throw</td>
</tr>
<tr>
<td>ConstantExpression</td>
<td> —   </td>
</tr>
<tr>
<td>ParameterExpression</td>
<td> </td>
</tr>
<tr>
<td>MethodCallExpression</td>
<td>  ,  MethodInfo</td>
</tr>
<tr>
<td>IndexExpression</td>
<td></td>
</tr>
<tr>
<td>BlockExpression</td>
<td>,   .      </td>
</tr>
<tr>
<td colspan="2" align="center"><b>  </b></td>
</tr>
<tr>
<td>ConditionalExpression </td>
<td>   — if-else</td>
</tr>
<tr>
<td>LabelTarget</td>
<td>   goto</td>
</tr>
<tr>
<td>LabelExpression</td>
<td> ,            .    LabelTarget.    ,    GotoExpression,    —   .    void,    .</td>
</tr>
<tr>
<td>GotoExpression</td>
<td>  .    . ( .. «break»)</td>
</tr>
<tr>
<td>LoopExpression</td>
<td> ,    «break»</td>
</tr>
<tr>
<td>SwitchCase</td>
<td>    SwitchExpression</td>
</tr>
<tr>
<td>SwitchExpression</td>
<td>  switch/case</td>
</tr>
<tr>
<td>TryExpression</td>
<td>    try/catch/finally/fault </td>
</tr>
<tr>
<td>CatchBlock</td>
<td>,   ,    </td>
</tr>
<tr>
<td colspan="2" align="center"><b></b></td>
</tr>
<tr>
<td>ElementInit</td>
<td>    IEnumerable.   ListInitExpression</td>
</tr>
<tr>
<td>ListInitExpression</td>
<td>  +   </td>
</tr>
<tr>
<td>DefaultExpression</td>
<td>       </td>
</tr>
<tr>
<td>NewArrayExpression</td>
<td>   +  </td>
</tr>
<tr>
<td>NewExpression</td>
<td> </td>
</tr>
<tr>
<td colspan="2" align="center"><b>  /</b></td>
</tr>
<tr>
<td>MemberAssignment</td>
<td>    </td>
</tr>
<tr>
<td>MemberBinding</td>
<td>  ,    ,  ,        </td>
</tr>
<tr>
<td>MemberExpression</td>
<td>  /</td>
</tr>
<tr>
<td>MemberInitExpression</td>
<td>      </td>
</tr>
<tr>
<td>MemberListBinding</td>
<td> /  </td>
</tr>
<tr>
<td>MemberMemberBinding</td>
<td> / ,    /</td>
</tr>
<tr>
<td colspan="2" align="center"><b></b></td>
</tr>
<tr>
<td>LambdaExpression</td>
<td></td>
</tr>
<tr>
<td>InvocationExpression</td>
<td>   -    </td>
</tr>
<tr>
<td>DebugInfoExpression</td>
<td>       .         </td>
</tr>
<tr>
<td>SymbolDocumentInfo</td>
<td>       ,        .</td>
</tr>
<tr>
<td>DynamicExpression</td>
<td>   ( )</td>
</tr>
<tr>
<td>RuntimeVariablesExpression</td>
<td>   /    </td>
</tr>
<tr>
<td>TypeBinaryExpression</td>
<td>,      (is)</td>
</tr>
</tbody></table></div><br>
      <br>
<br>
<ul>
<li>ExpressionVisitor —     .  .</li>
<li>DynamicExpressionVisitor —      DynamicExpression ( VisitDynamic)</li>
</ul><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Informationen reichen aus, um die Methoden zum Arbeiten mit Ausdrucksbäumen zu vergleichen. </font><font style="vertical-align: inherit;">Ich beschloss, all dies am Beispiel der Suche nach dem Derivat zu analysieren. </font><font style="vertical-align: inherit;">Ich habe nicht alle möglichen Optionen vorausgesehen - nur grundlegende. </font><font style="vertical-align: inherit;">Aber wenn sich aus irgendeinem Grund jemand dazu entschlossen hat, es zu ändern und zu verwenden, werde ich die Verbesserungen gerne über die Anfrage an mein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository weitergeben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="pm"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mustervergleich</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufgabe besteht also darin, eine Ableitung zu berechnen. </font><font style="vertical-align: inherit;">Sie können Folgendes schätzen: Es gibt einige Regeln zum Finden der Ableitung für verschiedene Arten von Operationen - Multiplikation, Division usw. </font><font style="vertical-align: inherit;">Abhängig von der Operation müssen Sie eine bestimmte Formel auswählen. </font><font style="vertical-align: inherit;">In einer solchen banalen Formulierung ist die Aufgabe idealerweise auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schalter / Fall gelegt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Und in der neuesten Version der Sprache wurde uns Switch / Case 2.0 oder </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pattern Matching vorgestellt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist schwer, hier etwas zu besprechen. </font><font style="vertical-align: inherit;">Auf einem Hub sieht eine solche Menge an Code umständlich und schlecht gelesen aus, daher empfehle ich, sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github anzuschauen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Für ein Beispiel eines Derivats stellte sich Folgendes heraus:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PatterntMatchingDerivative</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _one = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
		<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; ParseDerivative(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(ParseDerivative(function.Body), function.Parameters);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> Expression <span class="hljs-title">ParseDerivative</span>(<span class="hljs-params">Expression function</span>)</span> =&gt; function <span class="hljs-keyword">switch</span><font></font>
        {<font></font>
            BinaryExpression binaryExpr =&gt; function.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{	<font></font>
	  	    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression _) =&gt; constant,<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; constant,<font></font>
		    _ =&gt; Expression.Add(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right)))<font></font>
		},<font></font>
<font></font>
                ExpressionType.Divide =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{<font></font>
		    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression parameter) =&gt; Expression.Divide(constant, Expression.Multiply(parameter, parameter)),<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; Expression.Divide(_one, constant),<font></font>
		    _ =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right))<font></font>
	        },<font></font>
            },<font></font>
            MethodCallExpression methodCall <span class="hljs-keyword">when</span> methodCall.Method == _pow =&gt; (methodCall.Arguments[<span class="hljs-number">0</span>], methodCall.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(methodCall, Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, _pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(ParseDerivative(expression), methodCall), Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
             },<font></font>
             _ =&gt; function.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Constant =&gt; _zero,<font></font>
                ExpressionType.Parameter =&gt; _one,<font></font>
                _ =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryException(<span class="hljs-string">"Bitmap best practice"</span>)<font></font>
             }<font></font>
        };<font></font>
    }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht etwas ungewöhnlich aus, aber interessant. </font><font style="vertical-align: inherit;">Es war eine Freude, dies zu schreiben - alle Bedingungen passen organisch in eine Zeile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Beispiel spricht für sich selbst. Sie können es nicht besser mit Worten beschreiben.</font></font><br>
<a name="nv"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naiver Besucher</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einer solchen Aufgabe fällt einem sofort ein Besucher des Ausdrucksbaums </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ein, der unter den Fans </font><font style="vertical-align: inherit;">viel Lärm </font><font style="vertical-align: inherit;">und ein wenig Panik macht, um über Agilität in der Küche zu diskutieren. </font><font style="vertical-align: inherit;">„Fürchte dich nicht vor Unwissenheit, sondern vor falschem Wissen. </font><font style="vertical-align: inherit;">Es ist besser, nichts zu wissen, als die Wahrheit als das zu betrachten, was nicht wahr ist. " </font><font style="vertical-align: inherit;">Wenn Sie sich an diesen wunderbaren Satz von Tolstoi erinnern, Unwissenheit anerkennen und die Unterstützung von Google in Anspruch nehmen, finden Sie die folgende </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anleitung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe diesen Link ist der erste (nach Sibirien im Jahr 1949) für die Abfrage "Ausdrucksbaum Besucher". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Genau das brauchen wir auf den ersten Blick. </font><font style="vertical-align: inherit;">Der Titel des Artikels passt zu dem, was wir tun möchten, und die Klassen in den Beispielen werden mit dem Suffix </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visitor benannt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir den Artikel </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">gelesen</font></a><font style="vertical-align: inherit;"> und analog zu unserem Beispiel mit Derivaten erstellt haben, erhalten wir: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zu Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomDerivativeExpressionTreeVisitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; Visit(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(Visitor.CreateFromExpression(function.Body).Visit(), function.Parameters);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> MethodInfo Pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> MethodInfo Log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> ConstantExpression Zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> ConstantExpression One = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Visitor <span class="hljs-title">CreateFromExpression</span>(<span class="hljs-params">Expression node</span>)</span>
            =&gt; node <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                BinaryExpression be =&gt; <span class="hljs-keyword">new</span> BinaryVisitor(be),<font></font>
                MethodCallExpression mce <span class="hljs-keyword">when</span> mce.Method == Pow =&gt; <span class="hljs-keyword">new</span> PowMethodCallVisitor(mce),<font></font>
                _ =&gt; <span class="hljs-keyword">new</span> SimpleVisitor(node),<font></font>
            };<font></font>
        <font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BinaryVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> BinaryExpression _node;<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinaryVisitor</span>(<span class="hljs-params">BinaryExpression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; _node.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{	<font></font>
	  	    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression _) =&gt; constant,<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; constant,<font></font>
		    _ =&gt; Expression.Add(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right)))<font></font>
		},<font></font>
<font></font>
                ExpressionType.Divide =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{<font></font>
		    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression parameter) =&gt; Expression.Divide(constant, Expression.Multiply(parameter, parameter)),<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; Expression.Divide(_one, constant),<font></font>
		    _ =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right))<font></font>
	        },<font></font>
            };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PowMethodCallVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodCallExpression _node;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PowMethodCallVisitor</span>(<span class="hljs-params">MethodCallExpression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; (_node.Arguments[<span class="hljs-number">0</span>], _node.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(_node, Expression.Call(<span class="hljs-literal">null</span>, Log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, Pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(CreateFromExpression(expression).Visit(), _node), Expression.Call(<span class="hljs-literal">null</span>, Log, constant)),<font></font>
            };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Expression _node;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleVisitor</span>(<span class="hljs-params">Expression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; _node.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Constant =&gt; Zero,<font></font>
                ExpressionType.Parameter =&gt; One,<font></font>
            };<font></font>
    }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich verteilen wir die Switch-Fälle auf verschiedene Klassen. </font><font style="vertical-align: inherit;">Es gab nicht weniger von ihnen, Magie erschien nicht. </font><font style="vertical-align: inherit;">Trotzdem viel mehr Zeilen. </font><font style="vertical-align: inherit;">Und wo ist der versprochene Doppelversand?</font></font><br>
<a name="cv"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassischer Besucher und Doppelversand</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier lohnt es sich, etwas über die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besuchervorlage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> selbst zu erzählen. </font><font style="vertical-align: inherit;">Es ist auch </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besucher</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der die Grundlage für den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besucher</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des </font><i><font style="vertical-align: inherit;">Ausdrucksbaums bildet</font></i><font style="vertical-align: inherit;"> . Lassen Sie es uns nur am Beispiel von Ausdrucksbäumen analysieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir für eine Sekunde an, wir entwerfen Ausdrucksbäume. Wir möchten Benutzern die Möglichkeit geben, den Ausdrucksbaum zu durchlaufen und abhängig von den Knotentypen (Ausdruckstypen) bestimmte Aktionen auszuführen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Möglichkeit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist, nichts zu tun. Das heißt, Benutzer zwingen, Schalter / Fall zu verwenden. Dies ist keine so schlechte Option. Aber hier gibt es eine solche Nuance: Wir verbreiten die Logik, die für einen bestimmten Typ verantwortlich ist. Einfach ausgedrückt, Polymorphismus und virtuelle Herausforderungen (auch </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bekannt als Late Binding)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) ermöglichen es, die Typdefinition auf die Laufzeit zu verschieben und diese Prüfungen aus unserem Code zu entfernen. Es reicht für uns, eine Logik zu haben, die eine Instanz des gewünschten Typs erstellt, dann wird alles zur Laufzeit für uns erledigt. </font></font><br>
 <br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite Option.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die offensichtliche Lösung besteht darin, die Logik in virtuelle Methoden zu ziehen. Durch Überschreiben der virtuellen Methode in jedem Nachfolger können wir Switch / Case vergessen. Der Mechanismus polymorpher Aufrufe wird für uns entscheiden. Die Methodentabelle funktioniert hier, Methoden werden durch den darin enthaltenen Offset aufgerufen. Aber dies ist ein Thema für einen ganzen Artikel, also lassen wir uns nicht mitreißen. Virtuelle Methoden scheinen unser Problem zu lösen. Aber leider schaffen sie eine andere. Für unsere Aufgabe könnten wir die GetDeriviative () -Methode hinzufügen. Aber jetzt sehen die Ausdrucksklassen selbst komisch aus. Wir könnten solche Methoden für alle Gelegenheiten hinzufügen, aber sie passen nicht zur allgemeinen Logik der Klasse. Und wir haben immer noch nicht die Möglichkeit geboten, etwas Ähnliches wie Benutzer zu tun (natürlich in angemessener Weise). Wir müssen den Benutzer die Logik für jeden bestimmten Typ definieren lassen.aber behalte den Polymorphismus (der uns zur Verfügung steht).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nur die Bemühungen des Benutzers, dies zu tun, werden nicht erfolgreich sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier liegt der wahre Besucher. </font><font style="vertical-align: inherit;">In der Grundart der Hierarchie (in unserem Fall Ausdruck) definieren wir eine Methode der Form</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">virtual</span> Expression <span class="hljs-title">Accept</span>(<span class="hljs-params">ExpressionVisitor visitor</span>)</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei den Erben wird diese Methode überschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ExpressionVisitor selbst ist eine Basisklasse, die </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
für jeden Hierarchietyp </font><font style="vertical-align: inherit;">eine virtuelle Methode mit derselben Signatur enthält </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Am Beispiel der ExpressionVisitor-Klasse - VisitBinary (...), VisitMethodCall (...), VisitConstant (...), VisitParameter (...). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methoden werden in der entsprechenden Klasse unserer Hierarchie aufgerufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jene. </font><font style="vertical-align: inherit;">Die Accept-Methode in der BinaryExpression-Klasse sieht folgendermaßen aus:</font></font><br>
<br>
<pre><code class="cs hljs">	
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">internal</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Accept</span>(<span class="hljs-params">ExpressionVisitor visitor</span>)</span><font></font>
{<font></font>
        <span class="hljs-keyword">return</span> visitor.VisitBinary(<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ein neues Verhalten zu definieren, muss der Benutzer daher nur einen Erben der ExpressionVisitor-Klasse erstellen, in dem die entsprechenden Methoden zur Lösung eines Problems neu definiert werden. In unserem Fall wird ein DerivativeExpressionVisitor erstellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weiter haben wir einige Objekte der Nachfolger von Expression, aber welche sind unbekannt, aber nicht notwendig.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir rufen die virtuelle Accept-Methode mit der ExpressionVisitor-Implementierung auf, die wir benötigen, d. H. mit DerivativeExpressionVisitor. Dank des dynamischen Dispatchings wird eine überschriebene Implementierung von Accept aufgerufen, z. B. eine Laufzeit, z. B. BinaryExpression. Im Verlauf dieser Methode verstehen wir genau, dass wir uns in BinaryExpression befinden, wissen jedoch nicht, welcher ExpressionVisitor-Nachfolger zu uns gekommen ist. Aber seit VisitBinary ist auch virtuell, wir müssen es nicht wissen. Wieder rufen wir einfach den Verweis auf die Basisklasse auf, der Aufruf wird dynamisch (zur Laufzeit) ausgelöst und eine überschriebene VisitBinary-Implementierung des Laufzeittyps wird aufgerufen. Soviel zum doppelten Versand - Tischtennis im Stil von „du machst es“ - „nein, du“. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was gibt es uns? Auf diese Weise können virtuelle Methoden von außen hinzugefügt werden, nicht</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
die Klasse ändern. </font><font style="vertical-align: inherit;">Es klingt großartig, hat aber auch Nachteile:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Linke in Form der Accept-Methode, die gleichzeitig für alles und für nichts verantwortlich ist</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Welligkeitseffekt einer guten Hash-Funktion besteht darin, dass im schlimmsten Fall jeder seine Besucher beenden muss, wenn Sie der Hierarchie nur einen Erben hinzufügen</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Art der Ausdrucksbäume ermöglicht diese Kosten jedoch aufgrund der Besonderheiten der Arbeit mit Ausdrücken, da diese Art von Problemumgehungen eines ihrer Hauptmerkmale ist. </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie alle verfügbaren Methoden zum Überladen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie es am Ende aussieht. </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zum Github.</font></font></a><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BuildinExpressionTreeVisitor</span> : <span class="hljs-title">ExpressionVisitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _one = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; GetDerivative(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(Visit(function.Body), function.Parameters);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitBinary</span>(<span class="hljs-params">BinaryExpression binaryExpr</span>)</span>
            =&gt; binaryExpr.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(Visit(binaryExpr.Left), Visit(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(Visit(binaryExpr.Left), Visit(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; _zero,<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ParameterExpression =&gt; binaryExpr.Left,<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ParameterExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; binaryExpr.Right,<font></font>
                ExpressionType.Multiply =&gt; Expression.Add(Expression.Multiply(Visit(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, Visit(binaryExpr.Right))),<font></font>
<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; _zero,<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ParameterExpression =&gt; Expression.Divide(binaryExpr.Left, Expression.Multiply(binaryExpr.Right, binaryExpr.Right)),<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ParameterExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; Expression.Divide(_one, binaryExpr.Right),<font></font>
                ExpressionType.Divide =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(Visit(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, Visit(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right)),<font></font>
            };<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitMethodCall</span>(<span class="hljs-params">MethodCallExpression methodCall</span>)</span>
            =&gt; (methodCall.Arguments[<span class="hljs-number">0</span>], methodCall.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(methodCall, Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, _pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(Visit(expression), methodCall), Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
            };<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitConstant</span>(<span class="hljs-params">ConstantExpression _</span>)</span> =&gt; _zero;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitParameter</span>(<span class="hljs-params">ParameterExpression b</span>)</span> =&gt; _one;<font></font>
    }<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht kann, wie bei den meisten Programmieraufgaben, keine eindeutige Antwort gegeben werden. </font><font style="vertical-align: inherit;">Alles hängt wie immer von der jeweiligen Situation ab. </font><font style="vertical-align: inherit;">Ich mag den üblichen Mustervergleich für mein Beispiel, weil </font><font style="vertical-align: inherit;">Ich habe es nicht im Maßstab der industriellen Entwicklung entwickelt. </font><font style="vertical-align: inherit;">Wenn dieser Ausdruck unkontrolliert zunehmen würde, wäre es wert, über den Besucher nachzudenken. </font><font style="vertical-align: inherit;">Und selbst ein naiver Besucher hat das Recht auf Leben - schließlich ist dies eine gute Möglichkeit, eine große Menge Code in Klassen zu verteilen, wenn die Hierarchie ihrerseits keine Unterstützung geleistet hat. </font><font style="vertical-align: inherit;">Und auch hier gibt es Ausnahmen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenso ist die Unterstützung des Besuchers durch die Hierarchie sehr kontrovers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe jedoch, dass die hier bereitgestellten Informationen ausreichen, um die richtige Wahl zu treffen.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de486972/">https://habr.com/ru/post/de486972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486948/index.html">Wie wähle ich einen Editor aus und warum wähle ich NeoVim?</a></li>
<li><a href="../de486950/index.html">Antiquitäten: das gnadenlose Upgrade des 386. Computers</a></li>
<li><a href="../de486962/index.html">HSE Game Development Review</a></li>
<li><a href="../de486964/index.html">Multitasking und neugierig. Java-Champion Mitya Alexandrov über die Schaffung der IT-Community, der "Remote" und des Lebens</a></li>
<li><a href="../de486966/index.html">Warum Bequemlichkeit gegen Sicherheit kein Kompromiss ist</a></li>
<li><a href="../de486974/index.html">Massenproduktion von Elektronik in Russland. Testautomatisierung</a></li>
<li><a href="../de486976/index.html">Probleme der russischen Informationserziehung und ihre möglichen Lösungen</a></li>
<li><a href="../de486978/index.html">Feldnotizen: Eine der größten OpenSource-Konferenzen FOSDEM 2020</a></li>
<li><a href="../de486980/index.html">Kim Dotcom: Gefangen, die meistgesuchte Person online. Teil 1</a></li>
<li><a href="../de486982/index.html">So lernen Sie die Front-End-Entwicklung, finden Ihren ersten Job und bekommen keine Unebenheiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>