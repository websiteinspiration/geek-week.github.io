<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèø ü¶á ü§ôüèΩ Expressionsb√§ume in C # anhand eines Beispiels zum Auffinden eines Derivats (Expression Tree Visitor vs Pattern Matching) ‚òÄÔ∏è ü§¥ üò±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sch√∂nen Tag. Ausdrucksb√§ume waren, besonders wenn sie mit dem Besuchermuster kombiniert wurden, immer ein ziemlich verwirrendes Thema. Je vielf√§ltiger...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Expressionsb√§ume in C # anhand eines Beispiels zum Auffinden eines Derivats (Expression Tree Visitor vs Pattern Matching)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486972/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sch√∂nen Tag. </font><font style="vertical-align: inherit;">Ausdrucksb√§ume waren, besonders wenn sie mit dem Besuchermuster kombiniert wurden, immer ein ziemlich verwirrendes Thema. </font><font style="vertical-align: inherit;">Je vielf√§ltiger die Informationen zu diesem Thema sind, desto mehr Beispiele, desto einfacher wird es f√ºr diejenigen, die interessiert sind, etwas zu finden, das f√ºr sie klar und n√ºtzlich ist.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xt/6c/bf/xt6cbf1-gfkv4-64zs250n_-7pa.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel ist wie gewohnt aufgebaut - er beginnt mit dem konzeptionellen Rahmen und den Definitionen und endet mit Beispielen und Verwendungsm√∂glichkeiten. </font><font style="vertical-align: inherit;">Inhaltsverzeichnis unten. </font></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundlagen der Expression Trees </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax von Expression Trees Expression </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typen </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pattern Matching </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naive Besucher </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassische Besucher</font></font></a></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nun, das </font><font style="vertical-align: inherit;">ist das Ziel nicht eine bestimmte L√∂sung aufzuzwingen oder sagen , </font><font style="vertical-align: inherit;">dass man besser ist als die andere. </font><font style="vertical-align: inherit;">Ich schlage vor, selbst Schlussfolgerungen zu ziehen und dabei alle Nuancen in Ihrem Fall zu ber√ºcksichtigen. </font><font style="vertical-align: inherit;">Ich werde meine Meinung zu meinem Beispiel √§u√üern.</font></font><br>
<br>
<a name="basic"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausdrucksb√§ume</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Grundlagen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst m√ºssen Sie sich mit Ausdrucksb√§umen befassen. Sie bedeuten die Art des Ausdrucks oder einen seiner Erben (sie werden sp√§ter besprochen). Im √ºblichen Szenario werden die Ausdr√ºcke / Algorithmen in Form von ausf√ºhrbarem Code / ausf√ºhrbaren Anweisungen dargestellt, mit denen der Benutzer m√∂glicherweise nicht viel zu tun hat (haupts√§chlich ausf√ºhren). Mit dem Ausdruckstyp k√∂nnen Sie einen Ausdruck / Algorithmus (normalerweise Lambdas, aber nicht unbedingt) als Daten darstellen, die in einer Baumstruktur organisiert sind, auf die der Benutzer Zugriff hat. Die baumartige Art, Informationen √ºber den Algorithmus und den Namen der Klasse zu organisieren, gibt uns "Ausdrucksb√§ume". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Verdeutlichung werden wir ein einfaches Beispiel analysieren. Angenommen, wir haben Lambda </font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(x) =&gt; Console.WriteLine (x + 5)</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dies kann als der folgende Baum dargestellt werden</font></font><br>
<br>
<div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/yv/wy/sq/yvwysqugbtttw-gvz07tipuq-oy.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Wurzel des Baums ist die Spitze des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodCall</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die Parameter der Methode sind ebenfalls Ausdr√ºcke, daher kann sie eine beliebige Anzahl von </font><b><font style="vertical-align: inherit;">untergeordneten Elementen</font></b><font style="vertical-align: inherit;"> haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall gibt es nur einen Nachkommen - den Peak von " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArithmeticOperation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". Es enth√§lt Informationen dar√ºber, um welche Art von Operation es sich handelt, und der linke und der rechte Operand sind ebenfalls Ausdr√ºcke. Ein solcher Scheitelpunkt hat immer 2 Nachkommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Operanden werden durch eine Konstante ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstante</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und einen Parameter ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dargestellt. Solche Ausdr√ºcke haben keine Nachkommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies sind sehr vereinfachte Beispiele, die jedoch die Essenz vollst√§ndig widerspiegeln.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Hauptmerkmal von Ausdrucksb√§umen ist, dass sie analysiert werden k√∂nnen und alle erforderlichen Informationen dar√ºber lesen, was der Algorithmus tun soll. In gewisser Hinsicht ist dies das Gegenteil von Attributen. Attribute sind ein Mittel zur deklarativen Beschreibung des Verhaltens (sehr bedingt, aber das endg√ºltige Ziel ist ungef√§hr dasselbe). W√§hrend Ausdrucksb√§ume eine Funktion / einen Algorithmus verwenden, um Daten zu beschreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden beispielsweise in </font><font style="vertical-align: inherit;">Entity-Framework- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anbietern verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die Anwendung liegt auf der Hand - den Ausdrucksbaum zu analysieren, zu verstehen, was dort ausgef√ºhrt werden soll, und aus dieser Beschreibung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL zu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellen </font><font style="vertical-align: inherit;">. Weniger bekannte Beispiele sind die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moq-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliotheken zum Rauchen </font><font style="vertical-align: inherit;">. Ausdrucksb√§ume werden auch im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DLR verwendet.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dynamische Sprachlaufzeit). </font><font style="vertical-align: inherit;">Compiler-Entwickler verwenden sie, um die Kompatibilit√§t zwischen der dynamischen Natur und Dotnet sicherzustellen, anstatt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSIL zu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generieren </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erw√§hnenswert ist auch, dass Ausdrucksb√§ume unver√§nderlich sind.</font></font><br>
<a name="syn"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das n√§chste, was es wert ist, besprochen zu werden, ist die Syntax. </font><font style="vertical-align: inherit;">Es gibt zwei Hauptwege:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen von Ausdrucksb√§umen mit statischen Methoden der Expression-Klasse</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden von in Expression kompilierten Lambda-Ausdr√ºcken</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statische Methoden der Ausdrucksklasse</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erstellen von Ausdrucksb√§umen mit statischen Methoden der Ausdrucksklasse wird seltener verwendet (insbesondere aus Benutzersicht). Dies ist umst√§ndlich, aber recht einfach. Wir verf√ºgen √ºber </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
viele Grundbausteine, aus denen Sie recht komplexe </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dinge </font><font style="vertical-align: inherit;">bauen k√∂nnen </font><font style="vertical-align: inherit;">. Die Erstellung erfolgt seitdem durch statische Methoden Ausdruckskonstruktoren haben einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">internen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modifikator </font><font style="vertical-align: inherit;">. Und das bedeutet nicht, dass Sie Reflexion aufdecken m√ºssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Beispiel werde ich einen Ausdruck aus dem obigen Beispiel erstellen: </font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(x) =&gt; Console.WriteLine (x + 5)</font></font></i></b><br>
<br>
<pre><code class="cs hljs">ParameterExpression parameter = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
ConstantExpression constant = Expression.Constant(<span class="hljs-number">5</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
BinaryExpression <span class="hljs-keyword">add</span> = Expression.Add(parameter, constant);<font></font>
MethodInfo writeLine = <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.WriteLine), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });<font></font>
MethodCallExpression methodCall = Expression.Call(<span class="hljs-literal">null</span>, writeLine, <span class="hljs-keyword">add</span>);<font></font>
Expression&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt; expressionlambda = Expression.Lambda&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt;(methodCall, parameter);<font></font>
Action&lt;<span class="hljs-keyword">double</span>&gt; delegateLambda = expressionlambda.Compile();<font></font>
delegateLambda(<span class="hljs-number">123321</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist m√∂glicherweise kein sehr bequemer Weg, spiegelt jedoch die interne Struktur von Ausdrucksb√§umen vollst√§ndig wider. </font><font style="vertical-align: inherit;">Dar√ºber hinaus bietet diese Methode weitere Funktionen, die in Ausdrucksb√§umen verwendet werden k√∂nnen: Ausgehend von Schleifen, Bedingungen, Try-Catch, Goto, Zuweisung, Beenden mit Fehlerbl√∂cken, Debuggen von Informationen f√ºr Haltepunkte, Dynamisch usw.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lambda-Ausdruck</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verwendung von Lambdas als Ausdruck ist h√§ufiger. </font><font style="vertical-align: inherit;">Es funktioniert sehr einfach - der Smart Compiler in der Kompilierungsphase untersucht, wof√ºr Lambda verwendet wird. </font><font style="vertical-align: inherit;">Und kompiliert es entweder zu einem Delegaten oder zu einem Ausdruck. </font><font style="vertical-align: inherit;">In einem bereits gemasterten Beispiel sieht es wie folgt aus</font></font><br>
<br>
<pre><code class="cs hljs">Expression&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt; write =  =&gt; Console.WriteLine( + <span class="hljs-number">5</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es lohnt sich, so etwas zu kl√§ren - ein Ausdruck ist eine ersch√∂pfende Beschreibung. </font><font style="vertical-align: inherit;">Und es reicht aus, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
um das Ergebnis zu erhalten. </font><font style="vertical-align: inherit;">Ausdrucksb√§ume wie LambdaExpression oder seine Nachkommen k√∂nnen </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
in eine ausf√ºhrbare IL konvertiert werden. </font><font style="vertical-align: inherit;">Die verbleibenden Typen k√∂nnen nicht direkt in ausf√ºhrbaren Code konvertiert werden (dies ist jedoch nicht sehr sinnvoll). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úbrigens, wenn jemand die schnelle Kompilierung eines Ausdrucks kritisiert, k√∂nnen Sie sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projekt </font><font style="vertical-align: inherit;">eines </font><font style="vertical-align: inherit;">Drittanbieters </font><font style="vertical-align: inherit;">ansehen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Gegenteil ist im allgemeinen Fall nicht der Fall. </font><font style="vertical-align: inherit;">Ein Delegierter kann es nicht einfach aufgreifen und sich als Ausdruck vorstellen (aber das ist immer noch m√∂glich). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nicht alle Lambdas k√∂nnen in Ausdrucksb√§ume umgewandelt werden. </font><font style="vertical-align: inherit;">Diese beinhalten:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enth√§lt Zuweisungsoperator</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamisch beitragen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchron</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit K√∂rper (Zahnspange)</font></font></li>
</ul><br>
<pre><code class="cs hljs"><span class="hljs-keyword">double</span> variable;
<span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">dynamic</span>;<font></font>
Expression&lt;Action&gt; assignment = () =&gt; variable = <span class="hljs-number">5</span>; <span class="hljs-comment">//Compiler error: An expression tree may not contain an assignment operator</span>
Expression&lt;Func&lt;<span class="hljs-keyword">double</span>&gt;&gt; dynamically = () =&gt; <span class="hljs-keyword">dynamic</span>; <span class="hljs-comment">//Compiler error: An expression tree may not contain a dynamic operation</span>
Expression&lt;Func&lt;Task&gt;&gt; asynchon = <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">await</span> Task.CompletedTask; <span class="hljs-comment">//Compiler error: Async lambda cannot be converted to expresiion trees</span>
Expression&lt;Action&gt; body = () =&gt; { }; <span class="hljs-comment">//Compiler error: A lambda expression with a statement body cannot be converted to an expression tree</span>
</code></pre> <br>
<a name="types"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arten von Ausdr√ºcken</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich schlage einen kurzen Blick auf die verf√ºgbaren Typen vor, um darzustellen, welche M√∂glichkeiten wir haben. </font><font style="vertical-align: inherit;">Alle befinden sich im Namespace </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Linq.Expressions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich schlage vor, dass Sie sich zuerst mit einigen wirklich interessanten und ungew√∂hnlichen Funktionen vertraut machen. </font><font style="vertical-align: inherit;">Die einfacheren Arten von Ausdr√ºcken habe ich in einem Tablet mit einer kurzen Beschreibung zusammengestellt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamisch</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit DynamicExpression k√∂nnen Sie Dynamic und alle seine Funktionen in Ausdrucksb√§umen verwenden. </font><font style="vertical-align: inherit;">Es gibt eine ziemlich verwirrende API, ich habe l√§nger an diesem Beispiel gesessen als an allen anderen zusammen. </font><font style="vertical-align: inherit;">Die ganze Verwirrung wird durch eine Reihe verschiedener Flaggen verursacht. </font><font style="vertical-align: inherit;">Und einige von ihnen √§hneln denen, die Sie suchen, aber sie sind nicht unbedingt. </font><font style="vertical-align: inherit;">Und wenn Sie mit dynamischen Ausdrucksb√§umen arbeiten, ist es schwierig, einen Sprechfehler zu erhalten. </font><font style="vertical-align: inherit;">Beispiel:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> parameter1 = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), <span class="hljs-string">"name1"</span>);
<span class="hljs-keyword">var</span> parameter2 = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), <span class="hljs-string">"name2"</span>); 
<span class="hljs-keyword">var</span> dynamicParam1 = CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal">null</span>);
<span class="hljs-keyword">var</span> dynamicParam2 = CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal">null</span>);<font></font>
CallSiteBinder csb = Microsoft.CSharp.RuntimeBinder.Binder.BinaryOperation(CSharpBinderFlags.None, ExpressionType.Add, <span class="hljs-keyword">typeof</span>(Program), <span class="hljs-keyword">new</span>[] { dynamicParam1, dynamicParam2 });
<span class="hljs-keyword">var</span> dyno = Expression.Dynamic(csb, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), parameter1, parameter2);<font></font>
Expression&lt;Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt;&gt; expr = Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt;&gt;(dyno, <span class="hljs-keyword">new</span>[] { parameter1, parameter2 });<font></font>
Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt; action = expr.Compile();
<span class="hljs-keyword">var</span> res = action(<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>);<font></font>
Console.WriteLine(res); <span class="hljs-comment">//12</span>
res = action(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<font></font>
Console.WriteLine(res); <span class="hljs-comment">//3</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe ausdr√ºcklich angegeben, woher der Binder stammt, um Verwechslungen mit dem Binder von System.Reflection zu vermeiden. </font><font style="vertical-align: inherit;">Von interessanten Dingen k√∂nnen wir ref- und out-Parameter, benannte Parameter, un√§re Operationen und im Prinzip alles tun, was durch Dynamik m√∂glich ist, aber dies erfordert einige F√§higkeiten.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmefangbl√∂cke</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite, worauf ich achten werde, ist die Funktion try / catch / finally / error oder vielmehr die Tatsache, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dass wir Zugriff auf den Fehlerblock haben. </font><font style="vertical-align: inherit;">Es ist nicht in C # verf√ºgbar, aber in MSIL. Dies ist eine Art </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
endg√ºltiges Analogon, das im Falle einer Ausnahme ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">Im folgenden Beispiel wird eine Ausnahme ausgel√∂st, wonach "Hi" angezeigt wird und das Programm auf die Eingabe wartet. </font><font style="vertical-align: inherit;">Erst danach wird es vollst√§ndig fallen. </font><font style="vertical-align: inherit;">Ich empfehle diese Praxis nicht zur Verwendung.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> throwSmth = Expression.Throw(Expression.Constant(<span class="hljs-keyword">new</span> Exception(), <span class="hljs-keyword">typeof</span>(Exception)));
<span class="hljs-keyword">var</span> log = Expression.Call(<span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.WriteLine), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">string</span>) }), Expression.Constant(<span class="hljs-string">"Hi"</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">string</span>)));
<span class="hljs-keyword">var</span> read = Expression.Call(<span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.ReadLine)));
<span class="hljs-keyword">var</span> fault = Expression.TryFault(throwSmth, Expression.Block(<span class="hljs-keyword">new</span>[] { log, read }));<font></font>
Expression&lt;Action&gt; expr = Expression.Lambda&lt;Action&gt;(fault);<font></font>
Action compiledExpression = expr.Compile();<font></font>
compiledExpression();<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurze Beschreibung der verf√ºgbaren Ausdrucksbaumtypen</font></font></b><div class="spoiler_text"><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabelle</font></font></h4><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Art</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurzbeschreibung</font></font></th>
</tr>
<tr>
<td colspan="2" align="center"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Haupt</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausdruck</font></font></td>
<td> ,      .     ,      </td>
</tr>
<tr>
<td>Expression&lt;TDelegate&gt;</td>
<td>    </td>
</tr>
<tr>
<td colspan="2" align="center"><b> </b></td>
</tr>
<tr>
<td>BinaryExpression</td>
<td>     (+, ‚Äî  )</td>
</tr>
<tr>
<td>UnaryExpression</td>
<td> (+, -),    throw</td>
</tr>
<tr>
<td>ConstantExpression</td>
<td> ‚Äî   </td>
</tr>
<tr>
<td>ParameterExpression</td>
<td> </td>
</tr>
<tr>
<td>MethodCallExpression</td>
<td>  ,  MethodInfo</td>
</tr>
<tr>
<td>IndexExpression</td>
<td></td>
</tr>
<tr>
<td>BlockExpression</td>
<td>,   .      </td>
</tr>
<tr>
<td colspan="2" align="center"><b>  </b></td>
</tr>
<tr>
<td>ConditionalExpression </td>
<td>   ‚Äî if-else</td>
</tr>
<tr>
<td>LabelTarget</td>
<td>   goto</td>
</tr>
<tr>
<td>LabelExpression</td>
<td> ,            .    LabelTarget.    ,    GotoExpression,    ‚Äî   .    void,    .</td>
</tr>
<tr>
<td>GotoExpression</td>
<td>  .    . ( .. ¬´break¬ª)</td>
</tr>
<tr>
<td>LoopExpression</td>
<td> ,    ¬´break¬ª</td>
</tr>
<tr>
<td>SwitchCase</td>
<td>    SwitchExpression</td>
</tr>
<tr>
<td>SwitchExpression</td>
<td>  switch/case</td>
</tr>
<tr>
<td>TryExpression</td>
<td>    try/catch/finally/fault </td>
</tr>
<tr>
<td>CatchBlock</td>
<td>,   ,    </td>
</tr>
<tr>
<td colspan="2" align="center"><b></b></td>
</tr>
<tr>
<td>ElementInit</td>
<td>    IEnumerable.   ListInitExpression</td>
</tr>
<tr>
<td>ListInitExpression</td>
<td>  +   </td>
</tr>
<tr>
<td>DefaultExpression</td>
<td>       </td>
</tr>
<tr>
<td>NewArrayExpression</td>
<td>   +  </td>
</tr>
<tr>
<td>NewExpression</td>
<td> </td>
</tr>
<tr>
<td colspan="2" align="center"><b>  /</b></td>
</tr>
<tr>
<td>MemberAssignment</td>
<td>    </td>
</tr>
<tr>
<td>MemberBinding</td>
<td>  ,    ,  ,        </td>
</tr>
<tr>
<td>MemberExpression</td>
<td>  /</td>
</tr>
<tr>
<td>MemberInitExpression</td>
<td>      </td>
</tr>
<tr>
<td>MemberListBinding</td>
<td> /  </td>
</tr>
<tr>
<td>MemberMemberBinding</td>
<td> / ,    /</td>
</tr>
<tr>
<td colspan="2" align="center"><b></b></td>
</tr>
<tr>
<td>LambdaExpression</td>
<td></td>
</tr>
<tr>
<td>InvocationExpression</td>
<td>   -    </td>
</tr>
<tr>
<td>DebugInfoExpression</td>
<td>       .         </td>
</tr>
<tr>
<td>SymbolDocumentInfo</td>
<td>       ,        .</td>
</tr>
<tr>
<td>DynamicExpression</td>
<td>   ( )</td>
</tr>
<tr>
<td>RuntimeVariablesExpression</td>
<td>   /    </td>
</tr>
<tr>
<td>TypeBinaryExpression</td>
<td>,      (is)</td>
</tr>
</tbody></table></div><br>
      <br>
<br>
<ul>
<li>ExpressionVisitor ‚Äî     .  .</li>
<li>DynamicExpressionVisitor ‚Äî      DynamicExpression ( VisitDynamic)</li>
</ul><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Informationen reichen aus, um die Methoden zum Arbeiten mit Ausdrucksb√§umen zu vergleichen. </font><font style="vertical-align: inherit;">Ich beschloss, all dies am Beispiel der Suche nach dem Derivat zu analysieren. </font><font style="vertical-align: inherit;">Ich habe nicht alle m√∂glichen Optionen vorausgesehen - nur grundlegende. </font><font style="vertical-align: inherit;">Aber wenn sich aus irgendeinem Grund jemand dazu entschlossen hat, es zu √§ndern und zu verwenden, werde ich die Verbesserungen gerne √ºber die Anfrage an mein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository weitergeben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="pm"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mustervergleich</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufgabe besteht also darin, eine Ableitung zu berechnen. </font><font style="vertical-align: inherit;">Sie k√∂nnen Folgendes sch√§tzen: Es gibt einige Regeln zum Finden der Ableitung f√ºr verschiedene Arten von Operationen - Multiplikation, Division usw. </font><font style="vertical-align: inherit;">Abh√§ngig von der Operation m√ºssen Sie eine bestimmte Formel ausw√§hlen. </font><font style="vertical-align: inherit;">In einer solchen banalen Formulierung ist die Aufgabe idealerweise auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schalter / Fall gelegt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Und in der neuesten Version der Sprache wurde uns Switch / Case 2.0 oder </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pattern Matching vorgestellt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist schwer, hier etwas zu besprechen. </font><font style="vertical-align: inherit;">Auf einem Hub sieht eine solche Menge an Code umst√§ndlich und schlecht gelesen aus, daher empfehle ich, sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github anzuschauen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">F√ºr ein Beispiel eines Derivats stellte sich Folgendes heraus:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PatterntMatchingDerivative</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _one = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
		<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; ParseDerivative(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(ParseDerivative(function.Body), function.Parameters);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> Expression <span class="hljs-title">ParseDerivative</span>(<span class="hljs-params">Expression function</span>)</span> =&gt; function <span class="hljs-keyword">switch</span><font></font>
        {<font></font>
            BinaryExpression binaryExpr =&gt; function.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{	<font></font>
	  	    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression _) =&gt; constant,<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; constant,<font></font>
		    _ =&gt; Expression.Add(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right)))<font></font>
		},<font></font>
<font></font>
                ExpressionType.Divide =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{<font></font>
		    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression parameter) =&gt; Expression.Divide(constant, Expression.Multiply(parameter, parameter)),<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; Expression.Divide(_one, constant),<font></font>
		    _ =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right))<font></font>
	        },<font></font>
            },<font></font>
            MethodCallExpression methodCall <span class="hljs-keyword">when</span> methodCall.Method == _pow =&gt; (methodCall.Arguments[<span class="hljs-number">0</span>], methodCall.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(methodCall, Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, _pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(ParseDerivative(expression), methodCall), Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
             },<font></font>
             _ =&gt; function.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Constant =&gt; _zero,<font></font>
                ExpressionType.Parameter =&gt; _one,<font></font>
                _ =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryException(<span class="hljs-string">"Bitmap best practice"</span>)<font></font>
             }<font></font>
        };<font></font>
    }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht etwas ungew√∂hnlich aus, aber interessant. </font><font style="vertical-align: inherit;">Es war eine Freude, dies zu schreiben - alle Bedingungen passen organisch in eine Zeile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Beispiel spricht f√ºr sich selbst. Sie k√∂nnen es nicht besser mit Worten beschreiben.</font></font><br>
<a name="nv"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naiver Besucher</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einer solchen Aufgabe f√§llt einem sofort ein Besucher des Ausdrucksbaums </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ein, der unter den Fans </font><font style="vertical-align: inherit;">viel L√§rm </font><font style="vertical-align: inherit;">und ein wenig Panik macht, um √ºber Agilit√§t in der K√ºche zu diskutieren. </font><font style="vertical-align: inherit;">‚ÄûF√ºrchte dich nicht vor Unwissenheit, sondern vor falschem Wissen. </font><font style="vertical-align: inherit;">Es ist besser, nichts zu wissen, als die Wahrheit als das zu betrachten, was nicht wahr ist. " </font><font style="vertical-align: inherit;">Wenn Sie sich an diesen wunderbaren Satz von Tolstoi erinnern, Unwissenheit anerkennen und die Unterst√ºtzung von Google in Anspruch nehmen, finden Sie die folgende </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anleitung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe diesen Link ist der erste (nach Sibirien im Jahr 1949) f√ºr die Abfrage "Ausdrucksbaum Besucher". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Genau das brauchen wir auf den ersten Blick. </font><font style="vertical-align: inherit;">Der Titel des Artikels passt zu dem, was wir tun m√∂chten, und die Klassen in den Beispielen werden mit dem Suffix </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visitor benannt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir den Artikel </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">gelesen</font></a><font style="vertical-align: inherit;"> und analog zu unserem Beispiel mit Derivaten erstellt haben, erhalten wir: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zu Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomDerivativeExpressionTreeVisitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; Visit(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(Visitor.CreateFromExpression(function.Body).Visit(), function.Parameters);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> MethodInfo Pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> MethodInfo Log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> ConstantExpression Zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> ConstantExpression One = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Visitor <span class="hljs-title">CreateFromExpression</span>(<span class="hljs-params">Expression node</span>)</span>
            =&gt; node <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                BinaryExpression be =&gt; <span class="hljs-keyword">new</span> BinaryVisitor(be),<font></font>
                MethodCallExpression mce <span class="hljs-keyword">when</span> mce.Method == Pow =&gt; <span class="hljs-keyword">new</span> PowMethodCallVisitor(mce),<font></font>
                _ =&gt; <span class="hljs-keyword">new</span> SimpleVisitor(node),<font></font>
            };<font></font>
        <font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BinaryVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> BinaryExpression _node;<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinaryVisitor</span>(<span class="hljs-params">BinaryExpression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; _node.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{	<font></font>
	  	    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression _) =&gt; constant,<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; constant,<font></font>
		    _ =&gt; Expression.Add(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right)))<font></font>
		},<font></font>
<font></font>
                ExpressionType.Divide =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{<font></font>
		    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression parameter) =&gt; Expression.Divide(constant, Expression.Multiply(parameter, parameter)),<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; Expression.Divide(_one, constant),<font></font>
		    _ =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right))<font></font>
	        },<font></font>
            };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PowMethodCallVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodCallExpression _node;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PowMethodCallVisitor</span>(<span class="hljs-params">MethodCallExpression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; (_node.Arguments[<span class="hljs-number">0</span>], _node.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(_node, Expression.Call(<span class="hljs-literal">null</span>, Log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, Pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(CreateFromExpression(expression).Visit(), _node), Expression.Call(<span class="hljs-literal">null</span>, Log, constant)),<font></font>
            };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Expression _node;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleVisitor</span>(<span class="hljs-params">Expression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; _node.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Constant =&gt; Zero,<font></font>
                ExpressionType.Parameter =&gt; One,<font></font>
            };<font></font>
    }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich verteilen wir die Switch-F√§lle auf verschiedene Klassen. </font><font style="vertical-align: inherit;">Es gab nicht weniger von ihnen, Magie erschien nicht. </font><font style="vertical-align: inherit;">Trotzdem viel mehr Zeilen. </font><font style="vertical-align: inherit;">Und wo ist der versprochene Doppelversand?</font></font><br>
<a name="cv"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassischer Besucher und Doppelversand</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier lohnt es sich, etwas √ºber die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besuchervorlage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> selbst zu erz√§hlen. </font><font style="vertical-align: inherit;">Es ist auch </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besucher</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der die Grundlage f√ºr den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besucher</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des </font><i><font style="vertical-align: inherit;">Ausdrucksbaums bildet</font></i><font style="vertical-align: inherit;"> . Lassen Sie es uns nur am Beispiel von Ausdrucksb√§umen analysieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir f√ºr eine Sekunde an, wir entwerfen Ausdrucksb√§ume. Wir m√∂chten Benutzern die M√∂glichkeit geben, den Ausdrucksbaum zu durchlaufen und abh√§ngig von den Knotentypen (Ausdruckstypen) bestimmte Aktionen auszuf√ºhren. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste M√∂glichkeit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist, nichts zu tun. Das hei√üt, Benutzer zwingen, Schalter / Fall zu verwenden. Dies ist keine so schlechte Option. Aber hier gibt es eine solche Nuance: Wir verbreiten die Logik, die f√ºr einen bestimmten Typ verantwortlich ist. Einfach ausgedr√ºckt, Polymorphismus und virtuelle Herausforderungen (auch </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bekannt als Late Binding)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) erm√∂glichen es, die Typdefinition auf die Laufzeit zu verschieben und diese Pr√ºfungen aus unserem Code zu entfernen. Es reicht f√ºr uns, eine Logik zu haben, die eine Instanz des gew√ºnschten Typs erstellt, dann wird alles zur Laufzeit f√ºr uns erledigt. </font></font><br>
 <br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite Option.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die offensichtliche L√∂sung besteht darin, die Logik in virtuelle Methoden zu ziehen. Durch √úberschreiben der virtuellen Methode in jedem Nachfolger k√∂nnen wir Switch / Case vergessen. Der Mechanismus polymorpher Aufrufe wird f√ºr uns entscheiden. Die Methodentabelle funktioniert hier, Methoden werden durch den darin enthaltenen Offset aufgerufen. Aber dies ist ein Thema f√ºr einen ganzen Artikel, also lassen wir uns nicht mitrei√üen. Virtuelle Methoden scheinen unser Problem zu l√∂sen. Aber leider schaffen sie eine andere. F√ºr unsere Aufgabe k√∂nnten wir die GetDeriviative () -Methode hinzuf√ºgen. Aber jetzt sehen die Ausdrucksklassen selbst komisch aus. Wir k√∂nnten solche Methoden f√ºr alle Gelegenheiten hinzuf√ºgen, aber sie passen nicht zur allgemeinen Logik der Klasse. Und wir haben immer noch nicht die M√∂glichkeit geboten, etwas √Ñhnliches wie Benutzer zu tun (nat√ºrlich in angemessener Weise). Wir m√ºssen den Benutzer die Logik f√ºr jeden bestimmten Typ definieren lassen.aber behalte den Polymorphismus (der uns zur Verf√ºgung steht).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nur die Bem√ºhungen des Benutzers, dies zu tun, werden nicht erfolgreich sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier liegt der wahre Besucher. </font><font style="vertical-align: inherit;">In der Grundart der Hierarchie (in unserem Fall Ausdruck) definieren wir eine Methode der Form</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">virtual</span> Expression <span class="hljs-title">Accept</span>(<span class="hljs-params">ExpressionVisitor visitor</span>)</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei den Erben wird diese Methode √ºberschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ExpressionVisitor selbst ist eine Basisklasse, die </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
f√ºr jeden Hierarchietyp </font><font style="vertical-align: inherit;">eine virtuelle Methode mit derselben Signatur enth√§lt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Am Beispiel der ExpressionVisitor-Klasse - VisitBinary (...), VisitMethodCall (...), VisitConstant (...), VisitParameter (...). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methoden werden in der entsprechenden Klasse unserer Hierarchie aufgerufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jene. </font><font style="vertical-align: inherit;">Die Accept-Methode in der BinaryExpression-Klasse sieht folgenderma√üen aus:</font></font><br>
<br>
<pre><code class="cs hljs">	
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">internal</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Accept</span>(<span class="hljs-params">ExpressionVisitor visitor</span>)</span><font></font>
{<font></font>
        <span class="hljs-keyword">return</span> visitor.VisitBinary(<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ein neues Verhalten zu definieren, muss der Benutzer daher nur einen Erben der ExpressionVisitor-Klasse erstellen, in dem die entsprechenden Methoden zur L√∂sung eines Problems neu definiert werden. In unserem Fall wird ein DerivativeExpressionVisitor erstellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weiter haben wir einige Objekte der Nachfolger von Expression, aber welche sind unbekannt, aber nicht notwendig.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir rufen die virtuelle Accept-Methode mit der ExpressionVisitor-Implementierung auf, die wir ben√∂tigen, d. H. mit DerivativeExpressionVisitor. Dank des dynamischen Dispatchings wird eine √ºberschriebene Implementierung von Accept aufgerufen, z. B. eine Laufzeit, z. B. BinaryExpression. Im Verlauf dieser Methode verstehen wir genau, dass wir uns in BinaryExpression befinden, wissen jedoch nicht, welcher ExpressionVisitor-Nachfolger zu uns gekommen ist. Aber seit VisitBinary ist auch virtuell, wir m√ºssen es nicht wissen. Wieder rufen wir einfach den Verweis auf die Basisklasse auf, der Aufruf wird dynamisch (zur Laufzeit) ausgel√∂st und eine √ºberschriebene VisitBinary-Implementierung des Laufzeittyps wird aufgerufen. Soviel zum doppelten Versand - Tischtennis im Stil von ‚Äûdu machst es‚Äú - ‚Äûnein, du‚Äú. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was gibt es uns? Auf diese Weise k√∂nnen virtuelle Methoden von au√üen hinzugef√ºgt werden, nicht</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
die Klasse √§ndern. </font><font style="vertical-align: inherit;">Es klingt gro√üartig, hat aber auch Nachteile:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Linke in Form der Accept-Methode, die gleichzeitig f√ºr alles und f√ºr nichts verantwortlich ist</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Welligkeitseffekt einer guten Hash-Funktion besteht darin, dass im schlimmsten Fall jeder seine Besucher beenden muss, wenn Sie der Hierarchie nur einen Erben hinzuf√ºgen</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Art der Ausdrucksb√§ume erm√∂glicht diese Kosten jedoch aufgrund der Besonderheiten der Arbeit mit Ausdr√ºcken, da diese Art von Problemumgehungen eines ihrer Hauptmerkmale ist. </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie alle verf√ºgbaren Methoden zum √úberladen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie es am Ende aussieht. </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zum Github.</font></font></a><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BuildinExpressionTreeVisitor</span> : <span class="hljs-title">ExpressionVisitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _one = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; GetDerivative(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(Visit(function.Body), function.Parameters);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitBinary</span>(<span class="hljs-params">BinaryExpression binaryExpr</span>)</span>
            =&gt; binaryExpr.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(Visit(binaryExpr.Left), Visit(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(Visit(binaryExpr.Left), Visit(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; _zero,<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ParameterExpression =&gt; binaryExpr.Left,<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ParameterExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; binaryExpr.Right,<font></font>
                ExpressionType.Multiply =&gt; Expression.Add(Expression.Multiply(Visit(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, Visit(binaryExpr.Right))),<font></font>
<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; _zero,<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ParameterExpression =&gt; Expression.Divide(binaryExpr.Left, Expression.Multiply(binaryExpr.Right, binaryExpr.Right)),<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ParameterExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; Expression.Divide(_one, binaryExpr.Right),<font></font>
                ExpressionType.Divide =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(Visit(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, Visit(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right)),<font></font>
            };<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitMethodCall</span>(<span class="hljs-params">MethodCallExpression methodCall</span>)</span>
            =&gt; (methodCall.Arguments[<span class="hljs-number">0</span>], methodCall.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(methodCall, Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, _pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(Visit(expression), methodCall), Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
            };<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitConstant</span>(<span class="hljs-params">ConstantExpression _</span>)</span> =&gt; _zero;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitParameter</span>(<span class="hljs-params">ParameterExpression b</span>)</span> =&gt; _one;<font></font>
    }<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht kann, wie bei den meisten Programmieraufgaben, keine eindeutige Antwort gegeben werden. </font><font style="vertical-align: inherit;">Alles h√§ngt wie immer von der jeweiligen Situation ab. </font><font style="vertical-align: inherit;">Ich mag den √ºblichen Mustervergleich f√ºr mein Beispiel, weil </font><font style="vertical-align: inherit;">Ich habe es nicht im Ma√üstab der industriellen Entwicklung entwickelt. </font><font style="vertical-align: inherit;">Wenn dieser Ausdruck unkontrolliert zunehmen w√ºrde, w√§re es wert, √ºber den Besucher nachzudenken. </font><font style="vertical-align: inherit;">Und selbst ein naiver Besucher hat das Recht auf Leben - schlie√ülich ist dies eine gute M√∂glichkeit, eine gro√üe Menge Code in Klassen zu verteilen, wenn die Hierarchie ihrerseits keine Unterst√ºtzung geleistet hat. </font><font style="vertical-align: inherit;">Und auch hier gibt es Ausnahmen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenso ist die Unterst√ºtzung des Besuchers durch die Hierarchie sehr kontrovers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe jedoch, dass die hier bereitgestellten Informationen ausreichen, um die richtige Wahl zu treffen.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de486972/">https://habr.com/ru/post/de486972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486948/index.html">Wie w√§hle ich einen Editor aus und warum w√§hle ich NeoVim?</a></li>
<li><a href="../de486950/index.html">Antiquit√§ten: das gnadenlose Upgrade des 386. Computers</a></li>
<li><a href="../de486962/index.html">HSE Game Development Review</a></li>
<li><a href="../de486964/index.html">Multitasking und neugierig. Java-Champion Mitya Alexandrov √ºber die Schaffung der IT-Community, der "Remote" und des Lebens</a></li>
<li><a href="../de486966/index.html">Warum Bequemlichkeit gegen Sicherheit kein Kompromiss ist</a></li>
<li><a href="../de486974/index.html">Massenproduktion von Elektronik in Russland. Testautomatisierung</a></li>
<li><a href="../de486976/index.html">Probleme der russischen Informationserziehung und ihre m√∂glichen L√∂sungen</a></li>
<li><a href="../de486978/index.html">Feldnotizen: Eine der gr√∂√üten OpenSource-Konferenzen FOSDEM 2020</a></li>
<li><a href="../de486980/index.html">Kim Dotcom: Gefangen, die meistgesuchte Person online. Teil 1</a></li>
<li><a href="../de486982/index.html">So lernen Sie die Front-End-Entwicklung, finden Ihren ersten Job und bekommen keine Unebenheiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>