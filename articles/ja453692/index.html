<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗣️ ➕ 🗡️ 初心者向け3Dゲームシェーダー：効果 👊🏾 🧑🏿 🧗🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ 最初の部分 ] 
 
 基本を扱ったので、記事のこの部分では、オブジェクトのアウトライン、ブルーム、SSAO、ぼかし、被写界深度、ピクセレーションなどのエフェクトを実装します。
 
 輪郭
 
 シーンのジオメトリの周りに輪郭を作成すると、コミックや漫画に似たユニークな外観がゲームに与えられます...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>初心者向け3Dゲームシェーダー：効果</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453692/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の部分</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本を扱ったので、記事のこの部分では、オブジェクトのアウトライン、ブルーム、SSAO、ぼかし、被写界深度、ピクセレーションなどのエフェクトを実装します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">輪郭</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/96f/9b2/3b896f9b246e1695fa908b4bdc145480.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーンのジオメトリの周りに輪郭を作成すると、コミックや漫画に似たユニークな外観がゲームに与えられます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡散材</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
輪郭シェーダーには、エッジを認識して色を付けるための入力テクスチャが必要です。</font><font style="vertical-align: inherit;">このような入力テクスチャの候補は、マテリアルの拡散色、拡散テクスチャの色、頂点法線、または法線マップの色です。</font></font><br>
<br>
<pre><code class="cpp hljs">uniform <span class="hljs-class"><span class="hljs-keyword">struct</span>
  {</span> vec4 diffuse<font></font>
  ;<font></font>
  } p3d_Material;<font></font>
<font></font>
out vec4 fragColor;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<font></font>
  vec3 diffuseColor = p3d_Material.diffuse.rgb;<font></font>
  fragColor = vec4(diffuseColor, <span class="hljs-number">1</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ジオメトリマテリアルの拡散色をフレームバッファテクスチャにレンダリングする小さなフラグメントシェーダです。</font><font style="vertical-align: inherit;">フレームバッファーからのこの拡散カラーテクスチャは、パスシェーダーの入力テクスチャになります。</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/abd/05c/f0babd05caf7104156c15929995c9279.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Blenderで設定した色を表示する、フレームバッファーからのマテリアルの拡散色のテクスチャです。</font><font style="vertical-align: inherit;">コンターシェーダーは、シーンのエッジを認識して色を付けます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーンの特定の部分に独自のマテリアルの拡散色がない場合、マテリアルの拡散色は機能しないことに注意してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エッジの作成</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/a0d/57a/33aa0d57aeba90366ddd95865ea0d6c6.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エッジの作成は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GIMPでの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エッジ認識フィルターの使用に似てい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシェーディング手法のすべての計算は、フラグメントシェーダーで実行されます。</font><font style="vertical-align: inherit;">頂点シェーダーのコンターを作成するには、長方形メッシュの4つの頂点を画面に合わせて出力に渡すだけで十分です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ...</span><font></font>
<font></font>
uniform sampler2D materialDiffuseTexture;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  vec2 texSize  = textureSize(materialDiffuseTexture, <span class="hljs-number">0</span>).xy;<font></font>
  vec2 texCoord = gl_FragCoord.xy;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エッジの認識を開始する前に、処理するテクスチャを準備する必要があります。</font><font style="vertical-align: inherit;">テクスチャには画面サイズがあるので、フラグメントの座標と入ってくるテクスチャのサイズを知って、UV座標を計算できます。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">int</span> separation = <span class="hljs-number">1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータ</font></font><code>separation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は好みに合わせてカスタマイズできます。</font><font style="vertical-align: inherit;">分離が大きいほど、エッジまたはラインは太くなります。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> threshold = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  vec4 mx = vec4(<span class="hljs-number">0</span>);<font></font>
  vec4 mn = vec4(<span class="hljs-number">1</span>);<font></font>
<font></font>
  <span class="hljs-keyword">int</span> x = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> y = <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i) {<font></font>
    vec4 color =<font></font>
      texture<font></font>
        ( materialDiffuseTexture<font></font>
        , (texCoord + (vec2(x, y) * separation)) / texSize<font></font>
        );<font></font>
    mx = max(color, mx);<font></font>
    mn = min(color, mn);<font></font>
    x += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">2</span>) {<font></font>
      x  = <span class="hljs-number">-1</span>;<font></font>
      y +=  <span class="hljs-number">1</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">float</span> alpha = ((mx.r + mx.g + mx.b) / <span class="hljs-number">3</span>) - ((mn.r + mn.g + mn.b) / <span class="hljs-number">3</span>);
  <span class="hljs-keyword">if</span> (alpha &gt; threshold) { alpha = <span class="hljs-number">1</span>; }<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/d24/e56/42fd24e5682700e1e7cd5186bebc33af.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エッジ認識技術は、入ってくるテクスチャの色の変化を見つけます。</font><font style="vertical-align: inherit;">現在のフラグメントに注目し、3x3フラグメントウィンドウを使用して、9つのサンプルの最も明るい色と最も暗い色を見つけます。</font><font style="vertical-align: inherit;">次に、1つの色の明るさから別の色の明るさを差し引いて、それらの違いを取得します。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  vec3 lineRgb    = vec3(<span class="hljs-number">0.012</span>, <span class="hljs-number">0.014</span>, <span class="hljs-number">0.022</span>);<font></font>
<font></font>
  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  vec4 lineColor = vec4(lineRgb, alpha);<font></font>
<font></font>
      <span class="hljs-comment">// ...</span><font></font>
<font></font>
      fragColor = lineColor;<font></font>
<font></font>
      <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この違いは、出力カラーのアルファチャネルで使用されます。</font><font style="vertical-align: inherit;">違いがない場合、エッジまたは線は描画されません。</font><font style="vertical-align: inherit;">違いがある場合は、エッジが描画されます。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> threshold = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span> (alpha &gt; threshold) { alpha = <span class="hljs-number">1</span>; }<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しきい値を試してみてください。</font><font style="vertical-align: inherit;">今はゼロです。</font><font style="vertical-align: inherit;">ゼロ以外の値はエッジになり、このしきい値は変更できます。</font><font style="vertical-align: inherit;">これは、小さな違いのあるノイズの多い入ってくるテクスチャに特に役立ちます。</font><font style="vertical-align: inherit;">ノイズの多い入ってくるテクスチャの場合、通常は大きな違いの場合にのみアウトラインを作成する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">material-diffuse.frag</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outline.frag</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">霧</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/02c/e52/5af02ce52f813b27461f79e5dca5fe20.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
霧（またはBlenderで呼ばれる霧）は、シーンに大気のもやを追加し、不思議な柔らかく突き出た部分を作成します。</font><font style="vertical-align: inherit;">一部のジオメトリが突然カメラの視界のピラミッドに入ると、突出した部分が表示されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ...</span><font></font>
<font></font>
uniform <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">p3d_FogParameters</span>
  {</span> vec4 color<font></font>
  ; <span class="hljs-keyword">float</span> start<font></font>
  ; <span class="hljs-keyword">float</span> end<font></font>
  ;<font></font>
  } p3d_Fog;<font></font>
<font></font>
<span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Panda3Dには、すべてのフォグパラメーターを含む便利なデータ構造がありますが、手動でシェーダーに転送できます。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    <span class="hljs-keyword">float</span> fogIntensity =<font></font>
      clamp<font></font>
        (   ( p3d_Fog.end - vertexPosition.y)<font></font>
          / ( p3d_Fog.end - p3d_Fog.start)<font></font>
        , <span class="hljs-number">0</span>
        , <span class="hljs-number">1</span><font></font>
        );<font></font>
    fogIntensity = <span class="hljs-number">1</span> - fogIntensity;<font></font>
<font></font>
<font></font>
    <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード例では、線形モデルを使用して、カメラから離れるときの霧の明るさを計算しています。</font><font style="vertical-align: inherit;">代わりに、指数モデルを使用できます。</font><font style="vertical-align: inherit;">霧の明るさは、霧の前または最初はゼロです。</font><font style="vertical-align: inherit;">頂点の位置が霧の終わりに</font></font><code>fogIntensity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">近づくと</font><font style="vertical-align: inherit;">、1に</font><font style="vertical-align: inherit;">近づきます。</font><font style="vertical-align: inherit;">フォグ終了後のすべての頂点では</font></font><code>fogIntensity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、上から1に制限されます。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    fragColor =<font></font>
      mix<font></font>
        ( outputColor<font></font>
        , p3d_Fog.color<font></font>
        , fogIntensity<font></font>
        );<font></font>
<font></font>
    <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォグの明るさに基づいて、フォグのカラーと出力カラーを混合します。</font></font><code>fogIntensity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統一に</font><font style="vertical-align: inherit;">近づくにつれて</font></font><code>outputColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、霧の色</font><font style="vertical-align: inherit;">が少なく</font><font style="vertical-align: inherit;">なります。</font></font><code>fogIntensity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統一</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">達すると、霧の色だけが残ります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">輪郭の霧</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/ee8/d49/e1fee8d490abe10ecb798df618f183f7.gif"></div><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ...</span><font></font>
<font></font>
uniform sampler2D positionTexture;<font></font>
<font></font>
      <span class="hljs-comment">// ...</span><font></font>
<font></font>
      vec4 position = texture(positionTexture, texCoord / texSize);<font></font>
<font></font>
      <span class="hljs-keyword">float</span> fogIntensity =<font></font>
        clamp<font></font>
          (   ( p3d_Fog.end - position.y)<font></font>
            / ( p3d_Fog.end - p3d_Fog.start)<font></font>
          , <span class="hljs-number">0</span>
          , <span class="hljs-number">1</span><font></font>
          );<font></font>
      fogIntensity = <span class="hljs-number">1</span> - fogIntensity;<font></font>
<font></font>
      vec4 lineWithFogColor =<font></font>
        mix<font></font>
          ( lineColor<font></font>
          , p3d_Fog.color<font></font>
          , fogIntensity<font></font>
          );<font></font>
<font></font>
      fragColor = vec4(lineWithFogColor.rgb, alpha);<font></font>
<font></font>
      <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パスシェーダーは、エッジの色にフォグを適用して、より全体的な画像にします。</font><font style="vertical-align: inherit;">彼がこれを行わなかった場合、輪郭のジオメトリが霧によって不明瞭になり、奇妙に見えます。</font><font style="vertical-align: inherit;">ただし、エッジは頂点の位置がないジオメトリの境界を超えているため、ミルを使用してステージのジオメトリの最も外側のエッジに輪郭を作成します。</font></font><br>
<br>
<code>positionTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは、表示スペースの頂点の位置を含むフレームバッファーのテクスチャです。</font><font style="vertical-align: inherit;">これについては、SSAOシェーダーを実装するときに学習します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outline.frag</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">咲く</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/744/f35/31d744f35168ac87f609474998802b12.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーンにブルームを追加すると、ライティングモデルの説得力のある錯覚を作成できます。</font><font style="vertical-align: inherit;">発光オブジェクトはより説得力があり、光の反射は追加の量の輝きを受け取ります。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">//...</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> separation = <span class="hljs-number">3</span>;
  <span class="hljs-keyword">int</span>   samples    = <span class="hljs-number">15</span>;
  <span class="hljs-keyword">float</span> threshold  = <span class="hljs-number">0.5</span>;
  <span class="hljs-keyword">float</span> amount     = <span class="hljs-number">1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの設定は好みに応じてカスタマイズできます。</font><font style="vertical-align: inherit;">分離すると、ぼかしのサイズが大きくなります。</font><font style="vertical-align: inherit;">サンプルは、ぼかしの強さを決定します。</font><font style="vertical-align: inherit;">しきい値は、この効果の影響を受けるものと影響されないものを決定します。</font><font style="vertical-align: inherit;">量は、ブルームの出力量を制御します。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">int</span> size  = samples;
  <span class="hljs-keyword">int</span> size2 = size * size;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> value = <span class="hljs-number">0</span>;<font></font>
<font></font>
  vec4 result = vec4(<span class="hljs-number">0</span>);<font></font>
  vec4 color = vec4(<span class="hljs-number">0</span>);<font></font>
<font></font>
  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size2; ++i) {
    <span class="hljs-comment">// ...</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
窓を通過させることによって、この技術が開始さ寸法</font></font><code>samples</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font><code>samples</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、現行断片を中心。</font><font style="vertical-align: inherit;">パスの作成に使用されるウィンドウのように見えます。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    color =<font></font>
      texture<font></font>
        ( bloomTexture<font></font>
        ,   ( gl_FragCoord.xy<font></font>
            + vec2(x * separation, y * separation)<font></font>
            )<font></font>
          / texSize<font></font>
        );<font></font>
<font></font>
    value = ((<span class="hljs-number">0.3</span> * color.r) + (<span class="hljs-number">0.59</span> * color.g) + (<span class="hljs-number">0.11</span> * color.b));
    <span class="hljs-keyword">if</span> (value &lt; threshold) { color = vec4(<span class="hljs-number">0</span>); }<font></font>
<font></font>
    result += color;<font></font>
<font></font>
    <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは、着信テクスチャから色を取得し、赤、緑、青の値をグレースケールの値に変換します。</font><font style="vertical-align: inherit;">グレースケールの値がしきい値よりも小さい場合、この色は破棄され、黒になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィンドウ内のすべてのサンプルを通過すると、すべてのサンプルの値が累積され</font></font><code>result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  result = result / size2;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプルの収集が完了すると、カラーサンプルの合計を、取得したサンプルの数で割ります。</font><font style="vertical-align: inherit;">結果は、フラグメント自体とその近傍の中間色です。</font><font style="vertical-align: inherit;">フラグメントごとにそうすることにより、ぼやけた画像が得られます。</font><font style="vertical-align: inherit;">この種類のぼかしはボックスぼかしと呼ばれます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/16f/ea4/f9016fea492bc7b136ef6437a683c937.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、ブルームアルゴリズムの実行プロセスを確認できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloom.frag</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面スペースアンビエントオクルージョン（SSAO）</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/5ab/5bf/f935ab5bf4794caae3be90b611ad771c.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SSAOはあなたが知らないこれらの効果の1つですが、あなたがそれを理解しているとすぐに、それなしでは生きられなくなります。</font><font style="vertical-align: inherit;">彼は平凡なシーンを素晴らしいものに変えることができます！</font><font style="vertical-align: inherit;">静的なシーンでは、アンビエントオクルージョンをテクスチャにベイクできますが、より動的なシーンでは、シェーダーが必要です。</font><font style="vertical-align: inherit;">SSAOは、より洗練されたシェーディングテクニックの1つですが、それを理解すると、マスターシェーダーになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての計算が画面スペースで実行されるわけではないため、タイトルの「画面スペース」という用語は完全に正しくないことに注意してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着信データ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SSAOシェーダーには次の入力が必要です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示スペース内の頂点位置のベクトル。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示スペースの頂点に対する法線ベクトル。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接線空間のサンプルベクトル。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接線空間のノイズベクトル。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カメラレンズの投影行列。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポジション</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/f36/d42/2d2f36d425c2596288d8982158687354.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フレームバッファーテクスチャに頂点の位置を保存する必要はありません。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カメラ深度バッファ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からそれらを再作成でき</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">私は初心者向けのガイドを書いているので、この最適化は使用せず、すぐに業務に取りかかります。</font><font style="vertical-align: inherit;">実装では、深度バッファーを簡単に使用できます。</font></font><br>
<br>
<pre><code class="cpp hljs">PT(Texture) depthTexture = <span class="hljs-keyword">new</span> Texture(<span class="hljs-string">"depthTexture"</span>);<font></font>
depthTexture-&gt;set_format(Texture::Format::F_depth_component32);<font></font>
<font></font>
PT(GraphicsOutput) depthBuffer = graphicsOutput-&gt;make_texture_buffer(<span class="hljs-string">"depthBuffer"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, depthTexture);<font></font>
depthBuffer-&gt;set_clear_color(LVecBase4f(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<font></font>
<font></font>
NodePath depthCameraNP = window-&gt;make_camera();<font></font>
DCAST(Camera, depthCameraNP.node())-&gt;set_lens(window-&gt;get_camera(<span class="hljs-number">0</span>)-&gt;get_lens());<font></font>
PT(DisplayRegion) depthBufferRegion = depthBuffer-&gt;make_display_region(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<font></font>
depthBufferRegion-&gt;set_camera(depthCameraNP);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
深度バッファーを使用する場合は、Panda3Dで構成する方法を次に示します。</font></font><br>
<br>
<pre><code class="cpp hljs">in vec4 vertexPosition;<font></font>
<font></font>
out vec4 fragColor;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<font></font>
  fragColor = vertexPosition;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、表示スペースの頂点位置をフレームバッファーテクスチャにレンダリングするための単純なシェーダーです。</font><font style="vertical-align: inherit;">より困難なタスクは、フレームバッファーのテクスチャを調整して、フレームバッファーによって取得されるフラグメントベクトルのコンポーネントが間隔によって制限されない</font></font><code>[0, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ようにし、すべての人が十分に高い精度（十分に大きなビット数）を持つようにすることです。</font><font style="vertical-align: inherit;">たとえば、いくつかの補間された頂点の位置が等しい場合</font></font><code>&lt;-139.444444566, 0.00000034343, 2.5&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それをとしてテクスチャに保存することはできません</font></font><code>&lt;0.0, 0.0, 1.0&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  FrameBufferProperties fbp = FrameBufferProperties::get_default();<font></font>
<font></font>
  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  fbp.set_rgba_bits(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>);<font></font>
  fbp.set_rgb_color(<span class="hljs-literal">true</span>);<font></font>
  fbp.set_float_color(<span class="hljs-literal">true</span>);<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頂点の位置を保存するためにフレームバッファーテクスチャを準備するサンプルコードを次に示します。</font><font style="vertical-align: inherit;">赤、緑、青、アルファには32ビットが必要なので、間隔値の制限をオフにします</font></font><code>[0, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">呼び出し</font></font><code>set_rgba_bits(32, 32, 32, 32)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はビットボリュームを設定し、制限を無効にします。</font></font><br>
<br>
<pre><code class="cpp hljs">  glTexImage2D<font></font>
    ( GL_TEXTURE_2D<font></font>
    , <span class="hljs-number">0</span><font></font>
    , GL_RGB32F<font></font>
    , <span class="hljs-number">1200</span>
    , <span class="hljs-number">900</span>
    , <span class="hljs-number">0</span><font></font>
    , GL_RGB<font></font>
    , GL_FLOAT<font></font>
    , <span class="hljs-literal">nullptr</span>
    );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenGLに対する同様の呼び出しを次に示します。</font></font><code>GL_RGB32F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビットを設定し、制限を無効にします。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カラーバッファーに固定のコンマがある場合、ミキシング方程式を計算する前の初期値と最終値のコンポーネント、およびミキシングインデックスは、符号なし正規化カラーバッファーと符号付き正規化カラーバッファーのそれぞれ[0、1]または[-1、1]に制限されます。</font><font style="vertical-align: inherit;">カラーバッファーに浮動小数点がある場合、制限は満たされません。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース</font></font></a></blockquote><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17b/2d0/2ad/17b2d02ad53c411dc251d90fdc16fdf3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、頂点の位置を確認できます。</font><font style="vertical-align: inherit;">y軸は上です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Panda3Dはz軸を上向きのベクトルとして定義しているのに対し、OpenGLではy軸が上を向いていることに注意してください。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータは</font><font style="vertical-align: inherit;">Panda3D </font><font style="vertical-align: inherit;">で構成さ</font><font style="vertical-align: inherit;">れているため、位置シェーダーは上向きのzで頂点の位置を表示します</font></font><code>gl-coordinate-system default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正常</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c4/064/9c5/0c40649c525edd7bcf3c829d6e948789.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SSAOシェーダーで取得されたサンプルの正しい向きを得るには、頂点の法線が必要です。</font><font style="vertical-align: inherit;">サンプルコードは、半球に分散されたいくつかのサンプリングベクトルを生成しますが、球を使用して、法線の必要性の問題を完全に解決できます。</font></font><br>
<br>
<pre><code class="cpp hljs">in vec3 vertexNormal;<font></font>
<font></font>
out vec4 fragColor;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<font></font>
  vec3 normal = normalize(vertexNormal);<font></font>
<font></font>
  fragColor = vec4(normal, <span class="hljs-number">1</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
位置シェーダーと同様に、通常のシェーダーは非常にシンプルです。</font><font style="vertical-align: inherit;">法線を頂点に正規化し、それらが表示スペース内にあることを忘れないでください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/a82/f00/57ba82f003b0ab9c2aafa7c9affa28bb.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頂点の法線は次のとおりです。</font><font style="vertical-align: inherit;">y軸は上です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Panda3Dはz軸を上向きのベクトル、OpenGLをy軸と見なしていることを思い出してください。</font><font style="vertical-align: inherit;">パラメータはPanda3Dで構成されているため、通常のシェーダーはz軸が上を向いた状態で頂点の位置を表示します</font></font><code>gl-coordinate-system default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単一のフラグメントのアンビエントオクルージョン値を決定するには、周囲の領域をサンプリングする必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numberOfSamples; ++i) {<font></font>
    LVecBase3f sample =<font></font>
      LVecBase3f<font></font>
        ( randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>
        , randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span><font></font>
        , randomFloats(generator)<font></font>
        ).normalized();<font></font>
<font></font>
    <span class="hljs-keyword">float</span> rand = randomFloats(generator);<font></font>
    sample[<span class="hljs-number">0</span>] *= rand;<font></font>
    sample[<span class="hljs-number">1</span>] *= rand;<font></font>
    sample[<span class="hljs-number">2</span>] *= rand;<font></font>
<font></font>
    <span class="hljs-keyword">float</span> scale = (<span class="hljs-keyword">float</span>) i / (<span class="hljs-keyword">float</span>) numberOfSamples;<font></font>
    scale = lerp(<span class="hljs-number">0.1</span>, <span class="hljs-number">1.0</span>, scale * scale);<font></font>
    sample[<span class="hljs-number">0</span>] *= scale;<font></font>
    sample[<span class="hljs-number">1</span>] *= scale;<font></font>
    sample[<span class="hljs-number">2</span>] *= scale;<font></font>
<font></font>
    ssaoSamples.push_back(sample);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプルコードは、半球全体に分散された64個のランダムサンプルを生成します。</font><font style="vertical-align: inherit;">これら</font></font><code>ssaoSamples</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はSSAOシェーダーに渡されます。</font></font><br>
<br>
<pre><code class="cpp hljs">    LVecBase3f sample =<font></font>
      LVecBase3f<font></font>
        ( randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>
        , randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>
        , randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>
        ).normalized();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプルを球全体に分布させる場合は、ランダム成分zの間隔を変更して、マイナス1から1に変更します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノイズ</font></font></h3><br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; ++i) {<font></font>
    LVecBase3f noise =<font></font>
      LVecBase3f<font></font>
        ( randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>
        , randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>
        , <span class="hljs-number">0.0</span><font></font>
        );<font></font>
<font></font>
    ssaoNoise.push_back(noise);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプリングされた領域をうまくカバーするには、ノイズベクトルを生成する必要があります。</font><font style="vertical-align: inherit;">これらのノイズベクトルは、表面の上部を中心にサンプルを回転させることができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アンビエントオクルージョン</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c1d/bb4/d35c1dbb4e0e9dfeedc3bd4285f26004.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SSAOは、フラグメントの周りの表示スペースをサンプリングすることによって、そのタスクを実行します。</font><font style="vertical-align: inherit;">表面の下のサンプルが多いほど、フラグメントの色は暗くなります。</font><font style="vertical-align: inherit;">これらのサンプルはフラグメントにあり、頂点の法線の一般的な方向を示します。</font><font style="vertical-align: inherit;">各サンプルは、フレームバッファー位置のテクスチャ内の位置を検索するために使用されます。</font><font style="vertical-align: inherit;">返された位置がサンプルと比較されます。</font><font style="vertical-align: inherit;">サンプルが位置からカメラから遠い場合、フラグメントに向かうサンプルは閉塞されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/b9a/f1d/cb7b9af1d4dc613f337da5a253ef5a8c.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、オクルージョン用にサンプリングされたサーフェスの上のスペースを確認できます。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> radius     = <span class="hljs-number">1.1</span>;
  <span class="hljs-keyword">float</span> bias       = <span class="hljs-number">0.026</span>;
  <span class="hljs-keyword">float</span> lowerRange = <span class="hljs-number">-2</span>;
  <span class="hljs-keyword">float</span> upperRange =  <span class="hljs-number">2</span>;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のいくつかの手法と同様に、SSAOシェーダーには、目的の外観を取得するために変更できるいくつかの制御パラメーターがあります。</font><font style="vertical-align: inherit;">バイアスは、サンプルからカメラまでの距離に追加されます。</font><font style="vertical-align: inherit;">このパラメータは、汚れと戦うために使用できます。</font><font style="vertical-align: inherit;">radiusは、サンプルスペースのカバレッジエリアを増減します。</font><font style="vertical-align: inherit;">lowerRangeおよびupperRangeは、選択した</font></font><code>[0, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意の値</font><font style="vertical-align: inherit;">から因子メトリックの標準範囲を変更します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">範囲を広げることで、コントラストを上げることができます。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  vec4 position = texture(positionTexture, texCoord);<font></font>
  vec3 normal   = texture(normalTexture, texCoord).xyz;<font></font>
<font></font>
  <span class="hljs-keyword">int</span>  noiseX = <span class="hljs-keyword">int</span>(gl_FragCoord.x - <span class="hljs-number">0.5</span>) % <span class="hljs-number">4</span>;
  <span class="hljs-keyword">int</span>  noiseY = <span class="hljs-keyword">int</span>(gl_FragCoord.y - <span class="hljs-number">0.5</span>) % <span class="hljs-number">4</span>;<font></font>
  vec3 random = noise[noiseX + (noiseY * <span class="hljs-number">4</span>)];<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに使用するために、位置、法線、ランダムベクトルを取得します。</font><font style="vertical-align: inherit;">コード例では、16個のランダムベクトルが作成されたことを思い出してください。</font><font style="vertical-align: inherit;">現在のフラグメントの画面位置に基づいてランダムなベクトルが選択されます。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  vec3 tangent  = normalize(random - normal * dot(random, normal));<font></font>
  vec3 binormal = cross(normal, tangent);<font></font>
  mat3 tbn      = mat3(tangent, binormal, normal);<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランダムベクトルと法線ベクトルを使用して、接線、従法線、および法線の行列を収集します。</font><font style="vertical-align: inherit;">接線空間から測量空間にサンプルベクトルを変換するには、この行列が必要です。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> occlusion = NUM_SAMPLES;<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_SAMPLES; ++i) {
    <span class="hljs-comment">// ...</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マトリックスがあるシェーダーは、ループ内のすべてのサンプルをループして、開いていないサンプルの数を差し引くことができます。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    vec3 sample = tbn * samples[i];<font></font>
         sample = position.xyz + sample * radius;<font></font>
<font></font>
    <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マトリックスを使用して、サンプルを頂点/フラグメントの位置の隣に配置し、半径でスケーリングします。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    vec4 offset      = vec4(sample, <span class="hljs-number">1.0</span>);<font></font>
         offset      = lensProjection * offset;<font></font>
         offset.xyz /= offset.w;<font></font>
         offset.xyz  = offset.xyz * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>;<font></font>
<font></font>
    <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表示スペースでのサンプルの位置を使用して、サンプルを表示スペースからクリッピングスペースに変換し、次にUVスペースに変換します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">-1</span> * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span> = <span class="hljs-number">0</span>
 <span class="hljs-number">1</span> * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span> = <span class="hljs-number">1</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クリッピングスペースのコンポーネントはマイナス1から1の範囲であり、UV座標は0から1の範囲であることを忘れないでください。</font><font style="vertical-align: inherit;">クリッピングスペースの座標をUV座標に変換するには、それらに1秒を掛けて1秒加算します。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    vec4 offsetPosition = texture(positionTexture, offset.xy);<font></font>
<font></font>
    <span class="hljs-keyword">float</span> occluded = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (sample.y + bias &lt;= offsetPosition.y) { occluded = <span class="hljs-number">0</span>; } <span class="hljs-keyword">else</span> { occluded = <span class="hljs-number">1</span>; }<font></font>
<font></font>
    <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dサンプルを2D位置テクスチャに投影して得られたUVオフセット座標を使用して、対応する位置ベクトルを見つけます。</font><font style="vertical-align: inherit;">これにより、表示スペースからクリッピングスペース、UVスペース、そして表示スペースに戻ります。</font><font style="vertical-align: inherit;">シェーダーはこのループを実行して、サンプルの後ろ、サンプルの場所、またはサンプルの前にジオメトリがあるかどうかを判断します。</font><font style="vertical-align: inherit;">サンプルがジオメトリの前または一部に配置されている場合、このサンプルは、重複しているフラグメントに対して考慮されません。</font><font style="vertical-align: inherit;">サンプルが一部のジオメトリの背後にある場合、このサンプルは、重複するフラグメントと比較して考慮されます。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    <span class="hljs-keyword">float</span> intensity =<font></font>
      smoothstep<font></font>
        ( <span class="hljs-number">0.0</span>
        , <span class="hljs-number">1.0</span><font></font>
        ,   radius<font></font>
          / <span class="hljs-built_in">abs</span>(position.y - offsetPosition.y)<font></font>
        );<font></font>
    occluded *= intensity;<font></font>
<font></font>
    occlusion -= occluded;<font></font>
<font></font>
    <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、半径の内側または外側の距離に基づいて、このサンプリングされた位置に重みを追加します。</font><font style="vertical-align: inherit;">次に、このサンプルをオクルージョンメトリックから差し引きます。これは、ループの前にすべてのサンプルが重複していると想定しているためです。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    occlusion /= NUM_SAMPLES;<font></font>
<font></font>
    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    fragColor = vec4(vec3(occlusion), position.a);<font></font>
<font></font>
    <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーバーラップの数をサンプルの数で除算して、オクルージョンをintervalからinterval </font></font><code>[0, NUM_SAMPLES]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">変換</font><font style="vertical-align: inherit;">します</font></font><code>[0, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ゼロは完全な閉塞を意味し、単位は閉塞がないことを意味します。</font><font style="vertical-align: inherit;">次に、オクルージョンメトリックをフラグメントの色に割り当てます。これで完了です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプルコードでは、背景の重複を避けるために、アルファチャネルにフレームバッファーからの位置テクスチャのアルファ値が割り当てられていることに注意してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ぼかし</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/566/2a7/5b15662a7c46db6b8102fe9eabae17c9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SSAOフレームバッファーのテクスチャは少しうるさいので、滑らかにするためにぼかす必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size2; ++i) {<font></font>
    x = size - xCount;<font></font>
    y = yCount - size;<font></font>
<font></font>
    result +=<font></font>
      texture<font></font>
        ( ssaoTexture<font></font>
        ,   texCoord<font></font>
          + vec2(x * parameters.x, y * parameters.x)<font></font>
        ).rgb;<font></font>
<font></font>
    xCount -= <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (xCount &lt; countMin) { xCount = countMax; yCount -= <span class="hljs-number">1</span>; }<font></font>
  }<font></font>
<font></font>
  result = result / size2;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SSAOブラーシェーダーは、通常のボックスブラーです。</font><font style="vertical-align: inherit;">ブルームシェーダーのように、入力テクスチャの上にウィンドウを描画し、各フラグメントをその近傍の値で平均化します。</font><font style="vertical-align: inherit;">これは分離パラメーターであることに</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意して</font></font><code>parameters.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アンビエントカラー</font></font></h3><br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  vec2 ssaoBlurTexSize  = textureSize(ssaoBlurTexture, <span class="hljs-number">0</span>).xy;<font></font>
  vec2 ssaoBlurTexCoord = gl_FragCoord.xy / ssaoBlurTexSize;<font></font>
  <span class="hljs-keyword">float</span> ssao            = texture(ssaoBlurTexture, ssaoBlurTexCoord).r;<font></font>
<font></font>
  vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex * ssao;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SSAOの最後の課題は、やはり照明の計算です。</font><font style="vertical-align: inherit;">ここでは、オクルージョンがテクスチャSSAOテクスチャバッファーにあり、アンビエントライトの計算にどのように含まれているかを確認します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">position.frag</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normal.frag</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ssao.frag</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blur.frag</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被写界深度</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/eb0/10f/6efeb010f4623ff49b928d72550f7985.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
被写界深度もそのような効果であり、それについて学んだら、それなしでは生きられない。</font><font style="vertical-align: inherit;">芸術的な観点から、それを使用して、特定のオブジェクトに視聴者の注意を引くことができます。</font><font style="vertical-align: inherit;">しかし、一般的なケースでは、少しの努力を犠牲にして被写界深度を深めることで、リアリズムの大部分が追加されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">焦点があっている</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のステップは、完全に焦点の合ったシーンをレンダリングすることです。</font><font style="vertical-align: inherit;">フレームバッファーテクスチャにレンダリングします。</font><font style="vertical-align: inherit;">被写界深度バッファーの入力値の1つになります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">焦点が合っていない</font></font></h3><br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  vec4 result = vec4(<span class="hljs-number">0</span>);<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size2; ++i) {<font></font>
    x = size - xCount;<font></font>
    y = yCount - size;<font></font>
<font></font>
    result +=<font></font>
      texture<font></font>
        ( blurTexture<font></font>
        ,   texCoord<font></font>
          + vec2(x * parameters.x, y * parameters.x)<font></font>
        );<font></font>
<font></font>
    xCount -= <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (xCount &lt; countMin) { xCount = countMax; yCount -= <span class="hljs-number">1</span>; }<font></font>
  }<font></font>
<font></font>
  result = result / size2;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の手順は、完全に焦点が合っていないかのようにシーンをぼかすことです。</font><font style="vertical-align: inherit;">ブルームやSSAOと同様に、ボックスブラーを使用できます。</font><font style="vertical-align: inherit;">このデフォーカスシーンをフレームバッファーテクスチャにレンダリングします。</font><font style="vertical-align: inherit;">被写界深度シェーダーの別の入力値になります。</font><font style="vertical-align: inherit;">これは分離パラメーターであることに</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意して</font></font><code>parameters.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">混合</font></font></h3><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d68/067/83a/d6806783a567c4708d8f13dcb0763f7c.gif"></div><br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> focalLengthSharpness = <span class="hljs-number">100</span>;
  <span class="hljs-keyword">float</span> blurRate             = <span class="hljs-number">6</span>;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの設定は好みに合わせてカスタマイズできます。</font></font><code>focalLengthSharpness</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">焦点距離でのシーンの焦点ぼけに影響します。</font><font style="vertical-align: inherit;">小さいほど</font></font><code>focalLengthSharpness</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、焦点距離での焦点がぼやけたシーンになります。</font></font><code>blurRate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">焦点距離から離れるときにシーンをぼかす速度に影響します。</font><font style="vertical-align: inherit;">が小さいほど</font></font><code>blurRate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、フォーカスポイントから離れるときのシーンのぼやけが少なくなります。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  vec4 focusColor      = texture(focusTexture, texCoord);<font></font>
  vec4 outOfFocusColor = texture(outOfFocusTexture, texCoord);<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
焦点の合った画像とぼかした画像の色が必要です。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  vec4 position = texture(positionTexture, texCoord);<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表示スペース内の頂点の位置も必要になる場合があります。</font><font style="vertical-align: inherit;">SSAOに使用されたフレームバッファーの位置のテクスチャを再適用できます。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> blur =<font></font>
    clamp<font></font>
      (   <span class="hljs-built_in">pow</span><font></font>
            ( blurRate<font></font>
            , <span class="hljs-built_in">abs</span>(position.y - focalLength.x)<font></font>
            )<font></font>
        / focalLengthSharpness<font></font>
      , <span class="hljs-number">0</span>
      , <span class="hljs-number">1</span><font></font>
      );<font></font>
<font></font>
  <span class="hljs-comment">// ...</span><font></font>
<font></font>
    fragColor = mix(focusColor, outOfFocusColor, blur);<font></font>
<font></font>
    <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ここで混乱が起こります。</font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つに</font><font style="vertical-align: inherit;">近いほど</font><font style="vertical-align: inherit;">、より多く使用されます</font></font><code>outOfFocusColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ゼロの値</font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、このフラグメントが完全にフォーカスされていることを意味します。</font></font><code>blur &gt;= 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このフラグメント</font><font style="vertical-align: inherit;">により</font><font style="vertical-align: inherit;">、完全にデフォーカスされます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blur.frag</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depth-of-field.frag</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポスタリゼーション</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/078/84d/f1807884d79c5c73915ce9adf6ead5cb.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポスタリゼーションまたはカラーサンプリングは、画像内の固有の色の数を減らすプロセスです。</font><font style="vertical-align: inherit;">このシェーダーを使用して、ゲームにコミックまたはレトロな外観を与えることができます。</font><font style="vertical-align: inherit;">アウトラインと組み合わせると、本当の漫画風のスタイルになります。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> levels = <span class="hljs-number">8</span>;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパラメータを試すことができます。</font><font style="vertical-align: inherit;">それが大きいほど、結果としてより多くの花が残ります。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  vec4 texColor = texture(posterizeTexture, texCoord);<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入ってくる色が必要になります。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    vec3 grey  = vec3((texColor.r + texColor.g + texColor.b) / <span class="hljs-number">3.0</span>);<font></font>
    vec3 grey1 = grey;<font></font>
<font></font>
    grey = <span class="hljs-built_in">floor</span>(grey * levels) / levels;<font></font>
<font></font>
    texColor.rgb += (grey - grey1);<font></font>
<font></font>
    <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はそのようなポスタリゼーションの方法を見たことがありません。</font><font style="vertical-align: inherit;">調べてみると、従来の方法よりも綺麗な結果になることがわかりました。</font><font style="vertical-align: inherit;">カラーパレットを減らすには、まずカラーをグレースケールの値に変換します。</font><font style="vertical-align: inherit;">レベルの1つに関連付けることで、色を離散化します。</font><font style="vertical-align: inherit;">グレースケールのサンプル値とグレースケールの非サンプル値の差を計算します。</font><font style="vertical-align: inherit;">この違いを入力色に追加します。</font><font style="vertical-align: inherit;">この違いは、グレースケールで離散化された値を達成するために色を増減する必要がある量です。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  fragColor = texColor;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力カラーの値をフラグメントのカラーに割り当てることを忘れないでください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルシェーディング</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d1/f9c/133/2d1f9c1333960c0299388fc51323a8b3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セルシェーディングは、ディフューズカラーとディフューズカラーを離散的なシェードに離散化するプロセスであるため、ポスタリゼーションによってセルのシェーディングのような画像にすることができます。</font><font style="vertical-align: inherit;">法線マップの細部と小さな値なしで、無地の拡散色のみを使用したいとします</font></font><code>levels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posterize.frag</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピクセル化</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/0b9/9bc/3960b99bc2f1fa900c40a1c9f32169bc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dゲームのピクセル化は、面白い外観を与えたり、すべてのピクセルアートを手動で作成するのに費やす時間を節約したりできます。</font><font style="vertical-align: inherit;">それをポスタリゼーションと組み合わせて、真のレトロな外観を作成します。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">int</span> pixelSize = <span class="hljs-number">5</span>;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピクセルサイズは自分で調整できます。</font><font style="vertical-align: inherit;">大きいほど、画像は粗くなります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/818/aee/413818aee5509763cc383f800b837cfb.gif"></div><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> x = <span class="hljs-keyword">int</span>(gl_FragCoord.x) % pixelSize;
  <span class="hljs-keyword">float</span> y = <span class="hljs-keyword">int</span>(gl_FragCoord.y) % pixelSize;<font></font>
<font></font>
  x = <span class="hljs-built_in">floor</span>(pixelSize / <span class="hljs-number">2.0</span>) - x;<font></font>
  y = <span class="hljs-built_in">floor</span>(pixelSize / <span class="hljs-number">2.0</span>) - y;<font></font>
<font></font>
  x = gl_FragCoord.x + x;<font></font>
  y = gl_FragCoord.y + y;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この手法は、各フラグメントを、最も近い重複しないピクセルサイズのウィンドウの中心にアタッチします。</font><font style="vertical-align: inherit;">これらのウィンドウは、入ってくるテクスチャの上に並んでいます。</font><font style="vertical-align: inherit;">ウィンドウの中央にあるフラグメントは、ウィンドウ内の他のフラグメントの色を決定します。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    fragColor = texture(pixelizeTexture, vec2(x, y) / texSize);<font></font>
<font></font>
    <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用する目的のフラグメントの座標を決定したら、入力テクスチャからその色を取り、それをフラグメントの色に割り当てます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixelize.frag</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">研ぐ</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/674/617/b52674617a0733ee1fe0d525b0053750.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シャープ効果（シャープ）は、画像のエッジのコントラストを上げます。</font><font style="vertical-align: inherit;">グラフィックが柔らかすぎる場合に便利です。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> amount = <span class="hljs-number">0.8</span>;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値を変更することで、結果のシャープネスの大きさを制御できます。</font><font style="vertical-align: inherit;">値がゼロの場合、画像は変化しません。</font><font style="vertical-align: inherit;">負の値では、画像が奇妙に見え始めます。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> neighbor = amount * <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">float</span> center   = amount * <span class="hljs-number">4</span> + <span class="hljs-number">1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
隣接するフラグメントにはが掛けられ</font></font><code>amount * -1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">現在のフラグメントにが掛けられ</font></font><code>amount * 4 + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  vec3 color =<font></font>
        texture(sharpenTexture, vec2(gl_FragCoord.x + <span class="hljs-number">0</span>, gl_FragCoord.y + <span class="hljs-number">1</span>) / texSize).rgb<font></font>
      * neighbor<font></font>
<font></font>
      + texture(sharpenTexture, vec2(gl_FragCoord.x - <span class="hljs-number">1</span>, gl_FragCoord.y + <span class="hljs-number">0</span>) / texSize).rgb<font></font>
      * neighbor<font></font>
      + texture(sharpenTexture, vec2(gl_FragCoord.x + <span class="hljs-number">0</span>, gl_FragCoord.y + <span class="hljs-number">0</span>) / texSize).rgb<font></font>
      * center<font></font>
      + texture(sharpenTexture, vec2(gl_FragCoord.x + <span class="hljs-number">1</span>, gl_FragCoord.y + <span class="hljs-number">0</span>) / texSize).rgb<font></font>
      * neighbor<font></font>
<font></font>
      + texture(sharpenTexture, vec2(gl_FragCoord.x + <span class="hljs-number">0</span>, gl_FragCoord.y - <span class="hljs-number">1</span>) / texSize).rgb<font></font>
      * neighbor<font></font>
      ;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
隣接するフラグメントは、上下左右にあります。</font><font style="vertical-align: inherit;">近傍と現在のフラグメントにそれらの値を掛けた後、結果が加算されます。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    fragColor = vec4(color, texture(sharpenTexture, texCoord).a);<font></font>
<font></font>
    <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この量は、フラグメントの最終的な色です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sharpen.frag</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィルムグレイン</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f3/16e/232/2f316e232598d07fa8114f8db32c12a7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
穀物フィルム（例のように少量ではなく）は、この効果がなくなるまで見えないリアリズムを追加できます。</font><font style="vertical-align: inherit;">通常、これらはデジタル生成された画像をより説得力のあるものにする欠陥です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、フィルムグレインは、表示される前にフレームに適用される最後のエフェクトです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font></font></h3><br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> amount = <span class="hljs-number">0.1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br>
<code>amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィルム粒子の可視性を制御します。</font><font style="vertical-align: inherit;">値が高いほど、画像の「雪」が多くなります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランダムな明るさ</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ...</span><font></font>
<font></font>
uniform <span class="hljs-keyword">float</span> osg_FrameTime;<font></font>
<font></font>
  <span class="hljs-comment">//...</span><font></font>
<font></font>
  <span class="hljs-keyword">float</span> toRadians = <span class="hljs-number">3.14</span> / <span class="hljs-number">180</span>;<font></font>
<font></font>
    <span class="hljs-comment">//...</span><font></font>
<font></font>
    <span class="hljs-keyword">float</span> randomIntensity =<font></font>
      fract<font></font>
        ( <span class="hljs-number">10000</span>
        * <span class="hljs-built_in">sin</span><font></font>
            (<font></font>
              ( gl_FragCoord.x<font></font>
              + gl_FragCoord.y<font></font>
              * osg_FrameTime<font></font>
              )<font></font>
            * toRadians<font></font>
            )<font></font>
        );<font></font>
<font></font>
    <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは、値を調整するために必要なランダムな明るさを計算します。</font></font><br>
<br>
<pre><code class="cpp hljs">Time Since F1 = <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">10</span><font></font>
Frame Number  = F1    F3    F4       F5 F6<font></font>
osg_FrameTime = <span class="hljs-number">00</span>    <span class="hljs-number">02</span>    <span class="hljs-number">04</span>       <span class="hljs-number">07</span> <span class="hljs-number">08</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panda3D </font></font><code>osg_FrameTime</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって提供される</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
値</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">フレーム時間は、最初のフレームから経過した秒数に関する情報を含むタイムスタンプです。</font><font style="vertical-align: inherit;">サンプルコードは、これを使用してフィルムの粒子をアニメーション化し</font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これ</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">フレームごとに異なります。</font></font><br>
<br>
<pre><code class="cpp hljs">              <span class="hljs-comment">// ...</span><font></font>
<font></font>
              ( gl_FragCoord.x<font></font>
              + gl_FragCoord.y<font></font>
              * <span class="hljs-number">8009</span> <span class="hljs-comment">// Large number here.</span><font></font>
<font></font>
              <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的な粒子の場合、フィルムを</font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多数</font><font style="vertical-align: inherit;">交換する必要があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">パターンが表示されないようにするには、別の数値を試してください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/358/2bd/6d2/3582bd6d2d67eb5ac1fdcdf8d52800e6.gif"></div><br>
<br>
<pre><code class="cpp hljs">        <span class="hljs-comment">// ...</span><font></font>
<font></font>
        * <span class="hljs-built_in">sin</span><font></font>
            (<font></font>
              ( gl_FragCoord.x<font></font>
              + gl_FragCoord.y<font></font>
              * someNumber<font></font>
<font></font>
              <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィルム粒子の点またはスポットを作成するには、座標と、xおよびyの両方が使用されます。</font><font style="vertical-align: inherit;">xを使用すると垂直線のみが表示され、yを使用すると水平線のみが表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードでは、1つの座標に別の座標を乗算して、対角対称性を破壊しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/ad6/d5a/4c0ad6d5ada5d533b6dc31bbfa7aa0fc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、座標乗数を取り除くことができ、かなり許容できる雨の効果を得ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
乗算、出力を雨効果をアニメーション化することに注意してください</font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
雨の方向を変更するには、x座標とy座標を試してください。</font><font style="vertical-align: inherit;">下向きのシャワーの場合は、x座標のみを残します。</font></font><br>
<br>
<pre><code class="cpp hljs">input = (gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime) * toRadians<font></font>
  frame(<span class="hljs-number">10000</span> * <span class="hljs-built_in">sin</span>(input)) =<font></font>
    fract(<span class="hljs-number">10000</span> * <span class="hljs-built_in">sin</span>(<span class="hljs-number">6.977777777777778</span>)) =<font></font>
      fract(<span class="hljs-number">10000</span> * <span class="hljs-number">0.6400723818964882</span>) =</code></pre><br>
<code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハッシュ関数として使用されます。</font><font style="vertical-align: inherit;">フラグメント座標は出力値でハッシュされます</font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これのおかげで、便利なプロパティが表示されます。入力データ（大小にかかわらず）にかかわらず、出力間隔はマイナス1から1の範囲になります。</font></font><br>
<br>
<pre><code class="cpp hljs">fract(<span class="hljs-number">10000</span> * <span class="hljs-built_in">sin</span>(<span class="hljs-number">6.977777777777778</span>)) =<font></font>
  fract(<span class="hljs-number">10000</span> * <span class="hljs-number">0.6400723818964882</span>) =<font></font>
    fract(<span class="hljs-number">6400.723818964882</span>) =
      <span class="hljs-number">0.723818964882</span></code></pre><br>
<code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と組み合わせて</font></font><code>fract</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、疑似乱数ジェネレータとしても使用されます。</font></font><br>
<br>
<pre><code class="cpp hljs">&gt;&gt;&gt; [<span class="hljs-built_in">floor</span>(fract(<span class="hljs-number">4</span>     * <span class="hljs-built_in">sin</span>(x * toRadians)) * <span class="hljs-number">10</span>) <span class="hljs-function"><span class="hljs-keyword">for</span> x in <span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)</span>]
[0, 0, 1, 2, 2, 3, 4, 4, 5, 6]

&gt;&gt;&gt; [<span class="hljs-title">floor</span><span class="hljs-params">(fract(<span class="hljs-number">10000</span> * <span class="hljs-built_in">sin</span>(x * toRadians)) * <span class="hljs-number">10</span>)</span> <span class="hljs-keyword">for</span> x in <span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)</span>]
[0, 4, 8, 0, 2, 1, 7, 0, 0, 5]</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に数値の最初の行を見て、次に2番目の行を見てください。</font><font style="vertical-align: inherit;">各行が決定されますが、2番目のパターンは2番目のパターンよりも目立ちません。</font><font style="vertical-align: inherit;">したがって、出力が</font></font><code>fract(10000 * sin(...))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">確定的で</font><font style="vertical-align: inherit;">あるという事実にもかかわらず、</font><font style="vertical-align: inherit;">パターンははるかに弱く認識されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/6e7/f0f/b886e7f0feda6760c5fc87df6680680f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、係数</font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が最初に1、次に10、次に100、次に1000となる</font><font style="vertical-align: inherit;">様子を示して</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
います。出力値の乗数が増加するにつれて、</font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターンが目立たなくなります。</font><font style="vertical-align: inherit;">このため、コード</font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は10,000倍されています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグメントの色</font></font></h3><br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  vec2 texSize  = textureSize(filmGrainTexture, <span class="hljs-number">0</span>).xy;<font></font>
  vec2 texCoord = gl_FragCoord.xy / texSize;<font></font>
<font></font>
  vec4 color = texture(filmGrainTexture, texCoord);<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグメントの座標をUV座標に変換します。</font><font style="vertical-align: inherit;">これらのUV座標を使用して、現在のフラグメントのテクスチャカラーを探します。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    amount *= randomIntensity;<font></font>
<font></font>
    color.rgb += amount;<font></font>
<font></font>
    <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値をランダムな明るさに変更し、色に追加します。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-comment">// ...</span><font></font>
<font></font>
  fragColor = color;<font></font>
<font></font>
  <span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグメントの色を設定します。それだけです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">film-grain.frag</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">謝辞</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事では</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Kiwi Soda Fontフォントを</font></a><font style="vertical-align: inherit;">使用しています</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja453676/index.html">LinuxのようにSSH経由でWindowsに接続する</a></li>
<li><a href="../ja453678/index.html">水を通して音のリバーブまたはビデオ伝送を確認する方法-2</a></li>
<li><a href="../ja453682/index.html">ReddにインストールされたFPGA用の最も単純な「ファームウェア」の開発。パート2.プログラムコード</a></li>
<li><a href="../ja453686/index.html">セキュリティウィーク22：脅威の統計、バンキング型トロイの木馬、一般的なエクスプロイト</a></li>
<li><a href="../ja453688/index.html">Javaは流血型の企業であるだけでなく、遅延に敏感な高速アプリケーションでもあります</a></li>
<li><a href="../ja453696/index.html">双方向角度バインディング、もう少し理解</a></li>
<li><a href="../ja453698/index.html">量子意識における量子情報</a></li>
<li><a href="../ja453700/index.html">SDL 2のレッスン：レッスン1-こんにちは、SDL 2</a></li>
<li><a href="../ja453706/index.html">Google Cloud Professional Data Engineer認定試験に合格した方法</a></li>
<li><a href="../ja453708/index.html">BASCOM AVR環境のMK AVR用AQUA RTOSリアルタイムOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>