<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍁 🏂🏼 🙄 Código asincrónico linealizado con corutina 🙌 🤨 🤟🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Además de usar la rutina para crear generadores, puede intentar usarlos para linealizar el código asincrónico existente. Intentemos hacer esto con un ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Código asincrónico linealizado con corutina</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/493808/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98e/c7c/314/98ec7c314c49b57c2d8af8d53508b211.jpg" alt="imagen"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además de usar la rutina para crear generadores, puede intentar usarlos para linealizar el código asincrónico existente. </font><font style="vertical-align: inherit;">Intentemos hacer esto con un pequeño ejemplo. </font><font style="vertical-align: inherit;">Tome el código escrito en el marco del actor y reescriba una función de este código en las rutinas. </font><font style="vertical-align: inherit;">Para construir el proyecto, usaremos gcc de la rama de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corutinas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro objetivo es obtener devoluciones de llamada de fideos:</font></font><br>
<br>
<pre><code class="cpp hljs">    abActor.getA(ABActor::GetACallback([<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
        abActor.getB(ABActor::GetBCallback([a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {<font></font>
            abActor.saveAB(a - b, a + b, ABActor::SaveABCallback([<span class="hljs-keyword">this</span>](){<font></font>
                abActor.getA(ABActor::GetACallback([<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
                    abActor.getB(ABActor::GetBCallback([a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
                    }));<font></font>
                }));<font></font>
            }));<font></font>
        }));<font></font>
    }));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algo así como:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync();
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync();
<span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(a - b, a + b);
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync();
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync();
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces empecemos.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actores</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para empezar, necesitamos crear un marco de actor simple. </font><font style="vertical-align: inherit;">Crear un marco de actor completo es una tarea difícil y grande, por lo que solo implementamos algún tipo de él. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, cree una clase base:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actor</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> Task = <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt;;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~Actor();
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Task &amp;task)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tryRunTask</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;Task&gt; <span class="hljs-built_in">queue</span>;
    <span class="hljs-keyword">mutable</span> <span class="hljs-built_in">std</span>::mutex mutex;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea es básicamente simple: colocamos tareas que son objetos funcionales en una cola, y cuando intentamos RunTask, intentamos completar esta tarea. </font><font style="vertical-align: inherit;">La implementación de la clase confirma nuestras intenciones:</font></font><br>
<br>
<pre><code class="cpp hljs">Actor::~Actor() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Actor::addTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Task &amp;task)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;
    <span class="hljs-built_in">queue</span>.push(task);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Actor::tryRunTask</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>.empty()) {
        <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">const</span> Task task = <span class="hljs-built_in">queue</span>.front();
    <span class="hljs-built_in">queue</span>.pop();<font></font>
    lock.unlock();<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::invoke(task);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La siguiente clase es el "hilo" al que pertenecerán nuestros actores:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actor</span>;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActorThread</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
    ~ActorThread();<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addActor</span><span class="hljs-params">(Actor &amp;actor)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::reference_wrapper&lt;Actor&gt;&gt; actors;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí también todo es simple: al comienzo del programa, "vinculamos" a nuestros actores al hilo usando el método addActor, y luego comenzamos el hilo usando el método run.</font></font><br>
<br>
<pre><code class="cpp hljs">ActorThread::~ActorThread() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ActorThread::addActor</span><span class="hljs-params">(Actor &amp;actor)</span> </span>{<font></font>
    actors.emplace_back(actor);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ActorThread::run</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">for</span> (Actor &amp;actor: actors) {<font></font>
            actor.tryRunTask();<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al comenzar el hilo, ingresamos en un bucle infinito e intentamos realizar una tarea de cada actor. </font><font style="vertical-align: inherit;">No es la mejor solución, pero servirá para una demostración. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora veamos al representante de la clase de actor:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABActor</span>:</span> <span class="hljs-keyword">public</span> Actor {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> GetACallback = Callback&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> result)&gt;;
    <span class="hljs-keyword">using</span> GetBCallback = Callback&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> result)&gt;;
    <span class="hljs-keyword">using</span> SaveABCallback = Callback&lt;<span class="hljs-keyword">void</span>()&gt;;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getA</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getB</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveAB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getAProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getBProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveABProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta clase almacena 2 números en sí mismo, ayb, y, a pedido, devuelve sus valores o los sobrescribe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como devolución de llamada, acepta un objeto funcional con los parámetros necesarios. </font><font style="vertical-align: inherit;">Pero prestemos atención al hecho de que diferentes actores pueden ser lanzados en diferentes hilos. </font><font style="vertical-align: inherit;">Y, por lo tanto, si al final del trabajo simplemente llamamos a la devolución de llamada pasada al método, esta devolución de llamada se invocará en el subproceso ejecutable actual, y no en el subproceso que llamó a nuestro método y creó esta devolución de llamada. </font><font style="vertical-align: inherit;">Por lo tanto, necesitamos crear un contenedor sobre la devolución de llamada que resolverá esta situación:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Callback</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Functor&gt;
    <span class="hljs-title">Callback</span><span class="hljs-params">(Actor &amp;sender, <span class="hljs-keyword">const</span> Functor &amp;callback)</span>
        : <span class="hljs-title">sender</span><span class="hljs-params">(sender)</span>
        , <span class="hljs-title">callback</span><span class="hljs-params">(callback)</span>
    </span>{}
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Args&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(Args&amp;&amp; ...args)</span> <span class="hljs-keyword">const</span> </span>{<font></font>
        sender.addTask(<span class="hljs-built_in">std</span>::bind(callback, <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...));<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:<font></font>
    Actor &amp;sender;<font></font>
    <span class="hljs-built_in">std</span>::function&lt;C&gt; callback;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este contenedor recuerda al actor original, y cuando intenta ejecutarse, simplemente agrega una devolución de llamada real a la cola de tareas del actor original. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, la implementación de la clase ABActor se ve así:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getA</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getAProcess, <span class="hljs-keyword">this</span>, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getAProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ABActor::GetACallback &amp;callback)</span> </span>{
    <span class="hljs-built_in">std</span>::invoke(callback, a);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getB</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getBProcess, <span class="hljs-keyword">this</span>, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getBProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ABActor::GetBCallback &amp;callback)</span> </span>{
    <span class="hljs-built_in">std</span>::invoke(callback, b);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::saveAB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::saveABProcess, <span class="hljs-keyword">this</span>, a, b, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::saveABProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> ABActor::SaveABCallback &amp;callback)</span> </span>{
    <span class="hljs-keyword">this</span>-&gt;a = a;
    <span class="hljs-keyword">this</span>-&gt;b = b;
    <span class="hljs-built_in">std</span>::invoke(callback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el método de interfaz de la clase, simplemente vinculamos los argumentos pasados ​​a la "ranura" correspondiente de la clase, creando así una tarea, y colocamos esta tarea en la cola de tareas de esta clase. </font><font style="vertical-align: inherit;">Cuando el subproceso de la tarea comienza a realizar la tarea, llamará al "slot" correcto, que realizará todas las acciones que necesita y llamará a la devolución de llamada, que a su vez enviará la devolución de llamada real a la cola de la tarea que lo causó. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escribamos un actor que usará la clase ABActor:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABActor</span>;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WokrerActor</span>:</span> <span class="hljs-keyword">public</span> Actor {
<span class="hljs-keyword">public</span>:<font></font>
    WokrerActor(ABActor &amp;actor)<font></font>
        : abActor(actor)<font></font>
    {}<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">workProcess</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:<font></font>
    ABActor &amp;abActor;<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::work</span><span class="hljs-params">()</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;WokrerActor::workProcess, <span class="hljs-keyword">this</span>));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{<font></font>
    abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    }));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y poner todo junto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<font></font>
    ABActor abActor;<font></font>
    <span class="hljs-function">WokrerActor <span class="hljs-title">workerActor</span><span class="hljs-params">(abActor)</span></span>;<font></font>
<font></font>
    ActorThread thread;<font></font>
    thread.addActor(abActor);<font></font>
    thread.addActor(workerActor);<font></font>
<font></font>
    workerActor.work();<font></font>
<font></font>
    thread.run();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sigamos toda la cadena de código. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al principio, creamos los objetos necesarios y establecemos conexiones entre ellos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego agregamos la tarea workProcess a la cola de tareas del actor Worker. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando se inicia el hilo, encontrará nuestra tarea en la cola y comenzará a ejecutarla. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el proceso de ejecución, llamamos al método getA de la clase ABActor, colocando así la tarea correspondiente en la cola de la clase ABActor y completamos la ejecución. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuación, el subproceso tomará la tarea recién creada de la clase ABActor y la ejecutará, lo que conducirá a la ejecución del código getAProcess.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este código llamará a una devolución de llamada, pasando el argumento necesario: la variable a. Pero dado que la devolución de llamada que posee es una envoltura, de hecho, una devolución de llamada real con parámetros completados se colocará en la cola de la clase Worker. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y cuando, en la próxima iteración del ciclo, el subproceso se retira y ejecuta nuestra devolución de llamada desde la clase Worker, veremos el resultado de la línea "Resultado 10"</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actor Framework es una forma bastante conveniente de interactuar con las clases dispersas entre diferentes flujos físicos entre sí. La peculiaridad del diseño de clase, como debería haber estado convencido de esto, es que dentro de cada actor individual todas las acciones se realizan por completo y en un solo hilo. El único punto de sincronización de las secuencias se realiza en los detalles de implementación del marco del actor y no es visible para el programador. Por lo tanto, un programador puede escribir código de un solo subproceso sin preocuparse por cerrar mutexes y rastrear situaciones de carrera, puntos muertos y otros dolores de cabeza. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lamentablemente, esta solución tiene un precio. Dado que el resultado de ejecutar a otro actor solo es accesible desde la devolución de llamada, tarde o temprano el código del actor se convierte en algo como esto:</font></font><br>
<br>
<pre><code class="cpp hljs">    abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
        abActor.getB(ABActor::GetBCallback(*<span class="hljs-keyword">this</span>, [a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {<font></font>
            abActor.saveAB(a - b, a + b, ABActor::SaveABCallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](){<font></font>
                abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
                    abActor.getB(ABActor::GetBCallback(*<span class="hljs-keyword">this</span>, [a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
                    }));<font></font>
                }));<font></font>
            }));<font></font>
        }));<font></font>
    }));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos si podemos evitar esto usando la innovación de C ++ 20 - corutinas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero primero, especificaremos las limitaciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Naturalmente, de ninguna manera podemos cambiar el código del marco del actor. </font><font style="vertical-align: inherit;">Además, no podemos cambiar las firmas de los métodos públicos y privados de instancias de la clase Actor: ABActor y WorkerActor. </font><font style="vertical-align: inherit;">Veamos si podemos salir de esta situación.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corutinas </font><font style="vertical-align: inherit;">Parte 1. Awaiter</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea principal de la rutina es que al crear la rutina, se crea un marco de pila separado para él en el montón, desde el cual podemos "salir" en cualquier momento, mientras mantenemos la posición de ejecución actual, los registros del procesador y otra información necesaria. Luego, en cualquier momento, también podemos volver a la ejecución de la corutina suspendida y completarla hasta el final o hasta la próxima suspensión. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El objeto std :: coroutine_handle &lt;&gt; es responsable de administrar estos datos, que esencialmente representan un puntero al marco de la pila (y otros datos necesarios), y que tiene un método de reanudación (o su análogo, el operador ()), que nos devuelve a la ejecución de la rutina. . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En base a estos datos, primero escribamos la función getAAsync y luego intentemos generalizar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, supongamos que ya tenemos una instancia de la clase coro std :: coroutine_handle &lt;&gt;, ¿qué necesitamos hacer? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debe llamar al método ya existente ABActor :: getA, que resolverá la situación según sea necesario, pero primero debe crear una devolución de llamada para el método getA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recordemos que una devolución de llamada se devuelve a la devolución de llamada del método getA, el resultado del método getA. Además, esta devolución de llamada se llama en el subproceso de trabajo del subproceso. Por lo tanto, a partir de esta devolución de llamada, podemos continuar ejecutando con seguridad la rutina que se creó solo a partir del subproceso Worker y que continuará llevando a cabo su secuencia de acciones. Pero también, en algún lugar debemos guardar el resultado devuelto en la devolución de llamada, por supuesto, nos será útil aún más.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> callback = GetACallback(returnCallbackActor, [&amp;value, coro](<span class="hljs-keyword">int</span> result) {<font></font>
        value = result;<font></font>
        <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
 });<font></font>
getA(callback);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ahora necesita tomar una instancia del objeto coroutine_handle de alguna parte y un enlace donde pueda guardar nuestro resultado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el futuro, veremos que se nos pasa coroutine_handle como resultado de llamar a la función. </font><font style="vertical-align: inherit;">En consecuencia, todo lo que podemos hacer con él es pasarlo a alguna otra función. </font><font style="vertical-align: inherit;">Preparemos esta función como lambda. </font><font style="vertical-align: inherit;">(Pasaremos el enlace a la variable donde se almacenará el resultado de la devolución de llamada a la empresa).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> storeCoroToQueue = [&amp;returnCallbackActor, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">auto</span> &amp;value, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro) {
    <span class="hljs-keyword">auto</span> callback=GetACallback(returnCallbackActor, [&amp;value, coro](<span class="hljs-keyword">int</span> result){<font></font>
        value = result;<font></font>
        <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
    });<font></font>
    getA(callback);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Guardaremos esta función en la próxima clase.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorAwaiterSimple</span> {</span>
    <span class="hljs-keyword">int</span> value;<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> &amp;value,<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; forwardCoroToCallback;<font></font>
<font></font>
    ActorAwaiterSimple(<font></font>
        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> &amp;value, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; &amp;forwardCoroToCallback<font></font>
    )<font></font>
        : forwardCoroToCallback(forwardCoroToCallback)<font></font>
    {}<font></font>
<font></font>
    ActorAwaiterSimple(<span class="hljs-keyword">const</span> ActorAwaiterSimple &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> ActorAwaiterSimple &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple(ActorAwaiterSimple &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple&amp; <span class="hljs-keyword">operator</span>=(ActorAwaiterSimple &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
<span class="hljs-comment">// ...</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además del objeto funcional, también mantendremos aquí la memoria (en forma de valor variable) para el valor que nos espera en la devolución de llamada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como mantenemos la memoria debajo del valor aquí, difícilmente queremos que la instancia de esta clase se copie o se mueva a alguna parte. Imagine, por ejemplo, que alguien copió esta clase, guardó el valor bajo la variable de valor en la instancia anterior de la clase y luego trató de leerlo desde la nueva instancia. Y, naturalmente, no está allí, ya que la copia se produjo antes de guardar. Desagradable. Por lo tanto, nos protegemos de este problema al prohibir a los constructores y copiar y mover operadores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sigamos escribiendo esta clase. El siguiente método que necesitamos es:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Responde a la pregunta de si nuestro significado está listo para ser emitido. </font><font style="vertical-align: inherit;">Naturalmente, en la primera llamada, nuestro valor aún no está listo, y en el futuro nadie nos preguntará sobre esto, así que simplemente devuelva falso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La instancia de coroutine_handle se nos pasará en el método void await_suspend (std :: coroutine_handle &lt;&gt; coro), así que llamemos a nuestro functor preparado, pasando allí también un enlace de memoria debajo del valor:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro)</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-built_in">std</span>::invoke(forwardCoroToCallback, <span class="hljs-built_in">std</span>::ref(value), coro);<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado de la ejecución de la función se preguntará en el momento adecuado llamando al método await_resume. </font><font style="vertical-align: inherit;">No nos negaremos al solicitante:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> value;<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora se puede llamar a nuestro método usando la palabra clave co_await:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo que sucederá aquí, ya lo estamos representando aproximadamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, se creará un objeto de tipo ActorAwaiterSimple, que se transferirá a la "entrada" de co_await. Primero preguntará (llamando a await_ready) si accidentalmente tenemos un resultado final (no tenemos), luego llamará a await_suspend, pasando en un contexto (de hecho, un puntero al marco de pila de rutina actual) e interrumpirá la ejecución. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el futuro, cuando el actor ABActor complete su trabajo y llame a la devolución de llamada de resultado, este resultado (que ya está en el subproceso de subproceso de trabajo) se guardará en la única instancia (que queda en la pila de la rutina) de ActorAwaiterSimple y comenzará la continuación de la rutina. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Corutin continuará la ejecución, tomará el resultado guardado llamando al método await_resume y pasará este resultado a la variable a</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por el momento, la limitación del Awaiter actual es que solo puede funcionar con devoluciones de llamada con un parámetro de tipo int. </font><font style="vertical-align: inherit;">Intentemos expandir la aplicación de Awaiter:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorAwaiter</span> {</span><font></font>
<font></font>
    <span class="hljs-built_in">std</span>::tuple&lt;T...&gt; values;<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-built_in">std</span>::tuple&lt;T...&gt; &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; storeHandler;<font></font>
<font></font>
    ActorAwaiter(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-built_in">std</span>::tuple&lt;T...&gt; &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; &amp;storeHandler)<font></font>
        : storeHandler(storeHandler)<font></font>
    {}<font></font>
<font></font>
    ActorAwaiter(<span class="hljs-keyword">const</span> ActorAwaiter &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> ActorAwaiter &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter(ActorAwaiter &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter&amp; <span class="hljs-keyword">operator</span>=(ActorAwaiter &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro)</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-built_in">std</span>::invoke(storeHandler, <span class="hljs-built_in">std</span>::ref(values), coro);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len==<span class="hljs-number">0</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-keyword">void</span> await_resume() <span class="hljs-keyword">noexcept</span> {<font></font>
<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len==<span class="hljs-number">1</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-keyword">auto</span> await_resume() <span class="hljs-keyword">noexcept</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">0</span>&gt;(values);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len!=<span class="hljs-number">1</span> &amp;&amp; len!=<span class="hljs-number">0</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-built_in">std</span>::tuple&lt;T...&gt; await_resume() <span class="hljs-keyword">noexcept</span> {
        <span class="hljs-keyword">return</span> values;<font></font>
    }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí usamos std :: tuple para poder guardar varias variables a la vez. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sfinae se impone en el método await_resume para que sea posible no devolver una tupla en todos los casos, sino que depende del número de valores que se encuentran en la tupla, return void, exactamente 1 argumento o la tupla completa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los envoltorios para crear Awaiter ahora se ven así:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> MakeCallback, <span class="hljs-keyword">typename</span>... ReturnArgs, <span class="hljs-keyword">typename</span> Func&gt;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">makeCoroCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Func &amp;func, Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> [&amp;returnCallback, func](<span class="hljs-keyword">auto</span> &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro) {
        <span class="hljs-keyword">auto</span> callback = MakeCallback(returnCallback, [&amp;values, coro](ReturnArgs&amp;&amp; ...result) {<font></font>
            values = <span class="hljs-built_in">std</span>::make_tuple(<span class="hljs-built_in">std</span>::forward&lt;ReturnArgs&gt;(result)...);
            <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
        });<font></font>
        func(callback);<font></font>
    };<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> MakeCallback, <span class="hljs-keyword">typename</span>... ReturnArgs, <span class="hljs-keyword">typename</span> Func&gt;
<span class="hljs-keyword">static</span> ActorAwaiter&lt;ReturnArgs...&gt; <span class="hljs-title">makeActorAwaiter</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Func &amp;func, Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> storeCoroToQueue = makeCoroCallback&lt;MakeCallback, ReturnArgs...&gt;(func, returnCallback);
    <span class="hljs-keyword">return</span> ActorAwaiter&lt;ReturnArgs...&gt;(storeCoroToQueue);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getAAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;GetACallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getA, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getBAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;GetBCallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getB, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;&gt; <span class="hljs-title">ABActor::saveABAsync</span><span class="hljs-params">(Actor &amp;returnCallback, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;SaveABCallback&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::saveAB, <span class="hljs-keyword">this</span>, a, b, _1), returnCallback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora veamos cómo usar el tipo creado directamente en la rutina.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corutinas </font><font style="vertical-align: inherit;">Parte 2. Reanudable</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desde el punto de vista de C ++, una función que contiene las palabras co_await, co_yield o co_return se considera de rutina. Pero también dicha función debería devolver un cierto tipo. Acordamos que no cambiaremos la firma de las funciones (aquí quiero decir que el tipo de retorno también se refiere a la firma), por lo que tendremos que salir de alguna manera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creemos una corutina lambda y llamemos desde nuestra función:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(¿Por qué no capturar esto en la captura-lista de lambdas? Entonces todo el interior de código saldría un poco más fácil. Pero da la casualidad de que, al parecer, las lambda-co-rutinas en el compilador todavía no están soportados por completo, por lo que este código no funcionará.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se puede ver, nuestra el código de devolución de llamada ahora se ha convertido en un código lineal bastante agradable. </font><font style="vertical-align: inherit;">Todo lo que nos queda es inventar la clase ActorResumable </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorResumable</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">promise_type</span> {</span>
        <span class="hljs-keyword">using</span> coro_handle = <span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>{ 
            <span class="hljs-comment">//  ,    ActorResumable   promise_type</span>
            <span class="hljs-keyword">return</span> coro_handle::from_promise(*<span class="hljs-keyword">this</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//      </span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::suspend_never();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//      . </span>
            <span class="hljs-comment">// ,     </span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::suspend_never();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//   ,       </span>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">terminate</span>();<font></font>
        }<font></font>
    };<font></font>
<font></font>
    ActorResumable(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;) {}<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El pseudocódigo de la corutina generada a partir de nuestra lambda se parece a esto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ActorResumable <span class="hljs-title">coro</span><span class="hljs-params">()</span> </span>{<font></font>
    promise_type promise;<font></font>
    ActorResumable retobj = promise.get_return_object();<font></font>
    <span class="hljs-keyword">auto</span> intial_suspend = promise.initial_suspend();
    <span class="hljs-keyword">if</span> (initial_suspend == <span class="hljs-built_in">std</span>::suspend_always)  {
          <span class="hljs-comment">// yield</span><font></font>
    }<font></font>
    <span class="hljs-keyword">try</span> { 
        <span class="hljs-comment">//  .</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    } <span class="hljs-keyword">catch</span>(...) { <font></font>
        promise.unhandled_exception();<font></font>
    }<font></font>
final_suspend:<font></font>
    <span class="hljs-keyword">auto</span> final_suspend = promise.final_suspend();
    <span class="hljs-keyword">if</span> (final_suspend == <span class="hljs-built_in">std</span>::suspend_always)  {
         <span class="hljs-comment">// yield</span>
    } <span class="hljs-keyword">else</span> {<font></font>
         cleanup();<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es solo un pseudocódigo, algunas cosas se simplifican intencionalmente. </font><font style="vertical-align: inherit;">Sin embargo, veamos qué pasa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero creamos una promesa y ActorResumable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de initial_suspend () no hacemos una pausa, sino que seguimos adelante. </font><font style="vertical-align: inherit;">Comenzamos a ejecutar la parte principal del programa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando llegamos a co_await, entendemos que debemos hacer una pausa. </font><font style="vertical-align: inherit;">Ya hemos examinado esta situación en la sección anterior, puede volver a ella y revisarla. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de continuar la ejecución y mostrar el resultado en la pantalla, finaliza la ejecución de rutina. </font><font style="vertical-align: inherit;">Verificamos final_suspend y borramos todo el contexto de la rutina.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corutinas </font><font style="vertical-align: inherit;">Parte 3. Tarea</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recordemos a qué etapa hemos llegado ahora.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se ve bien, pero es fácil ver que el código:</font></font><br>
<br>
<pre><code class="cpp hljs">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
repetido 2 veces. </font><font style="vertical-align: inherit;">¿Es posible refactorizar este momento y ponerlo en una función separada? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esbocemos cómo se vería esto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">CoroTask&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">WokrerActor::readAB</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> abActor.getAAsync2(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> abActor.getBAsync2(*<span class="hljs-keyword">this</span>);
    <span class="hljs-function"><span class="hljs-keyword">co_return</span> <span class="hljs-title">std::make_pair</span><span class="hljs-params">(a, b)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workCoroProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [a, b] = <span class="hljs-keyword">co_await</span> actor.readAB();
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync2(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [newA, newB] = <span class="hljs-keyword">co_await</span> actor.readAB();
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo lo que nos queda es inventar el tipo CoroTask. </font><font style="vertical-align: inherit;">Pensemos en ello. </font><font style="vertical-align: inherit;">Primero, co_return se usa dentro de la función readAB, lo que significa que CoroTask debe satisfacer la interfaz Reanudable. </font><font style="vertical-align: inherit;">Pero también, un objeto de esta clase se usa para ingresar co_await de otra corutina. </font><font style="vertical-align: inherit;">Esto significa que la clase CoroTask también debe satisfacer la interfaz Awaitable. </font><font style="vertical-align: inherit;">Implementemos ambas interfaces en la clase CoroTask:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">void</span>&gt;<font></font>
struct CoroTask {<font></font>
    struct promise_type {<font></font>
        T result;<font></font>
        <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; waiter;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> CoroTask{*<span class="hljs-keyword">this</span>};<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">return_value</span><span class="hljs-params">(T value)</span> </span>{<font></font>
            result = value;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">terminate</span>();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-built_in">std</span>::suspend_always <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> {};<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">final_awaiter</span> {</span>
                <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>{}
                <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt; me)</span> </span>{
                    <span class="hljs-keyword">return</span> me.promise().waiter;<font></font>
                }<font></font>
            };<font></font>
            <span class="hljs-keyword">return</span> final_awaiter{};<font></font>
        }<font></font>
    };<font></font>
<font></font>
    CoroTask(CoroTask &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask&amp; <span class="hljs-keyword">operator</span>=(CoroTask&amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask(<span class="hljs-keyword">const</span> CoroTask&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> CoroTask&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
    ~CoroTask() {<font></font>
        <span class="hljs-keyword">if</span> (h) {<font></font>
            h.destroy();<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CoroTask</span><span class="hljs-params">(promise_type &amp; p)</span>
        : <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;::from_promise(p))</span>
    </span>{}<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">T <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">auto</span> &amp;result = h.promise().result;
        <span class="hljs-keyword">return</span> result;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; waiter)</span> </span>{<font></font>
        h.promise().waiter = waiter;<font></font>
        h.resume();<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt; h;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Recomiendo encarecidamente abrir la imagen de fondo de esta publicación. En el futuro, esto será de gran ayuda). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, veamos qué sucede aquí. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Vaya a la rutina lambda e inmediatamente cree la rutina WokrerActor :: readAB. Pero después de crear esta corutina, no comenzamos a ejecutarla (initial_suspend == suspend_always), lo que nos obliga a interrumpir y volver a la lambda corutina. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. co_await lambda comprueba si readAB está listo. El resultado no está listo (await_ready == false), lo que lo obliga a pasar su contexto al método CoroTask :: await_suspend. Este contexto se guarda en CoroTask y se inicia el resumen de la rutina </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
de </font><font style="vertical-align: inherit;">readAB </font><font style="vertical-align: inherit;">3. Después de que la rutina de readAB haya completado todas las acciones necesarias, llega a la línea:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">co_return</span> <span class="hljs-title">std::make_pair</span><span class="hljs-params">(a, b)</span></span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
como resultado, se llama al método CoroTask :: promise_type :: return_value y dentro del método CoroTask :: promise_type se guarda el par de números creado </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. Dado que se llamó al método co_return, la ejecución de la rutina llega a su fin, lo que significa que es hora de llamar al método CoroTask :: promise_type :: final_suspend . Este método devuelve una estructura autoescrita (no olvide mirar la imagen), que le obliga a llamar al método final_awaiter :: await_suspend, desde el cual se devuelve el contexto lambda de rutina guardado en el paso 2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Por qué no podríamos regresar suspend_always aquí? Después de todo, en el caso de initial_suspend de esta clase, ¿tuvimos éxito? El hecho es que en initial_suspend lo logramos porque nuestra corutina fue llamada por nuestra corutina lambda, y volvimos a ella. Pero en el momento en que llegamos a la llamada final_suspend, lo más probable es que nuestra rutina continúe desde otra pila (específicamente, desde el lambda que preparó la función makeCoroCallback), y si regresáramos suspend_always aquí, regresaríamos a ella, y no al método workCoroProcess. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5. Dado que el método final_awaiter :: await_suspend nos devolvió el contexto, esto obliga al programa a continuar ejecutando el contexto devuelto, es decir, la lambda corutina. Desde que la ejecución volvió al punto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [a, b] = <span class="hljs-keyword">co_await</span> actor.readAB();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
entonces necesitamos aislar el resultado guardado llamando al método CoroTask :: await_resume. Se recibe el resultado, se pasa a las variables a y b, y ahora se destruye la instancia de CoroTask. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6. La instancia de CoroTask fue destruida, pero ¿qué pasó con el contexto WokrerActor :: readAB? Si desde CoroTask :: promise_type :: final_suspend devolveríamos suspend_never (más precisamente, devolveríamos eso a la pregunta await_ready volvería verdadero), entonces en ese momento el contexto de rutina se limpiaría. Pero como no lo hicimos, se nos transfiere la obligación de aclarar el contexto. Despejaremos este contexto en el destructor CoroTask, en este punto ya es seguro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7. Se ejecuta la corrutina readAB, se obtiene el resultado, se borra el contexto, la corrutina lambda continúa ejecutándose ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uf, más o menos lo resolvió. </font><font style="vertical-align: inherit;">¿Recuerdas que de los métodos ABActor :: getAAsync () y similares, devolvemos una estructura autoescrita? </font><font style="vertical-align: inherit;">De hecho, el método getAAsync también se puede convertir en una rutina combinando el conocimiento obtenido de la implementación de las clases CoroTask y ActorAwaiter y obteniendo algo como:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">CoroTaskActor&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getAAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">co_return</span> makeCoroCallback&lt;GetACallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getA, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pero esto lo dejaré para autoanálisis.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, con la ayuda de la rutina, puede linealizar bastante bien el código de devolución de llamada asíncrono. </font><font style="vertical-align: inherit;">Es cierto que el proceso de escribir tipos y funciones auxiliares todavía no parece demasiado intuitivo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo el código está disponible en el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositorio.</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
También le recomiendo que mire </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estas conferencias</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para una inmersión más completa en el tema </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Aquí</font></a></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
hay una gran cantidad de ejemplos sobre el tema de la corutina del mismo autor </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">
Y también puedes ver esta </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">conferencia.</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es493796/index.html">4 mejores patrones de diseño para pruebas automatizadas (y 86 más)</a></li>
<li><a href="../es493798/index.html">No hay diseño en 1C UX / UI</a></li>
<li><a href="../es493800/index.html">Probabilidad empírica</a></li>
<li><a href="../es493802/index.html">Comprender la actividad de Android launchMode: estándar, singleTop, singleTask y singleInstance</a></li>
<li><a href="../es493804/index.html">Jugador que habla en frambuesa</a></li>
<li><a href="../es493810/index.html">Cinco años de desarrollo intensivo del mercado para el reconocimiento de documentos.</a></li>
<li><a href="../es493814/index.html">Cómo realizamos entrevistas en Barcelona</a></li>
<li><a href="../es493816/index.html">Git Guide Número de parte 1: todo lo que necesita saber sobre el directorio .git</a></li>
<li><a href="../es493818/index.html">Git Guide Parte número 2: la regla de oro y otros conceptos básicos de rebase</a></li>
<li><a href="../es493820/index.html">Kubernetes equilibra la carga y escala las conexiones de larga duración</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>