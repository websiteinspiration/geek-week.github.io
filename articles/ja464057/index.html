<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔘 😤 🧒🏽 ヒルベルト、ルベーグ...そしてボイド 👨 👨🏿‍🎤 🍑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="カットの下で、優れた多次元索引付けアルゴリズムをどのように配置すべきかという問題が調査されます。驚いたことに、それほど多くのオプションはありません。
 
 1次元インデックス、Bツリー
 検索アルゴリズムの成功の尺度として2つの事実を検討します- 
 
 

1. 結果の有無の事実の確立は、（インデ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ヒルベルト、ルベーグ...そしてボイド</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464057/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fz/fh/qp/fzfhqp64ark_qr2begezr_lvmha.jpeg" width="80%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 カットの下で、優れた多次元索引付けアルゴリズムをどのように配置すべきかという問題が調査されます。</font><font style="vertical-align: inherit;">驚いたことに、それほど多くのオプションはありません。</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1次元インデックス、Bツリー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検索アルゴリズムの成功の尺度として2つの事実を検討します- </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果の有無の事実の確立は、（インデックスのサイズに関して）対数のディスクページの読み取り数に対して発生します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果を発行するコストはその量に比例します</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この意味で、Bツリーは非常に成功しており、その理由はバランスの取れたツリーの使用と考えることができます。アルゴリズムの単純さは、キースペースの1次元性によるものです。必要に応じて、ページを分割します。このページの要素のソートされたセットの半分に分割するだけで十分です。通常、要素の数で除算されますが、これは必須ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜならツリーのページはディスクに格納されます。Bツリーには、1次元のキースペースを1次元のディスクスペースに非常に効率的に変換する機能があると言えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「正しい挿入」でツリーを埋める場合、これはかなり一般的なケースですが、ページはキーの成長順に生成され、ときどき上位のページと交互に表示されます。それらがディスク上に存在する可能性も十分にあります。したがって、何の努力もせずに、データの局所性が高くなります。同様の重要性を持つデータは、ディスク上の近くのどこかにあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、値をランダムな順序で挿入すると、キーとページがランダムに生成され、その結果、いわゆるインデックスの断片化。データの局所性を復元する断片化防止ツールもあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAIDおよびSSDディスクの時代には、ディスクからの読み取りの順序は重要ではないと思われます。しかし、むしろ、以前と同じ意味ではありません。 SSDではヘッドの物理的な転送は行われないため、そのランダムな読み取り速度は、HDDのような確実な読み取りと比較して数百倍も低下しません。そして、10回に1回</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以上</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bツリーは1970年に磁気テープとドラムの時代に登場したことを思い出してください。前述のテープとドラムのランダムアクセス速度の違いが、HDDやSSDと比べてはるかに劇的だったとき。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、10回も問題になります。</font><font style="vertical-align: inherit;">そして、これらの10回にはSSDの物理的機能だけでなく、基本的なポイントであるリーダーの動作の予測可能性も含まれています。</font><font style="vertical-align: inherit;">読者がこのブロックの次のブロックを要求する可能性が非常に高い場合は、想定により、積極的にダウンロードすることは理にかなっています。</font><font style="vertical-align: inherit;">行動が無秩序である場合、予測の試みはすべて意味がなく、有害ですらあります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多次元インデックス</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、2次元のポイント（X、Y）のインデックスを扱います。これは、それらを操作するのが便利で明確だからです。</font><font style="vertical-align: inherit;">しかし、問題は基本的に同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XとYの個別のインデックスを持つ単純な「洗練されていない」オプションは、私たちの成功基準に従って合格しません。</font><font style="vertical-align: inherit;">最初のポイントを取得するための対数コストは与えられません。</font><font style="vertical-align: inherit;">実際、この質問に答えるには、望ましい範囲に何かがあるか、</font></font><br>
<br>
<ul>
<li>    X      X- </li>
<li>  Y</li>
<li>    </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のポイントはすでにエクステントのサイズに依存しており、対数を保証するものではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「成功」するためには、多次元インデックスを多かれ少なかれバランスの取れたツリーとして配置する必要があります。このステートメントは物議を醸すように見えるかもしれません。しかし、対数検索の要件は、まさにそのようなデバイスを指示します。なぜ2本以上の木ではないのですか？すでに2つのツリーを持つ「洗練されていない」不適切なオプションを検討しました。おそらく適切なものがあります。しかし、2つのツリー-これは2倍の（同時を含む）ロックであり、2倍のコストであり、デッドロックをキャッチする可能性が大幅に高くなります。一本の木でうまくいけば、絶対に使ってみてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてを踏まえると、非常に成功したBツリーエクスペリエンスをベースにして、それを「一般化」して2次元データを処理することを望むのはごく自然なことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Rツリーが表示されました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rツリー</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rツリー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は次のように構成されています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は空白のページがあり、そこにデータ（ポイント）を追加するだけです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ページはオーバーフローしており、分割する必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bツリーでは、ページ要素は自然な順序で並べられているので、問題はどれだけカットするかです。</font><font style="vertical-align: inherit;">Rツリーには自然な順序はありません。</font><font style="vertical-align: inherit;">2つのオプションがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注文、つまり </font><font style="vertical-align: inherit;">X＆Yに基づいて、どのページ要素が順序付けられ、それに応じて分割されるかに従って値を提供する関数を導入します。</font><font style="vertical-align: inherit;">この場合、インデックス全体が、指定された関数の値から構築された通常のBツリーに退化します。</font><font style="vertical-align: inherit;">明らかなプラスに加えて、大きな問題があります-ええと、ええと、私たちは索引を付けましたが、どのように見るのですか？</font><font style="vertical-align: inherit;">これについては後で、最初に2番目のオプションを検討します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ページを空間基準で分割します。</font><font style="vertical-align: inherit;">これを行うには、各ページに、その上/下にある要素の範囲を割り当てる必要があります。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">ルートページには、レイヤー全体の範囲があります。</font><font style="vertical-align: inherit;">分割すると、2つ（またはそれ以上）のページが生成され、その範囲は親ページ（検索用）の範囲に含まれます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全くの不確実性があります。</font><font style="vertical-align: inherit;">どのようにページを分割するのですか？</font><font style="vertical-align: inherit;">水平か垂直か？</font><font style="vertical-align: inherit;">面積の半分または要素の半分に基づいていますか？</font><font style="vertical-align: inherit;">しかし、ポイントが2つのクラスターを形成していても、それらを対角線でしか分離できない場合はどうでしょうか。</font><font style="vertical-align: inherit;">そして、3つのクラスターがある場合はどうでしょうか。</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような質問の単なる存在は、Rツリーがアルゴリズムではないことを示しています。これは、少なくとも挿入時のページの分割、削除/変更時のページのマージ、一括挿入の前処理のための一連のヒューリスティックです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒューリスティックスには、特定のデータ型の特定のツリーの特殊化が含まれます。それら。特定の種類のデータセットでは、彼女はそれほど頻繁に誤りを犯しません。 「ヒューリスティックスを完全に誤解することはできません。この場合、それはアルゴリズムになります」©。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この文脈でのヒューリスティックエラーとはどういう意味ですか？たとえば、ページが分割またはマージされて失敗し、ページが互いに部分的に重なり始めます。検索範囲がページの重複領域に突然落ちる場合、検索のコストはすでにかなり対数的ではありません。時間の経過とともに、挿入/削除を行うと、エラーの数が累積し、ツリーのパフォーマンスが低下し始めます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uf/ls/nc/uflsncc4sbgqqokdgf9ofvlyole.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図1これは自然に構築されたR *ツリーの例です。</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/vw/f0/ic/vwf0icm5lrfl7yapbxzwm0rkipg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2そしてここで同じデータセットが前処理され、ツリーは大量挿入によって構築されます</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bツリーも時間とともに劣化すると言えますが、これは少し異なる劣化です。 Bツリーのパフォーマンスは、そのページが一列に並んでいないために低下します。これは、ツリーを「まっすぐにする」ことで簡単に処理できます-デフラグ。 Rツリーの場合、それを取り除くことはそれほど簡単ではありません。ツリー自体の構造は、状況を修正するために「曲線」です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rツリーの多次元空間への一般化は明らかではありません。たとえば、ページを分割するとき、子ページの周囲を最小化しました。 3次元の場合に最小化するものは何ですか？体積または表面積？そして8次元の場合では？常識はもはやアドバイザーではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インデックス付きスペースは、等方性でない場合があります。</font><font style="vertical-align: inherit;">ポイントだけでなく、時間内の位置をインデックス化しないのはなぜですか？</font><font style="vertical-align: inherit;">（X、Y、t）。</font><font style="vertical-align: inherit;">この場合、たとえば、境界に基づくヒューリスティックは無意味です。</font><font style="vertical-align: inherit;">時間間隔で長さを積み重ねます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rツリーの一般的な印象は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">鰓の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">甲殻類の</font><font style="vertical-align: inherit;">ようなもの</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">それらは彼らと競争するのが難しい独自の生態学的ニッチを持っています。</font><font style="vertical-align: inherit;">しかし、一般的なケースでは、彼らはより発達した動物と競争する機会はありません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クワッドツリー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">四分木、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各非リーフページは正確に均等象限にそのスペースを分割4人の子孫を、持っています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wi/bp/ka/wibpkauhekq5ar01kbafsupfu9c.png" width="500"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3構築されたクワッドツリーの例</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これは、データベースに関して最も成功した設計ではありません。</font></font><br>
<br>
<ul>
<li>            . ,     ,      2,      , ( 100)   B-.</li>
<li>  ,         .</li>
<li>   ,      .       (,    —    ,   — )        .        .<br>
<br>
    ( )   .   ,         .<br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1ポイントを格納するためのスペースのコストは非常に大きくなります。</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スペース番号</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多次元キーに基づいて、通常のBツリーに書き込むための値を計算する機能を備えた以前の据え置きバージョンを検討する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなインデックスの構成は明白であり、インデックス自体にはBツリーのすべての利点があります。</font><font style="vertical-align: inherit;">唯一の問題は、このインデックスを効果的な検索に使用できるかどうかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような機能は非常に多くあり、その中には少数の「良い」、多数の「悪い」、そして膨大な数の「ひどい」が存在すると想定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ひどい関数を見つけるのは難しくありません。キーを文字列にシリアル化し、そこからMD5を検討して、目的に完全に役立たない値を取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、どのように善にアプローチするのですか？</font><font style="vertical-align: inherit;">有用なインデックスはデータの「局所性」を提供すると既に述べられています-空間内で近接し、ディスクに保存されたときに互いに近接していることが多い点。</font><font style="vertical-align: inherit;">これは、目的の関数に適用される場合、空間的に近いポイントに対して近い値を与えることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インデックスに登録されると、計算された値が値の順に「物理」ページに表示されます。</font><font style="vertical-align: inherit;">「物理的感覚」の観点からは、検索範囲はできるだけ少ない物理インデックスページに影響を与える必要があります。</font><font style="vertical-align: inherit;">一般的に明らかなこと。</font><font style="vertical-align: inherit;">この観点から、データを「引き出す」番号付け曲線は「悪い」ものです。</font><font style="vertical-align: inherit;">そして、「ボールで混乱する」-「良い」に近いもの。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純な番号付け</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1次元空間のロジックにとどまったまま、セグメントを正方形（ハイパーキューブ）に押し込もうとする試み。</font><font style="vertical-align: inherit;">粉々に切り、正方形をこれらの粉で満たします。</font><font style="vertical-align: inherit;">これは、</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m6/1z/fp/m61zfp6xf6wfzjkl2617fu1m6-m.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図4の水平走査、</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/b9/9p/hc/b99phcgowrxhdvtinm--p4anow0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図5のインターレース</font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">走査、</font></i><i><font style="vertical-align: inherit;">図</font></i></font><br>
<br>
<img src="https://habrastorage.org/webt/ym/vh/e-/ymvhe-a64v_evksgfmdyxheuvuw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6のスパイラル、</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
または...多くのオプションが考えられますが、すべて2つの欠点があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あいまいさ、たとえば：らせんが反時計回りではなく時計回りに丸まっている理由、または水平方向のスキャンが最初にXに沿って行われ、次にYに沿って行われる理由</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このような方法の使用を多次元のインデックス作成に効果のないものにする長い直線部分の存在（大きなページの周囲）</font></font></li>
</ol> <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接アクセス機能</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「素朴な」メソッドの主な主張が非常に長いページを生成することである場合は、「正しい」ページを自分で生成してみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアは単純です-スペースの外部パーティションをブロックに分け、各ブロックに識別子を割り当てます。これが空間インデックスのキーになります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X＆Y座標を16ビットにします（明確にするため）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ1024X1024の正方形のブロックでスペースをカバーします</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">座標を粗くし、10ビット右にシフト</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、ページ識別子を取得し、X＆Yからビットを接着します。</font><font style="vertical-align: inherit;">識別子の下位6桁はXからの最古、次の6桁はYからの最古です</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロックがラインスキャンを形成していることが簡単にわかるので、検索範囲のデータを見つけるには、この範囲が置かれたブロックの各行のインデックスで検索/読み取りを行う必要があります。</font><font style="vertical-align: inherit;">一般に、この方法は優れていますが、いくつかの欠点があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスを作成するときは、最適なブロックサイズを選択する必要があります。これは完全に自明ではありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロックが通常のクエリよりも大幅に大きい場合、検索は非効率になります。</font><font style="vertical-align: inherit;">読み取りとフィルタリング（後処理）が多すぎる</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロックが一般的なクエリよりも大幅に小さい場合、検索は非効率になります。</font><font style="vertical-align: inherit;">行ごとに多くのクエリを実行する必要があります</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロックのデータが平均して多すぎる、または少なすぎる場合、検索は無効になります</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データがクラスター化されている場合（例：マップ上の自宅）、検索はどこでも効果的ではありません</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データセットが大きくなると、ブロックサイズが最適でなくなったことがわかる場合があります。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
部分的には、これらの問題はマルチレベルのブロックを構築することで解決されます。</font><font style="vertical-align: inherit;">同じ例の場合：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それでも1024X1024ブロックが必要</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、今でもサイズ8X8の下位レベルのトップレベルブロックがあります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーは次のように配置されます（最下位から最上位まで）：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3ビット-ビット10 ... 12 X座標</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3ビット-ビット10 ... 12 Y座標</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3ビット-ビット13 ... 15 X座標</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3ビット-ビット13。 ..15 Y座標</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/az/y5/h6/azy5h6jt0wtephbmp96lcsbs_rm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図7低レベルのブロックは高レベルのブロックを形成します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
大規模なエクステントの場合、大量の小さなブロックを読み取る必要はありませんが、これは高レベルのブロックを犠牲にして行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深いことに、座標を粗くするのではなく、同じ方法で座標をキーに押し込むことが可能でした。この場合、ポストフィルタリングはより安価になりますインデックスを読み取るときに発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
空間</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GRIDインデックス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、MS SQL</font></a><font style="vertical-align: inherit;">でも</font><font style="vertical-align: inherit;">同様の方法</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">配置さ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">れ</font></a><font style="vertical-align: inherit;">、最大4つのブロックレベルが許可されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dn/kx/r_/dnkxr_kdijxhpjpggh3sgvoh2lm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図8 GRIDインデックス</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
直接インデックス付けのもう1つの興味深い方法は、空間の外部分割に四分木を使用することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
四分木は、オブジェクトの密度に適応できるという点で便利です。ノードがオーバーフローすると分割されます。その結果、オブジェクトの密度が高い場合、ブロックは小さくなり、逆も同様です。これにより、空のインデックス呼び出しの数が減少します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確かに、四分木はその場で再構築するのに不便な構造であり、時々これを行うことは有利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
楽しいことから、クアッドツリーを再構築する場合、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">モートンコード</font></a><font style="vertical-align: inherit;">によってブロックが識別されていれば、インデックスを再構築する必要はありません。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトはそれを使用してエンコードされます。</font><font style="vertical-align: inherit;">ポイントは、ポイントの座標がモートンコードでエンコードされている場合、ページ識別子はそのコードのプレフィックスです。</font><font style="vertical-align: inherit;">ページデータを検索するとき、[prefix] 00 ... 00B〜[prefix] 11 ... 11Bの範囲にあるすべてのキーが選択されます。ページが分割されている場合、その子孫のプレフィックスのみが長くなっていることを意味します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自己相似機能</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自己相似関数について言及するときに最初に頭に浮かぶのは、「曲線のスイープ」です。 「顕著な曲線は連続的なマッピングであり、そのドメインは単位セグメント[0、1]であり、ドメインはユークリッド（厳密には、トポロジー）空間です。」例は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ペアノ曲線です。図</font></font></a><br>
<br>
<img src="https://habrastorage.org/webt/if/1t/yo/if1tyoie_5uobqmnznsudpfnoau.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9 </font></font></i><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ペアノ曲線の</font></a><i><font style="vertical-align: inherit;">最初の反復。</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
左下隅は定義領域の始まり（そして関数の値はゼロ）、右上隅は終わり（そして1）で、1ステップ移動するたびに1 / （N * N）を値に変換します（ただし、Nはもちろん3の累乗です）。その結果、右上隅の値は1に達します。各ステップで1を追加すると、このような関数は単に正方格子に順番に番号を付けるだけであり、これが目的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのスイープ曲線は自己相似です。この場合、シンプレックスは3x3の正方形です。反復ごとに、シンプレックスの各ポイントが同じシンプレックスに変わり、連続性を確保するには、マッピング（フリップ）に頼る必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自己相似性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-私たちにとって非常に重要な品質。検索の対数値に希望を与えます。たとえば、3x3シンプレックスの場合、その後の詳細の反復によって9つの基本正方形のそれぞれの中で生成されるすべての数値は、同じ範囲内になります。数が最初から進んだ道だからです。それら。エクステントを9つの部分に分割すると、それぞれの内容を1つのインデックストラバースで取得できます。そして、再帰的に、それぞれの正方形の9つのサブ正方形のそれぞれは、インデックスに対する単一のクエリで取得できます（ただし、範囲は狭くなります）。そのため、検索範囲を少数の正方形のサブクエリに分解し、全体として、またはフィルタリングして（周囲で）読み取ることができます。図9は、検索範囲を緑色で示し、赤い線でサブクエリに分割しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、自己相似性が自動的に番号付け曲線を索引付けの目的に適したものにするわけではありません。 </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲線は正方形のグリッドを埋める必要があります。</font><font style="vertical-align: inherit;">正方格子のノードの値にインデックスを付けます。毎回、たとえば三角など、格子上で適切なノードを探したくありません。</font><font style="vertical-align: inherit;">少なくとも丸めの問題を回避するために。</font><font style="vertical-align: inherit;">ここでは、たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このような（図10）</font></font></a><br>
<br>
<img src="https://habrastorage.org/webt/86/7s/w1/867sw16ik5sqwl5syykidgylzuw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図10の三元湖のコカー</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
曲線は適していません。</font><font style="vertical-align: inherit;">ただし、表面を完全に「ブリッジ」します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲線は隙間なくスペースを満たす必要があります（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラクタル次元</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D = 2）。</font><font style="vertical-align: inherit;">ここ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（図11）：</font></font><br>
<img src="https://habrastorage.org/webt/kt/pi/ag/ktpiaglmp2_ylugv2cosyoyefsy.gif"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図11匿名のフラクタル曲線</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
も適切で</font><i><font style="vertical-align: inherit;">は</font></i><font style="vertical-align: inherit;">ありません。</font></font><br>
</li>
<li>   (,     )    .   ,          ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a><br>
<br>
<img src="https://habrastorage.org/webt/83/p3/ck/83p3ckw6mejy8prdspy7wklo87m.png"><br>
<i>.12  </i><br>
<br>
,     ( ), “<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   </a>”<br>
<br>
<img src="https://habrastorage.org/webt/ja/64/2v/ja642v4mwxfgneoknpnejnwwymc.png"><br>
<i>. 13  ,       85° </i></li>
<li>      ,     (   ).         . :       ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>)<br>
<br>
<img src="https://habrastorage.org/webt/my/na/py/mynapy6g0pimgnlttggkw6tkjym.png"><br>
<i>. 14 “A Plane Filling Curve for the Year 2017”</i><br>
<br>
        ,    (  )       .<br>
     , ,   ,        . </li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等方</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性も重要な特性です。番号付け関数は、より高い次元に容易に一般化できる必要があることが理解されます。また、N次元の立方体の場合、次元（N-1）へのN個の投影がすべて同じであるとよいでしょう。これは、等方性空間を使用しているという事実に基づいており、異なる軸が関数で異なるように使用されていると、奇妙になります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zp/e8/th/zpe8thfxsdipyiwe5iwwpwo2jfk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 15 3x3x3ペアノ曲線の3次元シンプレックス等</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
方性は厳密な要件ではありませんが、番号付け曲線の品質の重要な指標です。</font><b><font style="vertical-align: inherit;">継続性</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
について</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記では、目的に適さない連続番号付け関数の例を見ました。</font><font style="vertical-align: inherit;">一方、ブロックを使用した非常に不連続なラインスキャン機能は、これには最適です（いくつか制限があります）。</font><font style="vertical-align: inherit;">それだけでなく、連続インターレーススキャンに基づいてブロックインデックスを作成しても、パフォーマンスの点では何も変わりません。</font><font style="vertical-align: inherit;">ブロック全体が読み取られる場合、オブジェクトが受信される順序に違いはないためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自己相似曲線の場合も同様です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ページサイズ、ディスクページ上のすべてのオブジェクトの範囲領域を呼び出しましょう</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特徴的なサイズは平均ページ領域です</font></font></li>
<li>   (   )          ,         .      ,    .   —         .      .</li>
<li>   —   ,        ..            .<br>
</li>
<li>       ,       .   ,      ,          .  ,     ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a> —  ()     3...10%      () Z-.<br>
<br>
  —   ,         . </li>
</ul><br>
<h4></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以上のことから、多次元インデックス作成の目的で、正方形（超立方）シンプレックスのみが（格子の十分な詳細のために）必要な回数だけ再帰的に適用されることになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、正方格子をブリッジする他の自己相似方法がありますが、そのような変換を行うための計算的に安価な方法はありません。おそらくそのような数値のトリックが存在しますが、それらは作者には知られていません。さらに、</font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正方形のシンプレックスは、座標の1つに沿ったカットによって検索範囲をサブクエリに効果的に分割することを可能にし</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シンプレックス間の境界が壊れているため、これは不可能</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンプレックスが長方形ではなく正方形であるのはなぜですか？等方性のため。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンプレックス（バイパス）内の適切なサイズと番号付けを選択する必要があります。</font><b><font style="vertical-align: inherit;">シンプレックス</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を選択するに</font><b><font style="vertical-align: inherit;">は、</font></b><font style="vertical-align: inherit;">それが何に影響するかを理解する必要があります。検索中に作成する必要がある生成されたサブクエリの数。たとえば、ペアノ曲線のシンプレックス3X3は、最初はXで、次にそれぞれがYで3つの部分に、連続した数の間隔を持つ3つのサブクエリにカットされます。その結果、再帰の次のステージに戻ります。同様の（インターレースされた）シンプレックス5X5がある場合、5つの部分にカットする必要があります。または不平等な不均等な部分（例：2 + 3）への分割。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、いくつかの方法で検索ツリーの1つを思い出させます-もちろん、5進数と7進数のツリーを使用できますが、実際には2進数のみが使用されます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トリニティツリー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレフィックスで検索するための独自の狭いニッチがあります。そして、これは正確に三分木として理解されているものではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは効率によって説明されます。三項ノードでは、子孫を選択するには、2つの比較を行う必要があります。バイナリツリーでは、これは4つのオプションからの選択に対応します。木の深さがさらに短くても、比較回数の増加による生産性の低下を妨げることはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、単に3&gt; 2であるために3X3が2X2よりも効果的である場合、4X4は3X3より効果的であり、8X8は5X5より効果的です。 2X2のいくつかの反復によって形成される2の適切な累乗を常に見つけることができます... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、</font><b><font style="vertical-align: inherit;">シンプレックスバイパスの</font></b><font style="vertical-align: inherit;">影響を受けるもの</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？まず、検索によって生成されたサブクエリの数。なぜならシンプレックスを使用すると、連続した数の間隔で自分自身を細かく切ることができる場合に適しています。ここではPeano 3X3が許可されているため、1回の反復で3つの部分に分割されます。また、チェスナイトを備えた8x8シンプレックスを使用する場合（図16）、唯一のオプションは64要素をすぐに持つことです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/l7/cf/dc/l7cfdcocdq3oe-xal_wbvc34t74.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 16 8x8シンプレックスを回避するためのオプションの1つしたがっ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
て、最適なシンプレックスは2x2であることがわかったので、それにはどのオプションが存在するかを検討する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ev/q3/b2/evq3b277yrimcisco3m9iqcksgk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 17 2x2シンプレックスを回避するためのオプション</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
対称的には、「Z」、「オメガ」、「アルファ」と呼ばれる3つの</font><i><font style="vertical-align: inherit;">オプション</font></i><font style="vertical-align: inherit;">があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「アルファ」自体が交差しているため、バイナリ分割には不適切であることはすぐにわかります。すぐに4つの部分にカットする必要があります。または、8次元の場合は256です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異なる次元のスペースに対して単一のアルゴリズムを使用する機能（「アルファ」のような曲線の場合、これは奪われます）は非常に魅力的に見えます。したがって、今後は最初の2つのオプションのみを検討します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ij/pk/p2/ijpkp2sneivmayqaie38y91mylc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。図１８のＺ曲線</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/bo/ar/oq/boaroq7scpwqyvargccwvv6i7li.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 19“ omega”-ヒルベルト曲線</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これらの曲線が近親関係になったら</font><font style="vertical-align: inherit;">、1つのアルゴリズム</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">処理</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">でき</font></a><font style="vertical-align: inherit;">ます。曲線の主な特異性は、サブクエリの分割に限定されます。</font></font><br>
<br>
<ul>
<li>   ,   ,           .<br>
    — <br>
<ul>
<li>            (KMin, KMax)<br>
 </li>
<li>    (    )  KMin, KMax<br>
 </li>
<li>    ,  SMin,   ,  SMax<br>
 </li>
<li>          .    , ,           SMin,    .      . </li>
<li>      ,   ,      ( ).<br>
 </li>
<li> Z-         .     z- —           ,    —  ( ). ,         ,      . </li>
</ul></li>
<li>     </li>
<li>    <ul>
<li>   </li>
<li>      ,  ,  .   ,          </li>
<li>       ,        .      — “ ” &gt;=   “ ”   () ,   “ ”<br>
<br>
<ul>
<li> “ ” &gt;    ,   ,  <br>
 </li>
<li>      ,         ,  <br>
</li>
<li> “ ” &gt;    ,         ,        ,   </li>
<li>  “ ” ==    ,    <br>
 </li>
</ul></li>
<li>  <ul>
<li>    0  1 —     </li>
<li>   0  1 —        </li>
<li>   ,  ,   1,  0.     .</li>
</ul></li>
</ul><br>
</li>
</ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zカーブでは、次のように機能し</font></font><br>
<br>
<img src="https://habrastorage.org/files/8a1/104/6c5/8a11046c5b1749cc8a5dbd0ef1634eba.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。図２０は、</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/zh/kv/n5/zhkvn5nfyem8jdgvdhbromo9oyq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図</font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">１９のＺ曲線のサブクエリである</font></i><i><font style="vertical-align: inherit;">。 21ヒルベルト曲線、開始範囲が最大の場合</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
第一段階はここに示されています-最大範囲から余分なレイヤーを切り取ります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mq/2z/xe/mq2zxetkzhkkpxenqzoxxifkmp8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 22ヒルベルト曲線、検索クエリ領域次に、検索クエリ領域での</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
サブクエリ、見つかったポイント、およびインデックスコールの内訳を示します。これは、ヒルベルト曲線の観点からはまだ非常に失敗した要求です。通常、すべてがはるかに少ない血です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、クエリ統計では、（ほぼ）同じデータに対して、ヒルベルト曲線に基づく2次元インデックスは、平均で5％少ないディスクページを読み取りますが、動作は半分になります。速度低下は、この曲線の計算自体（直接および逆）がはるかに難しいという事実によっても引き起こされます-Zカーブの50と比較して、ヒルベルトの2000プロセッササイクル。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒルベルト曲線をサポートしなくなったため、アルゴリズムを簡略化することは可能ですが、一見すると、そのような減速は正当化されません。一方、これは2次元の場合にすぎません。たとえば、8次元以上の空間では、統計がまったく新しい色で輝きます。この問題はまだ明確化を待っています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：Zカーブは、値を計算するアルゴリズムのため、ビットインターリービングカーブと呼ばれることもあります。各座標の数字は1を介してキー値に含まれるため、非常に技術的です。しかし、結局、個別にではなく、2.3 ... 8 ...個のパックで放電をインターリーブできます。ここで、8ビットを取る場合、32ビットのキーでは、MS SQLから4レベルのGRIDインデックスの類似物を取得します。そして、極端な場合-32ビットの1パック-水平走査アルゴリズム。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなインデックス（もちろん小文字ではありません）は非常に効果的で、一部のデータセットのZカーブよりもさらに効率的です。残念ながら、一般性が失われたためです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：説明されているインデックスは、四分木での作業と非常に似ています。最大範囲はクワッドツリーのルートページで、4つの子孫があります。したがって、このアルゴリズムは「直接アクセス方式」に帰することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
違いは依然として根本的なものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
四分木はどこにも保存されていません。仮想であり、数値そのものに埋め込まれています。木の深さに制限はなく、メインツリーの母集団から子孫の母集団に関する情報を取得します。さらに、メインツリーが1回読み込まれ、最小値から最も古い値に移動します。おかしいですが、Bツリーの物理構造により、空のクエリを回避し、再帰の深さを制限できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、各反復で2つの子孫のみが表示されます-それらから4つのサブクエリを生成でき、その下にデータがない場合は生成できません。 3次元の場合は8つの子孫、8次元の場合は約256です</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。PPPS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：この記事の冒頭で、多次元インデックスを検索するときの二分法について説明しました。対数値を取得するには、いずれかの反復で有限リソース（キー値スペースまたは検索スペース）を分割する必要があります。提示されたアルゴリズムでは、この二分法は崩壊しました-鍵と空間の両方を同時に共有します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「私は両方の庭に住んでおり、木は常に背が高くなっています。」（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPPPS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：Zカーブを呼び出すと、Zオーダーとビットインターリーブ、モートンコード/カーブがあります。また、それはルベーグ曲線としても知られているため、バランスを保つために、著者は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘンリーレオンルベーグを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記念して記事にタイトルを付けました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPPPPS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：タイトルの図では、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fedchenko Glacier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、美しいだけでなく、十分な空虚があります。</font><font style="vertical-align: inherit;">実際、作者は、さまざまなアイデアや方法がスムーズに相互に流れ込み、徐々に1つのアルゴリズムに融合することに感銘を受けました。</font><font style="vertical-align: inherit;">集水域を構成する多くの小さな水源が単一の流出を形成するように。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja464041/index.html">最高の戦闘機パイロットがしばしば大きな問題に直面する理由</a></li>
<li><a href="../ja464043/index.html">Ethernet-CANコンバーターの歴史</a></li>
<li><a href="../ja464045/index.html">1997年のほぼリアルタイムのレーストレイル</a></li>
<li><a href="../ja464053/index.html">注意：トラックの選択と回転アルゴリズム</a></li>
<li><a href="../ja464055/index.html">Xiaomi Mi Bandが年間に収集したデータを調査します</a></li>
<li><a href="../ja464063/index.html">2019年にケーブルを切断する</a></li>
<li><a href="../ja464071/index.html">革命か痛みか？Yandex React Hooksレポート</a></li>
<li><a href="../ja464075/index.html">Cの紹介 前世紀からのメッセージ</a></li>
<li><a href="../ja464077/index.html">いいえ、50 km / sのデルタveは必要ありません。付加技術が必要（パート1）</a></li>
<li><a href="../ja464079/index.html">ミラクルテクノロジーなしで水平離着陸宇宙船を作る方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>