<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÜòÔ∏è üòå üë®‚Äçüë©‚Äçüë¶‚Äçüë¶ Estructuras de datos: una lista que puede hacer todo * üîå ü§∏üèæ üë®üèø‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Por todo, me refiero a la ejecuci√≥n relativamente r√°pida de operaciones en un solo elemento de una matriz. 
 
 Las estructuras de datos que implemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Estructuras de datos: una lista que puede hacer todo *</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488778/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Por todo, me refiero a la ejecuci√≥n relativamente r√°pida de operaciones en un solo elemento de una matriz. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las estructuras de datos que implementan la lista est√°n completas. </font><font style="vertical-align: inherit;">Cada uno tiene sus propias ventajas y desventajas. </font><font style="vertical-align: inherit;">Por ejemplo, en el mundo Java, dependiendo de las operaciones necesarias, puede usar:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add (obj), get (obj), set (index, obj): un conjunto b√°sico de casi todas las listas, por ejemplo, ArrayList. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add (index, obj): estructuras en forma de √°rbol, por ejemplo, TreeList de apache common-collections. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eliminar (√≠ndice): igual que el anterior. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene (obj), indexOf (obj): puede usar un mont√≥n de ArrayList y HashMap. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remove (obj): ... me resulta dif√≠cil responder. </font><font style="vertical-align: inherit;">En algunos casos, puede arregl√°rselas con LinkedHashSet. </font><font style="vertical-align: inherit;">Se resuelve trivialmente en presencia de los dos puntos anteriores, pero ¬øqu√© estructuras pueden ambos r√°pidamente?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando necesitaba una estructura con r√°pida adici√≥n (obj), get (index), remove (index) e indexOf (obj), google no dio una respuesta. No encontr√© ning√∫n c√≥digo de ejemplos o descripciones de tales estructuras. Tal vez no estaba buscando all√≠, tuve que inventarlo yo mismo. Pero si alguien deja caer el enlace en los comentarios, lo agradecer√© enormemente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quiz√°s alguien se dio cuenta de que puede tomar una TreeList, que puede insertar / eliminar r√°pidamente elementos en el medio de la lista y agregar un HashMap del objeto al √≠ndice en la TreeList para la ejecuci√≥n r√°pida de indexOf (obj). Y ser√° una decisi√≥n simple, elegante, pero incorrecta. Despu√©s de todo, cuando se agrega al medio o se elimina del medio, ser√° necesario volver a calcular los √≠ndices, en promedio, para la mitad de los elementos. Esto degradar√° el rendimiento a O (n).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n hablar√© sobre una estructura de datos que puede hacer todo lo anterior. Que realiza cualquier operaci√≥n en un elemento en tiempo O (log (n)). Bueno, casi, porque el logaritmo se realiza en el caso en que todos los objetos de la lista son diferentes. Si la lista contiene los mismos objetos, entonces es posible reducir el rendimiento hasta O (log (n) ^ 2).</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Te advertir√© de inmediato que no pintar√© el c√≥digo aqu√≠. </font><font style="vertical-align: inherit;">Puede ser bastante complicado para el art√≠culo. </font><font style="vertical-align: inherit;">Pero lo es, escrito en Java. </font><font style="vertical-align: inherit;">Basado en la clase TreeList de apache common-collections. </font><font style="vertical-align: inherit;">La solicitud de extracci√≥n ya existe, pero al momento de la redacci√≥n, el art√≠culo a√∫n no se ha vertido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, no describir√© algoritmos bien conocidos. </font><font style="vertical-align: inherit;">Por ejemplo, algoritmos de equilibrio de √°rboles. </font><font style="vertical-align: inherit;">Para la mayor√≠a, puede ser suficiente dar por sentado el hecho de que el √°rbol puede mantenerse equilibrado. </font><font style="vertical-align: inherit;">Esto no afecta la comprensi√≥n de la idea general. </font><font style="vertical-align: inherit;">Aquellos que quieran saber m√°s pueden encontrar f√°cilmente informaci√≥n. </font><font style="vertical-align: inherit;">Pero le contar√© muy brevemente sobre algunas cosas b√°sicas, porque sin el conocimiento de los conceptos b√°sicos, muchos elementos clave no se pueden entender. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los enlaces estar√°n al final.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por qu√© es necesario</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, no es tan f√°cil encontrar situaciones en las que todo se necesita directamente de la lista. </font><font style="vertical-align: inherit;">Es poco probable que se trate de alg√∫n tipo de estructura s√∫per necesaria, de lo contrario, todos lo sabr√≠an. </font><font style="vertical-align: inherit;">Sin embargo, se pueden dar algunos ejemplos donde dicha lista podr√≠a ser √∫til. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reconozco que muchos de los ejemplos son descabellados. </font><font style="vertical-align: inherit;">Todo o casi todo se puede resolver de otra manera.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Almacenamiento en cach√© y compresi√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi tarea inicial, por lo que comenc√© a investigar el tema. </font><font style="vertical-align: inherit;">Jug√≥ con la compresi√≥n de datos espec√≠ficos y necesitaba una lista para el cach√© de objetos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea es esta: cuando procesamos otro objeto, lo buscamos en la lista. </font><font style="vertical-align: inherit;">Si no se encuentra, guarde el objeto y agr√©guelo al principio de la lista. </font><font style="vertical-align: inherit;">Si se encuentra, tomamos su √≠ndice en la lista y, en lugar del objeto, guardamos solo su √≠ndice, despu√©s de lo cual movemos el objeto a la parte superior de la lista. </font><font style="vertical-align: inherit;">Por lo tanto, los objetos que ocurren a menudo recibir√°n √≠ndices peque√±os, y los objetos que ocurren solo una vez eventualmente se mover√°n al final de la lista y se eliminar√°n.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Giro</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si en lugar de la cola FIFO habitual, para algunas tareas, se utiliza una estructura similar, se pueden realizar las siguientes operaciones:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Responda la pregunta: cu√°ntas tareas hay en la cola antes de esta tarea. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminar tareas de la cola. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es como en un supermercado. </font><font style="vertical-align: inherit;">Si viniste por una barra de chocolate, pero ves que la l√≠nea se mueve lentamente, ¬øtal vez la barra de chocolate no es tan necesaria? </font><font style="vertical-align: inherit;">:)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabla de puntaje alto</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que queremos almacenar el tiempo durante el cual los jugadores completan un nivel en un juego. </font><font style="vertical-align: inherit;">Hay muchos jugadores y todos compiten, tratando de mostrar el tiempo m√≠nimo. </font><font style="vertical-align: inherit;">Los datos del jugador pueden colocarse en una matriz y ordenarse por tiempo. </font><font style="vertical-align: inherit;">Usando esta estructura, puedes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mueve a los jugadores m√°s arriba en la lista si muestran mejores resultados que antes. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminar jugadores de la lista, por ejemplo, en el caso de una prohibici√≥n de hacer trampa. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muestra a cada jugador d√≥nde est√°. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mostrar la tabla de registros p√°gina por p√°gina. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mostrar una tabla dispersa en lugares, por ejemplo, tiempo 1, 2, 3, 5, 10, 20, 50, 100, 1000, 10000 lugares. </font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estructura de datos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La estructura se basa en un √°rbol con una clave impl√≠cita. </font><font style="vertical-align: inherit;">En este enfoque, por ejemplo, se basa TreeList en apache common-collections. </font><font style="vertical-align: inherit;">Para seguir adelante, debe comprender c√≥mo funciona esta estructura.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Årbol de claves impl√≠citas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un √°rbol consta de nodos (nodos). </font><font style="vertical-align: inherit;">Cada nodo contiene un enlace a un objeto que se almacena en el nodo y 2 enlaces a otros nodos: izquierdo y derecho. </font><font style="vertical-align: inherit;">El nodo superior se llama nodo ra√≠z. </font><font style="vertical-align: inherit;">En el caso m√°s simple, el nodo se ve as√≠:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  obj: T<font></font>
  left: Node&lt;T&gt;<font></font>
  right: Node&lt;T&gt;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el √°rbol binario cl√°sico para cada nodo en el sub√°rbol izquierdo, todos los objetos son m√°s peque√±os que en el nodo actual, y en el derecho - grande. </font><font style="vertical-align: inherit;">Por ejemplo:</font></font><br>
<br>
<pre><code class="plaintext hljs">                             [ element: 25 ]<font></font>
                           /                 \<font></font>
                          /                   \<font></font>
          [ element: 14 ]                       [ element: 45 ]<font></font>
           /          \                           /          \<font></font>
          /            \                         /            \<font></font>
[ element: 10 ]    [ element: 22 ]     [ element: 27 ]    [ element: 90 ]<font></font>
                    /          \                            /<font></font>
                   /            \                          /<font></font>
            [ element: 17 ] [ element: 23 ]         [ element: 80 ] </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero para nuestro prop√≥sito, tal √°rbol no es adecuado. No necesitamos almacenar objetos ordenados, pero debemos tener acceso a ellos por √≠ndice, como en una matriz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo puedo poner una matriz en un √°rbol? Seleccionemos un elemento con √≠ndice i desde el centro de la matriz. Coloque el elemento i-√©simo de la matriz en el nodo ra√≠z. 2 sub√°rboles salen del nodo ra√≠z. En el sub√°rbol izquierdo colocamos la mitad de la matriz con √≠ndice &lt;i, y en el derecho con √≠ndice&gt; i. ¬øC√≥mo hacerlo? De la misma manera: seleccionamos un elemento del medio en un subconjunto, colocamos este elemento en un nodo, obtenemos 2 subconjuntos m√°s peque√±os. Y as√≠ hasta que coloquemos todos los elementos de la matriz en los nodos del √°rbol. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, una matriz con los elementos [‚Äúq‚Äù, ‚Äúw‚Äù, ‚Äúe‚Äù, ‚Äúr‚Äù, ‚Äút‚Äù, ‚Äúy‚Äù, ‚Äúu‚Äù] podr√≠a verse as√≠:</font></font><br>
<br>
<pre><code class="plaintext hljs">                            [el: r,  size: 7]<font></font>
                           /        :        \<font></font>
                          /         :         \<font></font>
         [el: w, size: 3]           :           [el: y, size: 3]<font></font>
           /     :    \             :             /    :     \<font></font>
          /      :     \            :            /     :      \<font></font>
[el: q, size: 1] : [el: e, size: 1] : [el: t, size: 1] : [el: u, size: 1]<font></font>
        :        :         :        :         :        :         :<font></font>
        :        :         :        :         :        :         :<font></font>
       [q]      [w]       [e]      [r]       [t]      [y]       [u]<font></font>
<font></font>
Index:  0        1         2        3         4        5         6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El elemento del medio en la matriz "r", lo colocamos en el nodo ra√≠z. Dos submatrices ["q", "w", "e"] y ["t", "y", "u"] se colocan en los sub√°rboles izquierdo y derecho. Para esto, los elementos centrales se seleccionan de las submatrices, en nuestro caso son "w" e "y", y caen en los nodos del siguiente nivel. Y as√≠ sucesivamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestro caso, el √°rbol est√° equilibrado, la profundidad de todos los sub√°rboles es la misma. Pero esto no tiene por qu√© ser as√≠. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la imagen de arriba, cada nodo, adem√°s del elemento y los enlaces a los nodos izquierdo y derecho, contiene el n√∫mero de elementos de todo el sub√°rbol. Esta informaci√≥n debe actualizarse correctamente cuando cambie el √°rbol. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos c√≥mo encontrar, por ejemplo, un elemento con √≠ndice = 4 en dicho √°rbol.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comenzamos el rastreo desde el nodo ra√≠z (ra√≠z, en nuestro caso con el elemento "r"). Tenemos 3 opciones: ya estamos en el nodo derecho, el nodo derecho a la izquierda, el nodo derecho a la derecha. Para comprender d√≥nde buscar el elemento deseado, debe comparar el tama√±o del sub√°rbol izquierdo (en nuestro caso left.size = 3) y el √≠ndice actual (en nuestro caso 4). Si estos 2 n√∫meros son iguales, entonces encontramos el nodo necesario y el elemento deseado en √©l. Si el tama√±o del sub√°rbol izquierdo es mayor, entonces el nodo requerido en el sub√°rbol izquierdo. Si es menor, entonces debe buscar en el sub√°rbol correcto, pero debe reducir el √≠ndice deseado: index = index - left.size - 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que en nuestro caso left.size &lt;index, estamos buscando en el sub√°rbol derecho el elemento con el nuevo √≠ndice 4 - 3 - 1 = 0. Mover al nodo con el elemento "y".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego hacemos lo mismo que hicimos en el nodo ra√≠z. Compare left.size e index. Como 1&gt; 0, miramos en el sub√°rbol izquierdo, nos movemos al nodo con el elemento "t". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No hay sub√°rbol izquierdo en este nodo, y su tama√±o es 0. index = left.size, lo que significa que encontramos un nodo con √≠ndice 4 y podemos obtener el elemento "t" requerido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En pseudoc√≥digo, se ve m√°s o menos as√≠:</font></font><br>
<br>
<pre><code class="kotlin hljs">function <span class="hljs-keyword">get</span>(node: Node&lt;T&gt;, index: int): T {
  <span class="hljs-keyword">val</span> leftSize: int = (node.left == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : node.left.size;
  <span class="hljs-keyword">if</span> (leftSize == index) {
    <span class="hljs-keyword">return</span> node.obj;<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leftSize &gt; index) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(node.left, index);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(node.right, index ‚Äî leftSize ‚Äî <span class="hljs-number">1</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trat√© de describir el principio clave de c√≥mo poner una matriz en un √°rbol. </font><font style="vertical-align: inherit;">Tal estructura funciona, por supuesto, m√°s lenta que la matriz cl√°sica, para O (log (n)) versus O (1). </font><font style="vertical-align: inherit;">Pero tiene una ventaja importante: agregar un elemento al medio o eliminarlo del medio tambi√©n funciona para O (log (n)) versus O (n) para la matriz. </font><font style="vertical-align: inherit;">Por supuesto, siempre que el √°rbol est√© m√°s o menos equilibrado. </font><font style="vertical-align: inherit;">Existen muchos algoritmos para mantener un √°rbol de forma casi equilibrada. </font><font style="vertical-align: inherit;">Por ejemplo, √°rbol rojo-negro, √°rbol AVL, √°rbol cartesiano. </font><font style="vertical-align: inherit;">No escribir√© los detalles del equilibrio del √°rbol, cualquier algoritmo es adecuado para nosotros. </font><font style="vertical-align: inherit;">Supongamos que el √°rbol est√° equilibrado en promedio y su profundidad m√°xima no es muy diferente de la m√≠nima.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ligera optimizaci√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El enfoque descrito anteriormente, con la comprobaci√≥n del tama√±o del √°rbol a la izquierda, es conveniente para la percepci√≥n, pero se puede hacer un poco m√°s eficientemente. Para no mirar cada vez el sub√°rbol izquierdo, en lugar del tama√±o del √°rbol, se puede almacenar en el nodo su posici√≥n en relaci√≥n con la posici√≥n de su nodo padre. El nodo ra√≠z almacena una posici√≥n absoluta que coincide con el tama√±o del sub√°rbol izquierdo.</font></font><br>
<br>
<pre><code class="plaintext hljs">                             [el: r, pos: 3]<font></font>
                           /        :        \<font></font>
                          /         :         \<font></font>
         [el: w, pos: -2]           :           [el: y, pos: +2]<font></font>
           /     :    \             :             /    :     \<font></font>
          /      :     \            :            /     :      \<font></font>
[el: q, pos: -1] : [el: e, pos: +1] : [el: t, pos: -1] : [el: u, pos: +1]<font></font>
        :        :         :        :         :        :         :<font></font>
        :        :         :        :         :        :         :<font></font>
       [q]      [w]       [e]      [r]       [t]      [y]       [u]<font></font>
<font></font>
Index:  0        1         2        3         4        5         6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, el nodo ra√≠z "r" tiene una posici√≥n de 3. El nodo "w" tiene una posici√≥n de -2 en relaci√≥n con el nodo principal o la posici√≥n absoluta de 3 + (-2) = 1. Del mismo modo, puede bajar un nivel m√°s, por ejemplo, el nodo "e" tiene una posici√≥n de 3 + (-2) + (+1) = 2. Es decir, </font><font style="vertical-align: inherit;">El √≠ndice de nodo es la suma de las posiciones desde la ra√≠z del √°rbol hasta este nodo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta optimizaci√≥n, adem√°s de una b√∫squeda m√°s r√°pida de un elemento en la lista, proporcionar√° una b√∫squeda m√°s r√°pida y f√°cil del √≠ndice en el nodo. </font><font style="vertical-align: inherit;">Pero, por supuesto, actualizar la posici√≥n correctamente al cambiar el √°rbol se ha vuelto un poco m√°s dif√≠cil.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregar indexaci√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, en el √°rbol podemos tomar un elemento por √≠ndice, cambiar su valor, agregar elementos al medio y eliminar. Esencialmente, solo necesitamos agregar una b√∫squeda r√°pida de √≠ndice por valor, indexOf (obj). Luego contiene (obj) y eliminar (obj) se resolver√° trivialmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero primero, simplifiquemos un poco la tarea. Hagamos una estructura que almacene solo elementos √∫nicos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para buscar r√°pidamente algo, generalmente usan una tabla. En el mundo de Java, las tablas se llaman Map; tiene 2 implementaciones principales: HashMap y TreeMap. La clave de la tabla ser√° un enlace al objeto, y el valor es un enlace a su nodo:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexedTreeListSet</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  root: Node&lt;T&gt;<font></font>
  indexMap: Map&lt;T, Node&lt;T&gt;&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquellos. la estructura consta de dos partes: el √°rbol de la lista en s√≠ y la tabla con enlaces a objetos y nodos de este √°rbol. Al actualizar el √°rbol, la tabla tambi√©n debe actualizarse. No describir√© el proceso en detalle. Intuitivamente, deber√≠a ser comprensible: agregue un nodo - p√≥ngalo en la tabla, elimine el nodo - elim√≠nelo de la tabla. En la pr√°ctica, hay matices con el equilibrio del √°rbol: el algoritmo debe cambiar los enlaces entre nodos y no mover objetos entre nodos. De lo contrario, tendr√° que hacer muchas actualizaciones en la tabla y el rendimiento disminuir√°. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, asumiremos que podemos encontrar r√°pidamente el nodo por el elemento que contiene. ¬øY qu√©? Necesitamos encontrar su √≠ndice, pero esto a√∫n no se puede hacer. Pero podemos complicar la clase de nodo para que contenga no solo enlaces a los nodos izquierdo y derecho, sino tambi√©n a su padre:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  obj: T<font></font>
  left: Node&lt;T&gt;<font></font>
  right: Node&lt;T&gt;<font></font>
  parent: Node&lt;T&gt;<font></font>
  pos: int<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, actualizar el √°rbol es un poco m√°s complicado, porque ahora necesitamos actualizar cuidadosamente el enlace al padre. Pero ahora, conociendo el nodo, podemos subir el √°rbol y calcular el √≠ndice de cualquier nodo. Si utilizamos la optimizaci√≥n del cap√≠tulo anterior, entonces solo tenemos que calcular la suma de las posiciones desde el nodo actual hasta la ra√≠z. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para una lista que contiene elementos √∫nicos, el problema puede considerarse resuelto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es cierto que tenemos un peque√±o problema. </font><font style="vertical-align: inherit;">Supongamos que llamamos set (index, obj). </font><font style="vertical-align: inherit;">Podemos reemplazar f√°cilmente un elemento en un nodo con otro, pero solo si todav√≠a no hay un elemento nuevo en la lista. </font><font style="vertical-align: inherit;">Y si es as√≠, ¬øqu√© debo hacer? </font><font style="vertical-align: inherit;">¬øEliminar el elemento sobrante de la posici√≥n anterior y colocar uno nuevo? </font><font style="vertical-align: inherit;">O viceversa, ¬øprimero agregar y luego eliminar? </font><font style="vertical-align: inherit;">El resultado puede ser diferente. </font><font style="vertical-align: inherit;">Y no puede hacer nada en absoluto o lanzar una excepci√≥n. </font><font style="vertical-align: inherit;">No hay una solucion perfecta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ordenar por m√©todos est√°ndar, tal lista, muy probablemente, tampoco funcionar√°. </font><font style="vertical-align: inherit;">Despu√©s de todo, el algoritmo de clasificaci√≥n no sabr√° acerca de la necesidad de unicidad de los objetos y crear√° duplicados al mover elementos en la lista.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminamos la unicidad</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, complicando a√∫n m√°s las cosas, conservemos los mismos objetos. Obviamente, necesitas hacer algo con la mesa. La primera idea para almacenar una lista de nodos en ella no parece muy buena: con un aumento en la longitud de la lista, el rendimiento disminuir√°. Hasta O (n) si todos los elementos de la lista son iguales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, intentemos almacenar un √°rbol ordenado de nodos en una tabla en lugar de una lista. Ordenado por posici√≥n en la lista.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexedTreeList</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  root: Node&lt;T&gt;<font></font>
  indexMap: Map&lt;T, TreeSet&lt;Node&lt;T&gt;&gt;&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, la inserci√≥n / eliminaci√≥n a / del TreeSet &lt;Node&gt; de tama√±o m se producir√° durante las comparaciones log (m) de las posiciones de los nodos, y cada comparaci√≥n se producir√° durante el tiempo log (n). La complejidad final de insertar o eliminar en una estructura similar ocurrir√° en O (log (n) * (1 + log (m))), donde n es el n√∫mero total de elementos en la lista ym es el n√∫mero de elementos en la lista igual al insertado / eliminado. En el peor de los casos, cuando todos los elementos son iguales entre s√≠, obtenemos la complejidad O (log (n) ^ 2).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un lector atento probablemente objetar√°: pero ¬øqu√© pasa con la inmutabilidad? </font><font style="vertical-align: inherit;">Despu√©s de todo, ¬øno podemos cambiar los objetos si son claves de tabla? </font><font style="vertical-align: inherit;">En general lo es. </font><font style="vertical-align: inherit;">Sin embargo, para un √°rbol que almacena objetos ordenados en claves, adem√°s de las reglas est√°ndar para las comparaciones, es suficiente preservar la invariante: si a &lt;b, entonces esta propiedad no deber√≠a cambiar con el tiempo. </font><font style="vertical-align: inherit;">Este es solo nuestro caso: si la posici√≥n de un nodo es menor que la posici√≥n de otro nodo, esta propiedad se conservar√° independientemente de cu√°ntos nodos se hayan agregado o eliminado entre ellos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øEs posible hacer que la estructura sea persistente?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Respuesta corta: no, es imposible. </font><font style="vertical-align: inherit;">Debido a la biconconexi√≥n del √°rbol, desde la ra√≠z hasta las hojas y viceversa, tenemos cada nodo del √°rbol conectado a cada uno. </font><font style="vertical-align: inherit;">La persistencia no se puede hacer de esta manera; hay que recrear toda la estructura con cualquier cambio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero entiendo c√≥mo implementar una estructura persistente para los casos en los que no necesitamos insertar elementos en el medio de la lista. </font><font style="vertical-align: inherit;">Puede agregar elementos al principio o al final, y puede eliminarlos del medio. </font><font style="vertical-align: inherit;">Las propiedades restantes son las mismas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si est√° interesado, intentar√© escribir un art√≠culo sobre esta estructura. </font><font style="vertical-align: inherit;">Quiz√°s incluso lo implemente en Java, Kotlin o Scala. </font><font style="vertical-align: inherit;">Pero, lo m√°s probable, no ser√° pronto.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algunas caracter√≠sticas de implementaci√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ quiero describir algunas caracter√≠sticas que tuve que enfrentar. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobre una de las optimizaciones sobre el almacenamiento de la posici√≥n del nodo en la lista, escrib√≠ anteriormente. La fuerza del c√≥digo abierto se manifiesta aqu√≠: tom√© el c√≥digo TreeList listo y no profundic√© en los detalles del √°rbol AVL, los giros de nodos, las actualizaciones de posici√≥n, etc.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra caracter√≠stica heredada de TreeList son los enlaces a sub√°rboles en las hojas de los √°rboles. Cada nodo almacena el valor booleano leftIsPrevious y rightIsNext. Estas variables indican la presencia o ausencia de un sub√°rbol izquierdo / derecho. Si no hay un sub√°rbol, entonces en izquierda / derecha, en lugar de un enlace al sub√°rbol, se almacena un enlace al nodo que corresponde al elemento anterior o siguiente. En nuestro ejemplo, [‚Äúq‚Äù, ‚Äúw‚Äù, ‚Äúe‚Äù, ‚Äúr‚Äù, ‚Äút‚Äù, ‚Äúy‚Äù, ‚Äúu‚Äù] el nodo ‚Äúe‚Äù es frondoso, no tiene sub√°rboles. En consecuencia, leftIsPrevious y rightIsNext son verdaderos, y los puntos left y right apuntan a los nodos "w" y "r", respectivamente. Este enfoque ayuda a recorrer la lista m√°s r√°pido. E interfiere con la programaci√≥n de nuevas caracter√≠sticas :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un poco sobre trabajar con la tabla objeto ‚Üí nodo. Idealmente, debe colocar un elemento en la tabla una vez al agregarlo a la estructura y eliminarlo una vez al eliminarlo de la estructura. En la pr√°ctica, no pude lograr esto. Cuando agrega un elemento, se agrega a la tabla, todo est√° como deber√≠a. Sin embargo, cuando elimina un elemento, el algoritmo de equilibrio a veces mueve elementos entre nodos. El resultado son dos eliminaciones y un registro en la tabla en lugar de una eliminaci√≥n. Esto se puede solucionar si elimina la optimizaci√≥n de leftIsPrevious y rightIsNext. E incluso obtenga una peque√±a ganancia de rendimiento, y no solo durante la eliminaci√≥n. En algunas pruebas, el aumento fue del 10-20%. Pero la velocidad de iteraci√≥n cae significativamente, 1.5-2.5 veces en mis pruebas. Decid√≠ dejar la optimizaci√≥n por ahora.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Java, los principales tipos de tablas son HashMap y TreeMap. Para una tabla, un objeto ‚Üí un nodo usa HashMap de forma predeterminada. Sin embargo, puede usar TreeMap con un comparador espec√≠fico de tareas. En este caso, indexOf (obj) y remove (obj) buscar√°n / eliminar√°n el objeto que sea igual al objeto especificado de acuerdo con el c√≥digo del comparador. Por ejemplo, almacenamos una lista de usuarios, y el comparador compara a los usuarios solo por su nombre. Entonces podemos responder a la pregunta "¬øQu√© posiciones de la lista son usuarios con el nombre 'Napole√≥n?'". O elimine todos los Napoleones de la lista :). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La estructura no admite nulo. Puede arreglarlo, pero no se siente que sea necesario.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cuanto al hecho de que la estructura "lo sabe todo", yo, por supuesto, fui un poco enga√±oso. </font><font style="vertical-align: inherit;">Por supuesto, cuando se trabaja con elementos individuales, todo est√° bien y bajo ciertas condiciones, incluso para el logaritmo. </font><font style="vertical-align: inherit;">Sin embargo, ella no sabe algunas cosas que otras estructuras pueden. </font><font style="vertical-align: inherit;">Por ejemplo, un √°rbol cartesiano con una clave impl√≠cita, hab√≠a art√≠culos sobre √©l en el centro </font><font style="vertical-align: inherit;">No sabe c√≥mo hacer indexOf r√°pidamente, pero sabe c√≥mo hacer una sublista y concatenar dos listas en una para el logaritmo (en promedio, no garantizado), adem√°s puede hacerse persistente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actuaci√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Java, el rendimiento generalmente se mide utilizando el marco jmh. </font><font style="vertical-align: inherit;">Las pruebas se realizaron en el MacBook Pro 2017 con Java11. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compar√© el rendimiento de ArrayList est√°ndar, TreeList de apache common-collections y mis dos clases IndexedTreeList e IndexedTreeListSet en varios escenarios. </font><font style="vertical-align: inherit;">En cada escenario, se realizaron 1000 operaciones del mismo tipo, por lo que el resultado deber√≠a multiplicarse por 1000.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥digo bajo el spoiler</font></font></b><div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-meta">@Fork(1)</span>
<span class="hljs-meta">@Warmup(iterations = 3)</span>
<span class="hljs-meta">@Measurement(iterations = 5)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceCompare</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Class&gt; CLASSES = Stream.of(TreeList.class, IndexedTreeListSet.class, IndexedTreeList.class,<font></font>
            ArrayList.class)<font></font>
            .collect(Collectors.toMap(c -&gt; c.getSimpleName(), c -&gt; c));<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ITERATIONS = <span class="hljs-number">1000</span>;<font></font>
<font></font>
    <span class="hljs-meta">@State(Scope.Benchmark)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plan</span> </span>{<font></font>
<font></font>
        <span class="hljs-meta">@Param({"10", "100", "1000", "10000", "100000", "1000000"/*, "10000000"*/})</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> size;<font></font>
<font></font>
        <span class="hljs-meta">@Param({"ArrayList", "TreeList", "IndexedTreeList", "IndexedTreeListSet"})</span>
        <span class="hljs-keyword">public</span> String className;<font></font>
<font></font>
        <span class="hljs-keyword">private</span> Random random;
        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<font></font>
<font></font>
        <span class="hljs-meta">@Setup</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException </span>{<font></font>
            random = <span class="hljs-keyword">new</span> Random();<font></font>
            list = (List&lt;Integer&gt;) CLASSES.get(className).newInstance();<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<font></font>
                list.add(i);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">indexOfKnown</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value = list.indexOf(random.nextInt(plan.size));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">indexOfUnknown</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value += list.indexOf(random.nextInt());<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addRemoveRandom</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            list.add(random.nextInt(list.size() + <span class="hljs-number">1</span>), random.nextInt());<font></font>
            value += list.remove(random.nextInt(list.size()));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value += list.get(random.nextInt(list.size()));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Timeout(time = 1, timeUnit = TimeUnit.MILLISECONDS)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException </span>{<font></font>
        Options opt = <span class="hljs-keyword">new</span> OptionsBuilder()<font></font>
                .include(PerformanceCompare.class.getSimpleName())<font></font>
                .forks(<span class="hljs-number">1</span>)
<span class="hljs-comment">//                .jvmArgs("-Xms2048m", "-Xmx2048m", "-XX:MaxDirectMemorySize=512M")</span><font></font>
                .build();<font></font>
<font></font>
        <span class="hljs-keyword">new</span> Runner(opt).run();<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para empezar, compar√© la velocidad de obtener un elemento aleatorio de una lista. </font><font style="vertical-align: inherit;">Te advertir√© de inmediato que en esta prueba la sobrecarga es muy significativa. </font><font style="vertical-align: inherit;">Los resultados que se aproximan a 100,000 * 1,000 operaciones por segundo est√°n severamente distorsionados.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtener resultado de la prueba</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.get                       ArrayList       10  thrpt    5  79865.412 ¬± 10145.202  ops/s<font></font>
PerformanceCompare.get                       ArrayList      100  thrpt    5  81862.243 ¬±   983.727  ops/s<font></font>
PerformanceCompare.get                       ArrayList     1000  thrpt    5  81033.507 ¬±  4540.206  ops/s<font></font>
PerformanceCompare.get                       ArrayList    10000  thrpt    5  64096.123 ¬±  1430.361  ops/s<font></font>
PerformanceCompare.get                       ArrayList   100000  thrpt    5  41289.491 ¬± 11286.114  ops/s<font></font>
PerformanceCompare.get                       ArrayList  1000000  thrpt    5   8598.944 ¬±  2048.461  ops/s<font></font>
PerformanceCompare.get                        TreeList       10  thrpt    5  33912.275 ¬±  3754.284  ops/s<font></font>
PerformanceCompare.get                        TreeList      100  thrpt    5  21346.854 ¬±   863.588  ops/s<font></font>
PerformanceCompare.get                        TreeList     1000  thrpt    5  14808.414 ¬±   508.098  ops/s<font></font>
PerformanceCompare.get                        TreeList    10000  thrpt    5   8679.384 ¬±   109.250  ops/s<font></font>
PerformanceCompare.get                        TreeList   100000  thrpt    5   4605.998 ¬±  1028.945  ops/s<font></font>
PerformanceCompare.get                        TreeList  1000000  thrpt    5   2241.381 ¬±   768.147  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList       10  thrpt    5  34054.357 ¬±  3682.829  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList      100  thrpt    5  21934.002 ¬±  2339.947  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList     1000  thrpt    5  14626.691 ¬±   369.893  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList    10000  thrpt    5   7386.863 ¬±   342.150  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList   100000  thrpt    5   4562.126 ¬±   352.772  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList  1000000  thrpt    5   2105.718 ¬±   702.064  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet       10  thrpt    5  33317.503 ¬±  2307.829  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet      100  thrpt    5  21247.440 ¬±  1253.386  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet     1000  thrpt    5  14665.557 ¬±   487.833  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet    10000  thrpt    5   7667.214 ¬±    80.093  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet   100000  thrpt    5   3454.023 ¬±    82.994  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet  1000000  thrpt    5   1768.701 ¬±    35.878  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠, curiosamente, el mayor inter√©s es la ArrayList est√°ndar. Te√≥ricamente, la velocidad de salida debe ser constante y no depender del n√∫mero de elementos. En la pr√°ctica, el rendimiento inicialmente contiene alrededor de 90,000 * 1000 operaciones por segundo (recuerde la sobrecarga), pero con una longitud de lista de varios miles de elementos, comienza a ceder. Esto se debe a la falta de memoria cach√© cada vez m√°s frecuente: la memoria cach√© del procesador no tiene los datos necesarios y, cada vez m√°s, debe buscar datos en la RAM. Con un mill√≥n de elementos, la velocidad de la prueba es 10 veces menor, pero en la pr√°ctica, la reducci√≥n del rendimiento es a√∫n mayor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TreeList, IndexedTreeList e IndexedTreeListSet esperan resultados similares. </font><font style="vertical-align: inherit;">Se esperaba mucho m√°s lento que ArrayList. </font><font style="vertical-align: inherit;">Incluso con una peque√±a cantidad de elementos, TreeList es varias veces m√°s lento que ArrayList, aunque la prueba muestra la diferencia solo 2 veces. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La siguiente prueba es addRemoveRandom. </font><font style="vertical-align: inherit;">Aqu√≠, en cada prueba, inserto un elemento en una posici√≥n aleatoria y elimino un elemento de una posici√≥n aleatoria.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado de la prueba AddRemoveRandom</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.addRemoveRandom           ArrayList       10  thrpt    5  12440.764 ¬±   485.642  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList      100  thrpt    5   9880.123 ¬±   464.014  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList     1000  thrpt    5   5288.905 ¬±  1219.055  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList    10000  thrpt    5   1024.942 ¬±   179.366  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList   100000  thrpt    5     91.219 ¬±    25.380  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList  1000000  thrpt    5      5.499 ¬±     0.400  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList       10  thrpt    5   6242.607 ¬±   350.290  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList      100  thrpt    5   3117.945 ¬±   116.066  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList     1000  thrpt    5   1829.778 ¬±    80.516  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList    10000  thrpt    5   1230.077 ¬±    53.381  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList   100000  thrpt    5    443.571 ¬±    69.207  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList  1000000  thrpt    5    308.963 ¬±    84.077  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList       10  thrpt    5   3556.511 ¬±   144.596  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList      100  thrpt    5   2120.777 ¬±    83.848  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList     1000  thrpt    5   1211.112 ¬±    92.288  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList    10000  thrpt    5    789.458 ¬±    19.450  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList   100000  thrpt    5    302.989 ¬±    40.030  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList  1000000  thrpt    5    178.822 ¬±    92.853  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet       10  thrpt    5   4138.007 ¬±   119.943  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet      100  thrpt    5   2435.803 ¬±    20.276  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet     1000  thrpt    5   1445.054 ¬±   276.909  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet    10000  thrpt    5    972.256 ¬±    19.987  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet   100000  thrpt    5    366.608 ¬±    94.487  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet  1000000  thrpt    5    227.677 ¬±    48.276  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se podr√≠a suponer que ArrayList es m√°s r√°pido en listas peque√±as. </font><font style="vertical-align: inherit;">Sin embargo, el hecho de que gane en esta prueba en listas de hasta 10,000 elementos parece interesante. </font><font style="vertical-align: inherit;">Aparentemente, System.arrayCopy est√° muy bien optimizado y utiliza todas las caracter√≠sticas de los procesadores modernos. </font><font style="vertical-align: inherit;">A partir de 10.000 elementos, las estructuras de datos especializadas comienzan a ganar. </font><font style="vertical-align: inherit;">Con 1,000,000 de elementos, la diferencia de velocidad es de 30-50 veces. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se espera que IndexedTreeList e IndexedTreeListSet sean m√°s lentas que TreeList. </font><font style="vertical-align: inherit;">Aproximadamente 1.5 - 2 veces. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las 2 pruebas restantes indexOfKnown e indexOfUnknown deber√≠an demostrar la caracter√≠stica principal de esta estructura. </font><font style="vertical-align: inherit;">La diferencia entre las pruebas es que en un caso estamos buscando un elemento que est√° en la lista, y en el otro caso estamos buscando un elemento que no est√© en la lista.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado de la prueba indexOfKnown e indexOfUnknown</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.indexOfKnown              ArrayList       10  thrpt    5  41424.356 ¬±   549.047  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList      100  thrpt    5  17216.477 ¬±  1444.744  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList     1000  thrpt    5   2296.306 ¬±    76.372  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList    10000  thrpt    5    233.863 ¬±    26.926  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList   100000  thrpt    5     23.208 ¬±     2.776  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList  1000000  thrpt    5      0.919 ¬±     0.455  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList       10  thrpt    5  26740.708 ¬±  1323.125  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList      100  thrpt    5   5670.923 ¬±    99.638  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList     1000  thrpt    5    745.408 ¬±    26.827  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList    10000  thrpt    5     52.288 ¬±     1.362  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList   100000  thrpt    5      4.224 ¬±     0.855  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList  1000000  thrpt    5      0.193 ¬±     0.052  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList       10  thrpt    5  34485.128 ¬±  1582.703  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList      100  thrpt    5  29209.412 ¬±  1544.268  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList     1000  thrpt    5  21139.584 ¬±  1442.867  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList    10000  thrpt    5  12544.306 ¬±   312.097  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList   100000  thrpt    5   3538.201 ¬±   272.537  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList  1000000  thrpt    5   1420.119 ¬±   538.476  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet       10  thrpt    5  39201.995 ¬±  1887.065  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet      100  thrpt    5  34204.112 ¬±  1122.517  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet     1000  thrpt    5  25374.557 ¬±  1596.746  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet    10000  thrpt    5  14291.317 ¬±   391.180  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet   100000  thrpt    5   4215.898 ¬±   283.680  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet  1000000  thrpt    5   1729.100 ¬±  1260.815  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList       10  thrpt    5  59053.313 ¬±  1845.665  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList      100  thrpt    5  10867.572 ¬±   142.823  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList     1000  thrpt    5   1186.583 ¬±    28.003  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList    10000  thrpt    5    120.953 ¬±     4.146  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList   100000  thrpt    5     11.936 ¬±     0.320  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList  1000000  thrpt    5      0.566 ¬±     0.335  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList       10  thrpt    5  28134.237 ¬±  2291.670  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList      100  thrpt    5   3153.930 ¬±   158.734  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList     1000  thrpt    5    322.383 ¬±    44.245  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList    10000  thrpt    5     25.674 ¬±     1.787  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList   100000  thrpt    5      1.867 ¬±     0.291  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList  1000000  thrpt    5      0.093 ¬±     0.008  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList       10  thrpt    5  66625.126 ¬±  5232.668  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList      100  thrpt    5  70038.055 ¬±  5803.848  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList     1000  thrpt    5  63240.467 ¬±   885.956  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList    10000  thrpt    5  54731.988 ¬±  3950.150  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList   100000  thrpt    5  22049.476 ¬±   821.924  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList  1000000  thrpt    5   9459.862 ¬±   804.738  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet       10  thrpt    5  70274.968 ¬± 15830.355  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet      100  thrpt    5  71017.685 ¬±  6920.447  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet     1000  thrpt    5  66405.960 ¬±  1127.231  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet    10000  thrpt    5  57983.963 ¬±  3276.142  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet   100000  thrpt    5  41277.110 ¬±  9919.893  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet  1000000  thrpt    5   9840.185 ¬±  2159.352  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠, ArrayList y TreeList casi no tienen sorpresas. Con el aumento de tama√±o, la velocidad disminuye casi linealmente. No se espera que la b√∫squeda de un elemento de una lista sea 2 veces m√°s lenta que la b√∫squeda de un elemento de una lista, porque necesita pasar por toda la matriz en lugar de la mitad en promedio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero IndexedTreeList e IndexedTreeListSet aqu√≠ muestran el buen resultado esperado. Estas estructuras de datos muestran una velocidad de ejecuci√≥n indexOf comparable a ArrayList incluso con 10 elementos. Con 1000 elementos, estas estructuras son 10 veces m√°s r√°pidas, con 1,000,000 m√°s r√°pidas 1000 veces. Al buscar un elemento que no est√° en la lista, se espera que den una mejor velocidad que cuando se busca un elemento de la lista.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A lo que es interesante prestar atenci√≥n es a la subsidencia del rendimiento de IndexedTreeList e IndexedTreeListSet en la prueba indexOfUnknown. </font><font style="vertical-align: inherit;">Aqu√≠ la situaci√≥n es similar a la de la prueba con ArrayList.get. </font><font style="vertical-align: inherit;">Te√≥ricamente, no deber√≠amos haber tenido una ca√≠da en el rendimiento, pero en la pr√°ctica, debido a la p√©rdida de cach√©, lo hemos conseguido, adem√°s, de manera significativa.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de una conclusi√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todav√≠a no s√© si la estructura propuesta tiene una novedad o no. Por un lado, la idea no es complicada si sabes c√≥mo funciona el √°rbol con una clave impl√≠cita. Por otro lado, no he visto una descripci√≥n de una estructura con tales propiedades. Y si es as√≠, entonces tiene sentido hacer que la estructura sea m√°s famosa, podr√≠a ser √∫til para alguien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero incluso si esta es otra bicicleta, trat√© de hacerla √∫til. Se ha creado una solicitud de extracci√≥n en colecciones comunes, pero al momento de escribir este art√≠culo a√∫n no se ha vertido. Sabiendo lo lento que puede pasar todo en c√≥digo abierto, no me sorprender√° si el proceso se prolonga durante meses.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algo sorprendido por el resultado de comparar el rendimiento de ArrayList y TreeList. </font><font style="vertical-align: inherit;">Las pruebas mostraron que TreeList no tiene sentido usar hasta 10,000 elementos en el tama√±o de la lista. </font><font style="vertical-align: inherit;">Ser√≠a interesante probar b-tree en lugar de un √°rbol binario. </font><font style="vertical-align: inherit;">Esta estructura deber√≠a usar la memoria con m√°s cuidado y, lo m√°s probable, trabajar m√°s r√°pido. </font><font style="vertical-align: inherit;">Y para ello puedes adaptar la idea con indexaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cualquier caso, es divertido tener un instrumento en el arsenal que pueda (casi) hacer todo con una complejidad predecible.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referencias</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proyecto original de </font></font><br>
</a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solicitud de extracci√≥n en Apache Common-Collections </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ticket en Jira</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es488758/index.html">Conferencia 27 de DEFCON. Reconocimiento de estafas en Internet</a></li>
<li><a href="../es488762/index.html">Programaci√≥n asincr√≥nica elegante con promesas.</a></li>
<li><a href="../es488766/index.html">Arte y tecnolog√≠a: Universidad de Massachusetts en Lowell</a></li>
<li><a href="../es488768/index.html">Infierno sangriento, o c√≥mo jurar en ingl√©s que se confunde con una persona culta</a></li>
<li><a href="../es488776/index.html">Mejoras de accesibilidad en Visual Studio 2019 para Mac</a></li>
<li><a href="../es488780/index.html">Mozilla perdi√≥ en la guerra del navegador, pero a√∫n cree que podr√≠a salvar Internet</a></li>
<li><a href="../es488782/index.html">¬øQu√© le parece esta opci√≥n de administraci√≥n de dependencias en Python?</a></li>
<li><a href="../es488784/index.html">Comercializaci√≥n de mejoras de software libre bajo licencias Copyleft</a></li>
<li><a href="../es488786/index.html">¬øQu√© tan detallada debe ser una historia de usuario?</a></li>
<li><a href="../es488792/index.html">Monitorear la disponibilidad del sitio en Rusia en la rodilla</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>