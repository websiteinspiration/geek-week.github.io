<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏽 🙋🏾 👩🏽‍💼 我如何摆脱一千个标签... 🖕🏾 👨‍❤️‍💋‍👨 👩🏻‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="...而且晚了3年。理想情况下，应该是这样的：用户启动浏览器，浏览器显示用户的需求。但是，尽管未实现，但您必须使用搜索引擎。理想情况下，应该是这样的：用户打开搜索引擎，输入搜索查询，并显示用户的需求。但是，尽管“我感到很幸运”按钮不能很好地工作（尽管最近在该方向上出现了明显的变化），但有时您必须从搜...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>我如何摆脱一千个标签...</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487782/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...而且晚了3年。理想情况下，应该是这样的：用户启动浏览器，浏览器显示用户的需求。但是，尽管未实现，但您必须使用搜索引擎。理想情况下，应该是这样的：用户打开搜索引擎，输入搜索查询，并显示用户的需求。但是，尽管</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“我感到很幸运”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按钮</font><font style="vertical-align: inherit;">不能很好地工作（尽管最近在该方向上出现了明显的变化），但有时您必须从搜索结果页面转到几个地址。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
显然，使用搜索引擎的场景在历史上是固定的（当互联网很慢时）：进入搜索结果页面，我在后台打开了几个选项卡，而其余的在加载时，已经可以读取第一个选项卡了。如果我在其中一个标签上找到了必要的信息，则其余的必须手动关闭。如果它没有立即关闭，则选项卡将保持挂起状态，从而增加浏览器中打开的选项卡的数量，通常，此后很少打开。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，如果单击带有在新窗口中打开的链接的页面，则会创建几个（逻辑上）选项卡式的选项卡。</font><font style="vertical-align: inherit;">找到所需信息后，您将永远无法记住已连接的标签页，也无法关闭所有内容，这还会导致打开的标签页数量激增。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我一直需要</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“找到”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按钮</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">按钮</font><font style="vertical-align: inherit;">会在我之后清除搜索的结果（我们称其为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“我很幸运”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">进入浏览器扩展世界后，我认为在这种情况下这可能会有所帮助。</font><font style="vertical-align: inherit;">因此，开始变得朦胧地开始想要编写可以解决我的问题的扩展程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我会告诉你我的故事，我将按时间顺序带领故事，结论可能出乎意料。</font></font><a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">迈向的第一步</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我要做的第一件事是建立基础架构：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">webpack + babel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在，我不喜欢</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">babel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在每个模块中为其助手提供重复的代码。</font><font style="vertical-align: inherit;">可以将其配置为使用该对象</font></font><code>babelHelper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是随后</font></font><code>babelHelper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">webpack</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置中连接</font><font style="vertical-align: inherit;">代码文件</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">将这样的文件保存在项目中并指向它</font></font><code>entry</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很丑陋，我为webpack制作了一个插件，该插件可以自动为我完成此任务。</font><font style="vertical-align: inherit;">在第一步上花费了大量的精力并为扩展本身编写了更多代码之后，我放慢了速度。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插入</font></font></b><div class="spoiler_text"><strong>webpack-babel-external-helpers-2:</strong><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.npmjs.com/package/webpack-babel-external-helpers-2</a></div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基础</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
时间流逝，只有webpack的插件可用，但不能以任何方式解决我的问题。每次我搜索某项内容但没有关闭标签时，都会有一个想法：“完成扩展很高兴……”欲望越来越大，如今，一天，质量就变成了质量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在该说说主要思想了：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用户进入搜索结果页面</font></font><abbr title="搜索引擎结果页"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-SICKLE</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们解析搜索结果，保存自己的链接地址，当用户单击其中一个地址后，向他显示带有其他地址和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ Found”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按钮的通知</font><font style="vertical-align: inherit;">关闭标签页。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当您转到页面时，可能会有多种选择。最简单：一个请求-来自服务器的一个响应（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">最困难的是：一个请求-多个服务器重定向（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3xx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），然后是客户端重定向（使用</font></font><code>&lt;meta/&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或javascript），</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">历史记录API</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也位于最上方</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">而且，它们之间的组合通常是大多数网站的类别。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简单过渡案例：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d9/ml/od/d9mlodnv9fkgcqczxiomnwwhvqc.png" alt="简单过渡的情况（答案200）"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
复杂的过渡案例：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yl/zc/ps/ylzcpsc_dcgocw-o5vhwci2xoy4.png" alt="复杂的过渡案例（3xx +客户端重定向）"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，保存页面地址并仅对其进行检查并不总是足够的。因此，您需要创建一个逻辑转换，在其中记录路径上遇到的所有地址，然后检查逻辑转换是否包含存储的地址。任务很明确，但是并不是所有的事情都那么直接执行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Chrome中，有两个与导航相关的API：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">webNavigation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">webRequest-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个都有自己的事件。前者-连接转换和浏览器UI，后者-基础网络请求。因此，如果页面的地址更改是由于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">历史记录API引起的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则后者不会发生任何事件，并且如果在网络请求期间发生重定向，则前者根本不会报告它。</font><font style="vertical-align: inherit;">因此，有必要使用两个API，从每个API的每个事件中收集少量信息，以形成一个逻辑转换。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一些细节</font></font></b><div class="spoiler_text">   ,   <code>webNavigation</code> (wN)    :<br>
<br>
<pre><code class="plaintext hljs">onBeforeNavigate -&gt; onCommitted -&gt; onDOMContentLoaded -&gt; onCompleted
</code></pre><br>
  <code>webRequest</code> (wR):<br>
<br>
<pre><code class="plaintext hljs">onBeforeRequest -&gt; [onBeforeRedirect -&gt; onBeforeRequest]* -&gt; onCompleted | onErrorOccurred
</code></pre><br>
    wR  wN     (   ), ..  -  <code>wN.onBeforeNavigate</code>    <code>wR.onBeforeRequest</code>,  - .     .<br>
<br>
<code>         ,     ,        .</code><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发展历程</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...让我们回到数量增长为质量的时刻。从开发开始到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">已经花费了大量时间：浏览器开始支持</font><i><font style="vertical-align: inherit;">es6模块</font></i><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shadow DOM</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和其他现代功能。为了构建项目，我转到了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rollup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这一次我不必编写插件。建立基础-能够在任何选项卡中获取有关任何过渡的信息的能力之后，仍然需要实施解析支持的SICKLES并在相关页面上显示通知的逻辑。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一个任务是非常原始的：我们知道SICKLE的地址，使用内容脚本进入页面内容，获取我们感兴趣的数据，保存它，等待用户转到其中一个页面向他显示其他页面的通知。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于第二项任务，您需要实现通知本身，即在页面上向用户显示的内容。在这里，内容脚本也无法做到。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初，只有一个处理程序（也称为控制器）负责用户与搜索引擎的交互过程中的逻辑。然后这个想法出现了，为什么当用户只是单击在新选项卡中打开的链接时，为什么不在相关选项卡上显示通知。我不得不重做逻辑，使其更具通用性。类似于中间件</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React / Redux</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您可以连接多个Transition处理程序，将来它们将使您能够实现在扩展程序设置中禁用/启用各种处理程序的功能。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隐私</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于通知是屏幕底部的面板，并且已添加到页面布局，因此页面上的脚本可以使用与该页面上任何其他元素相同的方式访问此元素。也就是说，从理论上讲，该页面可以找出您使用了哪个搜索查询，在哪个搜索引擎中以及向您提供了哪些其他页面，这不是很好。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一种称为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">影子DOM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的技术可以解决</font><font style="vertical-align: inherit;">。不建议</font></font><code>closed mode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在创建时在</font><font style="vertical-align: inherit;">网络</font><font style="vertical-align: inherit;">上</font><font style="vertical-align: inherit;">使用它</font></font><code>shadowRoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为它意义不大（</font></font><code>shadowRoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果要以编程方式访问它，</font><font style="vertical-align: inherit;">您仍然必须将指向元素的链接存储在</font><font style="vertical-align: inherit;">某个位置；您还可以重新定义</font></font><code>attachShadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建</font><font style="vertical-align: inherit;">函数</font></font><code>shadowRoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在打开模式下，重新定义后加载的脚本将已经使用该函数的新版本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于扩展，情况并非如此。内容脚本和页面脚本生活在平行世界中。页面中的脚本无权访问内容脚本中定义的对象，而内容脚本以对象的DOM功能的本机实现运行（页面中脚本的重写功能对内容脚本所使用的功能没有影响）。结合这两个条件，我们看到可以</font></font><code>shadowRoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过将链接存储在变量中</font><font style="vertical-align: inherit;">来创建带有私有元素的元素</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，页面中的脚本将只能访问wrapper元素，该元素将为空。</font><font style="vertical-align: inherit;">他将无法接收请求的文本或建议的页面。</font><font style="vertical-align: inherit;">必须注意不要在通知中提供任何链接到生成的事件中的任何元素或纯文本。</font><font style="vertical-align: inherit;">因此，在扩展名中，生成的id用于事件中，并且后台脚本已经可以理解该id对它的要求。</font><font style="vertical-align: inherit;">对于页面，此ID毫无意义。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻译困难</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初，该扩展程序仅针对</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Chrome</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开发</font><font style="vertical-align: inherit;">，但是由于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebExtensions API的存在</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我脑海中的某个地方仍然能够移植到其他浏览器。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">webextension-polyfill</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的存在</font><font style="vertical-align: inherit;">激发了人们的信心。但是，无论如何。此扩展程序的polyphil仅带来了使用带有承诺的chrome API的功能。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firefox已</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成为今年的令人失望的一年。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">Firefox chrome API不匹配（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">错误1543647</font></a><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误1595621</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）对于扩展程序的正常运行至关重要，我们可以说它在此浏览器中不起作用（如预期的那样）。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">维瓦尔第（Vivaldi）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是最接近的，但也不是没有成本的。事件</font></font><code>wN.onCreatedNavigationTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当用户使用鼠标中键或通过</font></font><code>Shift|Ctrl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+鼠标左键而不是</font><i><font style="vertical-align: inherit;">chrome API中</font></i></font><code>wN.onCommitted transitionType == 'start_page'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未</font><font style="vertical-align: inherit;">包含的event </font><font style="vertical-align: inherit;">（</font><font style="vertical-align: inherit;">而不是event）来</font><font style="vertical-align: inherit;">打开链接时，就不会发生</font><font style="vertical-align: inherit;">这种情况，因此，并非在所有情况下，扩展程序都可以正常工作。</font><font style="vertical-align: inherit;">同样在Vivaldi中，扩展功能热键不起作用。</font><font style="vertical-align: inherit;">在这种情况下，Chrome的杀手级功能是什么，它使您可以快速浏览选项卡并关闭它们，而无需使用鼠标。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在编写代码期间，用于显示通知的逻辑发生了多次更改，每次都简化了。结果，事实证明，可能不是用逻辑转换来围堵花园，而是捕捉用户的“相关转换”（如果</font></font><code>wN.onCommitted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一个标志</font></font><code>transitionType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指示转换的目的，在许多情况下是“链接”，这意味着用户切换了通过引用），这将大大简化代码并在许多情况下（但并非在所有情况下）都可以工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，不在主题之内，我期望在</font><i><font style="vertical-align: inherit;">webExtensions API</font></i><font style="vertical-align: inherit;">方面具有更多的兼容性</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">与往常一样，当您不需要对旧版本的支持时，生活在现代浏览器中是件好事。</font><font style="vertical-align: inherit;">CSS动画是一件很了不起的事情：您过去使用js库的目的现在已经在CSS的几行中完成了。</font><font style="vertical-align: inherit;">自定义元素在扩展中不起作用，但是影子DOM起作用，从而允许您利用其所有功能。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扩张</font></font></b><div class="spoiler_text">     chrome web store: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Handy Search</a></div></div></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN487768/index.html">在小米网关2上打开端口4321和9898</a></li>
<li><a href="../zh-CN487772/index.html">满足Yandex中的Chuvash语言。翻译：我们如何解决机器翻译的主要问题</a></li>
<li><a href="../zh-CN487774/index.html">SQL Server日期和时间错误</a></li>
<li><a href="../zh-CN487776/index.html">Microsoft Azure培训日：服务器基础结构迁移（注册完成）</a></li>
<li><a href="../zh-CN487780/index.html">漏洞管理-更多：管理还是漏洞？</a></li>
<li><a href="../zh-CN487784/index.html">它们来自质量检查的哪儿？</a></li>
<li><a href="../zh-CN487786/index.html">智能烤箱用户需要多少自由度。一个强大的团队如何在两周而不是三周内检验假设</a></li>
<li><a href="../zh-CN487788/index.html">没有设计师的产品设计</a></li>
<li><a href="../zh-CN487790/index.html">“是的，它们存在！” 哈萨克斯坦的数据科学专家做什么，他们能赚多少钱？</a></li>
<li><a href="../zh-CN487792/index.html">在Windows服务器（使用Nginx）上提高Mercurial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>