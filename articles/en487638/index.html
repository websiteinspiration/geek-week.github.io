<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòØ ‚ò™Ô∏è üë™ HighLoad ++, Mikhail Tyulenev (MongoDB): Causal consistency: from theory to practice üëºüèº üèí #‚É£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The next HighLoad ++ conference will be held on April 6 and 7, 2020 in St. Petersburg. 
 Details and tickets here . HighLoad ++ Siberia 2019. Hall "Kr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>HighLoad ++, Mikhail Tyulenev (MongoDB): Causal consistency: from theory to practice</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/487638/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next HighLoad ++ conference will be held on April 6 and 7, 2020 in St. Petersburg. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Details and tickets </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . HighLoad ++ Siberia 2019. Hall "Krasnoyarsk". June 25, 12:00. Abstracts and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ok/iw/mz/okiwmzx4qkp6dxvjvqjxvfzqtnk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It happens that practical requirements conflict with a theory where aspects important for a commercial product are not taken into account. This report presents the process of selecting and combining various approaches to creating Causal consistency components based on academic research based on the requirements of a commercial product. Students will learn about the existing theoretical approaches to logical clocks, dependency tracking, system security, clock synchronization, and why MongoDB stopped on these or those solutions.</font></font><a name="habracut"></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mikhail Tyulenev (hereinafter - MT):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - I will talk about Causal consistency - this is a feature that we worked on in MongoDB. </font><font style="vertical-align: inherit;">I work in a group of distributed systems, we did it about two years ago. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ih/xx/xg/ihxxxghkrknnqdxg7tb4w97izi0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the process, I had to get acquainted with a lot of academic Research, because this feature is well studied. </font><font style="vertical-align: inherit;">It turned out that not a single article fits into what is required in production, the database in view of the very specific requirements that are, probably, in any production applications. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will talk about how we, as a consumer of academic Research, prepare something from it that we can then present to our users as a ready-made dish that is convenient, safe to use.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Causal consistency. </font><font style="vertical-align: inherit;">Let's define concepts</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To begin with, I want to outline in general terms what Causal consistency is. There are two characters - Leonard and Penny (the series "The Big Bang Theory"): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7q/nw/lr/7qnwlrmqtidow8cl_jrdakec3d0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose Penny is in Europe, and Leonard wants to make some kind of surprise for her, a party. And he doesn‚Äôt come up with anything better than throwing her out of the friend list, sending updates to feed all friends: ‚ÄúLet's make Penny happy!‚Äù (she in Europe, while sleeping, does not see this all and cannot see, because she is not there). At the end, it deletes this post, erases it from the "Feed" and restores access so that it does not notice anything and there is no scandal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is all fine, but let's assume that the system is distributed, and the events went a bit wrong. </font><font style="vertical-align: inherit;">Maybe, for example, it happens that the Penny access restriction occurred after this post appeared, if the events are not connected by a causal relationship. </font><font style="vertical-align: inherit;">Actually, this is an example of when Causal consistency is required in order to fulfill a business function (in this case). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, these are quite non-trivial properties of the database - very few people support them. </font><font style="vertical-align: inherit;">Let's move on to the models.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consistency Models</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is a consistency model in databases in general? </font><font style="vertical-align: inherit;">These are some of the guarantees that a distributed system gives regarding what data and in what sequence the client can receive. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In principle, all consistency models come down to how distributed the system is like a system that works, for example, on the same nod on a laptop. </font><font style="vertical-align: inherit;">And this is how much the system, which works on thousands of geo-distributed ‚ÄúNodes‚Äù, is similar to a laptop, in which all these properties are executed automatically in principle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, consistency models only apply to distributed systems. </font><font style="vertical-align: inherit;">All systems that previously existed and worked on the same vertical scaling did not experience such problems. </font><font style="vertical-align: inherit;">There was one Buffer Cache, and everything was always read from it.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strong Model</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actually, the very first model is Strong (or the line of rise ability, as it is often called). </font><font style="vertical-align: inherit;">This is a consistency model that ensures that every change, as soon as confirmation is received that it has occurred, is visible to all users of the system. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This creates a global order of all events in the database. </font><font style="vertical-align: inherit;">This is a very strong consistency property, and it is generally very expensive. </font><font style="vertical-align: inherit;">However, it is very well maintained. </font><font style="vertical-align: inherit;">It is simply very expensive and slow - they are simply rarely used. </font><font style="vertical-align: inherit;">This is called rise ability. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is another, more powerful property that is supported in the "Spanner" - called External Consistency. </font><font style="vertical-align: inherit;">We will talk about him a little later.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Causal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following is Causal, just what I was talking about. There are several sublevels between Strong and Causal that I won‚Äôt talk about, but they all come down to Causal. This is an important model because it is the strongest of all models, the strongest consistency in the presence of a network or partitions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Causals is actually a situation in which events are connected by a causal relationship. Very often they are perceived as Read your on rights from the point of view of the client. If the client observed some values, he cannot see the values ‚Äã‚Äãthat were in the past. He is already starting to see prefix readings. It all comes down to the same thing.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Causals as a model of consistency is a partial ordering of events on the server, in which events from all clients are observed in the same sequence. </font><font style="vertical-align: inherit;">In this case, Leonard and Penny.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eventual</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The third model is Eventual Consistency. This is what supports absolutely all distributed systems, a minimal model that generally makes sense. It means the following: when we have some changes in the data, they become consistent at some point. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At such a moment, she does not say anything, otherwise she would turn into External Consistency - there would be a completely different story. Nevertheless, this is a very popular model, the most common. By default, all users of distributed systems use Eventual Consistency. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I want to give some comparative examples: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yn/5s/p9/yn5sp9tyjn4dh4q3vonroirvxic.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What do these arrows mean?</font></font><br>
<br>
<ul>
<li><b>Latency.</b>          :    ,       ,    ,     .   Eventual Consistency   ,   ,  ,    memory       .</li>
<li><b>Availability.</b>           , partitions,  -  ‚Äì      ,    ,         - . Eventual Consistency        ‚Äì    ,  .</li>
<li><b>Anomalies.</b>  , ,   .  Strong Consistency       ,  Eventual Consistency     .  :     Eventual Consistency,    ?    ,  Eventual Consistency- ,   , ,    ;        -   ;       .   ,       .</li>
</ul><br>
<h3> CAP</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When you see the words consistency, availability - what comes to mind? Right - CAP theorem! Now I want to dispel the myth ... It's not me - there is Martin Kleppman, who wrote a wonderful article, a wonderful book. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-k/rc/v1/-krcv1vofhv9ofnwbty6ql6hvhg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The CAP theorem is a principle formulated in the 2000s that Consistency, Availability, Partitions: take any two, and you cannot choose three. It was a certain principle. It was proved as a theorem a few years later, by Gilbert and Lynch. Then it became used as a mantra - systems began to be divided into CA, CP, AP and so on.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This theorem was actually proved for the following reasons ... First, Availability was considered not as a continuous value from zero to hundreds (0 - the system is "dead", 100 - answers quickly; we are so used to considering it), but as a property of the algorithm , which ensures that with all its executions it returns data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is not a word about the response time! There is an algorithm that returns data after 100 years - a perfectly fine available algorithm, which is part of the CAP theorem. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Second: a theorem was proved for changes in the values ‚Äã‚Äãof the same key, despite the fact that these changes are a resizable line. This means that in fact they are practically not used, because the models are different Eventual Consistency, Strong Consistency (maybe).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why is this all? </font><font style="vertical-align: inherit;">Moreover, the CAP theorem in the form in which it is proved is practically not applicable is rarely used. </font><font style="vertical-align: inherit;">In a theoretical form, it somehow limits everything. </font><font style="vertical-align: inherit;">It turns out a certain principle that is intuitively true, but in no way, in general, is proved.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Causal consistency - the strongest model</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is happening now - you can get all three things: Consistency, Availability can be obtained using Partitions. </font><font style="vertical-align: inherit;">In particular, Causal consistency is the strongest consistency model, which, in the presence of Partitions (network breaks), still works. </font><font style="vertical-align: inherit;">Therefore, it is of such great interest, and therefore we are engaged in it. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/4s/k8/ty4sk8sx4n73xnsxlkw2wtb1ity.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, it simplifies the work of application developers. </font><font style="vertical-align: inherit;">In particular, there is a lot of support from the server: when all the records that occur inside one client are guaranteed to arrive in this order on the other client. </font><font style="vertical-align: inherit;">Secondly, it withstands partitions.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interior Kitchen MongoDB</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remembering that lunch, we move to the kitchen. I will talk about the system model, namely, what is MongoDB for those who first hear about such a database. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fn/-b/kj/fn-bkjwvkdxcokzum9xwwkshcu8.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/2u/qz/3g/2uqz3gts5ipfvvojtpo2epigtf4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MongoDB (hereinafter referred to as ‚ÄúMongoBD‚Äù) is a distributed system that supports horizontal scaling, that is, sharding; and within each shard, it also supports data redundancy, i.e. replication. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sharding in ‚ÄúMongoBD‚Äù (non-relational database) performs automatic balancing, that is, each collection of documents (or ‚Äútable‚Äù in terms of relational data) into pieces, and already the server automatically moves them between shards. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Query Router that distributes queries for the client is some client through which it works. He already knows where and what data is located, sends all requests to the correct shard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another important point: MongoDB is a single master. </font><font style="vertical-align: inherit;">There is one Primary - it can take records that support the keys that it contains. </font><font style="vertical-align: inherit;">You cannot do multi-master write. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We made release 4.2 - new interesting things appeared there. </font><font style="vertical-align: inherit;">In particular, they inserted Lucene - the search - it was executable java directly in "Mongo", and there it became possible to search through Lucene, the same as in "Elastic". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And they made a new product - Charts, it is also available on Atlas (Mongo's own Cloud). </font><font style="vertical-align: inherit;">They have Free Tier - you can play around with this. </font><font style="vertical-align: inherit;">I really liked the charts - the data visualization is very intuitive.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Causal consistency ingredients</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I counted about 230 articles that were published on this topic - from Leslie Lampert. </font><font style="vertical-align: inherit;">Now from my memory I will bring to you some parts of these materials. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2_/dt/2n/2_dt2nhood8jlup51kyeddsy7w8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It all started with an article by Leslie Lampert, which was written in the 1970s. </font><font style="vertical-align: inherit;">As you can see, some research on this topic is still ongoing. </font><font style="vertical-align: inherit;">Now Causal consistency is experiencing interest in connection with the development of distributed systems.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limitations</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What are the limitations? </font><font style="vertical-align: inherit;">This is actually one of the main points, because the restrictions that production systems impose are very different from the restrictions that exist in academic articles. </font><font style="vertical-align: inherit;">Often they are quite artificial.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qd/nh/ql/qdnhql6zcor1hzt53ur72spzqzy.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firstly, ‚ÄúMongoDB‚Äù is a single master, as I have already said (this greatly simplifies).</font></font></li>
<li> ,   10     .     -  ,      .</li>
<li>   ,   ,      ,    binary,     ,    .</li>
<li>  ,   Research  :      . ¬´¬ª ‚Äì  . ,     ,  ‚Äì    .  ,     .</li>
<li>  ,     ‚Äì  :    ,   performance degradation   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another point is generally anti-academic: compatibility of previous and future versions. </font><font style="vertical-align: inherit;">Old drivers must support new updates, and the database must support old drivers.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, all this imposes limitations.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Causal consistency components</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will now talk about some of the components. </font><font style="vertical-align: inherit;">If we consider the general Causal consistency, we can distinguish blocks. </font><font style="vertical-align: inherit;">We chose from the works that belong to a block: Dependency Tracking, the choice of hours, how these watches can be synchronized with each other, and how we ensure safety - this is an approximate plan of what I‚Äôll talk about:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/rb/rq/zvrbrqunyfdrj1pmbrjncugqed4.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full Dependency Tracking</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why is it needed? In order that when the data is replicated - each record, each data change contains information about what changes it depends on. The very first and naive change is when each message that contains a record contains information about previous messages: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/ue/jh/gkuejhztxm81mfji3fazhsmbmbm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this example, the number in braces is the number of records. Sometimes these records with values ‚Äã‚Äãare even transferred in their entirety, sometimes some versions are transferred. The bottom line is that each change contains information about the previous one (obviously it carries everything in itself).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why did we decide not to use this approach (full tracking)? </font><font style="vertical-align: inherit;">Obviously, because this approach is impractical: any change in the social network depends on all previous changes in this social network, transmitting, say, Facebook or Vkontakte in each update. </font><font style="vertical-align: inherit;">Nevertheless, there is a lot of research namely Full Dependency Tracking - these are social networks, for some situations it really works.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explicit Dependency Tracking</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next one is more limited. </font><font style="vertical-align: inherit;">Here, too, transmission of information is considered, but only that which clearly depends. </font><font style="vertical-align: inherit;">What depends on what, as a rule, is determined already by Application. </font><font style="vertical-align: inherit;">When data is replicated, only responses are returned when a request is made, when previous dependencies were satisfied, that is, shown. </font><font style="vertical-align: inherit;">This is the essence of how Causal consistency works. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y_/jc/mw/y_jcmwt2w-vqj9guslui0wl8vgi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
She sees that record 5 depends on records 1, 2, 3, 4 - respectively, she waits before the client gets access to the changes made by Penny's access decree when all previous changes have already passed to the database. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This also does not suit us, because anyway there is too much information, and this will slow down. </font><font style="vertical-align: inherit;">There is a different approach ...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lamport Clock</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
They are very old. Lamport Clock implies that these dependency are collapsed into a scalar function called Lamport Clock. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A scalar function is some abstract number. Often called logical time. At each event, this counter increases. Counter, which is currently known to the process, sends each message. It is clear that processes can be out of sync, they can have completely different times. Nevertheless, the system somehow balances the clock with such messaging. What happens in this case?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I split that big shard in two so that it is clear: Friends can live in one node that contains a piece of the collection, and Feed can live in another node that contains a piece of this collection. It‚Äôs clear how they can get out of turn? First, Feed says, ‚ÄúReplicated,‚Äù and then Friends. If the system does not provide any guarantees that Feed will not be shown until the Friends dependencies in the Friends collection are also delivered, then we will just have a situation that I mentioned. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You see how logically counter time increases on Feed:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gv/pz/vw/gvpzvwwxqonuthkwv6j2ez0fruc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, the main property of this Lamport Clock and Causal consistency (explained through Lamport Clock) is as follows: if we have events A and B, and event B depends on event A *, then it follows that the LogicalTime from Event A is less than the LogicalTime from Event B. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Sometimes they even say that A happened before B, that is, A happened before B - this is a kind of relationship that partially orders the whole set of events that generally happened.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The reverse is wrong. This is actually one of the main disadvantages of Lamport Clock - partial ordering. There is a concept of simultaneous events, that is, events in which neither (A happened before B) nor (A happened before B). An example is the parallel addition by Leonard to friends of someone else (not even Leonard, but Sheldon, for example).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is the property that is often used when working with Lamport watches: they look at the function exactly and draw a conclusion from this - maybe these events are dependent. </font><font style="vertical-align: inherit;">Because in one direction this is true: if LogicalTime A is less than LogicalTime B, then B cannot happen before A; </font><font style="vertical-align: inherit;">and if more, then maybe.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vector Clock</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The logical development of Lamport watches is the Vector Clock. They differ in that each node that is here contains its own separate clock, and they are transmitted as a vector. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, you see that the zero index of the vector is responsible for Feed, and the first index of the vector is for Friends (each of these nodes). And now they will increase: the zero index of the "Feed" increases when recording - 1, 2, 3: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cv/xm/cd/cvxmcdiz_dgbjsu7elnj3xt2hcc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How is the Vector Clock better? The fact that they can figure out which events are simultaneous and when they occur on different nodes. This is very important for a sharding system like the MongoBD. However, we didn‚Äôt choose this, although it‚Äôs a wonderful thing, and it works great, and probably would suit us ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we have 10 thousand shards, we cannot transfer 10 thousand components, even if we compress, we think up something else - all the same, the payload will be several times less than the volume of this whole vector. </font><font style="vertical-align: inherit;">Therefore, grinding our hearts and teeth, we abandoned this approach and moved on to another.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spanner TrueTime. </font><font style="vertical-align: inherit;">Atomic clock</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I said that there will be a story about Spanner. This is a cool thing, right the 21st century: atomic clocks, GPS synchronization. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What idea? Spanner is a Google system that has recently even become available to people (they have attached SQL to it). Each transaction there has some time stamp. Since the time is synchronized *, each event can be assigned a specific time - the atomic clock has a wait time, after which it is guaranteed that another time will occur. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zn/vw/e3/znvwe3zwpqvjhsx-qglxpbqen9g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, just writing to the database and waiting for a certain period of time, the event serialization is automatically guaranteed. They have the strongest Consistency model, which in principle can be imagined - it is External Consistency.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* This is the main problem of Lampart watches - they are never synchronous on distributed systems. </font><font style="vertical-align: inherit;">They can diverge, even with NTP, they still do not work very well. </font><font style="vertical-align: inherit;">"Spanner" has an atomic clock and synchronization seems to be then microseconds. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why didn‚Äôt we choose? </font><font style="vertical-align: inherit;">We do not assume that our users have a built-in atomic clock. </font><font style="vertical-align: inherit;">When they appear, being built into every laptop, there will be some kind of super cool GPS synchronization - then yes ... In the meantime, the best that is possible is Amazon, Base Stations for fanatics ... Therefore, we used other watches.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybrid Clock</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is actually what ticks the ‚ÄúMongoBD‚Äù while ensuring Causal consistency. </font><font style="vertical-align: inherit;">What are they hybrid? </font><font style="vertical-align: inherit;">A hybrid is a scalar value, but it consists of two components:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hi/wz/uv/hiwzuvz-czbmb52b9iypojrr0_u.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first is the unix era (how many seconds have passed since the "beginning of the computer world").</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second is some increment, also a 32-bit unsigned int.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's all, actually. </font><font style="vertical-align: inherit;">There is such an approach: the part that is responsible for the time is synchronized with the clock all the time; </font><font style="vertical-align: inherit;">every time an update occurs, this part is synchronized with the clock and it turns out that the time is always more or less correct, and increment allows you to distinguish between events that occurred at the same time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why is this important for MongoBD? </font><font style="vertical-align: inherit;">Because it allows you to make some kind of backup restorants at a certain point in time, that is, the event is indexed by time. </font><font style="vertical-align: inherit;">This is important when some events are needed; </font><font style="vertical-align: inherit;">for a database, events are changes to the database that occur at certain times in time.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will only tell you the most important reason (please, just don‚Äôt tell anyone)! </font><font style="vertical-align: inherit;">We did this because ordered, indexed data in MongoDB OpLog looks like this. </font><font style="vertical-align: inherit;">OpLog is a data structure that contains absolutely all changes in the database: they first go to OpLog, and then they are already applied to Storage itself in the case when it is a replicated date or shard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That was the main reason. </font><font style="vertical-align: inherit;">Still, there are also practical requirements for developing the database, which means that it should be simple - there is little code, as few broken things as possible that need to be rewritten and tested. </font><font style="vertical-align: inherit;">The fact that our oplogs were indexed by a hybrid watch greatly helped, and allowed us to make the right choice. </font><font style="vertical-align: inherit;">It really paid off and somehow magically worked, on the very first prototype. </font><font style="vertical-align: inherit;">It was very cool!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clock synchronization</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are several synchronization methods described in the scientific literature. </font><font style="vertical-align: inherit;">I'm talking about synchronization when we have two different shards. </font><font style="vertical-align: inherit;">If there is one replica set, there is no need for synchronization there: it is a ‚Äúsingle master‚Äù; </font><font style="vertical-align: inherit;">we have an OpLog in which all changes get into - in this case everything is already sequentially ordered in the "Oplog" itself. </font><font style="vertical-align: inherit;">But if we have two different shards, time synchronization is important here. </font><font style="vertical-align: inherit;">Here vector clocks helped more! </font><font style="vertical-align: inherit;">But we do not have them. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ei/kq/bk/eikqbkbbzrsdquzxjxlzayc81qq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second one is Heartbeats. </font><font style="vertical-align: inherit;">You can exchange some signals that occur every unit of time. </font><font style="vertical-align: inherit;">But Hartbits are too slow, we cannot provide latency to our client.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
True time is, of course, a wonderful thing. </font><font style="vertical-align: inherit;">But, again, this is probably the future ... Although the Atlas can already be done, there are already fast "Amazonian" time synchronizers. </font><font style="vertical-align: inherit;">But it will not be available to everyone. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gossiping is when all messages include time. </font><font style="vertical-align: inherit;">This is roughly what we use. </font><font style="vertical-align: inherit;">Each message between nodes, a driver, a router of data nodes, absolutely everything for MongoDB are some elements, database components that contain hours that flow. </font><font style="vertical-align: inherit;">Everywhere they have the meaning of hybrid time, it is transmitted. </font><font style="vertical-align: inherit;">64 bits? </font><font style="vertical-align: inherit;">It allows, it is possible.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How does it all work together?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here I look at one replica set to make it a little easier. There are Primary and Secondary. Secondary does replication and is not always fully synchronized with Primary. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is an insert (insert) in the "Primaries" with a certain value of time. This insert increases the internal counter by 11, if it is maximum. Or it will check the clock values ‚Äã‚Äãand synchronize by the clock if the clock is larger. This allows you to sort by time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After he makes a record, an important moment occurs. The hours are in ‚ÄúMongoDB‚Äù and are incremented only if recorded in the ‚ÄúOplog‚Äù. This is an event that changes the state of the system. Absolutely in all classic articles, an event is considered to be a message entering a node: a message has arrived - that means the system has changed its state.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is due to the fact that during the study it is not entirely possible to understand how this message will be interpreted. We know for sure that if it is not reflected in the ‚ÄúOplog‚Äù, then it will not be interpreted in any way, and only the entry in the ‚ÄúOplog‚Äù is a change in the state of the system. This simplifies everything for us: the model simplifies and allows us to organize in the framework of one replica set, and many other useful things. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It returns the value that has already been recorded in the ‚ÄúOplog‚Äù - we know that in the ‚ÄúOplog‚Äù this value already lies, and its time is 12. Now, say, the reading starts from another node (Secondary), and it transfers already afterClusterTime itself message. He says: ‚ÄúI need everything that happened after at least 12 or during twelve‚Äù (see fig. Above).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is what is called Causal a consistent (CAT). There is such a concept in theory that it is some slice of time, which is consistent in itself. In this case, we can say that this is the state of the system that was observed at time 12. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now there is nothing here, because it seems to simulate a situation where Secondary needs to replicate data from Primary. He is waiting ... And now the data has come - returns these values ‚Äã‚Äãback. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/a1/q7/3q/a1q73qclyk9sn567b2x8szr_ejm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's how it all works. Almost.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What does "almost" mean? Let's assume that there is some person who has read and understood how this all works. I realized that every time ClusterTime occurs, it updates the internal logical clock, and then the next record increases by one. This function takes up 20 lines. Suppose this person transmits the largest possible 64-bit number, minus one. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why is minus one? Because the internal clock is substituted into this value (obviously, this is the largest possible and more than the current time), then there will be an entry in the ‚ÄúOlog‚Äù, and the clock will increment by one more - and there will already be a maximum value (there are simply all units, there‚Äôs nowhere to go , unsigned ints).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is clear that after this the system becomes completely inaccessible for nothing. </font><font style="vertical-align: inherit;">It can only be unloaded, cleaned - a lot of manual work. </font><font style="vertical-align: inherit;">Full availability: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/lz/fs/iulzfslzcst3tn9c-qpouy9zqsk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Moreover, if this is replicated somewhere else, then the entire cluster simply lies down. </font><font style="vertical-align: inherit;">An absolutely unacceptable situation that anyone can organize very quickly and simply! </font><font style="vertical-align: inherit;">Therefore, we considered this moment as one of the most important. </font><font style="vertical-align: inherit;">How to prevent it?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our way is to sign clusterTime</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So it is transmitted in the message (before the blue text). But we also began to generate a signature (blue text): The </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zg/9r/iu/zg9riuabqzdlnw9dwttrwkwzkmi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
signature is generated by a key that is stored inside the database, inside the protected perimeter; it is generated, updated (users do not see anything). Hash is generated, and each message is signed during creation, and validated upon receipt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probably, the question arises in people: "How much does it slow down?" I said that it should work quickly, especially in the absence of this feature. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What does it mean to use Causal consistency in this case? This will show the afterClusterTime parameter. And without it, it will simply pass values ‚Äã‚Äãanyway. Gossiping, since version 3.6, always works.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we leave the constant generation of signatures, this will slow down the system even in the absence of features, which does not meet our approaches and requirements. </font><font style="vertical-align: inherit;">And what have we done?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do it fast!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A simple enough thing, but the trick is interesting - I‚Äôll share it, maybe someone will be interested. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have a hash that stores signed data. </font><font style="vertical-align: inherit;">All data goes through the cache. </font><font style="vertical-align: inherit;">The cache does not specifically sign the time, but Range. </font><font style="vertical-align: inherit;">When a certain value comes, we generate a Range, mask the last 16 bits, and we sign this value: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s8/ml/3a/s8ml3aaec2pj5xl8t0zvkrp7iik.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By receiving such a signature, we speed up the system (conditionally) by 65 thousand times. </font><font style="vertical-align: inherit;">It works great: when they did the experiments, the time when we had a consistent update was really reduced there by 10 thousand times. </font><font style="vertical-align: inherit;">It is clear that when they are at odds, this does not work. </font><font style="vertical-align: inherit;">But in most practical cases this works. </font><font style="vertical-align: inherit;">The combination of the Range signature with the signature resolved the security issue.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What have we learned?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lessons we learned from this:</font></font><br>
<br>
<ul>
<li>  , , ,       .     -  ( ,      . .),  , .   ,       ,    ,   .        ‚Äì   .<br>
<br>
,     ,      (¬´¬ª, ) ‚Äì      .     ?    .     ,      .   ‚Äì   ,   .</li>
<li>    .  ,        ¬´¬ª     ,   ,  ,      availability, latency  .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last is that we had to consider different ideas and combine several generally different articles into one approach, together. </font><font style="vertical-align: inherit;">The idea of ‚Äã‚Äãsigning, for example, came from an article that examined the Paxos protocol, which for non-Byzantine Faylor inside the authorization protocol, for the Byzantine ones outside the authorization protocol ... In general, this is exactly what we did in the end. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is absolutely nothing new here! </font><font style="vertical-align: inherit;">But as soon as we mixed it all together ... It's like saying that the Olivier salad recipe is nonsense, because eggs, mayonnaise and cucumbers have already come up with ... It's about the same story.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/6o/pc/q8/6opcq8ew4bcry9qnt0lsdlasflo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On this I will end. </font><font style="vertical-align: inherit;">Thank!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Questions</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Question from the audience (hereinafter - B):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Thank you, Michael for the report! The theme of time is interesting. You are using gossiping. They said that everyone has their own time, everyone knows their local time. As I understand it, we have a driver - there can be many clients with drivers, query-planners too, a lot of shards ... But what is the system going to if we suddenly have a discrepancy: someone decides that he is for a minute ahead, someone - a minute behind? Where will we find ourselves? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Great question really! I just wanted to say about shards. If I understand the question correctly, we have this situation: there is shard 1 and shard 2, reading occurs from these two shards - they have a discrepancy, they do not interact with each other, because the time they know is different, especially the time that They exist in oplogs.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose shard 1 made a million records, shard 2 did nothing at all, and the request came in two shards. And the first one has afterClusterTime over a million. In such a situation, as I explained, shard 2 will never respond at all. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - I wanted to know how they synchronize and choose one logical time? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Very easy to sync. Shard, when afterClusterTime comes to him, and he does not find the time in the ‚ÄúCatch‚Äù - initiates no approved. That is, he raises his hands to this value with his hands. This means that it has no events matching this query. He creates this event artificially and thus becomes the Causal Consistent. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - And if after that some other events that were lost somewhere on the network still come to him? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- The shard is so arranged that they will not come anymore, since it is a single master. If he has already recorded, then they will not come, but will be after. It can‚Äôt happen that somewhere something is stuck, then he will do no write, and then these events arrived - and Causal consistency was violated. When he does no write, they all have to come next (he will wait for them). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t2/wb/oo/t2wboofhfs7qpepqz8zwsm1o0u4.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- I have a few questions regarding the lines. Causal consistency assumes that there is a certain queue of actions that need to be performed. What happens if we lose one package? So the 10th went, the 11th ... the 12th disappeared, and everyone else is waiting for it to be fulfilled. And suddenly our car died, we can‚Äôt do anything. Is there a maximum queue length that accumulates before it is executed? What fatal failure occurs when any one state is lost? Moreover, if we write down that there is some kind of state previous, then we should somehow start from it? And they didn‚Äôt push from him! </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Also a wonderful question! What are we doing? MongoDB has the concept of quorum records, quorum reads. When can a message disappear? When the record is not quorum or when the reading is not quorum (some garbage can also stick). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Concerning the Causal consistency, we performed a large experimental test, which resulted in the fact that when the recording and reading are not quorum, Causal consistency violations occur. Exactly what you say!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our tip: Use at least quorum reading when using Causal consistency. In this case, nothing will be lost, even if the quorum record is lost ... This is an orthogonal situation: if the user does not want the data to be lost, you need to use the quorum record. Causal consistency does not guarantee durability. The durability guarantee is provided by replication and machinery associated with replication. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - When we create an instance that sharding does for us (not master, but slave, respectively), it relies on the unix time of its own machine or on the time of the ‚Äúmaster‚Äù; synchronized for the first time or periodically? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Now I‚Äôll make it clear. Shard (i.e., horizontal partition) - there is always Primary. And in a shard there may be a ‚Äúmaster‚Äù and there may be replicas. But the shard always supports writing, because it must support a certain domain (Primary is in the shard). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - That is, everything depends purely on the "master"? Always use the "master" -time? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Yes. It can be figuratively said: the clock is ticking when there is a recording in the "master", in the "Oplog". </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - We have a client who connects, and he does not need to know anything about time? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- In general, you do not need to know anything! If we talk about how it works on the client: at the client, when he wants to use Causal consistency, he needs to open a session. Now everything is there: both transactions in the session and retrieve a rights ... A session is an ordering of logical events occurring with a client. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If he opens this session and says there that he wants Causal consistency (if by default the session supports Causal consistency), everything automatically works. The driver remembers this time and increases it when it receives a new message. It remembers which answer returned the previous one from the server that returned the data. The following request will contain afterCluster ("time is greater than this").</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The client does not need to know absolutely nothing! This is absolutely opaque to him. If people use these features, what can I do? First, you can safely read secondaries: you can write in Primary, and read from geographically replicated secondaries and be sure that it works. At the same time, the sessions that were recorded on Primary can be transferred even to Secondary, that is, you can use not one session, but several. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - The topic of Eventual consistency is strongly related to the new Compute science layer - CRDT (Conflict-free Replicated Data Types) data types. Have you considered the integration of these types of data into the database and what can you say about it? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Good question! CRDT makes sense for write conflicts: in MongoDB - single master. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- I have a question from the devops. In the real world, there are such Jesuit situations when the Byzantine Failure occurs, and the evil people inside the protected perimeter begin to stick into the protocol, send craft packages in a special way? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8d/m3/p5/8dm3p5em6rsqsv2ojzy-vdylffg.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Evil people inside the perimeter are like a Trojan horse! Evil people inside the perimeter can do many bad things. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - It is clear that leaving a hole in the server, roughly speaking, through which you can stick the elephant zoo and collapse the entire cluster forever ... It will take time for manual recovery ... This, to put it mildly, is wrong. On the other hand, this is curious: in real life, in practice, there are situations when naturally similar internal attacks occur? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Since I rarely encounter security breachs in real life, I can‚Äôt say - maybe they happen. But if we talk about development philosophy, then we think so: we have a perimeter that provides the guys who make security - it's a castle, a wall; and inside the perimeter you can do anything you want. It is clear that there are users with the ability to only look, and there are users with the ability to erase the directory. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depending on the rights, the damage that users can do may be a mouse, or it may be an elephant. It is clear that a user with full rights can do anything at all. A user with not broad rights of harm can cause significantly less. In particular, he cannot break the system. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- In the secure perimeter, someone climbed to form unexpected protocols for the server in order to set up the server with cancer, and if you are lucky, then the entire cluster ... Does it ever happen so ‚Äúwell"? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - I have never heard of such things. The fact that this way you can fill up the server is not a secret. To fill up inside, being from the protocol, being an authorized user who can write something like that in a message ... Actually, it‚Äôs impossible, because anyway it will be verified. It is possible to disable this authentication for users who do not want to - this is then their problem; roughly speaking, they themselves destroyed the walls and you can cram an elephant there, which will trample ... In general, you can dress as a repairman, come and get it! </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Thanks for the report. </font><font style="vertical-align: inherit;">Sergey (Yandex). </font><font style="vertical-align: inherit;">In ‚ÄúMong‚Äù there is a constant that limits the number of voting members in the Replica Set, and this constant is 7 (seven). </font><font style="vertical-align: inherit;">Why is this a constant? </font><font style="vertical-align: inherit;">Why is this not some kind of parameter? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Replica Set we also have 40 nodes. </font><font style="vertical-align: inherit;">There is always a majority. </font><font style="vertical-align: inherit;">I don‚Äôt know which version ... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - In the Replica Set, you can run non-voting members, but voting - a maximum of 7. How, in this case, experience shutdown if we have the Replica Set pulled to 3 data centers? </font><font style="vertical-align: inherit;">One data center can easily turn off, and another machine fall out. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - This is already a bit outside the scope of the report. </font><font style="vertical-align: inherit;">This is a common question. </font><font style="vertical-align: inherit;">Maybe then I can tell him.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9t/cr/ga/9tcrgaodiufisllhrktf_5iok_a.jpeg"><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/UnAprFMX1d4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A bit of advertising :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thank you for staying with us. Do you like our articles? Want to see more interesting materials? Support us by placing an order or recommending to your friends, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloud VPS for developers from $ 4.99</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unique analog of entry-level servers that was invented by us for you: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The whole truth about VPS (KVM) E5-2697 v3 (6 Cores) 10GB DDR4 480GB SSD 1Gbps from $ 19 or how to divide the server?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2 times cheaper at the Equinix Tier IV data center in Amsterdam?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Only we have </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV from $ 199</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the Netherlands!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - from $ 99! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Read about</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How to Build Infrastructure Bldg. </font><font style="vertical-align: inherit;">class c using Dell R730xd E5-2650 v4 servers costing 9,000 euros per penny?</font></font></a></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en487626/index.html">How parking sensors work and how to trick him</a></li>
<li><a href="../en487628/index.html">Diagnosis of aging based on 9 hallmarks of aging signs</a></li>
<li><a href="../en487630/index.html">The Simplest Algorithm for Creating a Field Puzzle (Part 1)</a></li>
<li><a href="../en487632/index.html">‚ÄúColleagues, breathe more quietly‚Äù: why office noise drives us crazy - we discuss research</a></li>
<li><a href="../en487636/index.html">APIs for which it‚Äôs finally worth upgrading from Java 8. Part 2</a></li>
<li><a href="../en487640/index.html">Game Automation Testing</a></li>
<li><a href="../en487644/index.html">Getting stock quotes using Python</a></li>
<li><a href="../en487646/index.html">Test tube neutron star. Sonoluminescence</a></li>
<li><a href="../en487648/index.html">It could be another javascript framework.</a></li>
<li><a href="../en487650/index.html">Hope on the SDK and don‚Äôt go wrong: The problem of nested scrolls in BottomSheetBehavior</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>