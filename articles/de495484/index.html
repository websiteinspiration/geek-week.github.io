<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍⚕️ 🤨 🐽 Wie Unix-Pipelines implementiert werden 🌏 🖊️ 🚲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel beschreibt die Implementierung von Pipelines im Unix-Kernel. Ich war etwas enttäuscht von einem kürzlich erschienenen Artikel mit dem T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wie Unix-Pipelines implementiert werden</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/495484/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/sl/9i/gesl9iqjuhatlmgyrdps28zgje0.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel beschreibt die Implementierung von Pipelines im Unix-Kernel. </font><font style="vertical-align: inherit;">Ich war etwas enttäuscht von einem kürzlich erschienenen Artikel mit dem Titel " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktionieren Pipelines unter Unix?" </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Ging </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um das interne Gerät. </font><font style="vertical-align: inherit;">Ich wurde interessiert und vergrub mich in den alten Quellen, um die Antwort zu finden.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Worüber reden wir?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pipelines - „wahrscheinlich die wichtigste Erfindung unter Unix“ - sind das bestimmende Merkmal der zugrunde liegenden Philosophie von Unix, kleine Programme miteinander zu kombinieren, sowie die bekannte Befehlszeile:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ echo hello | wc -c<font></font>
6<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktionalität hängt vom Systemaufruf des Kernels ab </font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der auf den Dokumentationsseiten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipe (7)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipe (2) beschrieben wird</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Förderer bieten einen unidirektionalen Interprozess-Kommunikationskanal. </font><font style="vertical-align: inherit;">Die Pipeline hat einen Eingang (Schreibende) und einen Ausgang (Leseende). </font><font style="vertical-align: inherit;">Auf den Eingang der Pipeline geschriebene Daten können ausgelesen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Pipeline wird mithilfe eines Aufrufs erstellt </font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der zwei Dateideskriptoren zurückgibt: einer bezieht sich auf die Eingabe der Pipeline, der zweite auf die Ausgabe.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ablaufverfolgungsergebnisse des obigen Befehls veranschaulichen die Erstellung einer Pipeline und den Datenfluss durch sie von einem Prozess zum anderen:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ strace -qf -e execve,pipe,dup2,read,write \<font></font>
    sh -c 'echo hello | wc -c'<font></font>
<font></font>
execve("/bin/sh", ["sh", "-c", "echo hello | wc -c"], …)<font></font>
pipe([3, 4])                            = 0<font></font>
[pid 2604795] dup2(4, 1)                = 1<font></font>
[pid 2604795] write(1, "hello\n", 6)    = 6<font></font>
[pid 2604796] dup2(3, 0)                = 0<font></font>
[pid 2604796] execve("/usr/bin/wc", ["wc", "-c"], …)<font></font>
[pid 2604796] read(0, "hello\n", 16384) = 6<font></font>
[pid 2604796] write(1, "6\n", 2)        = 2<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der übergeordnete Prozess ruft </font></font><code>pipe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf, um die angehängten Dateideskriptoren abzurufen. </font><font style="vertical-align: inherit;">Ein untergeordneter Prozess schreibt in einen Deskriptor, und ein anderer Prozess liest dieselben Daten aus einem anderen Deskriptor. </font><font style="vertical-align: inherit;">Der Wrapper, der dup2 verwendet, „benennt“ die Deskriptoren 3 und 4 um, um stdin und stdout abzugleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ohne Pipelines müsste die Shell das Ergebnis eines Prozesses in eine Datei schreiben und in einen anderen Prozess übertragen, damit sie die Daten aus der Datei liest. </font><font style="vertical-align: inherit;">Infolgedessen würden wir mehr Ressourcen und Speicherplatz ausgeben. </font><font style="vertical-align: inherit;">Pipelines sind jedoch nicht nur deshalb gut, weil sie die Verwendung temporärer Dateien vermeiden:</font></font><br>
<br>
<blockquote>      ,  <code>read(2)</code>    ,     .       ,  <code>write(2)</code>    ,           .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie die POSIX-Anforderung ist dies eine wichtige Eigenschaft: Das Schreiben in die Pipeline bis zu </font></font><code>PIPE_BUF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bytes (mindestens 512) muss atomar sein, damit Prozesse über die Pipeline auf dieselbe Weise miteinander interagieren können wie reguläre Dateien (die keine solchen Garantien bieten). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Verwendung einer regulären Datei kann ein Prozess alle seine Ausgabedaten in diese Datei schreiben und an einen anderen Prozess übertragen. </font><font style="vertical-align: inherit;">Oder Prozesse können im harten Parallelisierungsmodus arbeiten und einen externen Signalisierungsmechanismus (z. B. ein Semaphor) verwenden, um sich gegenseitig über den Abschluss des Schreibens oder Lesens zu informieren. </font><font style="vertical-align: inherit;">Förderer ersparen uns all diese Probleme.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was suchen wir?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich erkläre es an meinen Fingern, damit Sie sich leichter vorstellen können, wie der Förderer funktionieren kann. </font><font style="vertical-align: inherit;">Sie müssen einen Puffer und einen Status im Speicher zuweisen. </font><font style="vertical-align: inherit;">Sie benötigen Funktionen zum Hinzufügen und Entfernen von Daten zum Puffer. </font><font style="vertical-align: inherit;">Es erfordert einige Mittel, um Funktionen während Lese- und Schreibvorgängen in Dateideskriptoren aufzurufen. </font><font style="vertical-align: inherit;">Und Sperren sind erforderlich, um das oben beschriebene spezielle Verhalten zu implementieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt sind wir bereit, im hellen Licht der Lampen den Quellcode des Kernels abzufragen, um unser vages mentales Modell zu bestätigen oder zu widerlegen. </font><font style="vertical-align: inherit;">Aber seien Sie immer auf das Unerwartete vorbereitet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wo suchen wir?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich weiß nicht, wo sich meine Kopie des berühmten Buches " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lions-Buch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " mit Unix 6-Quellcode befindet, aber dank </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Unix Heritage Society können</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie online nach </font><font style="vertical-align: inherit;">noch älteren Versionen von Unix </font><font style="vertical-align: inherit;">im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellcode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> suchen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Spaziergang durch die TUHS-Archive ist wie ein Museumsbesuch. </font><font style="vertical-align: inherit;">Wir können einen Blick auf unsere gemeinsame Geschichte werfen, und ich respektiere die langjährigen Bemühungen, all diese Materialien Stück für Stück aus alten Kassetten und Ausdrucken wiederzugewinnen. </font><font style="vertical-align: inherit;">Und ich bin mir der Fragmente, die noch fehlen, sehr bewusst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir unsere Neugier auf die alte Geschichte der Förderer befriedigt haben, können wir uns moderne Kerne zum Vergleich ansehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Übrigens </font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist eine Systemrufnummer 42 in der Tabelle </font></font><code>sysent[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zufall?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traditionelle Unix-Kernel (1970–1974)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe </font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weder in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDP-7 Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Januar 1970) noch in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ersten Ausgabe von Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (November 1971) oder im unvollständigen Quellcode der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zweiten Ausgabe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Juni 1972) </font><font style="vertical-align: inherit;">eine Spur gefunden </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TUHS behauptet, dass die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dritte Ausgabe von Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Februar 1973) die erste Version mit Pipelines war:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die dritte Ausgabe von Unix war die neueste Version mit einem in Assemblersprache geschriebenen Kernel, aber die erste Version mit Pipelines. </font><font style="vertical-align: inherit;">Im Jahr 1973 wurde an der Verbesserung der dritten Ausgabe gearbeitet, der Kern wurde in C umgeschrieben, und so erschien die vierte Ausgabe von Unix.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einer der Leser fand einen Scan eines Dokuments, in dem Doug McIlroy die Idee vorschlug, „Programme nach dem Prinzip eines Gartenschlauchs zu verbinden“.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6c/8c2/c8c/c6c8c2c8c5720d79227246af98c9b8d5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem Buch von Brian Kernighan „ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unix: Eine Geschichte und eine Erinnerung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “, in der Geschichte des Auftretens von Förderbändern, wird dieses Dokument auch erwähnt: „... es hing 30 Jahre lang in meinem Büro bei Bell Labs an der Wand.“ Hier ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Interview mit McIlroy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und eine weitere Geschichte aus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">McIlroys Arbeit aus dem Jahr 2014</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote>  Unix,        ,  ,  ,   - ,     ,       .  ,   . ,  ,  ,       .                ?           «»     , , -, : «  !».<br>
<br>
 .        ,    ,       (    ),     .          .              .      API          ,      .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider geht der Kernel-Quellcode für die dritte Unix-Edition verloren. Und obwohl wir den Quellcode für den Kernel der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vierten Ausgabe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in C haben </font><font style="vertical-align: inherit;">, der im November 1973 veröffentlicht wurde, wurde er einige Monate vor der offiziellen Veröffentlichung veröffentlicht und enthält keine Pipeline-Implementierungen. Schade, dass der Quellcode der legendären Unix-Funktion möglicherweise für immer verloren geht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den Text der Dokumentation </font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus beiden Versionen, sodass Sie zunächst die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dritte Ausgabe der</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dokumentation durchsuchen können </font><font style="vertical-align: inherit;">(nach bestimmten Wörtern, die „manuell“ unterstrichen sind, eine Zeichenfolge von Literalen ^ H, gefolgt von Unterstrichen!). Dieses Proto ist </font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Assembler geschrieben und gibt nur einen Dateideskriptor zurück, bietet jedoch bereits die erwartete Grundfunktionalität:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipe</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Systemaufruf </font><font style="vertical-align: inherit;">erstellt einen Ausgabeeingabemechanismus, der als Pipeline bezeichnet wird. </font><font style="vertical-align: inherit;">Der zurückgegebene Dateideskriptor kann für Lese- und Schreibvorgänge verwendet werden. </font><font style="vertical-align: inherit;">Wenn etwas in die Pipeline geschrieben wird, werden bis zu 504 Datenbytes gepuffert, wonach der Schreibvorgang angehalten wird. </font><font style="vertical-align: inherit;">Beim Lesen aus einer Pipeline werden gepufferte Daten erfasst.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bis zum nächsten Jahr wurde der Kernel in C umgeschrieben, und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipe (2) in der vierten Ausgabe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fand mit dem Prototyp " </font></font><code>pipe(fildes)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font><font style="vertical-align: inherit;">sein modernes Aussehen </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<blockquote>  <i>pipe</i>    ,   .          .  -   ,   ,   r1 (. fildes[1]),    4096  ,     .     ,   r0 (. fildes[0]),  .<br>
<br>
,      ( )   (   <i>fork</i>)         <i>read</i>  <i>write</i>.<br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Shell verfügt über eine Syntax zum Definieren eines linearen Arrays von Prozessen, die über eine Pipeline verbunden sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leseaufrufe von einer leeren Pipeline (die keine gepufferten Daten enthält) mit nur einem Ende (alle Schreibdateideskriptoren sind geschlossen) geben das "Dateiende" zurück. </font><font style="vertical-align: inherit;">Das Aufzeichnen von Anrufen in einer ähnlichen Situation wird ignoriert.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die früheste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">überlebende Pipeline-Implementierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stammt aus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der fünften Ausgabe von Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Juni 1974), ist jedoch fast identisch mit der in der nächsten Version veröffentlichten. </font><font style="vertical-align: inherit;">Es wurden nur Kommentare hinzugefügt, sodass die fünfte Ausgabe übersprungen werden kann.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sechste Ausgabe von Unix (1975)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir beginnen mit dem Lesen des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sechsten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unix-Quellcodes </font><font style="vertical-align: inherit;">(Mai 1975). </font><font style="vertical-align: inherit;">Vor allem dank </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lions ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es viel einfacher, es zu finden als den Quellcode früherer Versionen:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lions ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seit </font><font style="vertical-align: inherit;">vielen Jahren </font><font style="vertical-align: inherit;">das einzige Unix-Kerndokument, das außerhalb der Wände von Bell Labs verfügbar ist. </font><font style="vertical-align: inherit;">Obwohl die Lizenz der sechsten Ausgabe es Lehrern erlaubte, ihren Quellcode zu verwenden, schloss die Lizenz der siebten Ausgabe diese Möglichkeit aus, so dass das Buch in Form von illegalen maschinengeschriebenen Kopien verteilt wurde.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heute können Sie eine Nachdruckkopie des Buches kaufen, auf dessen Cover die Schüler beim Fotokopierer gezeigt werden. Und dank Warren Tumi (der das TUHS-Projekt ins Leben gerufen hat) können Sie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDF-Datei mit dem Quellcode für die sechste Ausgabe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herunterladen </font><font style="vertical-align: inherit;">. Ich möchte Ihnen eine Vorstellung davon geben, wie viel Aufwand beim Erstellen der Datei erforderlich war:</font></font><br>
<br>
<blockquote> 15       ,   <i>Lions</i>,             . TUHS   ,         .   1988-      9 ,        PDP11.   ,   ,      /usr/src/,       1979- ,     .        PWB,   .<br>
<br>
            .     ,    ,    +=   =+. -  ,  -   ,    .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und heute können wir online auf TUHS den Quellcode der sechsten Ausgabe aus dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Archiv</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">, an dem Dennis Ritchie beteiligt war</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf den ersten Blick ist das Hauptmerkmal des C-Codes vor der Kernigan- und Richie-Zeit übrigens seine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kürze</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nicht so oft schaffe ich es, Codefragmente ohne umfangreiche Bearbeitung einzubetten, um sie an einen relativ engen Anzeigebereich auf meiner Website anzupassen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Anfang von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/usr/sys/ken/pipe.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> steht ein erklärender Kommentar (und ja, es gibt auch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ usr / sys / dmr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Max allowable buffering per pipe.<font></font>
 * This is also the max size of the<font></font>
 * file created to implement the pipe.<font></font>
 * If this size is bigger than 4096,<font></font>
 * pipes will be implemented in LARG<font></font>
 * files, which is probably not good.<font></font>
 */<font></font>
#define    PIPSIZ    4096<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Puffergröße hat sich seit der vierten Ausgabe nicht geändert. Aber hier, ohne öffentliche Dokumentation, sehen wir, dass einmal die Pipelines Dateien als Backup-Speicher verwendet haben! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LARG-Dateien entsprechen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem LARG-Inode-Flag</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das vom "High-Addressing-Algorithmus" zur Verarbeitung </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indirekter Blöcke</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet wird, um größere Dateisysteme zu unterstützen. Da Ken sagte, es sei besser, sie nicht zu benutzen, nehme ich gerne sein Wort dafür. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der eigentliche Systemaufruf </font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * The sys-pipe entry.<font></font>
 * Allocate an inode on the root device.<font></font>
 * Allocate 2 file structures.<font></font>
 * Put it all together with flags.<font></font>
 */<font></font>
pipe()<font></font>
{<font></font>
    register *ip, *rf, *wf;<font></font>
    int r;<font></font>
<font></font>
    ip = ialloc(rootdev);<font></font>
    if(ip == NULL)<font></font>
        return;<font></font>
    rf = falloc();<font></font>
    if(rf == NULL) {<font></font>
        iput(ip);<font></font>
        return;<font></font>
    }<font></font>
    r = u.u_ar0[R0];<font></font>
    wf = falloc();<font></font>
    if(wf == NULL) {<font></font>
        rf-&gt;f_count = 0;<font></font>
        u.u_ofile[r] = NULL;<font></font>
        iput(ip);<font></font>
        return;<font></font>
    }<font></font>
    u.u_ar0[R1] = u.u_ar0[R0]; /* wf's fd */<font></font>
    u.u_ar0[R0] = r;           /* rf's fd */<font></font>
    wf-&gt;f_flag = FWRITE|FPIPE;<font></font>
    wf-&gt;f_inode = ip;<font></font>
    rf-&gt;f_flag = FREAD|FPIPE;<font></font>
    rf-&gt;f_inode = ip;<font></font>
    ip-&gt;i_count = 2;<font></font>
    ip-&gt;i_flag = IACC|IUPD;<font></font>
    ip-&gt;i_mode = IALLOC;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Kommentar beschreibt klar, was hier passiert. Das Verstehen des Codes ist jedoch nicht einfach, teilweise aufgrund der Möglichkeit, mithilfe von « </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a struct user u</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> » </font><font style="vertical-align: inherit;">Parameter von Systemaufrufen und Rückgabewerten zu </font><font style="vertical-align: inherit;">registrieren </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und zu </font></font><code>R1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">übertragen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir, mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ialloc () </font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inode (Inode </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">)</font></a><font style="vertical-align: inherit;"> auf der Festplatte zu platzieren </font><font style="vertical-align: inherit;">und mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falloc ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zwei </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dateien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Speicher </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">abzulegen</font></a><font style="vertical-align: inherit;"> . Wenn alles gut geht, setzen wir Flags, um diese Dateien als die beiden Enden der Pipeline zu definieren, zeigen sie auf denselben Inode (dessen Referenzanzahl 2 ist) und markieren den Inode als geändert und verwendet. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Achten Sie</font></a><font style="vertical-align: inherit;"> auf Aufrufe von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iput ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Fehlerpfaden, um die Referenzanzahl im neuen Inode zu verringern. </font></font><br>
<br>
<code>pipe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss </font><font style="vertical-align: inherit;">die Dateideskriptornummern zum Lesen und Schreiben </font><font style="vertical-align: inherit;">durchlaufen </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>R1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zurückgeben. </font></font><code>falloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt einen Zeiger auf die Dateistruktur zurück, gibt aber auch über den </font></font><code>u.u_ar0[R0]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dateideskriptor zurück. Das heißt, der Code wird </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Lesen </font><font style="vertical-align: inherit;">in einem </font><font style="vertical-align: inherit;">Dateideskriptor gespeichert und weist direkt </font></font><code>u.u_ar0[R0]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach dem zweiten Aufruf </font><font style="vertical-align: inherit;">einen Deskriptor zum Schreiben zu </font></font><code>falloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Flag </font></font><code>FPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das wir beim Erstellen der Pipeline setzen, steuert das Verhalten der Funktion </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rdwr () in sys2.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die bestimmte E / A-E / A-Routinen aufruft:</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * common code for read and write calls:<font></font>
 * check permissions, set base, count, and offset,<font></font>
 * and switch out to readi, writei, or pipe code.<font></font>
 */<font></font>
rdwr(mode)<font></font>
{<font></font>
    register *fp, m;<font></font>
<font></font>
    m = mode;<font></font>
    fp = getf(u.u_ar0[R0]);<font></font>
        /* … */<font></font>
<font></font>
    if(fp-&gt;f_flag&amp;FPIPE) {<font></font>
        if(m==FREAD)<font></font>
            readp(fp); else<font></font>
            writep(fp);<font></font>
    }<font></font>
        /* … */<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann </font><font style="vertical-align: inherit;">liest </font><font style="vertical-align: inherit;">die Funktion </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Daten aus der Pipeline. </font><font style="vertical-align: inherit;">Es ist jedoch besser, die Implementierung zu verfolgen </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Erneut wurde der Code aufgrund der Besonderheiten der Argumentübertragungsvereinbarung komplizierter, aber einige Details können weggelassen werden.</font></font><br>
<br>
<pre><code class="plaintext hljs">writep(fp)<font></font>
{<font></font>
    register *rp, *ip, c;<font></font>
<font></font>
    rp = fp;<font></font>
    ip = rp-&gt;f_inode;<font></font>
    c = u.u_count;<font></font>
<font></font>
loop:<font></font>
    /* If all done, return. */<font></font>
<font></font>
    plock(ip);<font></font>
    if(c == 0) {<font></font>
        prele(ip);<font></font>
        u.u_count = 0;<font></font>
        return;<font></font>
    }<font></font>
<font></font>
    /*<font></font>
     * If there are not both read and write sides of the<font></font>
     * pipe active, return error and signal too.<font></font>
     */<font></font>
<font></font>
    if(ip-&gt;i_count &lt; 2) {<font></font>
        prele(ip);<font></font>
        u.u_error = EPIPE;<font></font>
        psignal(u.u_procp, SIGPIPE);<font></font>
        return;<font></font>
    }<font></font>
<font></font>
    /*<font></font>
     * If the pipe is full, wait for reads to deplete<font></font>
     * and truncate it.<font></font>
     */<font></font>
<font></font>
    if(ip-&gt;i_size1 == PIPSIZ) {<font></font>
        ip-&gt;i_mode =| IWRITE;<font></font>
        prele(ip);<font></font>
        sleep(ip+1, PPIPE);<font></font>
        goto loop;<font></font>
    }<font></font>
<font></font>
    /* Write what is possible and loop back. */<font></font>
<font></font>
    u.u_offset[0] = 0;<font></font>
    u.u_offset[1] = ip-&gt;i_size1;<font></font>
    u.u_count = min(c, PIPSIZ-u.u_offset[1]);<font></font>
    c =- u.u_count;<font></font>
    writei(ip);<font></font>
    prele(ip);<font></font>
    if(ip-&gt;i_mode&amp;IREAD) {<font></font>
        ip-&gt;i_mode =&amp; ~IREAD;<font></font>
        wakeup(ip+2);<font></font>
    }<font></font>
    goto loop;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wollen Bytes in die Eingabe der Pipeline schreiben </font></font><code>u.u_count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zuerst müssen wir den Inode sperren (siehe unten </font></font><code>plock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>prele</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überprüfen Sie dann den Inode-Referenzzähler. </font><font style="vertical-align: inherit;">Während beide Enden der Pipeline offen bleiben, sollte der Zähler 2 sein. Wir behalten eine Verbindung (out </font></font><code>rp-&gt;f_inode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) bei. Wenn der Zähler also kleiner als 2 ist, sollte dies bedeuten, dass der Lesevorgang sein Ende der Pipeline geschlossen hat. </font><font style="vertical-align: inherit;">Mit anderen Worten, wir versuchen, in einer geschlossenen Pipeline zu schreiben, und dies ist ein Fehler. </font><font style="vertical-align: inherit;">Der Fehlercode </font></font><code>EPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und das Signal wurden erstmals </font></font><code>SIGPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der sechsten Ausgabe von Unix veröffentlicht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber selbst wenn der Förderer geöffnet ist, kann er voll sein. In diesem Fall entfernen wir die Sperre und schlafen ein, in der Hoffnung, dass ein anderer Prozess aus der Pipeline liest und genügend Speicherplatz darin freigibt. Nach dem Aufwachen kehren wir zum Anfang zurück, blockieren erneut die Sperre und starten einen neuen Aufnahmezyklus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn in der Pipeline genügend freier Speicherplatz vorhanden ist, schreiben wir Daten mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">writei () darauf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Der Parameter </font></font><code>i_size1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Inode (bei einer leeren Pipeline kann 0 sein) gibt das Ende der Daten an, die bereits enthalten sind. Wenn genügend Aufnahmeraum vorhanden ist, können wir den Förderer von </font></font><code>i_size1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis </font><font style="vertical-align: inherit;">füllen</font></font><code>PIPESIZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dann entfernen wir die Sperre und versuchen, jeden Prozess zu aktivieren, der auf die Gelegenheit wartet, aus der Pipeline zu lesen. Wir gehen zurück zum Anfang, um zu sehen, ob wir es geschafft haben, so viele Bytes zu schreiben, wie wir brauchten. Wenn dies fehlgeschlagen ist, beginnen wir einen neuen Aufnahmezyklus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typischerweise </font></font><code>i_mode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird ein Inode </font><font style="vertical-align: inherit;">wird Parameter </font><font style="vertical-align: inherit;">speichern Berechtigungen verwendet </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Im Fall von Pipelines signalisieren wir jedoch, dass ein Prozess darauf wartet, mit Bits </font></font><code>IREAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bzw. </font><font style="vertical-align: inherit;">zu schreiben oder zu lesen </font></font><code>IWRITE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ein Prozess setzt ein Flag und ruft auf </font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und es wird erwartet, dass in Zukunft ein anderer Prozess </font><font style="vertical-align: inherit;">aufruft </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wirkliche Magie passiert in </font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie sind in </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">slp.c</font></a><font style="vertical-align: inherit;"> implementiert</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die Quelle des berühmten Kommentars: "Es wird nicht erwartet, dass Sie dies verstehen." </font><font style="vertical-align: inherit;">Glücklicherweise müssen wir den Code nicht verstehen, sehen Sie sich nur einige Kommentare an:</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Give up the processor till a wakeup occurs<font></font>
 * on chan, at which time the process<font></font>
 * enters the scheduling queue at priority pri.<font></font>
 * The most important effect of pri is that when<font></font>
 * pri&lt;0 a signal cannot disturb the sleep;<font></font>
 * if pri&gt;=0 signals will be processed.<font></font>
 * Callers of this routine must be prepared for<font></font>
 * premature return, and check that the reason for<font></font>
 * sleeping has gone away.<font></font>
 */<font></font>
sleep(chan, pri) /* … */<font></font>
<font></font>
/*<font></font>
 * Wake up all processes sleeping on chan.<font></font>
 */<font></font>
wakeup(chan) /* … */<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Prozess, der </font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für einen bestimmten Kanal aufgerufen wird, kann später von einem anderen Prozess geweckt werden, der </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für denselben Kanal aufgerufen wird. </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">koordinieren ihre Aktionen durch solche gepaarten Anrufe. </font><font style="vertical-align: inherit;">Bitte beachten Sie, dass </font><font style="vertical-align: inherit;">beim Anrufen </font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer Vorrang hat </font><font style="vertical-align: inherit;">, damit jeder </font><font style="vertical-align: inherit;">das Signal unterbrechen kann. </font><font style="vertical-align: inherit;">
Jetzt haben wir alles, um die Funktion zu verstehen </font><font style="vertical-align: inherit;">:</font></font><code>PPIPE</code><font style="vertical-align: inherit;"></font><code>sleep()</code><font style="vertical-align: inherit;"></font><code>sleep()</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>readp()</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="plaintext hljs">readp(fp)<font></font>
int *fp;<font></font>
{<font></font>
    register *rp, *ip;<font></font>
<font></font>
    rp = fp;<font></font>
    ip = rp-&gt;f_inode;<font></font>
<font></font>
loop:<font></font>
    /* Very conservative locking. */<font></font>
<font></font>
    plock(ip);<font></font>
<font></font>
    /*<font></font>
     * If the head (read) has caught up with<font></font>
     * the tail (write), reset both to 0.<font></font>
     */<font></font>
<font></font>
    if(rp-&gt;f_offset[1] == ip-&gt;i_size1) {<font></font>
        if(rp-&gt;f_offset[1] != 0) {<font></font>
            rp-&gt;f_offset[1] = 0;<font></font>
            ip-&gt;i_size1 = 0;<font></font>
            if(ip-&gt;i_mode&amp;IWRITE) {<font></font>
                ip-&gt;i_mode =&amp; ~IWRITE;<font></font>
                wakeup(ip+1);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        /*<font></font>
         * If there are not both reader and<font></font>
         * writer active, return without<font></font>
         * satisfying read.<font></font>
         */<font></font>
<font></font>
        prele(ip);<font></font>
        if(ip-&gt;i_count &lt; 2)<font></font>
            return;<font></font>
        ip-&gt;i_mode =| IREAD;<font></font>
        sleep(ip+2, PPIPE);<font></font>
        goto loop;<font></font>
    }<font></font>
<font></font>
    /* Read and return */<font></font>
<font></font>
    u.u_offset[0] = 0;<font></font>
    u.u_offset[1] = rp-&gt;f_offset[1];<font></font>
    readi(ip);<font></font>
    rp-&gt;f_offset[1] = u.u_offset[1];<font></font>
    prele(ip);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Möglicherweise fällt es Ihnen leichter, diese Funktion von unten nach oben zu lesen. Der Zweig "Lesen und Zurückgeben" wird normalerweise verwendet, wenn sich Daten in der Pipeline befinden. In diesem Fall verwenden wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readi (),</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um ab dem aktuellen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Lesevorgang</font></a><font style="vertical-align: inherit;"> so viele Daten </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">zu</font></a><font style="vertical-align: inherit;"> lesen, wie verfügbar sind </font></font><code>f_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und aktualisieren dann den Wert des entsprechenden Offsets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei nachfolgenden Lesevorgängen ist die Pipeline leer, wenn der Leseversatz den Wert des </font></font><code>i_size1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inodes erreicht hat. Wir setzen die Position auf 0 zurück und versuchen, jeden Prozess zu aktivieren, der in die Pipeline geschrieben werden soll. Wir wissen, dass der Förderer, wenn er voll ist, </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einschlafen wird </font></font><code>ip+1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Und jetzt, da die Pipeline leer ist, können wir sie aufwecken, damit sie ihren Aufnahmezyklus fortsetzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn es nichts zu lesen gibt, </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann es eine Flagge setzen </font></font><code>IREAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und einschlafen</font></font><code>ip+2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir wissen, was ihn wecken wird, </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn er einige Daten in die Pipeline schreibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Kommentare zu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readi () und writei ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> helfen zu verstehen, dass </font></font><code>u</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">Parameter nicht durch " </font><font style="vertical-align: inherit;">" übergeben können </font><font style="vertical-align: inherit;">, sondern </font><font style="vertical-align: inherit;">wie übliche E / A-Funktionen behandeln können, die eine Datei, Position, Puffer im Speicher und die Anzahl der zu lesenden oder zu schreibenden Bytes zählen .</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Read the file corresponding to<font></font>
 * the inode pointed at by the argument.<font></font>
 * The actual read arguments are found<font></font>
 * in the variables:<font></font>
 *    u_base        core address for destination<font></font>
 *    u_offset    byte offset in file<font></font>
 *    u_count        number of bytes to read<font></font>
 *    u_segflg    read to kernel/user<font></font>
 */<font></font>
readi(aip)<font></font>
struct inode *aip;<font></font>
/* … */<font></font>
<font></font>
/*<font></font>
 * Write the file corresponding to<font></font>
 * the inode pointed at by the argument.<font></font>
 * The actual write arguments are found<font></font>
 * in the variables:<font></font>
 *    u_base        core address for source<font></font>
 *    u_offset    byte offset in file<font></font>
 *    u_count        number of bytes to write<font></font>
 *    u_segflg    write to kernel/user<font></font>
 */<font></font>
writei(aip)<font></font>
struct inode *aip;<font></font>
/* … */<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie für die „konservativen“ lock, dann </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Block Inode , </font><font style="vertical-align: inherit;">solange sie einen Job zu </font><font style="vertical-align: inherit;">beenden oder nicht bekommen , </font><font style="vertical-align: inherit;">das Ergebnis (dh die Ursache </font></font><code>wakeup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><code>plock()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und sie </font></font><code>prele()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktionieren einfach: Verwenden Sie einen anderen Satz von Aufrufen </font></font><code>sleep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>wakeup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ermöglichen Sie uns, jeden Prozess zu aktivieren, der eine Sperre benötigt, die wir gerade entfernt haben:</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Lock a pipe.<font></font>
 * If its already locked, set the WANT bit and sleep.<font></font>
 */<font></font>
plock(ip)<font></font>
int *ip;<font></font>
{<font></font>
    register *rp;<font></font>
<font></font>
    rp = ip;<font></font>
    while(rp-&gt;i_flag&amp;ILOCK) {<font></font>
        rp-&gt;i_flag =| IWANT;<font></font>
        sleep(rp, PPIPE);<font></font>
    }<font></font>
    rp-&gt;i_flag =| ILOCK;<font></font>
}<font></font>
<font></font>
/*<font></font>
 * Unlock a pipe.<font></font>
 * If WANT bit is on, wakeup.<font></font>
 * This routine is also used to unlock inodes in general.<font></font>
 */<font></font>
prele(ip)<font></font>
int *ip;<font></font>
{<font></font>
    register *rp;<font></font>
<font></font>
    rp = ip;<font></font>
    rp-&gt;i_flag =&amp; ~ILOCK;<font></font>
    if(rp-&gt;i_flag&amp;IWANT) {<font></font>
        rp-&gt;i_flag =&amp; ~IWANT;<font></font>
        wakeup(rp);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst konnte ich nicht verstehen, warum es </font><font style="vertical-align: inherit;">vor dem Anruf </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht </font></font><code>prele(ip)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anrief </font></font><code>wakeup(ip+1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Das erste, was </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in seiner Schleife verursacht wird, ist, dass es </font></font><code>plock(ip)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu einem Deadlock führt, wenn </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es seinen Block noch nicht entfernt hat, so dass der Code irgendwie korrekt funktionieren muss. Wenn Sie es sich ansehen </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird klar, dass er den Schlafprozess nur als zur Ausführung bereit markiert, damit er in Zukunft </font></font><code>sched()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wirklich gestartet wird. Es </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verursacht </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entsperrt, setzt </font></font><code>IREAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ruft </font></font><code>sleep(ip+2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- all dies, bevor </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Zyklus fortgesetzt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit ist die Beschreibung der Förderer in der sechsten Ausgabe abgeschlossen. Einfacher Code, weitreichende Konsequenzen. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siebte Ausgabe von Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Januar 1979) war die neue Hauptversion (vier Jahre später), in der viele neue Anwendungen und Kernel-Eigenschaften erschienen. </font><font style="vertical-align: inherit;">Es gab auch signifikante Änderungen im Zusammenhang mit der Verwendung von Typguss, Union'ov und typisierten Zeigern auf Strukturen. </font><font style="vertical-align: inherit;">Der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipeline-Code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat sich jedoch nicht wesentlich geändert. </font><font style="vertical-align: inherit;">Wir können diese Ausgabe überspringen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xv6, ein einfacher Unix-förmiger Kernel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font><font style="vertical-align: inherit;">sechste Ausgabe von Unix hat die </font><font style="vertical-align: inherit;">Erstellung des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xv6-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kerns beeinflusst </font><font style="vertical-align: inherit;">, ist jedoch in modernem C für die Ausführung auf x86-Prozessoren geschrieben. Der Code ist leicht zu lesen, es ist klar. Im Gegensatz zu Unix-Quellen mit TUHS können Sie es außerdem kompilieren, ändern und auf etwas anderem als PDP 11/70 ausführen. Daher wird dieser Kern an Universitäten häufig als Lehrmaterial für Betriebssysteme verwendet. Quellen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sind auf Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code enthält eine übersichtliche und durchdachte Implementierung von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pipe.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die durch einen Puffer im Speicher anstelle von Inode auf der Festplatte gesichert wird. Hier gebe ich nur die Definition von "strukturelle Pipeline" und Funktion </font></font><code>pipealloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">#define PIPESIZE 512<font></font>
<font></font>
struct pipe {<font></font>
  struct spinlock lock;<font></font>
  char data[PIPESIZE];<font></font>
  uint nread;     // number of bytes read<font></font>
  uint nwrite;    // number of bytes written<font></font>
  int readopen;   // read fd is still open<font></font>
  int writeopen;  // write fd is still open<font></font>
};<font></font>
<font></font>
int<font></font>
pipealloc(struct file **f0, struct file **f1)<font></font>
{<font></font>
  struct pipe *p;<font></font>
<font></font>
  p = 0;<font></font>
  *f0 = *f1 = 0;<font></font>
  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)<font></font>
    goto bad;<font></font>
  if((p = (struct pipe*)kalloc()) == 0)<font></font>
    goto bad;<font></font>
  p-&gt;readopen = 1;<font></font>
  p-&gt;writeopen = 1;<font></font>
  p-&gt;nwrite = 0;<font></font>
  p-&gt;nread = 0;<font></font>
  initlock(&amp;p-&gt;lock, "pipe");<font></font>
  (*f0)-&gt;type = FD_PIPE;<font></font>
  (*f0)-&gt;readable = 1;<font></font>
  (*f0)-&gt;writable = 0;<font></font>
  (*f0)-&gt;pipe = p;<font></font>
  (*f1)-&gt;type = FD_PIPE;<font></font>
  (*f1)-&gt;readable = 0;<font></font>
  (*f1)-&gt;writable = 1;<font></font>
  (*f1)-&gt;pipe = p;<font></font>
  return 0;<font></font>
<font></font>
 bad:<font></font>
  if(p)<font></font>
    kfree((char*)p);<font></font>
  if(*f0)<font></font>
    fileclose(*f0);<font></font>
  if(*f1)<font></font>
    fileclose(*f1);<font></font>
  return -1;<font></font>
}<font></font>
</code></pre><br>
<code>pipealloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legt den Status der restlichen Implementierung fest, die Funktionen enthält </font></font><code>piperead()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>pipewrite()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>pipeclose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der eigentliche Systemaufruf </font></font><code>sys_pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist ein in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sysfile.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementierter </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Wrapper</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich empfehle, den gesamten Code zu lesen. </font><font style="vertical-align: inherit;">Die Komplexität liegt auf der Quellenebene der sechsten Ausgabe, ist aber viel einfacher und angenehmer zu lesen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 0.01</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie finden den Quellcode für Linux 0.01. </font><font style="vertical-align: inherit;">Es wird lehrreich sein, die Implementierung von Pipelines in seinem </font></font><code>fs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font><font style="vertical-align: inherit;">zu studieren </font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hier wird Inode verwendet, um die Pipeline darzustellen, aber die Pipeline selbst ist in modernem C geschrieben. Wenn Sie den Code der sechsten Ausgabe durchlaufen haben, werden Sie keine Schwierigkeiten haben. </font><font style="vertical-align: inherit;">So sieht die Funktion aus </font></font><code>write_pipe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">int write_pipe(struct m_inode * inode, char * buf, int count)<font></font>
{<font></font>
    char * b=buf;<font></font>
<font></font>
    wake_up(&amp;inode-&gt;i_wait);<font></font>
    if (inode-&gt;i_count != 2) { /* no readers */<font></font>
        current-&gt;signal |= (1&lt;&lt;(SIGPIPE-1));<font></font>
        return -1;<font></font>
    }<font></font>
    while (count--&gt;0) {<font></font>
        while (PIPE_FULL(*inode)) {<font></font>
            wake_up(&amp;inode-&gt;i_wait);<font></font>
            if (inode-&gt;i_count != 2) {<font></font>
                current-&gt;signal |= (1&lt;&lt;(SIGPIPE-1));<font></font>
                return b-buf;<font></font>
            }<font></font>
            sleep_on(&amp;inode-&gt;i_wait);<font></font>
        }<font></font>
        ((char *)inode-&gt;i_size)[PIPE_HEAD(*inode)] =<font></font>
            get_fs_byte(b++);<font></font>
        INC_PIPE( PIPE_HEAD(*inode) );<font></font>
        wake_up(&amp;inode-&gt;i_wait);<font></font>
    }<font></font>
    wake_up(&amp;inode-&gt;i_wait);<font></font>
    return b-buf;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch ohne die Definitionen von Strukturen zu betrachten, können Sie herausfinden, wie der Inode-Referenzzähler verwendet wird, um zu überprüfen, ob die Schreiboperation dazu führt </font></font><code>SIGPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zusätzlich zur Bytearbeit kann diese Funktion leicht mit den obigen Ideen korreliert werden. </font><font style="vertical-align: inherit;">Auch die Logik </font></font><code>sleep_on</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>wake_up</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sieht nicht so fremd aus.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moderne Linux-, FreeBSD-, NetBSD- und OpenBSD-Kernel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich ging schnell einige moderne Kernel durch. Keiner von ihnen hat bereits eine Festplattenimplementierung (nicht überraschend). Linux hat eine eigene Implementierung. Obwohl die drei modernen BSD-Kernel Implementierungen enthalten, die auf Code basieren, der von John Dyson geschrieben wurde, sind sie im Laufe der Jahre zu unterschiedlich geworden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Lesen von </font></font><code>fs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(unter Linux) oder </font></font><code>sys</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>kern</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>sys_pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(unter * BSD) ist eine echte Widmung erforderlich. Leistung und Unterstützung für Funktionen wie Vektor und asynchrone E / A sind heute im Code wichtig. Und die Details der Speicherzuordnung, Sperren und Kernelkonfiguration - all dies ist sehr unterschiedlich. Dies ist nicht das, was Universitäten für einen Einführungskurs in Betriebssysteme benötigen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf jeden Fall war es für mich interessant, </font><font style="vertical-align: inherit;">in all diesen so unterschiedlichen, modernen Kernen </font><font style="vertical-align: inherit;">mehrere alte Muster zu entdecken (z. B. Generieren </font></font><code>SIGPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und Zurückkehren </font></font><code>EPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beim Schreiben in eine geschlossene Pipeline). </font><font style="vertical-align: inherit;">Ich werde wahrscheinlich nie einen Live-PDP-11-Computer sehen, aber es gibt noch viel zu lernen aus dem Code, der einige Jahre vor meiner Geburt geschrieben wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der 2011 von Divi Kapoor verfasste Artikel „ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Implementierung von Pipes und FIFOs im Linux-Kernel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “ bietet einen Überblick über die (bisherige) Funktionsweise von Pipelines unter Linux. </font><font style="vertical-align: inherit;">Das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jüngste Linux-Commit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zeigt ein Pipeline-Interaktionsmodell, dessen Funktionen die Funktionen temporärer Dateien übertreffen. </font><font style="vertical-align: inherit;">und zeigt auch, wie weit die Pipelines vom „sehr konservativen Sperren“ im Unix-Kernel der sechsten Ausgabe entfernt sind.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495472/index.html">Die Umstellung auf Vegetarismus verhindert nicht, dass Menschen mit Krankheiten wie COVID-19 infiziert werden</a></li>
<li><a href="../de495474/index.html">DataGrip 2020.1: Konfigurationen starten, nach Excel exportieren, Ergebnisse im Editor und mehr</a></li>
<li><a href="../de495476/index.html">Warum der Erfolg der Atari DeepMind AI enttäuschend ist</a></li>
<li><a href="../de495478/index.html">Big and Small Data Tester: Trends, Theorie, meine Geschichte</a></li>
<li><a href="../de495480/index.html">Erstellen von Python-Bindungen für C / C ++ - Bibliotheken mit SIP. Teil 1</a></li>
<li><a href="../de495486/index.html">Neue Bedrohungen für vertrauliche Daten: Ergebnisse der globalen Umfrage von Acronis</a></li>
<li><a href="../de495490/index.html">Test- und QS-Bereich auf der DUMP 2020-Konferenz. Was erwartet Sie in diesem Jahr? Spoiler: ein Paar Schmerzmittel und Kirschen</a></li>
<li><a href="../de495492/index.html">Unreal Engine 4 iOS Game Release-Funktionen</a></li>
<li><a href="../de495494/index.html">Erstellen eines zusätzlichen Kube-Schedulers mit benutzerdefinierten Planungsregeln</a></li>
<li><a href="../de495500/index.html">Alexey Klyanin: „Bis 2018 habe ich OSM nur als Substrat in meinem Blog verwendet.“</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>