<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äç‚öïÔ∏è ü§® üêΩ Wie Unix-Pipelines implementiert werden üåè üñäÔ∏è üö≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel beschreibt die Implementierung von Pipelines im Unix-Kernel. Ich war etwas entt√§uscht von einem k√ºrzlich erschienenen Artikel mit dem T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wie Unix-Pipelines implementiert werden</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/495484/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/sl/9i/gesl9iqjuhatlmgyrdps28zgje0.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel beschreibt die Implementierung von Pipelines im Unix-Kernel. </font><font style="vertical-align: inherit;">Ich war etwas entt√§uscht von einem k√ºrzlich erschienenen Artikel mit dem Titel " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktionieren Pipelines unter Unix?" </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Ging </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um das interne Ger√§t. </font><font style="vertical-align: inherit;">Ich wurde interessiert und vergrub mich in den alten Quellen, um die Antwort zu finden.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wor√ºber reden wir?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pipelines - ‚Äûwahrscheinlich die wichtigste Erfindung unter Unix‚Äú - sind das bestimmende Merkmal der zugrunde liegenden Philosophie von Unix, kleine Programme miteinander zu kombinieren, sowie die bekannte Befehlszeile:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ echo hello | wc -c<font></font>
6<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktionalit√§t h√§ngt vom Systemaufruf des Kernels ab </font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der auf den Dokumentationsseiten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipe (7)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipe (2) beschrieben wird</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√∂rderer bieten einen unidirektionalen Interprozess-Kommunikationskanal. </font><font style="vertical-align: inherit;">Die Pipeline hat einen Eingang (Schreibende) und einen Ausgang (Leseende). </font><font style="vertical-align: inherit;">Auf den Eingang der Pipeline geschriebene Daten k√∂nnen ausgelesen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Pipeline wird mithilfe eines Aufrufs erstellt </font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der zwei Dateideskriptoren zur√ºckgibt: einer bezieht sich auf die Eingabe der Pipeline, der zweite auf die Ausgabe.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ablaufverfolgungsergebnisse des obigen Befehls veranschaulichen die Erstellung einer Pipeline und den Datenfluss durch sie von einem Prozess zum anderen:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ strace -qf -e execve,pipe,dup2,read,write \<font></font>
    sh -c 'echo hello | wc -c'<font></font>
<font></font>
execve("/bin/sh", ["sh", "-c", "echo hello | wc -c"], ‚Ä¶)<font></font>
pipe([3, 4])                            = 0<font></font>
[pid 2604795] dup2(4, 1)                = 1<font></font>
[pid 2604795] write(1, "hello\n", 6)    = 6<font></font>
[pid 2604796] dup2(3, 0)                = 0<font></font>
[pid 2604796] execve("/usr/bin/wc", ["wc", "-c"], ‚Ä¶)<font></font>
[pid 2604796] read(0, "hello\n", 16384) = 6<font></font>
[pid 2604796] write(1, "6\n", 2)        = 2<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der √ºbergeordnete Prozess ruft </font></font><code>pipe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf, um die angeh√§ngten Dateideskriptoren abzurufen. </font><font style="vertical-align: inherit;">Ein untergeordneter Prozess schreibt in einen Deskriptor, und ein anderer Prozess liest dieselben Daten aus einem anderen Deskriptor. </font><font style="vertical-align: inherit;">Der Wrapper, der dup2 verwendet, ‚Äûbenennt‚Äú die Deskriptoren 3 und 4 um, um stdin und stdout abzugleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ohne Pipelines m√ºsste die Shell das Ergebnis eines Prozesses in eine Datei schreiben und in einen anderen Prozess √ºbertragen, damit sie die Daten aus der Datei liest. </font><font style="vertical-align: inherit;">Infolgedessen w√ºrden wir mehr Ressourcen und Speicherplatz ausgeben. </font><font style="vertical-align: inherit;">Pipelines sind jedoch nicht nur deshalb gut, weil sie die Verwendung tempor√§rer Dateien vermeiden:</font></font><br>
<br>
<blockquote>      ,  <code>read(2)</code>    ,     .       ,  <code>write(2)</code>    ,           .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie die POSIX-Anforderung ist dies eine wichtige Eigenschaft: Das Schreiben in die Pipeline bis zu </font></font><code>PIPE_BUF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bytes (mindestens 512) muss atomar sein, damit Prozesse √ºber die Pipeline auf dieselbe Weise miteinander interagieren k√∂nnen wie regul√§re Dateien (die keine solchen Garantien bieten). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Verwendung einer regul√§ren Datei kann ein Prozess alle seine Ausgabedaten in diese Datei schreiben und an einen anderen Prozess √ºbertragen. </font><font style="vertical-align: inherit;">Oder Prozesse k√∂nnen im harten Parallelisierungsmodus arbeiten und einen externen Signalisierungsmechanismus (z. B. ein Semaphor) verwenden, um sich gegenseitig √ºber den Abschluss des Schreibens oder Lesens zu informieren. </font><font style="vertical-align: inherit;">F√∂rderer ersparen uns all diese Probleme.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was suchen wir?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich erkl√§re es an meinen Fingern, damit Sie sich leichter vorstellen k√∂nnen, wie der F√∂rderer funktionieren kann. </font><font style="vertical-align: inherit;">Sie m√ºssen einen Puffer und einen Status im Speicher zuweisen. </font><font style="vertical-align: inherit;">Sie ben√∂tigen Funktionen zum Hinzuf√ºgen und Entfernen von Daten zum Puffer. </font><font style="vertical-align: inherit;">Es erfordert einige Mittel, um Funktionen w√§hrend Lese- und Schreibvorg√§ngen in Dateideskriptoren aufzurufen. </font><font style="vertical-align: inherit;">Und Sperren sind erforderlich, um das oben beschriebene spezielle Verhalten zu implementieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt sind wir bereit, im hellen Licht der Lampen den Quellcode des Kernels abzufragen, um unser vages mentales Modell zu best√§tigen oder zu widerlegen. </font><font style="vertical-align: inherit;">Aber seien Sie immer auf das Unerwartete vorbereitet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wo suchen wir?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wei√ü nicht, wo sich meine Kopie des ber√ºhmten Buches " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lions-Buch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " mit Unix 6-Quellcode befindet, aber dank </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Unix Heritage Society k√∂nnen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie online nach </font><font style="vertical-align: inherit;">noch √§lteren Versionen von Unix </font><font style="vertical-align: inherit;">im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellcode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> suchen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Spaziergang durch die TUHS-Archive ist wie ein Museumsbesuch. </font><font style="vertical-align: inherit;">Wir k√∂nnen einen Blick auf unsere gemeinsame Geschichte werfen, und ich respektiere die langj√§hrigen Bem√ºhungen, all diese Materialien St√ºck f√ºr St√ºck aus alten Kassetten und Ausdrucken wiederzugewinnen. </font><font style="vertical-align: inherit;">Und ich bin mir der Fragmente, die noch fehlen, sehr bewusst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir unsere Neugier auf die alte Geschichte der F√∂rderer befriedigt haben, k√∂nnen wir uns moderne Kerne zum Vergleich ansehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úbrigens </font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist eine Systemrufnummer 42 in der Tabelle </font></font><code>sysent[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zufall?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traditionelle Unix-Kernel (1970‚Äì1974)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe </font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weder in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDP-7 Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Januar 1970) noch in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ersten Ausgabe von Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (November 1971) oder im unvollst√§ndigen Quellcode der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zweiten Ausgabe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Juni 1972) </font><font style="vertical-align: inherit;">eine Spur gefunden </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TUHS behauptet, dass die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dritte Ausgabe von Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Februar 1973) die erste Version mit Pipelines war:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die dritte Ausgabe von Unix war die neueste Version mit einem in Assemblersprache geschriebenen Kernel, aber die erste Version mit Pipelines. </font><font style="vertical-align: inherit;">Im Jahr 1973 wurde an der Verbesserung der dritten Ausgabe gearbeitet, der Kern wurde in C umgeschrieben, und so erschien die vierte Ausgabe von Unix.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einer der Leser fand einen Scan eines Dokuments, in dem Doug McIlroy die Idee vorschlug, ‚ÄûProgramme nach dem Prinzip eines Gartenschlauchs zu verbinden‚Äú.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6c/8c2/c8c/c6c8c2c8c5720d79227246af98c9b8d5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem Buch von Brian Kernighan ‚Äû </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unix: Eine Geschichte und eine Erinnerung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äú, in der Geschichte des Auftretens von F√∂rderb√§ndern, wird dieses Dokument auch erw√§hnt: ‚Äû... es hing 30 Jahre lang in meinem B√ºro bei Bell Labs an der Wand.‚Äú Hier ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Interview mit McIlroy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und eine weitere Geschichte aus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">McIlroys Arbeit aus dem Jahr 2014</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote>  Unix,        ,  ,  ,   - ,     ,       .  ,   . ,  ,  ,       .                ?           ¬´¬ª     , , -, : ¬´  !¬ª.<br>
<br>
 .        ,    ,       (    ),     .          .              .      API          ,      .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider geht der Kernel-Quellcode f√ºr die dritte Unix-Edition verloren. Und obwohl wir den Quellcode f√ºr den Kernel der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vierten Ausgabe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in C haben </font><font style="vertical-align: inherit;">, der im November 1973 ver√∂ffentlicht wurde, wurde er einige Monate vor der offiziellen Ver√∂ffentlichung ver√∂ffentlicht und enth√§lt keine Pipeline-Implementierungen. Schade, dass der Quellcode der legend√§ren Unix-Funktion m√∂glicherweise f√ºr immer verloren geht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den Text der Dokumentation </font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus beiden Versionen, sodass Sie zun√§chst die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dritte Ausgabe der</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dokumentation durchsuchen k√∂nnen </font><font style="vertical-align: inherit;">(nach bestimmten W√∂rtern, die ‚Äûmanuell‚Äú unterstrichen sind, eine Zeichenfolge von Literalen ^ H, gefolgt von Unterstrichen!). Dieses Proto ist </font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Assembler geschrieben und gibt nur einen Dateideskriptor zur√ºck, bietet jedoch bereits die erwartete Grundfunktionalit√§t:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipe</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Systemaufruf </font><font style="vertical-align: inherit;">erstellt einen Ausgabeeingabemechanismus, der als Pipeline bezeichnet wird. </font><font style="vertical-align: inherit;">Der zur√ºckgegebene Dateideskriptor kann f√ºr Lese- und Schreibvorg√§nge verwendet werden. </font><font style="vertical-align: inherit;">Wenn etwas in die Pipeline geschrieben wird, werden bis zu 504 Datenbytes gepuffert, wonach der Schreibvorgang angehalten wird. </font><font style="vertical-align: inherit;">Beim Lesen aus einer Pipeline werden gepufferte Daten erfasst.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bis zum n√§chsten Jahr wurde der Kernel in C umgeschrieben, und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipe (2) in der vierten Ausgabe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fand mit dem Prototyp " </font></font><code>pipe(fildes)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font><font style="vertical-align: inherit;">sein modernes Aussehen </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<blockquote>  <i>pipe</i>    ,   .          .  -   ,   ,   r1 (. fildes[1]),    4096  ,     .     ,   r0 (. fildes[0]),  .<br>
<br>
,      ( )   (   <i>fork</i>)         <i>read</i>  <i>write</i>.<br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Shell verf√ºgt √ºber eine Syntax zum Definieren eines linearen Arrays von Prozessen, die √ºber eine Pipeline verbunden sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leseaufrufe von einer leeren Pipeline (die keine gepufferten Daten enth√§lt) mit nur einem Ende (alle Schreibdateideskriptoren sind geschlossen) geben das "Dateiende" zur√ºck. </font><font style="vertical-align: inherit;">Das Aufzeichnen von Anrufen in einer √§hnlichen Situation wird ignoriert.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die fr√ºheste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºberlebende Pipeline-Implementierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stammt aus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der f√ºnften Ausgabe von Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Juni 1974), ist jedoch fast identisch mit der in der n√§chsten Version ver√∂ffentlichten. </font><font style="vertical-align: inherit;">Es wurden nur Kommentare hinzugef√ºgt, sodass die f√ºnfte Ausgabe √ºbersprungen werden kann.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sechste Ausgabe von Unix (1975)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir beginnen mit dem Lesen des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sechsten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unix-Quellcodes </font><font style="vertical-align: inherit;">(Mai 1975). </font><font style="vertical-align: inherit;">Vor allem dank </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lions ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es viel einfacher, es zu finden als den Quellcode fr√ºherer Versionen:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lions ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seit </font><font style="vertical-align: inherit;">vielen Jahren </font><font style="vertical-align: inherit;">das einzige Unix-Kerndokument, das au√üerhalb der W√§nde von Bell Labs verf√ºgbar ist. </font><font style="vertical-align: inherit;">Obwohl die Lizenz der sechsten Ausgabe es Lehrern erlaubte, ihren Quellcode zu verwenden, schloss die Lizenz der siebten Ausgabe diese M√∂glichkeit aus, so dass das Buch in Form von illegalen maschinengeschriebenen Kopien verteilt wurde.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heute k√∂nnen Sie eine Nachdruckkopie des Buches kaufen, auf dessen Cover die Sch√ºler beim Fotokopierer gezeigt werden. Und dank Warren Tumi (der das TUHS-Projekt ins Leben gerufen hat) k√∂nnen Sie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDF-Datei mit dem Quellcode f√ºr die sechste Ausgabe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herunterladen </font><font style="vertical-align: inherit;">. Ich m√∂chte Ihnen eine Vorstellung davon geben, wie viel Aufwand beim Erstellen der Datei erforderlich war:</font></font><br>
<br>
<blockquote> 15       ,   <i>Lions</i>,             . TUHS   ,         .   1988-      9 ,        PDP11.   ,   ,      /usr/src/,       1979- ,     .        PWB,   .<br>
<br>
            .     ,    ,    +=   =+. -  ,  -   ,    .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und heute k√∂nnen wir online auf TUHS den Quellcode der sechsten Ausgabe aus dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Archiv</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">, an dem Dennis Ritchie beteiligt war</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf den ersten Blick ist das Hauptmerkmal des C-Codes vor der Kernigan- und Richie-Zeit √ºbrigens seine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K√ºrze</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nicht so oft schaffe ich es, Codefragmente ohne umfangreiche Bearbeitung einzubetten, um sie an einen relativ engen Anzeigebereich auf meiner Website anzupassen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Anfang von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/usr/sys/ken/pipe.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> steht ein erkl√§render Kommentar (und ja, es gibt auch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ usr / sys / dmr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Max allowable buffering per pipe.<font></font>
 * This is also the max size of the<font></font>
 * file created to implement the pipe.<font></font>
 * If this size is bigger than 4096,<font></font>
 * pipes will be implemented in LARG<font></font>
 * files, which is probably not good.<font></font>
 */<font></font>
#define    PIPSIZ    4096<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Puffergr√∂√üe hat sich seit der vierten Ausgabe nicht ge√§ndert. Aber hier, ohne √∂ffentliche Dokumentation, sehen wir, dass einmal die Pipelines Dateien als Backup-Speicher verwendet haben! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LARG-Dateien entsprechen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem LARG-Inode-Flag</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das vom "High-Addressing-Algorithmus" zur Verarbeitung </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indirekter Bl√∂cke</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet wird, um gr√∂√üere Dateisysteme zu unterst√ºtzen. Da Ken sagte, es sei besser, sie nicht zu benutzen, nehme ich gerne sein Wort daf√ºr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der eigentliche Systemaufruf </font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * The sys-pipe entry.<font></font>
 * Allocate an inode on the root device.<font></font>
 * Allocate 2 file structures.<font></font>
 * Put it all together with flags.<font></font>
 */<font></font>
pipe()<font></font>
{<font></font>
    register *ip, *rf, *wf;<font></font>
    int r;<font></font>
<font></font>
    ip = ialloc(rootdev);<font></font>
    if(ip == NULL)<font></font>
        return;<font></font>
    rf = falloc();<font></font>
    if(rf == NULL) {<font></font>
        iput(ip);<font></font>
        return;<font></font>
    }<font></font>
    r = u.u_ar0[R0];<font></font>
    wf = falloc();<font></font>
    if(wf == NULL) {<font></font>
        rf-&gt;f_count = 0;<font></font>
        u.u_ofile[r] = NULL;<font></font>
        iput(ip);<font></font>
        return;<font></font>
    }<font></font>
    u.u_ar0[R1] = u.u_ar0[R0]; /* wf's fd */<font></font>
    u.u_ar0[R0] = r;           /* rf's fd */<font></font>
    wf-&gt;f_flag = FWRITE|FPIPE;<font></font>
    wf-&gt;f_inode = ip;<font></font>
    rf-&gt;f_flag = FREAD|FPIPE;<font></font>
    rf-&gt;f_inode = ip;<font></font>
    ip-&gt;i_count = 2;<font></font>
    ip-&gt;i_flag = IACC|IUPD;<font></font>
    ip-&gt;i_mode = IALLOC;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Kommentar beschreibt klar, was hier passiert. Das Verstehen des Codes ist jedoch nicht einfach, teilweise aufgrund der M√∂glichkeit, mithilfe von ¬´ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a struct user u</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font><font style="vertical-align: inherit;">Parameter von Systemaufrufen und R√ºckgabewerten zu </font><font style="vertical-align: inherit;">registrieren </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und zu </font></font><code>R1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºbertragen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir, mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ialloc () </font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inode (Inode </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">)</font></a><font style="vertical-align: inherit;"> auf der Festplatte zu platzieren </font><font style="vertical-align: inherit;">und mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falloc ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zwei </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dateien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Speicher </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">abzulegen</font></a><font style="vertical-align: inherit;"> . Wenn alles gut geht, setzen wir Flags, um diese Dateien als die beiden Enden der Pipeline zu definieren, zeigen sie auf denselben Inode (dessen Referenzanzahl 2 ist) und markieren den Inode als ge√§ndert und verwendet. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Achten Sie</font></a><font style="vertical-align: inherit;"> auf Aufrufe von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iput ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Fehlerpfaden, um die Referenzanzahl im neuen Inode zu verringern. </font></font><br>
<br>
<code>pipe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss </font><font style="vertical-align: inherit;">die Dateideskriptornummern zum Lesen und Schreiben </font><font style="vertical-align: inherit;">durchlaufen </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>R1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zur√ºckgeben. </font></font><code>falloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt einen Zeiger auf die Dateistruktur zur√ºck, gibt aber auch √ºber den </font></font><code>u.u_ar0[R0]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dateideskriptor zur√ºck. Das hei√üt, der Code wird </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Lesen </font><font style="vertical-align: inherit;">in einem </font><font style="vertical-align: inherit;">Dateideskriptor gespeichert und weist direkt </font></font><code>u.u_ar0[R0]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach dem zweiten Aufruf </font><font style="vertical-align: inherit;">einen Deskriptor zum Schreiben zu </font></font><code>falloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Flag </font></font><code>FPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das wir beim Erstellen der Pipeline setzen, steuert das Verhalten der Funktion </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rdwr () in sys2.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die bestimmte E / A-E / A-Routinen aufruft:</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * common code for read and write calls:<font></font>
 * check permissions, set base, count, and offset,<font></font>
 * and switch out to readi, writei, or pipe code.<font></font>
 */<font></font>
rdwr(mode)<font></font>
{<font></font>
    register *fp, m;<font></font>
<font></font>
    m = mode;<font></font>
    fp = getf(u.u_ar0[R0]);<font></font>
        /* ‚Ä¶ */<font></font>
<font></font>
    if(fp-&gt;f_flag&amp;FPIPE) {<font></font>
        if(m==FREAD)<font></font>
            readp(fp); else<font></font>
            writep(fp);<font></font>
    }<font></font>
        /* ‚Ä¶ */<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann </font><font style="vertical-align: inherit;">liest </font><font style="vertical-align: inherit;">die Funktion </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Daten aus der Pipeline. </font><font style="vertical-align: inherit;">Es ist jedoch besser, die Implementierung zu verfolgen </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Erneut wurde der Code aufgrund der Besonderheiten der Argument√ºbertragungsvereinbarung komplizierter, aber einige Details k√∂nnen weggelassen werden.</font></font><br>
<br>
<pre><code class="plaintext hljs">writep(fp)<font></font>
{<font></font>
    register *rp, *ip, c;<font></font>
<font></font>
    rp = fp;<font></font>
    ip = rp-&gt;f_inode;<font></font>
    c = u.u_count;<font></font>
<font></font>
loop:<font></font>
    /* If all done, return. */<font></font>
<font></font>
    plock(ip);<font></font>
    if(c == 0) {<font></font>
        prele(ip);<font></font>
        u.u_count = 0;<font></font>
        return;<font></font>
    }<font></font>
<font></font>
    /*<font></font>
     * If there are not both read and write sides of the<font></font>
     * pipe active, return error and signal too.<font></font>
     */<font></font>
<font></font>
    if(ip-&gt;i_count &lt; 2) {<font></font>
        prele(ip);<font></font>
        u.u_error = EPIPE;<font></font>
        psignal(u.u_procp, SIGPIPE);<font></font>
        return;<font></font>
    }<font></font>
<font></font>
    /*<font></font>
     * If the pipe is full, wait for reads to deplete<font></font>
     * and truncate it.<font></font>
     */<font></font>
<font></font>
    if(ip-&gt;i_size1 == PIPSIZ) {<font></font>
        ip-&gt;i_mode =| IWRITE;<font></font>
        prele(ip);<font></font>
        sleep(ip+1, PPIPE);<font></font>
        goto loop;<font></font>
    }<font></font>
<font></font>
    /* Write what is possible and loop back. */<font></font>
<font></font>
    u.u_offset[0] = 0;<font></font>
    u.u_offset[1] = ip-&gt;i_size1;<font></font>
    u.u_count = min(c, PIPSIZ-u.u_offset[1]);<font></font>
    c =- u.u_count;<font></font>
    writei(ip);<font></font>
    prele(ip);<font></font>
    if(ip-&gt;i_mode&amp;IREAD) {<font></font>
        ip-&gt;i_mode =&amp; ~IREAD;<font></font>
        wakeup(ip+2);<font></font>
    }<font></font>
    goto loop;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wollen Bytes in die Eingabe der Pipeline schreiben </font></font><code>u.u_count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zuerst m√ºssen wir den Inode sperren (siehe unten </font></font><code>plock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>prele</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úberpr√ºfen Sie dann den Inode-Referenzz√§hler. </font><font style="vertical-align: inherit;">W√§hrend beide Enden der Pipeline offen bleiben, sollte der Z√§hler 2 sein. Wir behalten eine Verbindung (out </font></font><code>rp-&gt;f_inode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) bei. Wenn der Z√§hler also kleiner als 2 ist, sollte dies bedeuten, dass der Lesevorgang sein Ende der Pipeline geschlossen hat. </font><font style="vertical-align: inherit;">Mit anderen Worten, wir versuchen, in einer geschlossenen Pipeline zu schreiben, und dies ist ein Fehler. </font><font style="vertical-align: inherit;">Der Fehlercode </font></font><code>EPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und das Signal wurden erstmals </font></font><code>SIGPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der sechsten Ausgabe von Unix ver√∂ffentlicht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber selbst wenn der F√∂rderer ge√∂ffnet ist, kann er voll sein. In diesem Fall entfernen wir die Sperre und schlafen ein, in der Hoffnung, dass ein anderer Prozess aus der Pipeline liest und gen√ºgend Speicherplatz darin freigibt. Nach dem Aufwachen kehren wir zum Anfang zur√ºck, blockieren erneut die Sperre und starten einen neuen Aufnahmezyklus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn in der Pipeline gen√ºgend freier Speicherplatz vorhanden ist, schreiben wir Daten mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">writei () darauf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Der Parameter </font></font><code>i_size1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Inode (bei einer leeren Pipeline kann 0 sein) gibt das Ende der Daten an, die bereits enthalten sind. Wenn gen√ºgend Aufnahmeraum vorhanden ist, k√∂nnen wir den F√∂rderer von </font></font><code>i_size1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis </font><font style="vertical-align: inherit;">f√ºllen</font></font><code>PIPESIZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dann entfernen wir die Sperre und versuchen, jeden Prozess zu aktivieren, der auf die Gelegenheit wartet, aus der Pipeline zu lesen. Wir gehen zur√ºck zum Anfang, um zu sehen, ob wir es geschafft haben, so viele Bytes zu schreiben, wie wir brauchten. Wenn dies fehlgeschlagen ist, beginnen wir einen neuen Aufnahmezyklus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typischerweise </font></font><code>i_mode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird ein Inode </font><font style="vertical-align: inherit;">wird Parameter </font><font style="vertical-align: inherit;">speichern Berechtigungen verwendet </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Im Fall von Pipelines signalisieren wir jedoch, dass ein Prozess darauf wartet, mit Bits </font></font><code>IREAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bzw. </font><font style="vertical-align: inherit;">zu schreiben oder zu lesen </font></font><code>IWRITE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ein Prozess setzt ein Flag und ruft auf </font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und es wird erwartet, dass in Zukunft ein anderer Prozess </font><font style="vertical-align: inherit;">aufruft </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wirkliche Magie passiert in </font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie sind in </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">slp.c</font></a><font style="vertical-align: inherit;"> implementiert</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die Quelle des ber√ºhmten Kommentars: "Es wird nicht erwartet, dass Sie dies verstehen." </font><font style="vertical-align: inherit;">Gl√ºcklicherweise m√ºssen wir den Code nicht verstehen, sehen Sie sich nur einige Kommentare an:</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Give up the processor till a wakeup occurs<font></font>
 * on chan, at which time the process<font></font>
 * enters the scheduling queue at priority pri.<font></font>
 * The most important effect of pri is that when<font></font>
 * pri&lt;0 a signal cannot disturb the sleep;<font></font>
 * if pri&gt;=0 signals will be processed.<font></font>
 * Callers of this routine must be prepared for<font></font>
 * premature return, and check that the reason for<font></font>
 * sleeping has gone away.<font></font>
 */<font></font>
sleep(chan, pri) /* ‚Ä¶ */<font></font>
<font></font>
/*<font></font>
 * Wake up all processes sleeping on chan.<font></font>
 */<font></font>
wakeup(chan) /* ‚Ä¶ */<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Prozess, der </font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr einen bestimmten Kanal aufgerufen wird, kann sp√§ter von einem anderen Prozess geweckt werden, der </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr denselben Kanal aufgerufen wird. </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">koordinieren ihre Aktionen durch solche gepaarten Anrufe. </font><font style="vertical-align: inherit;">Bitte beachten Sie, dass </font><font style="vertical-align: inherit;">beim Anrufen </font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer Vorrang hat </font><font style="vertical-align: inherit;">, damit jeder </font><font style="vertical-align: inherit;">das Signal unterbrechen kann. </font><font style="vertical-align: inherit;">
Jetzt haben wir alles, um die Funktion zu verstehen </font><font style="vertical-align: inherit;">:</font></font><code>PPIPE</code><font style="vertical-align: inherit;"></font><code>sleep()</code><font style="vertical-align: inherit;"></font><code>sleep()</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>readp()</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="plaintext hljs">readp(fp)<font></font>
int *fp;<font></font>
{<font></font>
    register *rp, *ip;<font></font>
<font></font>
    rp = fp;<font></font>
    ip = rp-&gt;f_inode;<font></font>
<font></font>
loop:<font></font>
    /* Very conservative locking. */<font></font>
<font></font>
    plock(ip);<font></font>
<font></font>
    /*<font></font>
     * If the head (read) has caught up with<font></font>
     * the tail (write), reset both to 0.<font></font>
     */<font></font>
<font></font>
    if(rp-&gt;f_offset[1] == ip-&gt;i_size1) {<font></font>
        if(rp-&gt;f_offset[1] != 0) {<font></font>
            rp-&gt;f_offset[1] = 0;<font></font>
            ip-&gt;i_size1 = 0;<font></font>
            if(ip-&gt;i_mode&amp;IWRITE) {<font></font>
                ip-&gt;i_mode =&amp; ~IWRITE;<font></font>
                wakeup(ip+1);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        /*<font></font>
         * If there are not both reader and<font></font>
         * writer active, return without<font></font>
         * satisfying read.<font></font>
         */<font></font>
<font></font>
        prele(ip);<font></font>
        if(ip-&gt;i_count &lt; 2)<font></font>
            return;<font></font>
        ip-&gt;i_mode =| IREAD;<font></font>
        sleep(ip+2, PPIPE);<font></font>
        goto loop;<font></font>
    }<font></font>
<font></font>
    /* Read and return */<font></font>
<font></font>
    u.u_offset[0] = 0;<font></font>
    u.u_offset[1] = rp-&gt;f_offset[1];<font></font>
    readi(ip);<font></font>
    rp-&gt;f_offset[1] = u.u_offset[1];<font></font>
    prele(ip);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√∂glicherweise f√§llt es Ihnen leichter, diese Funktion von unten nach oben zu lesen. Der Zweig "Lesen und Zur√ºckgeben" wird normalerweise verwendet, wenn sich Daten in der Pipeline befinden. In diesem Fall verwenden wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readi (),</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um ab dem aktuellen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Lesevorgang</font></a><font style="vertical-align: inherit;"> so viele Daten </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">zu</font></a><font style="vertical-align: inherit;"> lesen, wie verf√ºgbar sind </font></font><code>f_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und aktualisieren dann den Wert des entsprechenden Offsets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei nachfolgenden Lesevorg√§ngen ist die Pipeline leer, wenn der Leseversatz den Wert des </font></font><code>i_size1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inodes erreicht hat. Wir setzen die Position auf 0 zur√ºck und versuchen, jeden Prozess zu aktivieren, der in die Pipeline geschrieben werden soll. Wir wissen, dass der F√∂rderer, wenn er voll ist, </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einschlafen wird </font></font><code>ip+1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Und jetzt, da die Pipeline leer ist, k√∂nnen wir sie aufwecken, damit sie ihren Aufnahmezyklus fortsetzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn es nichts zu lesen gibt, </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann es eine Flagge setzen </font></font><code>IREAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und einschlafen</font></font><code>ip+2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir wissen, was ihn wecken wird, </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn er einige Daten in die Pipeline schreibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Kommentare zu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readi () und writei ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> helfen zu verstehen, dass </font></font><code>u</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">Parameter nicht durch " </font><font style="vertical-align: inherit;">" √ºbergeben k√∂nnen </font><font style="vertical-align: inherit;">, sondern </font><font style="vertical-align: inherit;">wie √ºbliche E / A-Funktionen behandeln k√∂nnen, die eine Datei, Position, Puffer im Speicher und die Anzahl der zu lesenden oder zu schreibenden Bytes z√§hlen .</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Read the file corresponding to<font></font>
 * the inode pointed at by the argument.<font></font>
 * The actual read arguments are found<font></font>
 * in the variables:<font></font>
 *    u_base        core address for destination<font></font>
 *    u_offset    byte offset in file<font></font>
 *    u_count        number of bytes to read<font></font>
 *    u_segflg    read to kernel/user<font></font>
 */<font></font>
readi(aip)<font></font>
struct inode *aip;<font></font>
/* ‚Ä¶ */<font></font>
<font></font>
/*<font></font>
 * Write the file corresponding to<font></font>
 * the inode pointed at by the argument.<font></font>
 * The actual write arguments are found<font></font>
 * in the variables:<font></font>
 *    u_base        core address for source<font></font>
 *    u_offset    byte offset in file<font></font>
 *    u_count        number of bytes to write<font></font>
 *    u_segflg    write to kernel/user<font></font>
 */<font></font>
writei(aip)<font></font>
struct inode *aip;<font></font>
/* ‚Ä¶ */<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie f√ºr die ‚Äûkonservativen‚Äú lock, dann </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Block Inode , </font><font style="vertical-align: inherit;">solange sie einen Job zu </font><font style="vertical-align: inherit;">beenden oder nicht bekommen , </font><font style="vertical-align: inherit;">das Ergebnis (dh die Ursache </font></font><code>wakeup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><code>plock()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und sie </font></font><code>prele()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktionieren einfach: Verwenden Sie einen anderen Satz von Aufrufen </font></font><code>sleep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>wakeup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erm√∂glichen Sie uns, jeden Prozess zu aktivieren, der eine Sperre ben√∂tigt, die wir gerade entfernt haben:</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Lock a pipe.<font></font>
 * If its already locked, set the WANT bit and sleep.<font></font>
 */<font></font>
plock(ip)<font></font>
int *ip;<font></font>
{<font></font>
    register *rp;<font></font>
<font></font>
    rp = ip;<font></font>
    while(rp-&gt;i_flag&amp;ILOCK) {<font></font>
        rp-&gt;i_flag =| IWANT;<font></font>
        sleep(rp, PPIPE);<font></font>
    }<font></font>
    rp-&gt;i_flag =| ILOCK;<font></font>
}<font></font>
<font></font>
/*<font></font>
 * Unlock a pipe.<font></font>
 * If WANT bit is on, wakeup.<font></font>
 * This routine is also used to unlock inodes in general.<font></font>
 */<font></font>
prele(ip)<font></font>
int *ip;<font></font>
{<font></font>
    register *rp;<font></font>
<font></font>
    rp = ip;<font></font>
    rp-&gt;i_flag =&amp; ~ILOCK;<font></font>
    if(rp-&gt;i_flag&amp;IWANT) {<font></font>
        rp-&gt;i_flag =&amp; ~IWANT;<font></font>
        wakeup(rp);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst konnte ich nicht verstehen, warum es </font><font style="vertical-align: inherit;">vor dem Anruf </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht </font></font><code>prele(ip)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anrief </font></font><code>wakeup(ip+1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Das erste, was </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in seiner Schleife verursacht wird, ist, dass es </font></font><code>plock(ip)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu einem Deadlock f√ºhrt, wenn </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es seinen Block noch nicht entfernt hat, so dass der Code irgendwie korrekt funktionieren muss. Wenn Sie es sich ansehen </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird klar, dass er den Schlafprozess nur als zur Ausf√ºhrung bereit markiert, damit er in Zukunft </font></font><code>sched()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wirklich gestartet wird. Es </font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verursacht </font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entsperrt, setzt </font></font><code>IREAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ruft </font></font><code>sleep(ip+2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- all dies, bevor </font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Zyklus fortgesetzt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit ist die Beschreibung der F√∂rderer in der sechsten Ausgabe abgeschlossen. Einfacher Code, weitreichende Konsequenzen. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siebte Ausgabe von Unix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Januar 1979) war die neue Hauptversion (vier Jahre sp√§ter), in der viele neue Anwendungen und Kernel-Eigenschaften erschienen. </font><font style="vertical-align: inherit;">Es gab auch signifikante √Ñnderungen im Zusammenhang mit der Verwendung von Typguss, Union'ov und typisierten Zeigern auf Strukturen. </font><font style="vertical-align: inherit;">Der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipeline-Code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat sich jedoch nicht wesentlich ge√§ndert. </font><font style="vertical-align: inherit;">Wir k√∂nnen diese Ausgabe √ºberspringen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xv6, ein einfacher Unix-f√∂rmiger Kernel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font><font style="vertical-align: inherit;">sechste Ausgabe von Unix hat die </font><font style="vertical-align: inherit;">Erstellung des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xv6-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kerns beeinflusst </font><font style="vertical-align: inherit;">, ist jedoch in modernem C f√ºr die Ausf√ºhrung auf x86-Prozessoren geschrieben. Der Code ist leicht zu lesen, es ist klar. Im Gegensatz zu Unix-Quellen mit TUHS k√∂nnen Sie es au√üerdem kompilieren, √§ndern und auf etwas anderem als PDP 11/70 ausf√ºhren. Daher wird dieser Kern an Universit√§ten h√§ufig als Lehrmaterial f√ºr Betriebssysteme verwendet. Quellen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sind auf Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code enth√§lt eine √ºbersichtliche und durchdachte Implementierung von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pipe.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die durch einen Puffer im Speicher anstelle von Inode auf der Festplatte gesichert wird. Hier gebe ich nur die Definition von "strukturelle Pipeline" und Funktion </font></font><code>pipealloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">#define PIPESIZE 512<font></font>
<font></font>
struct pipe {<font></font>
  struct spinlock lock;<font></font>
  char data[PIPESIZE];<font></font>
  uint nread;     // number of bytes read<font></font>
  uint nwrite;    // number of bytes written<font></font>
  int readopen;   // read fd is still open<font></font>
  int writeopen;  // write fd is still open<font></font>
};<font></font>
<font></font>
int<font></font>
pipealloc(struct file **f0, struct file **f1)<font></font>
{<font></font>
  struct pipe *p;<font></font>
<font></font>
  p = 0;<font></font>
  *f0 = *f1 = 0;<font></font>
  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)<font></font>
    goto bad;<font></font>
  if((p = (struct pipe*)kalloc()) == 0)<font></font>
    goto bad;<font></font>
  p-&gt;readopen = 1;<font></font>
  p-&gt;writeopen = 1;<font></font>
  p-&gt;nwrite = 0;<font></font>
  p-&gt;nread = 0;<font></font>
  initlock(&amp;p-&gt;lock, "pipe");<font></font>
  (*f0)-&gt;type = FD_PIPE;<font></font>
  (*f0)-&gt;readable = 1;<font></font>
  (*f0)-&gt;writable = 0;<font></font>
  (*f0)-&gt;pipe = p;<font></font>
  (*f1)-&gt;type = FD_PIPE;<font></font>
  (*f1)-&gt;readable = 0;<font></font>
  (*f1)-&gt;writable = 1;<font></font>
  (*f1)-&gt;pipe = p;<font></font>
  return 0;<font></font>
<font></font>
 bad:<font></font>
  if(p)<font></font>
    kfree((char*)p);<font></font>
  if(*f0)<font></font>
    fileclose(*f0);<font></font>
  if(*f1)<font></font>
    fileclose(*f1);<font></font>
  return -1;<font></font>
}<font></font>
</code></pre><br>
<code>pipealloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legt den Status der restlichen Implementierung fest, die Funktionen enth√§lt </font></font><code>piperead()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>pipewrite()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>pipeclose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der eigentliche Systemaufruf </font></font><code>sys_pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist ein in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sysfile.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementierter </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Wrapper</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich empfehle, den gesamten Code zu lesen. </font><font style="vertical-align: inherit;">Die Komplexit√§t liegt auf der Quellenebene der sechsten Ausgabe, ist aber viel einfacher und angenehmer zu lesen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 0.01</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie finden den Quellcode f√ºr Linux 0.01. </font><font style="vertical-align: inherit;">Es wird lehrreich sein, die Implementierung von Pipelines in seinem </font></font><code>fs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font><font style="vertical-align: inherit;">zu studieren </font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hier wird Inode verwendet, um die Pipeline darzustellen, aber die Pipeline selbst ist in modernem C geschrieben. Wenn Sie den Code der sechsten Ausgabe durchlaufen haben, werden Sie keine Schwierigkeiten haben. </font><font style="vertical-align: inherit;">So sieht die Funktion aus </font></font><code>write_pipe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">int write_pipe(struct m_inode * inode, char * buf, int count)<font></font>
{<font></font>
    char * b=buf;<font></font>
<font></font>
    wake_up(&amp;inode-&gt;i_wait);<font></font>
    if (inode-&gt;i_count != 2) { /* no readers */<font></font>
        current-&gt;signal |= (1&lt;&lt;(SIGPIPE-1));<font></font>
        return -1;<font></font>
    }<font></font>
    while (count--&gt;0) {<font></font>
        while (PIPE_FULL(*inode)) {<font></font>
            wake_up(&amp;inode-&gt;i_wait);<font></font>
            if (inode-&gt;i_count != 2) {<font></font>
                current-&gt;signal |= (1&lt;&lt;(SIGPIPE-1));<font></font>
                return b-buf;<font></font>
            }<font></font>
            sleep_on(&amp;inode-&gt;i_wait);<font></font>
        }<font></font>
        ((char *)inode-&gt;i_size)[PIPE_HEAD(*inode)] =<font></font>
            get_fs_byte(b++);<font></font>
        INC_PIPE( PIPE_HEAD(*inode) );<font></font>
        wake_up(&amp;inode-&gt;i_wait);<font></font>
    }<font></font>
    wake_up(&amp;inode-&gt;i_wait);<font></font>
    return b-buf;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch ohne die Definitionen von Strukturen zu betrachten, k√∂nnen Sie herausfinden, wie der Inode-Referenzz√§hler verwendet wird, um zu √ºberpr√ºfen, ob die Schreiboperation dazu f√ºhrt </font></font><code>SIGPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zus√§tzlich zur Bytearbeit kann diese Funktion leicht mit den obigen Ideen korreliert werden. </font><font style="vertical-align: inherit;">Auch die Logik </font></font><code>sleep_on</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>wake_up</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sieht nicht so fremd aus.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moderne Linux-, FreeBSD-, NetBSD- und OpenBSD-Kernel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich ging schnell einige moderne Kernel durch. Keiner von ihnen hat bereits eine Festplattenimplementierung (nicht √ºberraschend). Linux hat eine eigene Implementierung. Obwohl die drei modernen BSD-Kernel Implementierungen enthalten, die auf Code basieren, der von John Dyson geschrieben wurde, sind sie im Laufe der Jahre zu unterschiedlich geworden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Lesen von </font></font><code>fs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(unter Linux) oder </font></font><code>sys</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>kern</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>sys_pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(unter * BSD) ist eine echte Widmung erforderlich. Leistung und Unterst√ºtzung f√ºr Funktionen wie Vektor und asynchrone E / A sind heute im Code wichtig. Und die Details der Speicherzuordnung, Sperren und Kernelkonfiguration - all dies ist sehr unterschiedlich. Dies ist nicht das, was Universit√§ten f√ºr einen Einf√ºhrungskurs in Betriebssysteme ben√∂tigen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf jeden Fall war es f√ºr mich interessant, </font><font style="vertical-align: inherit;">in all diesen so unterschiedlichen, modernen Kernen </font><font style="vertical-align: inherit;">mehrere alte Muster zu entdecken (z. B. Generieren </font></font><code>SIGPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und Zur√ºckkehren </font></font><code>EPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beim Schreiben in eine geschlossene Pipeline). </font><font style="vertical-align: inherit;">Ich werde wahrscheinlich nie einen Live-PDP-11-Computer sehen, aber es gibt noch viel zu lernen aus dem Code, der einige Jahre vor meiner Geburt geschrieben wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der 2011 von Divi Kapoor verfasste Artikel ‚Äû </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Implementierung von Pipes und FIFOs im Linux-Kernel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äú bietet einen √úberblick √ºber die (bisherige) Funktionsweise von Pipelines unter Linux. </font><font style="vertical-align: inherit;">Das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j√ºngste Linux-Commit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zeigt ein Pipeline-Interaktionsmodell, dessen Funktionen die Funktionen tempor√§rer Dateien √ºbertreffen. </font><font style="vertical-align: inherit;">und zeigt auch, wie weit die Pipelines vom ‚Äûsehr konservativen Sperren‚Äú im Unix-Kernel der sechsten Ausgabe entfernt sind.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495472/index.html">Die Umstellung auf Vegetarismus verhindert nicht, dass Menschen mit Krankheiten wie COVID-19 infiziert werden</a></li>
<li><a href="../de495474/index.html">DataGrip 2020.1: Konfigurationen starten, nach Excel exportieren, Ergebnisse im Editor und mehr</a></li>
<li><a href="../de495476/index.html">Warum der Erfolg der Atari DeepMind AI entt√§uschend ist</a></li>
<li><a href="../de495478/index.html">Big and Small Data Tester: Trends, Theorie, meine Geschichte</a></li>
<li><a href="../de495480/index.html">Erstellen von Python-Bindungen f√ºr C / C ++ - Bibliotheken mit SIP. Teil 1</a></li>
<li><a href="../de495486/index.html">Neue Bedrohungen f√ºr vertrauliche Daten: Ergebnisse der globalen Umfrage von Acronis</a></li>
<li><a href="../de495490/index.html">Test- und QS-Bereich auf der DUMP 2020-Konferenz. Was erwartet Sie in diesem Jahr? Spoiler: ein Paar Schmerzmittel und Kirschen</a></li>
<li><a href="../de495492/index.html">Unreal Engine 4 iOS Game Release-Funktionen</a></li>
<li><a href="../de495494/index.html">Erstellen eines zus√§tzlichen Kube-Schedulers mit benutzerdefinierten Planungsregeln</a></li>
<li><a href="../de495500/index.html">Alexey Klyanin: ‚ÄûBis 2018 habe ich OSM nur als Substrat in meinem Blog verwendet.‚Äú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>