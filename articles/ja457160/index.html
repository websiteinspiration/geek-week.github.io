<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍚 🏇🏽 👧🏻 C ++でデリゲートを実装する私のアプローチ：実行時に不明なパラメーターで関数を呼び出す 🚅 🖌️ 🚡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="バックグラウンド
 C ++言語が好きです。私はこれが私の好きな言語だと言ってもいいでしょう。さらに、私は.NETテクノロジーを開発に使用しており、その中でのアイデアの多くは、私の意見では、単に驚くべきものです。アイデアを思いついたら、C ++でリフレクションと動的関数呼び出しのいくつかの手段を実装...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++でデリゲートを実装する私のアプローチ：実行時に不明なパラメーターで関数を呼び出す</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457160/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックグラウンド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++言語が好きです。私はこれが私の好きな言語だと言ってもいいでしょう。さらに、私は.NETテクノロジーを開発に使用しており、その中でのアイデアの多くは、私の意見では、単に驚くべきものです。アイデアを思いついたら、C ++でリフレクションと動的関数呼び出しのいくつかの手段を実装する方法は？私は本当に、C ++に、未知の数のパラメーターとその型を使用してデリゲートを呼び出すようなCLIの利点が欲しいと思っていました。これは、たとえば、関数を呼び出す必要があるデータ型が事前にわからない場合に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、デリゲートの完全な模倣は複雑すぎるため、この記事では、ライブラリの一般的なアーキテクチャと、言語で直接サポートされていないものを扱うときに発生するいくつかの重要な問題の解決策のみを示します。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイル時に不特定数のパラメーターと不明な型を使用して関数を呼び出す</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これはC ++の主な問題であり、それほど簡単には解決できません。</font><font style="vertical-align: inherit;">もちろん、C ++にはC- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">varargs</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から継承されたツールがあり、</font><font style="vertical-align: inherit;">おそらくこれが最初に頭に浮かぶものです...しかし、それらは最初はタイプセーフでない性質（Cの多くのものと同様）のため、適合しません。次に、そのような引数を使用するときは、引数の型を事前に知っておく必要があります。</font><font style="vertical-align: inherit;">ただし、ほぼ確実に、これが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">varargsの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての問題ではありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一般に、このツールは私たちのアシスタントではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、この問題の解決に役立つツールをリストします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std ::任意</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17以降、言語にはあらゆるもののための素晴らしいコンテナーコンテナー</font><font style="vertical-align: inherit;">があります。CLIの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Object</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">との</font><font style="vertical-align: inherit;">類似点</font><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: any</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。このコンテナは、何でも、そしてどのようにでも効率的に格納できます。 -標準では、小さなオブジェクトを直接格納することを推奨していますが、大きなオブジェクトは既に動的メモリに格納できます（この動作は必須ではありませんが、MicrosoftはこれをC ++実装で行ったので、朗報です）。そして、System.Objectが継承関係に関与しているため（ "is a"）、std :: anyがメンバーシップ関係に関与しているため（ "has a"）、それだけが類似性と呼ばれます。データに加えて、コンテナーにはオブジェクト</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: type_info-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナー内にオブジェクトが「存在する」型に関するRTTI </font><font style="vertical-align: inherit;">へのポインターが含まれています</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;any&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ヘッダーファイル全体がコンテナに割り当てられています</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナからオブジェクトを「プル」する</font><font style="vertical-align: inherit;">には、オブジェクトへの参照を返す</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: any_cast（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンプレート関数を使用する必要があり</font><font style="vertical-align: inherit;">ます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用例：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;any&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">any_test</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-built_in">std</span>::any obj = <span class="hljs-number">5</span>;
	<span class="hljs-keyword">int</span> from_any = <span class="hljs-built_in">std</span>::any_cast&lt;<span class="hljs-keyword">int</span>&gt;(obj);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエストされたタイプがオブジェクトがコンテナ内に持っているものと一致しない場合、例外</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: bad_any_castがスローされ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
加えて、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意:: STD</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STD :: bad_any_castクラス</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STD :: any_cast機能</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ヘッダファイルにテンプレート関数がある</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STD :: make_any</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と同様</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のstd :: make_shared</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STD :: make_pair</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この種のおよび他の機能は。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTTI</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、実行時に型情報なしで動的関数呼び出しを実装することは、C ++では実際的に非現実的です。結局のところ、正しい型が渡されたかどうかを何らかの方法で確認する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++でのRTTIのプリミティブサポートは、かなり前から存在しています。しかし、問題の事実はその原始的なものです-装飾された名前と装飾されていない名前を除いて、タイプについてほとんど学ぶことができません。また、タイプを相互に比較することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、「RTTI」という用語は、多形タイプに関連して使用されます。</font><font style="vertical-align: inherit;">ただし、ここではこの用語をより広い意味で使用します。</font><font style="vertical-align: inherit;">たとえば、各型は実行時に型に関する情報を持っているという事実を考慮します（ただし、ポリモーフィック型とは異なり、コンパイル時に静的にしか取得できません）。</font><font style="vertical-align: inherit;">したがって、実行時に非多形型（トートロジーは申し訳ありません）でも型を比較す​​ることが可能です（必要です）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RTTIには</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: type_infoクラス</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してアクセスできます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このクラスは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;typeinfo&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘッダーファイルにあります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このクラスのオブジェクトへの参照は、（少なくとも今のところ）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">typeid（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子を使用してのみ取得できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアを実現するために必要な言語のもう1つの非常に重要な機能は、テンプレートです。</font><font style="vertical-align: inherit;">このツールは非常に強力で非常に困難であり、実際にコンパイル時にコードを生成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テンプレートは非常に広範なトピックであり、記事の枠組みの中でそれを明らかにすることは不可能であり、これは必要ありません。</font><font style="vertical-align: inherit;">私たちは読者がそれが何であるかを理解していると想定しています。</font><font style="vertical-align: inherit;">その過程でいくつかのあいまいな点が明らかにされます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数の折り返しとそれに続く呼び出し</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、いくつかのパラメーターを入力として受け取る特定の関数があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意図を説明するコードスケッチをお見せします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Variadic_args_binder.hpp&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;any&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s)</span>
</span>{
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"int: "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">"\nstring: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::any&gt; params;<font></font>
	params.push_back(<span class="hljs-number">5</span>);<font></font>
	params.push_back(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>{ <span class="hljs-string">"Hello, Delegates!"</span> });<font></font>
	delegates::Variadic_args_binder&lt;<span class="hljs-keyword">int</span>(*)(<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>), <span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; binder{ f, params };<font></font>
	binder();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは尋ねるかもしれません、これはどのように可能ですか？クラス名</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variadic_args_binder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、オブジェクトが関数と、それを呼び出すときに渡す必要がある引数をバインドしていることを示しています。したがって、このバインダーをパラメーターなしの関数として呼び出すだけです！</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから外を見る。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すぐに、何も考えずに、これをどのように実装できるかを想定する</font><font style="vertical-align: inherit;">と、異なる数のパラメーターに対して</font><font style="vertical-align: inherit;">いくつかの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variadic_args_binder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特殊化を書くことが頭に浮かぶかもしれません</font><font style="vertical-align: inherit;">。ただし、無制限の数のパラメーターをサポートする必要がある場合、これは不可能です。そしてここに問題があります：残念ながら、引数は静的に関数呼び出しに代入する必要があります。つまり、最終的にコンパイラーの場合、呼び出しコードは次のように減らす必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs">fun_ptr(param1, param2, …, paramN);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがC ++のしくみです。</font><font style="vertical-align: inherit;">そして、これらすべては非常に複雑です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テンプレートマジックだけが処理できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主なアイデアは、各ネストレベルで引数または関数の1つを格納する再帰型を作成することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Tagged_args_binder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスを宣言し</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> delegates::impl<font></font>
{<font></font>
	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Func_type, <span class="hljs-keyword">typename</span>... T&gt;
	<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Tagged_args_binder</span>;</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプパッケージを便利に「転送」するために、補助タイプ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Type_pack_tag</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作成します</font><font style="vertical-align: inherit;">（これが必要だった理由は、すぐに明らかになります）。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Type_pack_tag</span>
{</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Tagged_args_binder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスの特殊化を作成します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の専門分野</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存知のように、再帰が無限ではないようにするには、境界ケースを定義する必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の専門分野は初期のものです。</font><font style="vertical-align: inherit;">簡単にするために、非参照型と右辺値参照型のみの特殊化を引用します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
直接パラメーター値の特殊化：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Func_type, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span>... Types_to_construct&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Tagged_args_binder</span>&lt;Func_type, Type_pack_tag&lt;T1, Types_to_construct...&gt;, Type_pack_tag&lt;&gt;&gt;
{</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-keyword">static_assert</span>(!<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">void</span>, T1&gt;, <span class="hljs-string">"Void argument is not allowed"</span>);<font></font>
<font></font>
<span class="hljs-keyword">using</span> Ret_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">invoke_result_t</span>&lt;Func_type, T1, Types_to_construct...&gt;;<font></font>
<font></font>
	_Tagged_args_binder(Func_type func, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::any&gt;&amp; args)<font></font>
		: ap_arg{ <span class="hljs-built_in">std</span>::move(unihold::reference_any_cast&lt;T1&gt;(args.at(<span class="hljs-number">0</span>))) },<font></font>
		ap_caller_part{ func, args } { }<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">void</span>, Ret_type&gt;)</span>
		</span>{<font></font>
			ap_caller_part(<span class="hljs-built_in">std</span>::move(ap_arg));
			<span class="hljs-keyword">return</span>;<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span><font></font>
		{<font></font>
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in">std</span>::move(ap_arg)));<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
	</span>{
		<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">void</span>, Ret_type&gt;)</span>
		</span>{<font></font>
			ap_caller_part(<span class="hljs-built_in">std</span>::move(ap_arg));
			<span class="hljs-keyword">return</span>;<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span><font></font>
		{<font></font>
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in">std</span>::move(ap_arg)));<font></font>
		}<font></font>
	}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
	_Tagged_args_binder&lt;Func_type, Type_pack_tag&lt;Types_to_construct...&gt;, Type_pack_tag&lt;T1&gt;&gt; ap_caller_part;<font></font>
	T1 ap_arg;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ap_arg</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
呼び出しの最初の引数と</font><font style="vertical-align: inherit;">再帰的な</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ap_caller_part</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトの残りは</font><i><font style="vertical-align: inherit;">ここに格納されます</font></i><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプは、このオブジェクトのタイプの最初のパケットから、再帰オブジェクトの「テール」の2番目のパケットに「移動」した</font><font style="vertical-align: inherit;">ことに注意してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右辺値リンクの特殊化：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Func_type, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span>... Types_to_construct&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Tagged_args_binder</span>&lt;Func_type, Type_pack_tag&lt;T1&amp;&amp;, Types_to_construct...&gt;, Type_pack_tag&lt;&gt;&gt;
{</span>
	<span class="hljs-keyword">using</span> move_ref_T1 = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_rvalue_reference_t</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_reference_t</span>&lt;T1&gt;&gt;;
<span class="hljs-keyword">public</span>:
	<span class="hljs-keyword">using</span> Ret_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">invoke_result_t</span>&lt;Func_type, move_ref_T1, Types_to_construct&gt;;<font></font>
<font></font>
	_Tagged_args_binder(Func_type func, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::any&gt;&amp; args)<font></font>
		: ap_arg{ <span class="hljs-built_in">std</span>::move(unihold::reference_any_cast&lt;T1&gt;(args.at(<span class="hljs-number">0</span>))) },<font></font>
		ap_caller_part{ func, args }<font></font>
	{<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">void</span>, Ret_type&gt;)</span>
		</span>{<font></font>
			ap_caller_part(<span class="hljs-built_in">std</span>::move(unihold::reference_any_cast&lt;T1&gt;(ap_arg)));<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span><font></font>
		{<font></font>
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in">std</span>::move(unihold::reference_any_cast&lt;T1&gt;(ap_arg))));<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
	</span>{
		<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">void</span>, Ret_type&gt;)</span>
		</span>{<font></font>
			ap_caller_part(<span class="hljs-built_in">std</span>::move(unihold::reference_any_cast&lt;T1&gt;(ap_arg)));<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span><font></font>
		{<font></font>
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in">std</span>::move(unihold::reference_any_cast&lt;T1&gt;(ap_arg))));<font></font>
		}<font></font>
	}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
	_Tagged_args_binder&lt;Func_type, Type_pack_tag&lt;Types_to_construct...&gt;, Type_pack_tag&lt;move_ref_T1&gt;&gt; ap_caller_part;<font></font>
	<span class="hljs-built_in">std</span>::any ap_arg;<font></font>
}; </code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テンプレートの「右利き」リンクは、実際には右利きの意味ではありません。</font><font style="vertical-align: inherit;">これらは、の種類に応じて、いわゆる「ユニバーサルリンク」、ある</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、どちらかになる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T1＆ </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T1 &amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、回避策を使用する必要があります。まず、特殊化は両方のタイプのリンクに対して定義されているため（既に述べた理由により、正確には言えません）、非参照パラメーターの場合、テンプレートをインスタンス化すると、右利きのリンクであっても目的の特殊化が選択されます。</font><font style="vertical-align: inherit;">次に、タイプ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をパッケージ間で</font><font style="vertical-align: inherit;">転送する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ために</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">move_ref_T1</font></i><font style="vertical-align: inherit;">の修正バージョン</font><i><font style="vertical-align: inherit;">が使用さ</font></i><font style="vertical-align: inherit;">れ、実際の右辺値リンクに変換されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のリンクを使用した特殊化も同様に行われ、必要な修正が行われます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">究極の専門</font></font></h4><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Func_type, <span class="hljs-keyword">typename</span>... Param_type&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Tagged_args_binder</span>&lt;Func_type, Type_pack_tag&lt;&gt;, Type_pack_tag&lt;Param_type...&gt;&gt;
{</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-keyword">using</span> Ret_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">invoke_result_t</span>&lt;Func_type, Param_type...&gt;;<font></font>
<font></font>
	<span class="hljs-keyword">inline</span> _Tagged_args_binder(Func_type func, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::any&gt;&amp; args)<font></font>
		: ap_func{ func } { }<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Param_type... param)</span>
	</span>{
		<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">void</span>, <span class="hljs-keyword">decltype</span>(ap_func(<span class="hljs-built_in">std</span>::forward&lt;Param_type&gt;(param)...))&gt;)</span>
		</span>{<font></font>
			ap_func(<span class="hljs-built_in">std</span>::forward&lt;Param_type&gt;(param)...);
			<span class="hljs-keyword">return</span>;<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span><font></font>
		{<font></font>
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::forward&lt;Ret_type&gt;(ap_func(<span class="hljs-built_in">std</span>::forward&lt;Param_type&gt;(param)...));<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Param_type... param)</span> <span class="hljs-keyword">const</span>
	</span>{
		<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">void</span>, Ret_type&gt;)</span>
		</span>{<font></font>
			ap_func(param...);<font></font>
			<span class="hljs-keyword">return</span>;<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span><font></font>
		{<font></font>
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::forward&lt;Ret_type&gt;(ap_func(param...));<font></font>
		}<font></font>
	}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
	Func_type ap_func;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この特殊化は、機能オブジェクトの格納を担当し、実際には、それに対するラッパーです。</font><font style="vertical-align: inherit;">これが最後の再帰型です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Type_pack_tagが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのように使用されているかに注意してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">すべてのタイプのパラメーターが左側のパッケージでコンパイルされるようになりました。</font><font style="vertical-align: inherit;">つまり、それらはすべて処理およびパッケージ化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Type_pack_tag</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用する必要があった理由が明らかになったと思います</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">実際、この言語では、たとえば次のように、2つのタイプのパッケージを並べて使用することはできません。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Func_type, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span>... Types_to_construct, <span class="hljs-keyword">typename</span>... Param_type&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Tagged_args_binder</span>&lt;Func_type, T1, Types_to_construct..., Param_type...&gt;
{</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、それらを2つのタイプ内の2つの個別のパッケージに分離する必要があります。</font><font style="vertical-align: inherit;">さらに、処理されたタイプをまだ処理されていないタイプから何らかの方法で分離する必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中級専門分野</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中間的な特殊化から、私は最後に特殊化を行います。ここでも、値型については、残りは類推によるものです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Func_type, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span>... Types_to_construct, <span class="hljs-keyword">typename</span>... Param_type&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Tagged_args_binder</span>&lt;Func_type, Type_pack_tag&lt;T1, Types_to_construct...&gt;, Type_pack_tag&lt;Param_type...&gt;&gt;
{</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-keyword">using</span> Ret_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">invoke_result_t</span>&lt;Func_type, Param_type..., T1, Types_to_construct...&gt;;<font></font>
<font></font>
	<span class="hljs-keyword">static_assert</span>(!<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">void</span>, T1&gt;, <span class="hljs-string">"Void argument is not allowed"</span>);<font></font>
<font></font>
	<span class="hljs-keyword">inline</span> _Tagged_args_binder(Func_type func, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::any&gt;&amp; args)<font></font>
		: ap_arg{ <span class="hljs-built_in">std</span>::move(unihold::reference_any_cast&lt;T1&gt;(args.at(<span class="hljs-keyword">sizeof</span>...(Param_type)))) },<font></font>
		ap_caller_part{ func, args } { }<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Param_type... param)</span>
	</span>{
		<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">void</span>, Ret_type&gt;)</span>
		</span>{<font></font>
			ap_caller_part(<span class="hljs-built_in">std</span>::forward&lt;Param_type&gt;(param)..., <span class="hljs-built_in">std</span>::move(ap_arg));
			<span class="hljs-keyword">return</span>;<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span><font></font>
		{<font></font>
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in">std</span>::forward&lt;Param_type&gt;(param)..., <span class="hljs-built_in">std</span>::move(ap_arg)));<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Param_type... param)</span> <span class="hljs-keyword">const</span>
	</span>{
		<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">void</span>, Ret_type&gt;)</span>
		</span>{<font></font>
			ap_caller_part(<span class="hljs-built_in">std</span>::forward&lt;Param_type&gt;(param)..., <span class="hljs-built_in">std</span>::move(ap_arg));<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span><font></font>
		{<font></font>
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in">std</span>::forward&lt;Param_type&gt;(param)..., <span class="hljs-built_in">std</span>::move(ap_arg)));<font></font>
		}<font></font>
	}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
	_Tagged_args_binder&lt;Func_type,<font></font>
		Type_pack_tag&lt;Types_to_construct...&gt;,<font></font>
		Type_pack_tag&lt;Param_type..., T1&gt;&gt; ap_caller_part;<font></font>
	T1 ap_arg;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この特殊化は、最初の引数以外の引数をパックすることを目的としています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バインダークラス</font></font></h4><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Tagged_args_binder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
クラス</font><i><font style="vertical-align: inherit;">は</font></i><font style="vertical-align: inherit;">直接使用するためのもので</font><i><font style="vertical-align: inherit;">はあり</font></i><font style="vertical-align: inherit;">ません。名前の先頭に単一の下線を付けて強調したかったのです。</font><font style="vertical-align: inherit;">したがって、私は、この醜くてタイプを使用するのに不便な「インターフェイス」のような小さなクラスのコードを提供します（ただし、これはかなり珍しいC ++のトリックを使用しており、私の意見ではそれを魅力的にしています）：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> cutecpplib::delegates<font></font>
{<font></font>
	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Functor_type, <span class="hljs-keyword">typename</span>... Param_type&gt;
	<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Variadic_args_binder</span>
	{</span>
		<span class="hljs-keyword">using</span> binder_type = impl::_Tagged_args_binder&lt;Functor_type, Type_pack_tag&lt;Param_type...&gt;, Type_pack_tag&lt;&gt;&gt;;<font></font>
<font></font>
	<span class="hljs-keyword">public</span>:
		<span class="hljs-keyword">using</span> Ret_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">invoke_result_t</span>&lt;binder_type&gt;;<font></font>
<font></font>
		<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Variadic_args_binder</span><span class="hljs-params">(Functor_type function, Param_type... param)</span>
			: ap_tagged_binder</span>{ function, param... } { }<font></font>
<font></font>
		<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Variadic_args_binder</span><span class="hljs-params">(Functor_type function, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::any&gt;&amp; args)</span>
			: ap_tagged_binder</span>{ function, args } { }<font></font>
<font></font>
		<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span>
		</span>{
			<span class="hljs-keyword">return</span> ap_tagged_binder();<font></font>
		}<font></font>
<font></font>
		<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
		</span>{
			<span class="hljs-keyword">return</span> ap_tagged_binder();<font></font>
		}<font></font>
<font></font>
	<span class="hljs-keyword">private</span>:<font></font>
		binder_type ap_tagged_binder;<font></font>
	};<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unihold規約-std内でリンクを渡す</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">::任意</font></font></i></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意深い読者は、コードが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unihold :: reference_any_cast（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を使用していることに気付いている</font><i><font style="vertical-align: inherit;">はず</font></i><font style="vertical-align: inherit;">です。この関数は、アナログの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unihold :: pointer_any_cast（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と同様に</font><font style="vertical-align: inherit;">、ライブラリ合意を実装するように設計されています。参照によって渡される必要がある引数は、ポインタによって</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: anyに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渡されます</font><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">reference_any_cast</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
関数</font><font style="vertical-align: inherit;">は、オブジェクト自体がコンテナに格納されているか、それへのポインタのみであるかにかかわらず、常にオブジェクトへの参照を返します。場合</font><i><font style="vertical-align: inherit;">はstd ::いずれかの</font></i><font style="vertical-align: inherit;">オブジェクトが含まれ、このオブジェクトへの参照は、容器内に戻されます。ポインターが含まれている場合、ポインターが指すオブジェクトへの参照が返されます。</font><font style="vertical-align: inherit;">
関数ごとに、定数</font><i><font style="vertical-align: inherit;">std :: anyの</font></i><font style="vertical-align: inherit;">オプションがあります。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std ::</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナが</font><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">所有者であるか、ポインタのみが含まれ</font><font style="vertical-align: inherit;">ているかを判断するためのオーバーロードバージョン</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は、C ++の型変換や同様のテンプレート関数と同様に、格納されたオブジェクトの型に明示的に特化する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの関数のコード：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;&amp; <span class="hljs-title">unihold::reference_any_cast</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::any&amp; wrapper)</span>
</span>{
	<span class="hljs-keyword">bool</span> result;
	<span class="hljs-keyword">return</span> reference_any_cast&lt;T&gt;(wrapper, result);<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;&amp; <span class="hljs-title">unihold::reference_any_cast</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::any&amp; wrapper)</span>
</span>{
	<span class="hljs-keyword">bool</span> result;
	<span class="hljs-keyword">return</span> reference_any_cast&lt;T&gt;(wrapper, result);<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;&amp; <span class="hljs-title">unihold::reference_any_cast</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::any&amp; wrapper, <span class="hljs-keyword">bool</span>&amp; is_owner)</span>
</span>{
	<span class="hljs-keyword">auto</span> ptr = pointer_any_cast&lt;T&gt;(&amp;wrapper, is_owner);
	<span class="hljs-keyword">if</span> (!ptr)
		<span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::bad_any_cast{ };
	<span class="hljs-keyword">return</span> *ptr;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;&amp; <span class="hljs-title">unihold::reference_any_cast</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::any&amp; wrapper, <span class="hljs-keyword">bool</span>&amp; is_owner)</span>
</span>{
	<span class="hljs-keyword">auto</span> ptr = pointer_any_cast&lt;T&gt;(&amp;wrapper, is_owner);
	<span class="hljs-keyword">if</span> (!ptr)
		<span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::bad_any_cast{ };
	<span class="hljs-keyword">return</span> *ptr;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;* <span class="hljs-title">unihold::pointer_any_cast</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::any* wrapper, <span class="hljs-keyword">bool</span>&amp; is_owner)</span>
</span>{
	<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
	<span class="hljs-keyword">using</span> NR_T = <span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;; <span class="hljs-comment">// No_reference_T</span>
	<span class="hljs-comment">//     wrapper</span><font></font>
	NR_T** double_ptr_to_original = any_cast&lt;NR_T*&gt;(wrapper);<font></font>
	<span class="hljs-comment">//      wrapper</span><font></font>
	NR_T* ptr_to_copy;<font></font>
	<span class="hljs-keyword">if</span> (double_ptr_to_original)<font></font>
	{<font></font>
		<span class="hljs-comment">// Wrapper     </span>
		is_owner = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">return</span> *double_ptr_to_original;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ptr_to_copy = any_cast&lt;NR_T&gt;(wrapper))<font></font>
	{<font></font>
		<span class="hljs-comment">// Wrapper   </span>
		is_owner = <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">return</span> ptr_to_copy;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span><font></font>
	{<font></font>
		<span class="hljs-keyword">throw</span> bad_any_cast{};<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;* <span class="hljs-title">unihold::pointer_any_cast</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::any* wrapper, <span class="hljs-keyword">bool</span>&amp; is_owner)</span>
</span>{
	<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
	<span class="hljs-keyword">using</span> NR_T = <span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;; <span class="hljs-comment">// No_reference_T</span>
	<span class="hljs-comment">//     wrapper</span>
	NR_T*<span class="hljs-keyword">const</span> * double_ptr_to_original = any_cast&lt;NR_T*&gt;(wrapper);
	<span class="hljs-comment">//      wrapper</span>
	<span class="hljs-keyword">const</span> NR_T* ptr_to_copy;
	<span class="hljs-comment">//remove_reference_t&lt;T&gt;* ptr2 = any_cast&lt;remove_reference_t&lt;T&gt;&gt;(&amp;wrapper);</span>
	<span class="hljs-keyword">if</span> (double_ptr_to_original)<font></font>
	{<font></font>
		<span class="hljs-comment">// Wrapper     </span>
		is_owner = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">return</span> *double_ptr_to_original;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ptr_to_copy = any_cast&lt;NR_T&gt;(wrapper))<font></font>
	{<font></font>
		<span class="hljs-comment">// Wrapper   </span>
		is_owner = <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">return</span> ptr_to_copy;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span><font></font>
	{<font></font>
		<span class="hljs-keyword">throw</span> bad_any_cast{};<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;* <span class="hljs-title">unihold::pointer_any_cast</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::any* wrapper)</span>
</span>{
	<span class="hljs-keyword">bool</span> result;
	<span class="hljs-keyword">return</span> pointer_any_cast&lt;T&gt;(wrapper, result);<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;* <span class="hljs-title">unihold::pointer_any_cast</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::any* wrapper)</span>
</span>{
	<span class="hljs-keyword">bool</span> result;
	<span class="hljs-keyword">return</span> pointer_any_cast&lt;T&gt;(wrapper, result);<font></font>
}<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++での動的関数呼び出しの問題を解決するための可能なアプローチの1つを簡単に説明しようとしました。</font><font style="vertical-align: inherit;">その後、これはC ++デリゲートライブラリの基礎を形成します（実際、私はライブラリの主要機能、つまりポリモーフィックデリゲートを既に記述しましたが、コードを示し、いくつかの未実現機能を追加するために、ライブラリを必要に応じて書き換える必要があります）。</font><font style="vertical-align: inherit;">近い将来、ライブラリの作業を終了し、残りのデリゲート機能をC ++にどのように実装したかを正確に説明する予定です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RTTIを使用したPSについては、次のパートで説明します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457144/index.html">誰も必要としないエミュレータを作成</a></li>
<li><a href="../ja457150/index.html">新しいWindowsターミナルがMicrosoftストアで入手可能に</a></li>
<li><a href="../ja457152/index.html">DEFCON 25カンファレンス。GarryKasparov。「最後の脳の戦い」パート1</a></li>
<li><a href="../ja457154/index.html">すべてのユーザー向けのレスポンシブなアプリ設計</a></li>
<li><a href="../ja457156/index.html">将来のコンピューティングシステムは何か</a></li>
<li><a href="../ja457164/index.html">ReactiveUIとAvaloniaの例を使用してディスクに状態を保存するクロスプラットフォームの.NET Coreアプリケーションでのナビゲーション</a></li>
<li><a href="../ja457168/index.html">PythonとTextBlobによるプロトタイプ感情分析</a></li>
<li><a href="../ja457172/index.html">ScreenLogger-笑顔、隠されたカメラがあなたを撃ちます</a></li>
<li><a href="../ja457178/index.html">プロセッサの設計と製造方法：CPU設計</a></li>
<li><a href="../ja457180/index.html">公式サイトNode.jsがロシア語になりました</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>