<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉüèΩ üèòÔ∏è üçØ First impression of concepts üìπ üòß üòæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I decided to deal with the new C ++ 20 feature - concepts. 
 
 Concepts (or concepts , as the Russian-speaking Wiki writes) is a very interesting and ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>First impression of concepts</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495396/"><img src="https://habrastorage.org/webt/qd/ja/kc/qdjakcxd4173w_juzv5fx3bf0_o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I decided to deal with the new C ++ 20 feature - concepts. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concepts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (or </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">concepts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as the Russian-speaking Wiki writes) is a very interesting and useful feature that has long been lacking. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essentially, it is typing for template arguments. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main problem of templates before C ++ 20 is that you could substitute anything in them, including something that they were not designed for at all. That is, the template system was completely untyped. As a result, incredibly long and completely unreadable error messages occurred when passing the wrong parameter to the template. They tried to fight this with the help of different language hacks, which I do not even want to mention (although I had to deal with).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Concepts are designed to correct this misunderstanding. </font><font style="vertical-align: inherit;">They add a typing system to the templates, and it‚Äôs very powerful. </font><font style="vertical-align: inherit;">And now, understanding the features of this system, I began to study the available materials on the Internet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frankly, I'm a little shocked :) C ++ is an already complicated language, but at least there is an excuse: it happened. </font><font style="vertical-align: inherit;">Metaprogramming on templates was discovered, not laid down, when designing a language. </font><font style="vertical-align: inherit;">And then, when developing the next versions of the language, they were forced to adapt to this ‚Äúdiscovery‚Äù, since a lot of code was written in the world. </font><font style="vertical-align: inherit;">Concepts are a fundamentally new opportunity. </font><font style="vertical-align: inherit;">And, it seems to me, some opacity is already present in their implementation. </font><font style="vertical-align: inherit;">Perhaps this is a consequence of the need to take into account the huge amount of inherited capabilities? </font><font style="vertical-align: inherit;">Let's try to figure it out ...</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">General information</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A concept is a new language entity based on template syntax. </font><font style="vertical-align: inherit;">A concept has a name, parameters, and a body - a predicate that returns a constant (i.e., computed at the compilation stage) logical value depending on the parameters of the concept. </font><font style="vertical-align: inherit;">Like this:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt; 
<span class="hljs-keyword">concept</span> Even = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;  <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> FourByte = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Technically, concepts are very similar to template constexpr expressions like bool:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> EvenX = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> FourByteX = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can even use concepts in common expressions:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Even&lt;<span class="hljs-number">2</span>&gt;; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main idea of ‚Äã‚Äãthe concepts is that they can be used instead of the typename or class keywords in templates. </font><font style="vertical-align: inherit;">Like metatypes ("types for types"). </font><font style="vertical-align: inherit;">Thus, static typing is introduced into the templates.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;FourByte T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp; t)</span> </span>{}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, if we use int as a template parameter, then the code in the vast majority of cases will compile; </font><font style="vertical-align: inherit;">and if double, then a short and understandable error message will be issued. </font><font style="vertical-align: inherit;">Simple and clear typing of templates, so far everything is ok.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requires</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a new ‚Äúcontextual‚Äù C ++ 20 keyword with a dual purpose: requires clause and requires expression. </font><font style="vertical-align: inherit;">As will be shown later, this weird keyword savings leads to some confusion.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requires expression</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, consider requires expression. </font><font style="vertical-align: inherit;">The idea is quite good: this word has a block in braces, the code inside of which is evaluated for compilation. </font><font style="vertical-align: inherit;">True, the code there should not be written </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in C ++, but in a special language, close to C ++, but having its own characteristics</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (this is the first oddity, it was quite possible to make just C ++ code). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the code is correct - requires expression returns true, otherwise false. </font><font style="vertical-align: inherit;">The code itself, of course, never gets into code generation ever, much like expressions in sizeof or decltype. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, the word is contextual and works only inside templates, that is, outside the template, this does not compile:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b = <span class="hljs-keyword">requires</span> { <span class="hljs-number">3.14</span> &gt;&gt; <span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And in the template - please:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> Shiftable = <span class="hljs-keyword">requires</span>(T i) { i&gt;&gt;<span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And it will work:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Shiftable&lt;<span class="hljs-keyword">int</span>&gt;; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">bool</span> b2 = Shiftable&lt;<span class="hljs-keyword">double</span>&gt;; <span class="hljs-comment">// false</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main use of requires expression is the creation of concepts. </font><font style="vertical-align: inherit;">For example, this is how you can check for the presence of fields and methods in a type. </font><font style="vertical-align: inherit;">A very popular case.</font></font><br>
<br>
<pre><code class="plaintext hljs">template &lt;typename T&gt;<font></font>
concept Machine = <font></font>
  requires(T m) {  //   `m` ,   Machine<font></font>
	m.start();     //    `m.start()` <font></font>
	m.stop();      //   `m.stop()`<font></font>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By the way, all variables that may be required in the tested code (not only the template parameters) must be declared in parentheses requires expression. </font><font style="vertical-align: inherit;">For some reason, declaring a variable is simply not possible.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Type checking inside requires</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is where the differences between requires code and standard C ++ begin. </font><font style="vertical-align: inherit;">To check the returned types, a special syntax is used: the object is taken in curly brackets, an arrow is placed, and after it, a concept is written that the type must satisfy. </font><font style="vertical-align: inherit;">Moreover, the use of directly types is not allowed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Check that the return of the function can be converted to int:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">int</span>&gt;;<font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Check that the return function is exactly int:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::same_as&lt;<span class="hljs-keyword">int</span>&gt;; <font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(std :: same_as and std :: convertible_to are concepts from the standard library). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you do not enclose an expression whose type is checked in braces, the compiler does not understand what they want from him and interprets the entire string as a single expression that needs to be checked for compilation.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requires inside requires</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The requires keyword has a special meaning inside requires expressions. </font><font style="vertical-align: inherit;">Nested requires-expressions (already without curly braces) are checked not for compilation, but for equality true or false. </font><font style="vertical-align: inherit;">If such an expression turns out to be false, then the enclosing expression immediately turns out to be false (and further compilation analysis is interrupted). </font><font style="vertical-align: inherit;">General form:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> { <font></font>
  expression;         <span class="hljs-comment">// expression is valid</span>
  <span class="hljs-keyword">requires</span> predicate; <span class="hljs-comment">// predicate is true</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a predicate, for example, previously defined concepts or type traits can be used. </font><font style="vertical-align: inherit;">Example:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(Iter it) {
  <span class="hljs-comment">//     (   Iter   *  ++)</span><font></font>
  *it++;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_convertible_v&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the same time, nested requires-expressions are allowed with code in curly brackets, which is checked for validity. </font><font style="vertical-align: inherit;">However, if you simply write one requires-expression inside another, then the nested expression (everything as a whole, including the nested requires keyword) will simply be checked for validity:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">typename</span> T::value_type x) { ++x; }; <span class="hljs-comment">//     , </span>
												<span class="hljs-comment">//     !</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, a strange form with double requires arose:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span> <span class="hljs-params">(<span class="hljs-keyword">typename</span> T::value_type x)</span> </span>{ ++x; }; <span class="hljs-comment">//       "++x"</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is such a fun escape sequence from ‚Äúrequires‚Äù. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By the way, another combination of two requires is this time clause (see below) and expression:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span><span class="hljs-params">(T x, T y)</span> </span>{ <span class="hljs-keyword">bool</span>(x &lt; y); }
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">equivalent</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; x, T <span class="hljs-keyword">const</span>&amp; y)</span>
</span>{
  <span class="hljs-keyword">return</span> !(x &lt; y) &amp;&amp; !(y &lt; x);<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requires clause</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's move on to another use of the word requires - to declare restrictions of a template type. </font><font style="vertical-align: inherit;">This is an alternative to using concept names instead of typename. </font><font style="vertical-align: inherit;">In the following example, all three methods are equivalent:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  require</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
	<span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span></span>;<font></font>
<font></font>
<span class="hljs-comment">//   require (  )</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span> <span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;</span>;<font></font>
<font></font>
<span class="hljs-comment">//    typename</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Sortable Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span>  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The requires declaration can use several predicates combined by logical operators.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<font></font>
 <font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// ok</span>
  fun(s);  <span class="hljs-comment">// compiler error</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, just invert one of the conditions, as a compilation error occurs:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; !is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is an example that will not compile either</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> !<span class="hljs-function">is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;	</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The reason for this is the ambiguities that arise when parsing some expressions. </font><font style="vertical-align: inherit;">For example, in such a template:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">bool</span>)&amp;<span class="hljs-function">T::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
it is unclear what to attribute unsigned to - the operator or the prototype of the foo () function. </font><font style="vertical-align: inherit;">Therefore, the developers decided that without parentheses as arguments requires clause only a very limited set of entities can be used - true or false literals, field names of the bool type of the form value, value, T :: value, ns :: trait :: value, Concept names of the type Concept and requires expressions. </font><font style="vertical-align: inherit;">Everything else should be enclosed in parentheses:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!is_trivial_v&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now about predicate features in requires clause</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider another example.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this example, requires uses a trait that depends on the nested value_type type. </font><font style="vertical-align: inherit;">It is not known in advance whether an arbitrary type has such a nested type that can be passed to the template. </font><font style="vertical-align: inherit;">If you pass, for example, a simple int type to such a template, there will be a compilation error, however, if we have two specializations of the template, then there will be no error; </font><font style="vertical-align: inherit;">just another specialization will be chosen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"1"</span>; } <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2"</span>; } <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// displays: "2"</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, specialization is discarded not only when the require clause predicate returns false, but also when it turns out to be incorrect. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The parentheses around the predicate are an important reminder that in requires clause the inverse of the predicate is not the opposite of the predicate itself. </font><font style="vertical-align: inherit;">So,</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
means that the trait is correct and returns true. </font><font style="vertical-align: inherit;">Wherein</font></font><br>
<br>
<pre><code class="cpp hljs">!is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
would mean ‚Äúthe trait is correct and returns false‚Äù The </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
real logical inversion of the first predicate is NOT (‚Äúthe trait is correct and returns true‚Äù) == ‚Äúthe trait is INCORRECT or returns false‚Äù - this is achieved in a slightly more complex way - through an explicit definition of the concept:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> value_type_valid_and_trivial <font></font>
  = is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;; <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!value_type_valid_and_trivial&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conjunction and Disjunction</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The logical conjunction and disjunction operators look as usual, but actually work a little differently than in normal C ++. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider two very similar code snippets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first is a predicate without parentheses:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		|| <span class="hljs-function"><span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second is with brackets:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> (<span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		 || <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The difference is only in brackets. </font><font style="vertical-align: inherit;">But because of this, in the second template, there are not two constraints united by a ‚Äúrequire-clause‚Äù, but one united by a usual logical OR. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This difference is as follows. </font><font style="vertical-align: inherit;">Consider the code</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">int</span>&gt; oi {};
<span class="hljs-keyword">int</span> i {};<font></font>
fun(i, oi);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here the template is instantiated by types int and std :: optional. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the first case, the int :: value_type type is invalid, and the first limitation is thereby not satisfied. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But the type optional :: value_type is valid, the second trait returns true, and since there is an OR operator between the constraints, the whole predicate is satisfied as a whole. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the second case, this is a single expression containing an invalid type, because of which it is invalid in general and the predicate is not satisfied. </font><font style="vertical-align: inherit;">So simple brackets imperceptibly change the meaning of what is happening.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, not all features of the concepts are shown here. I just did not go further. But as a first impression - a very interesting idea and a somewhat strange confused implementation. And a funny syntax with repeating requires, which really confuses. Is there really so few words in English that you had to use one word for completely different purposes? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The idea with compiled code is definitely good. It is even somewhat similar to ‚Äúquasi-quoting‚Äù in syntax macros. But was it worth mixing up the special syntax for checking return types? IMHO, for this it would simply be necessary to make a separate keyword.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implicit mixing of the concepts ‚Äútrue / false‚Äù and ‚Äúcompiles / does not compile‚Äù in one heap, and as a result, jokes with brackets are also wrong. </font><font style="vertical-align: inherit;">These are different concepts, and they must exist strictly in different contexts (although I understand where it came from - from the SFINAE rule, where uncompiled code just silently excluded specialization from consideration). </font><font style="vertical-align: inherit;">But if the goal of the concepts is to make the code as explicit as possible, was it worth it to drag all these implicit things into new features? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The article is written mainly on the basis of </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/01/29/requires-expression </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/03/26/requires-clause</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
(there are much more examples and interesting features) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
with my additions from other sources, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
all examples can be checked on</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wandbox.org</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en495380/index.html">Great Egyptian Firewall</a></li>
<li><a href="../en495384/index.html">My internship experience at Microsoft Redmond and getting an offer</a></li>
<li><a href="../en495388/index.html">1970s television show that became an ancestor of eSports</a></li>
<li><a href="../en495390/index.html">STM32CubeMonitor is worth a try</a></li>
<li><a href="../en495392/index.html">How to search for bugs on the front end: 4 main stages</a></li>
<li><a href="../en495398/index.html">Ro.Ri.Re</a></li>
<li><a href="../en495400/index.html">Work with SD card via SPI interface. VHDL implementation</a></li>
<li><a href="../en495402/index.html">Last year, we finally photographed a black hole. Now what?</a></li>
<li><a href="../en495404/index.html">Are sagging stocks promising? Let's analyze with python</a></li>
<li><a href="../en495408/index.html"># 02 - And a whole byte is not enough ... | The cross of changes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>