<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🍳 🔕 ✋🏿 シングルトンにアクセスするときに未定義の動作を回避するための手法 🕴🏾 🧙 🗣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、最新のc ++でシングルトンにアクセスする際の未定義の動作を回避するための原因と方法について説明します。シングルスレッドコードの例を示します。コンパイラ固有のものはなく、すべて標準に準拠しています。
 
 前書き
 まず、ハブレに関するシングルトンに関する他の記事を読むことをお勧めしま...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>シングルトンにアクセスするときに未定義の動作を回避するための手法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455848/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事では、最新のc ++でシングルトンにアクセスする際の未定義の動作を回避するための原因と方法について説明します。</font><font style="vertical-align: inherit;">シングルスレッドコードの例を示します。</font><font style="vertical-align: inherit;">コンパイラ固有のものはなく、すべて標準に準拠しています。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、ハブレに関するシングルトンに関する他の記事を読むことをお勧めします：</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルトンパターンの3つの時代</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルトーン</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と一般的なインスタンス</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一責任の原則</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルトン</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">に違反する3つの方法</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">-パターンまたはアンチパターン？</font></a></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルトンパターンを使用します。</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最後に、同じトピックに触れたが、通過中の記事（欠陥や制限が考慮されなかった場合のみ）：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tializedオブジェクト（つまり、オブジェクト</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルトンと</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">の寿命）</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
次：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは</font><font style="vertical-align: inherit;">シングルトンの建築特性に関する記事で</font><font style="vertical-align: inherit;">はあり</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは</font><font style="vertical-align: inherit;">「ひどくてひどいシングルトンから白くてふわふわのシングルトンを作る方法」という記事で</font><font style="vertical-align: inherit;">はあり</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは</font><font style="vertical-align: inherit;">シングルトンキャンペーンで</font><font style="vertical-align: inherit;">はあり</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルトンに対する十字軍で</font><font style="vertical-align: inherit;">はあり</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは</font><font style="vertical-align: inherit;">ハッピーエンドの記事で</font><font style="vertical-align: inherit;">はあり</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は非常に重要ですが、最新のC ++でシングルトンを使用する技術的な側面についてです。</font><font style="vertical-align: inherit;">記事の主な注意は、シングルトンの破壊の瞬間に向けられています。</font><font style="vertical-align: inherit;">ほとんどの情報源で、破壊の問題は十分に開示されていません。</font><font style="vertical-align: inherit;">通常は、シングルトンが作成された瞬間に重点が置かれ、破壊については、せいぜい「逆の順序で破壊された」などと表現されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特に「シングルトンパターンvsシングルトンアンチパターン」ホリバーを配置しないように、コメントの記事の範囲に従ってください。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
じゃ、行こう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準が言うこと</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引用はC ++ 14最終ドラフトN3936からのものです。</font><font style="vertical-align: inherit;">利用可能なC ++ 17ドラフトは「最終」としてマークされていません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も重要なセクション全体を示します。</font><font style="vertical-align: inherit;">私は重要な場所を強調しています。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.6.3終了[basic.start.term] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.初期化されたオブジェクト（つまり、有効期間（3.8）が開始されたオブジェクト）の静的ストレージ期間を持つデストラクタ（12.4）は、メインからの結果として、および結果として呼び出されますstd :: exit（18.5）の呼び出し。</font><font style="vertical-align: inherit;">特定のスレッド内のスレッドストレージ期間を持つ初期化されたオブジェクトのデストラクタは、そのスレッドの初期関数から戻った結果、およびそのスレッドがstd :: exitを呼び出した結果として呼び出されます。</font></font><b>The completions of the destructors for all initialized objects with thread storage duration within that thread are sequenced before the initiation of the destructors of any object with static storage duration. If the completion of the constructor or dynamic initialization of an object with thread storage duration is sequenced before that of another, the completion of the destructor of the second is sequenced before the initiation of the destructor of the first. If the completion of the constructor or dynamic initialization of an object with static storage duration is sequenced before that of another, the completion of the destructor of the second is sequenced before the initiation of the destructor of the first.</b> [ Note: This definition permits concurrent destruction. —end note ] If an object is initialized statically, the object is destroyed in the same order as if the object was dynamically initialized. For an object of array or class type, all subobjects of that object are destroyed before any block-scope object with static storage duration initialized during the construction of the subobjects is destroyed. If the destruction of an object with static or thread storage duration exits via an exception, std::terminate is called (15.5.1).<br>
<br>
2. <b>If a function contains a block-scope object of static or thread storage duration that has been destroyed and the function is called during the destruction of an object with static or thread storage duration, the program has undefined behavior if the flow of control passes through the definition of the previously destroyed blockscope object.</b> Likewise, the behavior is undefined if the block-scope object is used indirectly (i.e., through a pointer) after its destruction.<br>
<br>
<b>3. If the completion of the initialization of an object with static storage duration is sequenced before a call to std::atexit (see «cstdlib», 18.5), the call to the function passed to std::atexit is sequenced before the call to the destructor for the object. If a call to std::atexit is sequenced before the completion of the initialization of an object with static storage duration, the call to the destructor for the object is sequenced before the call to the function passed to std::atexit. If a call to std::atexit is sequenced before another call to std::atexit, the call to the function passed to the second std::atexit call is sequenced before the call to the function passed to the first std::atexit call.</b><br>
<br>
4. If there is a use of a standard library object or function not permitted within signal handlers (18.10) that does not happen before (1.10) completion of destruction of objects with static storage duration and execution of std::atexit registered functions (18.5), the program has undefined behavior. [ Note: If there is a use of an object with static storage duration that does not happen before the object’s destruction, the program has undefined behavior. Terminating every thread before a call to std::exit or the exit from main is sufficient, but not necessary, to satisfy these requirements. These requirements permit thread managers as static-storage-duration objects. —end note ]<br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5.「cstdlib」で宣言された関数std :: abort（）を呼び出すと、デストラクタを実行せずに、またstd :: atexit（）またはstd :: at_quick_exit（）に渡された関数を呼び出さずにプログラムが終了します。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 解釈：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドストレージ期間を持つオブジェクトの破棄は、オブジェクトの作成とは逆の順序で実行されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">厳密に言えば、静的な保存期間を持つオブジェクトは破棄され、std :: atexitに登録された関数が、そのようなオブジェクトの作成と登録とは逆の順序で呼び出されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドストレージ期間または静的ストレージ期間で破棄されたオブジェクトにアクセスしようとすると、未定義の動作が含まれます。</font><font style="vertical-align: inherit;">そのようなオブジェクトの再初期化は提供されていません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注：標準のグローバル変数は、「静的ストレージ期間を持つ非ローカル変数」と呼ばれます。</font><font style="vertical-align: inherit;">その結果、すべてのグローバル変数、すべてのシングルトーン（ローカルスタティック）、およびstd :: atexitへのすべての呼び出しが、それらが作成/登録されると、単一のLIFOキューに分類されることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事に役立つ情報は、セクション</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.6.2非ローカル変数の初期化[basic.start.init]に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も含まれてい</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最も重要なものだけを挙げます。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的ストレージ期間を持つ非ローカル変数の動的初期化は、順序付けされているか、順序付けされていません。</font><font style="vertical-align: inherit;">[...]単一の翻訳単位内で定義された順序付けられた初期化を持つ変数は、翻訳単位での定義の順序で初期化されます。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 解釈（セクションの全文を考慮に入れる）：1つの翻訳単位内のグローバル変数は、宣言順に初期化されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードに含まれるもの</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事で提供されているすべてのコード例は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">githubで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公開されてい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードは、まるで別の人が書いたかのように、3つの層で構成されています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルトン;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーティリティ（シングルトンを使用するクラス）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザー（グローバル変数とメイン）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルトンとユーティリティはサードパーティのライブラリのようなものであり、ユーザーはユーザーです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーティリティレイヤーは、ユーザーレイヤーをシングルトンレイヤーから分離するように設計されています。例では、ユーザーはシングルトンにアクセスする機会がありますが、不可能であるかのように行動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーは最初にすべてを正しく行い、次に手首を振るだけですべてが壊れます。最初に、ユーティリティレイヤーで修正しようとします。うまくいかない場合は、シングルトンレイヤーで修正します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードでは、常にエッジに沿って歩きます-今度は明るい側に、次に暗い側に。ダークサイドへの切り替えを簡単にするために、最も困難なケースが選択されました。ユーティリティデストラクタからシングルトンにアクセスすることです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デストラクタから呼び出すケースが最も難しいのはなぜですか？</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーティリティのデストラクタは、アプリケーションを最小化するプロセスで呼び出すことができるため、「シングルトンが破壊されたかどうか」という質問が関連する場合に該当します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある種の合成ケース。</font><font style="vertical-align: inherit;">実際には、デストラクタからシングルトンを呼び出す必要はありません。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要に応じて。</font><font style="vertical-align: inherit;">たとえば、オブジェクトの破壊をログに記録します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルトーンの3つのクラスが使用されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SingletonClassic-スマートポインターはありません。</font><font style="vertical-align: inherit;">実際、これは直接完全に古典的というわけではありませんが、考えられる3つの中で最も古典的です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SingletonShared-stdを使用：:: shared_ptr;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SingletonWeak-std :: weak_ptrを使用。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルトーンはすべてテンプレートです。テンプレートパラメータは、それを継承するために使用されます。ほとんどの例では、それらはPayloadクラスによってパラメーター化され、std ::セットにデータを追加するための1つのパブリック関数を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの例のユーティリティデストラクタは、100の値を入力しようとします。シングルトンコンストラクター、シングルトンデストラクター、およびインスタンス（）からコンソールへの診断出力も使用されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜそんなに難しいのですか？</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちがダークサイドにいることを理解しやすくするため。</font><font style="vertical-align: inherit;">破壊されたシングルトンに対するアピールは未定義の動作ですが、外部からは明示されない場合があります。</font><font style="vertical-align: inherit;">破棄されたstd ::セットに値を詰め込んでも、外部の明示が保証されないことは確かですが、信頼できる方法はありません（実際には、LinuxのGCCでは、クラシックシングルトンの誤った例では、破棄されたstd ::セットが正常に詰め込まれ、MSVSではWindows-ハングします）。</font><font style="vertical-align: inherit;">未定義の動作では、コンソールへの出力が</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行われない</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合が</font><b><font style="vertical-align: inherit;">あり</font></b><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">したがって、正しい例では、デストラクタの後のインスタンス（）へのアクセスがないこと、クラッシュが発生していないこと、ハングが発生していないこと、誤ったケースでは、そのようなアピール、クラッシュ、ハングのいずれか、またはすべての組み合わせで一度にすべてが予期されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラシックシングルトン</font></font></h3><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Payload.h</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Payload</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
  Payload() = <span class="hljs-keyword">default</span>;<font></font>
  ~Payload() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  Payload(<span class="hljs-keyword">const</span> Payload &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
  Payload(Payload &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
  Payload&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Payload &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
  Payload&amp; <span class="hljs-keyword">operator</span>=(Payload &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span>
  </span>{<font></font>
    m_data.emplace(value);<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; m_data;<font></font>
};<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SingletonClassic.h</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClassic</span> :</span> <span class="hljs-keyword">public</span> T<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  ~SingletonClassic()<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~SingletonClassic()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
  }<font></font>
<font></font>
  SingletonClassic(<span class="hljs-keyword">const</span> SingletonClassic &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
  SingletonClassic(SingletonClassic &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
  SingletonClassic&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> SingletonClassic &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
  SingletonClassic&amp; <span class="hljs-keyword">operator</span>=(SingletonClassic &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">static</span> SingletonClassic&amp; <span class="hljs-title">instance</span><span class="hljs-params">()</span>
  </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"instance()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">static</span> SingletonClassic inst;
    <span class="hljs-keyword">return</span> inst;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  SingletonClassic()<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"SingletonClassic()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
  }<font></font>
};<font></font>
</code></pre><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SingletonClassicの例1</font></font></h3><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classic_Example1_correct.cpp</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SingletonClassic.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Payload.h"</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassicSingleThreadedUtility</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
  ClassicSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-comment">// To ensure that singleton will be constucted before utility</span><font></font>
    SingletonClassic&lt;Payload&gt;::instance();<font></font>
  }<font></font>
<font></font>
  ~ClassicSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> &amp;instance = SingletonClassic&lt;Payload&gt;::instance();
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i )<font></font>
      instance.add(i);<font></font>
  }<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-comment">// 1. Create an empty unique_ptr</span>
<span class="hljs-comment">// 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor)</span>
<span class="hljs-comment">// 3. Create utility</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;ClassicSingleThreadedUtility&gt; emptyUnique;
<span class="hljs-keyword">auto</span> utilityUnique = <span class="hljs-built_in">std</span>::make_unique&lt;ClassicSingleThreadedUtility&gt;();<font></font>
<font></font>
<span class="hljs-comment">// This guarantee destruction in order:</span>
<span class="hljs-comment">// - utilityUnique;</span>
<span class="hljs-comment">// - singleton;</span>
<span class="hljs-comment">// - emptyUnique.</span>
<span class="hljs-comment">// This order is correct</span><font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンソール出力</font></font></b><div class="spoiler_text">instance()<br>
SingletonClassic()<br>
instance()<br>
~SingletonClassic()<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーティリティは、コンストラクタでシングルトンを呼び出して、ユーティリティが作成される前にシングルトンが作成されるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーは2つのstd :: unique_ptrを作成します。1つは空で、もう1つはユーティリティを含みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作成順序：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -空のstd :: unique_ptr。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -シングルトン; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -ユーティリティ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてそれに応じて、破壊の順序：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -ユーティリティ; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -シングルトン; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -空のstd :: unique_ptr。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーティリティデストラクタからシングルトンへの呼び出しは正しいです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルトンクラシックの例2</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが同じですが、ユーザーはそれを取り、1行ですべてを台無しにしました。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classic_Example2_incorrect.cpp</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SingletonClassic.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Payload.h"</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassicSingleThreadedUtility</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
  ClassicSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-comment">// To ensure that singleton will be constucted before utility</span><font></font>
    SingletonClassic&lt;Payload&gt;::instance();<font></font>
  }<font></font>
<font></font>
  ~ClassicSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> &amp;instance = SingletonClassic&lt;Payload&gt;::instance();
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i )<font></font>
      instance.add(i);<font></font>
  }<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-comment">// 1. Create an empty unique_ptr</span>
<span class="hljs-comment">// 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor)</span>
<span class="hljs-comment">// 3. Create utility</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;ClassicSingleThreadedUtility&gt; emptyUnique;
<span class="hljs-keyword">auto</span> utilityUnique = <span class="hljs-built_in">std</span>::make_unique&lt;ClassicSingleThreadedUtility&gt;();<font></font>
<font></font>
<span class="hljs-comment">// This guarantee destruction in order:</span>
<span class="hljs-comment">// - utilityUnique;</span>
<span class="hljs-comment">// - singleton;</span>
<span class="hljs-comment">// - emptyUnique.</span>
<span class="hljs-comment">// This order seems to be correct ...</span><font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-comment">// ... but user swaps unique_ptrs</span><font></font>
  emptyUnique.swap(utilityUnique);<font></font>
<font></font>
  <span class="hljs-comment">// Guaranteed destruction order is still the same:</span>
  <span class="hljs-comment">// - utilityUnique;</span>
  <span class="hljs-comment">// - singleton;</span>
  <span class="hljs-comment">// - emptyUnique,</span>
  <span class="hljs-comment">// but now utilityUnique is empty, and emptyUnique is filled,</span>
  <span class="hljs-comment">// so destruction order is incorrect</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンソール出力</font></font></b><div class="spoiler_text">instance()<br>
SingletonClassic()<br>
~SingletonClassic()<br>
instance()<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作成と破棄の順序は保持されます。</font><font style="vertical-align: inherit;">すべてがまだ残っているようです。</font><font style="vertical-align: inherit;">しかし、違います。</font><font style="vertical-align: inherit;">emptyUnique.swap（utilityUnique）を呼び出すことにより、ユーザーは未定義の動作をコミットしました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜユーザーはそのような愚かなことをしたのですか？</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼がライブラリとシングルトンとユーティリティを提供したライブラリの内部構造について何も知らないからです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、あなたがライブラリの内部構造を知っているなら？</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...とにかく実際のコードでは、関与するのは非常に簡単です。</font><font style="vertical-align: inherit;">そして、あなたは苦痛なデバッグによって抜け出す必要があります、なぜなら </font><font style="vertical-align: inherit;">何が起こったのかを正確に理解することは容易ではありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリを正しく使用する必要がないのはなぜですか？</font><font style="vertical-align: inherit;">さて、書くドックにはさまざまな種類があります。例を挙げ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ましょう</font><b><font style="vertical-align: inherit;">。</font></b><font style="vertical-align: inherit;">そして、だましにくいライブラリを作成してみませんか。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルトンクラシックの例3</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事を数日間作成する過程で、ユーティリティレイヤーで前の例から不明確な動作を排除することは不可能であり、ソリューションはシングルトンレイヤーでのみ利用可能であると思いました。</font><font style="vertical-align: inherit;">しかし、時間の経過とともに、解決策が思い付きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードと説明でスポイラーを開く前に、読者が自分で状況から抜け出す方法を見つけるように試みることをお勧めします（ユーティリティレイヤーでのみ！）。</font><font style="vertical-align: inherit;">より良い解決策があることを除外しません。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classic_Example3_correct.cpp</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SingletonClassic.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Payload.h"</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassicSingleThreadedUtility</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
  ClassicSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-keyword">thread_local</span> <span class="hljs-keyword">auto</span> flag_strong = <span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-keyword">char</span>&gt;(<span class="hljs-number">0</span>);<font></font>
    m_flag_weak = flag_strong;<font></font>
<font></font>
    SingletonClassic&lt;Payload&gt;::instance();<font></font>
  }<font></font>
<font></font>
  ~ClassicSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> ( !m_flag_weak.expired() )<font></font>
    {<font></font>
      <span class="hljs-keyword">auto</span> &amp;instance = SingletonClassic&lt;Payload&gt;::instance();
      <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i )<font></font>
        instance.add(i);<font></font>
    }<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
  <span class="hljs-built_in">std</span>::weak_ptr&lt;<span class="hljs-keyword">char</span>&gt; m_flag_weak;<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-comment">// 1. Create an empty unique_ptr</span>
<span class="hljs-comment">// 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor)</span>
<span class="hljs-comment">// 3. Create utility</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;ClassicSingleThreadedUtility&gt; emptyUnique;
<span class="hljs-keyword">auto</span> utilityUnique = <span class="hljs-built_in">std</span>::make_unique&lt;ClassicSingleThreadedUtility&gt;();<font></font>
<font></font>
<span class="hljs-comment">// This guarantee destruction in order:</span>
<span class="hljs-comment">// - utilityUnique;</span>
<span class="hljs-comment">// - singleton;</span>
<span class="hljs-comment">// - emptyUnique.</span>
<span class="hljs-comment">// This order seems to be correct ...</span><font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-comment">// ... but user swaps unique_ptrs</span><font></font>
  emptyUnique.swap(utilityUnique);<font></font>
<font></font>
  {<font></font>
    <span class="hljs-comment">// To demonstrate normal processing before application ends</span>
    <span class="hljs-keyword">auto</span> utility = ClassicSingleThreadedUtility();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Guaranteed destruction order is still the same:</span>
  <span class="hljs-comment">// - utilityUnique;</span>
  <span class="hljs-comment">// - singleton;</span>
  <span class="hljs-comment">// - emptyUnique,</span>
  <span class="hljs-comment">// but now utilityUnique is empty, and emptyUnique is filled,</span>
  <span class="hljs-comment">// so destruction order is incorrect ...</span>
  <span class="hljs-comment">// ... but utility uses a variable with thread storage duration to detect thread termination.</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンソール出力</font></font></b><div class="spoiler_text">instance()<br>
SingletonClassic()<br>
instance()<br>
instance()<br>
~SingletonClassic()<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明</font></font></b><div class="spoiler_text">     .     ,      .     flag_strong  std::shared_ptr,   thread storage duration (.      ) —   ,        <b>    </b>,    —   .  flag_strong —    ,         weak-.<br>
<br>
      , ..    .  ,    ,   (  )   .        ,        —  ,   .<br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルトン共有</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
std :: shared_ptrに基づいて変更されたシングルトンに移りましょう。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SingletonShared.h</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonShared</span> :</span> <span class="hljs-keyword">public</span> T<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  ~SingletonShared()<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~SingletonShared()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
  }<font></font>
<font></font>
  SingletonShared(<span class="hljs-keyword">const</span> SingletonShared &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
  SingletonShared(SingletonShared &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
  SingletonShared&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> SingletonShared &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
  SingletonShared&amp; <span class="hljs-keyword">operator</span>=(SingletonShared &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;SingletonShared&gt; <span class="hljs-title">instance</span><span class="hljs-params">()</span>
  </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"instance()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-comment">// "new" and no std::make_shared because of private c-tor</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> inst = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;SingletonShared&gt;(<span class="hljs-keyword">new</span> SingletonShared);
    <span class="hljs-keyword">return</span> inst;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  SingletonShared()<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"SingletonShared()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
  }<font></font>
};<font></font>
</code></pre><br>
</div></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ああ、ああ、新しい演算子は最近のコードでは使用しないでください。代わりにstd :: make_sharedが必要です！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、これはシングルトンのプライベートコンストラクタによって防止されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハ！</font><font style="vertical-align: inherit;">私も問題があります！</font><font style="vertical-align: inherit;">stdを宣言します::シングルトンフレンドをmake_sharedします！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...アンチパターンPublicMorozovのバリエーションを取得します。同じstd :: make_sharedを使用すると、アーキテクチャで提供されていないシングルトンの追加インスタンスを作成することが可能になります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルトン共有の例1および2</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラシックバージョンの例1と2に完全に対応します。</font><font style="vertical-align: inherit;">重要な変更はシングルトンレイヤーに対してのみ行われ、ユーティリティは基本的に同じままでした。</font><font style="vertical-align: inherit;">クラシックシングルトンの例と同様に、example-1は正しく、example-2は未定義の動作を示します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shared_Example1_correct.cpp</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SingletonShared.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Payload.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SharedSingleThreadedUtility</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
  SharedSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-comment">// To ensure that singleton will be constucted before utility</span><font></font>
    SingletonShared&lt;Payload&gt;::instance();<font></font>
  }<font></font>
<font></font>
  ~SharedSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">auto</span> instance = SingletonShared&lt;Payload&gt;::instance() )
      <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i )<font></font>
        instance-&gt;add(i);<font></font>
  }<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-comment">// 1. Create an empty unique_ptr</span>
<span class="hljs-comment">// 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor)</span>
<span class="hljs-comment">// 3. Create utility</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;SharedSingleThreadedUtility&gt; emptyUnique;
<span class="hljs-keyword">auto</span> utilityUnique = <span class="hljs-built_in">std</span>::make_unique&lt;SharedSingleThreadedUtility&gt;();<font></font>
<font></font>
<span class="hljs-comment">// This guarantee destruction in order:</span>
<span class="hljs-comment">// - utilityUnique;</span>
<span class="hljs-comment">// - singleton;</span>
<span class="hljs-comment">// - emptyUnique.</span>
<span class="hljs-comment">// This order is correct</span><font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンソール出力</font></font></b><div class="spoiler_text">instance()<br>
SingletonShared()<br>
instance()<br>
~SingletonShared()<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shared_Example2_incorrect.cpp</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SingletonShared.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Payload.h"</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SharedSingleThreadedUtility</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
  SharedSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-comment">// To ensure that singleton will be constucted before utility</span><font></font>
    SingletonShared&lt;Payload&gt;::instance();<font></font>
  }<font></font>
<font></font>
  ~SharedSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-comment">// Sometimes this check may result as "false" even for destroyed singleton</span>
    <span class="hljs-comment">// preventing from visual effects of undefined behaviour ...</span>
    <span class="hljs-comment">//if ( auto instance = SingletonShared::instance() )</span>
    <span class="hljs-comment">//  for ( int i = 0; i &lt; 100; ++i )</span>
    <span class="hljs-comment">//    instance-&gt;add(i);</span><font></font>
<font></font>
    <span class="hljs-comment">// ... so this code will demonstrate UB in colour</span>
    <span class="hljs-keyword">auto</span> instance = SingletonShared&lt;Payload&gt;::instance();
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i )<font></font>
      instance-&gt;add(i);<font></font>
  }<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-comment">// 1. Create an empty unique_ptr</span>
<span class="hljs-comment">// 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor)</span>
<span class="hljs-comment">// 3. Create utility</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;SharedSingleThreadedUtility&gt; emptyUnique;
<span class="hljs-keyword">auto</span> utilityUnique = <span class="hljs-built_in">std</span>::make_unique&lt;SharedSingleThreadedUtility&gt;();<font></font>
<font></font>
<span class="hljs-comment">// This guarantee destruction in order:</span>
<span class="hljs-comment">// - utilityUnique;</span>
<span class="hljs-comment">// - singleton;</span>
<span class="hljs-comment">// - emptyUnique.</span>
<span class="hljs-comment">// This order seems to be correct ...</span><font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-comment">// ... but user swaps unique_ptrs</span><font></font>
  emptyUnique.swap(utilityUnique);<font></font>
<font></font>
  <span class="hljs-comment">// Guaranteed destruction order is the same:</span>
  <span class="hljs-comment">// - utilityUnique;</span>
  <span class="hljs-comment">// - singleton;</span>
  <span class="hljs-comment">// - emptyUnique,</span>
  <span class="hljs-comment">// but now utilityUnique is empty, and emptyUnique is filled,</span>
  <span class="hljs-comment">// so destruction order is incorrect</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンソール出力</font></font></b><div class="spoiler_text">instance()<br>
SingletonShared()<br>
~SingletonShared()<br>
instance()<br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルトン共有の例3</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、クラシックの例3よりもこの問題を修正してみましょう。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策は明白です。シングルトンによって返されたstd :: shared_ptrのコピーをユーティリティに格納することで、シングルトンの寿命を延ばす必要があるだけです。</font><font style="vertical-align: inherit;">また、SingletonSharedを備えたこのソリューションは、オープンソースで広く複製されています。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shared_Example3_correct.cpp</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SingletonShared.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Payload.h"</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SharedSingleThreadedUtility</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
  SharedSingleThreadedUtility()<font></font>
      <span class="hljs-comment">// To ensure that singleton will be constucted before utility</span><font></font>
      : m_singleton(SingletonShared&lt;Payload&gt;::instance())<font></font>
  {<font></font>
  }<font></font>
<font></font>
  ~SharedSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-comment">// Sometimes this check may result as "false" even for destroyed singleton</span>
    <span class="hljs-comment">// preventing from visual effects of undefined behaviour ...</span>
    <span class="hljs-comment">//if ( m_singleton )</span>
    <span class="hljs-comment">//  for ( int i = 0; i &lt; 100; ++i )</span>
    <span class="hljs-comment">//    m_singleton-&gt;add(i);</span><font></font>
<font></font>
    <span class="hljs-comment">// ... so this code will allow to demonstrate UB in colour</span>
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i )<font></font>
      m_singleton-&gt;add(i);<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
  <span class="hljs-comment">// A copy of smart pointer, not a reference</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton;<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-comment">// 1. Create an empty unique_ptr</span>
<span class="hljs-comment">// 2. Create singleton (because of SharedSingleThreadedUtility c-tor)</span>
<span class="hljs-comment">// 3. Create utility</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;SharedSingleThreadedUtility&gt; emptyUnique;
<span class="hljs-keyword">auto</span> utilityUnique = <span class="hljs-built_in">std</span>::make_unique&lt;SharedSingleThreadedUtility&gt;();<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-comment">// This guarantee destruction in order:</span>
  <span class="hljs-comment">// - utilityUnique;</span>
  <span class="hljs-comment">// - singleton;</span>
  <span class="hljs-comment">// - emptyUnique.</span>
  <span class="hljs-comment">// This order is correct ...</span>
  <span class="hljs-comment">// ... but user swaps unique_ptrs</span><font></font>
  emptyUnique.swap(utilityUnique);<font></font>
<font></font>
  <span class="hljs-comment">// Guaranteed destruction order is the same:</span>
  <span class="hljs-comment">// - utilityUnique;</span>
  <span class="hljs-comment">// - singleton;</span>
  <span class="hljs-comment">// - emptyUnique,</span>
  <span class="hljs-comment">// but now utilityUnique is empty, and emptyUnique is filled,</span>
  <span class="hljs-comment">// so destruction order is incorrect...</span><font></font>
<font></font>
  <span class="hljs-comment">// ... but utility have made a copy of shared_ptr when it was available,</span>
  <span class="hljs-comment">// so it's correct again.</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンソール出力</font></font></b><div class="spoiler_text">instance()<br>
SingletonShared()<br>
~SingletonShared()<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今、注意、問題は次のとおり</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。本当にシングルトンの寿命を延ばしたいと思いましたか？</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それとも、不確定な行動を取り除き、表面上に横たわる方法として延命を選択しましたか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手段による目標の代替という形での理論的な誤りは、デッドロック（または循環参照-必要なものと呼ぶ）のリスクにつながります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はいnuuuuuuu、これはあなたが一生懸命努力しなければならない方法です！？</font><font style="vertical-align: inherit;">あなたはそんなに長い間思いつく必要があるでしょう、そしてあなたは確かに偶然それをしないでしょう！</font></font></b><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CallbackPayload.h</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackPayload</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
  CallbackPayload() = <span class="hljs-keyword">default</span>;<font></font>
  ~CallbackPayload() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  CallbackPayload(<span class="hljs-keyword">const</span> CallbackPayload &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
  CallbackPayload(CallbackPayload &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
  CallbackPayload&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> CallbackPayload &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
  CallbackPayload&amp; <span class="hljs-keyword">operator</span>=(CallbackPayload &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCallback</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt; &amp;&amp;fn)</span>
  </span>{<font></font>
    m_callbackFn = <span class="hljs-built_in">std</span>::move(fn);<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
  <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt; m_callbackFn;<font></font>
};<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SomethingWithVeryImportantDestructor.h</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomethingWithVeryImportantDestructor</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
  SomethingWithVeryImportantDestructor()<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"SomethingWithVeryImportantDestructor()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
  }<font></font>
  ~SomethingWithVeryImportantDestructor()<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~SomethingWithVeryImportantDestructor()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
  }<font></font>
<font></font>
  SomethingWithVeryImportantDestructor(<span class="hljs-keyword">const</span> SomethingWithVeryImportantDestructor &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
  SomethingWithVeryImportantDestructor(SomethingWithVeryImportantDestructor &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
  SomethingWithVeryImportantDestructor&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> SomethingWithVeryImportantDestructor &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
  SomethingWithVeryImportantDestructor&amp; <span class="hljs-keyword">operator</span>=(SomethingWithVeryImportantDestructor &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
};<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shared_Example4_incorrect.cpp</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SingletonShared.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"CallbackPayload.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SharedSingleThreadedUtility</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
  SharedSingleThreadedUtility()<font></font>
      <span class="hljs-comment">// To ensure that singleton will be constucted before utility</span><font></font>
      : m_singleton(SingletonShared&lt;CallbackPayload&gt;::instance())<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"SharedSingleThreadedUtility()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
  }<font></font>
<font></font>
  ~SharedSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~SharedSingleThreadedUtility()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCallback</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt; &amp;&amp;fn)</span>
  </span>{
    <span class="hljs-keyword">if</span> ( m_singleton )<font></font>
      m_singleton-&gt;setCallback(<span class="hljs-built_in">std</span>::move(fn));<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
  <span class="hljs-comment">// A copy of smart pointer, not a reference</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;SingletonShared&lt;CallbackPayload&gt;&gt; m_singleton;<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">auto</span> utility = <span class="hljs-built_in">std</span>::make_shared&lt;SharedSingleThreadedUtility&gt;();
  <span class="hljs-keyword">auto</span> something = <span class="hljs-built_in">std</span>::make_shared&lt;SomethingWithVeryImportantDestructor&gt;();<font></font>
<font></font>
  <span class="hljs-comment">// lambda with "utility" and "something" captured</span><font></font>
  utility-&gt;setCallback( [utility, something](){} );<font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンソール出力</font></font></b><div class="spoiler_text">instance()<br>
SingletonShared()<br>
SharedSingleThreadedUtility()<br>
SomethingWithVeryImportantDestructor()<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルトンが作成されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーティリティが作成されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Something-C-very-important-destructors</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（私が威圧的に追加した</font><b><font style="vertical-align: inherit;">もの</font></b><font style="vertical-align: inherit;">です）で作成さ</font><font style="vertical-align: inherit;">れました。インターネットなどの位置が見つかったためです。プログラム」）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これらのオブジェクトに対してデストラクタは呼び出されませんでした！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため？</font><font style="vertical-align: inherit;">手段による目標の代替のため。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルトン弱</font></font></h3><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SingletonWeak.h</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonWeak</span> :</span> <span class="hljs-keyword">public</span> T<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  ~SingletonWeak()<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~SingletonWeak()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
  }<font></font>
<font></font>
  SingletonWeak(<span class="hljs-keyword">const</span> SingletonWeak &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
  SingletonWeak(SingletonWeak &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
  SingletonWeak&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> SingletonWeak &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
  SingletonWeak&amp; <span class="hljs-keyword">operator</span>=(SingletonWeak &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::weak_ptr&lt;SingletonWeak&gt; <span class="hljs-title">instance</span><span class="hljs-params">()</span>
  </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"instance()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-comment">// "new" and no std::make_shared because of private c-tor</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> inst = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;SingletonWeak&gt;(<span class="hljs-keyword">new</span> SingletonWeak);
    <span class="hljs-keyword">return</span> inst;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  SingletonWeak()<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"SingletonWeak()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
  }<font></font>
};<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オープンソースのシングルトンにこのような変更が加えられたとしても、それはそれほど頻繁には起こりません。</font><font style="vertical-align: inherit;">std :: weak_ptrで裏返しになったいくつかの奇妙な変種に出会いました。これは使用されているようで、シングルトンの寿命を延ばす以外にユーティリティを提供していないようです。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stdを使用したシングルトン:: weak_ptr</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weak_ptrでsinlgetonクラスを作成するのは正しい方法ですか</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 シングルトンレイヤーとユーティリティレイヤーに正しく適用すると、私が提案するオプション：</font></font><br>
 <br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロックの防止など、上記の例で説明したユーザー層のアクションから保護します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classic_Example3_correctのthread_localアプリケーションよりも正確にアプリケーションが折りたたまれる瞬間を決定します。</font><font style="vertical-align: inherit;">エッジに近づくことができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目標を手段で代用するという理論上の問題に悩まされていません（この理論的な問題から、デッドロック以外の具体的なものが現れるかどうかはわかりません）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、欠点</font><font style="vertical-align: inherit;">があります。</font><font style="vertical-align: inherit;">シングルトンの寿命を延ばし</font><font style="vertical-align: inherit;">て</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、エッジに</font><b><font style="vertical-align: inherit;">さらに近づく</font></b><font style="vertical-align: inherit;">ことができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SingletonWeakの例1</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Shared_Example3_correct.cppに似ています。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weak_Example1_correct.cpp</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SingletonWeak.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Payload.h"</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeakSingleThreadedUtility</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
  WeakSingleThreadedUtility()<font></font>
      <span class="hljs-comment">// To ensure that singleton will be constucted before utility</span><font></font>
      : m_weak(SingletonWeak&lt;Payload&gt;::instance())<font></font>
  {<font></font>
  }<font></font>
<font></font>
  ~WeakSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-comment">// Sometimes this check may result as "false" even in case of incorrect usage,</span>
    <span class="hljs-comment">// and there's no way to guarantee a demonstration of undefined behaviour in colour</span>
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">auto</span> strong = m_weak.lock() )
      <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i )<font></font>
        strong-&gt;add(i);<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
  <span class="hljs-comment">// A weak copy of smart pointer, not a reference</span>
  <span class="hljs-built_in">std</span>::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak;<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-comment">// 1. Create an empty unique_ptr</span>
<span class="hljs-comment">// 2. Create singleton (because of WeakSingleThreadedUtility c-tor)</span>
<span class="hljs-comment">// 3. Create utility</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;WeakSingleThreadedUtility&gt; emptyUnique;
<span class="hljs-keyword">auto</span> utilityUnique = <span class="hljs-built_in">std</span>::make_unique&lt;WeakSingleThreadedUtility&gt;();<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-comment">// This guarantee destruction in order:</span>
  <span class="hljs-comment">// - utilityUnique;</span>
  <span class="hljs-comment">// - singleton;</span>
  <span class="hljs-comment">// - emptyUnique.</span>
  <span class="hljs-comment">// This order is correct ...</span>
  <span class="hljs-comment">// ... but user swaps unique_ptrs</span><font></font>
  emptyUnique.swap(utilityUnique);<font></font>
<font></font>
  <span class="hljs-comment">// Guaranteed destruction order is the same:</span>
  <span class="hljs-comment">// - utilityUnique;</span>
  <span class="hljs-comment">// - singleton;</span>
  <span class="hljs-comment">// - emptyUnique,</span>
  <span class="hljs-comment">// but now utilityUnique is empty, and emptyUnique is filled,</span>
  <span class="hljs-comment">// so destruction order is incorrect...</span><font></font>
<font></font>
  <span class="hljs-comment">// ... but utility have made a weak copy of shared_ptr when it was available,</span>
  <span class="hljs-comment">// so it's correct again.</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンソール出力</font></font></b><div class="spoiler_text">instance()<br>
SingletonWeak()<br>
~SingletonWeak()<br>
</div></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SingletonWeakとしてSingletonSharedを使用するユーティリティに煩わされることがないため、なぜSingletonWeakが必要なのですか？</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はい、誰も気にしません。</font><font style="vertical-align: inherit;">そして、SingletonWeakをSingletonSharedとして使用するユーティリティを気にする人はいません。</font><font style="vertical-align: inherit;">しかし、それらを本来の目的で使用する方が、他の目的で使用するよりも少し簡単です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SingletonWeakの例2</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Shared_Example4_incorrectと似ていますが、この場合はデッドロックのみが発生しません。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weak_Example2_correct.cpp</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SingletonWeak.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"CallbackPayload.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeakSingleThreadedUtility</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
  WeakSingleThreadedUtility()<font></font>
      <span class="hljs-comment">// To ensure that singleton will be constucted before utility</span><font></font>
      : m_weak(SingletonWeak&lt;CallbackPayload&gt;::instance())<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"WeakSingleThreadedUtility()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
  }<font></font>
<font></font>
  ~WeakSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~WeakSingleThreadedUtility()"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCallback</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt; &amp;&amp;fn)</span>
  </span>{
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">auto</span> strong = m_weak.lock() )<font></font>
      strong-&gt;setCallback(<span class="hljs-built_in">std</span>::move(fn));<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
  <span class="hljs-comment">// A weak copy of smart pointer, not a reference</span>
  <span class="hljs-built_in">std</span>::weak_ptr&lt;SingletonWeak&lt;CallbackPayload&gt;&gt; m_weak;<font></font>
};<font></font>
<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">auto</span> utility = <span class="hljs-built_in">std</span>::make_shared&lt;WeakSingleThreadedUtility&gt;();
  <span class="hljs-keyword">auto</span> something = <span class="hljs-built_in">std</span>::make_shared&lt;SomethingWithVeryImportantDestructor&gt;();<font></font>
<font></font>
  <span class="hljs-comment">// lambda with "utility" and "something" captured</span><font></font>
  utility-&gt;setCallback( [utility, something](){} );<font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンソール出力</font></font></b><div class="spoiler_text">instance()<br>
SingletonWeak()<br>
WeakSingleThreadedUtility()<br>
SomethingWithVeryImportantDestructor()<br>
~SingletonWeak()<br>
~SomethingWithVeryImportantDestructor()<br>
~WeakSingleThreadedUtility()<br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論の代わりに</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、シングルトンのそのような変更は、不確定な動作からあなたを救うでしょうか？</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は幸せな終わりはないと約束しました。</font><font style="vertical-align: inherit;">次の例は、ユーザーレイヤーの巧妙な妨害行為が、シングルトンで適切な考え抜かれたライブラリでさえ破壊する可能性があることを示しています（ただし、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は偶然ではほとんど不可能であることを</font><font style="vertical-align: inherit;">認めなければなりません</font><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shared_Example5_incorrect.cpp</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SingletonShared.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Payload.h"</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SharedSingleThreadedUtility</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
  SharedSingleThreadedUtility()<font></font>
      <span class="hljs-comment">// To ensure that singleton will be constucted before utility</span><font></font>
      : m_singleton(SingletonShared&lt;Payload&gt;::instance())<font></font>
  {<font></font>
  }<font></font>
<font></font>
  ~SharedSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-comment">// Sometimes this check may result as "false" even for destroyed singleton</span>
    <span class="hljs-comment">// preventing from visual effects of undefined behaviour ...</span>
    <span class="hljs-comment">//if ( m_singleton )</span>
    <span class="hljs-comment">//  for ( int i = 0; i &lt; 100; ++i )</span>
    <span class="hljs-comment">//    m_singleton-&gt;add(i);</span><font></font>
<font></font>
    <span class="hljs-comment">// ... so this code will allow to demonstrate UB in colour</span>
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i )<font></font>
      m_singleton-&gt;add(i);<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
  <span class="hljs-comment">// A copy of smart pointer, not a reference</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton;<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cracker</span><span class="hljs-params">()</span>
</span>{<font></font>
  SharedSingleThreadedUtility();<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-comment">// 1. Register cracker() using std::atexit</span>
<span class="hljs-comment">// 2. Create singleton</span>
<span class="hljs-comment">// 3. Create utility</span>
<span class="hljs-keyword">auto</span> reg = [](){ <span class="hljs-built_in">std</span>::atexit(&amp;cracker); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }();
<span class="hljs-keyword">auto</span> utility = SharedSingleThreadedUtility();<font></font>
<font></font>
<span class="hljs-comment">// This guarantee destruction in order:</span>
<span class="hljs-comment">// - utility;</span>
<span class="hljs-comment">// - singleton.</span>
<span class="hljs-comment">// This order is correct.</span>
<span class="hljs-comment">// Additionally, there's a copy of shared_ptr in the class instance...</span>
<span class="hljs-comment">// ... but there was std::atexit registered before singleton,</span>
<span class="hljs-comment">// so cracker() will be invoked after destruction of utility and singleton.</span>
<span class="hljs-comment">// There's second try to create a singleton - and it's incorrect.</span><font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンソール出力</font></font></b><div class="spoiler_text">instance()<br>
SingletonShared()<br>
~SingletonShared()<br>
instance()<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weak_Example3_incorrect.cpp</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SingletonWeak.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Payload.h"</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeakSingleThreadedUtility</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
  WeakSingleThreadedUtility()<font></font>
      <span class="hljs-comment">// To ensure that singleton will be constucted before utility</span><font></font>
      : m_weak(SingletonWeak&lt;Payload&gt;::instance())<font></font>
  {<font></font>
  }<font></font>
<font></font>
  ~WeakSingleThreadedUtility()<font></font>
  {<font></font>
    <span class="hljs-comment">// Sometimes this check may result as "false" even in case of incorrect usage,</span>
    <span class="hljs-comment">// and there's no way to guarantee a demonstration of undefined behaviour in colour</span>
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">auto</span> strong = m_weak.lock() )
      <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i )<font></font>
        strong-&gt;add(i);<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
  <span class="hljs-comment">// A weak copy of smart pointer, not a reference</span>
  <span class="hljs-built_in">std</span>::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak;<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cracker</span><span class="hljs-params">()</span>
</span>{<font></font>
  WeakSingleThreadedUtility();<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-comment">// 1. Register cracker() using std::atexit</span>
<span class="hljs-comment">// 2. Create singleton</span>
<span class="hljs-comment">// 3. Create utility</span>
<span class="hljs-keyword">auto</span> reg = [](){ <span class="hljs-built_in">std</span>::atexit(&amp;cracker); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }();
<span class="hljs-keyword">auto</span> utility = WeakSingleThreadedUtility();<font></font>
<font></font>
<span class="hljs-comment">// This guarantee destruction in order:</span>
<span class="hljs-comment">// - utility;</span>
<span class="hljs-comment">// - singleton.</span>
<span class="hljs-comment">// This order is correct.</span>
<span class="hljs-comment">// Additionally, there's a copy of shared_ptr in the class instance...</span>
<span class="hljs-comment">// ... but there was std::atexit registered before singleton,</span>
<span class="hljs-comment">// so cracker() will be invoked after destruction of utility and singleton.</span>
<span class="hljs-comment">// There's second try to create a singleton - and it's incorrect.</span><font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンソール出力</font></font></b><div class="spoiler_text">instance()<br>
SingletonWeak()<br>
~SingletonWeak()<br>
instance()<br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja455834/index.html">Linuxサーバーのベンチマーク：5つのオープンツール</a></li>
<li><a href="../ja455840/index.html">複数のクエリを使用する方法。組成、レジューサー、FP</a></li>
<li><a href="../ja455842/index.html">単一リンクリストを広げます。Swiftエディション</a></li>
<li><a href="../ja455844/index.html">例としてカプセル化テストを使用したRoslynアナライザーの作成</a></li>
<li><a href="../ja455846/index.html">ジュリアでの分散コンピューティング</a></li>
<li><a href="../ja455850/index.html">研究者向けツールボックス-第3版：ソースの検索と操作</a></li>
<li><a href="../ja455852/index.html">副鼻腔挙上と同時着床</a></li>
<li><a href="../ja455854/index.html">iOS 13でコンテキストメニューを実装する方法</a></li>
<li><a href="../ja455856/index.html">nRF52832のワイヤレス温度、湿度、および気圧センサー</a></li>
<li><a href="../ja455858/index.html">最小のケーブルテレビネットワーク。パート9：ヘッドエンド</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>