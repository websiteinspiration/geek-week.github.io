<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏻 🚰 🏝️ Unixパイプラインの実装方法 👭 🧣 👊🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、Unixカーネルでのパイプラインの実装について説明します。「UNIXでパイプラインはどのように機能するのですか？」というタイトルの最近の記事に少しがっかりしました。「内部デバイスについてではありませんでした。私は興味を持ち、古い情報源に身を投じて答えを見つけました。
 
 私たちは何に...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unixパイプラインの実装方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/495484/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/sl/9i/gesl9iqjuhatlmgyrdps28zgje0.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、Unixカーネルでのパイプラインの実装について説明します。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「UNIXでパイプラインはどのように機能するのですか？」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">というタイトルの最近の記事に少しがっかりしました</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">。</font></a><font style="vertical-align: inherit;">「</font><font style="vertical-align: inherit;">内部デバイスについてで</font><font style="vertical-align: inherit;">はあり</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ませんでした</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私は興味を持ち、古い情報源に身を投じて答えを見つけました。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは何について話していますか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パイプライン-「おそらくUnixで最も重要な発明」-小さなプログラムを組み合わせるというUnixの基本的な哲学の特徴と、おなじみのコマンドライン：</font></font><br>
<br>
<pre><code class="plaintext hljs">$ echo hello | wc -c<font></font>
6<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機能は</font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パイプ（7）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パイプ（2）の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントページで説明</font><font style="vertical-align: inherit;">されているカーネルによって提供されるシステムコールに依存し</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンベアは、一方向のプロセス間通信チャネルを提供します。</font><font style="vertical-align: inherit;">パイプラインには、入力（書き込み終了）と出力（読み取り終了）があります。</font><font style="vertical-align: inherit;">パイプラインの入力に書き込まれたデータを読み取ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パイプラインは、</font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つのファイル記述子を返す</font><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して作成され</font><font style="vertical-align: inherit;">ます。1つはパイプラインの入力を参照し、もう1つは出力を参照します。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコマンドのトレース結果は、パイプラインの作成と、1つのプロセスから別のプロセスへのパイプラインを通るデータのフローを示しています。</font></font><br>
<br>
<pre><code class="plaintext hljs">$ strace -qf -e execve,pipe,dup2,read,write \<font></font>
    sh -c 'echo hello | wc -c'<font></font>
<font></font>
execve("/bin/sh", ["sh", "-c", "echo hello | wc -c"], …)<font></font>
pipe([3, 4])                            = 0<font></font>
[pid 2604795] dup2(4, 1)                = 1<font></font>
[pid 2604795] write(1, "hello\n", 6)    = 6<font></font>
[pid 2604796] dup2(3, 0)                = 0<font></font>
[pid 2604796] execve("/usr/bin/wc", ["wc", "-c"], …)<font></font>
[pid 2604796] read(0, "hello\n", 16384) = 6<font></font>
[pid 2604796] write(1, "6\n", 2)        = 2<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
親プロセスは</font></font><code>pipe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、添付ファイル記述子を取得するために</font><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">1つの子プロセスが1つの記述子に書き込み、別のプロセスが別の記述子から同じデータを読み取ります。</font><font style="vertical-align: inherit;">stupおよびstdoutに一致させるために、dup2記述子3および4を「名前変更」するラッパー。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パイプラインがない場合、シェルは1つのプロセスの結果をファイルに書き込み、それを別のプロセスに転送して、ファイルからデータを読み取る必要があります。</font><font style="vertical-align: inherit;">その結果、より多くのリソースとディスク容量を費やすことになります。</font><font style="vertical-align: inherit;">ただし、パイプラインは一時ファイルの使用を回避するだけでなく、優れています。</font></font><br>
<br>
<blockquote>      ,  <code>read(2)</code>    ,     .       ,  <code>write(2)</code>    ,           .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
POSIX要件と同様に、これは重要なプロパティです。最大で</font></font><code>PIPE_BUF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイト（512以上）</font><font style="vertical-align: inherit;">までのパイプラインへの書き込みは、</font><font style="vertical-align: inherit;">プロセスが通常のファイル（このような保証を提供しない）と同じ方法でパイプラインを介して互いに通信できるように、アトミックである必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のファイルを使用する場合、プロセスはすべての出力データをファイルに書き込み、別のプロセスに転送できます。</font><font style="vertical-align: inherit;">または、プロセスはハード並列化モードで動作し、外部のシグナリングメカニズム（セマフォなど）を使用して、書き込みまたは読み取りの完了について互いに通知します。</font><font style="vertical-align: inherit;">コンベヤーは私達にこのすべての問題を救います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは何を探していますか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンベヤーがどのように機能するかを想像しやすくするために、それを指で説明します。</font><font style="vertical-align: inherit;">バッファといくつかの状態をメモリに割り当てる必要があります。</font><font style="vertical-align: inherit;">バッファのデータを追加および削除する関数が必要になります。</font><font style="vertical-align: inherit;">ファイル記述子への読み取りおよび書き込み操作中に関数を呼び出すには、いくつかの手段が必要です。</font><font style="vertical-align: inherit;">また、上記の特別な動作を実装するにはロックが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、ランプの明るい光の中でカーネルのソースコードに問い合わせて、漠然としたメンタルモデルを確認または否定する準備ができました。</font><font style="vertical-align: inherit;">しかし、常に予期しない事態に備えてください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どこを見ているの？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unix 6のソースコードを含む</font><font style="vertical-align: inherit;">
有名な本「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライオンズブック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」の</font><font style="vertical-align: inherit;">私のコピーがどこにあるかわかりませんが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unix Heritage Societyの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おかげ</font><font style="vertical-align: inherit;">で、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">古いバージョンのUnix </font><font style="vertical-align: inherit;">をオンラインで検索でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TUHSアーカイブを散策するのは、博物館を訪れるのと同じです。</font><font style="vertical-align: inherit;">私たちは私たちの共通の歴史を見ることができ、古いカセットや印刷物からこれらのすべての材料を少しずつ回収するための長年にわたる努力を尊重します。</font><font style="vertical-align: inherit;">そして、私はまだ欠けているそれらの断片に鋭く気づいています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンベヤーの古代の歴史に対する私たちの好奇心を満たしたので、比較のために現代のコアを見ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、</font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表のシステムコール番号は42 </font></font><code>sysent[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">一致？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">従来のUnixカーネル（1970–1974）</font></font></h2><br><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">PDP-7 Unix</font></a><font style="vertical-align: inherit;">（1970年1月）、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">UNIX</font></a><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">最初の版</font></a><font style="vertical-align: inherit;">（1971年11月）、および</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">2番目の版</font></a><font style="vertical-align: inherit;">（1972年6月）</font><font style="vertical-align: inherit;">の不完全なソースコードには、</font><font style="vertical-align: inherit;">
痕跡</font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">見つかりませんでした</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
TUHSは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、Unix</font></a><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">第3版</font></a><font style="vertical-align: inherit;">（1973年2月）がパイプラインを備えた最初のバージョンであると</font><font style="vertical-align: inherit;">主張してい</font><font style="vertical-align: inherit;">ます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unixの第3版は、アセンブリ言語で書かれたカーネルを備えた最新バージョンでしたが、パイプラインを備えた最初のバージョンです。</font><font style="vertical-align: inherit;">1973年に、第3版を改善するための作業が行われ、コアがCで書き直されたため、Unixの第4版が登場しました。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読者の1人は、Doug McIlroyが「庭のホースの原理によってプログラムを接続する」というアイデアを提案した文書のスキャンを見つけました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6c/8c2/c8c/c6c8c2c8c5720d79227246af98c9b8d5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブライアンカーニハンの本「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unix：A History and A Memoir</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」の中で、コンベヤーの出現の歴史の中で、この文書は次のようにも述べられています。これ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がMcIlroy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">への</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">インタビューと</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、2014年に書かれたMcIlroyの作品</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からの別のストーリー</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">です</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<blockquote>  Unix,        ,  ,  ,   - ,     ,       .  ,   . ,  ,  ,       .                ?           «»     , , -, : «  !».<br>
<br>
 .        ,    ,       (    ),     .          .              .      API          ,      .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、Unixの第3エディションのカーネルソースコードは失われています。</font><font style="vertical-align: inherit;">1973年11月にリリースさ</font><font style="vertical-align: inherit;">れたC </font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">書かれた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第4版の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カーネルのソースコードはありますが</font><font style="vertical-align: inherit;">、公式リリースの数か月前にリリースされ、パイプライン実装は含まれていません。伝説的なUnix関数のソースコードが、おそらく永久に失われるのは残念です。</font><font style="vertical-align: inherit;">両方のリリース</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
のドキュメントのテキストがあるため、ドキュメント</font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3版を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検索することから始めることができます</font><font style="vertical-align: inherit;">（特定の単語については、「手動で」下線が引かれ、リテラル^ Hの後にアンダースコアが続きます！）。このプロトは</font></font><code>pipe(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブラー</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">作成され、ファイル記述子を1つだけ返しますが、期待される基本機能はすでに提供されています。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pipe</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムコール</font><font style="vertical-align: inherit;">は、パイプラインと呼ばれる出力入力メカニズムを作成します。</font><font style="vertical-align: inherit;">返されたファイル記述子は、読み取りおよび書き込み操作に使用できます。</font><font style="vertical-align: inherit;">パイプラインに何かが書き込まれると、最大504バイトのデータがバッファーに入れられ、その後、書き込みプロセスは一時停止されます。</font><font style="vertical-align: inherit;">パイプラインから読み取る場合、バッファリングされたデータが取得されます。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
翌年までに、カーネルはCで書き直さ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れ、第4版のpipe（2）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はプロトタイプ " </font></font><code>pipe(fildes)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"で</font><font style="vertical-align: inherit;">モダンな外観になりました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<blockquote>  <i>pipe</i>    ,   .          .  -   ,   ,   r1 (. fildes[1]),    4096  ,     .     ,   r0 (. fildes[0]),  .<br>
<br>
,      ( )   (   <i>fork</i>)         <i>read</i>  <i>write</i>.<br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェルには、パイプラインを介して接続されたプロセスの線形配列を定義するための構文があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンドが1つしかない（すべての書き込みファイル記述子が閉じている）空のパイプライン（バッファーデータが含まれていない）からの読み取り呼び出しは、「ファイルの終わり」を返します。</font><font style="vertical-align: inherit;">同様の状況での通話の録音は無視されます。</font></font></blockquote><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現存する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最も古い</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">パイプラインの実装</font></a><font style="vertical-align: inherit;">は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unixの第5版</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1974年6月）</font><font style="vertical-align: inherit;">まで遡ります</font><font style="vertical-align: inherit;">が、次のリリースで登場したものとほとんど同じです。</font><font style="vertical-align: inherit;">コメントだけが追加されたので、第5版はスキップできます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unixの第6版（1975）</font></font></h2><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第6版の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
UNIXソースコード</font><font style="vertical-align: inherit;">（1975年5月）</font><font style="vertical-align: inherit;">を読み始めます</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライオンズの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おかげ</font><font style="vertical-align: inherit;">で、以前のバージョンのソースコードよりもはるかに簡単に見つけることができました。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長年にわたり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライオンズは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベル研究所の壁の外で利用できる唯一のUnixコアドキュメントでした。</font><font style="vertical-align: inherit;">第6版のライセンスでは教師がソースコードを使用できましたが、第7版のライセンスではこの可能性が排除されたため、本は違法な活字コピーの形で配布されました。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日、あなたは本の複製版を購入することができます。その表紙には、コピー機で学生が示されます。また、TUHSプロジェクトを立ち上げたWarren Tumiのおかげ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、第6版のソースコードを含むPDFファイルを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダウンロードできます</font><font style="vertical-align: inherit;">。ファイルを作成するのにどれだけの労力がかかったかをお伝えします：</font></font><br>
<br>
<blockquote> 15       ,   <i>Lions</i>,             . TUHS   ,         .   1988-      9 ,        PDP11.   ,   ,      /usr/src/,       1979- ,     .        PWB,   .<br>
<br>
            .     ,    ,    +=   =+. -  ,  -   ,    .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今日、TUHSで、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デニス・リッチーが</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手がけた</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">アーカイブの</font></a><font style="vertical-align: inherit;">第6版のソースコードをオンラインで読むことができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、一見すると、カーニガンおよびリッチー時代以前のCコードの主な特徴は、その</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡潔さ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。それほど頻繁ではありませんが、大幅な編集を行わずにコードスニペットを埋め込んで、サイトの比較的狭い表示領域に合わせることができます。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">/usr/sys/ken/pipe.c</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の最初に</font><font style="vertical-align: inherit;">説明コメントがあります（そして、はい、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">/ usr / sys / dmrもあります</font></a><font style="vertical-align: inherit;">）：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Max allowable buffering per pipe.<font></font>
 * This is also the max size of the<font></font>
 * file created to implement the pipe.<font></font>
 * If this size is bigger than 4096,<font></font>
 * pipes will be implemented in LARG<font></font>
 * files, which is probably not good.<font></font>
 */<font></font>
#define    PIPSIZ    4096<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バッファサイズは、第4版以降変更されていません。しかし、ここでは、公開ドキュメントがないため、パイプラインがファイルをバックアップストレージとして使用したことがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LARGファイル</font><font style="vertical-align: inherit;">については、</font><font style="vertical-align: inherit;">大きなファイルシステムをサポートするために</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">間接ブロック</font></a><font style="vertical-align: inherit;">を処理</font><font style="vertical-align: inherit;">するために</font><font style="vertical-align: inherit;">「高アドレス指定アルゴリズム」で使用される</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LARG inodeフラグ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に対応</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">してい</font></a><font style="vertical-align: inherit;">ます。ケンはそれらを使用しない方が良いと言ったので、喜んで彼の言葉を引き受けます。</font><font style="vertical-align: inherit;">
実際のシステムコールは</font><font style="vertical-align: inherit;">次のとおりです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>pipe</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * The sys-pipe entry.<font></font>
 * Allocate an inode on the root device.<font></font>
 * Allocate 2 file structures.<font></font>
 * Put it all together with flags.<font></font>
 */<font></font>
pipe()<font></font>
{<font></font>
    register *ip, *rf, *wf;<font></font>
    int r;<font></font>
<font></font>
    ip = ialloc(rootdev);<font></font>
    if(ip == NULL)<font></font>
        return;<font></font>
    rf = falloc();<font></font>
    if(rf == NULL) {<font></font>
        iput(ip);<font></font>
        return;<font></font>
    }<font></font>
    r = u.u_ar0[R0];<font></font>
    wf = falloc();<font></font>
    if(wf == NULL) {<font></font>
        rf-&gt;f_count = 0;<font></font>
        u.u_ofile[r] = NULL;<font></font>
        iput(ip);<font></font>
        return;<font></font>
    }<font></font>
    u.u_ar0[R1] = u.u_ar0[R0]; /* wf's fd */<font></font>
    u.u_ar0[R0] = r;           /* rf's fd */<font></font>
    wf-&gt;f_flag = FWRITE|FPIPE;<font></font>
    wf-&gt;f_inode = ip;<font></font>
    rf-&gt;f_flag = FREAD|FPIPE;<font></font>
    rf-&gt;f_inode = ip;<font></font>
    ip-&gt;i_count = 2;<font></font>
    ip-&gt;i_flag = IACC|IUPD;<font></font>
    ip-&gt;i_mode = IALLOC;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解説はここで何が起こっているかを明確に説明しています。しかし、コードを理解するのは簡単ではありません。理由の1つは、« </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">struct user u</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> »を</font><font style="vertical-align: inherit;">使用してシステムコールのパラメーターを</font><font style="vertical-align: inherit;">登録</font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>R1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">転送し、値を返すためです。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ialloc（）を</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
使用して</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">iノード（inode </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をディスクに配置し</font><font style="vertical-align: inherit;">、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">falloc（）</font></a><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して</font><font style="vertical-align: inherit;">2つの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ファイル</font></a><font style="vertical-align: inherit;">をメモリに配置して</font><font style="vertical-align: inherit;">みましょう</font><font style="vertical-align: inherit;">。すべてが順調に進んだら、フラグを設定してこれらのファイルをパイプラインの両端として定義し、それらを同じiノード（参照カウントは2）をポイントし、変更されたiノードを使用済みとしてマークします。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">iput（）の</font></a><font style="vertical-align: inherit;">呼び出しに注意して</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ください</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラーパスで新しいiノードの参照カウントを減らします。</font><font style="vertical-align: inherit;">読み書きのためにファイル記述子番号を</font></font><br>
<br>
<code>pipe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通過</font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して</font></font><code>R1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返す</font><font style="vertical-align: inherit;">必要があり</font><font style="vertical-align: inherit;">ます。</font></font><code>falloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル構造へのポインタを返しますが、</font></font><code>u.u_ar0[R0]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル記述子</font><font style="vertical-align: inherit;">を通じて「返します」</font><font style="vertical-align: inherit;">。つまり、コード</font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は読み取りのためにファイル記述子に</font><font style="vertical-align: inherit;">保存し</font></font><code>u.u_ar0[R0]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、2番目の呼び出しの</font><font style="vertical-align: inherit;">直後から書き込み用の記述子を割り当て</font><font style="vertical-align: inherit;">ます</font></font><code>falloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">パイプラインの作成時に設定する</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグ</font></font><code>FPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">特定のI / O I / Oルーチンを呼び出す</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sys2.cのrdwr（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の動作を制御し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * common code for read and write calls:<font></font>
 * check permissions, set base, count, and offset,<font></font>
 * and switch out to readi, writei, or pipe code.<font></font>
 */<font></font>
rdwr(mode)<font></font>
{<font></font>
    register *fp, m;<font></font>
<font></font>
    m = mode;<font></font>
    fp = getf(u.u_ar0[R0]);<font></font>
        /* … */<font></font>
<font></font>
    if(fp-&gt;f_flag&amp;FPIPE) {<font></font>
        if(m==FREAD)<font></font>
            readp(fp); else<font></font>
            writep(fp);<font></font>
    }<font></font>
        /* … */<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、関数</font><font style="vertical-align: inherit;">はパイプラインからデータ</font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読み取ります。</font><font style="vertical-align: inherit;">ただし、実装のトレースはから開始する方が適切</font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">繰り返しになりますが、引数転送合意の詳細によりコードはより複雑になりましたが、一部の詳細は省略できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">writep(fp)<font></font>
{<font></font>
    register *rp, *ip, c;<font></font>
<font></font>
    rp = fp;<font></font>
    ip = rp-&gt;f_inode;<font></font>
    c = u.u_count;<font></font>
<font></font>
loop:<font></font>
    /* If all done, return. */<font></font>
<font></font>
    plock(ip);<font></font>
    if(c == 0) {<font></font>
        prele(ip);<font></font>
        u.u_count = 0;<font></font>
        return;<font></font>
    }<font></font>
<font></font>
    /*<font></font>
     * If there are not both read and write sides of the<font></font>
     * pipe active, return error and signal too.<font></font>
     */<font></font>
<font></font>
    if(ip-&gt;i_count &lt; 2) {<font></font>
        prele(ip);<font></font>
        u.u_error = EPIPE;<font></font>
        psignal(u.u_procp, SIGPIPE);<font></font>
        return;<font></font>
    }<font></font>
<font></font>
    /*<font></font>
     * If the pipe is full, wait for reads to deplete<font></font>
     * and truncate it.<font></font>
     */<font></font>
<font></font>
    if(ip-&gt;i_size1 == PIPSIZ) {<font></font>
        ip-&gt;i_mode =| IWRITE;<font></font>
        prele(ip);<font></font>
        sleep(ip+1, PPIPE);<font></font>
        goto loop;<font></font>
    }<font></font>
<font></font>
    /* Write what is possible and loop back. */<font></font>
<font></font>
    u.u_offset[0] = 0;<font></font>
    u.u_offset[1] = ip-&gt;i_size1;<font></font>
    u.u_count = min(c, PIPSIZ-u.u_offset[1]);<font></font>
    c =- u.u_count;<font></font>
    writei(ip);<font></font>
    prele(ip);<font></font>
    if(ip-&gt;i_mode&amp;IREAD) {<font></font>
        ip-&gt;i_mode =&amp; ~IREAD;<font></font>
        wakeup(ip+2);<font></font>
    }<font></font>
    goto loop;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パイプラインの入力にバイトを書き込みます</font></font><code>u.u_count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最初に、iノードをロックする必要があります（以下を参照</font></font><code>plock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>prele</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、iノード参照カウントを確認します。</font><font style="vertical-align: inherit;">パイプラインの両端は開いたままですが、カウンターは2になります。1つのリンク（out </font></font><code>rp-&gt;f_inode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を保持する</font><font style="vertical-align: inherit;">ため、カウンターが2未満の場合は、読み取りプロセスがパイプラインの端を閉じたことを意味します。</font><font style="vertical-align: inherit;">つまり、クローズドパイプラインで記述しようとしているのですが、これは誤りです。</font><font style="vertical-align: inherit;">エラーコード</font></font><code>EPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とシグナル</font></font><code>SIGPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、UNIXの第6版で</font><font style="vertical-align: inherit;">最初に</font><font style="vertical-align: inherit;">登場しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、コンベヤが開いていても、満杯になる可能性があります。この場合、別のプロセスがパイプラインから読み取り、十分なスペースを解放することを期待して、ロックを解除してスリープ状態にします。目が覚めたら、最初に戻り、再びロックをブロックして、新しい録音サイクルを開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パイプラインに十分な空きスペースがある場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">writei（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">そこに</font></a><font style="vertical-align: inherit;">データを書き込みます</font><font style="vertical-align: inherit;">。</font></font><code>i_size1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inode内</font><font style="vertical-align: inherit;">のパラメーター</font><font style="vertical-align: inherit;">（空のパイプラインを0にすることもできます）は、すでに含まれているデータの終わりを示します。十分な記録容量がある場合は、我々からのコンベアを埋めることができ</font></font><code>i_size1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">へ</font></font><code>PIPESIZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。次に、ロックを解除し、パイプラインから読み取る機会を待っているプロセスを起こそうとします。最初に戻って、必要なバイト数を書き込めたかどうかを確認します。失敗した場合は、新しい記録サイクルを開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
典型的には</font></font><code>i_mode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、iノードの</font><font style="vertical-align: inherit;">パラメータである</font><font style="vertical-align: inherit;">アクセス許可を格納するために使用される</font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。しかし、パイプラインの場合、あるプロセスが</font><font style="vertical-align: inherit;">それぞれ</font><font style="vertical-align: inherit;">ビット</font></font><code>IREAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">ビット</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して書き込みまたは読み取りを待機していることを通知し</font></font><code>IWRITE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。プロセスはフラグを設定して呼び出し</font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">将来、他のプロセスが呼び出されることが予想されます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本当の魔法がで起こる</font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それらは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">slp.cに</font></a><font style="vertical-align: inherit;">実装されてい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、有名な解説のソース、「あなたはこれを理解することは期待されていません。」</font><font style="vertical-align: inherit;">幸い、コードを理解する必要はありません。いくつかのコメントを参照してください。</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Give up the processor till a wakeup occurs<font></font>
 * on chan, at which time the process<font></font>
 * enters the scheduling queue at priority pri.<font></font>
 * The most important effect of pri is that when<font></font>
 * pri&lt;0 a signal cannot disturb the sleep;<font></font>
 * if pri&gt;=0 signals will be processed.<font></font>
 * Callers of this routine must be prepared for<font></font>
 * premature return, and check that the reason for<font></font>
 * sleeping has gone away.<font></font>
 */<font></font>
sleep(chan, pri) /* … */<font></font>
<font></font>
/*<font></font>
 * Wake up all processes sleeping on chan.<font></font>
 */<font></font>
wakeup(chan) /* … */<font></font>
</code></pre><br><font style="vertical-align: inherit;"></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のチャネル</font><font style="vertical-align: inherit;">
を呼び出すプロセスは</font><font style="vertical-align: inherit;">、後で</font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じチャネル</font><font style="vertical-align: inherit;">を呼び出す別のプロセスによって起動</font><font style="vertical-align: inherit;">される場合があります。</font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そのようなペアの呼び出しを通じて彼らの行動を調整します。</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出すとき</font><font style="vertical-align: inherit;">は</font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常に優先さ</font></font><code>PPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れること</font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">注意してください</font></font><code>sleep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そのため、誰も</font><font style="vertical-align: inherit;">がシグナルで割り込みできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、関数を理解するためのすべてが揃いました</font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">readp(fp)<font></font>
int *fp;<font></font>
{<font></font>
    register *rp, *ip;<font></font>
<font></font>
    rp = fp;<font></font>
    ip = rp-&gt;f_inode;<font></font>
<font></font>
loop:<font></font>
    /* Very conservative locking. */<font></font>
<font></font>
    plock(ip);<font></font>
<font></font>
    /*<font></font>
     * If the head (read) has caught up with<font></font>
     * the tail (write), reset both to 0.<font></font>
     */<font></font>
<font></font>
    if(rp-&gt;f_offset[1] == ip-&gt;i_size1) {<font></font>
        if(rp-&gt;f_offset[1] != 0) {<font></font>
            rp-&gt;f_offset[1] = 0;<font></font>
            ip-&gt;i_size1 = 0;<font></font>
            if(ip-&gt;i_mode&amp;IWRITE) {<font></font>
                ip-&gt;i_mode =&amp; ~IWRITE;<font></font>
                wakeup(ip+1);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        /*<font></font>
         * If there are not both reader and<font></font>
         * writer active, return without<font></font>
         * satisfying read.<font></font>
         */<font></font>
<font></font>
        prele(ip);<font></font>
        if(ip-&gt;i_count &lt; 2)<font></font>
            return;<font></font>
        ip-&gt;i_mode =| IREAD;<font></font>
        sleep(ip+2, PPIPE);<font></font>
        goto loop;<font></font>
    }<font></font>
<font></font>
    /* Read and return */<font></font>
<font></font>
    u.u_offset[0] = 0;<font></font>
    u.u_offset[1] = rp-&gt;f_offset[1];<font></font>
    readi(ip);<font></font>
    rp-&gt;f_offset[1] = u.u_offset[1];<font></font>
    prele(ip);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数を下から上に読む方が簡単な場合があります。 「読み取りと戻り」ブランチは通常、パイプラインにデータがある場合に使用されます。この場合、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readi（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">して、現在の</font></font><code>f_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読み取り</font><font style="vertical-align: inherit;">から可能な限り多くのデータを</font><font style="vertical-align: inherit;">読み取り、対応するオフセットの値を更新します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
後続の読み取りでは、読み取りオフセットが</font></font><code>i_size1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iノードの</font><font style="vertical-align: inherit;">値に達した場合、パイプラインは空になります</font><font style="vertical-align: inherit;">。位置を0にリセットし、パイプラインに書き込みたいプロセスを起こします。コンベヤがいっぱいになる</font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">、で</font><font style="vertical-align: inherit;">眠りに落ちる</font><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">わかって</font><font style="vertical-align: inherit;">い</font></font><code>ip+1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。そしてパイプラインが空になったので、それをウェイクアップして、記録サイクルを再開できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読むものがない場合は</font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、フラグ</font></font><code>IREAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">設定して</font><font style="vertical-align: inherit;">眠りにつく</font><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">ができます</font></font><code>ip+2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">彼</font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がパイプラインにデータを書き込ん</font><font style="vertical-align: inherit;">だ</font><font style="vertical-align: inherit;">ときに</font><font style="vertical-align: inherit;">何が彼を目覚めさせるかはわかっています</font><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">readi（）およびwritei（）</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
に関するコメントは、</font><font style="vertical-align: inherit;">パラメーターを " </font><font style="vertical-align: inherit;">" </font><font style="vertical-align: inherit;">で渡す代わりに</font><font style="vertical-align: inherit;">、ファイル、位置、メモリー内のバッファーを取り、読み取りまたは書き込みのバイト数をカウントする通常のI / O関数として扱うことができること</font><font style="vertical-align: inherit;">を理解するのに役立ち</font><font style="vertical-align: inherit;">ます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>u</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Read the file corresponding to<font></font>
 * the inode pointed at by the argument.<font></font>
 * The actual read arguments are found<font></font>
 * in the variables:<font></font>
 *    u_base        core address for destination<font></font>
 *    u_offset    byte offset in file<font></font>
 *    u_count        number of bytes to read<font></font>
 *    u_segflg    read to kernel/user<font></font>
 */<font></font>
readi(aip)<font></font>
struct inode *aip;<font></font>
/* … */<font></font>
<font></font>
/*<font></font>
 * Write the file corresponding to<font></font>
 * the inode pointed at by the argument.<font></font>
 * The actual write arguments are found<font></font>
 * in the variables:<font></font>
 *    u_base        core address for source<font></font>
 *    u_offset    byte offset in file<font></font>
 *    u_count        number of bytes to write<font></font>
 *    u_segflg    write to kernel/user<font></font>
 */<font></font>
writei(aip)<font></font>
struct inode *aip;<font></font>
/* … */<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「保守的」、ロック、用として、</font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">限り、彼らは仕事を終えるか、結果（すなわち、原因を取得しないようするためのブロックiノード</font></font><code>wakeup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><code>plock()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼らは</font></font><code>prele()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単に仕事：通話の異なるセットを使用</font></font><code>sleep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、</font></font><code>wakeup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは単に削除されたことを、ロックを必要とする任意のプロセスをウェイクアップすることができます：</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
 * Lock a pipe.<font></font>
 * If its already locked, set the WANT bit and sleep.<font></font>
 */<font></font>
plock(ip)<font></font>
int *ip;<font></font>
{<font></font>
    register *rp;<font></font>
<font></font>
    rp = ip;<font></font>
    while(rp-&gt;i_flag&amp;ILOCK) {<font></font>
        rp-&gt;i_flag =| IWANT;<font></font>
        sleep(rp, PPIPE);<font></font>
    }<font></font>
    rp-&gt;i_flag =| ILOCK;<font></font>
}<font></font>
<font></font>
/*<font></font>
 * Unlock a pipe.<font></font>
 * If WANT bit is on, wakeup.<font></font>
 * This routine is also used to unlock inodes in general.<font></font>
 */<font></font>
prele(ip)<font></font>
int *ip;<font></font>
{<font></font>
    register *rp;<font></font>
<font></font>
    rp = ip;<font></font>
    rp-&gt;i_flag =&amp; ~ILOCK;<font></font>
    if(rp-&gt;i_flag&amp;IWANT) {<font></font>
        rp-&gt;i_flag =&amp; ~IWANT;<font></font>
        wakeup(rp);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初はどうして</font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電話の</font></font><code>prele(ip)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前に電話</font><font style="vertical-align: inherit;">がつかないの</font><font style="vertical-align: inherit;">か理解できませんでした</font></font><code>wakeup(ip+1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ループで</font><font style="vertical-align: inherit;">最初</font></font><code>plock(ip)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に発生</font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するのは、ブロックがまだ削除されていない</font><font style="vertical-align: inherit;">とデッドロックが発生する</font><font style="vertical-align: inherit;">ため、コードが何らかの方法で正しく機能する必要があることです。あなたがそれを見ると</font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、彼はスリープ状態のプロセスを実行の準備ができているとマークするだけであることが明らかになるので、将来的にそれは</font></font><code>sched()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本当にそれを起動します。したがって、それ</font></font><code>readp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>wakeup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ロック解除、設定</font></font><code>IREAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、呼び出し</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">引き起こし</font><font style="vertical-align: inherit;">ます</font></font><code>sleep(ip+2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これ</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">すべて</font></font><code>writep()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、サイクルを再開する</font><font style="vertical-align: inherit;">前に行われ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、第6版のコンベヤの説明は完了です。シンプルなコード、広範囲にわたる影響。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unixの第7版</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1979年1月）は新しいメジャーリリース（4年後）で、多くの新しいアプリケーションとカーネルプロパティが登場しました。</font><font style="vertical-align: inherit;">また、型キャスト、union'ov、および構造体への型付きポインターの使用に関連して、大幅な変更が行われました。</font><font style="vertical-align: inherit;">ただし、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パイプラインコード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はあまり変更されていません。</font><font style="vertical-align: inherit;">このエディションはスキップできます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xv6、単純なUnix型カーネル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unix </font><font style="vertical-align: inherit;">
の</font><font style="vertical-align: inherit;">第6版は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xv6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コアの作成に</font><font style="vertical-align: inherit;">影響を与えました</font><font style="vertical-align: inherit;">が、</font><font style="vertical-align: inherit;">x86プロセッサで実行するように最新のCで記述されています。コードは読みやすく、明確です。さらに、TUHSを使用するUnixソースとは異なり、コンパイルして変更し、PDP 11/70以外の何かで実行することができます。したがって、このコアは、オペレーティングシステムの教育資料として大学で広く使用されています。ソース</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はGithubにあり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードには</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pipe.cの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明確でよく考えられた実装が含まれており、</font><font style="vertical-align: inherit;">ディスク上のiノードではなくメモリ内のバッファによってバックアップされます。ここでは、「構造パイプライン」と関数の定義のみを示します</font></font><code>pipealloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">#define PIPESIZE 512<font></font>
<font></font>
struct pipe {<font></font>
  struct spinlock lock;<font></font>
  char data[PIPESIZE];<font></font>
  uint nread;     // number of bytes read<font></font>
  uint nwrite;    // number of bytes written<font></font>
  int readopen;   // read fd is still open<font></font>
  int writeopen;  // write fd is still open<font></font>
};<font></font>
<font></font>
int<font></font>
pipealloc(struct file **f0, struct file **f1)<font></font>
{<font></font>
  struct pipe *p;<font></font>
<font></font>
  p = 0;<font></font>
  *f0 = *f1 = 0;<font></font>
  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)<font></font>
    goto bad;<font></font>
  if((p = (struct pipe*)kalloc()) == 0)<font></font>
    goto bad;<font></font>
  p-&gt;readopen = 1;<font></font>
  p-&gt;writeopen = 1;<font></font>
  p-&gt;nwrite = 0;<font></font>
  p-&gt;nread = 0;<font></font>
  initlock(&amp;p-&gt;lock, "pipe");<font></font>
  (*f0)-&gt;type = FD_PIPE;<font></font>
  (*f0)-&gt;readable = 1;<font></font>
  (*f0)-&gt;writable = 0;<font></font>
  (*f0)-&gt;pipe = p;<font></font>
  (*f1)-&gt;type = FD_PIPE;<font></font>
  (*f1)-&gt;readable = 0;<font></font>
  (*f1)-&gt;writable = 1;<font></font>
  (*f1)-&gt;pipe = p;<font></font>
  return 0;<font></font>
<font></font>
 bad:<font></font>
  if(p)<font></font>
    kfree((char*)p);<font></font>
  if(*f0)<font></font>
    fileclose(*f0);<font></font>
  if(*f1)<font></font>
    fileclose(*f1);<font></font>
  return -1;<font></font>
}<font></font>
</code></pre><br>
<code>pipealloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能を含む実装の残りの状態を設定し</font></font><code>piperead()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>pipewrite()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><code>pipeclose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">実際のシステムコール</font></font><code>sys_pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sysfile.cに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装されているラッパー</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">です</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">すべてのコードを読むことをお勧めします。</font><font style="vertical-align: inherit;">複雑さは第6版のソースレベルにありますが、読む方がはるかに簡単で快適です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 0.01</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux 0.01のソースコードを見つけることができます。</font><font style="vertical-align: inherit;">彼</font></font><code>fs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font><font style="vertical-align: inherit;">のパイプラインの実装を研究することは有益</font></font><code>pipe.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">ここでは、パイプラインを表すためにiノードが使用されていますが、パイプライン自体は最新のCで記述されています。</font><font style="vertical-align: inherit;">これは関数がどのように見えるか</font></font><code>write_pipe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です：</font></font><br>
<br>
<pre><code class="plaintext hljs">int write_pipe(struct m_inode * inode, char * buf, int count)<font></font>
{<font></font>
    char * b=buf;<font></font>
<font></font>
    wake_up(&amp;inode-&gt;i_wait);<font></font>
    if (inode-&gt;i_count != 2) { /* no readers */<font></font>
        current-&gt;signal |= (1&lt;&lt;(SIGPIPE-1));<font></font>
        return -1;<font></font>
    }<font></font>
    while (count--&gt;0) {<font></font>
        while (PIPE_FULL(*inode)) {<font></font>
            wake_up(&amp;inode-&gt;i_wait);<font></font>
            if (inode-&gt;i_count != 2) {<font></font>
                current-&gt;signal |= (1&lt;&lt;(SIGPIPE-1));<font></font>
                return b-buf;<font></font>
            }<font></font>
            sleep_on(&amp;inode-&gt;i_wait);<font></font>
        }<font></font>
        ((char *)inode-&gt;i_size)[PIPE_HEAD(*inode)] =<font></font>
            get_fs_byte(b++);<font></font>
        INC_PIPE( PIPE_HEAD(*inode) );<font></font>
        wake_up(&amp;inode-&gt;i_wait);<font></font>
    }<font></font>
    wake_up(&amp;inode-&gt;i_wait);<font></font>
    return b-buf;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造の定義を見なくても、書き込み操作がにつながるかどうかを確認するために使用されるiノード参照に対抗する方法を理解できます</font></font><code>SIGPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">バイトワークに加えて、この関数は上記のアイデアと簡単に関連付けることができます。</font><font style="vertical-align: inherit;">ロジックも</font></font><code>sleep_on</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>wake_up</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エイリアンに見えません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最新のLinux、FreeBSD、NetBSD、OpenBSDカーネル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はすぐに最新のカーネルをいくつか調べました。それらのどれもすでにディスク実装を備えていません（当然のことですが）。 Linuxには独自の実装があります。最近の3つのBSDカーネルには、John Dysonによって作成されたコードに基づく実装が含まれていますが、年月を重ねると、それらは互いに大きく異なります。</font><font style="vertical-align: inherit;">/ </font><font style="vertical-align: inherit;">（Linuxの場合）または</font><font style="vertical-align: inherit;">/ </font><font style="vertical-align: inherit;">/ </font><font style="vertical-align: inherit;">（* BSDの場合）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を読むに</font><font style="vertical-align: inherit;">は、真の献身が必要です。今日のコードでは、ベクトルや非同期I / Oなどの機能のパフォーマンスとサポートが重要です。そして、メモリ割り当て、ロック、カーネル構成の詳細-これはすべて非常に異なります。これは、大学がオペレーティングシステムの入門コースに必要なものではありません。</font></font><code>fs</code><font style="vertical-align: inherit;"></font><code>pipe.c</code><font style="vertical-align: inherit;"></font><code>sys</code><font style="vertical-align: inherit;"></font><code>kern</code><font style="vertical-align: inherit;"></font><code>sys_pipe.c</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とにかく</font><font style="vertical-align: inherit;">、これらすべての非常に異なる最新のコアで、</font><font style="vertical-align: inherit;">いくつかの古いパターン（たとえば、</font><font style="vertical-align: inherit;">閉じたパイプラインに書き込むとき</font><font style="vertical-align: inherit;">に生成</font></font><code>SIGPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して戻る）</font><font style="vertical-align: inherit;">を発掘するのは興味深いことでした</font></font><code>EPIPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">おそらく私はライブのPDP-11コンピュータを見ることはないでしょうが、私の誕生の数年前に書かれたコードから学ぶべきことはまだたくさんあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2011年にDivi Kapoorによって書かれた記事「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パイプとFIFOのLinuxカーネル実装</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」は、Linuxでのパイプラインの動作（これまでのところ）の概要を説明しています。</font><font style="vertical-align: inherit;">また、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最近のLinuxコミット</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、一時ファイルの機能を超える機能を持つパイプライン型対話モデルを示しています。</font><font style="vertical-align: inherit;">また、第6版のUNIXカーネルでパイプラインが「非常に保守的なロック」からどれだけ進んでいるかを示しています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja495472/index.html">菜食主義に切り替えてもCOVID-19のような病気に感染するのを防ぐことはできません</a></li>
<li><a href="../ja495474/index.html">DataGrip 2020.1：構成の起動、Excelへのエクスポート、エディターでの結果など</a></li>
<li><a href="../ja495476/index.html">Atari DeepMind AIの成功が残念な理由</a></li>
<li><a href="../ja495478/index.html">大小のデータテスター：トレンド、理論、私のストーリー</a></li>
<li><a href="../ja495480/index.html">SIPを使用してC / C ++ライブラリのPythonバインディングを作成します。パート1</a></li>
<li><a href="../ja495486/index.html">機密データへの新しい脅威：アクロニスグローバル調査結果</a></li>
<li><a href="../ja495490/index.html">DUMP 2020カンファレンスのテストとQAセクション。今年の予定は？スポイラー：鎮痛剤とチェリーのペア</a></li>
<li><a href="../ja495492/index.html">アンリアルエンジン4 iOSゲームのリリース機能</a></li>
<li><a href="../ja495494/index.html">計画ルールのカスタムセットを使用して追加のkubeスケジューラを作成する</a></li>
<li><a href="../ja495500/index.html">Alexey Klyanin：「2018年まで、ブログではOSMを基質としてのみ使用していました」</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>