<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí± üà≤ ‚ô®Ô∏è Criando roguelike no Unity a partir do zero: gerador de masmorras üå¶Ô∏è üí£ üéÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desta vez, mergulharemos na implementa√ß√£o do algoritmo do gerador de masmorras. No √∫ltimo artigo, criamos a primeira sala e agora vamos gerar o restan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Criando roguelike no Unity a partir do zero: gerador de masmorras</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png" alt="imagem"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desta vez, mergulharemos na implementa√ß√£o do algoritmo do gerador de masmorras. No </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√∫ltimo artigo,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> criamos a primeira sala e agora vamos gerar o restante do n√≠vel da masmorra. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas antes de come√ßarmos, eu gostaria de corrigir um erro de uma postagem anterior. De fato, nas √∫ltimas semanas, aprendi algo novo, e √© por isso que parte do meu trabalho est√° desatualizada, e quero falar sobre isso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembra da classe Position que criamos? De fato, o Unity j√° possui uma classe interna que executa exatamente as mesmas fun√ß√µes, mas com um controle um pouco melhor - √© mais f√°cil declarar e processar. Essa classe √© chamada Vector2Int. Portanto, antes de iniciar, removeremos a classe Position do MapManager.cs e substituiremos cada vari√°vel Position pela vari√°vel Vector2Int.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/b7d/f40/656b7df4053976af99cbd2d359edd494.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mesmo precisa ser feito em v√°rios lugares no script DungeonGenerator.cs. </font><font style="vertical-align: inherit;">Agora vamos ao resto do algoritmo.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 7 - gera√ß√£o de sala / sal√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Come√ßaremos com uma pequena altera√ß√£o na fun√ß√£o FirstRoom () criada na √∫ltima vez. </font><font style="vertical-align: inherit;">Em vez de criar outra fun√ß√£o para gerar todos os outros elementos do mapa e duplicar um monte de c√≥digo, simplesmente transformamos essa fun√ß√£o, transformando-a em um GenerateFeature () generalizado. </font><font style="vertical-align: inherit;">Portanto, altere o nome de FirstRoom para GenerateFeature. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora precisaremos passar par√¢metros para esta fun√ß√£o. </font><font style="vertical-align: inherit;">Primeiro de tudo, voc√™ precisa saber qual fun√ß√£o ela gera - uma sala ou um corredor. </font><font style="vertical-align: inherit;">Podemos apenas passar uma string chamada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A seguir, a fun√ß√£o precisa conhecer o ponto de partida do elemento, ou seja, de qual parede ele vem (porque sempre criamos um novo elemento a partir da parede do elemento antigo) e, para isso, passar como argumento Wall √© suficiente. </font><font style="vertical-align: inherit;">Por fim, a primeira sala a ser criada possui caracter√≠sticas especiais; portanto, precisamos de uma vari√°vel bool opcional que informe se o item √© a primeira sala. </font><font style="vertical-align: inherit;">Por padr√£o, √© falso: bool isFirst = false. </font><font style="vertical-align: inherit;">Portanto, o t√≠tulo da fun√ß√£o mudar√° disso:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/b79/d17/e5fb79d178098b3bcde238ff733f9ca9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nisto:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45e/124/afc/45e124afc4b4f60b12ab18deaa060719.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem. </font><font style="vertical-align: inherit;">O pr√≥ximo passo √© alterar a maneira como voc√™ calcula a largura e a altura do elemento. </font><font style="vertical-align: inherit;">Enquanto os calculamos, obtendo um valor aleat√≥rio entre os valores m√≠nimo e m√°ximo da altura e largura das salas - isso √© ideal para salas, mas n√£o funciona para corredores. </font><font style="vertical-align: inherit;">At√© agora, temos o seguinte:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f5/c0d/976/2f5c0d9765a596c2d2188b56b1f7b7ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas os corredores ter√£o um tamanho constante de 3 em largura ou altura, dependendo da orienta√ß√£o. </font><font style="vertical-align: inherit;">Portanto, precisamos verificar qual √© o elemento - uma sala ou um corredor e, em seguida, executar os c√°lculos apropriados.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/163/df8/071163df82fc248fc92d370672369743.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim. </font><font style="vertical-align: inherit;">verificamos se o item √© uma sala. </font><font style="vertical-align: inherit;">Se sim, ent√£o fazemos o mesmo de antes </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - obtemos um n√∫mero aleat√≥rio no intervalo entre min e max de altura e largura. </font><font style="vertical-align: inherit;">Mas agora </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, do</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mesmo modo, se voc√™ precisar fazer algo um pouco diferente. </font><font style="vertical-align: inherit;">Precisamos verificar a orienta√ß√£o do corredor. </font><font style="vertical-align: inherit;">Felizmente, ao gerar um muro, salvamos informa√ß√µes sobre para qual dire√ß√£o ele √© direcionado e, portanto, usamos para obter a orienta√ß√£o do corredor.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91a/a84/328/91aa84328140d1414b8512843e1cd397.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas ainda n√£o declaramos a vari√°vel minCorridorLength. </font><font style="vertical-align: inherit;">Voc√™ precisa voltar para as declara√ß√µes de vari√°veis ‚Äã‚Äãe declar√°-las, logo acima de maxCorridorLength.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/857/6e1/f138576e1dc1cb4a9949fd51e8c5fe47.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, de volta √†s nossas instru√ß√µes de troca condicional. </font><font style="vertical-align: inherit;">O que estamos fazendo aqui: obtemos o valor da </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dire√ß√£o do</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muro, ou seja, para onde o muro est√° olhando, de onde o corredor passar√°. </font><font style="vertical-align: inherit;">A dire√ß√£o pode ter apenas quatro valores poss√≠veis: sul, norte, oeste e leste. </font><font style="vertical-align: inherit;">No sul e norte, o corredor ter√° uma largura de 3 (duas paredes e um piso no meio) e uma altura vari√°vel (comprimento). </font><font style="vertical-align: inherit;">Para oeste e leste, tudo ser√° o contr√°rio: a altura ser√° constantemente igual a 3 e a largura ter√° um comprimento vari√°vel. </font><font style="vertical-align: inherit;">Ent√£o, vamos faz√™-lo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e2/175/8d6/0e21758d6d2e17406ce516c3fef6ccf5.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uau. </font><font style="vertical-align: inherit;">E foi a√≠ que acabamos dimensionando o novo item. </font><font style="vertical-align: inherit;">Agora voc√™ precisa decidir onde coloc√°-lo. </font><font style="vertical-align: inherit;">Colocamos a primeira sala em um local aleat√≥rio dentro dos valores-limite relativos ao centro do mapa.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fb/d53/010/6fbd5301066f6b0ba77ab90142370a5d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas para todos os outros elementos, isso n√£o funcionar√°. Eles devem come√ßar ao lado do ponto aleat√≥rio na parede a partir da qual o elemento √© gerado. Ent√£o, vamos mudar o c√≥digo. Primeiro, precisamos verificar se o elemento √© a primeira sala. Se esta √© a primeira sala, definimos os pontos de partida da mesma maneira que antes - como metade da largura e altura do mapa.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d29/44d/ff3d2944da973a48200a6c9c3066d20d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caso </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contr√°rio,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se o elemento n√£o for a primeira sala, obteremos um ponto aleat√≥rio na parede a partir da qual o elemento √© gerado. Primeiro, devemos verificar se a parede tem um tamanho de 3 (isso significa que √© o ponto final do corredor) e, nesse caso, o ponto do meio ser√° sempre selecionado, ou seja, o √≠ndice 1 da matriz da parede (com 3 elementos, a matriz ter√° √≠ndices 0, 1, 2). Mas se o tamanho n√£o for igual a 3 (a parede n√£o √© o ponto final do corredor), tomaremos um ponto aleat√≥rio no intervalo entre o ponto 1 e o comprimento da parede menos 2. Isso √© necess√°rio para evitar passagens criadas no canto. Ou seja, por exemplo, em uma parede com um comprimento de 6, exclu√≠mos os √≠ndices 0 e 5 (primeiro e √∫ltimo) e selecionamos um ponto aleat√≥rio entre os pontos 1, 2, 3 e 4.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/4e1/703/ee24e1703c28b4cfa96e98d84a76c790.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora temos a posi√ß√£o do ponto na parede em que um novo elemento ser√° criado. Mas n√£o podemos simplesmente come√ßar a gerar um elemento a partir da√≠, pois assim ser√° bloqueado por paredes j√° colocadas. Tamb√©m √© importante observar que o elemento come√ßa a ser gerado a partir do canto inferior esquerdo e, em seguida, o incremento √© realizado para a direita e para cima, portanto, devemos definir a posi√ß√£o inicial em locais diferentes, dependendo da dire√ß√£o em que a parede estiver olhando. Al√©m disso, a primeira coluna x e a primeira linha y ser√£o paredes, e se iniciarmos um novo elemento pr√≥ximo a um ponto na parede, podemos criar um corredor que termina em um canto da sala e n√£o em um local adequado na parede.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, se a parede estiver direcionada para o norte, √© necess√°rio que o elemento comece em uma posi√ß√£o ao norte no eixo y, mas em um n√∫mero aleat√≥rio de posi√ß√µes a oeste no eixo x, no intervalo de 1 √† largura da sala-2. </font><font style="vertical-align: inherit;">Na dire√ß√£o sul, o eixo x age da mesma forma, mas a posi√ß√£o inicial no eixo y √© a posi√ß√£o do ponto na parede menos a altura da sala. </font><font style="vertical-align: inherit;">As muralhas ocidental e oriental seguem a mesma l√≥gica, apenas com eixos invertidos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas antes de fazer tudo isso, precisamos salvar a posi√ß√£o do ponto da parede na vari√°vel Vector2Int para que possamos manipul√°-lo mais tarde.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/129/41a/37412941a3a58f32fd2dd38c1fc2c252.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√ìtimo. </font><font style="vertical-align: inherit;">Vamos fazer isso.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/2c7/ec0/1402c7ec0596d77f9a9b70b5eac076a9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, geramos um elemento com o tamanho e a posi√ß√£o, e o pr√≥ximo passo √© colocar o elemento no mapa. </font><font style="vertical-align: inherit;">Mas primeiro, precisamos descobrir se realmente h√° espa√ßo no mapa para esse elemento nessa posi√ß√£o. </font><font style="vertical-align: inherit;">Por enquanto, chamamos a fun√ß√£o CheckIfHasSpace (). </font><font style="vertical-align: inherit;">Ser√° destacado em vermelho, porque ainda n√£o o implementamos. </font><font style="vertical-align: inherit;">Faremos isso logo ap√≥s concluir o que precisa ser feito aqui na fun√ß√£o GenerateFeature (). </font><font style="vertical-align: inherit;">Portanto, ignore o sublinhado vermelho e continue.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/805/942/b2080594237c23cae023cabb20b2d20e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na pr√≥xima parte, paredes s√£o criadas. </font><font style="vertical-align: inherit;">At√© toc√°-lo, com exce√ß√£o do fragmento no segundo loop </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/d7f/e2b/227d7fe2bf3c2eef41f423e36b4afc79.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enquanto escrevia este post, notei que essas constru√ß√µes if-else est√£o completamente erradas. Por exemplo, algumas paredes nelas receber√£o um comprimento de 1. Isso acontece porque quando a posi√ß√£o deve ser adicionada, digamos, √† parede norte, se ela estava na esquina com a parede leste, n√£o ser√° adicionada √† parede leste, como deveria. Isso causou bugs irritantes no algoritmo de gera√ß√£o. Vamos elimin√°-los. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consert√°-los √© bem simples. √â suficiente excluir todo o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resto</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que a posi√ß√£o passe por todas as constru√ß√µes </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e n√£o pare no in√≠cio, se retornou </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Em seguida, o √∫ltimo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (aquele que n√£o √© </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais se</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) √© alterado para </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que verifica se a posi√ß√£o j√° foi adicionada como Mural e, se n√£o estiver, a adiciona como Piso.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/784/834/65c784834461a2d8b05d1d39dd9ee44c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incr√≠vel, estamos quase terminando aqui. </font><font style="vertical-align: inherit;">Agora temos um elemento completamente novo, criado no lugar certo, mas √© o mesmo que o nosso primeiro quarto: √© completamente cercado por paredes. </font><font style="vertical-align: inherit;">Isso significa que o jogador n√£o poder√° chegar a este novo local. </font><font style="vertical-align: inherit;">Ou seja, precisamos converter um ponto na parede (que, como lembramos, √© armazenado em uma vari√°vel do tipo Vector2Int) e o ponto correspondente na parede de um novo elemento no Floor. </font><font style="vertical-align: inherit;">Mas somente quando o elemento n√£o √© o primeiro quarto.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/350/67f/5ac/35067f5ac7db26fd304578b8dd53326c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este trecho de c√≥digo verifica se o novo item √© o primeiro quarto. </font><font style="vertical-align: inherit;">Caso contr√°rio, ele converte a √∫ltima posi√ß√£o da parede no ch√£o e, em seguida, verifica a dire√ß√£o que a parede est√° olhando para verificar qual ladrilho do novo elemento deve se transformar no ch√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atingimos a √∫ltima parte da fun√ß√£o GenerateFeature (). </font><font style="vertical-align: inherit;">Ele j√° possui linhas que adicionam informa√ß√µes sobre o elemento que a fun√ß√£o cria.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/165/626/4fe165626aca42951f86568a4d6649c7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui precisamos mudar alguma coisa. </font><font style="vertical-align: inherit;">Em primeiro lugar, o tipo de elemento nem sempre √© igual a Room. </font><font style="vertical-align: inherit;">Felizmente, a vari√°vel necess√°ria √© passada para a fun√ß√£o como um par√¢metro, ou seja, o tipo string. </font><font style="vertical-align: inherit;">Ent√£o, vamos substituir "Room" aqui pelo tipo</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b57/d12/f17/b57d12f17802ec40e0c609d26803f661.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Boa. </font><font style="vertical-align: inherit;">Agora, para que o algoritmo que gera todos os elementos do jogo funcione corretamente, precisamos adicionar novos dados aqui. </font><font style="vertical-align: inherit;">Ou seja, um int que conta o n√∫mero de itens criados e uma lista de todos os itens criados. </font><font style="vertical-align: inherit;">Vamos at√© o local em que declaramos todas as vari√°veis ‚Äã‚Äãe declaramos um int com o nome countFeatures, bem como uma Lista de elementos com o nome allFeatures. </font><font style="vertical-align: inherit;">A lista de todos os elementos deve ser p√∫blica e o contador int pode ser privado.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/ebf/8dd/bcbebf8ddbc768864ba70331317cc72c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, de volta √† fun√ß√£o GenerateFeature () e adicione algumas linhas ao final: incrementando a vari√°vel countFeatures e adicionando um novo elemento √† lista allFeatures.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/8a8/496/5e68a8496d7047c87650a609acb912cf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, nosso GenerateFeature () est√° quase completo. </font><font style="vertical-align: inherit;">Mais tarde, precisaremos retornar a ela para preencher a fun√ß√£o CheckIfHasSpace vazia, mas primeiro precisamos cri√°-la. </font><font style="vertical-align: inherit;">√â isso que vamos fazer agora.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 8 - verifique se h√° um local</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos criar uma nova fun√ß√£o logo ap√≥s a conclus√£o da fun√ß√£o GenerateFeature (). Ela precisa de dois argumentos: a posi√ß√£o em que o elemento come√ßa e a posi√ß√£o em que termina. Voc√™ pode usar duas vari√°veis ‚Äã‚ÄãVector2Int como elas. A fun√ß√£o deve retornar um valor bool para que ele possa ser usado em </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verificar se h√° espa√ßo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/998/f03/cad/998f03cad9a6bd8a05bd7d8b9658bad6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele est√° sublinhado em vermelho, porque at√© agora n√£o retornou nada. Em breve iremos consertar, mas por enquanto n√£o prestaremos aten√ß√£o. Nesta fun√ß√£o, percorreremos todas as posi√ß√µes entre o in√≠cio e o final do elemento e verificaremos se a posi√ß√£o atual no MapManager.map √© nula ou se j√° existe alguma coisa. Se houver algo l√°, paramos a fun√ß√£o e retornamos false. Caso contr√°rio, continue. Se a fun√ß√£o chegar ao final do loop sem atender aos locais preenchidos, retorne true. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, antes de verificar a posi√ß√£o como nula, precisamos de uma linha para verificar se a posi√ß√£o est√° dentro do mapa. Porque, caso contr√°rio, podemos receber um erro de √≠ndice de matriz e uma falha no jogo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/473/582/a5b/473582a5b560d6738de08b2f6190cf6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem. </font><font style="vertical-align: inherit;">Agora, de volta ao local em que inserimos essa fun√ß√£o dentro da fun√ß√£o GenerateFeature (). </font><font style="vertical-align: inherit;">Precisamos consertar essa chamada porque ela n√£o passa os argumentos necess√°rios. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui queremos inserir uma </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instru√ß√£o if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para verificar se h√° espa√ßo suficiente para o elemento. </font><font style="vertical-align: inherit;">Se o resultado for falso, encerramos a fun√ß√£o sem inserir um novo elemento no MapManager.map.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/068/661/e53/068661e533ef21536a51f17ae3de570b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Precisamos passar os argumentos necess√°rios, ou seja, duas vari√°veis ‚Äã‚ÄãVector2Int. </font><font style="vertical-align: inherit;">Com o primeiro, tudo √© simples, esta √© a posi√ß√£o com as coordenadas x e y do ponto inicial do elemento.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/869/26d/0c186926d741d2423c791500adbed2cd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo √© mais dif√≠cil, mas n√£o muito. </font><font style="vertical-align: inherit;">Este √© o ponto inicial mais a altura para ye largura para x, subtraindo 1 de ambos (porque o in√≠cio j√° foi levado em considera√ß√£o).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a18/f85/4a9/a18f854a9e0a0bbe5883012bf2e313ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos para a pr√≥xima etapa - criando um algoritmo para chamar a fun√ß√£o GenerateFeature ().</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 9 - elementos gerados por chamada</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voltar para a fun√ß√£o GenerateDungeon () criada na parte anterior do artigo. </font><font style="vertical-align: inherit;">Agora deve ficar assim:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/57c/5e3/3e957c5e316f5329e935353e961df47b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A chamada para FirstRoom () est√° sublinhada em vermelho porque alteramos o nome dessa fun√ß√£o. </font><font style="vertical-align: inherit;">Ent√£o, vamos chamar a primeira gera√ß√£o de quarto.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d6/926/908/8d692690826997750f3bc860ae9216f0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passamos os argumentos necess√°rios: ‚ÄúRoom‚Äù como tipo, porque o primeiro quarto sempre ser√° Room, novo Wall (), porque o primeiro quarto n√£o ser√° criado a partir de nenhum outro, apenas passamos nulos, e isso √© normal. Em vez de novo Wall (), voc√™ pode substituir </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , isso √© uma quest√£o de prefer√™ncia pessoal. O √∫ltimo argumento determina se o novo elemento √© a primeira sala; portanto, no nosso caso, passamos a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verdade</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora chegamos ao ponto principal. Usamos um loop for que ser√° executado 500 vezes - sim, tentaremos adicionar elementos 500 vezes. Mas se o n√∫mero de elementos criados (vari√°vel countFeatures) for igual ao n√∫mero m√°ximo especificado de elementos (vari√°vel maxFeatures), interromperemos esse ciclo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e6/410/ded/9e6410ded47210776fcda40ae2492229.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira etapa desse loop √© declarar o elemento a partir do qual o novo elemento ser√° criado. </font><font style="vertical-align: inherit;">Se tivermos criado apenas um elemento (a primeira sala), ser√° o original. </font><font style="vertical-align: inherit;">Caso contr√°rio, selecionamos aleatoriamente um dos elementos j√° criados.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddb/e84/f92/ddbe84f92cbb06f56e3ccce561dde991.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos escolher qual parede desse elemento ser√° usada para criar o novo elemento.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/e7c/0e4/7ade7c0e438985098eed6f5dbdd42e6d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que ainda n√£o temos essa fun√ß√£o ChoseWall (). </font><font style="vertical-align: inherit;">Vamos escrever rapidamente. </font><font style="vertical-align: inherit;">V√° at√© o final da fun√ß√£o e crie-a. </font><font style="vertical-align: inherit;">Ele deve retornar uma parede e usar um elemento como argumento, para que a fun√ß√£o possa selecionar a parede desse elemento.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aeb/631/9f1/aeb6319f1ee6f601474d0aa0e32e2c77.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu o criei entre as fun√ß√µes CheckIfHasSpace () e DrawMap (). </font><font style="vertical-align: inherit;">Observe que, se voc√™ estiver trabalhando no Visual Studio, instalado com o Unity, poder√° usar os campos - / + √† esquerda para recolher / expandir partes do c√≥digo para simplificar o trabalho. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesta fun√ß√£o, encontraremos a parede a partir da qual o elemento ainda n√£o foi criado. </font><font style="vertical-align: inherit;">√Äs vezes, obteremos elementos com uma ou mais paredes das quais outros elementos j√° est√£o anexados; portanto, precisamos verificar repetidamente se alguma das paredes aleat√≥rias est√° livre. </font><font style="vertical-align: inherit;">Para fazer isso, usamos um loop for repetido dez vezes - se ap√≥s essas dez vezes uma parede livre n√£o for encontrada, a fun√ß√£o retornar√° nulo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/44a/028/b1044a028bf9ab566a0120690311396d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, volte para a fun√ß√£o GenerateDungeon () e passe o elemento original como par√¢metro para a fun√ß√£o ChoseWall ().</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/281/8aa/0a32818aafc77ddd87f1ffac21b6981e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A linha </font></font><code>if (wall == null) continue;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significa que, se a fun√ß√£o de pesquisa de parede retornou falsa, o elemento original n√£o pode gerar um novo elemento; portanto, a fun√ß√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuar√° o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ciclo, ou seja, n√£o poder√° criar um novo elemento e prosseguir√° para a pr√≥xima itera√ß√£o do ciclo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora precisamos selecionar o tipo para o pr√≥ximo item. </font><font style="vertical-align: inherit;">Se o elemento de origem for uma sala, o pr√≥ximo dever√° ser um corredor (n√£o queremos que a sala conduza diretamente para outra sala sem um corredor entre eles). </font><font style="vertical-align: inherit;">Mas se esse for um corredor, precisamos criar a probabilidade de que outro corredor ou sala seja o pr√≥ximo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b22/df0/954/b22df0954bbe21d82506d42e5118a70f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem. </font><font style="vertical-align: inherit;">Agora s√≥ precisamos chamar a fun√ß√£o GenerateFeature (), passando a parede e digite como par√¢metros.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a07/90b/834/a0790b83479f46dc17c57fbb981aef81.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por fim, v√° ao inspetor do Unity, selecione o objeto GameManager e altere os valores para o seguinte:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cc/09c/786/9cc09c786641bf85a89674cc33042ebf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ agora clicar no bot√£o play, j√° ver√° os resultados!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como eu disse, essa n√£o √© a melhor masmorra. </font><font style="vertical-align: inherit;">Temos muitos becos sem sa√≠da. </font><font style="vertical-align: inherit;">Mas √© totalmente funcional e garante que voc√™ n√£o ter√° uma sala que n√£o esteja conectada a nenhuma outra. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que tenha gostado! </font><font style="vertical-align: inherit;">No pr√≥ximo post, criaremos um jogador que passar√° pela masmorra e depois transformaremos o mapa de ASCII em sprite.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.UI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Post3</span> : <span class="hljs-title">MonoBehaviour</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapWidth;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapHeight;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMaxRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMaxRoom;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> minCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxFeatures;
    <span class="hljs-keyword">int</span> countFeatures;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isASCII;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> List&lt;Feature&gt; allFeatures;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        MapManager.map = <span class="hljs-keyword">new</span> Tile[mapWidth, mapHeight];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GenerateDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        GenerateFeature(<span class="hljs-string">"Room"</span>, <span class="hljs-keyword">new</span> Wall(), <span class="hljs-literal">true</span>);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) {<font></font>
            Feature originFeature;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (allFeatures.Count == <span class="hljs-number">1</span>) {<font></font>
                originFeature = allFeatures[<span class="hljs-number">0</span>];<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {<font></font>
                originFeature = allFeatures[Random.Range(<span class="hljs-number">0</span>, allFeatures.Count - <span class="hljs-number">1</span>)];<font></font>
            }<font></font>
<font></font>
            Wall wall = ChoseWall(originFeature);<font></font>
            <span class="hljs-keyword">if</span> (wall == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
            <span class="hljs-keyword">string</span> type;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (originFeature.type == <span class="hljs-string">"Room"</span>) {<font></font>
                type = <span class="hljs-string">"Corridor"</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) &lt; <span class="hljs-number">90</span>) {<font></font>
                    type = <span class="hljs-string">"Room"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                    type = <span class="hljs-string">"Corridor"</span>;<font></font>
                }<font></font>
            }<font></font>
<font></font>
            GenerateFeature(type, wall);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (countFeatures &gt;= maxFeatures) <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
<font></font>
        DrawMap(isASCII);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GenerateFeature</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> type, Wall wall, <span class="hljs-keyword">bool</span> isFirst = <span class="hljs-literal">false</span></span>)</span> {<font></font>
        Feature room = <span class="hljs-keyword">new</span> Feature();<font></font>
        room.positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
<font></font>
        <span class="hljs-keyword">int</span> roomWidth = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> roomHeight = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) {<font></font>
            roomWidth = Random.Range(widthMinRoom, widthMaxRoom);<font></font>
            roomHeight = Random.Range(heightMinRoom, heightMaxRoom);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">int</span> xStartingPoint;
        <span class="hljs-keyword">int</span> yStartingPoint;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint = mapWidth / <span class="hljs-number">2</span>;<font></font>
            yStartingPoint = mapHeight / <span class="hljs-number">2</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">int</span> id;
            <span class="hljs-keyword">if</span> (wall.positions.Count == <span class="hljs-number">3</span>) id = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> id = Random.Range(<span class="hljs-number">1</span>, wall.positions.Count - <span class="hljs-number">2</span>);<font></font>
<font></font>
            xStartingPoint = wall.positions[id].x;<font></font>
            yStartingPoint = wall.positions[id].y;<font></font>
        }<font></font>
<font></font>
        Vector2Int lastWallPosition = <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth);<font></font>
            yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint ++;<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    xStartingPoint -= roomWidth;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    xStartingPoint++;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
         <span class="hljs-keyword">if</span> (!CheckIfHasSpace(<span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint), <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint + roomWidth - <span class="hljs-number">1</span>, yStartingPoint + roomHeight - <span class="hljs-number">1</span>))) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        room.walls = <span class="hljs-keyword">new</span> Wall[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; room.walls.Length; i++) {<font></font>
            room.walls[i] = <span class="hljs-keyword">new</span> Wall();<font></font>
            room.walls[i].positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
            room.walls[i].length = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">switch</span> (i) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"South"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"North"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"West"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"East"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; roomHeight; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; roomWidth; x++) {<font></font>
                Vector2Int position = <span class="hljs-keyword">new</span> Vector2Int();<font></font>
                position.x = xStartingPoint + x;<font></font>
                position.y = yStartingPoint + y;<font></font>
<font></font>
                room.positions.Add(position);<font></font>
<font></font>
                MapManager.map[position.x, position.y] = <span class="hljs-keyword">new</span> Tile();<font></font>
                MapManager.map[position.x, position.y].xPosition = position.x;<font></font>
                MapManager.map[position.x, position.y].yPosition = position.y;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">0</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">0</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (y == (roomHeight - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">1</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">1</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">2</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">2</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == (roomWidth - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">3</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">3</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (MapManager.map[position.x, position.y].type != <span class="hljs-string">"Wall"</span>) {<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Floor"</span>;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!isFirst) {<font></font>
            MapManager.map[lastWallPosition.x, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y - <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y + <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    MapManager.map[lastWallPosition.x - <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    MapManager.map[lastWallPosition.x + <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        room.width = roomWidth;<font></font>
        room.height = roomHeight;<font></font>
        room.type = type;<font></font>
        allFeatures.Add(room);<font></font>
        countFeatures++;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckIfHasSpace</span>(<span class="hljs-params">Vector2Int start, Vector2Int end</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = start.y; y &lt;= end.y; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = start.x; x &lt;= end.x; x++) {
                <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= mapWidth || y &gt;= mapHeight) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (MapManager.map != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">Wall <span class="hljs-title">ChoseWall</span>(<span class="hljs-params">Feature feature</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">int</span> id = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) / <span class="hljs-number">25</span>;
            <span class="hljs-keyword">if</span> (!feature.walls[id].hasFeature) {
                <span class="hljs-keyword">return</span> feature.walls[id];<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawMap</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> isASCII</span>)</span> {
        <span class="hljs-keyword">if</span> (isASCII) {<font></font>
            Text screen = GameObject.Find(<span class="hljs-string">"ASCIITest"</span>).GetComponent&lt;Text&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">string</span> asciiMap = <span class="hljs-string">""</span>;<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = (mapHeight - <span class="hljs-number">1</span>); y &gt;= <span class="hljs-number">0</span>; y--) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; mapWidth; x++) {
                    <span class="hljs-keyword">if</span> (MapManager.map[x, y] != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">switch</span> (MapManager.map[x, y].type) {
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Wall"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"#"</span>;
                                <span class="hljs-keyword">break</span>;
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Floor"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"."</span>;
                                <span class="hljs-keyword">break</span>;<font></font>
                        }<font></font>
                    }<font></font>
                    <span class="hljs-keyword">else</span> {<font></font>
                        asciiMap += <span class="hljs-string">" "</span>;<font></font>
                    }<font></font>
<font></font>
                    <span class="hljs-keyword">if</span> (x == (mapWidth - <span class="hljs-number">1</span>)) {<font></font>
                        asciiMap += <span class="hljs-string">"\n"</span>;<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
<font></font>
            screen.text = asciiMap;<font></font>
        }<font></font>
    }<font></font>
}</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt495554/index.html">Programa para pesquisar o VKontakte com a mesma opini√£o [C√≥digo aberto]</a></li>
<li><a href="../pt495556/index.html">Fortinet - uma sele√ß√£o de materiais √∫teis</a></li>
<li><a href="../pt495560/index.html">Tend√™ncias da Internet das Coisas: IA responde a chamadas, nuvens e 5G domestica big data, habita√ß√£o e servi√ßos p√∫blicos - l√≠der em inova√ß√£o</a></li>
<li><a href="../pt495576/index.html">Plataforma automotriz no esp8266 MK com micropython</a></li>
<li><a href="../pt495580/index.html">JVM de pepino - n√£o apenas BDD</a></li>
<li><a href="../pt495592/index.html">Como usar dicion√°rios (e n√£o apenas)</a></li>
<li><a href="../pt495594/index.html">Comece a ganhar dinheiro com software: criando mini-neg√≥cios digitais</a></li>
<li><a href="../pt495596/index.html">Trabalho remoto no escrit√≥rio. RDP, Port Knocking, Mikrotik: simples e seguro</a></li>
<li><a href="../pt495602/index.html">Come√ßando com os dados principais! Dif√≠cil em palavras simples [Parte 2]</a></li>
<li><a href="../pt495604/index.html">Localiza√ß√£o tempor√°ria no Symfony 4 + Twig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>