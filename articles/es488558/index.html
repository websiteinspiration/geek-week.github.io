<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèª üí≠ üö° Garantizar una alta disponibilidad de aplicaciones con Kafka Streams ü•¢ üëâüèæ ‚è™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kafka Streams es una biblioteca de Java para analizar y procesar datos almacenados en Apache Kafka. Al igual que con cualquier otra plataforma de proc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Garantizar una alta disponibilidad de aplicaciones con Kafka Streams</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488558/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka Streams es una biblioteca de Java para analizar y procesar datos almacenados en Apache Kafka. </font><font style="vertical-align: inherit;">Al igual que con cualquier otra plataforma de procesamiento de transmisi√≥n, es capaz de realizar el procesamiento de datos con y / o sin preservaci√≥n del estado en tiempo real. </font><font style="vertical-align: inherit;">En esta publicaci√≥n intentar√© describir por qu√© lograr una alta disponibilidad (99.99%) es problem√°tico en Kafka Streams y qu√© podemos hacer para lograrlo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que necesitamos saber</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de describir el problema y las posibles soluciones, veamos los conceptos b√°sicos de Kafka Streams. </font><font style="vertical-align: inherit;">Si ha trabajado con las API de Kafka para consumidores / productores, entonces la mayor√≠a de estos paradigmas le son familiares. </font><font style="vertical-align: inherit;">En las siguientes secciones, intentar√© describir en pocas palabras el almacenamiento de datos en particiones, el reequilibrio de los grupos de consumidores y c√≥mo los conceptos b√°sicos de los clientes de Kafka se ajustan a la biblioteca de Kafka Streams.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka: Particionando datos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el mundo de Kafka, las aplicaciones de productores env√≠an datos como pares clave-valor a un tema espec√≠fico. </font><font style="vertical-align: inherit;">El tema en s√≠ est√° dividido en una o m√°s particiones en los corredores de Kafka. </font><font style="vertical-align: inherit;">Kafka utiliza una clave de mensaje para indicar en qu√© partici√≥n se deben escribir los datos. </font><font style="vertical-align: inherit;">En consecuencia, los mensajes con la misma clave siempre terminan en la misma partici√≥n.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las aplicaciones de consumo se organizan en grupos de consumidores, y cada grupo puede tener una o m√°s instancias de consumidores. </font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada instancia de un consumidor en el grupo de consumidores es responsable de procesar los datos de un conjunto √∫nico de particiones del tema de entrada.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las instancias del consumidor son esencialmente un medio para ampliar el procesamiento en su grupo de consumidores.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka: reequilibrio del grupo de consumidores</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como dijimos anteriormente, cada instancia del grupo de consumidores recibe un conjunto de particiones √∫nicas de las que consume datos. </font><font style="vertical-align: inherit;">Cada vez que un nuevo consumidor se une a un grupo, debe realizarse un reequilibrio para obtener una partici√≥n. </font><font style="vertical-align: inherit;">Lo mismo sucede cuando el consumidor muere, el resto del consumidor debe tomar sus particiones para asegurarse de que se procesen todas las particiones.</font></font><br>
<cut></cut><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka Streams: corrientes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al comienzo de esta publicaci√≥n, nos familiarizamos con el hecho de que la biblioteca Kafka Streams est√° construida sobre la base de API de productores y consumidores y el procesamiento de datos est√° organizado de la misma manera que la soluci√≥n est√°ndar en Kafka. En la configuraci√≥n de Kafka Streams, el campo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">application.id</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es </font><font style="vertical-align: inherit;">equivalente a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">group.id</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la API del consumidor. Kafka Streams crea previamente un cierto n√∫mero de subprocesos y cada uno de ellos realiza el procesamiento de datos de una o m√°s particiones de temas de entrada. Hablando en la terminolog√≠a de la API del consumidor, las transmisiones coinciden esencialmente con instancias del consumidor del mismo grupo. Los subprocesos son la forma principal de escalar el procesamiento de datos en Kafka Streams, esto se puede hacer verticalmente aumentando el n√∫mero de subprocesos para cada aplicaci√≥n de Kafka Streams en una m√°quina, u horizontalmente agregando una m√°quina adicional con el mismo application.id. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bb7/bd3/8ed/bb7bd38edd33f26a146c12a1dea385b5.jpg" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fuente: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kafka.apache.org/21/documentation/streams/architecture</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay muchos m√°s elementos en Kafka Streams, como tareas, topolog√≠a de procesamiento, modelo de subprocesos, etc., que no discutiremos en esta publicaci√≥n. </font><font style="vertical-align: inherit;">M√°s informaci√≥n se puede encontrar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka Streams: almacenamiento estatal</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el procesamiento continuo, hay operaciones con y sin preservaci√≥n del estado. </font><font style="vertical-align: inherit;">El estado es lo que permite que la aplicaci√≥n recuerde la informaci√≥n necesaria que va m√°s all√° del alcance del registro que se est√° procesando actualmente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las operaciones estatales, como conteo, cualquier tipo de agregaci√≥n, uniones, etc., son mucho m√°s complicadas. Esto se debe al hecho de que al tener solo un registro, no puede determinar el √∫ltimo estado (por ejemplo, contar) para una clave determinada, por lo que debe almacenar el estado de su transmisi√≥n en su aplicaci√≥n. Como discutimos anteriormente, cada subproceso procesa un conjunto de particiones √∫nicas; por lo tanto, un subproceso procesa solo un subconjunto del conjunto de datos completo. Esto significa que cada subproceso de aplicaci√≥n de Kafka Streams con el mismo application.id mantiene su propio estado aislado. No entraremos en detalles sobre c√≥mo se forma el estado en Kafka Streams, pero es importante comprender que los estados se restauran utilizando el tema de registro de cambios (tema de registro de cambios) y se guardan no solo en el disco local, sino tambi√©n en Kafka Broker.Guardar el registro de cambios de estado en Kafka Broker como un tema separado est√° hecho no solo para la tolerancia a fallas, sino tambi√©n para que pueda implementar f√°cilmente nuevas instancias de Kafka Streams con el mismo application.id. Dado que el estado se almacena como un tema de registro de cambios en el lado del intermediario, una nueva instancia puede cargar su propio estado desde este tema.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede encontrar m√°s informaci√≥n sobre el almacenamiento estatal </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© la alta disponibilidad es problem√°tica con Kafka Streams?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revisamos los conceptos y principios b√°sicos del procesamiento de datos con Kafka Streams. </font><font style="vertical-align: inherit;">Ahora intentemos combinar todas las partes y analizar por qu√© lograr una alta disponibilidad puede ser problem√°tico. </font><font style="vertical-align: inherit;">De las secciones anteriores, debemos recordar:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los datos en el tema de Kafka se dividen en particiones, que se distribuyen entre las secuencias de Kafka Streams.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las aplicaciones de Kafka Streams con el mismo application.id son, de hecho, un grupo de consumidores, y cada uno de sus hilos es una instancia aislada separada del consumidor.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para las operaciones de estado, el hilo mantiene su propio estado, que est√° "reservado" por el tema de Kafka en forma de un registro de cambios.</font></font></li>
<li>       , Kafka      ,    .</li>
</ol><br>
<h2>TransferWise SPaaS (Stream Processing as a Service)</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de resaltar la esencia de esta publicaci√≥n, d√©jenme decirles primero lo que creamos en TransferWise y por qu√© la alta disponibilidad es muy importante para nosotros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En TransferWise, tenemos varios nodos para el procesamiento de transmisi√≥n, y cada nodo contiene varias instancias de Kafka Streams para cada equipo de producto. Las instancias de Kafka Streams que est√°n dise√±adas para un equipo de desarrollo espec√≠fico tienen un application.id especial y generalmente tienen m√°s de 5 subprocesos. En general, los equipos suelen tener 10-20 hilos (equivalentes al n√∫mero de instancias de consumidores) en todo el cl√∫ster. Las aplicaciones que se implementan en los nodos escuchan temas de entrada y realizan varios tipos de operaciones con y sin estado en los datos de entrada y proporcionan actualizaciones de datos en tiempo real para los microservicios posteriores posteriores.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los equipos de productos necesitan actualizar los datos agregados en tiempo real. </font><font style="vertical-align: inherit;">Esto es necesario para proporcionar a nuestros clientes la capacidad de transferir dinero instant√°neamente. </font><font style="vertical-align: inherit;">Nuestro SLA habitual:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En cualquier d√≠a, el 99,99% de los datos agregados deber√≠an estar disponibles en menos de 10 segundos.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para darle una idea, durante las pruebas de estr√©s, Kafka Streams pudo procesar y agregar 20.085 mensajes de entrada por segundo. </font><font style="vertical-align: inherit;">Por lo tanto, 10 segundos de SLA bajo carga normal sonaban bastante alcanzables. </font><font style="vertical-align: inherit;">Desafortunadamente, nuestro SLA no se alcanz√≥ durante la actualizaci√≥n continua de los nodos en los que se implementan las aplicaciones, y a continuaci√≥n describir√© por qu√© sucedi√≥ esto.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualizaci√≥n de nodo deslizante</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En TransferWise, creemos firmemente en la entrega continua de nuestro software y generalmente lanzamos nuevas versiones de nuestros servicios un par de veces al d√≠a. </font><font style="vertical-align: inherit;">Veamos un ejemplo de una simple actualizaci√≥n continua del servicio y veamos qu√© sucede durante el proceso de lanzamiento. </font><font style="vertical-align: inherit;">Nuevamente, debemos recordar que:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los datos en el tema de Kafka se dividen en particiones, que se distribuyen entre las secuencias de Kafka Streams.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las aplicaciones de Kafka Streams con el mismo application.id son, de hecho, un grupo de consumidores, y cada uno de sus hilos es una instancia aislada separada del consumidor.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para las operaciones de estado, el hilo mantiene su propio estado, que est√° "reservado" por el tema de Kafka en forma de un registro de cambios.</font></font></li>
<li>       , Kafka      ,    .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un proceso de liberaci√≥n en un solo nodo generalmente toma de ocho a nueve segundos. </font><font style="vertical-align: inherit;">Durante el lanzamiento, las instancias de Kafka Streams en el nodo "se reinician suavemente". </font><font style="vertical-align: inherit;">Por lo tanto, para un solo nodo, el tiempo requerido para reiniciar correctamente el servicio es de aproximadamente ocho a nueve segundos. </font><font style="vertical-align: inherit;">Obviamente, cerrar una instancia de Kafka Streams en un nodo provoca un reequilibrio del grupo de consumidores. </font><font style="vertical-align: inherit;">Dado que los datos est√°n particionados, todas las particiones que pertenec√≠an a la instancia de arranque deben distribuirse entre las aplicaciones activas de Kafka Streams con el mismo application.id. </font><font style="vertical-align: inherit;">Esto tambi√©n se aplica a los datos agregados que se han guardado en el disco. </font><font style="vertical-align: inherit;">Hasta que este proceso se complete, los datos no ser√°n procesados.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©plicas en espera</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para reducir el tiempo de reequilibrio para las aplicaciones de Kafka Streams, existe un concepto de r√©plicas de respaldo, que se definen en la configuraci√≥n como num.standby.replicas. Las r√©plicas de respaldo son copias del almac√©n estatal local. Este mecanismo permite replicar la tienda de estado de una instancia de Kafka Streams a otra. Cuando el hilo de Kafka Streams muere por cualquier motivo, la duraci√≥n del proceso de recuperaci√≥n de estado se puede minimizar. Desafortunadamente, por las razones que explicar√© a continuaci√≥n, incluso las r√©plicas de respaldo no ayudar√°n con una actualizaci√≥n continua del servicio.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que tenemos dos instancias de Kafka Streams en dos m√°quinas diferentes: nodo-a y nodo-b. </font><font style="vertical-align: inherit;">Para cada una de las instancias de Kafka Streams, num.standby.replicas = 1 se indica en estos 2 nodos. Con esta configuraci√≥n, cada instancia de Kafka Streams mantiene su copia del almacenamiento en otro nodo. </font><font style="vertical-align: inherit;">Durante una actualizaci√≥n continua, tenemos la siguiente situaci√≥n:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La nueva versi√≥n del servicio se ha implementado en el nodo-a.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La instancia de Kafka Streams en el nodo-a est√° deshabilitada.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El reequilibrio ha comenzado.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El repositorio del nodo-a ya se ha replicado en el nodo-b, ya que especificamos la configuraci√≥n num.standby.replicas = 1.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El nodo-b ya tiene una copia oculta del nodo-a, por lo que el proceso de reequilibrio ocurre casi al instante.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El nodo-a se inicia de nuevo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> node-a se une a un grupo de consumidores.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El corredor de Kafka ve una nueva instancia de Kafka Streams y comienza a reequilibrar.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como podemos ver, num.standby.replicas solo ayuda en escenarios de un apagado completo de un nodo. </font><font style="vertical-align: inherit;">Esto significa que si el nodo-a se bloquea, entonces el nodo-b podr√≠a continuar funcionando correctamente casi instant√°neamente. </font><font style="vertical-align: inherit;">Pero en una situaci√≥n de actualizaci√≥n continua, despu√©s de desconectarse, el nodo-a se unir√° nuevamente al grupo, y este √∫ltimo paso provocar√° un reequilibrio. </font><font style="vertical-align: inherit;">Cuando el nodo-a se une al grupo de consumidores despu√©s de un reinicio, se considerar√° como una nueva instancia del consumidor. </font><font style="vertical-align: inherit;">Nuevamente, debemos recordar que el procesamiento de datos en tiempo real se detiene hasta que una nueva instancia restaura su estado del tema del registro de cambios.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que el reequilibrio de particiones cuando una nueva instancia se une a un grupo no se aplica a la API de Kafka Streams, ya que as√≠ es exactamente como funciona el protocolo del grupo de consumidores Apache Kafka.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logro: Alta disponibilidad con Kafka Streams</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pesar del hecho de que las bibliotecas de cliente de Kafka no proporcionan una funcionalidad integrada para el problema mencionado anteriormente, existen algunos trucos que se pueden usar para lograr una alta disponibilidad de cl√∫ster durante una actualizaci√≥n continua. </font><font style="vertical-align: inherit;">La idea detr√°s de las r√©plicas de respaldo sigue siendo v√°lida, y tener m√°quinas de respaldo cuando sea el momento adecuado es una buena soluci√≥n que utilizamos para garantizar una alta disponibilidad en caso de falla de la instancia.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema con nuestra configuraci√≥n inicial fue que ten√≠amos un grupo de consumidores para todos los equipos en todos los nodos. </font><font style="vertical-align: inherit;">Ahora, en lugar de un grupo de consumidores, tenemos dos, y el segundo act√∫a como un cl√∫ster "activo". </font><font style="vertical-align: inherit;">En prod, los nodos tienen una variable especial CLUSTER_ID, que se agrega al application.id de las instancias de Kafka Streams. </font><font style="vertical-align: inherit;">Aqu√≠ hay una muestra de la configuraci√≥n Spring boot application.yml:</font></font><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">application.yml</font></font></b><div class="spoiler_text"><code>spring.profiles: production<br>
streaming-pipelines:<br>
 team-a-stream-app-id: "${CLUSTER_ID}-team-a-stream-app"<br>
 team-b-stream-app-id: "${CLUSTER_ID}-team-b-stream-app"</code><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En un momento dado, solo uno de los cl√∫steres est√° en modo activo, respectivamente, el cl√∫ster de respaldo no env√≠a mensajes en tiempo real a microservicios posteriores. Durante el lanzamiento del lanzamiento, el cl√∫ster de respaldo se activa, lo que permite una actualizaci√≥n continua en el primer cl√∫ster. Dado que este es un grupo de consumidores completamente diferente, nuestros clientes ni siquiera notan ninguna violaci√≥n en el procesamiento, y los servicios posteriores contin√∫an recibiendo mensajes del grupo recientemente activo. Una de las desventajas obvias de usar un grupo de consumidores de respaldo es la sobrecarga adicional y el consumo de recursos, pero, sin embargo, esta arquitectura proporciona garant√≠as adicionales, control y tolerancia a fallas de nuestro sistema de procesamiento de transmisi√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s de agregar un cl√∫ster adicional, tambi√©n hay trucos que pueden mitigar el problema con reequilibrios frecuentes.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aumentar group.initial.rebalance.delay.ms</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A partir de Kafka 0.11.0.0, se ha agregado la configuraci√≥n group.initial.rebalance.delay.ms. </font><font style="vertical-align: inherit;">Seg√∫n la documentaci√≥n, esta configuraci√≥n es responsable de:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cantidad de tiempo en milisegundos que GroupCoordinator retrasar√° el reequilibrio inicial del consumidor del grupo.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, si establecemos 60,000 milisegundos en esta configuraci√≥n, entonces con una actualizaci√≥n continua podemos tener una ventana de minutos para el lanzamiento de la versi√≥n. </font><font style="vertical-align: inherit;">Si la instancia de Kafka Streams se reinicia correctamente en esta ventana de tiempo, no se llamar√° a reequilibrar. </font><font style="vertical-align: inherit;">Tenga en cuenta que los datos de los que fue responsable la instancia reiniciada de Kafka Streams no estar√°n disponibles hasta que el nodo vuelva al modo en l√≠nea. </font><font style="vertical-align: inherit;">Por ejemplo, si el reinicio de una instancia demora aproximadamente ocho segundos, tendr√° ocho segundos de tiempo de inactividad para los datos de los que es responsable esta instancia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cabe se√±alar que la principal desventaja de este concepto es que, en caso de falla de un nodo, recibir√° un retraso adicional de un minuto durante la restauraci√≥n, teniendo en cuenta la configuraci√≥n actual.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reducci√≥n del tama√±o del segmento en temas de registro de cambios</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La gran demora en reequilibrar Kafka Stream se debe a la restauraci√≥n de las tiendas estatales a partir de temas de registro de cambios. Los temas de registro de cambios son temas comprimidos, lo que le permite almacenar el √∫ltimo registro para una clave particular en el tema. Describir√© brevemente este concepto a continuaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los temas en Kafka Broker est√°n organizados en segmentos. Cuando un segmento alcanza el tama√±o de umbral configurado, se crea un nuevo segmento y el anterior se comprime. De manera predeterminada, este umbral se establece en 1 GB. Como sabr√°n, la estructura de datos principal que subyace a los temas de Kafka y sus particiones es la estructura de registro con una escritura directa, es decir, cuando se env√≠an mensajes al tema, siempre se agregan al √∫ltimo segmento "activo", y la compresi√≥n no es pasando</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, la mayor√≠a de los estados de almacenamiento almacenados en el registro de cambios siempre est√°n en el archivo de "segmento activo" y nunca se comprimen, lo que genera millones de mensajes de registro de cambios sin comprimir. </font><font style="vertical-align: inherit;">Para Kafka Streams, esto significa que durante el reequilibrio, cuando la instancia de Kafka Streams restaura su estado del tema del registro de cambios, necesita leer muchas entradas redundantes del tema del registro de cambios. </font><font style="vertical-align: inherit;">Dado que las tiendas estatales solo se preocupan por el √∫ltimo estado y no por el historial, este tiempo de procesamiento se desperdicia. </font><font style="vertical-align: inherit;">La reducci√≥n del tama√±o del segmento causar√° una compresi√≥n de datos m√°s agresiva, por lo que las nuevas instancias de aplicaciones Kafka Streams pueden recuperarse mucho m√°s r√°pido.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque Kafka Streams no proporciona una capacidad incorporada para proporcionar alta disponibilidad durante una actualizaci√≥n continua del servicio, esto a√∫n se puede hacer a nivel de infraestructura. </font><font style="vertical-align: inherit;">Debemos recordar que Kafka Streams no es un "marco de cl√∫ster" a diferencia de Apache Flink o Apache Spark. </font><font style="vertical-align: inherit;">Es una biblioteca ligera de Java que permite a los desarrolladores crear aplicaciones escalables para la transmisi√≥n de datos. </font><font style="vertical-align: inherit;">A pesar de esto, proporciona los bloques de construcci√≥n necesarios para lograr objetivos de transmisi√≥n tan ambiciosos como la disponibilidad de "99.99%".</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es488544/index.html">Eliminar la cobertura de c√≥digo de una aplicaci√≥n Node.JS que ya se est√° ejecutando</a></li>
<li><a href="../es488546/index.html">Hack The Box. Tutorial de JSON. Vulnerabilidad en Json.Net y LPE a trav√©s de SeImpersonatePrivilege</a></li>
<li><a href="../es488548/index.html">Experimento: c√≥mo aprender a crear textos populares en ingl√©s (y por qu√© los habristas de habla inglesa leen tan poco)</a></li>
<li><a href="../es488550/index.html">¬øQui√©n quiere hacer cooperativas con gigantes de TI?</a></li>
<li><a href="../es488552/index.html">Desarrolladores de Apple FAS y Control Parental</a></li>
<li><a href="../es488560/index.html">Alojamiento gratuito de bots de Telegram en Google Cloud Platform</a></li>
<li><a href="../es488564/index.html">Su primera red neuronal en una unidad de procesamiento de gr√°ficos (GPU). Gu√≠a para principiantes</a></li>
<li><a href="../es488566/index.html">C√≥mo un ingeniero de control de calidad ahorr√≥ un d√≠a entero al vincular AutoTests en Visual Studio y Test IT</a></li>
<li><a href="../es488568/index.html">¬øLas redes neuronales sue√±an con el dinero el√©ctrico?</a></li>
<li><a href="../es488570/index.html">C√≥mo el Servicio Secreto de EE. UU. Confundi√≥ el juego de rol cyberpunk con un libro de texto para hackers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>