<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôèüèø ü§∂üèæ ‚úäüèΩ Pohon ekspresi dalam C # menggunakan contoh menemukan turunan (Pengunjung Pohon Ekspresi vs Pencocokan Pola) üò§ üßëüèø ‚ìÇÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang. Pohon ekspresi, terutama bila dikombinasikan dengan pola Pengunjung, selalu menjadi topik yang agak membingungkan. Oleh karena itu, sem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pohon ekspresi dalam C # menggunakan contoh menemukan turunan (Pengunjung Pohon Ekspresi vs Pencocokan Pola)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486972/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selamat siang. </font><font style="vertical-align: inherit;">Pohon ekspresi, terutama bila dikombinasikan dengan pola Pengunjung, selalu menjadi topik yang agak membingungkan. </font><font style="vertical-align: inherit;">Oleh karena itu, semakin beragam informasi tentang topik ini, semakin banyak contoh, semakin mudah bagi mereka yang tertarik untuk menemukan sesuatu yang jelas dan bermanfaat bagi mereka.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xt/6c/bf/xt6cbf1-gfkv4-64zs250n_-7pa.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini dibangun seperti biasa - dimulai dengan kerangka kerja konseptual dan definisi dan diakhiri dengan contoh dan cara penggunaan. </font><font style="vertical-align: inherit;">Daftar isi di bawah ini. </font></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dasar-dasar Pohon Ekspresi </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaksis Pohon Ekspresi </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jenis </font></font></a></b><font style="vertical-align: inherit;"><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Ekspresi </font></a></b></font><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pola Pencocokan </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengunjung Naif Pengunjung </font></font></a></b><br>
 <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klasik</font></font></a></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nah, tujuannya bukan untuk memaksakan solusi tertentu atau mengatakan bahwa satu lebih baik daripada yang lain. </font><font style="vertical-align: inherit;">Saya mengusulkan untuk menarik kesimpulan sendiri, dengan mempertimbangkan semua nuansa dalam kasus Anda. </font><font style="vertical-align: inherit;">Saya akan mengungkapkan pendapat saya pada contoh saya.</font></font><br>
<br>
<a name="basic"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pohon Ekspresi</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dasar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, Anda perlu berurusan dengan pohon ekspresi. Mereka berarti jenis Ekspresi atau ahli warisnya (mereka akan dibahas nanti). Dalam skenario biasa, ekspresi / algoritme disajikan dalam bentuk kode / instruksi yang dapat dieksekusi di mana pengguna mungkin tidak memiliki banyak hal untuk dilakukan (terutama eksekusi). Tipe Ekspresi memungkinkan Anda untuk mewakili ekspresi / algoritma (biasanya lambdas, tetapi tidak perlu) sebagai data yang diorganisasikan dalam struktur pohon yang dapat diakses oleh pengguna. Cara seperti pohon mengatur informasi tentang algoritma dan nama kelas memberi kita "pohon ekspresi". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk kejelasan, kami akan menganalisis contoh sederhana. Misalkan kita memiliki lambda </font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(x) =&gt; Console.WriteLine (x + 5)</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ini dapat direpresentasikan sebagai pohon berikut</font></font><br>
<br>
<div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/yv/wy/sq/yvwysqugbtttw-gvz07tipuq-oy.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akar pohon adalah bagian atas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodCall</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , parameter dari metode ini juga ekspresi, oleh karena itu dapat memiliki jumlah anak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus kami, hanya ada satu keturunan - puncak " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArithmeticOperation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". Ini berisi informasi tentang operasi apa itu dan operan kiri dan kanan juga ekspresi. Vertex seperti itu akan selalu memiliki 2 keturunan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operan diwakili oleh konstanta ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dan parameter ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ekspresi semacam itu tidak memiliki keturunan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah contoh yang sangat sederhana, tetapi sepenuhnya mencerminkan esensi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fitur utama pohon ekspresi adalah mereka dapat diuraikan dan membaca semua informasi yang diperlukan tentang apa yang harus dilakukan algoritma. Dari beberapa sudut pandang, ini adalah kebalikan dari atribut. Atribut adalah sarana deskripsi perilaku deklaratif (sangat kondisional, tetapi tujuan akhir kira-kira sama). Sedangkan pohon ekspresi menggunakan fungsi / algoritma untuk menggambarkan data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mereka digunakan, misalnya, dalam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penyedia</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kerangka kerja entitas. Aplikasi ini jelas - untuk mengurai pohon ekspresi, untuk memahami apa yang harus dieksekusi di sana dan membuat </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari deskripsi ini </font><font style="vertical-align: inherit;">. Contoh yang kurang terkenal adalah perpustakaan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk diolok-olok </font><font style="vertical-align: inherit;">. Pohon ekspresi juga digunakan dalam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DLR.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(runtime bahasa dinamis). </font><font style="vertical-align: inherit;">Pengembang kompiler menggunakannya untuk memastikan kompatibilitas antara sifat dinamis dan dotnet, alih-alih menghasilkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSIL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu juga disebutkan bahwa pohon ekspresi tidak dapat diubah.</font></font><br>
<a name="syn"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaksis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal berikutnya yang layak dibahas adalah sintaksisnya. </font><font style="vertical-align: inherit;">Ada 2 cara utama:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membuat pohon ekspresi melalui metode statis dari kelas Ekspresi</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan ekspresi lambda yang dikompilasi dalam Ekspresi</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode Statis dari Kelas Ekspresi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Membuat pohon ekspresi melalui metode statis dari kelas Ekspresi lebih jarang digunakan (terutama dari sudut pandang pengguna). Ini rumit, tetapi cukup sederhana, kami memiliki </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
banyak batu bata dasar yang dapat Anda gunakan, dari mana Anda dapat membangun </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
hal-hal </font><font style="vertical-align: inherit;">yang cukup rumit </font><font style="vertical-align: inherit;">. Penciptaan terjadi melalui metode statis sejak itu konstruktor ekspresi memiliki pengubah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">internal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dan ini tidak berarti bahwa Anda perlu mengungkap refleksi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai contoh, saya akan membuat ekspresi dari contoh di atas: </font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(x) =&gt; Console.WriteLine (x + 5)</font></font></i></b><br>
<br>
<pre><code class="cs hljs">ParameterExpression parameter = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
ConstantExpression constant = Expression.Constant(<span class="hljs-number">5</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
BinaryExpression <span class="hljs-keyword">add</span> = Expression.Add(parameter, constant);<font></font>
MethodInfo writeLine = <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.WriteLine), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });<font></font>
MethodCallExpression methodCall = Expression.Call(<span class="hljs-literal">null</span>, writeLine, <span class="hljs-keyword">add</span>);<font></font>
Expression&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt; expressionlambda = Expression.Lambda&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt;(methodCall, parameter);<font></font>
Action&lt;<span class="hljs-keyword">double</span>&gt; delegateLambda = expressionlambda.Compile();<font></font>
delegateLambda(<span class="hljs-number">123321</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini mungkin bukan cara yang mudah, tetapi sepenuhnya mencerminkan struktur internal pohon ekspresi. </font><font style="vertical-align: inherit;">Plus, metode ini menyediakan lebih banyak fitur dan fitur yang dapat digunakan dalam pohon ekspresi: dari loop, kondisi, try-catch, goto, tugas, diakhiri dengan blok kesalahan, informasi debugging untuk breakpoints, dinamis, dll.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ekspresi lambda</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menggunakan lambdas sebagai ungkapan lebih sering dilakukan. </font><font style="vertical-align: inherit;">Ini bekerja sangat sederhana - kompiler pintar pada tahap kompilasi melihat apa yang digunakan lambda. </font><font style="vertical-align: inherit;">Dan mengkompilasinya menjadi delegasi atau ekspresi. </font><font style="vertical-align: inherit;">Pada contoh yang sudah dikuasai, tampilannya sebagai berikut</font></font><br>
<br>
<pre><code class="cs hljs">Expression&lt;Action&lt;<span class="hljs-keyword">double</span>&gt;&gt; write =  =&gt; Console.WriteLine( + <span class="hljs-number">5</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu mengklarifikasi hal semacam itu - sebuah ekspresi adalah deskripsi yang lengkap. </font><font style="vertical-align: inherit;">Dan itu sudah cukup untuk </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mendapatkan hasilnya. </font><font style="vertical-align: inherit;">Pohon ekspresi seperti LambdaExpression atau turunannya dapat </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dikonversi menjadi IL yang dapat dieksekusi. </font><font style="vertical-align: inherit;">Jenis yang tersisa tidak dapat secara langsung dikonversi ke kode yang dapat dieksekusi (tapi ini tidak masuk akal). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By the way, jika seseorang sangat penting dari kompilasi cepat dari sebuah ekspresi, Anda bisa lihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proyek pihak ketiga. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kebalikannya tidak benar dalam kasus umum. </font><font style="vertical-align: inherit;">Seorang delegasi tidak bisa begitu saja mengambilnya dan memperkenalkan dirinya sebagai sebuah ekspresi (tetapi ini masih mungkin). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak semua lambda dapat dikonversi menjadi pohon ekspresi. </font><font style="vertical-align: inherit;">Ini termasuk:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berisi operator penugasan</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menyumbang dinamis</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak sinkron</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan tubuh (kawat gigi)</font></font></li>
</ul><br>
<pre><code class="cs hljs"><span class="hljs-keyword">double</span> variable;
<span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">dynamic</span>;<font></font>
Expression&lt;Action&gt; assignment = () =&gt; variable = <span class="hljs-number">5</span>; <span class="hljs-comment">//Compiler error: An expression tree may not contain an assignment operator</span>
Expression&lt;Func&lt;<span class="hljs-keyword">double</span>&gt;&gt; dynamically = () =&gt; <span class="hljs-keyword">dynamic</span>; <span class="hljs-comment">//Compiler error: An expression tree may not contain a dynamic operation</span>
Expression&lt;Func&lt;Task&gt;&gt; asynchon = <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">await</span> Task.CompletedTask; <span class="hljs-comment">//Compiler error: Async lambda cannot be converted to expresiion trees</span>
Expression&lt;Action&gt; body = () =&gt; { }; <span class="hljs-comment">//Compiler error: A lambda expression with a statement body cannot be converted to an expression tree</span>
</code></pre> <br>
<a name="types"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jenis-jenis Ekspresi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya sarankan untuk melihat sekilas jenis yang tersedia untuk mewakili peluang apa yang kita miliki. </font><font style="vertical-align: inherit;">Semuanya ada dalam namespace </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Linq.Expressions.Saya</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
sarankan Anda untuk berkenalan dengan beberapa fitur yang sangat menarik dan tidak biasa. </font><font style="vertical-align: inherit;">Jenis ekspresi yang lebih sederhana yang saya kumpulkan di tablet dengan deskripsi singkat.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinamis</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menggunakan DynamicExpression dimungkinkan untuk menggunakan dinamis dan semua fitur-fiturnya di pohon ekspresi. </font><font style="vertical-align: inherit;">Ada API yang agak membingungkan, saya duduk di contoh ini lebih lama dari pada yang lainnya digabungkan. </font><font style="vertical-align: inherit;">Semua kebingungan disediakan oleh banyak bendera. </font><font style="vertical-align: inherit;">Dan beberapa di antaranya mirip dengan yang Anda cari, tetapi belum tentu. </font><font style="vertical-align: inherit;">Dan ketika bekerja dengan dinamis dalam pohon ekspresi, sulit untuk mendapatkan kesalahan bicara. </font><font style="vertical-align: inherit;">Contoh:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> parameter1 = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), <span class="hljs-string">"name1"</span>);
<span class="hljs-keyword">var</span> parameter2 = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), <span class="hljs-string">"name2"</span>); 
<span class="hljs-keyword">var</span> dynamicParam1 = CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal">null</span>);
<span class="hljs-keyword">var</span> dynamicParam2 = CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal">null</span>);<font></font>
CallSiteBinder csb = Microsoft.CSharp.RuntimeBinder.Binder.BinaryOperation(CSharpBinderFlags.None, ExpressionType.Add, <span class="hljs-keyword">typeof</span>(Program), <span class="hljs-keyword">new</span>[] { dynamicParam1, dynamicParam2 });
<span class="hljs-keyword">var</span> dyno = Expression.Dynamic(csb, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">object</span>), parameter1, parameter2);<font></font>
Expression&lt;Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt;&gt; expr = Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt;&gt;(dyno, <span class="hljs-keyword">new</span>[] { parameter1, parameter2 });<font></font>
Func&lt;<span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>, <span class="hljs-keyword">dynamic</span>&gt; action = expr.Compile();
<span class="hljs-keyword">var</span> res = action(<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>);<font></font>
Console.WriteLine(res); <span class="hljs-comment">//12</span>
res = action(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<font></font>
Console.WriteLine(res); <span class="hljs-comment">//3</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya secara eksplisit menunjukkan dari mana Binder berasal untuk menghindari kebingungan dengan binder dari System.Reflection. </font><font style="vertical-align: inherit;">Dari hal-hal menarik, kita dapat melakukan parameter ref dan out, parameter bernama, operasi unary, dan pada prinsipnya, semua yang dapat dilakukan melalui dinamis, tetapi ini akan memerlukan beberapa keterampilan.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blok tangkapan pengecualian</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal kedua yang akan saya perhatikan adalah fungsi try / catch / akhirnya / fault, atau lebih tepatnya, fakta </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bahwa kita memiliki akses ke blok kesalahan. </font><font style="vertical-align: inherit;">Ini tidak tersedia dalam C #, tetapi dalam MSIL. Ini adalah semacam </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
analog akhirnya yang akan dieksekusi jika ada pengecualian. </font><font style="vertical-align: inherit;">Pada contoh di bawah ini, pengecualian akan dilemparkan, setelah itu "Hai" akan ditampilkan dan program akan menunggu input. </font><font style="vertical-align: inherit;">Hanya setelah itu akan jatuh sepenuhnya. </font><font style="vertical-align: inherit;">Saya tidak merekomendasikan praktik ini untuk digunakan.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> throwSmth = Expression.Throw(Expression.Constant(<span class="hljs-keyword">new</span> Exception(), <span class="hljs-keyword">typeof</span>(Exception)));
<span class="hljs-keyword">var</span> log = Expression.Call(<span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.WriteLine), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">string</span>) }), Expression.Constant(<span class="hljs-string">"Hi"</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">string</span>)));
<span class="hljs-keyword">var</span> read = Expression.Call(<span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-keyword">nameof</span>(Console.ReadLine)));
<span class="hljs-keyword">var</span> fault = Expression.TryFault(throwSmth, Expression.Block(<span class="hljs-keyword">new</span>[] { log, read }));<font></font>
Expression&lt;Action&gt; expr = Expression.Lambda&lt;Action&gt;(fault);<font></font>
Action compiledExpression = expr.Compile();<font></font>
compiledExpression();<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deskripsi Singkat Jenis Pohon Ekspresi yang Tersedia</font></font></b><div class="spoiler_text"><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meja</font></font></h4><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebuah tipe</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deskripsi Singkat</font></font></th>
</tr>
<tr>
<td colspan="2" align="center"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utama</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ekspresi</font></font></td>
<td> ,      .     ,      </td>
</tr>
<tr>
<td>Expression&lt;TDelegate&gt;</td>
<td>    </td>
</tr>
<tr>
<td colspan="2" align="center"><b> </b></td>
</tr>
<tr>
<td>BinaryExpression</td>
<td>     (+, ‚Äî  )</td>
</tr>
<tr>
<td>UnaryExpression</td>
<td> (+, -),    throw</td>
</tr>
<tr>
<td>ConstantExpression</td>
<td> ‚Äî   </td>
</tr>
<tr>
<td>ParameterExpression</td>
<td> </td>
</tr>
<tr>
<td>MethodCallExpression</td>
<td>  ,  MethodInfo</td>
</tr>
<tr>
<td>IndexExpression</td>
<td></td>
</tr>
<tr>
<td>BlockExpression</td>
<td>,   .      </td>
</tr>
<tr>
<td colspan="2" align="center"><b>  </b></td>
</tr>
<tr>
<td>ConditionalExpression </td>
<td>   ‚Äî if-else</td>
</tr>
<tr>
<td>LabelTarget</td>
<td>   goto</td>
</tr>
<tr>
<td>LabelExpression</td>
<td> ,            .    LabelTarget.    ,    GotoExpression,    ‚Äî   .    void,    .</td>
</tr>
<tr>
<td>GotoExpression</td>
<td>  .    . ( .. ¬´break¬ª)</td>
</tr>
<tr>
<td>LoopExpression</td>
<td> ,    ¬´break¬ª</td>
</tr>
<tr>
<td>SwitchCase</td>
<td>    SwitchExpression</td>
</tr>
<tr>
<td>SwitchExpression</td>
<td>  switch/case</td>
</tr>
<tr>
<td>TryExpression</td>
<td>    try/catch/finally/fault </td>
</tr>
<tr>
<td>CatchBlock</td>
<td>,   ,    </td>
</tr>
<tr>
<td colspan="2" align="center"><b></b></td>
</tr>
<tr>
<td>ElementInit</td>
<td>    IEnumerable.   ListInitExpression</td>
</tr>
<tr>
<td>ListInitExpression</td>
<td>  +   </td>
</tr>
<tr>
<td>DefaultExpression</td>
<td>       </td>
</tr>
<tr>
<td>NewArrayExpression</td>
<td>   +  </td>
</tr>
<tr>
<td>NewExpression</td>
<td> </td>
</tr>
<tr>
<td colspan="2" align="center"><b>  /</b></td>
</tr>
<tr>
<td>MemberAssignment</td>
<td>    </td>
</tr>
<tr>
<td>MemberBinding</td>
<td>  ,    ,  ,        </td>
</tr>
<tr>
<td>MemberExpression</td>
<td>  /</td>
</tr>
<tr>
<td>MemberInitExpression</td>
<td>      </td>
</tr>
<tr>
<td>MemberListBinding</td>
<td> /  </td>
</tr>
<tr>
<td>MemberMemberBinding</td>
<td> / ,    /</td>
</tr>
<tr>
<td colspan="2" align="center"><b></b></td>
</tr>
<tr>
<td>LambdaExpression</td>
<td></td>
</tr>
<tr>
<td>InvocationExpression</td>
<td>   -    </td>
</tr>
<tr>
<td>DebugInfoExpression</td>
<td>       .         </td>
</tr>
<tr>
<td>SymbolDocumentInfo</td>
<td>       ,        .</td>
</tr>
<tr>
<td>DynamicExpression</td>
<td>   ( )</td>
</tr>
<tr>
<td>RuntimeVariablesExpression</td>
<td>   /    </td>
</tr>
<tr>
<td>TypeBinaryExpression</td>
<td>,      (is)</td>
</tr>
</tbody></table></div><br>
      <br>
<br>
<ul>
<li>ExpressionVisitor ‚Äî     .  .</li>
<li>DynamicExpressionVisitor ‚Äî      DynamicExpression ( VisitDynamic)</li>
</ul><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Informasi ini cukup untuk mulai membandingkan metode bekerja dengan pohon ekspresi. </font><font style="vertical-align: inherit;">Saya memutuskan untuk menguraikan semua ini dengan contoh menemukan turunannya. </font><font style="vertical-align: inherit;">Saya tidak melihat semua opsi yang mungkin - hanya yang dasar. </font><font style="vertical-align: inherit;">Tetapi jika karena alasan tertentu seseorang memutuskan untuk memodifikasi dan menggunakannya, saya akan dengan senang hati membagikan peningkatan melalui permintaan ke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositori</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saya </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="pm"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencocokan pola</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, tugasnya adalah membuat kalkulus derivatif. </font><font style="vertical-align: inherit;">Anda dapat memperkirakan yang berikut ini: ada beberapa aturan untuk menemukan turunan untuk berbagai jenis operasi - penggandaan, pembagian, dll. </font><font style="vertical-align: inherit;">Bergantung pada operasinya, Anda harus memilih formula tertentu. </font><font style="vertical-align: inherit;">Dalam formulasi dangkal seperti itu, tugas idealnya ditempatkan pada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sakelar / kasing</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dan dalam versi bahasa terbaru, kami disajikan dengan switch / case 2.0 atau </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pencocokan pola</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sulit untuk membahas sesuatu di sini. </font><font style="vertical-align: inherit;">Pada hub, jumlah kode seperti itu terlihat rumit dan kurang dibaca, jadi saya sarankan melihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sebagai contoh turunan, ternyata seperti ini:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh</font></font></b><div class="spoiler_text"><pre><code class="cs hljs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PatterntMatchingDerivative</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _one = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
		<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; ParseDerivative(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(ParseDerivative(function.Body), function.Parameters);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> Expression <span class="hljs-title">ParseDerivative</span>(<span class="hljs-params">Expression function</span>)</span> =&gt; function <span class="hljs-keyword">switch</span><font></font>
        {<font></font>
            BinaryExpression binaryExpr =&gt; function.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{	<font></font>
	  	    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression _) =&gt; constant,<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; constant,<font></font>
		    _ =&gt; Expression.Add(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right)))<font></font>
		},<font></font>
<font></font>
                ExpressionType.Divide =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{<font></font>
		    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression parameter) =&gt; Expression.Divide(constant, Expression.Multiply(parameter, parameter)),<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; Expression.Divide(_one, constant),<font></font>
		    _ =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right))<font></font>
	        },<font></font>
            },<font></font>
            MethodCallExpression methodCall <span class="hljs-keyword">when</span> methodCall.Method == _pow =&gt; (methodCall.Arguments[<span class="hljs-number">0</span>], methodCall.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(methodCall, Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, _pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(ParseDerivative(expression), methodCall), Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
             },<font></font>
             _ =&gt; function.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Constant =&gt; _zero,<font></font>
                ExpressionType.Parameter =&gt; _one,<font></font>
                _ =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryException(<span class="hljs-string">"Bitmap best practice"</span>)<font></font>
             }<font></font>
        };<font></font>
    }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terlihat agak tidak biasa, tetapi menarik. </font><font style="vertical-align: inherit;">Senang sekali menulis ini - semua persyaratan cocok secara organik pada satu baris. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh berbicara sendiri, Anda tidak dapat menggambarkannya lebih baik dengan kata-kata.</font></font><br>
<a name="nv"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengunjung naif</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam tugas seperti itu, seorang pengunjung pohon ekspresi segera muncul di benak, yang membuat banyak suara </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dan sedikit panik di antara para amatir untuk membahas lincah di dapur. </font><font style="vertical-align: inherit;">"Takut bukan karena ketidaktahuan, tetapi pengetahuan palsu. </font><font style="vertical-align: inherit;">Lebih baik tidak mengetahui apa pun daripada mempertimbangkan kebenaran yang tidak benar. " </font><font style="vertical-align: inherit;">Mengingat frasa Tolstoy yang indah ini, mengakui ketidaktahuan dan meminta dukungan Google, Anda dapat menemukan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panduan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berikut </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya memiliki tautan ini adalah yang pertama (setelah Siberia pada tahun 1949) untuk kueri "Pengunjung pohon ekspresi". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekilas, inilah tepatnya yang kita butuhkan. </font><font style="vertical-align: inherit;">Judul artikel sesuai dengan apa yang ingin kita lakukan, dan kelas-kelas dalam contoh diberi nama dengan suffix </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visitor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah meninjau artikel dan membuat, dengan analogi untuk contoh kita dengan turunannya, kita mendapatkan: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tautan ke github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomDerivativeExpressionTreeVisitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; Visit(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(Visitor.CreateFromExpression(function.Body).Visit(), function.Parameters);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> MethodInfo Pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> MethodInfo Log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> ConstantExpression Zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> ConstantExpression One = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Visitor <span class="hljs-title">CreateFromExpression</span>(<span class="hljs-params">Expression node</span>)</span>
            =&gt; node <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                BinaryExpression be =&gt; <span class="hljs-keyword">new</span> BinaryVisitor(be),<font></font>
                MethodCallExpression mce <span class="hljs-keyword">when</span> mce.Method == Pow =&gt; <span class="hljs-keyword">new</span> PowMethodCallVisitor(mce),<font></font>
                _ =&gt; <span class="hljs-keyword">new</span> SimpleVisitor(node),<font></font>
            };<font></font>
        <font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BinaryVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> BinaryExpression _node;<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinaryVisitor</span>(<span class="hljs-params">BinaryExpression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; _node.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(ParseDerivative(binaryExpr.Left), ParseDerivative(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{	<font></font>
	  	    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression _) =&gt; constant,<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; constant,<font></font>
		    _ =&gt; Expression.Add(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right)))<font></font>
		},<font></font>
<font></font>
                ExpressionType.Divide =&gt; (binaryExpr.Left, binaryExpr.Right) <span class="hljs-keyword">switch</span><font></font>
		{<font></font>
		    (ConstantExpression _, ConstantExpression _) =&gt; _zero,<font></font>
		    (ConstantExpression constant, ParameterExpression parameter) =&gt; Expression.Divide(constant, Expression.Multiply(parameter, parameter)),<font></font>
		    (ParameterExpression _, ConstantExpression constant) =&gt; Expression.Divide(_one, constant),<font></font>
		    _ =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(ParseDerivative(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, ParseDerivative(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right))<font></font>
	        },<font></font>
            };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PowMethodCallVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodCallExpression _node;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PowMethodCallVisitor</span>(<span class="hljs-params">MethodCallExpression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; (_node.Arguments[<span class="hljs-number">0</span>], _node.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(_node, Expression.Call(<span class="hljs-literal">null</span>, Log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, Pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(CreateFromExpression(expression).Visit(), _node), Expression.Call(<span class="hljs-literal">null</span>, Log, constant)),<font></font>
            };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleVisitor</span> : <span class="hljs-title">Visitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Expression _node;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleVisitor</span>(<span class="hljs-params">Expression node</span>)</span><font></font>
        {<font></font>
            _node = node;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Visit</span>(<span class="hljs-params"></span>)</span>
            =&gt; _node.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Constant =&gt; Zero,<font></font>
                ExpressionType.Parameter =&gt; One,<font></font>
            };<font></font>
    }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faktanya - kami menyebarkan switch case untuk kelas yang berbeda. </font><font style="vertical-align: inherit;">Tidak kurang dari mereka, sihir tidak muncul. </font><font style="vertical-align: inherit;">Semua kasus yang sama, lebih banyak garis. </font><font style="vertical-align: inherit;">Dan di mana pengiriman kiriman ganda dijanjikan?</font></font><br>
<a name="cv"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengunjung klasik dan pengiriman ganda</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini perlu diceritakan tentang template </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengunjung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> itu sendiri </font><font style="vertical-align: inherit;">, itu juga </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengunjung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang merupakan dasar dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengunjung pohon Ekspresi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mari kita menganalisisnya hanya pada contoh pohon ekspresi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk sesaat, misalkan kita merancang pohon ekspresi. Kami ingin memberi pengguna kemampuan untuk beralih melalui pohon ekspresi dan, tergantung pada jenis simpul (jenis Ekspresi), lakukan tindakan tertentu. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi pertama</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah tidak melakukan apa-apa. Artinya, memaksa pengguna untuk menggunakan sakelar / kasing. Ini bukan pilihan yang buruk. Tapi di sini ada nuansa seperti itu: kami menyebarkan logika yang bertanggung jawab untuk jenis tertentu. Sederhananya, polimorfisme dan tantangan virtual ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alias terlambat mengikat</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) memungkinkan untuk menggeser definisi tipe ke runtime dan menghapus pemeriksaan ini dari kode kami. Cukup bagi kita untuk memiliki logika yang menciptakan instance dari tipe yang diinginkan, maka semuanya akan dilakukan oleh runtime untuk kita. </font></font><br>
 <br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi kedua.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi yang jelas adalah menarik logika ke dalam metode virtual. Dengan mengganti metode virtual di setiap penggantinya, kita bisa melupakan sakelar / kasing. Mekanisme panggilan polimorfik akan memutuskan untuk kita. Tabel metode akan bekerja di sini, metode akan dipanggil oleh offset di dalamnya. Tapi ini adalah topik untuk seluruh artikel, jadi jangan terbawa suasana. Metode virtual sepertinya bisa menyelesaikan masalah kita. Namun sayangnya, mereka membuat yang lain. Untuk tugas kami, kami dapat menambahkan metode GetDeriviative (). Tapi sekarang kelas ekspresi sendiri terlihat aneh. Kita dapat menambahkan metode semacam itu untuk semua kesempatan, tetapi mereka tidak cocok dengan logika umum kelas. Dan kami masih tidak memberikan kesempatan untuk melakukan sesuatu yang mirip dengan pengguna (tentu saja dengan cara yang memadai). Kita perlu membiarkan pengguna menentukan logika untuk setiap jenis tertentu,tetapi pertahankan polimorfisme (yang tersedia untuk kita).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hanya upaya pengguna untuk melakukan ini tidak akan berhasil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sinilah letak pengunjung sebenarnya. </font><font style="vertical-align: inherit;">Dalam tipe hierarki dasar (Ekspresi dalam kasus kami), kami mendefinisikan metode formulir</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">virtual</span> Expression <span class="hljs-title">Accept</span>(<span class="hljs-params">ExpressionVisitor visitor</span>)</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam ahli waris, metode ini akan diganti. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ExpressionVisitor sendiri adalah kelas dasar yang berisi metode virtual dengan tanda tangan yang sama </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
untuk setiap jenis hierarki. </font><font style="vertical-align: inherit;">Menggunakan kelas ExpressionVisitor sebagai contoh, VisitBinary (...), VisitMethodCall (...), VisitConstant (...), VisitParameter (...). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode-metode ini disebut dalam kelas yang sesuai dari hierarki kita. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu </font><font style="vertical-align: inherit;">Metode Terima di kelas BinaryExpression akan terlihat seperti ini:</font></font><br>
<br>
<pre><code class="cs hljs">	
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">internal</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">Accept</span>(<span class="hljs-params">ExpressionVisitor visitor</span>)</span><font></font>
{<font></font>
        <span class="hljs-keyword">return</span> visitor.VisitBinary(<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, untuk mendefinisikan perilaku baru, pengguna hanya perlu membuat pewaris kelas ExpressionVisitor, di mana metode yang sesuai untuk menyelesaikan satu masalah akan didefinisikan ulang. Dalam kasus kami, DerivativeExpressionVisitor dibuat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lebih lanjut, kami memiliki beberapa objek penerus Ekspresi, tetapi mana yang tidak diketahui, tetapi tidak perlu.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memanggil metode Terima virtual dengan implementasi ExpressionVisitor yang kami butuhkan, yaitu dengan DerivativeExpressionVisitor. Berkat pengiriman dinamis, implementasi Terima yang ditimpa disebut, seperti run-time, katakan BinaryExpression. Dalam tubuh metode ini, kami sangat memahami bahwa kami berada di BinaryExpression, tetapi kami tidak tahu penerus ExpressionVisitor mana yang datang kepada kami. Tapi sejak itu VisitBinary juga virtual, kita tidak perlu tahu. Sekali lagi, kita cukup memanggil dengan merujuk ke kelas dasar, panggilan tersebut secara dinamis (pada saat run time) dikirim dan implementasi VisitBinary yang dikesampingkan dari jenis runtime dipanggil. Begitu banyak untuk pengiriman ganda - ping-pong dengan gaya "Anda melakukannya" - "tidak, Anda". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa manfaatnya bagi kita. Bahkan, ini memungkinkan untuk "menambahkan" metode virtual dari luar, bukan</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mengubah kelas. </font><font style="vertical-align: inherit;">Kedengarannya hebat, tetapi memiliki kelemahan:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa kiri dalam bentuk metode Terima, yang bertanggung jawab untuk segalanya dan untuk apa-apa pada saat yang sama</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Efek riak dari fungsi hash yang baik adalah bahwa ketika Anda menambahkan hanya satu pewaris hierarki, dalam kasus terburuk, semua orang harus menyelesaikan pengunjung mereka</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi sifat pohon ekspresi memungkinkan biaya ini karena spesifik bekerja dengan ekspresi, karena solusi semacam ini adalah salah satu fitur utama mereka. </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda dapat melihat semua metode yang tersedia untuk kelebihan beban. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, mari kita lihat bagaimana tampilannya pada akhirnya. </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tautan ke github.</font></font></a><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BuildinExpressionTreeVisitor</span> : <span class="hljs-title">ExpressionVisitor</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _pow = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Pow));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MethodInfo _log = <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-keyword">nameof</span>(Math.Log), <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>) });
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _zero = Expression.Constant(<span class="hljs-number">0</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ConstantExpression _one = Expression.Constant(<span class="hljs-number">1</span>d, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>));<font></font>
<font></font>
        <span class="hljs-keyword">public</span> Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; GetDerivative(Expression&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; function)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt;(Visit(function.Body), function.Parameters);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitBinary</span>(<span class="hljs-params">BinaryExpression binaryExpr</span>)</span>
            =&gt; binaryExpr.NodeType <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                ExpressionType.Add =&gt; Expression.Add(Visit(binaryExpr.Left), Visit(binaryExpr.Right)),<font></font>
                ExpressionType.Subtract =&gt; Expression.Subtract(Visit(binaryExpr.Left), Visit(binaryExpr.Right)),<font></font>
<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; _zero,<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ParameterExpression =&gt; binaryExpr.Left,<font></font>
                ExpressionType.Multiply <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ParameterExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; binaryExpr.Right,<font></font>
                ExpressionType.Multiply =&gt; Expression.Add(Expression.Multiply(Visit(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, Visit(binaryExpr.Right))),<font></font>
<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; _zero,<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ConstantExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ParameterExpression =&gt; Expression.Divide(binaryExpr.Left, Expression.Multiply(binaryExpr.Right, binaryExpr.Right)),<font></font>
                ExpressionType.Divide <span class="hljs-keyword">when</span> binaryExpr.Left <span class="hljs-keyword">is</span> ParameterExpression &amp;&amp; binaryExpr.Right <span class="hljs-keyword">is</span> ConstantExpression =&gt; Expression.Divide(_one, binaryExpr.Right),<font></font>
                ExpressionType.Divide =&gt; Expression.Divide(Expression.Subtract(Expression.Multiply(Visit(binaryExpr.Left), binaryExpr.Right), Expression.Multiply(binaryExpr.Left, Visit(binaryExpr.Right))), Expression.Multiply(binaryExpr.Right, binaryExpr.Right)),<font></font>
            };<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitMethodCall</span>(<span class="hljs-params">MethodCallExpression methodCall</span>)</span>
            =&gt; (methodCall.Arguments[<span class="hljs-number">0</span>], methodCall.Arguments[<span class="hljs-number">1</span>]) <span class="hljs-keyword">switch</span><font></font>
            {<font></font>
                (ConstantExpression constant, ParameterExpression _) =&gt; Expression.Multiply(methodCall, Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
                (ParameterExpression param, ConstantExpression constant) =&gt; Expression.Multiply(constant, Expression.Call(<span class="hljs-literal">null</span>, _pow, param, Expression.Constant((<span class="hljs-keyword">double</span>)constant.Value - <span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">double</span>)))),<font></font>
                (ConstantExpression constant, Expression expression) =&gt; Expression.Multiply(Expression.Multiply(Visit(expression), methodCall), Expression.Call(<span class="hljs-literal">null</span>, _log, constant)),<font></font>
            };<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitConstant</span>(<span class="hljs-params">ConstantExpression _</span>)</span> =&gt; _zero;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Expression <span class="hljs-title">VisitParameter</span>(<span class="hljs-params">ParameterExpression b</span>)</span> =&gt; _one;<font></font>
    }<font></font>
</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temuan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin, seperti dalam kebanyakan tugas pemrograman, jawaban yang pasti tidak dapat diberikan. </font><font style="vertical-align: inherit;">Semuanya, seperti biasa, tergantung pada situasi spesifik. </font><font style="vertical-align: inherit;">Saya suka pencocokan pola yang biasa untuk contoh saya, karena </font><font style="vertical-align: inherit;">Saya tidak mengembangkannya ke skala pengembangan industri. </font><font style="vertical-align: inherit;">Jika ungkapan ini akan meningkat tanpa terkendali, ada baiknya memikirkan pengunjung. </font><font style="vertical-align: inherit;">Dan bahkan pengunjung yang naif memiliki hak untuk hidup - setelah semua, ini adalah cara yang baik untuk menyebarkan sejumlah besar kode ke dalam kelas jika hierarki belum memberikan dukungan pada bagiannya. </font><font style="vertical-align: inherit;">Dan bahkan di sini ada pengecualian. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Demikian juga, dukungan pengunjung dari hierarki adalah hal yang sangat kontroversial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi saya berharap bahwa informasi yang diberikan di sini cukup untuk membuat pilihan yang tepat.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id486972/">https://habr.com/ru/post/id486972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id486948/index.html">Bagaimana memilih editor, dan mengapa memilih NeoVim?</a></li>
<li><a href="../id486950/index.html">Antiquities: upgrade tanpa ampun dari komputer 386</a></li>
<li><a href="../id486962/index.html">Ulasan Pengembangan Game HSE</a></li>
<li><a href="../id486964/index.html">Multitasking dan penasaran. Java Champion Mitya Alexandrov pada penciptaan komunitas TI, "jarak jauh" dan kehidupan</a></li>
<li><a href="../id486966/index.html">Mengapa kenyamanan vs keamanan bukanlah kompromi</a></li>
<li><a href="../id486974/index.html">Produksi massal elektronik di Rusia. Otomasi Tes</a></li>
<li><a href="../id486976/index.html">Masalah pendidikan informasi Rusia dan kemungkinan solusinya</a></li>
<li><a href="../id486978/index.html">Catatan Lapangan: Salah satu Konferensi OpenSource Terbesar FOSDEM 2020</a></li>
<li><a href="../id486980/index.html">Kim Dotcom: Tertangkap, orang yang paling dicari online. Bagian 1</a></li>
<li><a href="../id486982/index.html">Cara belajar pengembangan front-end, mencari pekerjaan pertama Anda dan tidak mendapatkan gundukan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>