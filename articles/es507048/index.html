<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëΩ üéã üì† Olya, pruebas y f√°brica: el camino hacia una bella arquitectura y un c√≥digo limpio üç¢ ‚ò†Ô∏è üë©üèæ‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la automatizaci√≥n de pruebas, hay muchos enfoques, soluciones y m√©todos diferentes. El m√°s com√∫n e indispensable es el patr√≥n Objeto de p√°gina (Obj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Olya, pruebas y f√°brica: el camino hacia una bella arquitectura y un c√≥digo limpio</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/507048/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la automatizaci√≥n de pruebas, hay muchos enfoques, soluciones y m√©todos diferentes. </font><font style="vertical-align: inherit;">El m√°s com√∫n e indispensable es el patr√≥n Objeto de p√°gina (Objeto de pantalla). </font><font style="vertical-align: inherit;">Me encontr√© con dos enfoques al trabajar con este patr√≥n: con una f√°brica para mis objetos de p√°gina y sin √©l. </font><font style="vertical-align: inherit;">En este art√≠culo, con el ejemplo de nuestras pruebas autom√°ticas, comparamos ambos enfoques, sus ventajas y desventajas. </font><font style="vertical-align: inherit;">D√©jame mostrarte c√≥mo es nuestra f√°brica de objetos de p√°gina. </font><font style="vertical-align: inherit;">Tambi√©n hablar√© sobre los problemas que encontramos en las pruebas autom√°ticas con la f√°brica y c√≥mo se resolvieron. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Citar√© todos los ejemplos en el art√≠culo en Swift, pero para las pruebas autom√°ticas de Android todo funciona de la misma manera.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ci/5e/br/ci5ebr0v9onedivfawpjjy-ux0c.png"></div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para comenzar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hola, mi nombre es Olya. Soy un probador de aplicaciones m√≥viles en hh.ru. Durante dos a√±os seguidos, transferimos el 90% de las pruebas manuales a automatizadas. Durante este tiempo, logramos tropezar con varias trampas muchas veces, discutir cientos de disputas y ahora quiero compartir nuestra experiencia con el mundo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escribimos autotests en Android (Kotlin, Kaspresso) y en iOS (Swift, XCUITest). Intentamos que las pruebas de IU sean peque√±as, verificando solo los scripts individuales. El beneficio del hierro es suficiente para esto, y la regresi√≥n de ~ 300-400 UI pruebas autom√°ticas en cada plataforma lleva un promedio de 30-40 minutos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestras pruebas autom√°ticas utilizamos el patr√≥n de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objeto de p√°gina</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se han escrito miles de art√≠culos sobre √©l, por lo que no nos detendremos en √©l con m√°s detalle.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hist√≥ricamente, al crear las primeras pruebas autom√°ticas en iOS y Android, elegimos diferentes enfoques para trabajar con objetos de p√°gina. </font><font style="vertical-align: inherit;">En Android, solo seguimos el patr√≥n, y en iOS tambi√©n creamos una f√°brica de objetos de p√°gina. </font><font style="vertical-align: inherit;">Una f√°brica es el lugar donde se inicializan todos los objetos de p√°gina. </font><font style="vertical-align: inherit;">Utiliz√°ndolo, en los m√©todos de nuestras pantallas, podemos transferir otros objetos de p√°gina, construyendo as√≠ cadenas de interacciones similares al comportamiento de la aplicaci√≥n.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øLa f√°brica necesita objetos de p√°gina?&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de crear cientos de casos de prueba, llegamos a la conclusi√≥n de que usar la f√°brica de objetos de p√°gina es una cuesti√≥n de gusto para el probador que escribir√° las pruebas autom√°ticas. No hay diferencia en el rendimiento y la estabilidad cuando se trabaja con diferentes enfoques. Pero para no sufrir c√≥digo nativo en el futuro, debe decidir lo antes posible si habr√° un lugar para la f√°brica de objetos de p√°gina en la arquitectura de las pruebas autom√°ticas o no. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para mayor claridad, dar√© dos ejemplos de la misma prueba: escrita con y sin f√°brica.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qu√© hace esta prueba: desde la pantalla principal de la aplicaci√≥n, el usuario intenta ir a la pesta√±a de perfil. En el perfil, selecciona "Iniciar sesi√≥n", luego el m√©todo de inicio de sesi√≥n por inicio de sesi√≥n e ingresa su nombre de usuario y contrase√±a, y luego hace clic en el bot√≥n "Iniciar sesi√≥n".</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//   </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{
   <span class="hljs-keyword">let</span> mainScreen = <span class="hljs-type">MainScreen</span>()
   <span class="hljs-keyword">let</span> profileScreen = <span class="hljs-type">ProfileScreen</span>()
   <span class="hljs-keyword">let</span> authorizationScreen = <span class="hljs-type">AuthorizationScreen</span>()
   <span class="hljs-keyword">let</span> loginScreen = <span class="hljs-type">LoginScreen</span>()<font></font>
 <font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser()<font></font>
 <font></font>
        mainScreen.openProfileTab()<font></font>
        profileScreen.goToAuthorization()<font></font>
        authorizationScreen.goToLogin()<font></font>
        loginScreen<font></font>
           .enterLogin(user.login)<font></font>
           .enterPassword(user.password)<font></font>
           .logIn()   <font></font>
   }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-comment">//   </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser()<font></font>
 <font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openProfileTab()<font></font>
            .goToAuthorization()<font></font>
            .goToLogin()<font></font>
            .enterLogin(user.login)<font></font>
            .enterPassword(user.password)<font></font>
            .logIn()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si despu√©s de este ejemplo decide que las pruebas sin una f√°brica se ven bien, simplemente tome y escriba sin ella. </font><font style="vertical-align: inherit;">Este consejo es especialmente relevante si no tiene una aplicaci√≥n muy grande, con diferentes contenidos y elementos que no se repitan. </font><font style="vertical-align: inherit;">O si escribe pruebas en las que no hay m√°s de 10-15 pasos. </font><font style="vertical-align: inherit;">En este caso, la f√°brica no har√° el clima.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero si este no es el caso, o si las pruebas de f√°brica han respondido en su coraz√≥n, entonces este art√≠culo es para usted.&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qe/g4/zc/qeg4zcjbcn8z9yrhq83bmteoz8k.jpeg"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo se ve nuestra f√°brica?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos para qu√© sirve la f√°brica de objetos de p√°gina, c√≥mo se ve y qu√© hace. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un caso de prueba est√°ndar es un conjunto de pasos:</font></font><br>
<blockquote><ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iniciar la aplicacion</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abrir pantalla de perfil</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toque "Iniciar sesi√≥n"</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elija un m√©todo de inicio de sesi√≥n con inicio de sesi√≥n y contrase√±a</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingrese los datos del usuario (nombre de usuario y contrase√±a)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toque el bot√≥n "Iniciar sesi√≥n"</font></font></li>
</ol><br>
</blockquote><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prueba de screencast</font></font></b>
                        <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/nYHsgZiJgo8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada paso del caso de prueba corresponde a un paso en la prueba autom√°tica. Tambi√©n puede decir que cada paso es un m√©todo de objeto de p√°gina separado de la pantalla correspondiente.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si queremos repetir este caso de prueba en la prueba autom√°tica exactamente en pasos, construir la misma cadena ininterrumpida de llamadas a m√©todos, necesitamos que cada m√©todo devuelva el objeto de p√°gina de la siguiente pantalla. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al crear un objeto de p√°gina, debe inicializarse. Resulta que si queremos crear objetos de p√°gina dentro de otros, habr√° muchas inicializaciones id√©nticas en cada objeto de p√°gina. Para no hacer esto, las inicializaciones de todos los objetos de p√°gina se mueven a la f√°brica: pageObjectFactory (o screenFactory, etc.). Al final de cada m√©todo, le pedimos a la f√°brica que cree la pantalla que necesitamos.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfilePageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goToAuthScreen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AuthPageObject</span> {<font></font>
        openAuthButton.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeAuthPageObject()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos los objetos de p√°gina se heredan de BasePageObject, que contiene los par√°metros principales. </font><font style="vertical-align: inherit;">En √©l, debemos prescribir un constructor requerido para que la f√°brica pueda crear cualquiera de sus herederos. </font><font style="vertical-align: inherit;">En nuestro caso, la clase base se ve as√≠:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePageObject</span> </span>{
    <span class="hljs-keyword">let</span> pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>
    <span class="hljs-keyword">let</span> application: <span class="hljs-type">XCUIApplication</span><font></font>
 <font></font>
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>,<font></font>
                       application: <span class="hljs-type">XCUIApplication</span>) {
        <span class="hljs-keyword">self</span>.pageObjectsFactory = pageObjectsFactory
        <span class="hljs-keyword">self</span>.application = application<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y la inicializaci√≥n de pantallas en la f√°brica como resultado se ve as√≠:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageObjectsFactory</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initializePageObject</span>&lt;PageObject: BasePageObject&gt;<span class="hljs-params">(ofType type: PageObject.<span class="hljs-keyword">Type</span>)</span></span> -&gt; <span class="hljs-type">PageObject</span> {
        <span class="hljs-keyword">return</span> type.<span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-keyword">self</span>, application: application)<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeAuthPageObject</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AuthPageObject</span> {
        <span class="hljs-keyword">return</span> initializePageObject(ofType: <span class="hljs-type">AuthPageObject</span>.<span class="hljs-keyword">self</span>)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, en el m√©todo de cualquier objeto de p√°gina, podemos llamar al m√©todo de f√°brica para crear una pantalla que lo inicialice.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ventajas de la vida de un probador sin f√°brica</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. De la prueba siempre queda claro en qu√© pantalla se realiza la acci√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin una f√°brica, en cada l√≠nea de </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo el punto de</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> prueba </font><s><font style="vertical-align: inherit;">,</font></s><font style="vertical-align: inherit;"> la pantalla y la acci√≥n que tiene lugar en ella est√°n claramente registradas. </font><font style="vertical-align: inherit;">Esto le permite no leer todo el c√≥digo de prueba desde el principio, por ejemplo, durante la depuraci√≥n y las correcciones. </font><font style="vertical-align: inherit;">La falta de una f√°brica agrega legibilidad, especialmente cuando se realizan acciones o verificaciones en una pantalla.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span> : <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
<font></font>
    <span class="hljs-comment">//   ,   </span>
    <span class="hljs-keyword">let</span> mainScreen = <span class="hljs-type">MainScreen</span>()
    <span class="hljs-keyword">let</span> profileScreen = <span class="hljs-type">ProfileScreen</span>()
    <span class="hljs-keyword">let</span> authorizationScreen = <span class="hljs-type">AuthorizationScreen</span>()
    <span class="hljs-keyword">let</span> loginScreen = <span class="hljs-type">LoginScreen</span>()<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser() <span class="hljs-comment">//   </span><font></font>
 <font></font>
        mainScreen.openProfileTab() <span class="hljs-comment">//      </span>
        profileScreen.goToAuthorization() <span class="hljs-comment">//     ""</span>
        authorizationScreen.goToLogin() <span class="hljs-comment">//          </span>
        loginScreen <span class="hljs-comment">//           </span><font></font>
            .enterLogin(user.login)<font></font>
            .enterPassword(user.password)<font></font>
            .login()   <font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incluso si no est√° muy inmerso en todas las complejidades de la aplicaci√≥n, inmediatamente quedar√° claro en el ejemplo anterior que las acciones enterLogin / enterPassword se realizan en la misma pantalla. </font><font style="vertical-align: inherit;">La prueba con la f√°brica no ser√° tan clara: puede pensar que la acci√≥n enterLogin transfiri√≥ al usuario a la siguiente pantalla.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Es m√°s conveniente escribir pruebas con acciones que pueden conducir a diferentes pantallas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al escribir pruebas sin una f√°brica, no necesita pensar en el hecho de que cualquier acci√≥n del usuario, dependiendo del estado de la aplicaci√≥n, puede comportarse de manera diferente, simplemente describa la l√≥gica de lo que est√° sucediendo:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//        </span><font></font>
    vacancyScreen.tapResponseButton()<font></font>
    authScreen.authUser(user)<font></font>
    responseScreen.checkScreenIsOpened()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//       	</span><font></font>
    vacancyScreen.tapResponseButton()<font></font>
    responseScreen.checkScreenIsOpened()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el caso de los objetos de p√°gina de f√°brica, tendr√° que pensar c√≥mo, seg√∫n la autorizaci√≥n del usuario, devolver la pantalla deseada en el m√©todo tapResponseButton () (o duplicar un m√©todo como tapResponseButtonAndLogin ())</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tapResponseButton</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ResponseSendPageObject</span> {<font></font>
        responseButton.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeResponseSendPageObject()<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tapResponseButtonAndLogin</span><span class="hljs-params">(login: String)</span></span> -&gt; <span class="hljs-type">ResponseSendPageObject</span> {<font></font>
        responseButton.tap()<font></font>
        pageObjectsFactory<font></font>
            .makeAuthorizationPageObject()<font></font>
            .goToLogin()<font></font>
            .logIn(login)<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeResponseSendPageObject()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos 6 m√©todos similares en esta pantalla, a pesar de que todos tocan el mismo bot√≥n.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. No es necesario ajustar cada acci√≥n y cada verificaci√≥n en un m√©todo separado</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los m√©todos de objetos de p√°gina sin una f√°brica no necesitan volver a la siguiente pantalla para continuar la cadena, respectivamente, para acciones individuales, no puede crear m√©todos separados.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, tocar un bot√≥n en una prueba sin una f√°brica podr√≠a verse as√≠:</font></font><br>
<br>
<pre><code class="swift hljs">    vacancyScreen.responseButton.tap()</code></pre><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. No tiene que pensar en soluciones complejas, adicionalmente piense en la arquitectura de los objetos de la p√°gina.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En mi experiencia, al escribir autotests sin una f√°brica, pr√°cticamente no hay problemas con los objetos de p√°gina. </font><font style="vertical-align: inherit;">Describir un nuevo objeto de p√°gina es un proceso f√°cil y r√°pido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La f√°brica, junto con sus capacidades, agrega algunas dificultades, de las que hablar√© m√°s adelante.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las indudables ventajas de la f√°brica.</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Al escribir una prueba, no hay forma de saltear un paso</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos los m√©todos de objetos de p√°gina son enlaces de una cadena. Cada nuevo enlace (m√©todo) debe enclavarse con lo siguiente. Esto se debe al hecho de que todos los m√©todos devuelven un objeto de p√°gina (ellos mismos u otro), por lo que al escribir una prueba no tenemos forma de elegir el m√©todo de ninguna pantalla, solo lo siguiente.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, acelera significativamente la escritura de su primer autotest por un nuevo probador. El IDE mismo le dice qu√© acciones y en qu√© pantalla puede llevar a cabo m√°s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En segundo lugar, esta arquitectura de pruebas autom√°ticas le permite reconocer la aplicaci√≥n a trav√©s de su escritura, y no al rev√©s. (De nuevo, una buena motivaci√≥n para los j√≥venes probadores).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En tercer lugar, no hay forma de omitir un paso, porque el m√©todo deseado simplemente no aparecer√° hasta que pase la secuencia de comandos correctamente. </font><font style="vertical-align: inherit;">Tales omisiones son bastante comunes cuando se escriben pruebas sin una f√°brica, y solo las descubrir√° cuando ejecute la prueba.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Si cambia la firma del m√©todo de objeto de p√°gina, el IDE lo obligar√° a cambiar todas las pruebas asociadas con el objeto</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este art√≠culo se sigue del anterior. </font><font style="vertical-align: inherit;">Todos los m√©todos de objeto de p√°gina repiten la l√≥gica y el comportamiento de la aplicaci√≥n. </font><font style="vertical-align: inherit;">Si la aplicaci√≥n cambia la l√≥gica de las transiciones entre pantallas o agrega otras nuevas, corregiremos el m√©todo que necesitamos y cambiaremos su rendimiento. </font><font style="vertical-align: inherit;">En las autocomprobaciones de f√°brica, para encontrar todas las pruebas que se ven afectadas por este cambio, no tiene que ejecutar todas las pruebas. </font><font style="vertical-align: inherit;">El IDE mismo se√±alar√° todos los lugares en los que se rompi√≥ la "cadena". </font><font style="vertical-align: inherit;">Las pruebas sin una f√°brica no siguen esto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. La arquitectura y la limpieza del c√≥digo no sufren la creaci√≥n de objetos de pantalla superfluos&nbsp;</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si no utiliza una f√°brica, y la prueba pasa por el gui√≥n a trav√©s de docenas de pantallas, al comienzo de la clase con la prueba tendr√° que escribir un bloque completo para crear objetos de cada pantalla. </font><font style="vertical-align: inherit;">Y debe hacer esto cada vez para cada clase de pruebas. </font><font style="vertical-align: inherit;">Peor a√∫n si escribe varias pruebas en la misma clase. </font><font style="vertical-align: inherit;">Luego, el tama√±o de este "bloque" con la creaci√≥n de todos los objetos de p√°gina aumenta significativamente.&nbsp;&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un ejemplo de una prueba real, en la que el usuario responde a una vacante, cierra sesi√≥n e inicia sesi√≥n en otro usuario. </font><font style="vertical-align: inherit;">Este bloque se mueve de clase a clase con cambios menores para todas las pruebas similares.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterUpdateAfterOtherUserLoginTest</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> mainScreen = <span class="hljs-type">MainScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> vacanciesScreen = <span class="hljs-type">VacanciesScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> responseToVacancyScreen = <span class="hljs-type">ResponseToVacancyBottomSheet</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> successResponseBottomSheet = <span class="hljs-type">SuccessResponseBottomSheet</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> settingsScreen = <span class="hljs-type">UserSettingsScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> chooseAuthScreen = <span class="hljs-type">ChooseAuthScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> authScreen = <span class="hljs-type">NativeAuthScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> navigation = <span class="hljs-type">NavigationPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> moreScreen = <span class="hljs-type">MoreScreenPageObject</span>()<font></font>
<font></font>
    ...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay una opci√≥n para realizar la inicializaci√≥n de todos los objetos de p√°gina en la clase base de pruebas utilizando la inicializaci√≥n diferida. </font><font style="vertical-align: inherit;">Luego, en cada prueba, todas las pantallas estar√°n disponibles y no se crear√°n objetos innecesarios. </font><font style="vertical-align: inherit;">Pero el problema de enumerar muchas pantallas volver√° cuando queramos crear objetos de p√°gina en los propios objetos de p√°gina si necesitamos escribir un m√©todo que pasar√° por otra pantalla. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La f√°brica asume la tarea de inicializar los objetos de p√°gina necesarios cuando se necesitan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Una gran oportunidad para profundizar en el c√≥digo de la aplicaci√≥n, estudiar su arquitectura, m√≥dulos, su interacci√≥n, etc.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tener una f√°brica de objetos de p√°gina requiere ajustar todas las acciones con la pantalla en m√©todos que devolver√°n la siguiente pantalla. </font><font style="vertical-align: inherit;">Debido a esto, los objetos de p√°gina se est√°n expandiendo enormemente, lo que hace que te preguntes c√≥mo hacer que todo sea m√°s hermoso y preciso. </font><font style="vertical-align: inherit;">En aras de esto, est√° tratando de usar t√©cnicas arquitect√≥nicas, ver la implementaci√≥n de varias pantallas en el c√≥digo de la aplicaci√≥n, rastrear la interacci√≥n de los m√≥dulos para construir un sistema similar en sus pruebas autom√°ticas, que ser√° agradable y conveniente de usar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como beneficio adicional, obtenemos conocimiento sobre c√≥mo funciona la aplicaci√≥n desde adentro. </font><font style="vertical-align: inherit;">Como m√≠nimo, esto es √∫til para el desarrollo general y, a menudo, ayuda mucho cuando se realizan pruebas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. El c√≥digo de prueba se ve muy limpio y ordenado.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No hay comentarios, esto es realmente aromatizante. </font><font style="vertical-align: inherit;">Acerca de c√≥mo para usted "m√°s preciso y m√°s limpio" se puede decidir por el primer ejemplo.</font></font><br>
<br>
<p></p><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Errores // c√≥mo tropezaron y dieron vueltas</font></font></h1><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gd/4a/jz/gd4ajzpobkjvg6t4tq1vy-3a-ws.jpeg" width="60%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos concluir que es mejor usar la f√°brica de objetos de p√°gina al escribir autotests. </font><font style="vertical-align: inherit;">No pregunte a nadie por qu√© usan la f√°brica, siempre hay una respuesta: "Y trata de escribir una prueba sin ella y comparar". </font><font style="vertical-align: inherit;">La f√°brica realmente asume una parte importante de las tareas, la responsabilidad por la ausencia de errores en la secuencia de la prueba autom√°tica, etc. </font><font style="vertical-align: inherit;">Tambi√©n abre algunas oportunidades interesantes sobre las que escrib√≠ anteriormente.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero quiero se√±alar que no todo es color de rosa con estas capacidades. </font><font style="vertical-align: inherit;">Durante la automatizaci√≥n con la f√°brica, encontramos problemas muy desagradables, pero al final los resolvimos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocolos y elementos comunes a toda la aplicaci√≥n.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay elementos en cualquier aplicaci√≥n m√≥vil a los que se puede acceder desde cualquier pantalla. Por ejemplo, puede tomar una barra de pesta√±as (men√∫). Surge la pregunta: ¬øc√≥mo, sin interrumpir la cadena de llamadas a los m√©todos de objetos de p√°gina, obtener acceso a los m√©todos de la barra de pesta√±as en cualquier momento de la prueba?&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La decisi√≥n m√°s obvia y nuestra decisi√≥n inicial es hacer la extensi√≥n de la clase base de objetos de p√°gina con estos m√©todos.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> XCTest<font></font>
 <font></font>
<span class="hljs-comment">/*
      .
 */</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> tabBar = application.tabBars[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.identifier].firstMatch
    <span class="hljs-keyword">var</span> searchTab =  tabBar.buttons[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.searchTab].firstMatch<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span> {<font></font>
        searchTab.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory.makeMainScreenPageObject()<font></font>
    }<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante la discusi√≥n, nos dimos cuenta de que la barra de pesta√±as no es el √∫nico elemento que se necesita en todas las pantallas y llegamos a la conclusi√≥n de que al agregar m√°s y m√°s extensiones, saturaremos r√°pidamente la clase base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra desventaja de esta soluci√≥n es que los m√©todos est√°n disponibles para todos los objetos de p√°gina, lo cual es incorrecto. Esto rompe el contrato para las clases sucesoras, que, en teor√≠a, deber√≠an contener solo m√©todos espec√≠ficos para ellas. Por ejemplo, para los objetos de alerta de p√°gina, no se necesitan m√©todos de barra de pesta√±as.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestra soluci√≥n final: creamos el protocolo TabBarUsable a partir del objeto de p√°gina de Tabbar (la interfaz para Kotlin es similar). Y escribieron su extensi√≥n (extensi√≥n, implementaci√≥n), que le permite no duplicar el c√≥digo y, al mismo tiempo, reemplazar la herencia con la composici√≥n.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> XCTest<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TabBarUsable</span> </span>{
    <span class="hljs-keyword">var</span> searchTab: <span class="hljs-type">XCUIElement</span> { <span class="hljs-keyword">get</span> }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span><font></font>
    ‚Ä¶<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">TabBarUsable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> tabBar: <span class="hljs-type">XCUIElement</span> { application.tabBars[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.identifier].firstMatch }
    <span class="hljs-keyword">var</span> searchTab: <span class="hljs-type">XCUIElement</span> { tabBar.buttons[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.searchTab].firstMatch }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span> {<font></font>
        searchTab.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory.makeMainScreenPageObject()<font></font>
    }<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para todas las pantallas que tienen una barra de pesta√±as, agregamos conformidad con este protocolo (conforme).</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span> </span>{<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En consecuencia, todos los m√©todos de trabajo con una barra de pesta√±as est√°n disponibles en todas estas pantallas.&nbsp;</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleTabbarTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleOpenSearchTab</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy() <span class="hljs-comment">//   .makeVacancyPageObject()</span>
            .openSearchTab() <span class="hljs-comment">//   TabBarUsable </span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al mismo tiempo, la arquitectura no se rompe, los m√©todos de la barra de pesta√±as est√°n disponibles solo para las pantallas que necesitamos y el c√≥digo de los mismos m√©todos no est√° duplicado.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocolos y Revisi√≥n de C√≥digo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se mencion√≥ anteriormente, cuando se usa la f√°brica de objetos de p√°gina, todas las acciones y todas las comprobaciones se envuelven en m√©todos. </font><font style="vertical-align: inherit;">Despu√©s de un tiempo, al crear la siguiente prueba autom√°tica, comienza a notar que escribe los mismos m√©todos para cada objeto de p√°gina, que ni siquiera difieren en los elementos. </font><font style="vertical-align: inherit;">Ejemplos de tales m√©todos pueden ser verificaciones de pantalla cero, trabajar con elementos de lista id√©nticos en diferentes pantallas, etc.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/a2/xg/ic/a2xgiczqetidmsoqa2rl2aandjo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un pensamiento l√≥gico: "¬°¬øMe lo har√© m√°s f√°cil ?!". ¬øC√≥mo dejar de duplicar c√≥digo? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primer m√©todo sobre el que ya escrib√≠ es poner todos esos m√©todos en la clase base. Es posible, pero con mucho cuidado. En primer lugar, este proceso es muy fascinante. Parece que un m√©todo en la clase base no arruinar√° nada, pero tarde o temprano la clase base se convertir√° en un monstruo insoportable, desestructurado y desordenado, en resumen, se vuelve completamente inadecuado. Lo intentamos, lo sabemos. Deshacerse de este monstruo es a√∫n m√°s dif√≠cil que hacerlo de inmediato.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con el tiempo, nos dimos cuenta de que el principio DRY (Don't Repeat Yourself) fue inventado por una raz√≥n. Comenzamos a buscar los mismos m√©todos que se utilizan en muchos objetos de p√°gina. Despu√©s de encontrarlos, discutieron durante mucho tiempo si estos m√©todos realmente se usan de la misma manera en todas partes, tienen la misma l√≥gica. Y finalmente, decidieron que si los m√©todos se usan en el 80% de los casos de la misma manera, entonces deber√≠an eliminarse en un protocolo separado.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uno de los primeros m√©todos representados fue el m√©todo waitView (). Hemos descrito el protocolo especial ViewWaitable y su implementaci√≥n en la extensi√≥n de protocolo, y ahora, para que este m√©todo est√© disponible en el objeto de p√°gina, solo necesita agregar conformidad al protocolo (conforme). Dado que los identificadores de vista son diferentes para todas las pantallas, todos los objetos de p√°gina que utilizan el protocolo deben declarar una vista en s√≠ mismos.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewWaitable</span> </span>{
    <span class="hljs-keyword">var</span> view: <span class="hljs-type">XCUIElement</span> { <span class="hljs-keyword">get</span> }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewWaitable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-meta">@discardableResult</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">waitView</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> {<font></font>
        testWaiter.waitForElementToAppear(view)<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span>, <span class="hljs-title">ViewWaitable</span> </span>{<font></font>
 <font></font>
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> view = application.otherElements[<span class="hljs-type">Accessibility</span>.view].firstMatch<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro ejemplo de nuestra aplicaci√≥n hh.ru: tenemos una lista de vacantes que se pueden encontrar en muchas pantallas diferentes, siendo la √∫nica diferencia el identificador de vista en el que se muestra esta lista. Muchas acciones y un mont√≥n de controles est√°n asociados con esta lista. Multipl√≠quelos por aproximadamente 10 (por el n√∫mero de pantallas en las que aparece esta lista) para estimar la escala de duplicaci√≥n de c√≥digo.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La soluci√≥n fue nuevamente los protocolos. Para que los protocolos sean a√∫n m√°s comprensibles y agradables de usar, dividimos los elementos de la lista (VacancyListContainig), los elementos de la celda (VacancyCellContainig), los m√©todos con controles (afirmaciones, controles) y los m√©todos de interacci√≥n (acciones). Esta separaci√≥n resolvi√≥ perfectamente el problema de la legibilidad del contenido de un gran objeto de p√°gina. La arquitectura final se ve as√≠:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sx/zw/_j/sxzw_jfnqwufs2snkgohmzxawb4.png" width="50%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los objetos de p√°gina en los que hay una lista de vacantes pueden agregar conformidad al protocolo VacancyListPageObject. </font><font style="vertical-align: inherit;">Por lo tanto, todos los m√©todos de la implementaci√≥n de este protocolo est√°n disponibles para la pantalla sin duplicaci√≥n de c√≥digo.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchResultPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">ViewWaitable</span>, <span class="hljs-title">VacancyListPageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> view = application<font></font>
        .otherElements[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">SearchResults</span>.view].firstMatch
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> listView = application<font></font>
        .tables[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">SearchResults</span>.tableView].firstMatch<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, debido a que seguimos el principio DRY, tenemos objetos de p√°gina muy limpios y ordenados, los mismos nombres de m√©todos y la falta de c√≥digo adicional.&nbsp;</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las mismas alertas en diferentes pantallas // Fuentes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los errores del sistema, las alertas y las hojas inferiores son una parte integral de las regresiones, que ciertamente quiero cubrir con pruebas autom√°ticas. Los errores y alertas ocurren en diferentes pantallas, en diferentes casos, difieren en diferentes estados de aplicaci√≥n, pero los elementos mismos, b√°sicamente, tienen los mismos identificadores y comportamiento. Obviamente, el mismo tipo de alerta con dos botones (por ejemplo, Aceptar / Cancelar) = un objeto de p√°gina separado.&nbsp;&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Volvemos al deseo de no interrumpir la cadena de llamadas a m√©todos. Tenemos: docenas de pantallas desde las que podemos abrir la misma alerta. Al cerrar dicha alerta, debemos volver al objeto de p√°gina desde el que se abri√≥. Al mismo tiempo, no queremos escribir estas mismas docenas de m√©todos duplicados en el objeto de p√°gina de dicha alerta, que solo diferir√°n entre s√≠ en el objeto de p√°gina devuelto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La soluci√≥n m√°s simple es calificar y romper la prueba una vez. </font><font style="vertical-align: inherit;">No hay nada malo con eso tampoco. </font><font style="vertical-align: inherit;">Y as√≠ la vida es mucho m√°s simple.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExample</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy()<font></font>
            .openAlert()<font></font>
            .closeAlert() <span class="hljs-comment">//      ,     </span><font></font>
        pageObjectFactory<font></font>
            .makeVacancyPageObject() <span class="hljs-comment">//   </span><font></font>
        ‚Ä¶<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestra soluci√≥n es m√°s complicada, ¬°pero qu√© hermosa es! </font><font style="vertical-align: inherit;">Agregamos el objeto de p√°gina del par√°metro de tipo de alerta ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gen√©rico</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), ser√° el tipo de objeto de p√°gina desde el que abrimos la alerta. </font><font style="vertical-align: inherit;">En este caso, el objeto de la p√°gina de esta pantalla se pasa a la alerta del objeto de la p√°gina tras la inicializaci√≥n y se almacena como una variable de origen gen√©rica.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√°s informaci√≥n sobre c√≥mo funciona esto: cuando abre (e inicializa) una alerta, pasamos la pantalla deseada en la variable gen√©rica de origen. </font><font style="vertical-align: inherit;">Esto se hace en el m√©todo de objeto de p√°gina, que abre la alerta:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openAlert</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AlertPageObject</span>&lt;<span class="hljs-type">VacancyPageObject</span>&gt; {<font></font>
        button.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeAlertPageObject(from: <span class="hljs-keyword">self</span>) <span class="hljs-comment">//  source VacancyPageObject</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, esta fuente (en este ejemplo, VacancyPageObject) pasa a trav√©s de todos los m√©todos necesarios en la prueba y termina en el despido finalAlert (). </font><font style="vertical-align: inherit;">Como resultado, el m√©todo de cierre de alerta devuelve la pantalla que necesitamos, en la que podemos continuar de inmediato la prueba.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlertPageObject</span>&lt;<span class="hljs-title">Source</span>: <span class="hljs-title">BasePageObject</span>&gt;: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dismissAlert</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Source</span> {<font></font>
        cancelButton.tap()<font></font>
        <span class="hljs-keyword">return</span> source <span class="hljs-comment">//  ,     ‚Äî VacancyPageObject</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como ya he dicho, para que el objeto de p√°gina pueda recibir y devolver las pantallas necesarias (fuentes), debe asignar un tipo gen√©rico limitado al tipo base de objetos de p√°gina e inicializarlo usando un objeto de p√°gina, que deber√° devolverse al final :</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlertPageObject</span>&lt;<span class="hljs-title">Source</span>: <span class="hljs-title">BasePageObject</span>&gt;: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-comment">// generic-          </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> source: <span class="hljs-type">Source</span><font></font>
 <font></font>
    <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>,<font></font>
         application: <span class="hljs-type">XCUIApplication</span>,<font></font>
         source: <span class="hljs-type">Source</span>) {
        <span class="hljs-keyword">self</span>.source = source
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(pageObjectsFactory: pageObjectsFactory, application: application)<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-comment">//  BasePageObject   ,      </span>
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>, application: <span class="hljs-type">XCUIApplication</span>) {
        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"init(pageObjectsFactory:application:) has not been implemented. Use another init"</span>)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La inicializaci√≥n del objeto de p√°gina gen√©rico en la f√°brica se ver√° as√≠:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageObjectsFactory</span> </span>{<font></font>
    ‚Ä¶<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeAlertPageObject</span>&lt;Source: BasePageObject&gt;<span class="hljs-params">(
        from source: Source
    )</span></span> -&gt; <span class="hljs-type">AlertPageObject</span>&lt;<span class="hljs-type">Source</span>&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-type">AlertPageObject</span>(pageObjectsFactory: <span class="hljs-keyword">self</span>,<font></font>
                                          application: application,<font></font>
                                          source: source)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ta-daa! </font><font style="vertical-align: inherit;">Todo est√° listo, y ahora podemos continuar la prueba sin romper la cadena de llamadas.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleSourcesTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleSource</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy()<font></font>
            .openAlert()<font></font>
            .dismissAlert()<font></font>
            .checkVacancyScreenIsOpened() <span class="hljs-comment">//       ,         </span><font></font>
        ‚Ä¶<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gn/rt/hs/gnrthsrb0jerc7jtimpsmfqeryw.jpeg" width="70%"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enorme objeto de p√°gina, c√≥mo entenderlo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay pantallas (aunque las hay), que alojan una gran cantidad de contenido diferente, varios elementos de interfaz, bloques l√≥gicos individuales. Al mismo tiempo, todos est√°n en la misma pantalla, y quiero interactuar con ellos a trav√©s del objeto de p√°gina, que describe esta pantalla.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, tome la pantalla principal de nuestra aplicaci√≥n m√≥vil.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/2a/bc/v8/2abcv8sw0r9idx5m53mrj7hcf8u.jpeg" width="40%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta pantalla se puede dividir en tres secciones completamente independientes: la barra de b√∫squeda, el bloque de historial de b√∫squeda y las pesta√±as con listados de trabajo. Ser√≠a posible describir todo en una p√°gina objeto-e (despu√©s de todo, esta es una pantalla completa completa), pero no ser√° muy conveniente usarlo, ya que cada secci√≥n tiene su propia l√≥gica, sus propios controles, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, al expandir los objetos de la p√°gina, tarde o temprano, surge el problema de los nombres de los m√©todos. Como resultado, hay muchas celdas diferentes, t√≠tulos, subt√≠tulos, etc., en lugar de nombres simples, debe dar unos largos, con aclaraciones sobre qu√© se relacionan exactamente. Escribir ex√°menes se vuelve muy inconveniente y dif√≠cil. Cada vez que selecciona un m√©todo en la prueba, debe abrir el c√≥digo objeto de la p√°gina y profundizarlo cuidadosamente para no cometer un error.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyListPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertHistoryListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertHistoryListCellByTitleExists</span><span class="hljs-params">(title: String)</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertRecommendationsListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertVacancyNearbyListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }<font></font>
    ‚Ä¶  <font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/ia/_g/zwia_gz_wjygrw7tpmis1_gnx8q.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La soluci√≥n m√°s simple es no ver el problema. No importa cu√°n grande sea el objeto de la p√°gina, a√∫n puede usarlo (especialmente si se acostumbra). Pero no quiero acostumbrarme a eso, pero quiero que sea hermoso y c√≥modo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, estas "secciones" pueden ser m√≥dulos diferentes en el c√≥digo, lo que significa que pueden reutilizarse en diferentes pantallas de la aplicaci√≥n. Si construimos una arquitectura similar con objetos de p√°gina, tambi√©n podemos reutilizarlos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tomamos una decisi√≥n decidida: ahora, para tales secciones, estamos escribiendo diferentes clases de objetos de p√°gina. A cada uno de ellos agregamos correspondencia al protocolo MainScreenSection vac√≠o unificador: BasePageObject {}. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, tome la secci√≥n del historial de b√∫squeda en la pantalla principal. Su objeto de p√°gina se ver√° as√≠:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchHistoryPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">MainScreenSection</span> </span>{
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
B√°sicamente, el objeto de p√°gina de MainScreenPageObject, que describe la pantalla principal, creamos un m√©todo por el cual decimos de la prueba en qu√© secci√≥n vamos a hacer algo ahora. </font><font style="vertical-align: inherit;">Se parece a esto.&nbsp;</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainScreenPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span> </span>{<font></font>
    ‚Ä¶<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">section</span>&lt;Section: MainScreenSection&gt;<span class="hljs-params">(<span class="hljs-number">_</span> section: Section.<span class="hljs-keyword">Type</span>)</span></span> -&gt; <span class="hljs-type">Section</span> {
        <span class="hljs-keyword">return</span> section.<span class="hljs-keyword">init</span>(pageObjectsFactory: pageObjectsFactory, application: application)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este m√©todo, pasamos el tipo de secci√≥n, en el interior inicializamos el objeto de p√°gina utilizando el m√©todo gen√©rico de f√°brica.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, obtuvimos una prueba ininterrumpida, la falta de inicializaciones innecesarias de grandes objetos de p√°gina y la legibilidad del c√≥digo.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//        ‚Äú ‚Äù</span>
    .openSearchTab() <span class="hljs-comment">//   MainScreenPageObject</span>
    .section(<span class="hljs-type">SearchHistoryPageObject</span>.<span class="hljs-keyword">self</span>) <span class="hljs-comment">//     </span>
    .waitHistoryIsLoad() <span class="hljs-comment">//   page object-  </span>
    .section(<span class="hljs-type">MainScreenPageObject</span>.<span class="hljs-keyword">self</span>) <span class="hljs-comment">//       </span>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumir</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede escribir pruebas autom√°ticas sin una f√°brica de objetos de p√°gina. Los objetos de p√°gina con este enfoque se escriben de manera muy r√°pida y sencilla, especialmente si no necesitan una inicializaci√≥n compleja. Pero, por otro lado, al escribir una prueba, debe ser extremadamente cuidadoso. La responsabilidad de la secuencia de pasos en la prueba, la inicializaci√≥n de los objetos de la p√°gina, la falta de una envoltura sobre algunas acciones, etc. recae en el probador. Si su aplicaci√≥n no es muy complicada, puede que no valga la pena complicarse, y todos los problemas enumerados ser√°n generalmente invisibles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si, al principio, se sienta un poco sobre la creaci√≥n de la f√°brica, en el futuro, en primer lugar, asumir√° todas las responsabilidades anteriores y, en segundo lugar, har√° que el proceso de redacci√≥n de autotests sea muy simple y casi sin posibilidad de error.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/uc/i6/ta/uci6takmotdv_r0ujdl5kbv3_3a.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que no existe una √∫nica decisi√≥n correcta, depende de usted decidir. </font><font style="vertical-align: inherit;">Continuamos usando ambos enfoques, y todos est√°n c√≥modos y bien. </font><font style="vertical-align: inherit;">¬°Buena suerte y hermosas autotestas!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlaces √∫tiles:</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Art√≠culo sobre el patr√≥n de objeto de p√°gina</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buen art√≠culo sobre el papel de la arquitectura en la automatizaci√≥n</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotlin DSL, accesorios y elegantes pruebas de IU en Android</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interfaces, protocolos y extensiones / Swift vs. </font><font style="vertical-align: inherit;">Kotlin</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El poder de los gen√©ricos en Swift</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es507032/index.html">Libro "Vende tu cartera. Lo que no se ense√±a en las escuelas de dise√±o "</a></li>
<li><a href="../es507034/index.html">Int√©rprete de Webstorm NodeJs del contenedor Docker</a></li>
<li><a href="../es507040/index.html">C√≥mo reducir el registro de da√±os bajo el seguro obligatorio de responsabilidad civil del motor de unos pocos d√≠as a 60 minutos</a></li>
<li><a href="../es507042/index.html">Quiero gamedev: 27 respuestas de 8 profesionales</a></li>
<li><a href="../es507044/index.html">La placa m√°s econ√≥mica para experimentar con SoC'om MCU y FPGA</a></li>
<li><a href="../es507050/index.html">An√°lisis del dise√±o del juego Hollow Knight. Parte 1. Encrucijada olvidada</a></li>
<li><a href="../es507052/index.html">El mejor cient√≠fico de datos no pierde el tiempo en estad√≠sticas</a></li>
<li><a href="../es507058/index.html">Joel Spolsky: papel de la gamificaci√≥n en el √©xito del desbordamiento de pila</a></li>
<li><a href="../es507066/index.html">10 maneras de automatizar anuncios en Google Ads</a></li>
<li><a href="../es507068/index.html">Gu√≠a de instrumentaci√≥n de administraci√≥n de Windows (WMI): comprensi√≥n de los ataques de WMI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>