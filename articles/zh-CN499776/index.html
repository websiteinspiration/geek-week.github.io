<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏸️ 🎱 🆙 MSH语言实现的功能 🅱️ 🙆🏾 👶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我继续有关MSH编程语言的系列文章。在上一篇文章中，我已经描述了这种语言的规范。但是该规范并未揭示语言的所有功能。我想通过这篇文章消除这种差距。当然，我没有设法描述所有内容，但是基本上我描述了主要功能。我们将把其余的推迟到更好的时候。
 
 当语言的形象刚刚成形时，似乎一切都是合乎逻辑且一致的。但是...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>MSH语言实现的功能</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499776/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我继续有关MSH编程语言的系列文章。</font><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上一篇文章中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我已经描述了这种语言的规范。</font><font style="vertical-align: inherit;">但是该规范并未揭示语言的所有功能。</font><font style="vertical-align: inherit;">我想通过这篇文章消除这种差距。</font><font style="vertical-align: inherit;">当然，我没有设法描述所有内容，但是基本上我描述了主要功能。</font><font style="vertical-align: inherit;">我们将把其余的推迟到更好的时候。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当语言的形象刚刚成形时，似乎一切都是合乎逻辑且一致的。</font><font style="vertical-align: inherit;">但是在实现语言的入口处，必须通过选择一种或另一种策略来解决问题。</font><font style="vertical-align: inherit;">现在，语言解释器已经准备就绪，您可以看到它如何解决一个或另一个实现问题。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSH编程语言概念</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
介绍2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
程序的组织。 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
运行时。 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据管理。 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据本地化。 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
速记语法。 5个</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 常数。 5 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 一些团队的功能。 5 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 CONSTANT命令。 5 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 XECUTE命令。 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 命令COPY和MOVE。 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 资源同步。 7 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 SET命令的缩写形式。 8个</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 团队。 8 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 IF命令。 8 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 CASE命令。 9 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 WHILE命令。 10个</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 块循环迭代器。 10 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 NEXT队。 11 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 BACK命令。 12 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 查询团队。 12 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 非块命令数据树遍历命令。 12 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 NEXT1队。 12 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 命令BACK1。十三</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 查询团队1。</font><font style="vertical-align: inherit;">13 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 程序执行管理。</font><font style="vertical-align: inherit;">13 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 传递参数。</font><font style="vertical-align: inherit;">14 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 事件处理。</font><font style="vertical-align: inherit;">15 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 EVENTTRAP命令。</font><font style="vertical-align: inherit;">15 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 队伍EVENTDELETE。</font><font style="vertical-align: inherit;">16 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 EVENTCALL团队。</font><font style="vertical-align: inherit;">16 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 EVENTWAIT团队。</font><font style="vertical-align: inherit;">16个</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 向量。</font><font style="vertical-align: inherit;">16 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 64位向量。</font><font style="vertical-align: inherit;">16 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 32位向量。</font><font style="vertical-align: inherit;">17 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 16位向量。</font><font style="vertical-align: inherit;">17 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 8位向量。</font><font style="vertical-align: inherit;">17 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 操作。</font><font style="vertical-align: inherit;">17个</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 对象。</font><font style="vertical-align: inherit;">18 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 对象的继承。</font><font style="vertical-align: inherit;">19 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 交换文件。</font><font style="vertical-align: inherit;">20 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 结论。</font><font style="vertical-align: inherit;">二十</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSH语言建立在MUMPS语言的概念之上。 MUMPS是上个世纪开发的鲜为人知的语言。但是它仍然用于信息应用程序中。有关该语言的信息可在Internet上找到。有此语言的有效实现，并且有一群程序员支持它。 MUMPS正在美国和俄罗斯开发。另外，据我所知，它在拉丁美洲，德国，澳大利亚和中国使用。一般来说，这种生活语言的概念。与MUMPS会面时，其古老的性质令人震惊。此开发旨在消除其缺点，同时保留其优势，简单性，一致性和数据组织性。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
程序的组织。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
翻译单元是MSH语言模块。该模块从标识语言版本的标准8字节开始。该行的开头可能是一个标签或空格。标签以“：”结尾，并且与其余命令之间用任意数量的空格隔开。行由命令组成。团队结束的标志是符号“;”。该命令与参数用空格分隔。字符的大小写无关紧要。该命令可以用任何寄存器的字符编写。此外，许多团队都有缩写形式。命令可能具有执行条件。如果有一个，则符号“？”跟随命令而没有空格以及执行此命令的条件。如果执行命令的条件不等于0，则执行命令。在条件内部，不允许使用空格，否则它们将作为命令和参数之间的分隔符进行处理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET？[5]&gt; 5 Val [1] = 25; </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// </font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确</font><b><font style="vertical-align: inherit;">吗？[2]&gt; 5 Val [1] = 25; </font></b><font style="vertical-align: inherit;">//语法错误</font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET？（[1,2]&gt; 5）Val [1] = 25; </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//正确地，内部（）空格是允许的，</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
参数之间用符号“，”分隔。</font><font style="vertical-align: inherit;">在参数内部，空格不是特殊字符，可以包含在任何位置。</font><font style="vertical-align: inherit;">通常，命令可以具有任意数量的参数。</font><font style="vertical-align: inherit;">模块中的标签位于模块内部，并且在模块中必须唯一（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令中的标签除外）</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该命令</font><font style="vertical-align: inherit;">内部本地化</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令的标签</font><font style="vertical-align: inherit;">应仅在此命令内部唯一，并且可以在此命令外部和嵌套</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令中重复使用</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在运行时，该应用程序具有一个或多个任务。</font><font style="vertical-align: inherit;">所有任务并行执行。</font><font style="vertical-align: inherit;">在每个任务中，程序都按顺序执行。</font><font style="vertical-align: inherit;">在每个时间点，任务中仅执行一个程序代码。</font><font style="vertical-align: inherit;">该任务以最后运行的程序的结尾结束。</font><font style="vertical-align: inherit;">主要任务由语言运行时启动。</font><font style="vertical-align: inherit;">剩余的作业由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Job</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令生成</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据管理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于那些熟悉MUMPS语言的人来说，MSH中的数据组织非常清楚。 MSH中没有数据描述。没有数据声明。数据可以存储为树，然后通过可选的名称和索引执行对树节点的访问。索引括在方括号[]中。名字在他们前面。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET Pr [4,5，“ rt”] =是[“ ty ^ 578”]; </font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Pr</font></b><font style="vertical-align: inherit;">和</font><b><font style="vertical-align: inherit;">Is</font></b></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在这里</font><b><font style="vertical-align: inherit;">是</font></b><font style="vertical-align: inherit;">树</font><b><font style="vertical-align: inherit;">的</font></b><font style="vertical-align: inherit;">名称。</font><b><font style="vertical-align: inherit;">4,5，“ rt”</font></b><font style="vertical-align: inherit;">和</font><b><font style="vertical-align: inherit;">“ ty ^ 578”</font></b><font style="vertical-align: inherit;">是节点索引。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该树可以具有任意数量的级别，因此，索引具有以逗号分隔的相应字段数。索引字段可以具有基本类型的任意值。 MSH中的基本类型是数字和字符串。仅将进行记录的节点直接存储在树中。名称，索引字段和索引本身可以是表达式。计算后，该名称只能是一个标识符。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同样，数据可以存储为连续数组，然后对数组元素的访问包括一个可选的符号名称“ $”和一个索引。索引是整数。最小的数组索引是1。名称和索引可以是表达式。计算后，名称只能是标识符，而索引只能是整数。数组可以按任何顺序填充，但是如果您写</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mc $ 1000</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后将创建一个</font><font style="vertical-align: inherit;">包含</font><b><font style="vertical-align: inherit;">1000个</font></b><font style="vertical-align: inherit;">元素</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">未定义的元素将不包含值，但它们将存在。</font><font style="vertical-align: inherit;">数组中元素的数量可以通过引用该数组的零元素来找到。</font><font style="vertical-align: inherit;">
例如：</font><b><font style="vertical-align: inherit;">mc $ 0</font></b><font style="vertical-align: inherit;"> 
可以通过向该元素写入新的数组长度来更改数组</font><b><font style="vertical-align: inherit;">的</font></b><font style="vertical-align: inherit;">大小。</font><font style="vertical-align: inherit;">但是在一般情况下，这是没有必要的，因为数组会自动扩展。</font><font style="vertical-align: inherit;">
树节点和数组元素包含基本类型的数据。</font><font style="vertical-align: inherit;">这些是字符串或数字。</font><font style="vertical-align: inherit;">不关心程序员数据的存储方式。</font><font style="vertical-align: inherit;">数据类型的存储及其操作是MSH语言实现的职责。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据本地化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSH数据分为全局和本地。它们的名称类型不同。全局数据存储在长期内存中，并且不依赖于应用程序的生存期。创建它们后，它们可以由应用程序更改，并且将一直存在，直到应用程序使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KILL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令销毁它们为止</font><font style="vertical-align: inherit;">。所有全局数据名称中均带有前缀“ ^”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过各种任务可以同时访问全局数据。因此，在访问全局变量时，必须进行同步。这种同步总是自动的。全局描述符中始终有一个同步原语，它控制对全局的访问。此外，在读取全局变量时，通过读取阻止，而在写入全局变量时，则通过写入阻止。不需要其他全局同步。对全局数组的访问也将同步。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">^ gl [87,9]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -访问全局树节点。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">^ glar $ 45-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问全局数组的元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本地数据仅在应用程序运行时存在。下一次启动的应用程序无法访问上一次启动的本地数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本地数据的范围取决于其类型。有三种类型的数据本地化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.本地程序数据。它们位于程序内部，并且从程序启动到完成一直存在。如果程序调用该子例程，则将创建新的子例程数据，并且该子例程内部的本地程序数据不可见。当您返回程序时，本地程序数据将再次变为可用。本地程序数据没有名称。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[7,9]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -访问位于程序内部的树的节点。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ 5-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问位于程序内部的数组元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一个例外。传递给</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A $</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序</font><font style="vertical-align: inherit;">的参数数组</font><font style="vertical-align: inherit;">也位于程序内部。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.本地应用程序数据。它们在应用程序的所有任务中可见。您可以通过任何任务与他们联系。它们从通过任何任务在应用程序中创建的那一刻起存在，直到应用程序完成或被</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KILL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">团队销毁为止</font><font style="vertical-align: inherit;">。此类数据的名称以“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">为前缀</font><font style="vertical-align: inherit;">。这些变量可同时在不同任务中使用，因此它们与全局变量一样同步。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％dapp [87.9]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -访问位于应用程序内部的树的节点。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％dapp $ 45-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问位于应用程序内部的数组元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.本地作业数据。</font><font style="vertical-align: inherit;">它们位于任务内部，并且从它们在任何任务程序中创建之日起一直存在，直到任务由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KILL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">团队完成或销毁为止</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此类数据必须具有名称，并且不包含前缀“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">^</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”和“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”。</font><font style="vertical-align: inherit;">程序参数数组</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A $</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font><b><font style="vertical-align: inherit;">一个</font></b><font style="vertical-align: inherit;">例外</font><font style="vertical-align: inherit;">，它位于程序内部，</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">djob [87,9]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -访问位于任务内部的树的节点。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">djob $ 45-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问位于作业内部的数组元素。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
访问变量只能具有此处列出的类型。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速记语法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该术语与MUMPS语言中的相似术语无关。 MSH中的缩写语法用于指代整个树或整个数组。它仅在单独的团队中使用，并且始终在允许的地方进行协商。对整棵树的吸引力包括名称和必需的方括号。没有为本地程序树指定名称。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">us []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -访问整个us树。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -访问本地程序树。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对整个数组的访问由名称和必需的字符“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”组成。没有为程序的本地数组提供名称。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">us $</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -访问整个us数组。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -访问本地程序数组。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本数据类型可以是数字或字符串。</font><font style="vertical-align: inherit;">在存在小数点的情况下，数字形式可以是整数或实数。</font><font style="vertical-align: inherit;">数字的底数是10。它们可以是正数或负数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
25，-4、789.56，-9.3 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
字符串常量是任何字符序列。</font><font style="vertical-align: inherit;">如果常量仅由字母和数字组成，则不能将其用引号引起来，因为它不能与变量混淆。</font><font style="vertical-align: inherit;">如果常量包含其他字符，则必须将其用单引号或双引号引起来。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“ rt @ tty＃123” </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
'14“ 5 * 7” 89 \？' </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
125Dsv</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一些团队的特点</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恒大团队</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CONSTANT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令为</font><b><font style="vertical-align: inherit;">常量</font></b><font style="vertical-align: inherit;">命名</font><font style="vertical-align: inherit;">。这些是广播时间名称。广播将其替换为它们的值。在运行时，这些名称不再存在。因此，</font><font style="vertical-align: inherit;">您不能</font><font style="vertical-align: inherit;">在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CONSTANT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令中将</font><font style="vertical-align: inherit;">表达式分配给名称。该值必须正好是一个常数。必须选择常量的名称，以使其与不带引号的程序中指定的常量的值不一致。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
常数ioInOut =“ /ini/par.ini&gt;,maxIs=25; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ioInOut和maxIs常量被分配了值。此外，在程序中，可以使用这些名称代替这些值。</font><b><font style="vertical-align: inherit;">不断的</font></b></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
团队</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它有2种形式。</font><font style="vertical-align: inherit;">在这种情况下，等式的右边不存在。</font><font style="vertical-align: inherit;">这个团队的含义是不同的。</font><font style="vertical-align: inherit;">名称是包含常量的模块的名称。</font><font style="vertical-align: inherit;">该模块的常量将导出到当前模块。</font><font style="vertical-align: inherit;">模块导入常量不包含有关导入的任何其他描述。</font><font style="vertical-align: inherit;">导入模块只能包含常量和程序。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CONSTANT sysCnsNet，usrCnsByx; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sysCnsNet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usrCnsByx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是包含常量的模块名称。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
两种形式都可以作为单个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CONSTANT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令的参数出现</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XECUTE团队</font></font></h4><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XECUTE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令</font><b><font style="vertical-align: inherit;">是一个</font></b><font style="vertical-align: inherit;">比较特殊的团队，但是它以MUMPS语言提供。在其他编程语言中，她只在JavaScript中遇到了我。那里被称为评估。执行该命令时，将计算该命令的自变量表达式，然后将该表达式转换为字符串，解释为MSH命令并执行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XECUTE“ SET $ 1 = 89;”;</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
结果，变量</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ 1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将接收值</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">89</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个原始示例，以这种形式使用此命令几乎没有任何意义。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XECUTE命令</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的参数</font><font style="vertical-align: inherit;">是表达式，使您可以在程序</font><b><font style="vertical-align: inherit;">运行</font></b><font style="vertical-align: inherit;">时生成各种MSH命令。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在命令所在的程序的上下文中执行该命令。</font><font style="vertical-align: inherit;">她可以使用所有程序资源，包括本地程序数据。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COPY和MOVE命令</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COPY命令是</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类似于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MERGE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流行性腮腺炎</font><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这些命令将源节点以及所有后代复制到接收者节点。</font><font style="vertical-align: inherit;">这些命令的参数由两个字段组成，用符号“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">分隔</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此标记的右侧是源节点，左侧是接收方。</font><font style="vertical-align: inherit;">允许使用缩写链接作为节点，在这种情况下，将使用整个树。</font><font style="vertical-align: inherit;">这些命令不仅复制后代，还复制节点本身。</font><font style="vertical-align: inherit;">该</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COPY命令</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行数据合并。</font><font style="vertical-align: inherit;">源数据被复制到接收器而不进行清洗。</font><font style="vertical-align: inherit;">来源没有改变。</font><b><font style="vertical-align: inherit;">MOVE</font></b><font style="vertical-align: inherit;">团队</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行实际的移动数据。</font><font style="vertical-align: inherit;">以前，清理接收器，然后复制源节点的所有后代，并删除源节点及其所有后代。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//将节点us [5,6]复制到节点[1] </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COPY [1] = us [5,6]; </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//将整个us树移动到节点[8] </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOVE [8] = us []; </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些命令也可以用于复制阵列。</font><font style="vertical-align: inherit;">在这种情况下，只有缩短的链接可以用作源和接收器。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
程序参数将复制到arg数组。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COPY arg $ = A $; </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以使用MOVE命令移动。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动a1 $ = b1 $; </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以复制和移动任何阵列。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源同步</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
执行多个任务时，有必要访问共享资源。同步由锁定命令执行。同步命令本身不会阻塞任何内容，这是一组协议，可以区分对共享资源的访问。如果未在作业之间共享锁定命令，则不会发生访问同步。同步建立在锁名上。这些名称在应用程序中本地化，并且在所有任务中都相同。在锁中，接受许多读者且一次只允许一个作家的概念。因此，存在读锁定和写锁定。</font><b><font style="vertical-align: inherit;">洛克</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
团队</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阻止读取名称。她的论点中列出的姓名将被阅读阻止。任意数量的任务都可以阻止相同的名称，但是尝试阻止任何这些名称的任务将等待所有这些名称被解锁。捕获写名称后，在写锁定释放名称之前，无法执行任何读锁定命令。如果无法锁定，该命令将等待释放名称。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LockR name1，name2，name3；</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
这些名称将被读取阻止。另一项任务也可以锁定这些名称，而不等待它们被解锁。</font><b><font style="vertical-align: inherit;">LockW</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按记录阻止名称。</font><font style="vertical-align: inherit;">她的论点中列出的姓名将被记录阻止。</font><font style="vertical-align: inherit;">如果参数中列出的名称已被任何lock命令阻止，则此命令将等待释放这些名称。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LockW name1，name2，name3；</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些名称将被记录锁定。</font><b><font style="vertical-align: inherit;">LockUn</font></b></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解锁</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该名称。</font><font style="vertical-align: inherit;">如果通过多次读取阻止了该名称，则需要解锁相同的次数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LockUn name1，name2，name3; </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
标准功能具有超时的这些命令的类似物。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET命令的缩写</font></font></h3><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令</font><font style="vertical-align: inherit;">具有缩写形式。</font><font style="vertical-align: inherit;">在这种情况下，等式的左侧不存在；其作用由表达式中提到的最后一个变量发挥。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET $ 1 = 2，$ 1 + 3; </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
变量</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ 1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将等于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果表达式中有多个变量，则结果将分配给最后一个变量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET $ 1 = 1，$ 2 = 2，$ 3 = 3，$ 1 + $ 2 + $ 3; </font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">$ 3</font></b></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
变量</font><font style="vertical-align: inherit;">将变为1 + 2 + 3 = 6。</font><font style="vertical-align: inherit;">尽管这种形式更适合仅在非常简单的情况下使用，类似于第一个示例。</font><font style="vertical-align: inherit;">提供第二个示例只是为了说明这种形式的</font><b><font style="vertical-align: inherit;">SET</font></b><font style="vertical-align: inherit;">命令的功能</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">块队</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
块命令形成命令块，并同时用作该块的标题。</font><font style="vertical-align: inherit;">即使块中只有一个命令，</font><font style="vertical-align: inherit;">每个块命令也必须具有自己的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">END</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中频团队</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果执行该命令的条件为真，则</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IF</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令</font><font style="vertical-align: inherit;">形成一个块。该命令没有参数。该块可能包含</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ELSE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ELSE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">没有参数。在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IF</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">块之外，</font><font style="vertical-align: inherit;">这些命令没有意义，因此无法应用。如果</font><font style="vertical-align: inherit;">满足</font><b><font style="vertical-align: inherit;">IF</font></b><font style="vertical-align: inherit;">命令的条件时，</font><b><font style="vertical-align: inherit;">如果</font></b><b><font style="vertical-align: inherit;">IF</font></b><font style="vertical-align: inherit;">块中</font><font style="vertical-align: inherit;">有</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ELSE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">，则</font><font style="vertical-align: inherit;">仅执行</font><b><font style="vertical-align: inherit;">IF</font></b><font style="vertical-align: inherit;">命令后面的命令，</font><font style="vertical-align: inherit;">直到下一个</font><b><font style="vertical-align: inherit;">ELSE</font></b><font style="vertical-align: inherit;">命令为止</font><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">ELSE</font></b><font style="vertical-align: inherit;">团队</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能包含一个执行条件，则在这种情况下为真时，仅执行位于该命令之后的命令，直到下一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ELSE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令或</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">END</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">为止</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IF</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">块</font><font style="vertical-align: inherit;">只能包含一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ELSE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令，</font><font style="vertical-align: inherit;">没有执行条件，并且它必须是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ELSE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令中的最后一个</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IF？[6] &lt;0; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET y [1] = 1; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">否[6] &lt;5; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET y [1] = 2; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">否[6] &lt;10; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET y [1] = 3; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他 </font><font style="vertical-align: inherit;">SET y [1] = 4; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结束 </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可能不存在执行该命令的条件，因此在任何情况下都将执行此块。</font><font style="vertical-align: inherit;">尽管很难想象为什么这可能有用。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">案例团队</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该命令的语义与其他MSH团队的语义有所不同。在其中执行命令的条件并非如此。在执行</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令的条件下，</font><font style="vertical-align: inherit;">表达式应计算将控制权转移到的标签。该命令没有参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该命令中的每个标签形成一个从该标签到下一个标签的块。当控制权转移到标签时，仅执行命令直到下一个标签，然后退出当前的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">块</font><font style="vertical-align: inherit;">。该命令更接近Pascal表示法，而不是C切换命令。如果作为计算标签名称的结果，发现当前</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">块中不存在名称，</font><font style="vertical-align: inherit;">则将执行</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">之后，第一个标签之前的</font><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CASE？L_ $ J; </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//评估标签</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET x [1] = 1; </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//如果未找到标签，则执行该块的命令</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET a [2] = x [1] +1; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1：SET x [1] = 2；</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//标签命令块L1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET a [2] = x [1] +2; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L2：SET x [1] = 3；</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//标签命令块L2 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET a [2] = x [1] +3; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结束 </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该命令中的标签隐式形成一个内部命令块。</font><font style="vertical-align: inherit;">在执行了此类命令块之后，控制权将转移到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令块之外</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WHILE命令</font></font></h4><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WHILE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令</font><font style="vertical-align: inherit;">用于组织循环。该命令的执行条件设置了继续循环的条件。只要执行命令的条件不为0，就将执行由该命令形成的块。该块以</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">END</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令结尾</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这样的块</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">END</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">具有功能。它可能具有块终止条件。如果条件不为0，则该块将完成。而且，这些条件可能同时出现在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WHILE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">END</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令中</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WHILE？X [7]&gt; 0;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> //继续循环的条件</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET y [2] = x [7] +2; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BREAK？是[2] &lt;0; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET x [7] = x [7] +1; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">END？X [7]&gt; 20;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> //结束循环的条件</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在块内部，可以通过BREAK命令中断循环。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">块循环迭代器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
块循环迭代器针对访问树节点进行了优化。他们使用内部链接来优化对旁路节点的访问。这对块迭代器的使用施加了限制。在块内部，您无法更改树的结构。您不能写这棵树。在块循环迭代器命令中，带有2个参数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一个参数是必需的，指向其后代将被绕过的节点的链接。参考索引。可以使用缩短的链接。第二个参数是到将存储后代索引的节点的链接。此参数是可选的。在块内部，第二个参数不应更改。</font><font style="vertical-align: inherit;">如果</font><b><font style="vertical-align: inherit;">$ 2</font></b><font style="vertical-align: inherit;">或</font><b><font style="vertical-align: inherit;">[3]，</font></b><b><font style="vertical-align: inherit;">则</font></b><font style="vertical-align: inherit;">不允许使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$$ 2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[[3]]之</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类的表达式</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在迭代器块内进行更改。</font><font style="vertical-align: inherit;">这些变量的更改将不被考虑。</font><font style="vertical-align: inherit;">可以通过</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％queryKey</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统变量</font><font style="vertical-align: inherit;">以及</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％queryData属性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的节点数据来</font><font style="vertical-align: inherit;">访问后代索引</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果一定不能从头开始绕过后代，则需要第二个参数，并且必须在其中放置节点索引，此后才开始绕过后代。</font><font style="vertical-align: inherit;">如果有第二个参数，但是您需要从头开始，那么在循环之前，您需要使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KILL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令删除此变量</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命令可能具有块执行条件。</font><font style="vertical-align: inherit;">进入该块后，仅检查一次此条件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您不仅可以遍历树的节点，还可以遍历数组。</font><font style="vertical-align: inherit;">在这种情况下，数组字段的序列号进入第二个参数。</font><font style="vertical-align: inherit;">只有缩短的链接可以用作第一个参数。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一队</font></font></h4><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEXT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令</font><b><font style="vertical-align: inherit;">遍历</font></b><font style="vertical-align: inherit;">树节点的直接后代。后代在从最小索引到最大索引的向前方向上付出代价。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEXT us [4,5];</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> //未指定2个参数，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//从系统变量％queryKey </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取索引</font><b><font style="vertical-align: inherit;">$ 1 =％queryKey，$ 2 =％queryData; </font></b></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">END？$ 1&gt; 1000;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> //结束循环</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
的</font><font style="vertical-align: inherit;">条件</font><font style="vertical-align: inherit;">节点索引立即放入数据</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KILL $ 1;中。</font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEXT我们[4,5]，$ 1；</font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET $ 2 =％queryData; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结束</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
缩写链接用作参考节点。在这种情况下，树的第一级被绕过。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">杀$ 1; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEXT us []，$ 1；</font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET $ 2 =％queryData; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结束</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
检索索引3。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET $ 1 = 3; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEXT我们[4,5]，$ 1；</font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET $ 2 =％queryData; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结束 </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当遍历数组时，所有字段都是按顺序排列的，即使未定义数据的字段也是如此。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KILL $ 1; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEXT我们$，$ 1; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET $ 2 =％queryData; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结束 </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在块内部，可以通过</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BREAK</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令中断循环</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BACK队</font></font></h4><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BACK</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令</font><font style="vertical-align: inherit;">与</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEXT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令的</font><font style="vertical-align: inherit;">区别</font><font style="vertical-align: inherit;">仅在于从最后一个顶点到第一个顶点的遍历方向。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KILL $ 1; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回我们[4,5]，$ 1；</font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET $ 2 =％queryData; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结束</font></font></b><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查询团队</font></font></h4><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QUERY</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令</font><font style="vertical-align: inherit;">在向前方向上从左到右以及从上到下遍历节点的所有后代到整个深度。</font><font style="vertical-align: inherit;">第二个参数包含整个可选索引。</font><font style="vertical-align: inherit;">如果该索引具有多个字段，则该列表将放置在第二个参数中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
否则，此命令类似于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEXT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">QUERY</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令</font><font style="vertical-align: inherit;">仅在从左到右的向前方向上</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遍历</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font><font style="vertical-align: inherit;">。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KILL $ 1; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
查询我们[4,5]，$ 1；</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 SET $ 2 =％queryData; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结束 </font></font><br>
</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是此命令仅绕过重要的顶点。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非块命令数据树遍历命令</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这些命令中，两个命令参数都是必需的。</font><font style="vertical-align: inherit;">第二个参数存储索引，之后下一条命令将找到下一个顶点。</font><font style="vertical-align: inherit;">在这些命令中，不会保存内部链接，因此对调整绕过的树没有任何限制。</font><font style="vertical-align: inherit;">由于相同的原因，到达峰的时间可能会更长。</font><font style="vertical-align: inherit;">也可以使用这些命令绕过阵列。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令NEXT1</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEXT1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供参考节点下同一级别的下一个节点。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
节点数据在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％queryData</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统变量中可用</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET $ 1 = 2; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NEXT1我们[1,4]，$ 1；</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//将给出位于节点us [1,4,2]之后的第3级的节点</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BACK1团队</font></font></h4><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BACK1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令</font><font style="vertical-align: inherit;">在参考节点下方的同一级别上提供先前的顶点。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
否则，它类似于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEXT1命令</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QUERY1小组</font></font></h4><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QUERY1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令</font><font style="vertical-align: inherit;">给出了树枝的下一个顶点，同时从上到下以及从左到右遍历整个节点。</font><font style="vertical-align: inherit;">第二个参数包含整个可选索引。</font><font style="vertical-align: inherit;">如果该索引具有多个字段，则该列表将放置在第二个参数中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
否则，它类似于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEXT1命令</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划管理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
模块标签可以是程序，函数的调用点，新任务的调用点，对象属性，对象方法和标签，这取决于对该标签的访问。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，可以在模块的不同部分以不同方式访问标签。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LB：设置Val [25] = 7 + A $ 1；返回值[25]; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做LB（78）;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> //访问程序。返回值将被忽略。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置Val [7] = 8 * LB（6）;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> //将返回值用作函数调用。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作LB（17，“ yt”）；</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> //调用新作业</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set Val [9] = Mod.LB（3）;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> //访问类方法Mod-在此上下文中，模块的名称被视为对象的类的名称。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置Val [15] = Obj [1,2，A] .LB;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> //访问对象Obj [1,2，A]的LB属性，</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">去LB;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> //转到LB标签</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在上面的示例中，除了4和5，该调用在当前模块内部执行。程序和功能的调用可以在任何可用模块上进行。顺便说一句，这也适用于围棋团队。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，在Mod模块中，有一个标签Lb。然后，它的吸引力将如下所示：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做Mod.Lb（78）; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
设置Val [7] = 8 * Mod.Lb（6）; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
设置Val [9] = Mod.Lb（3）; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JOB Mod.Lb（78）; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
去Mod.Lb;</font></font><br>
</b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，标签用作程序或功能。</font><font style="vertical-align: inherit;">如果模块用作对象类，则标签是此对象的属性或方法。</font><font style="vertical-align: inherit;">对象及其方法的属性是访问程序和函数的另一种形式，因此，有关程序和函数的所有说明均适用于属性和方法。</font><font style="vertical-align: inherit;">仅在继承方面访问对象时，没有任何细微差别。</font><font style="vertical-align: inherit;">此问题将在下面更详细地描述。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在一般情况下，模块的名称和对其的调用中的标签的名称均为表达式，可以在调用时进行计算。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置$ 1 =“ Md”，$ 2 =“ Lb”; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
做$ 1. $ 2; </font></font><br>
</b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
程序以</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Return</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令终止</font><b><font style="vertical-align: inherit;">；</font></b><font style="vertical-align: inherit;">可以使用</font><b><font style="vertical-align: inherit;">End</font></b><font style="vertical-align: inherit;">命令来完成一个模块</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">；</font></font></b><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传递参数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在MSH中，仅按值传递参数。通常，原则上不存在关于C ++语言的引用和指针，以及在此使用它们所带来的巨大问题。程序总是在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A $</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组中接受任意数量的参数</font><font style="vertical-align: inherit;">。它们的编号可以通过引用数组</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A $ 0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的0元素来找到</font><font style="vertical-align: inherit;">。程序员负责这些参数的含义。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们有一个Lb程序。可以解决：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DO Lb（1,2,7）; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DO Lb（25.7）; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DO Lb（）；</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作业磅（8）; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SET [7.8] = Lb（187，“公主”）；</font></font><br>
</b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
程序中未传递的参数未定义。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过值传递参数不会干扰将变量名称传递到程序中并在其中使用它们。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置我们[5] = 48; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
做Lb（“我们”）；</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
返回</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lb：设置面值[8,1,9] = A $ 1 [5];</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> // $ 1-传递的第一个参数包含</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
变量</font><font style="vertical-align: inherit;">名称</font><font style="vertical-align: inherit;">//：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">us</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[5]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -访问树的顶部</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//因此，节点值us [5] = 48 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Return;</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
结果，变量的名称可以被任意操纵。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用GO命令转到标签时，参数数组不会更改。</font><font style="vertical-align: inherit;">MSH具有GO命令格式，可以传输新参数。</font><font style="vertical-align: inherit;">在这种情况下，当前参数数组将替换为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令调用中指定的新参数数组</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GO Lb（1,2,7）;</font></font></b><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件处理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事件处理是一种强大的编程机制，通常不包含在高级语言中。但是它在库和操作系统中的存在说明了它的重要性。视觉组件库基于此机制构建。语言中事件处理的存在扩展了语言的功能。打开新的事件驱动的编程样式。顺便说一句，像Assembler这样受人尊敬的编程语言具有这样的功能。因此，此机制已被添加到MSH语言中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种机制的基础是事件。它位于应用程序内部。因此，这些名称在整个应用程序中必须是唯一的。如果事件名称与</font><b><font style="vertical-align: inherit;">CONSTANT</font></b><font style="vertical-align: inherit;">命令中声明的名称匹配</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么事件名称将被声明的常量的值替换。小心。在命名事件时，建议遵循某种命名策略。例如，分配以</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">evu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开头的事件名称</font><font style="vertical-align: inherit;">。考虑到UTF8编码，名称的长度不应超过18个字节。此限制仅与当前的语言实现有关。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在一个任务中创建的事件是可见的，可以在任何任务中进行处理。事件处理程序可以是任意数量，并且可以执行不同的任务。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事件发生后，将检查是否有该事件的处理程序；如果没有处理程序，则将事件删除。</font><font style="vertical-align: inherit;">如果有处理程序，则它们将按顺序执行。</font><font style="vertical-align: inherit;">事件可以是系统用户。</font><font style="vertical-align: inherit;">系统事件由系统生成。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVENTTRAP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令生成一个自定义事件</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该事件将参数传递给处理程序，就像调用程序时一样。</font><font style="vertical-align: inherit;">处理后，不会删除事件处理程序。</font><font style="vertical-align: inherit;">要删除事件，请使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVENTDELETE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">可以通过</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVENTCALL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVENTWAIT命令</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理事件</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVENTTRAP团队</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该命令创建一个自定义事件。</font><font style="vertical-align: inherit;">命令格式类似于程序调用，仅使用事件名称代替程序名称。</font><font style="vertical-align: inherit;">事件名称在应用程序中是本地的，因此它们在所有任务中都是可见的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小组将创建一个具有指定名称的事件。</font><font style="vertical-align: inherit;">将向事件处理程序传递命令参数中列出的参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVENTTRAP？X [1]&gt; 8 evuBoxData（我们[7]，$ 4），evuKorXY（我们[X]，我们[Y]，sh）；</font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">生成</font></b></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
2个事件</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">evuBoxData</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">evuKorXY</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为变量</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">us [7]，$ 4，us [X]，us [Y]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和字符串常量</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前没有此事件的处理程序，则不会生成该事件。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">活动团队</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该命令将删除程序参数中列出的事件处理程序。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVENTDELETE？X [1]&gt; 7 evuKorXY，evuBoxData; </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
活动将按照小组中的顺序删除。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">赛事团队</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该命令分配一个事件处理程序。</font><font style="vertical-align: inherit;">处理程序是程序。</font><font style="vertical-align: inherit;">该程序将从正在运行的任务中异步调用，并将参数传递给它。</font><font style="vertical-align: inherit;">执行处理程序后，控制权将返回到中断站点的主任务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVENTCALL evuBoxData = Mod1.intEvuBoxData，evuKorXY = Mod2.intevuKorXY;</font></font></b><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVENTWAIT团队</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
团队正在等待事件发生。</font><font style="vertical-align: inherit;">该命令将阻止当前任务，直到发生其参数中列出的事件为止。</font><font style="vertical-align: inherit;">它的参数中列出的所有事件都应发生，以继续执行当前线程。</font><font style="vertical-align: inherit;">当前的程序参数将替换为事件创建命令中传输的参数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVENTWAIT evuBoxData，evuKorXY; </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些命令使您可以组织程序的异步执行。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向量</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
向量与当前的实现紧密相关。</font><font style="vertical-align: inherit;">它们存储有符号和无符号整数。</font><font style="vertical-align: inherit;">这些向量的维数取决于向量分量的位深度，并且它是固定的。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64位向量</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样的向量的维数是2。组件可以是64位整数或无符号整数。</font><font style="vertical-align: inherit;">这样的数字存储在任何变量中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对向量的标志性整数分量的吸引力。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置我们[5]。％V64（0）= ss $ 1.％v64（1）; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％v64-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问向量的整数符号部分。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对向量的无符号整数分量的吸引力。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置我们[5]。％vu64（0）= ss $ 1.％vu64（1）; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％vu64-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问向量的整个无符号部分。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32位向量</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样的向量的维数是5。这些分量可以是32位整数或无符号整数。</font><font style="vertical-align: inherit;">这样的数字存储在任何变量中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对向量的标志性整数分量的吸引力。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置我们[5]。％V32（0）= ss $ 1.％v32（4）; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％v32-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问向量的整数符号部分。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对向量的无符号整数分量的吸引力。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置我们[5]。％vu32（0）= ss $ 1.％vu32（4）; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％vu32-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问向量的整个无符号部分。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16位向量</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样的向量的维数是11。这些分量可以是整数或无符号的16位数字。</font><font style="vertical-align: inherit;">这样的数字存储在任何变量中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对向量的标志性整数分量的吸引力。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置我们[5]。％V16（0）= ss $ 1.％v16（10）; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％v16-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问向量的整数符号部分。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对向量的无符号整数分量的吸引力。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置我们[5]。％Vu16（0）= SS $ 1.％vu16（4）; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％vu16-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问向量的无符号整数部分。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8位向量</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样的向量的维数是22。这些分量可以是整数或无符号的8位数字。</font><font style="vertical-align: inherit;">这样的数字存储在任何变量中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对向量的标志性整数分量的吸引力。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设为[5]。％V8（0）= ss $ 1.％v8（21）; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％v8-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问向量的整数符号部分。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对向量的无符号整数分量的吸引力。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置我们[5]。％vu8（0）= ss $ 1.％vu8（21）; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％vu8-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问向量的整个无符号部分。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运作方式</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSH中的操作扮演着特殊的角色。是他们控制数据类型的转换。根据操作的不同，操作数将转换为所需的数据类型。数据结果的类型唯一地对应于操作的类型。字符串和数字运算不重叠，就像C语言中的+运算一样。 MSH中的操作类型不取决于操作数的类型，所有情况都完全相反。 MSH中没有操作优先级；这是MUMPS的历史遗产。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET $ 1 = 2 + 3 * 4; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ 1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将为20，而不是14。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了使结果为14，将使用括号。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET $ 1 = 2 +（3 * 4）;</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
作为连接字符串的操作，使用符号“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
缺乏操作优先权的情况很少见，但很方便。</font><font style="vertical-align: inherit;">当操作多于累加时，提到优先级的自然性就​​变得非常令人怀疑。</font><font style="vertical-align: inherit;">一旦了解到没有优先级，就无需费劲地回忆一下它们的优先级，并且无需考虑文档中的内容。</font><font style="vertical-align: inherit;">通常，这是一个习惯问题。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现代编程语言中对象的存在是一种很好的形式。在一般情况下，对象由两部分组成。部分说明性描述和部分实现。在MUMPS系统中，变量不具有类型声明的声明部分。类基本上是用户数据类型。为了不违反MUMPS的原理，MSH缺少类描述的声明部分。事实证明，您可以完美地做到这一点。该类只剩下一部分实现。该类的实现可以由标准模块完美地表示。仅对于该类，必须引入与对象属性描述相关的其他约定。对象只能在树中。将对象放置在数组中将失败，因为没有地方可以存储对象的属性。尽管如果对象没有属性，则可以尝试。虽然是什么样的对象。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要描述一个公共属性，您需要一个返回该属性值的函数。它必须具有属性名称，并且在模块中具有类名称。写入属性的程序。该程序的属性名称以“。”为前缀。和财产清除计划。该程序的属性名称以“ ..”为前缀。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
模块中的功能名称可以对应于要读取的公共属性。在这种情况下，此类函数的返回值将作为公共属性的值传递给调用程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该类的构造函数是％objNew数据方法。如果在创建对象时需要确定任何属性或获取资源，则可以使用任何类模块程序（类方法）。但是建议坚持使用任何命名类构造函数的策略。例如，构造函数的名称必须与类的名称匹配。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过系统属性</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this可以</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问该类的受保护属性</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
析构函数是使用KILLD命令删除对象。如果您需要释放任何资源或执行其他操作，则可以通过此类的任何程序（类方法）来完成此操作。与构造函数的情况一样，建议在命名析构函数时遵循某种命名策略。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//类人</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//属性年龄</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//读取公共属性年龄</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">年龄：RETURN [％this，Age]; </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//公共财产</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Age.Age的记录：SET [％this，Age] = A $ 1; </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结束 </font></font><br>
</b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
程序对对象及其公共属性的吸引力如下所示。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//创建对象Person </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置我们[1,2]。％objNew = Person; </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//将值50写入Age属性</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET us [1,2] .Age = 50; </font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//读取Age </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font><b><font style="vertical-align: inherit;">u $ 1 = us [1,2] .Age + 5; </font></b></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//删除属性Age </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KILL us [1,2] .Age;</font></font></b><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象继承</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSH类支持多重继承。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PARENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">设置该类的所有祖先。此外，命令参数中此类祖先名称的顺序决定了继承的优先级。提及该类的时间越晚，其优先级就越低。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PARENT USER，BOX；</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
该类继承自</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USER</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BOX</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的祖先</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USER</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">祖先优先级</font><font style="vertical-align: inherit;">更高。优先级是什么。访问对象时，将在类本身中搜索类的公共属性或方法，如果在该类中找不到它们，则将在优先级最高的祖先中搜索它们，然后在该类的祖先中搜索它们，依此类推。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件共享</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在MSH中，文件共享是在最原始的级别进行组织的。 MSH中的文件起辅助作用。交换仅使用文本文件进行组织。文件结构是由指定的分隔符分隔的文本字段。定界符在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％dlmIO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统变量中</font><font style="vertical-align: inherit;">。默认情况下，该变量为“ </font><font style="vertical-align: inherit;">”。它可用于阅读和写作。写入文件时，变量将转换为字符串类型，并通过定界符写入文件。从文件读取时，变量通过分隔符进行选择，并被归一化。如果该字段是数字的记录，则将数字放置在变量中。通过数组</font><b><font style="vertical-align: inherit;">B $</font></b><font style="vertical-align: inherit;">与文件交换</font><font style="vertical-align: inherit;">。写入时，数组为</font><b><font style="vertical-align: inherit;">B $</font></b></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过定界符写入文件。</font><font style="vertical-align: inherit;">从文件读取时，这些字段将被选择到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B $</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> array中</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文件交换命令将文件路径作为参数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B $</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组将</font><font style="vertical-align: inherit;">数据写入文件。</font><font style="vertical-align: inherit;">通过写入打开文件。</font><font style="vertical-align: inherit;">文件中的数据将被替换。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写“ txt / tt1.txt”；</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据读入</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B $</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该阵列已预先清除。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读“ txt / tt1.txt”；</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
txt / tt1.txt-文件的路径。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文档不能替代MSH语言描述，而只是对其进行补充。</font><font style="vertical-align: inherit;">这里没有考虑MSH语言的所有功能，只有我想引起您注意的那些功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作者：Sharymov Mikhail Alekseevich。</font><font style="vertical-align: inherit;">电子邮件：misha_shar53@mail.ru </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用此材料时，需要链接到来源和作者。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN499762/index.html">升级DevSecOps的技能：5堂理论和实践网络研讨会</a></li>
<li><a href="../zh-CN499764/index.html">XYZPrinting 3D手动扫描仪2.0 3D扫描仪评论</a></li>
<li><a href="../zh-CN499770/index.html">自我隔离学习</a></li>
<li><a href="../zh-CN499772/index.html">将会非常非常：5G技术将如何改变广告市场</a></li>
<li><a href="../zh-CN499774/index.html">并非没有运动的一天-2：重新编程中国手镯</a></li>
<li><a href="../zh-CN499784/index.html">什么接触虚拟墙？</a></li>
<li><a href="../zh-CN499786/index.html">弱堆排序</a></li>
<li><a href="../zh-CN499788/index.html">免费在线课程“ IT项目中的技术文档”</a></li>
<li><a href="../zh-CN499792/index.html">负载测试Atlassian Jira，Confluence，Bitbucket第1部分</a></li>
<li><a href="../zh-CN499794/index.html">PostgreSQL和JDBC挤榨了所有果汁。弗拉基米尔·西特尼科夫</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>