<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🚒 ✌🏻 🧙🏾 测试人员使用的Python：小型C熊猫脚本如何帮助测试大型数据集 🧕🏼 🍶 🚚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我是一个项目的测试人员，其本质是收集和存储各种数据，并在此基础上形成各种报告和文件上传。在生成此类报告时，要考虑大量的数据选择条件，因此在测试时，您必须处理数据库中的SQL查询。但是，要验证数据的正确选择并搜索多余/丢失的数据，通常这是不够的，因此我不得不为此寻找其他工具。
 
 由于我已经掌握了一...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>测试人员使用的Python：小型C熊猫脚本如何帮助测试大型数据集</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486756/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我是一个项目的测试人员，其本质是收集和存储各种数据，并在此基础上形成各种报告和文件上传。</font><font style="vertical-align: inherit;">在生成此类报告时，要考虑大量的数据选择条件，因此在测试时，您必须处理数据库中的SQL查询。</font><font style="vertical-align: inherit;">但是，要验证数据的正确选择并搜索多余/丢失的数据，通常这是不够的，因此我不得不为此寻找其他工具。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我已经掌握了一些基本的python知识，因此我决定尝试编写一些小的脚本，使我可以对现有数据进行处理，从而促进并加快测试过程。</font><font style="vertical-align: inherit;">在本文中，我将告诉您它的来龙去脉。</font></font><br>
<a name="habracut"></a><br>
<b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设计脚本脚本</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要编写脚本，您需要弄清楚脚本应该做什么，需要输入什么数据以及希望输出什么数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该场景的样本步骤：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们得到一个包含某种格式数据的文件（或几个文件）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从一个或多个文件获取数据</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们选择必要的数据</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们对数据执行一些操作</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如有必要，我们会将数据上传到Excel文件中（通常，这种格式最方便进行进一步的分析和存储）</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，您需要考虑如何以及在何处获得输入。</font><font style="vertical-align: inherit;">它可以是带有数据的手动创建的文件，可以将数据上传到UI到带有过滤器的文件中，可以使用另一个脚本来解析数据的文件，可以将SQL查询结果上传到数据库的文件（您可以将数据从数据库快速上传到csv文件），json -file或xml-file，以及从响应到API请求等的数据。</font></font><br>
<br>
<b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用pandas和其他库在python中编写脚本</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编写脚本</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">，</font></a><font style="vertical-align: inherit;">您需要安装解释器和合适的IDE。</font><font style="vertical-align: inherit;">最好</font><font style="vertical-align: inherit;">为此项目</font><font style="vertical-align: inherit;">创建一个单独的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虚拟环境</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我为脚本使用了不同的库，其中一些是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内置的python库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，有些需要另外安装：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pandas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是用于数据分析的库。</font><font style="vertical-align: inherit;">它允许您处理来自各种格式文件的数据，以及使用SQL查询直接从数据库接收数据。</font><font style="vertical-align: inherit;">来自文件的数据被加载到数据框中（在视觉上与Excel中的表相同），并且数据已经可以执行不同的操作：类似于SQL中的join / union，将不同数据框中的数据组合在一起，选择所需的数据在某些条件下，比较数据帧不同列中的数据，等等。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">openpyxl，xlrd-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于Excel的库。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用于处理csv，json，Excel文件中数据的最简单脚本框架如下：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#   pandas</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
<span class="hljs-comment">#    csv-  -</span>
<span class="hljs-comment"># (        )</span>
<span class="hljs-comment">#       csv-     ";"</span>
df = pd.read_csv(<span class="hljs-string">'./csv_file.csv'</span>, sep=<span class="hljs-string">';'</span>, encoding=<span class="hljs-string">'utf-8'</span>)<font></font>
<font></font>
<span class="hljs-comment"># </span>
<span class="hljs-comment">#    json-  -</span>
<span class="hljs-comment"># (        )</span>
<span class="hljs-comment"># df = pd.read_json('./json_file.json', encoding='utf-8')</span><font></font>
<font></font>
<span class="hljs-comment"># </span>
<span class="hljs-comment">#    Excel-  -,     </span>
<span class="hljs-comment"># (        )</span>
<span class="hljs-comment"># file_excel = 'Excel_file.xlsx'</span>
<span class="hljs-comment"># df = pd.ExcelFile(file_excel).parse('1')</span><font></font>
<font></font>
<font></font>
<span class="hljs-comment">#  -     -  </span>
<span class="hljs-comment">#    - final_df</span><font></font>
<font></font>
<font></font>
<span class="hljs-comment">#    Excel-,  </span>
<span class="hljs-comment">#          </span>
<span class="hljs-comment"># (      )</span>
writer = pd.ExcelWriter(<span class="hljs-string">'.xlsx'</span>)<font></font>
final_df.to_excel(writer, <span class="hljs-string">'1'</span>)<font></font>
writer.save()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此脚本中，将所需格式文件中的数据加载到数据框中，选择了必需的数据并对其进行了一些操作，然后将数据写入新的Excel文件中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您需要处理通过SQL查询而获得的数据到数据库，则不能将它们导出到csv文件，而是可以通过在脚本本身中在数据库中执行SQL查询来立即将它们放入数据框：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#   pandas</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-comment">#      ,     PostgreSQL</span>
<span class="hljs-comment"># (   -    )</span>
<span class="hljs-keyword">import</span> psycopg2<font></font>
<font></font>
<span class="hljs-comment">#    </span>
conn = psycopg2.connect(dbname=<span class="hljs-string">'_'</span>, host=<span class="hljs-string">''</span>, port=<span class="hljs-string">''</span>,<font></font>
                        user=<span class="hljs-string">''</span>, password=<span class="hljs-string">''</span>)<font></font>
<font></font>
<span class="hljs-comment">#   SQL-</span>
q = <span class="hljs-string">"""select ... 
    from ... 
    where ..."""</span><font></font>
<font></font>
<span class="hljs-comment">#    -,  SQL-</span><font></font>
df = pd.read_sql_query(q, conn)<font></font>
<font></font>
<font></font>
<span class="hljs-comment">#  -     -  </span>
<span class="hljs-comment">#    - final_df</span><font></font>
<font></font>
<font></font>
<span class="hljs-comment">#    Excel-,  </span>
<span class="hljs-comment">#          </span>
<span class="hljs-comment"># (      )</span>
writer = pd.ExcelWriter(<span class="hljs-string">'.xlsx'</span>)<font></font>
final_df.to_excel(writer, <span class="hljs-string">'1'</span>)<font></font>
writer.save()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果需要从xml文件中获取数据，则可以使用为此设计的库。</font><font style="vertical-align: inherit;">我使用内置库</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ElementTree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当在一个数据帧中接收到数据时，您可以立即将其与另一个数据帧中的数据（SQL中的联接或联合的模拟）进行组合或对其执行一些操作，例如删除重复项，删除某些单元格中具有空值的行，比较多列中的数据，选择所需的行/列等。</font><font style="vertical-align: inherit;">在熊猫文档中阅读更多内容。</font></font><br>
<br>
<b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脚本使用选项</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们打开测试仪的主要工具，并选择项目中的数据/功能，以验证哪些脚本有用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为脚本创建了带有少量通过</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generateata生成</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的测试数据的文件</font><font style="vertical-align: inherit;">。实际上，数据文件包含数万行和大量列。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方案1：</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
有三个csv格式的文件，其中包含数据。对于每条数据线，都有一个带有唯一标识符ID的字段。考虑到某些条件从这些文件中选择数据，并将其输入数据库中的表中，然后将这些数据以UI上表的形式显示在报告中。可以将UI上的数据上传到Excel文件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设从源文件中选择报表数据的条件如下：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件可以按ID重复，在报表中，具有相同标识符的记录仅应考虑一次（在这种情况下，我们只需从数据中选择具有该标识符的任何行）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg_date列单元格中数据缺失的行不应计算在内。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，可能存在更多的选择条件，也可以将数据与系统中已有的数据进行比较，并且报告中仅显示ID相交的数据，但是例如，我们将仅考虑上述两个条件。</font></font></li>
</ul><br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试人员的任务：</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查是否从源文件中正确选择了带有必要对象的行，并且所有这些对象都显示在UI的报告中。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们为脚本编写一个脚本：</font></font></u><br>
<br>
<ul>
<li>  -      csv-,     - (   union  SQL),      id,       reg_date.</li>
<li>  UI     Excel-,   ,       -.</li>
<li> (merge)   -   (   outer join  SQL)          Excel-   .</li>
<li>              ,   ,   -   ,      ,   UI.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在最终文件中，如果不同数据帧中的列名称重合，则数据将仅包含具有ID的一列，并且可能不清楚来自哪个文件的列/行。</font><font style="vertical-align: inherit;">因此，我可以在文件中用不同的名称命名具有唯一标识符的列，或者在每个文件中添加一个单独的列“此类文件的行”并在其中添加“是”-然后，在分析生成的Excel文件时，方便地按此列进行过滤因为 </font><font style="vertical-align: inherit;">它们始终包含一个值，并且通过它们进行过滤，您已经可以了解相应列中哪些数据有所不同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从文件示例数据</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example1_csv_1.csv</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/of/5j/_u/of5j_us3u07uset3ljspbbwtrr4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
示例数据从</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">report_UI.xlsx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">：一个</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uh/xy/1s/uhxy1sygvioxbbhlksppdpsar_e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
python脚本如下所示：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#   pandas</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
<span class="hljs-comment">#     csv-    -</span>
<span class="hljs-comment"># (        )</span>
df_from_file1 = pd.read_csv(<span class="hljs-string">'./example1_csv_1.csv'</span>, sep=<span class="hljs-string">';'</span>, encoding=<span class="hljs-string">'utf-8'</span>,<font></font>
                            usecols=[<span class="hljs-string">'id'</span>, <span class="hljs-string">'name'</span>, <span class="hljs-string">'email'</span>, <span class="hljs-string">'reg_date'</span>])<font></font>
df_from_file2 = pd.read_csv(<span class="hljs-string">'./example1_csv_2.csv'</span>, sep=<span class="hljs-string">';'</span>, encoding=<span class="hljs-string">'utf-8'</span>,<font></font>
                            usecols=[<span class="hljs-string">'id'</span>, <span class="hljs-string">'name'</span>, <span class="hljs-string">'email'</span>,<span class="hljs-string">'reg_date'</span>])<font></font>
df_from_file3 = pd.read_csv(<span class="hljs-string">'./example1_csv_3.csv'</span>, sep=<span class="hljs-string">';'</span>, encoding=<span class="hljs-string">'utf-8'</span>,<font></font>
                            usecols=[<span class="hljs-string">'id'</span>, <span class="hljs-string">'name'</span>, <span class="hljs-string">'email'</span>, <span class="hljs-string">'reg_date'</span>])<font></font>
<font></font>
<span class="hljs-comment">#    -    - </span>
<span class="hljs-comment"># (   union  SQL)</span><font></font>
df_from_csv = pd.concat([df_from_file1, df_from_file2, df_from_file3]).\<font></font>
    reset_index(drop=<span class="hljs-literal">True</span>)<font></font>
print(df_from_csv)<font></font>
<font></font>
<span class="hljs-comment">#       </span>
df_from_csv.drop_duplicates(subset=<span class="hljs-string">'id'</span>, keep=<span class="hljs-string">'first'</span>, inplace=<span class="hljs-literal">True</span>)<font></font>
print(df_from_csv)<font></font>
<font></font>
<span class="hljs-comment">#     NaN ( )   reg_date</span><font></font>
df_from_csv = df_from_csv.dropna()<font></font>
print(df_from_csv)<font></font>
<font></font>
<span class="hljs-comment">#    Excel-   UI  -,</span>
<span class="hljs-comment">#       </span>
<span class="hljs-comment"># (        )</span>
file_excel = <span class="hljs-string">'report_UI.xlsx'</span>
df_from_excel = pd.ExcelFile(file_excel).parse(<span class="hljs-string">'1'</span>)<font></font>
print(df_from_excel)<font></font>
<font></font>
<span class="hljs-comment">#  -     - </span>
<span class="hljs-comment"># -       UI</span>
<span class="hljs-comment"># (   outer join  SQL)</span>
df = df_from_csv.merge(df_from_excel, left_on=<span class="hljs-string">'id'</span>, right_on=<span class="hljs-string">""</span>, how=<span class="hljs-string">'outer'</span>)<font></font>
print(df)<font></font>
<font></font>
<span class="hljs-comment">#     Excel-</span>
writer = pd.ExcelWriter(<span class="hljs-string">'.xlsx'</span>)<font></font>
df.to_excel(writer, <span class="hljs-string">'1'</span>)<font></font>
writer.save()<font></font>
</code></pre><br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">局限性：</font></font></u><br>
<br>
<ul>
<li>               (  ,       30 000 ).</li>
<li>   (  Excel)  /           ,            .</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方案2：</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
此部分以表格的形式包含来自单一来源的某些对象的数据。系统将从第二个来源（集成）接收数据，并使用此数据更新现有表数据。表中的每条记录都是具有唯一标识符的一个对象的数据。如果来自新源的按标识符的对象数据与现有对象的数据一致，那么将使用来自新源（已确认）的数据更新现有记录的所有字段。如果该表还没有带有来自第二个源的标识符的对象，则将使用来自新源的数据在表中创建一条新记录。来自第二个系统的数据可以提前上传到json文件。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试人员的任务：</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预先准备一个包含测试数据的文件，以验证是否正确更新了现有记录，并且如果标识符匹配则在数据库中将它们附加一个确认符号，并且正确创建了新记录，并且如果有这样的记录，则将它们标记为添加到数据库中标识符尚未。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们为脚本编写一个脚本：</font></font></u><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将数据从分区表上载到UI上的Excel文件中（如果不可能的话，您始终可以从代码中使用的SQL查询结果中导出数据，以将数据输出到UI上的该表中）并将其中的数据填充到第一个数据框中。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们从第二个来源获取带有数据的json文件，并将其加载到第二个数据帧中。</font></font></li>
<li>  (merge —    outer join  SQL)    -    -          Excel-,        .      ,        ,      .</li>
</ul><br>
<u>:</u><br>
<br>
<ul>
<li>               (  ,       30 000 ).</li>
<li>  json-     /  –           /,    -   json-   pandas        /.</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方案3</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
向系统API发出请求，以响应接收到json格式的对象数据。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试人员的任务：</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将来自对API的响应的响应数据与数据库中SQL查询结果的数据进行比较。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们为脚本编写一个脚本：</font></font></u><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在数据库中执行SQL查询，将查询结果中的数据导出到csv文件中，并将此数据加载到第一个数据帧中。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将响应请求的数据保存到json文件中的API，然后将文件中的数据加载到第二个数据帧中。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将两个接收到的数据帧中的数据（通过类比与SQL中的外部联接进行合并）通过唯一标识符组合成一个新数据帧，并将数据从其中卸载到Excel文件中，在该文件中，我们已经可以使用的功能按列比较数据电子表格</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或者可以使用熊猫比较常规数据框中列上的数据，同时将列中具有相同/不同数据的行卸载到新的数据框/ Excel文件中进行分析。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由实施例的数据</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example3_csv.csv</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zx/e6/xz/zxe6xzjff9vbfwgntsfqb-qyykc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如从数据</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example3_json.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="json hljs">[<font></font>
    {<font></font>
        <span class="hljs-attr">"id"</span>: <span class="hljs-string">"16421118-4116"</span>,
        <span class="hljs-attr">"name_json"</span>: <span class="hljs-string">"Tempor Consulting"</span>,
        <span class="hljs-attr">"email_json"</span>: <span class="hljs-string">"Nullam.lobortis.quam@***"</span>,
        <span class="hljs-attr">"tel_json"</span>: <span class="hljs-string">"1-821-805-****"</span>,
        <span class="hljs-attr">"reg_date_json"</span>: <span class="hljs-string">"12-11-16"</span>,
        <span class="hljs-attr">"city_json"</span>: <span class="hljs-string">"Natales"</span><font></font>
    },<font></font>
    {<font></font>
        <span class="hljs-attr">"id"</span>: <span class="hljs-string">"16040210-2206"</span>,
        <span class="hljs-attr">"name_json"</span>: <span class="hljs-string">"Odio Etiam Incorporated"</span>,
        <span class="hljs-attr">"email_json"</span>: <span class="hljs-string">"arcu@***"</span>,
        <span class="hljs-attr">"tel_json"</span>: <span class="hljs-string">"1-730-291-****"</span>,
        <span class="hljs-attr">"reg_date_json"</span>: <span class="hljs-string">"26-06-05"</span>,
        <span class="hljs-attr">"city_json"</span>: <span class="hljs-string">"Viddalba"</span><font></font>
    },<font></font>
...<font></font>
]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
python脚本如下所示：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#   pandas</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
<span class="hljs-comment">#    csv-  -</span>
<span class="hljs-comment"># (        )</span>
<span class="hljs-comment">#       csv-     ";"</span>
df_from_csv = pd.read_csv(<span class="hljs-string">'./example3_csv.csv'</span>, sep=<span class="hljs-string">';'</span>, encoding=<span class="hljs-string">'utf-8'</span>)<font></font>
print(df_from_csv)<font></font>
<font></font>
<span class="hljs-comment">#    json-  -</span>
<span class="hljs-comment"># (        )</span>
df_from_json = pd.read_json(<span class="hljs-string">'./example3_json.json'</span>, encoding=<span class="hljs-string">'utf-8'</span>)<font></font>
print(df_from_json)<font></font>
<font></font>
<span class="hljs-comment">#  -    -</span>
<span class="hljs-comment"># (   outer join  SQL)</span>
df_csv_json = df_from_csv.merge(df_from_json, left_on=<span class="hljs-string">'id'</span>, <font></font>
                                right_on=<span class="hljs-string">"id"</span>, how=<span class="hljs-string">'outer'</span>)<font></font>
print(df_csv_json)<font></font>
<font></font>
<span class="hljs-comment">#    Excel-,   ,</span>
<span class="hljs-comment">#      -   ,</span>
<span class="hljs-comment">#          </span>
<span class="hljs-comment"># (      )</span>
<span class="hljs-comment"># writer = pd.ExcelWriter('.xlsx')</span>
<span class="hljs-comment"># df_csv_json.to_excel(writer, '1')</span>
<span class="hljs-comment"># writer.save()</span><font></font>
<font></font>
<span class="hljs-comment">#       </span>
<span class="hljs-comment"># (, name_csv  name_json) </span>
<span class="hljs-comment">#       Excel-  </span>
<span class="hljs-comment"># (        )</span>
unequal_data_df = df_csv_json.loc[df_csv_json[<span class="hljs-string">'name_csv'</span>] != <font></font>
                                  df_csv_json[<span class="hljs-string">'name_json'</span>]]<font></font>
unequal_data_df = unequal_data_df[[<span class="hljs-string">'id'</span>, <span class="hljs-string">'name_csv'</span>, <span class="hljs-string">'name_json'</span>]]<font></font>
print(unequal_data_df)<font></font>
<font></font>
writer = pd.ExcelWriter(<span class="hljs-string">'_name.xlsx'</span>)<font></font>
unequal_data_df.to_excel(writer, <span class="hljs-string">'1'</span>)<font></font>
writer.save()<font></font>
<font></font>
</code></pre><br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">局限性：</font></font></u><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用行数非常多的文件时，您必须将它们分成单独的文件（在这里您需要尝试，我很少有超过30,000行的文件）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果json文件具有多层对象/数据数组嵌套，则将从内部级别将它们作为对象/数组加载到单元格中，因此，使用带有熊猫的json文件仅适用于没有过多嵌套对象的数据/数组。</font></font></li>
<li>       API         SQL-  ,             SQL-   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果对API请求的响应以xml格式出现，则您首先需要使用ElementTree或其他库从xml文件中解析必要的数据，然后将其加载到数据框中。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">场景4：</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在UI上下载了一个包含对象数据的xml文件，该文件是在某些条件下（例如，考虑对象的状态，日期，年份或其他参数值）从数据库中的数据即时生成的。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试人员的任务：</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将公司标签属性中xml文件中对象的唯一标识符id与数据库中SQL查询结果中的对象标识符进行比较。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们为脚本编写一个脚本：</font></font></u><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将响应请求的数据保存到xml文件中的API，使用ElementTree库从该文件中获取必要的数据，然后将数据加载到第一个数据帧中。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在数据库中执行SQL查询，将查询结果中的数据导出到csv文件中，并将此数据加载到第二个数据框中。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们通过唯一标识符将来自两个接收到的数据帧的数据（合并-与SQL中的外部联接类似）合并为一个新数据帧，并将数据从其中卸载到Excel文件中。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，打开结果文件并分析数据行。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从实例数据</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example4_csv.csv</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gb/zk/ou/gbzkou2bivh2gsnk6do0lthh1_g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如从数据</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example4_xml.xml</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">：一个</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zh/x4/no/zhx4noe3virrsagqnaduwpqyp_w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
python脚本如下所示：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#   ElementTree</span>
<span class="hljs-keyword">from</span> xml.etree <span class="hljs-keyword">import</span> ElementTree
<span class="hljs-comment">#   pandas</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
<span class="hljs-comment">#    xml-   </span>
<span class="hljs-comment"># (        )</span>
tree = ElementTree.parse(<span class="hljs-string">"example4_xml.xml"</span>)<font></font>
<font></font>
<span class="hljs-comment">#   </span><font></font>
root = tree.getroot()<font></font>
<font></font>
<span class="hljs-comment">#  ,     </span><font></font>
data_list = []<font></font>
i = <span class="hljs-number">1</span><font></font>
<font></font>
<span class="hljs-comment">#    -   id_type1  id_type2</span>
<span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> root.iter(<span class="hljs-string">"companies"</span>):
    <span class="hljs-keyword">for</span> child_1 <span class="hljs-keyword">in</span> child.iter(<span class="hljs-string">"company"</span>):<font></font>
            data_list.append({<span class="hljs-string">""</span>: i, <span class="hljs-string">"id"</span>: child_1.get(<span class="hljs-string">"id_type1"</span>)
                                                <span class="hljs-keyword">or</span> child_1.get(<span class="hljs-string">"id_type2"</span>), 
                              <span class="hljs-string">"  xml"</span>: <span class="hljs-string">""</span>})<font></font>
            i += <span class="hljs-number">1</span><font></font>
<font></font>
<span class="hljs-comment">#     data_list  -</span>
df_from_xml = pd.DataFrame.from_dict(data_list, orient=<span class="hljs-string">'columns'</span>)<font></font>
print(df_from_xml)<font></font>
<font></font>
<span class="hljs-comment">#    csv-  -</span>
df_from_csv = pd.read_csv(<span class="hljs-string">'./example4_csv.csv'</span>, sep=<span class="hljs-string">';'</span>, encoding=<span class="hljs-string">'utf-8'</span>)<font></font>
print(df_from_csv)<font></font>
<font></font>
<span class="hljs-comment">#  -   -</span>
<span class="hljs-comment"># (   outer join  SQL)</span>
df = df_from_csv.merge(df_from_xml, left_on=<span class="hljs-string">'id'</span>, right_on=<span class="hljs-string">"id"</span>, how=<span class="hljs-string">'outer'</span>)<font></font>
print(df)<font></font>
<font></font>
<span class="hljs-comment">#    Excel-</span>
<span class="hljs-comment">#          </span>
<span class="hljs-comment"># (      )</span>
writer = pd.ExcelWriter(<span class="hljs-string">'.xlsx'</span>)<font></font>
df.to_excel(writer, <span class="hljs-string">'1'</span>)<font></font>
writer.save()<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方案5</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在UI上，该部分以表的形式显示有关对象的数据。</font><font style="vertical-align: inherit;">可以将数据上传到Excel文件。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试人员的任务：</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将分区表中的数据与下载到Excel文件中的数据进行比较。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们为脚本编写一个脚本：</font></font></u><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们要求开发人员使用负责将数据输出到UI上的分区表的代码在数据库中进行SQL查询。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在数据库中执行此SQL查询，将数据上传到csv文件，然后将数据从其中加载到第一个数据帧中。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将数据从分区表上传到UI上的Excel文件，并将数据从其中加载到第二个数据框中。</font></font></li>
<li>  (merge —    outer join  SQL)    -    -          Excel-,             Excel.</li>
<li>      -     pandas,      /      -/Excel-  .</li>
</ul><br>
<u>:</u><br>
<br>
<ul>
<li>    ,     Excel-  UI, ,         ,          .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同样，类似的脚本可以简单地用于将数据从json文件或csv文件传输到Excel文件。</font><font style="vertical-align: inherit;">或者，您可以将某些列中的几个Excel文件中的数据合并，然后将它们上传到一个新的Excel文件中。</font></font><br>
<br>
<b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些只是如何使用python + pandas加快测试过程并查找错误的一些示例。</font><font style="vertical-align: inherit;">实际上，pandas有更多处理数据的机会，您可以在此库的文档中阅读有关此内容的更多信息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也许您的项目还有使用这些脚本的其他选项，本文将帮助您开始在测试人员的工作中使用它们。</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN486744/index.html">一款智能的国产姿势校正器开始销售。我们看了新产品-IBACK</a></li>
<li><a href="../zh-CN486746/index.html">写，不要剪。我在哈伯的出版物中开始想念的东西</a></li>
<li><a href="../zh-CN486750/index.html">系列“全人类”：从替代故事到废纸trash</a></li>
<li><a href="../zh-CN486752/index.html">使用ESP8266的独特WSGI Web服务器。第1部分</a></li>
<li><a href="../zh-CN486754/index.html">JIRA：及时准备好吃的软件的规则。TLDR 2：需求管理</a></li>
<li><a href="../zh-CN486760/index.html">安全周06：移动应用中的广告跟踪器</a></li>
<li><a href="../zh-CN486762/index.html">床头托管：家庭托管的令人毛骨悚然的做法</a></li>
<li><a href="../zh-CN486764/index.html">自己动手Schema.org：无需程序员即可自定义微布局</a></li>
<li><a href="../zh-CN486766/index.html">如何在旧式保理市场上在线转移所有交易？Sberbank保理业务的经验</a></li>
<li><a href="../zh-CN486768/index.html">修订Webasyst管理面板</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>