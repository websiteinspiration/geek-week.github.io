<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏾 👨🏿‍🎤 ✏️ 货架上的SwiftUI：动画。第1部分 🧑🏼 🧑🏽‍🤝‍🧑🏻 👨🏽‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，我碰到了一篇新鲜的文章，他们试图用SwiftUI重现一个有趣的概念。他们所做的是：
 
 
 
 我很感兴趣地研究了他们的代码，但是遇到了一些挫折。不，不是说他们做错了什么，一点也不没有。我只是没有从他们的代码中学到几乎没有新东西。它们的实现更多是关于合并而不是动画。然后，我决定构建自己的lu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>货架上的SwiftUI：动画。第1部分</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504198/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近，我碰到了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一篇</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新鲜的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">文章</font></a><font style="vertical-align: inherit;">，他们试图用SwiftUI重现一个有趣的概念。他们所做的是：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我很感兴趣地研究了他们的代码，但是遇到了一些挫折。不，不是说他们做错了什么，一点也不没有。我只是没有从他们的代码中学到几乎没有新东西。它们的实现更多是关于合并而不是动画。然后，我决定</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">构建自己的lunopark，</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以在</font><s><font style="vertical-align: inherit;">SwiftUI</font></s><font style="vertical-align: inherit;">中编写有关动画的文章，实现大致相同的概念，但是即使不是很有效，也要使用内置动画的100％功能。学习-直到结束。做实验-眨眼间:) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是我得到的：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，为了完全公开该主题，我不得不详细介绍一些基础知识。原来的文本很大，因此，我将其分为两篇文章。这是它的第一部分-而是有关动画的一般教程，与彩虹动画没有直接关系，我将在下一篇文章中详细讨论。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我将讨论基础知识，否则，您将很容易在更复杂的示例中感到困惑。很多东西，我会讲一下，在这种或那种形式，已经在英语文章中描述，如本系列（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">另一方面，我只专注于列举工作方式，而不是描述其工作原理。</font><font style="vertical-align: inherit;">和往常一样，我做了很多实验，所以我急于分享最有趣的结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
警告：猫下有很多图片和gif动画。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLDR</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该项目位于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github上</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您可以在TransitionRainbowView（）中看到彩虹动画的当前结果，但是我不会急于您的位置，但是我等待下一篇文章。</font><font style="vertical-align: inherit;">另外，在准备它时，我会梳理一下代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我们将仅讨论基础知识，并且仅影响Bases文件夹的内容。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我承认，我现在不打算写这篇文章。我有一个计划，根据这个计划，有关动画的文章应该连续第三甚至第四次。但是，我无法抗拒，我真的很想提供另一种观点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想马上预订。我不认为所提到的文章有任何错误，或者所使用的方法不正确。一点也不。它建立了过程（动画）的对象模型，该模型响应收到的信号开始执行某些操作。但是，对于我来说，本文很可能揭示了Combine框架的工作。是的，这个框架是SwiftUI的重要组成部分，但它更多的是关于反应式样式，而不是动画。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我的选择当然不是更优雅，更快，更容易维护。但是，它更好地揭示了SwiftUI的内幕，这的确是本文的目的-首先弄清楚。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如我在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">上一篇文章中</font></a><font style="vertical-align: inherit;">所说</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过SwiftUI，我立即开始使用SwiftUI进入移动开发领域，而忽略了UIKit。这当然有价格，但是有优势。根据旧宪章，我不是要住在新修道院里。老实说，我还没有任何租船合同，因此我不会拒绝新租船。这就是为什么在我看来，这篇文章不仅对像我这样的初学者有价值，而且对于那些已经以UIKit开发形式具有背景的研究SwiftUI的人也具有价值。在我看来，很多人都缺乏新鲜感。不要做同样的事情，试图在旧图纸中安装新工具，而要根据新的可能性改变视野。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们1c尼克以“受控形式”经历了这一过程。这是1年代世界中的一种SwiftUI，它发生于10多年前。实际上，这种类比非常准确，因为托管表单只是绘制界面的一种新方法。但是，他彻底改变了整个应用程序的客户端-服务器交互，尤其是在开发人员的脑海中。这并不容易，我本人不想研究大约5年，因为我认为那里切断的许多机会对我来说都是绝对必要的。但是，正如实践所示，在托管表单上编码不仅是可能的，而且是仅必要的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，让我们不再谈论它了。</font><font style="vertical-align: inherit;">我得到了详细，独立的指南，该指南没有任何参考，也没有与所提到的文章或1st过去的其他链接。</font><font style="vertical-align: inherit;">我们将逐步介绍细节，功能，原理和局限性。</font><font style="vertical-align: inherit;">走。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动画形状</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动画一般如何工作</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，动画的主要思想是将特定的，离散的变化转换为连续的过程。例如，圆的半径为100个单位，变为50个单位。如果没有动画，则更改将立即发生，并且带有动画-平滑。怎么运行的？很简单。为了平稳地进行更改，我们需要在``曾经是...已经成为''细分中内插几个值。对于半径，我们将必须绘制几个中间圆，其半径分别为98单位，95单位，90单位... 53单位，最后是50单位。 SwiftUI可以轻松自然地做到这一点，只需将执行此更改的代码包装在withAnimation {...}中。似乎很神奇……直到您想要实现比“ hello world”更复杂的东西。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们继续示例。动画的最简单和最易理解的对象被认为是形式的动画。 SwiftUI中的Shape（我仍然称其为符合shape form协议的结构）是一种结构，其参数可以适合这些边界。那些。它是具有功能主体的结构（以下简称：CGRect）-&gt;路径。绘制此形状的所有运行时所需的只是请求其轮廓（函数的结果是Path类型的对象，实际上是Bezier曲线）以获取所需大小（指定为函数参数，类型为CGRect的矩形）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
形状是存储的结构。通过对其进行初始化，您可以在参数中存储绘制轮廓所需的所有内容。可以更改此表单的选择大小，然后所需要做的就是为新的CGRect框架获取新的Path值，瞧。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们开始编码：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">Circle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.green)<font></font>
            .frame(height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habra"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.gray)<font></font>
                )<font></font>
<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
               .frame(height: <span class="hljs-number">200</span>)
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/pf/3j/eo/pf3jeo651jcwbhazddldv-rgxhy.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们有一个圆（Circle（）），可以使用滑块更改其半径。这顺利进行，因为滑块为我们提供了所有中间值。但是，当您单击“设置默认半径”按钮时，更改也不会立即发生，而是根据withAnimation（.linear（duration：1））指令进行。在没有加速的情况下线性拉伸1秒钟。类！我们掌握了动画！我们不同意:) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果我们想实现自己的形式并为其变化添加动画效果怎么办？这很难吗？让我们检查。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我复制了Circle，如下所示：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-keyword">let</span> radius = <span class="hljs-built_in">min</span>(rect.width, rect.height) / <span class="hljs-number">2</span>
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: rect.width / <span class="hljs-number">2</span>, y: rect.height / <span class="hljs-number">2</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-type">Path</span>(){path <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> rect.width &gt; rect.height{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: center.x, y: <span class="hljs-number">0</span>))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: center.y))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<font></font>
            path.closeSubpath()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
圆的半径计算为分配给我们的屏幕区域边框的宽度和高度中较小的一半。</font><font style="vertical-align: inherit;">如果宽度大于高度，则从上边框的中间（注1）开始，沿顺时针方向描述整个圆（注2），并在此上封闭轮廓。</font><font style="vertical-align: inherit;">如果高度大于宽度，则从右边框的中间开始，我们还顺时针描述整个圆并闭合轮廓。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注1</font></font></b>
                        <div class="spoiler_text">Apple     (  )  .  ,      (0, 0),         (x, y),  x —  ,  y —  . ..        y.   y —   .  ,        .  90    , 180  — , 270  — .</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">笔记2</font></font></b>
                        <div class="spoiler_text">   1   ,   “ ”  “ ”         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"></a>  Core Graphics (SwiftUI      ):<br>
<blockquote>In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.</blockquote></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们检查一下我们的新圈子将如何响应withAnimation块中的更改：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
                <span class="hljs-type">HStack</span>{
                <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)
                <span class="hljs-type">CustomCircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/ba/qp/5obaqpgty5ckwvic5uxzscqtix4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哇！</font><font style="vertical-align: inherit;">我们学习了如何制作自己的自由形式的图片并为它们设置动画！</font><font style="vertical-align: inherit;">是这样吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并不是的。</font><font style="vertical-align: inherit;">这里的所有工作都是由.frame修饰符完成的（宽度：self.radius * 2，高度：self.radius * 2）。</font><font style="vertical-align: inherit;">在withAnimation块{...}中，我们进行了更改</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">州</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量，它将发送信号以使用新的半径值重新初始化CustomCircleView（），此新值将落入.frame（）修改器中，并且该修改器已经可以对参数更改进行动画处理。我们的CustomCircle（）表单会对动画做出反应，因为它不依赖于为其选择的区域的大小。更改区域随动画发生（即逐渐在其之间插入中间值成为），因此我们的圆是用相同的动画绘制的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们简化一下（或仍然复杂吗？）我们的表单。我们不会根据可用区域的大小来计算半径，但会以完成的形式（即使其成为存储的结构参数。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-comment">//let radius = min(rect.width, rect.height) / 2</span><font></font>
...<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>(radius: radius)<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)
            <span class="hljs-comment">//.frame(height: self.radius * 2)</span><font></font>
...<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/g9/ju/pp/g9juppbsuti7iazguvffuy02fiu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，魔术是无法挽回的丢失。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们从CustomCircleView（）中排除了frame（）修饰符，将对圆的大小的责任移到了形状本身上，动画消失了。</font><font style="vertical-align: inherit;">但这没关系；教一种形式来对其参数的变化进行动画处理并不难。</font><font style="vertical-align: inherit;">为此，您需要实现Animatable协议的要求：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span>, <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span>{
         <span class="hljs-keyword">get</span>{<font></font>
             radius<font></font>
         }<font></font>
         <span class="hljs-keyword">set</span>{
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"new radius is \(newValue)"</span>)<font></font>
            radius = newValue<font></font>
         }<font></font>
     }<font></font>
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{<font></font>
	...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/f1/1-/xs/f11-xshpugfdigdwhnle4nupbek.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
瞧！</font><font style="vertical-align: inherit;">魔术又回来了！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们可以自信地说我们的表格是真正的动画-它可以通过动画反映其参数的变化。</font><font style="vertical-align: inherit;">我们为系统提供了一个窗口，可以在其中填充动画所需的内插值。</font><font style="vertical-align: inherit;">如果有这样的窗口，则会显示更改的动画。</font><font style="vertical-align: inherit;">如果不是这样，则更改将在没有动画的情况下进行，即 </font><font style="vertical-align: inherit;">即刻。</font><font style="vertical-align: inherit;">没什么复杂的，对吧？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动画修饰符</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何为视图内的变化制作动画</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，让我们直接转到View。</font><font style="vertical-align: inherit;">假设我们要为容器内元素的位置设置动画。</font><font style="vertical-align: inherit;">在我们的情况下，它将是一个简单的绿色矩形，宽度为10个单位。</font><font style="vertical-align: inherit;">我们将为其水平位置设置动画。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SimpleView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">Rectangle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.gray)
                <span class="hljs-type">BorderView</span>(position: position)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$position, <span class="hljs-keyword">in</span>: <span class="hljs-number">0</span>...<span class="hljs-number">1</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.position = <span class="hljs-number">0</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set to 0"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Reding position: \(position)"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">let</span> borderWidth: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, borderWidth: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">10</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.borderWidth = borderWidth
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"BorderView init"</span>)<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)
                <span class="hljs-comment">// .borderIn(position: position)</span><font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"calculating position: \(position)"</span>)
        <span class="hljs-keyword">return</span> -inSize.width / <span class="hljs-number">2</span> + inSize.width * position<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/7l/b-/pr/7lb-pry2ta71tvntbemngt8duts.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
类！</font><font style="vertical-align: inherit;">作品！</font><font style="vertical-align: inherit;">现在我们知道有关动画的一切！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并不是的。</font><font style="vertical-align: inherit;">如果您查看控制台，那么我们将看到以下内容：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BorderView初始</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
计算位置：0.4595176577568054 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BorderView初始</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
计算位置：0.468130886554718 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BorderView初始</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
计算位置：0.0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，使用滑块的位置值的每次更改都会使BorderView用新值重新初始化。这就是为什么我们在滑块之后看到绿线的平滑移动，而滑块只是经常报告变量的变化，而看上去却像是动画，但事实并非如此。调试动画时，使用滑块非常方便。您可以使用它来跟踪某些过渡状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其次，我们看到计算位置完全等于0，并且没有中间的对数，就像正确的圆形动画一样。为什么？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就像前面的示例一样，东西在修饰符中。</font><font style="vertical-align: inherit;">这次，.offset（）修饰符获得了新的缩进值，并且对更改本身进行了动画处理。</font><font style="vertical-align: inherit;">那些。</font><font style="vertical-align: inherit;">实际上，这不是我们要设置动画的position参数的变化，而是从中得出的.offset（）修饰符中的缩进的水平变化。</font><font style="vertical-align: inherit;">在这种情况下，这是无害的替换，结果是相同的。</font><font style="vertical-align: inherit;">但是，既然它们来了，让我们深入研究。</font><font style="vertical-align: inherit;">让我们创建自己的修饰符，该修饰符将在输入处接收位置（从0到1），它将接收可用区域的大小并计算缩进量。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">ViewModifier</span></span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
            .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)<font></font>
            .animation(<span class="hljs-literal">nil</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> offset = -inSize.width / <span class="hljs-number">2</span> + inSize.width * position
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"at position  \(position) offset is \(offset)"</span>)
        <span class="hljs-keyword">return</span> offset<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">borderIn</span><span class="hljs-params">(position: CGFloat)</span></span> -&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">BorderPosition</span>(position: position))<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在原始的BorderView中，分别不再需要GeometryReader以及用于计算缩进的函数：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{<font></font>
    ...<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .borderIn(position: position)<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/3i/r0/hd3ir0e-_jji7qwiasacdwpnpx4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的，我们仍然在修改器中使用.offset（）修改器，但是在它之后，我们添加了.animation（nil）修改器，该修改器会阻止我们自己的偏移动画。</font><font style="vertical-align: inherit;">我了解到，在此阶段，您可以确定足以删除此锁，但是，我们将无法深入浅出。</font><font style="vertical-align: inherit;">事实是，我们为BorderView使用animatableData的技巧不起作用。</font><font style="vertical-align: inherit;">实际上，如果您查看</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animatable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协议的文档</font><font style="vertical-align: inherit;">，则会注意到仅AnimatableModifier，GeometryEffect和Shape支持此协议的实现。</font><font style="vertical-align: inherit;">视图不在其中。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的方法是制作修改动画</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们要求View对某些更改进行动画处理时，该方法本身是不正确的。</font><font style="vertical-align: inherit;">对于View，不能使用与表单相同的方法。</font><font style="vertical-align: inherit;">而是需要将动画嵌入每个修改器中。</font><font style="vertical-align: inherit;">大多数内置修改器已经支持开箱即用的动画。</font><font style="vertical-align: inherit;">如果要为自己的修改器添加动画，则可以使用AnimatableModifier协议代替ViewModifier。</font><font style="vertical-align: inherit;">就像上面所做的那样，您可以在其中实现与动画形状更改相同的操作。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"reading position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)
            <span class="hljs-keyword">return</span> position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {<font></font>
            position = newValue<font></font>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
...<font></font>
    }<font></font>
    ...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/p2/l3/ys/p2l3yslis_hirenud-lpkt8xaoa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在一切正确。</font><font style="vertical-align: inherit;">控制台中的消息有助于了解我们的动画确实有效，并且修饰符内的.animation（nil）完全不会对其产生干扰。</font><font style="vertical-align: inherit;">但是，让我们仍然弄清楚它是如何工作的。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，您需要了解什么是修饰符。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们有一个视图。正如我在上一部分中所述，这是一个具有存储的参数和汇编指令的结构。总的来说，该指令不包含一系列动作，这是我们以非声明式的方式编写的常用代码，而是一个简单的列表。它列出了其他视图，应用于它们的修饰符以及包含它们的容器。我们对容器不感兴趣，但是让我们更多地谈谈修饰符。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
修饰符还是具有存储的参数和View处理指令的结构。</font><font style="vertical-align: inherit;">这实际上是与View相同的指令-我们可以使用其他修饰符，容器（例如，我使用更高的GeometryReader）以及其他View。</font><font style="vertical-align: inherit;">但是我们只有传入的内容，因此需要使用此指令以某种方式对其进行更改。</font><font style="vertical-align: inherit;">修饰符参数是指令的一部分。</font><font style="vertical-align: inherit;">但最有趣的是它们已存储。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在上一篇文章中，我说过指令本身并没有存储，而是在视图更新后每次都抛出。</font><font style="vertical-align: inherit;">一切都是这样，但有细微差别。</font><font style="vertical-align: inherit;">由于该指令的工作，正如我之前所说的，我们所获得的画面并不多-是一种简化。</font><font style="vertical-align: inherit;">在执行该指令后，修饰符不会消失。</font><font style="vertical-align: inherit;">在父视图存在时，它们仍然保留。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一些原始的类比</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将如何以声明式方式描述表格？</font><font style="vertical-align: inherit;">好吧，我们将列出4条腿和一个台面。</font><font style="vertical-align: inherit;">他们会将它们组合到某种容器中，并借助一些修饰符来规定如何将它们彼此固定。</font><font style="vertical-align: inherit;">例如，每条腿将指示相对于台面的方向以及位置-哪条腿固定在哪个角上。</font><font style="vertical-align: inherit;">是的，组装后我们可以扔掉说明书，但是钉子会留在桌子上。</font><font style="vertical-align: inherit;">修饰符也是如此。</font><font style="vertical-align: inherit;">在body函数的出口处，我们还没有一张桌子。</font><font style="vertical-align: inherit;">使用主体，我们创建表格元素（视图）和紧固件（修饰符），并将其全部放置在抽屉中。</font><font style="vertical-align: inherit;">桌子本身由机器人组装。</font><font style="vertical-align: inherit;">您在每条腿的盒子中放什么紧固件，您会得到这样的桌子。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.modifier（BorderPosition（position：position））函数使我们将BorderPosition结构变成修饰符，只在抽屉中放了一个额外的螺钉到桌腿。 BorderPosition结构就是这个螺钉。渲染时，渲染时，请提取此框，从中取出一条腿（在本例中为Rectangle（）），然后从列表中顺序获取所有修饰符，并将值存储在其中。每个修饰符的主体功能是有关如何使用此螺钉将腿固定到桌面上以及具有存储属性的结构本身（即该螺钉）的说明。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么在动画的背景下理解这一点很重要？因为动画允许您更改一个修改器的参数而不影响其他修改器，然后重新渲染图像。如果您通过更改某些内容来执行相同操作</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数-这将导致整个链中嵌套View，修饰符结构等的重新初始化。但是动画不是。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，当我们在按下按钮时更改position的值时，它就会更改。从头到尾。没有中间状态存储在变量本身中，关于修饰符不能说中间状态。对于每个新帧，修改器参数的值会根据当前动画的进度而变化。如果动画持续1秒，则每1/60秒（iphone精确显示每秒的帧数），修改器内的animatableData值将更改，然后将被渲染读取，以进行渲染，此后再经过1/60秒，将再次更改，并通过渲染再次读取。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
什么是特征，我们首先获取整个View的最终状态，并记住它，然后动画机制才开始将插值的位置值移入修改器中。初始状态不会存储在任何地方。在SwiftUI的肠道中，仅存储初始状态和最终状态之间的差异。每次将此差乘以经过时间的分数。这就是内插值的计算方式，随后将其代入animatableData。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">差异= </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">钢</font></font><br><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">- </font></i><i><font style="vertical-align: inherit;">当前值=钢-差异*（1--经过的时间）经过的</font></i><i><font style="vertical-align: inherit;">
时间=从StartAnimations / DurationAnimations开始的时间</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
当前值需要计算为我们需要显示的帧数的次数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么没有明确使用“ Was”？事实是，SwiftUI不存储初始状态。仅存储差异：因此，如果发生某种故障，您可以简单地关闭动画，并进入“成为”的当前状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方法使您可以使动画可逆。假设在一个动画的中间某处，用户再次按下了一个按钮，然后我们再次更改了同一变量的值。在这种情况下，我们需要做的就是漂亮地克服此更改，就是将新更改时动画中的“当前”取为“它”，记住新的“差异”，然后根据新的“蜜饯”和新的“差异”开始制作新的动画。 。是的，实际上，从一种动画过渡到另一种动画可能很难模拟惯性，但我认为含义是可以理解的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有趣的是，每个帧的动画都要求修饰符内的当前值（使用吸气剂）。从日志中的服务记录中可以看出，这是造成“钢”状态的原因。然后，使用设置器，设置该帧当前的新状态。之后，对于下一帧，再次请求修改器的当前值-并再次“已成为”，即动画要移动到的最终值。可能会使用修改器结构的副本进行动画处理，并使用一种结构的吸气剂（实际View的真实修改器）来获取值“钢”，而使用另一种结构的setter（用于动画的临时修改器）。我还没有想出办法来确保这一点，但是通过间接指示，一切看起来都差不多。无论如何，动画中的更改不会影响当前视图的修改器结构的存储值。如果您对如何确切地了解getter和setter会发生什么有任何想法，请在评论中进行介绍，我将对此文章进行更新。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几个参数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
到目前为止，我们只有一个动画参数。</font><font style="vertical-align: inherit;">可能会出现问题，但是如果将多个参数传递给修饰符怎么办？</font><font style="vertical-align: inherit;">如果两个都需要同时进行动画处理？</font><font style="vertical-align: inherit;">例如，这是使用frame修饰符（width：height :）的方式。</font><font style="vertical-align: inherit;">毕竟，我们可以同时更改此View的宽度和高度，并且希望使更改发生在一个动画中，该怎么做？</font><font style="vertical-align: inherit;">毕竟，AnimatableData参数是一个，我可以替代它吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您看，Apple仅对animatableData有一个要求。替换为它的数据类型必须满足VectorArithmetic协议。该协议要求对象确保最小的算术运算，以便能够形成两个值的分段并在该分段内插点。为此所需的运算是加法，减法和乘法。困难在于我们必须使用存储多个参数的单个对象执行这些操作。那些。我们必须将整个参数列表包装在一个向量容器中。苹果提供了一个开箱即用的对象，并为我们提供了在不太困难的情况下使用交钥匙解决方案的解决方案。它称为AnimatablePair。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们稍微改变一下任务。</font><font style="vertical-align: inherit;">我们需要一个新的修改器，该修改器不仅会移动绿色条，而且还会更改其高度。</font><font style="vertical-align: inherit;">这将是两个独立的修饰符参数。</font><font style="vertical-align: inherit;">我不会提供需要完成的所有更改的完整代码，您可以在github上的SimpleBorderMove文件中找到它。</font><font style="vertical-align: inherit;">我将只显示修饰符本身：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TwoParameterBorder</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">AnimatablePair</span>&lt;<span class="hljs-type">CGFloat</span>, <span class="hljs-type">CGFloat</span>&gt; {
        <span class="hljs-keyword">get</span> {
           <span class="hljs-built_in">print</span>(<span class="hljs-string">"animation read position: \(position), height: \(height)"</span>)
           <span class="hljs-keyword">return</span> <span class="hljs-type">AnimatablePair</span>(position, height)<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue.first
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating position at \(position)"</span>)
            <span class="hljs-keyword">self</span>.height = newValue.second
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating height at \(height)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, height: <span class="hljs-type">CGFloat</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.height = height<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
                .animation(<span class="hljs-literal">nil</span>)<font></font>
                .offset(x: -geometry.size.width / <span class="hljs-number">2</span> + geometry.size.width * <span class="hljs-keyword">self</span>.position, y: <span class="hljs-number">0</span>)<font></font>
                .frame(height: <span class="hljs-keyword">self</span>.height * (geometry.size.height - <span class="hljs-number">20</span>) + <span class="hljs-number">20</span>)<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vn/0q/mi/vn0qmirl31w63mzgjvijsw-f-ps.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我添加了另一个滑块和一个按钮，用于在SimpleView的父视图中一次随机更改两个参数，但是没有什么有趣的，因此对于完整代码，欢迎使用github。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切正常，我们确实在AnimatablePair元组中包装的参数对中有了一个一致的变化。</font><font style="vertical-align: inherit;">不错。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此实施过程中，没有什么混乱的吗？</font><font style="vertical-align: inherit;">就我个人而言，看到此设计时我会紧张：</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.position = newValue.first
<span class="hljs-keyword">self</span>.height = newValue.second
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我没有指出应该首先使用哪个参数，然后再选择哪个参数。 SwiftUI如何确定将第一个值放在第二个值中？好吧，它不匹配功能参数名称和结构属性名称吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一个想法是函数参数及其类型中属性的顺序，就像@EnvironmentObject一样。在这里，我们只需将值放在框中，而无需为其分配任何标签，然后我们将其移出该位置，也无需指示任何标签。在那里，类型很重要，在一种类型内，就是顺序。他们以相同的顺序将其放入包装盒中并得到。我尝试了函数的参数的不同顺序，初始化结构的参数的顺序，结构本身的属性的顺序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后它突然降临在我身上。我自己指出哪个参数将是吸气剂中的第一个，哪个是第二个。 SwiftUI不需要确切地知道我们如何初始化此结构。它可以获取更改前的animatableData值，更改后获取它，计算它们之间的差，并将相同的差（按经过的时间间隔成比例缩放）返回给我们的设置者。通常，它不需要了解AnimatableData内部的值本身的任何信息。而且，如果您不混淆两个相邻行中变量的顺序，那么不管其余代码的结构多么复杂，一切都会按顺序进行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，让我们检查一下。毕竟，我们可以创建自己的容器向量（哦，我喜欢它，创建我们自己的现有对象的实现，您可能在上一篇文章中已经注意到了这一点）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ao/v4/an/aov4an8tjqou27syes6klcckwy0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们描述基本结构，声明对VectorArithmetic协议的支持，打开关于协议不符合的错误，单击“修复”，然后获得所有必需功能和计算参数的声明。</font><font style="vertical-align: inherit;">它仍然只是填充它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同样，我们使用AdditiveArithmetic协议所需的方法填充对象（VectorArithmetic包括其支持）。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyAnimatableVector</span>: <span class="hljs-title">VectorArithmetic</span></span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> - <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position - rhs.position, height: lhs.height - rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> + <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position + rhs.position, height: lhs.height + rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scale</span><span class="hljs-params">(by rhs: Double)</span></span> {
        <span class="hljs-keyword">self</span>.position = <span class="hljs-keyword">self</span>.position * <span class="hljs-type">CGFloat</span>(rhs)
        <span class="hljs-keyword">self</span>.height = <span class="hljs-keyword">self</span>.height * <span class="hljs-type">CGFloat</span>(rhs)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> magnitudeSquared: <span class="hljs-type">Double</span>{
         <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.position * <span class="hljs-keyword">self</span>.position) + <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.height * <span class="hljs-keyword">self</span>.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> zero: <span class="hljs-type">MyAnimatableVector</span>{
        <span class="hljs-type">MyAnimatableVector</span>(position: <span class="hljs-number">0</span>, height: <span class="hljs-number">0</span>)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
}</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我认为为什么我们需要+和-显然。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缩放是缩放的函数。</font><font style="vertical-align: inherit;">我们采用“过去-它已成为”的差异，并将其乘以动画的当前阶段（从0到1）。</font><font style="vertical-align: inherit;">“它变成+差异*（（1-阶段）””，并且会有一个当前值，我们应该在animatableData中添加</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化其值将用于动画的新对象可能需要零。</font><font style="vertical-align: inherit;">动画一开始就使用.zero，但是我不知道具体如何。</font><font style="vertical-align: inherit;">但是，我认为这并不重要。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itudeSquared是给定向量与其自身的标量积。</font><font style="vertical-align: inherit;">对于二维空间，这意味着矢量的长度平方。</font><font style="vertical-align: inherit;">这可能用来比较两个对象，而不是逐个比较，而是作为一个整体。</font><font style="vertical-align: inherit;">它似乎不用于动画目的。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般来说，“-=”“ + =”功能也包含在协议支持中，但是对于结构，它们可以以这种形式自动生成</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> -= <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs - rhs<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> += <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs + rhs<font></font>
    }<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了清楚起见，我以图表的形式列出了所有这些逻辑。</font><font style="vertical-align: inherit;">
图片是可单击的。</font><font style="vertical-align: inherit;">
动画过程中得到的结果以红色突出显示-每隔一个滴答声（1/60秒），计时器将给出一个新的t值，而在修改器的设置器中，我们将获得一个新的animatableData值。</font><font style="vertical-align: inherit;">这就是动画在幕后的工作方式。</font><font style="vertical-align: inherit;">同时，重要的是要了解修饰符是存储的结构，并且使用具有新的当前状态的当前修饰符的副本来显示动画。</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/zl/ag/q4/zlagq42atcapum-br2sj00ikubu.png"></a><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么AnimatableData只能是一个结构</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有一点。您不能将类用作AnimatableData对象。正式地，您可以为一个类描述相应协议的所有必要方法，但这不会奏效，这就是原因。如您所知，类是引用数据类型，而结构是基于值的数据类型。在基于另一个变量创建一个变量时（对于类而言），将链接复制到该对象，对于结构而言，则基于现有变量的值创建一个新对象。这是一个说明此差异的小示例：</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TestStruct</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
            <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
             <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
        <span class="hljs-keyword">init</span>(value: <span class="hljs-type">CGFloat</span>){
            <span class="hljs-keyword">self</span>.value = value<font></font>
        }<font></font>
    }<font></font>
        <span class="hljs-keyword">var</span> stA = <span class="hljs-type">TestStruct</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> stB = stA<font></font>
        stB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"structs: a = \(stA.value), b = \(stB.value))"</span>) <span class="hljs-comment">//structs: a = 5.0, b = 10.0)</span>
        <span class="hljs-keyword">var</span> clA = <span class="hljs-type">TestClass</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> clB = clA<font></font>
        clB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"classes: a = \(clA.value), b = \(clB.value))"</span>) <span class="hljs-comment">//classes: a = 10.0, b = 10.0)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于动画，完全相同的事情也会发生。我们有一个AnimatableData对象，表示“ was”和“ became”之间的区别。我们需要计算出部分差异以反映在屏幕上。为此，我们必须复制此差异并将其乘以代表动画当前阶段的数字。在结构的情况下，这不会影响差异本身，但在类的情况下会影响。我们绘制的第一帧是“ was”状态。为此，我们需要计算Steel +差异*当前阶段-差异。在类的情况下，在第一帧中，我们将差乘以0，将其归零，然后绘制所有后续帧，以使差= 0。动画似乎已正确绘制，但实际上我们看到了从一种状态到另一种状态的即时过渡，就好像没有动画一样。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能可以编写某种低级代码来为乘法结果创建新的内存地址-但是为什么呢？</font><font style="vertical-align: inherit;">您可以只使用结构-为此而创建的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于那些想彻底了解SwiftUI如何通过什么操作和什么时候计算中间值的人，</font><font style="vertical-align: inherit;">消息会被推送到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的控制台</font><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">另外，我在那儿插入了0.1秒的sleep以模拟动画中的资源密集型计算，玩得开心:)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">屏幕动画：.transition（）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
到此为止，我们已经讨论过将传递给修饰符或形式的值的变化设置为动画。这些是非常强大的工具。但是还有另一个工具也使用动画-这是View外观和消失的动画。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在上一篇文章中，我们讨论了一个事实，即以if-else的声明方式，这根本不是控制运行时中的代码流，而是Schrödinger的观点。这是一个同时包含两个View的容器，该容器根据特定条件决定显示哪个View。如果错过else块，则显示EmptyView而不是第二个视图。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在两个视图之间切换也可以设置动画。为此，请使用.transition（）修饰符。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TransitionView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">let</span> views: [<span class="hljs-type">AnyView</span>] = [<span class="hljs-type">AnyView</span>(<span class="hljs-type">CustomCircleTestView</span>()), <span class="hljs-type">AnyView</span>(<span class="hljs-type">SimpleBorderMove</span>())]<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> currentViewInd = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-type">HStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">10</span>)<font></font>
                        .fill(ind == <span class="hljs-keyword">self</span>.currentViewInd ? <span class="hljs-type">Color</span>.green : <span class="hljs-type">Color</span>.gray)<font></font>
                        .overlay(<font></font>
                            <span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + Int(1))"</span>))<font></font>
                        .onTapGesture{<font></font>
                            withAnimation{<font></font>
                                <span class="hljs-keyword">self</span>.currentViewInd = ind<font></font>
                            }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
                .frame(height: <span class="hljs-number">50</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看它是如何工作的。首先，即使在父视图的初始化阶段，我们也要预先创建并在数组中放置几个​​视图。该数组的类型为AnyView，因为数组的元素必须具有相同的类型，否则它们不能在ForEach中使用。前</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一篇文章的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不透明结果类型</font><font style="vertical-align: inherit;">，还记得吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我们规定了该数组索引的枚举，对于每个数组，我们都通过该索引显示视图。我们被迫这样做，而不是立即遍历View，因为要使用ForEach，我们需要为每个元素分配一个内部标识符，以便SwiftUI可以遍历集合的内容。或者，我们必须在每个View中创建一个代理标识符，但是为什么可以使用索引呢？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将集合中的每个视图包装成一个条件，并仅在其处于活动状态时显示它。但是，if-else构造在这里根本不存在，编译器将其用于流控制，因此我们将所有这些都放在了Group中，以便编译器确切地了解它是View的意思，或更确切地说，是ViewBuilder创建可选的ConditionalContent容器的指令&lt;View1，View2&gt;。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，当更改currentViewInd的值时，SwiftUI将隐藏先前的活动视图，并显示当前视图。您如何在应用程序内部喜欢这种导航方式？</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ua/kr/gd/uakrgd2tzwv9hik_egmn1fglsfw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
剩下要做的就是将currentViewInd更改放入withAnimation包装器中，并且在窗口之间切换将变得很顺畅。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
添加.transition修饰符，并指定.scale作为参数。</font><font style="vertical-align: inherit;">这将使每个视图的外观和消失的动画不同-使用缩放而不是默认SwiftUI使用的透明度。</font></font><br>
<br>
<pre><code class="swift hljs">                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                                .transition(.scale)<font></font>
                        }<font></font>
                    }<font></font>
                }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/l5/ib/d-/l5ibd-y7m986miqinbv56qaslfc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，该视图以相同的动画出现和消失，只有消失以相反的顺序滚动。</font><font style="vertical-align: inherit;">实际上，我们可以为视图的外观和消失分别分配动画。</font><font style="vertical-align: inherit;">为此使用非对称过渡。</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                               .transition(.asymmetric(<font></font>
                                    insertion: insertion: <span class="hljs-type">AnyTransition</span>.scale(scale: <span class="hljs-number">0.1</span>, anchor: .leading).combined(with: .opacity),<font></font>
                                    removal: .move(edge: .trailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mq/xg/ji/mqxgji1ton95qn6ywl23xhl2mzm.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
屏幕上会出现相同的.scale动画，但是现在我们指定了使用它的参数。它的开头不是零（点），而是通常的0.1。小窗口的起始位置不在屏幕中央，而是移到了左边缘。此外，外观不是由一个过渡负责，而是由两个过渡负责。它们可以与.combined（与：）组合。在这种情况下，我们增加了透明度。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
视图的消失现在由另一个动画渲染-扫掠屏幕的右边缘。我将动画放慢了一些，因此您可以看一下它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
和往常一样，我迫不及待想编写自己的公交动画版本。这比动画形式或修饰符还要简单。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)<font></font>
            .clipped()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">AnyTransition</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinIn</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: -<span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinOut</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/k-/mu/eck-muqydvucs1o59dkbnzpnw6e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们编写通常的修饰符，在该修饰符中我们传递一定的数-旋转角度（以度为单位）以及发生旋转的相对点。然后，我们使用两个函数扩展AnyTransition类型。它本来可以是一个，但对我来说似乎更方便。我发现给每个语音名称分配名称要比直接在View本身中控制旋转度要容易得多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AnyTransition类型有一个静态修饰符方法，我们向其中传递了两个修饰符，然后得到一个AnyTransition对象，该对象描述了从一种状态到另一种状态的平滑过渡。 identity是动画视图的正常状态修改器。活动是指视图外观的动画开始或消失的动画结束的状态，即段的另一端，将在其中插值的状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，spinIn表示我将通过沿指定点沿顺时针方向旋转来使视图从屏幕外部（或为视图分配的空间）出现。 spinOut表示视图将以相同的方式消失，围绕相同的点（也沿顺时针方向）旋转。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据我的想法，如果对View的出现和消失使用相同的点，则会获得围绕该点旋转整个屏幕的效果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有动画均基于标准修改器机制。如果编写完全自定义的修饰符，则必须像对TwoParameterBorder那样实现AnimatableModifier协议的要求，或者使用其中提供内置默认修饰符的内置修饰符。在这种情况下，我依靠SpinTransitionModifier修改器中的内置.rotationEffect（）动画。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.transition（）修饰符仅阐明将什么视为动画的起点和终点。如果我们需要在开始动画之前请求AnimatableData状态，请请求当前状态的AnimatableData修改器，计算差值，然后将减小的动画设置为1到0，那么.transition（）只会更改原始数据。您没有依附于View的状态；您不是基于此状态的。您可以自己明确指定初始状态和最终状态，并从中获得AnimatableData，计算差异并对其进行动画处理。然后，在动画的结尾，您当前的View成为最重要的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说一句，标识是一个修饰符，它将在动画结束时保留应用于您的视图。否则，此处的错误将导致外观动画的末尾和消失动画的开始处的跳转。因此，过渡可以视为“二合一”-将特定的修改器直接应用于View +在View出现和消失时可以对其更改进行动画处理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
老实说，这种动画控制机制在我看来非常强大，对于我们不能将其用于任何动画，我感到有点遗憾。我不会拒绝制作无尽的封闭动画。但是，我们将在下一篇文章中讨论它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了更好地了解更改本身是如何发生的，我将测试视图替换为基本正方形，并用数字签名并加了边框。</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-comment">//self.views[ind]</span>
                            <span class="hljs-type">Rectangle</span>()<font></font>
                                .fill(<span class="hljs-type">Color</span>.gray)<font></font>
                                .frame(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)<font></font>
                                .border(<span class="hljs-type">Color</span>.black, width: <span class="hljs-number">2</span>)<font></font>
                                .overlay(<span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + 1)"</span>))<font></font>
                              .transition(.asymmetric(<font></font>
                                  insertion: .spinIn(anchor: .bottomTrailing),<font></font>
                                  removal: .spinOut(anchor: .bottomTrailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/4s/u9/vx4su9aoaqzuqzi2wq8uctpxe7c.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了使此动作更好，我从SpinTransitionModifier修饰符中删除了.clipped（）：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)
            <span class="hljs-comment">//.clipped()</span><font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/ml/0i/ihml0id6hnttwuhbjuv5s28jhaa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说一下，现在我们总共需要在自己的修饰符中使用SpinTransitionModifier。</font><font style="vertical-align: inherit;">创建它仅是为了将两个修改器rotationEffect和clip（（））组合为一个，以便旋转动画不会超出为View选择的范围。</font><font style="vertical-align: inherit;">现在，我们可以直接在.modifier（）内部使用.rotationEffect（），而无需使用SpinTransitionModifier形式的中介。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当视图死亡时</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有趣的一点是View生命周期（如果放置在if-else中）。</font><font style="vertical-align: inherit;">视图虽然已启动并记录为数组元素，但未存储在内存中。</font><font style="vertical-align: inherit;">她所有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">州</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下次它们出现在屏幕上时，参数将重置为默认值。这几乎与初始化相同。尽管对象结构本身仍然存在，但渲染器将其从其视野中删除，因为它实际上不存在。一方面，这减少了内存使用。如果数组中有大量复杂的View，则渲染必须不断绘制所有视图，并对更改做出反应-这会对性能产生负面影响。如果我没记错的话，那就是Xcode 11.3更新之前的情况。现在，非活动视图将从渲染内存中卸载。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一方面，我们必须将所有重要状态移出该视图的范围。为此，最好使用@EnvironmentObject变量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
返回生命周期，还应注意，如果.onAppear {}修饰符（如果已在此View中注册），则在更改View的条件和外观后，甚至在动画开始之前，都可以立即使用。</font><font style="vertical-align: inherit;">因此，消失动画结束后会触发onDisappear {}。</font><font style="vertical-align: inherit;">如果您打算将它们与过渡动画一起使用，请记住这一点。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一步是什么？ </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ew </font><font style="vertical-align: inherit;">结果非常详尽，但是很详细，我希望可以理解。</font><font style="vertical-align: inherit;">老实说，我希望在一篇文章中谈论彩虹动画，但是我无法及时了解细节。</font><font style="vertical-align: inherit;">因此，等待继续。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下部分等待着我们：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用渐变：线性，圆形和角度-一切都会派上用场</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">颜色根本不是颜色：明智地选择。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">循环动画：如何开始和如何停止以及如何立即停止（没有动画，更改动画-是的，也有一个）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前流动画：优先级，替代，不同对象的不同动画</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关动画时间的详细信息：我们将在尾部和鬃毛中驱动时间，直到我们自己实现的TimingCurve为止（哦，让我保持七个:)）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何找出所播放动画的当前时刻</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果SwiftUI还不够</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将通过创建彩虹动画的示例来详细讨论所有这些，如图所示：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我没有走简单的路，而是收集了我可以达到的所有耙，并按照上述原理将动画体现了出来。</font><font style="vertical-align: inherit;">关于这个的故事应该证明是很有信息的，并且有许多技巧和各种各样的黑客手段，关于这些东西的报道很少，对于那些决定成为SwiftUI先锋的人来说，这将是有用的。</font><font style="vertical-align: inherit;">它将大约在一两个星期内出现。</font><font style="vertical-align: inherit;">顺便说一句，您可以订阅，以免错过。</font><font style="vertical-align: inherit;">但是，当然，前提是该材料对您似乎有用并且演示方法已被批准。</font><font style="vertical-align: inherit;">然后，您的订阅将有助于快速将新文章推到顶部，并尽早将它们带给更广泛的受众。</font><font style="vertical-align: inherit;">否则，请在注释中写错。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN504186/index.html">保罗·格雷厄姆（Paul Graham）：如何撰写有用的文章（完整）</a></li>
<li><a href="../zh-CN504188/index.html">检疫，在线系统和数据科学。谁会考虑保留客户？</a></li>
<li><a href="../zh-CN504190/index.html">MVCC是确保事务隔离的一种方法</a></li>
<li><a href="../zh-CN504194/index.html">对Stack Overflow 2020（+ habraopros）开发人员的调查结果</a></li>
<li><a href="../zh-CN504196/index.html">NFC：解析近场通信技术</a></li>
<li><a href="../zh-CN504204/index.html">IBM Workshops：Quarkus（用于微服务的Ultrafast Java），Jakarta EE和OpenShift</a></li>
<li><a href="../zh-CN504208/index.html">如何自动化共享服务中心</a></li>
<li><a href="../zh-CN504210/index.html">什么是Deno，它将取代Node.js？</a></li>
<li><a href="../zh-CN504214/index.html">DATA VAULT的发展以及向业务DATA VAULT的过渡</a></li>
<li><a href="../zh-CN504216/index.html">这房子几岁了。我如何绘制圣彼得堡房屋年龄的地图</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>