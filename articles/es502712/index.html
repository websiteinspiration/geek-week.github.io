<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❓ 😠 👨🏾‍🏭 ¿Cómo funciona una tira de dirección led? 📕 👦 🦀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probablemente esta pregunta "cómo funciona" parece tonta para muchos. La respuesta es casi obvia: una tira de LED direccionable consiste en una plural...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>¿Cómo funciona una tira de dirección led?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502712/"><img src="https://habrastorage.org/webt/vo/6r/d2/vo6rd2jupdaxgzun1zl3_iyp-k4.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablemente esta pregunta "cómo funciona" parece tonta para muchos. La respuesta es casi obvia: una tira de LED direccionable consiste en una pluralidad de "LED inteligentes" conectados en serie. Esto se puede ver simplemente mirando el dispositivo de cinta. Puede ver microcircuitos individuales soldados a un bucle flexible, puede ver las conexiones: los microcircuitos están conectados en serie con solo tres cables, y dos de ellos son de alimentación y tierra. Solo un cable transmite datos de color de píxeles. ¿Como es eso? ¿Qué es un LED inteligente? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuación, hablaré sobre el protocolo de transferencia de datos utilizado en la tira de LED basada en WS2812B y, además, casi crearé mi propio "chip de tira de LED" en el chip FPGA.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, la cinta utiliza la transmisión en serie a través de una sola señal de datos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El bit cero se transmite como un impulso positivo corto y una pausa que es aproximadamente dos veces más ancha que el impulso. La unidad de bits se transmite como un pulso positivo amplio y una pausa breve: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/e9/d-/6ne9d-mfj_ah8zurj1i6fnrevgy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
si no hay transmisión de más de 50 microsegundos, la cinta vuelve a su estado original, lista para aceptar píxeles a partir del primero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada 24 bits en una secuencia son 3 bytes para tres colores RGB. Y, de hecho, la secuencia será GRB. La parte alta de G7 es lo primero.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La secuencia de los primeros 24 bits es de un píxel, que recibirá el primer LED en la cinta. Hasta que el primer LED esté saturado, no transfiere datos al siguiente LED. Después de que el primer LED recibe su porción de bits RGB 24x, abre la transmisión al siguiente. Primitivamente, uno puede imaginar una secuencia de LED como una cascada de jarras que se llenan sucesivamente de agua: la </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pv/8d/rz/pv8drz6goxvaujnutaw38e0tvbi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
primera, luego la segunda, luego la tercera, y así sucesivamente, se llenarán. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, creo que el protocolo de transferencia ha sido resuelto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Es posible intentar diseñar un "LED inteligente" usted mismo? Por supuesto, esto tiene poco sentido práctico, pero para la autoeducación y la ampliación de los horizontes, esta es una tarea interesante. Intentemos describir la lógica del chip en el lenguaje de programación Verilog HDL. Por supuesto, este no será un diseño de chip real, habrá limitaciones. Una de las limitaciones más importantes: necesitaré un reloj externo para mi microcircuito. En un LED inteligente real, dicho generador también existe, pero ya está integrado en el chip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos el módulo Verilog así:</font></font><br>
<br>
<pre><code class="vhdl hljs">module WS2812B(<font></font>
	input wire clk,<font></font>
	input wire <span class="hljs-keyword">in</span>,<font></font>
	output wire <span class="hljs-keyword">out</span>,<font></font>
	output reg r,<font></font>
	output reg g,<font></font>
	output reg b<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que todo está claro aquí: la frecuencia de reloj de clk, las señales de entrada y salida del "LED inteligente" dentro y fuera, y, por supuesto, las señales de salida r, g, b a través de las cuales controlaré los LED externos reales en rojo, verde y azul. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Capturaré la señal de entrada en un registro de desplazamiento de dos bits y desde el estado actual en estos bits capturados puedo determinar el comienzo del borde positivo de la señal en:</font></font><br>
<br>
<pre><code class="vhdl hljs">reg [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]r_in = <span class="hljs-number">0</span>;<font></font>
always @( posedge clk )<font></font>
	r_in &lt;= { r_in[<span class="hljs-number">0</span>],<span class="hljs-keyword">in</span> };<font></font>
<font></font>
wire in_pos_edge; assign in_pos_edge = (r_in==<span class="hljs-number">2</span><span class="hljs-symbol">'b01</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, es importante determinar el estado del restablecimiento de la cinta cuando el controlador de control hace una pausa antes de comenzar una nueva transmisión:</font></font><br>
<br>
<pre><code class="vhdl hljs">localparam reset_level = <span class="hljs-number">3000</span>;<font></font>
reg [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]reset_counter = <span class="hljs-number">0</span>;<font></font>
always @( posedge clk )<font></font>
	<span class="hljs-keyword">if</span>( r_in[<span class="hljs-number">0</span>] )<font></font>
		reset_counter &lt;= <span class="hljs-number">0</span>;
	<span class="hljs-keyword">else</span>
	<span class="hljs-keyword">if</span>( reset_counter&lt;reset_level )<font></font>
		reset_counter &lt;= reset_counter+<span class="hljs-number">1</span>;<font></font>
<font></font>
wire reset; assign reset = (reset_counter==reset_level);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, desde un borde positivo en_pos_edge es necesario soportar alguna pausa para obtener el momento de arreglar un nuevo bit:</font></font><br>
<br>
<pre><code class="vhdl hljs">localparam fix_level   = <span class="hljs-number">50</span>;<font></font>
reg [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]bit_length_cnt;<font></font>
always @( posedge clk )<font></font>
	<span class="hljs-keyword">if</span>( in_pos_edge )<font></font>
		bit_length_cnt &lt;= <span class="hljs-number">0</span>;
	<span class="hljs-keyword">else</span>
	<span class="hljs-keyword">if</span>( bit_length_cnt&lt;(fix_level+<span class="hljs-number">1</span>) &amp;&amp; !pass )<font></font>
		bit_length_cnt &lt;= bit_length_cnt + <span class="hljs-number">1</span>;<font></font>
<font></font>
wire bit_fix; assign bit_fix = (bit_length_cnt==fix_level);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El número de bits ya recibidos en el chip se considera de la siguiente manera:</font></font><br>
<br>
<pre><code class="vhdl hljs">reg pass = <span class="hljs-number">0</span>;<font></font>
reg [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>]bits_captured = <span class="hljs-number">0</span>;<font></font>
<font></font>
always @( posedge clk )<font></font>
	<span class="hljs-keyword">if</span>( reset )<font></font>
		bits_captured &lt;= <span class="hljs-number">1</span><span class="hljs-symbol">'b0</span>;
	<span class="hljs-keyword">else</span>
	<span class="hljs-keyword">if</span>( ~pass &amp;&amp; bit_fix )<font></font>
		bits_captured &lt;= bits_captured+<span class="hljs-number">1</span><span class="hljs-symbol">'b1</span>;</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí se introduce una señal de paso importante, que solo determina la redirección del flujo de entrada a la salida. </font><font style="vertical-align: inherit;">Después de aceptar el bit de píxeles de 24x, la señal de paso se establece en uno:</font></font><br>
<br>
<pre><code class="vhdl hljs">always @( posedge clk )
	<span class="hljs-keyword">if</span>( reset )<font></font>
		pass &lt;= <span class="hljs-number">1</span><span class="hljs-symbol">'b0</span>;
	<span class="hljs-keyword">else</span>
	<span class="hljs-keyword">if</span>( bits_captured==<span class="hljs-number">23</span> &amp;&amp; bit_fix )<font></font>
		pass &lt;= <span class="hljs-number">1</span><span class="hljs-symbol">'b1</span>;<font></font>
		<font></font>
reg pass_final;<font></font>
always @( posedge clk )<font></font>
	<span class="hljs-keyword">if</span>( reset )<font></font>
		pass_final &lt;= <span class="hljs-number">1</span><span class="hljs-symbol">'b0</span>;
	<span class="hljs-keyword">else</span>
	<span class="hljs-keyword">if</span>( r_in!=<span class="hljs-number">2</span><span class="hljs-symbol">'b11</span> )<font></font>
		pass_final &lt;= pass;<font></font>
		<font></font>
assign <span class="hljs-keyword">out</span> = pass_final ? <span class="hljs-keyword">in</span> : <span class="hljs-number">1</span><span class="hljs-symbol">'b0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La salida de entrada se multiplexa a la salida cuando la señal pass_final es una. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, por supuesto, necesitamos un registro de desplazamiento, donde se acumulan los 24 bits del píxel recibidos:</font></font><br>
<br>
<pre><code class="vhdl hljs">reg [<span class="hljs-number">23</span>:<span class="hljs-number">0</span>]shift_rgb;<font></font>
always @( posedge clk )<font></font>
	<span class="hljs-keyword">if</span>( bit_fix )<font></font>
		shift_rgb &lt;= { <span class="hljs-keyword">in</span>, shift_rgb[<span class="hljs-number">23</span>:<span class="hljs-number">1</span>] };<font></font>
<font></font>
reg [<span class="hljs-number">23</span>:<span class="hljs-number">0</span>]fix_rgb;<font></font>
always @( posedge clk )<font></font>
	<span class="hljs-keyword">if</span>( bits_captured==<span class="hljs-number">23</span> &amp;&amp; bit_fix )<font></font>
		fix_rgb &lt;= { <span class="hljs-keyword">in</span>, shift_rgb[<span class="hljs-number">23</span>:<span class="hljs-number">1</span>] };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al recibir los 24 bits, también se copian en el registro final de 24 bits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora el asunto sigue siendo pequeño. </font><font style="vertical-align: inherit;">Es necesario implementar una señal PWM (Latitudinal Pulse Modulation) para transmitir el brillo a los LED externos reales de acuerdo con los bytes RGB recibidos:</font></font><br>
<br>
<pre><code class="vhdl hljs">wire [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]wgreen; assign wgreen = { fix_rgb[<span class="hljs-number">0</span> ], fix_rgb[<span class="hljs-number">1</span> ], fix_rgb[<span class="hljs-number">2</span> ], fix_rgb[<span class="hljs-number">3</span> ], fix_rgb[<span class="hljs-number">4</span> ], fix_rgb[<span class="hljs-number">5</span> ], fix_rgb[<span class="hljs-number">6</span> ], fix_rgb[<span class="hljs-number">7</span> ] };<font></font>
wire [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]wred;   assign wred   = { fix_rgb[<span class="hljs-number">8</span> ], fix_rgb[<span class="hljs-number">9</span> ], fix_rgb[<span class="hljs-number">10</span>], fix_rgb[<span class="hljs-number">11</span>], fix_rgb[<span class="hljs-number">12</span>], fix_rgb[<span class="hljs-number">13</span>], fix_rgb[<span class="hljs-number">14</span>], fix_rgb[<span class="hljs-number">15</span>] };<font></font>
wire [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]wblue;  assign wblue  = { fix_rgb[<span class="hljs-number">16</span>], fix_rgb[<span class="hljs-number">17</span>], fix_rgb[<span class="hljs-number">18</span>], fix_rgb[<span class="hljs-number">19</span>], fix_rgb[<span class="hljs-number">20</span>], fix_rgb[<span class="hljs-number">21</span>], fix_rgb[<span class="hljs-number">22</span>], fix_rgb[<span class="hljs-number">23</span>] };<font></font>
<font></font>
reg [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]pwm_cnt;<font></font>
<font></font>
always @( posedge clk )<font></font>
<span class="hljs-keyword">begin</span>
	pwm_cnt &lt;= pwm_cnt+<span class="hljs-number">1</span>;<font></font>
	r &lt;= pwm_cnt&lt;wred;<font></font>
	g &lt;= pwm_cnt&lt;wgreen;<font></font>
	b &lt;= pwm_cnt&lt;wblue;<font></font>
<span class="hljs-keyword">end</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eso parece ser todo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Queda un pequeño detalle: ¿cómo experimentarlo todo? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tomé algunas placas base simples con FPGA MAX II (estas son las tarjetas de la serie Mars rover) y las flasheé todas con el proyecto con este código Verilog. Ya había 8 LED en los tableros, pero todos eran amarillos. En cada una de las placas, reemplacé 3 LED con R, G, B. Conecté las placas en serie y, además, las conecté a una tira de LED real. Por lo tanto, alargué la cinta real con mis LED caseros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta conexión resultó así: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-u/5k/sh/-u5kshz_kj4zwuj1uewj7wstrdk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
en realidad, se ve así: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v1/rm/qt/v1rmqtb1_pbswak3fy8ewtl0-k0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ahora, aplicando una determinada imagen a la cinta, veo que mis "LED inteligentes" se comportan exactamente igual que los reales de la cinta:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/s7GkTgyDVCc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Resulta que la lógica que implementé en el FPGA es completamente funcional! </font><font style="vertical-align: inherit;">Como primera aproximación, pude hacer algo similar a un chip LED inteligente real. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En realidad, me gustan las tiras de LED. </font><font style="vertical-align: inherit;">Sobre su base, todos pueden inventar algo propio: iluminación inteligente, pantallas, efectos ambilight. </font><font style="vertical-align: inherit;">Una vez incluso implementé música en color en una cinta LED con FPGA. </font><font style="vertical-align: inherit;">Pero esa es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">otra historia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es502696/index.html">Cómo los proveedores de servicios de Internet evitan el apagón global durante los brotes</a></li>
<li><a href="../es502700/index.html">Creador de Stack Overflow: "Los desarrolladores son los que escriben el script para el futuro"</a></li>
<li><a href="../es502702/index.html">Acerca del almacenamiento de tokens JWT en navegadores</a></li>
<li><a href="../es502704/index.html">Cómo reentrenamos el apoyo para hablar humanamente y qué sucedió</a></li>
<li><a href="../es502706/index.html">El estado de las habilidades blandas.</a></li>
<li><a href="../es502714/index.html">Exportar datos de OpenStreetMap usando el editor visual en rete.js</a></li>
<li><a href="../es502716/index.html">¿No puedes compartir la computadora de tu casa? Haz uno de dos</a></li>
<li><a href="../es502718/index.html">El proyecto Talking Head, o la historia del desarrollo de software para un robot de telepresencia</a></li>
<li><a href="../es502720/index.html">Probar tendencias para observar en 2020</a></li>
<li><a href="../es502722/index.html">Silicon Valley en ruso. Cómo funciona # ITX5 en Innopolis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>