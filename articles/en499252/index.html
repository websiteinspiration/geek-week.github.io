<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ú¥Ô∏è üèä üëî Creating a pseudo-three-dimensional racing game ü§õ üöé ü•á</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As a child, I rarely went to arcade arcade halls, because I didn‚Äôt really need them, because at home I had awesome games for C64 ... but there are thr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Creating a pseudo-three-dimensional racing game</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499252/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d16/6e3/cff/d166e3cff9c2a3cefeb68f5c1ddc02d1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a child, I rarely went to arcade arcade halls, because I didn‚Äôt really need them, because at home I had awesome games for C64 ... but there are three arcade games for which I always had money - Donkey Kong, Dragons Lair and Outrun ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... and I really loved Outrun - speed, hills, palm trees and music, even on the weak version for the C64.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48e/aee/56f/48eaee56f43d8a25e840c6ae13268db4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So I decided to try writing an old-school pseudo-three-dimensional racing game in the style of Outrun, Pitstop or Pole position. </font><font style="vertical-align: inherit;">I do not plan to put together a complete and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">complete</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> game, but it seems to me it will be interesting to re-examine the mechanics with which these games realized their tricks. </font><font style="vertical-align: inherit;">Curves, hills, sprites and a sense of speed ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, here is my ‚Äúweekend project,‚Äù which ultimately took five or six weeks on the weekend</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/27b/d28/7ec27bd28630dbbaf7b81c87233c28ac.png"></div><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Play a game</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">source code</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The playable version is more like a technical demo than a real game. </font><font style="vertical-align: inherit;">In fact, if you want to create a real pseudo-three-dimensional race, then this will be the most minimal foundation that you need to gradually turn into a game. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is not polished, a little ugly, but fully functional. </font><font style="vertical-align: inherit;">I will show you how to implement it on your own in four simple steps. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can also play</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direct road demo</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demo with curves</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demo with the hills</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finished version</font></font></a></li>
</ul><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About performance</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The performance of this game </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is very</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dependent on the machine / browser. </font><font style="vertical-align: inherit;">In modern browsers, it works well, especially in those that have canvas GPU-acceleration, but a bad graphics driver can cause it to freeze. </font><font style="vertical-align: inherit;">In the game, you can change the rendering resolution and rendering distance.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About the code structure</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It so happened that the project was implemented in Javascript (due to the simplicity of prototyping), but it is not intended to demonstrate the techniques or recommended techniques of Javascript. </font><font style="vertical-align: inherit;">In fact, for ease of understanding, the Javascript of each example is embedded directly in the HTML page (horror!); </font><font style="vertical-align: inherit;">worse, it uses global variables and functions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If I were creating a real game, the code would be much more structured and streamlined, but since this is a technical demo of a racing game, I decided to stick to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KISS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 1. Straight roads.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, how do we get started on creating a pseudo-three-dimensional racing game? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, we need</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repeat trigonometry</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recall the basics of 3d projection</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create a game loop</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Download sprite images</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Build road geometry</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render background</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render the road</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render car</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implement keyboard support for machine control</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But before we begin, let's read </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lou's Pseudo 3d Page</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">translation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Habr√©] - the only source of information (that I could find) on how to create psevdotrohmernuyu racing game. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finished reading Lou's article? </font><font style="vertical-align: inherit;">Fine! </font><font style="vertical-align: inherit;">We will be creating a variation of his Realistic Hills Using 3d-Projected Segments technique. </font><font style="vertical-align: inherit;">We will do this gradually over the next four parts. </font><font style="vertical-align: inherit;">But we will start now, with version v1, and create a very simple straight road geometry by projecting it onto an HTML5 canvas element.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The demo can be seen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A little trigonometry</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before we get into the implementation, let's use the basics of trigonometry to remember how to project a point in the 3D world onto a 2D screen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the simplest case, if you do not touch vectors and matrices, the law of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">similar triangles is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used for 3D projection </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We use the following notation:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = camera height</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = distance from camera to screen</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = distance from camera to car</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = screen </font><strong><font style="vertical-align: inherit;">y</font></strong><font style="vertical-align: inherit;"> coordinate</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then we can use the law of similar triangles to calculate </font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y = h * d / z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
as shown in the diagram:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/949/0ab/47b/9490ab47bb570b61218e46e5913c18bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You could also draw a similar diagram in a top view instead of a side view, and derive a similar equation to calculate the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinate of the </font><font style="vertical-align: inherit;">screen:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x = w * d / z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Where </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = half the width of the road (from the camera to the edge of the road). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, for </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we scale by a factor</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d / z</font></font></strong></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordinate systems</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the form of a diagram, it looks beautiful and simple, but when you start coding, you can get a little confused, because we chose arbitrary names, and it is not clear with what we designated the coordinates of the 3D world, and what the coordinates of the 2D screen are. </font><font style="vertical-align: inherit;">We also assume that the camera is in the center of the origin of the world, although in reality it will follow the machine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you approach more formally, then we need to perform:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conversion</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from world coordinates to screen coordinates</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projecting</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> camera coordinates onto a normalized projection plane</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scaling the</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> projected coordinates to the coordinates of the physical screen (in our case, this is canvas)</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/5d2/30f/b595d230f4f45b9b0c9409266d5804d8.png"></div><br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: in the present 3d-system </font><font style="vertical-align: inherit;">, the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotation</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stage is performed between stages 1 and 2 </font><font style="vertical-align: inherit;">, but since we will simulate the curves, we do not need a rotation.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projection</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The formal projection equations can be represented as follows:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/246/e18/edb246e187e7fe0eb027b53c58790c34.png"></div><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conversion Equations ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">translate</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) point is calculated relative to the chamber</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The projection equations ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">project</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) are variations of the ‚Äúlaw of similar triangles‚Äù shown above.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scaling Equations ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scale</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) take into account the difference between:</font></font><br>
<ul>
<li><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">math</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where 0,0 is in the center and the y axis is up, and</font></font></li>
<li><em></em>,  0,0     ,   y  :</li>
</ul></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11f/050/aad/11f050aadea0d1c537baefcb06f7c2f0.png"></div><br>
<blockquote><em>:   3d-         <code>Vector</code>  <code>Matrix</code>     3d-,      ,      WebGL (  )‚Ä¶       .           Outrun.</em></blockquote><br>
<h2>  </h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/27b/1bd/3b727b1bdb285d874bd659c29db13522.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last piece of the puzzle will be a way to calculate </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the distance from the camera to the projection plane. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instead of just writing a hard-set value of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it would be more useful to calculate it from the desired vertical field of view. </font><font style="vertical-align: inherit;">Thanks to this, we will be able to "zoom" the camera if necessary. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we assume that we are projecting onto a normalized projection plane, the coordinates of which are in the range from -1 to +1, then </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be calculated as follows:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 / tan (fov / 2)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defining fov</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as one (of many) variables, we can adjust the scope to fine-tune the rendering algorithm.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javascript Code Structure</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the beginning of the article, I already said that the code does not quite comply with the guidelines for writing Javascript - it is a ‚Äúquick and dirty‚Äù demo with simple global variables and functions. </font><font style="vertical-align: inherit;">However, since I am going to create four separate versions (straight, curves, hills and sprites), I will store some reusable methods inside </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">within the following modules:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dom</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a few minor DOM helper functions.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Util</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - general utilities, mainly auxiliary mathematical functions.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - general gaming support functions, such as image downloader and game loop.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - helper rendering functions on canvas.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will explain in detail methods from </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only if they relate to the game itself, and are not just auxiliary mathematical or DOM functions. </font><font style="vertical-align: inherit;">Hopefully from the name and context it will be clear what the methods should do.</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As usual, the source code is in the final documentation.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simple game loop</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before rendering something, we need a game loop. </font><font style="vertical-align: inherit;">If you read any of my previous articles about games ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">breakout</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tetris</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">snakes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boulderdash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), then you have already seen examples of my favorite game cycle with a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fixed time step</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will not go deep into the details, and simply reuse part of the code from previous games to create a game loop with a fixed time step using </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requestAnimationFrame</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The principle is that each of my four examples can call </font></font><code>Game.run(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and and use its own versions</font></font><br>
<br>
<ul>
<li><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Updating the game world with a fixed time step.</font></font></li>
<li><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Updating the game world when the browser allows.</font></font></li>
</ul><br>
<pre><code class="javascript hljs">run: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{<font></font>
<font></font>
  Game.loadImages(options.images, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">images</span>) </span>{<font></font>
<font></font>
    <span class="hljs-keyword">var</span> update = options.update,    <span class="hljs-comment">// method to update game logic is provided by caller</span>
        render = options.render,    <span class="hljs-comment">// method to render the game is provided by caller</span>
        step   = options.step,      <span class="hljs-comment">// fixed frame step (1/fps) is specified by caller</span>
        now    = <span class="hljs-literal">null</span>,<font></font>
        last   = Util.timestamp(),<font></font>
        dt     = <span class="hljs-number">0</span>,<font></font>
        gdt    = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">frame</span>(<span class="hljs-params"></span>) </span>{<font></font>
      now = Util.timestamp();<font></font>
      dt  = <span class="hljs-built_in">Math</span>.min(<span class="hljs-number">1</span>, (now - last) / <span class="hljs-number">1000</span>); <span class="hljs-comment">// using requestAnimationFrame have to be able to handle large delta's caused when it 'hibernates' in a background or non-visible tab</span><font></font>
      gdt = gdt + dt;<font></font>
      <span class="hljs-keyword">while</span> (gdt &gt; step) {<font></font>
        gdt = gdt - step;<font></font>
        update(step);<font></font>
      }<font></font>
      render();<font></font>
      last = now;<font></font>
      requestAnimationFrame(frame);<font></font>
    }<font></font>
    frame(); <span class="hljs-comment">// lets get this party started</span><font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Again, this is a remake of ideas from my previous canvas games, so if you don‚Äôt understand how the game loop works, then return to one of the previous articles.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Images and sprites</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before the game cycle begins, we load two separate spritesheets (sprite sheets):</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">background</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - three parallax layers for sky, hills and trees</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sprites</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - machine sprites (plus trees and billboards to be added to the final version)</font></font></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6f/111/acc/f6f111accbba448459e25c6fe761ff05.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The sprite sheet was generated using a small task Rake and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruby Gem sprite-factory</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This task generates the combined sprite sheets, as well as the coordinates x, y, w, h, which will be stored in the constants </font></font><code>BACKGROUND</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: I created the backgrounds using Inkscape, and most sprites are graphics </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">taken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from the old Outrun version for Genesis and used as training examples.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game variables</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to images of backgrounds and sprites, we will need several game variables, namely:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> fps           = <span class="hljs-number">60</span>;                      <span class="hljs-comment">// how many 'update' frames per second</span>
<span class="hljs-keyword">var</span> step          = <span class="hljs-number">1</span>/fps;                   <span class="hljs-comment">// how long is each frame (in seconds)</span>
<span class="hljs-keyword">var</span> width         = <span class="hljs-number">1024</span>;                    <span class="hljs-comment">// logical canvas width</span>
<span class="hljs-keyword">var</span> height        = <span class="hljs-number">768</span>;                     <span class="hljs-comment">// logical canvas height</span>
<span class="hljs-keyword">var</span> segments      = [];                      <span class="hljs-comment">// array of road segments</span>
<span class="hljs-keyword">var</span> canvas        = Dom.get(<span class="hljs-string">'canvas'</span>);       <span class="hljs-comment">// our canvas...</span>
<span class="hljs-keyword">var</span> ctx           = canvas.getContext(<span class="hljs-string">'2d'</span>); <span class="hljs-comment">// ...and its drawing context</span>
<span class="hljs-keyword">var</span> background    = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// our background image (loaded below)</span>
<span class="hljs-keyword">var</span> sprites       = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// our spritesheet (loaded below)</span>
<span class="hljs-keyword">var</span> resolution    = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// scaling factor to provide resolution independence (computed)</span>
<span class="hljs-keyword">var</span> roadWidth     = <span class="hljs-number">2000</span>;                    <span class="hljs-comment">// actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth</span>
<span class="hljs-keyword">var</span> segmentLength = <span class="hljs-number">200</span>;                     <span class="hljs-comment">// length of a single segment</span>
<span class="hljs-keyword">var</span> rumbleLength  = <span class="hljs-number">3</span>;                       <span class="hljs-comment">// number of segments per red/white rumble strip</span>
<span class="hljs-keyword">var</span> trackLength   = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// z length of entire track (computed)</span>
<span class="hljs-keyword">var</span> lanes         = <span class="hljs-number">3</span>;                       <span class="hljs-comment">// number of lanes</span>
<span class="hljs-keyword">var</span> fieldOfView   = <span class="hljs-number">100</span>;                     <span class="hljs-comment">// angle (degrees) for field of view</span>
<span class="hljs-keyword">var</span> cameraHeight  = <span class="hljs-number">1000</span>;                    <span class="hljs-comment">// z height of camera</span>
<span class="hljs-keyword">var</span> cameraDepth   = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// z distance camera is from screen (computed)</span>
<span class="hljs-keyword">var</span> drawDistance  = <span class="hljs-number">300</span>;                     <span class="hljs-comment">// number of segments to draw</span>
<span class="hljs-keyword">var</span> playerX       = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// player x offset from center of road (-1 to 1 to stay independent of roadWidth)</span>
<span class="hljs-keyword">var</span> playerZ       = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// player relative z distance from camera (computed)</span>
<span class="hljs-keyword">var</span> fogDensity    = <span class="hljs-number">5</span>;                       <span class="hljs-comment">// exponential fog density</span>
<span class="hljs-keyword">var</span> position      = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// current camera Z position (add playerZ to get player's absolute Z position)</span>
<span class="hljs-keyword">var</span> speed         = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// current speed</span>
<span class="hljs-keyword">var</span> maxSpeed      = segmentLength/step;      <span class="hljs-comment">// top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)</span>
<span class="hljs-keyword">var</span> accel         =  maxSpeed/<span class="hljs-number">5</span>;             <span class="hljs-comment">// acceleration rate - tuned until it 'felt' right</span>
<span class="hljs-keyword">var</span> breaking      = -maxSpeed;               <span class="hljs-comment">// deceleration rate when braking</span>
<span class="hljs-keyword">var</span> decel         = -maxSpeed/<span class="hljs-number">5</span>;             <span class="hljs-comment">// 'natural' deceleration rate when neither accelerating, nor braking</span>
<span class="hljs-keyword">var</span> offRoadDecel  = -maxSpeed/<span class="hljs-number">2</span>;             <span class="hljs-comment">// off road deceleration is somewhere in between</span>
<span class="hljs-keyword">var</span> offRoadLimit  =  maxSpeed/<span class="hljs-number">4</span>;             <span class="hljs-comment">// limit when off road deceleration no longer applies (e.g. you can always go at least this speed even when off road)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some of them can be customized using UI controls to change critical values ‚Äã‚Äãduring program execution so that you can see how they affect the rendering of the road. </font><font style="vertical-align: inherit;">Others are recalculated from custom UI values ‚Äã‚Äãin the method </font></font><code>reset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We manage Ferrari</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We perform key bindings for </font></font><code>Game.run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which provides simple keyboard input that sets or resets variables that report the player‚Äôs current actions:</font></font><br>
<br>
<pre><code class="javascript hljs">Game.run({<font></font>
  ...<font></font>
  keys: [<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.LEFT,  KEY.A], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyLeft   = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.RIGHT, KEY.D], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyRight  = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.UP,    KEY.W], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyFaster = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.DOWN,  KEY.S], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keySlower = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.LEFT,  KEY.A], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyLeft   = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.RIGHT, KEY.D], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyRight  = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.UP,    KEY.W], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyFaster = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.DOWN,  KEY.S], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keySlower = <span class="hljs-literal">false</span>; } }<font></font>
  ],<font></font>
  ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The player‚Äôs state is controlled by the following variables:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speed</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - current speed.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">position</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the current Z position on the track. </font><font style="vertical-align: inherit;">Note that this is a camera position, not a Ferrari.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playerX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - player‚Äôs current position on X on the road. </font><font style="vertical-align: inherit;">Normalized in the range from -1 to +1, so as not to depend on the actual value </font></font><code>roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These variables are set inside the method </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which performs the following actions:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">updates </font></font><code>position</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">based on the current </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">updates </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when you press the left or right key.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">increases </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if the up key is pressed.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decreases </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if the down key is pressed.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduces </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if the up and down keys are not pressed.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduces </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">located off the edge of the road and on the grass.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the case of direct roads, the method is </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quite clear and simple:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">dt</span>) </span>{<font></font>
<font></font>
  position = Util.increase(position, dt * speed, trackLength);<font></font>
<font></font>
  <span class="hljs-keyword">var</span> dx = dt * <span class="hljs-number">2</span> * (speed/maxSpeed); <span class="hljs-comment">// at top speed, should be able to cross from left to right (-1 to 1) in 1 second</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span> (keyLeft)<font></font>
    playerX = playerX - dx;<font></font>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keyRight)<font></font>
    playerX = playerX + dx;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (keyFaster)<font></font>
    speed = Util.accelerate(speed, accel, dt);<font></font>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keySlower)<font></font>
    speed = Util.accelerate(speed, breaking, dt);<font></font>
  <span class="hljs-keyword">else</span><font></font>
    speed = Util.accelerate(speed, decel, dt);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (((playerX &lt; <span class="hljs-number">-1</span>) || (playerX &gt; <span class="hljs-number">1</span>)) &amp;&amp; (speed &gt; offRoadLimit))<font></font>
    speed = Util.accelerate(speed, offRoadDecel, dt);<font></font>
<font></font>
  playerX = Util.limit(playerX, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>);     <span class="hljs-comment">// dont ever let player go too far out of bounds</span>
  speed   = Util.limit(speed, <span class="hljs-number">0</span>, maxSpeed); <span class="hljs-comment">// or exceed maxSpeed</span><font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Do not worry, it will become much more difficult when in the finished version we add sprites and collision recognition.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road geometry</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before we can render the game world, we need to build an array of </font></font><code>segments</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in in the method </font></font><code>resetRoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each of these segments of the road will ultimately be projected from its world coordinates so that it turns into a 2d polygon in screen coordinates. </font><font style="vertical-align: inherit;">For each segment, we store two points, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the center of the edge closest to the camera, and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the center of the edge farthest from the camera.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53a/fa4/076/53afa40768a00b49833703b1457a6941.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Strictly speaking, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2 of</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> each segment is identical to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1 of the</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> previous segment, but it seems to me that it is easier to store them as separate points and convert each segment separately. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We keep separate </font></font><code>rumbleLength</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">because we can have beautiful detailed curves and hills, but at the same time horizontal stripes. If each subsequent segment has a different color, then this will create a bad strobe effect. Therefore, we want to have many small segments, but group them together to form separate horizontal stripes.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetRoad</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments = [];<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span> ; n &lt; <span class="hljs-number">500</span> ; n++) { <span class="hljs-comment">// arbitrary road length</span><font></font>
    segments.push({<font></font>
       <span class="hljs-attr">index</span>: n,
       <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
       <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
       <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
    });<font></font>
  }<font></font>
<font></font>
  trackLength = segments.length * segmentLength;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We initialize </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> only with world coordinates </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , because we only need straight roads. The </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinates </font><font style="vertical-align: inherit;">will always be 0, and the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinates </font><font style="vertical-align: inherit;">will always depend on the scaled value </font></font><code>+/- roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Later, when we add curves and hills, this part will change. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will also set empty objects to store representations of these points in the camera and on the screen so as not to create a bunch of temporary objects in each </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. To minimize garbage collection, we must avoid allocating objects within the game loop.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When the car reaches the end of the road, we simply return to the beginning of the cycle. </font><font style="vertical-align: inherit;">To simplify this, we will create a method to find a segment for any value of Z, even if it goes beyond the length of the road:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSegment</span>(<span class="hljs-params">z</span>) </span>{
  <span class="hljs-keyword">return</span> segments[<span class="hljs-built_in">Math</span>.floor(z/segmentLength) % segments.length];<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Background rendering</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The method </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">begins by rendering the background image. </font><font style="vertical-align: inherit;">In the following parts, where we will add curves and hills, we will need the background to perform parallax scrolling, so we will now begin to move in this direction, rendering the background as three separate layers:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>{<font></font>
<font></font>
  ctx.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<font></font>
<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.SKY);<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.HILLS);<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.TREES);<font></font>
<font></font>
  ...</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road rendering</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then, the render function iterates through all the segments and projects </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2 of</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> each segment from world coordinates to screen coordinates, trimming the segment if necessary, and otherwise rendering it:</font></font><br>
<br>
<pre><code class="javascript hljs">  <span class="hljs-keyword">var</span> baseSegment = findSegment(position);
  <span class="hljs-keyword">var</span> maxy        = height;
  <span class="hljs-keyword">var</span> n, segment;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
    segment = segments[(baseSegment.index + n) % segments.length];<font></font>
<font></font>
    Util.project(segment.p1, (playerX * roadWidth), cameraHeight, position, cameraDepth, width, height, roadWidth);<font></font>
    Util.project(segment.p2, (playerX * roadWidth), cameraHeight, position, cameraDepth, width, height, roadWidth);<font></font>
<font></font>
    <span class="hljs-keyword">if</span> ((segment.p1.camera.z &lt;= cameraDepth) || <span class="hljs-comment">// behind us</span>
        (segment.p2.screen.y &gt;= maxy))          <span class="hljs-comment">// clip by (already rendered) segment</span>
      <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
    Render.segment(ctx, width, lanes,<font></font>
                   segment.p1.screen.x,<font></font>
                   segment.p1.screen.y,<font></font>
                   segment.p1.screen.w,<font></font>
                   segment.p2.screen.x,<font></font>
                   segment.p2.screen.y,<font></font>
                   segment.p2.screen.w,<font></font>
                   segment.color);<font></font>
<font></font>
    maxy = segment.p2.screen.y;<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Above, we have already seen the calculations necessary for projecting a point; The javascript version combines transformation, projection and scaling into one method:</font></font><br>
<br>
<pre><code class="javascript hljs">project: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth</span>) </span>{<font></font>
  p.camera.x     = (p.world.x || <span class="hljs-number">0</span>) - cameraX;<font></font>
  p.camera.y     = (p.world.y || <span class="hljs-number">0</span>) - cameraY;<font></font>
  p.camera.z     = (p.world.z || <span class="hljs-number">0</span>) - cameraZ;<font></font>
  p.screen.scale = cameraDepth/p.camera.z;<font></font>
  p.screen.x     = <span class="hljs-built_in">Math</span>.round((width/<span class="hljs-number">2</span>)  + (p.screen.scale * p.camera.x  * width/<span class="hljs-number">2</span>));<font></font>
  p.screen.y     = <span class="hljs-built_in">Math</span>.round((height/<span class="hljs-number">2</span>) - (p.screen.scale * p.camera.y  * height/<span class="hljs-number">2</span>));<font></font>
  p.screen.w     = <span class="hljs-built_in">Math</span>.round(             (p.screen.scale * roadWidth   * width/<span class="hljs-number">2</span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to calculating the screen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for each point </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we use the same projection calculations to calculate the projected width ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) of the segment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having the screen coordinates </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y of</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> points </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as well as the projected width of the road </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we can quite easily calculate with the help of an auxiliary function </font></font><code>Render.segment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all the polygons necessary for rendering grass, road, horizontal stripes and dividing lines, using the general auxiliary function </font></font><code>Render.polygon</code> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(see . </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Car rendering</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, the last thing the method needs </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a Ferrari rendering:</font></font><br>
<br>
<pre><code class="javascript hljs">  Render.player(ctx, width, height, resolution, roadWidth, sprites, speed/maxSpeed,<font></font>
                cameraDepth/playerZ,<font></font>
                width/<span class="hljs-number">2</span>,<font></font>
                height);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This method is called </font></font><code>player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and not </font></font><code>car</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because in the final version of the game there will be other cars on the road, and we want to separate the player's Ferrari from other cars. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The helper function </font></font><code>Render.player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uses the canvas method called </font></font><code>drawImage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to render the sprite, having previously scaled it using the same projection scaling that was used before:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Where </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in this case is the relative distance from the machine to the camera, stored in the variable </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playerZ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, the function ‚Äúshakes‚Äù the car a little at high speeds, adding a bit of randomness to the scaling equation, depending on </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speed / maxSpeed</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And here is what we got:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/845/dfd/3e8/845dfd3e88ef0a22b2c9fd021140ff3b.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We did a fairly large amount of work just to create a system with straight roads. </font><font style="vertical-align: inherit;">We added</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generic helper module </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dom</font></font></strong></li>
<li><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">Util</font></strong><font style="vertical-align: inherit;"> general math module</font></font><strong><font style="vertical-align: inherit;"></font></strong></li>
<li><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> general canvas helper module </font><font style="vertical-align: inherit;">...</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... including </font></font><code>Render.segment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Render.polygon</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>Render.sprite</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fixed pitch game cycle</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">image downloader</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keyboard handler</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parallax background</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sprite sheet with cars, trees and billboards</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rudimentary geometry of the road</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for controlling the machine</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for rendering background, road and player‚Äôs car</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTML5 tag </font></font><code>&lt;audio&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with racing music (hidden bonus!)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... which gave us a good foundation for further development.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 2. Curves.</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/c3d/6d1/98fc3d6d13cc16f12847d253e112fcb2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this part, we will explain in more detail how curves work. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the previous part, we compiled the geometry of the road in the form of an array of segments, each of which has world coordinates that are transformed relative to the camera and then projected onto the screen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We needed only the world coordinate </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for each point, because on straight roads both </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> were equal to zero.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c78/551/359/c78551359ef7c11e4af48b4285d61842.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we were to create a fully functional 3d system, we could implement the curves by calculating the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stripes of the polygons shown above. However, this type of geometry will be rather difficult to calculate, and for this it will be necessary to add the 3d-rotation stage to the projection equations ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... if we went this way, it would be better to use WebGL or its analogues, but this project does not have other tasks for our project. We just want to use old-school pseudo-three-dimensional tricks to simulate curves. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, you will probably be surprised to learn that we will not calculate the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinates </font><font style="vertical-align: inherit;">of the road segments at all ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instead, we will use </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lu‚Äôs advice</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúTo curve the road, simply change the position of the center line of the curve shape ... starting from the bottom of the screen, the amount of shift of the center of the road left or right gradually increases</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><em><font style="vertical-align: inherit;">‚Äù</font></em></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our case, the center line is the value </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passed to the projection calculations. </font><font style="vertical-align: inherit;">This means that when we perform </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">each segment of the road, you can simulate the curves by shifting the value </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by a gradually increasing value.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8a/569/19e/c8a56919e67d6f19cc737074ce92fffb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To know how much to shift, we need to store a value in each segment </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This value indicates how much the segment should be shifted from the center line of the camera. </font><font style="vertical-align: inherit;">She will be:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">negative for left-turning curves</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">positive for curves turning right</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">less for smooth curves</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">more for sharp curves</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The values ‚Äã‚Äãthemselves are chosen quite arbitrarily; </font><font style="vertical-align: inherit;">through trial and error, we can find good values ‚Äã‚Äãat which the curves seem to be ‚Äúcorrect‚Äù:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> ROAD = {
  <span class="hljs-attr">LENGTH</span>: { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">SHORT</span>:  <span class="hljs-number">25</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">50</span>, <span class="hljs-attr">LONG</span>:  <span class="hljs-number">100</span> }, <span class="hljs-comment">// num segments</span>
  <span class="hljs-attr">CURVE</span>:  { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">EASY</span>:    <span class="hljs-number">2</span>, <span class="hljs-attr">MEDIUM</span>:   <span class="hljs-number">4</span>, <span class="hljs-attr">HARD</span>:    <span class="hljs-number">6</span> }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to choosing good values ‚Äã‚Äãfor the curves, we need to avoid any gaps in the transitions when the line turns into a curve (or vice versa). </font><font style="vertical-align: inherit;">This can be achieved by </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">softening</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when entering and exiting the curves. </font><font style="vertical-align: inherit;">We will do this by gradually increasing (or decreasing) the value </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for each segment using traditional smoothing functions until it reaches the desired value:</font></font><br>
<br>
<pre><code class="javascript hljs">easeIn:    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*<span class="hljs-built_in">Math</span>.pow(percent,<span class="hljs-number">2</span>);                           },
<span class="hljs-attr">easeOut</span>:   <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*(<span class="hljs-number">1</span>-<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">1</span>-percent,<span class="hljs-number">2</span>));                     },
<span class="hljs-attr">easeInOut</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*((-<span class="hljs-built_in">Math</span>.cos(percent*<span class="hljs-built_in">Math</span>.PI)/<span class="hljs-number">2</span>) + <span class="hljs-number">0.5</span>);        },</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, now, taking into account the function of adding one segment to the geometry ...</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params">curve</span>) </span>{
  <span class="hljs-keyword">var</span> n = segments.length;<font></font>
  segments.push({<font></font>
     <span class="hljs-attr">index</span>: n,
        <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
        <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
     <span class="hljs-attr">curve</span>: curve,
     <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
we can create a method for smooth entry, finding and smooth exit from a curved road:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoad</span>(<span class="hljs-params">enter, hold, leave, curve</span>) </span>{
  <span class="hljs-keyword">var</span> n;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; enter ; n++)<font></font>
    addSegment(Util.easeIn(<span class="hljs-number">0</span>, curve, n/enter));
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; hold  ; n++)<font></font>
    addSegment(curve);<font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; leave ; n++)<font></font>
    addSegment(Util.easeInOut(curve, <span class="hljs-number">0</span>, n/leave));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... and on top you can impose additional geometry, for example, S-shaped curves:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSCurves</span>(<span class="hljs-params"></span>) </span>{<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.MEDIUM);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.MEDIUM);<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changes to the update () Method</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The only changes that need to be made to the method </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are the application of a kind of centrifugal force when the machine moves along a curve. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We set an arbitrary factor that can be adjusted according to our preferences.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> centrifugal = <span class="hljs-number">0.3</span>;   <span class="hljs-comment">// centrifugal force multiplier when going around curves</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And then we will just update the position </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">based on its current speed, curve value and centrifugal force multiplier:</font></font><br>
<br>
<pre><code class="javascript hljs">playerX = playerX - (dx * speedPercent * playerSegment.curve * centrifugal);</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curve rendering</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We said above that you can render simulated curves by shifting the value </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used in projection calculations during the execution of </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">each road segment.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8a/569/19e/c8a56919e67d6f19cc737074ce92fffb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To do this, we will store the drive variable </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , increasing for each segment by a value </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as well as the variable </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which will be used as the offset of the value </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used in projection calculations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To implement the curves, we need the following:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shift the projection </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1 of</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> each segment by </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shift the projection </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2 of</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> each segment by </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">increase </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the next segment by </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, in order to avoid torn transitions when crossing the boundaries of segments, we must make </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> initialized with the interpolated value of the curve of the current base segments. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Change the method </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as follows:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> baseSegment = findSegment(position);
<span class="hljs-keyword">var</span> basePercent = Util.percentRemaining(position, segmentLength);
<span class="hljs-keyword">var</span> dx = - (baseSegment.curve * basePercent);
<span class="hljs-keyword">var</span> x  = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
  ...<font></font>
<font></font>
  Util.project(segment.p1, (playerX * roadWidth) - x,      cameraHeight, position - (segment.looped ? trackLength : <span class="hljs-number">0</span>), cameraDepth, width, height, roadWidth);<font></font>
  Util.project(segment.p2, (playerX * roadWidth) - x - dx, cameraHeight, position - (segment.looped ? trackLength : <span class="hljs-number">0</span>), cameraDepth, width, height, roadWidth);<font></font>
<font></font>
  x  = x + dx;<font></font>
  dx = dx + segment.curve;<font></font>
<font></font>
  ...<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallax Scrolling Background</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, we need to scroll the parallax background layers, storing the offset for each layer ...</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> skySpeed    = <span class="hljs-number">0.001</span>; <span class="hljs-comment">// background sky layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> hillSpeed   = <span class="hljs-number">0.002</span>; <span class="hljs-comment">// background hill layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> treeSpeed   = <span class="hljs-number">0.003</span>; <span class="hljs-comment">// background tree layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> skyOffset   = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current sky scroll offset</span>
<span class="hljs-keyword">var</span> hillOffset  = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current hill scroll offset</span>
<span class="hljs-keyword">var</span> treeOffset  = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current tree scroll offset</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... and increasing it during time </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depending on the curve value of the current player segment and its speed ...</font></font><br>
<br>
<pre><code class="javascript hljs">skyOffset  = Util.increase(skyOffset,  skySpeed  * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);<font></font>
hillOffset = Util.increase(hillOffset, hillSpeed * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);<font></font>
treeOffset = Util.increase(treeOffset, treeSpeed * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... and then use to use this offset when doing </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">background layers.</font></font><br>
<br>
<pre><code class="javascript hljs">Render.background(ctx, background, width, height, BACKGROUND.SKY,   skyOffset);<font></font>
Render.background(ctx, background, width, height, BACKGROUND.HILLS, hillOffset);<font></font>
Render.background(ctx, background, width, height, BACKGROUND.TREES, treeOffset);</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, here we get the fake pseudo-three-dimensional curves:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/c3d/6d1/98fc3d6d13cc16f12847d253e112fcb2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main part of the code that we added is to build the geometry of the road with the corresponding value </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Realizing it, adding centrifugal force during the time is </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">much easier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Curve rendering is performed in just a few lines of code, but it can be difficult to understand (and describe) what exactly is happening here. There are many ways to simulate curves and it is very easy to wander when they are implemented into a dead end. It is even easier to get carried away with an outside task and try to do everything ‚Äúcorrectly‚Äù; before you realize this, you will begin to create a fully functional 3d-system with matrices, rotations and real 3d-geometry ... which, as I said, is not our task.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When I wrote this article, I was sure that there definitely were problems in my implementation of the curves. </font><font style="vertical-align: inherit;">Trying to visualize the algorithm, I did not understand why I needed two values ‚Äã‚Äãof the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> drives </font><font style="vertical-align: inherit;">instead of one ... and if I can‚Äôt fully explain something, then something went wrong somewhere ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... but the project‚Äôs time </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúon the weekend ‚Äùhas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> almost expired, and, frankly, the curves seem to me quite beautiful, and in the end, this is the most important.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en499240/index.html">Through thorns to the stars, or data analysis in the affairs of heaven</a></li>
<li><a href="../en499242/index.html">Researchers transmitted data from a desktop PC through vibrations across a table</a></li>
<li><a href="../en499244/index.html">Synergetic organizations. Part II</a></li>
<li><a href="../en499246/index.html">Investigation of the logistic function as a law of industry development</a></li>
<li><a href="../en499248/index.html">How we recognize personal protective equipment</a></li>
<li><a href="../en499254/index.html">PyConRu 2020 Program Committee Member answers questions about Python: an up-to-date look and a bit of parseltang</a></li>
<li><a href="../en499262/index.html">Final online hackathon for self-employed SMZhack: projects that will hit the people</a></li>
<li><a href="../en499268/index.html">Spatial awareness: what can Hololens glasses do?</a></li>
<li><a href="../en499272/index.html">Soldering components 0201. Nervous, please move away from the screens</a></li>
<li><a href="../en499274/index.html">We disassembled the new Capsule. We know how many microphones and how it works</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>