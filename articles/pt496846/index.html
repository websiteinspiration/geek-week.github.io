<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕯️ 👨 💬 Mecânica da linguagem de pilhas e ponteiros 〰️ 👩🏻‍🤝‍👨🏼 🌧️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prelúdio
 Este é o primeiro dos quatro artigos da série que fornecerá informações sobre a mecânica e o design de ponteiros, pilhas, pilhas, análise de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Mecânica da linguagem de pilhas e ponteiros</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496846/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prelúdio</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este é o primeiro dos quatro artigos da série que fornecerá informações sobre a mecânica e o design de ponteiros, pilhas, pilhas, análise de escape e semântica de Go / ponteiro. </font><font style="vertical-align: inherit;">Este post é sobre pilhas e indicadores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Índice:</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mecânica da linguagem em pilhas e ponteiros</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mecânica da linguagem na análise de escape</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tradução</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mecânica da linguagem no perfil de memória</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filosofia de Design em Dados e Semântica</font></font></a></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introdução</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não vou dissimular - os ponteiros são difíceis de entender. </font><font style="vertical-align: inherit;">Se usados ​​incorretamente, os ponteiros podem causar erros desagradáveis ​​e até problemas de desempenho. </font><font style="vertical-align: inherit;">Isto é especialmente verdade ao escrever programas competitivos ou multithread. </font><font style="vertical-align: inherit;">Não é de surpreender que muitas linguagens tentem ocultar indicadores de programadores. </font><font style="vertical-align: inherit;">No entanto, se você escrever no Go, não poderá escapar dos ponteiros. </font><font style="vertical-align: inherit;">Sem uma compreensão clara dos ponteiros, será difícil escrever código limpo, simples e eficiente.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bordas do quadro</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As funções são executadas dentro dos limites dos quadros que fornecem um espaço de memória separado para cada função correspondente. Cada quadro permite que a função funcione em seu próprio contexto e também fornece controle de fluxo. Uma função tem acesso direto à memória dentro de seu quadro por meio de um ponteiro, mas o acesso à memória fora do quadro requer acesso indireto. Para uma função acessar a memória fora de seu quadro, essa memória deve ser usada em conjunto com esta função. A mecânica e as limitações estabelecidas por esses limites devem ser entendidas e estudadas primeiro.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando uma função é chamada, ocorre uma transição entre dois quadros. O código vai do quadro da função de chamada para o quadro da função chamada. Se os dados forem necessários para chamar a função, esses dados deverão ser transferidos de um quadro para outro. A transferência de dados entre dois quadros no Go é feita "por valor". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A vantagem da transmissão de dados "por valor" é a legibilidade. O valor que você vê na chamada de função é o que é copiado e aceito no outro lado. É por isso que associo "passar por valor" a WYSIWYG, porque o que você vê é o que recebe. Tudo isso permite que você escreva um código que não oculte o custo de alternar entre duas funções. Isso ajuda a manter um bom modelo mental de como cada chamada de função afetará o programa durante a transição.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veja este pequeno programa que chama uma função passando dados inteiros "por valor": </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 1:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">04</span>
<span class="hljs-number">05</span>    <span class="hljs-comment">// Declare variable of type int with a value of 10.</span>
<span class="hljs-number">06</span>    count := <span class="hljs-number">10</span>
<span class="hljs-number">07</span>
<span class="hljs-number">08</span>    <span class="hljs-comment">// Display the "value of" and "address of" count.</span>
<span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>    <span class="hljs-comment">// Pass the "value of" the count.</span>
<span class="hljs-number">12</span>    increment(count)
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">15</span> }
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc <span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">19</span>
<span class="hljs-number">20</span>    <span class="hljs-comment">// Increment the "value of" inc.</span>
<span class="hljs-number">21</span>    inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]"</span>)
<span class="hljs-number">23</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando o programa Go é iniciado, o tempo de execução cria a goroutine principal para começar a executar todo o código, incluindo o código dentro da função principal. Gorutin é o caminho de execução que se encaixa no encadeamento do sistema operacional, que finalmente roda em algum kernel. A partir da versão 1.8, cada goroutine é fornecida com um bloco inicial de memória contínua de 2048 bytes de tamanho, que forma o espaço da pilha. Esse tamanho inicial da pilha mudou ao longo dos anos e pode mudar no futuro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pilha é importante porque fornece espaço de memória física para os limites do quadro que são atribuídos a cada função individual. No momento em que a goroutine principal executa a função principal na Listagem 1, a pilha de programas (em um nível muito alto) terá a seguinte aparência: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figura 1:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z4/7w/l0/z47wl0tm16nh5u-gf8u9m0kemba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na Figura 1, você pode ver que parte da pilha foi "emoldurada" para a função principal. </font><font style="vertical-align: inherit;">Esta seção é chamada de " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quadro de pilha</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " e é esse quadro que denota o limite da função principal na pilha. </font><font style="vertical-align: inherit;">O quadro é definido como parte do código que é executado quando a função é chamada. </font><font style="vertical-align: inherit;">Você também pode ver que a memória da variável count foi alocada em 0x10429fa4 dentro do quadro para main. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há outro ponto interessante, ilustrado na Figura 1. Toda a memória da pilha sob o quadro ativo não é válida, mas a memória do quadro ativo e acima é válida. </font><font style="vertical-align: inherit;">Você precisa entender claramente o limite entre a parte válida e inválida da pilha.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endereços</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As variáveis ​​são usadas para atribuir um nome a uma célula de memória específica para melhorar a legibilidade do código e ajudá-lo a entender com quais dados você está trabalhando. </font><font style="vertical-align: inherit;">Se você tiver uma variável, terá um valor na memória e, se tiver um valor na memória, ele deverá ter um endereço. </font><font style="vertical-align: inherit;">Na linha 09, a função principal chama a função println interna para exibir o "valor" e o "endereço" da variável count. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 2:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O uso do "e" comercial "&amp;" para obter o endereço da localização de uma variável não é novo, outros idiomas também usam esse operador. </font><font style="vertical-align: inherit;">A saída da linha 09 deve se parecer com a saída abaixo se você estiver executando o código em uma arquitetura de 32 bits como o Go Playground: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 3:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chamada de Função</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, na linha 12, a função principal chama a função de incremento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 4:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">12</span>    increment(count)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fazer uma chamada de função significa que o programa deve criar uma nova seção de memória na pilha. No entanto, tudo é um pouco mais complicado. Para concluir com êxito uma chamada de função, espera-se que os dados sejam transferidos através do limite do quadro e colocados em um novo quadro durante a transição. Em particular, espera-se que um valor inteiro seja copiado e transmitido durante a chamada. Você pode ver esse requisito observando a declaração da função de incremento na linha 18. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 5:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc <span class="hljs-keyword">int</span>)</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você olhar novamente para a chamada da função de incremento na linha 12, verá que o código passa o "valor" da contagem de variáveis. Este valor será copiado, transferido e colocado em um novo quadro para a função de incremento. Lembre-se de que a função de incremento só pode ler e gravar na memória em seu próprio quadro; portanto, é necessário que a variável inc receba, armazene e acesse sua própria cópia do valor do contador transmitido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pouco antes do código dentro da função de incremento começar a ser executado, a pilha do programa (em um nível muito alto) terá a seguinte aparência: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figura 2:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2g/jw/n9/2gjwn96mbhikaxys6ftv3cf4s14.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode ver que agora existem dois quadros na pilha - um para o principal e um abaixo para o incremento. </font><font style="vertical-align: inherit;">Dentro do quadro para incremento, você pode ver a variável inc contendo o valor 10, que foi copiado e passado durante a chamada de função. </font><font style="vertical-align: inherit;">O endereço da variável inc é 0x10429f98 e tem menos memória porque os quadros são colocados na pilha, que são apenas detalhes de implementação que não significam nada. </font><font style="vertical-align: inherit;">O importante é que o programa recuperou o valor da contagem do quadro para main e colocou uma cópia desse valor no quadro para aumentar usando a variável inc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O restante do código dentro do incremento é incrementado e exibe o "valor" e o "endereço" da variável inc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 6:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">21</span>    inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A saída da linha 22 no playground deve ser algo como isto: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 7:</font></font><br>
<br>
<pre><code class="go hljs">inc:    Value Of[ <span class="hljs-number">11</span> ]  Addr Of[ <span class="hljs-number">0x10429f98</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está a aparência da pilha após executar as mesmas linhas de código: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figura 3: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/59/1o/kv/591okvkseze5gjqum4k8hp-qv34.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Após executar as linhas 21 e 22, a função de incremento termina e retorna o controle para a função principal. </font><font style="vertical-align: inherit;">Em seguida, a função principal novamente exibe o "valor" e o "endereço" da contagem da variável local na linha 14. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 8:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>,count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A saída completa do programa no playground deve ser algo como isto: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 9:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]<font></font>
inc:    Value Of[ <span class="hljs-number">11</span> ]  Addr Of[ <span class="hljs-number">0x10429f98</span> ]<font></font>
count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O valor da contagem no quadro para main é o mesmo antes e depois da chamada para incrementar.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retorno de funções</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que realmente acontece com a memória na pilha quando a função sai e o controle retorna à função de chamada? A resposta curta não é nada. Aqui está a aparência da pilha após o retorno da função de incremento: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figura 4: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qq/ve/-n/qqve-nygmg0jnhsnwrubpchwfky.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pilha parece exatamente a mesma da Figura 3, exceto que o quadro associado à função de incremento agora é considerado memória inválida. Isso ocorre porque o quadro para main agora está ativo. A memória criada para a função de incremento permaneceu intocada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A limpeza do quadro de memória da função de retorno será uma perda de tempo, porque não se sabe se essa memória será necessária novamente. </font><font style="vertical-align: inherit;">Então a memória permaneceu do jeito que estava. </font><font style="vertical-align: inherit;">Durante cada chamada de função, quando um quadro é capturado, a memória da pilha para esse quadro é limpa. </font><font style="vertical-align: inherit;">Isso é feito inicializando quaisquer valores que se ajustem ao quadro. </font><font style="vertical-align: inherit;">Como todos os valores são inicializados como seu "valor zero", as pilhas são limpas corretamente a cada chamada de função.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partilha de Valor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E se fosse importante para a função de incremento trabalhar diretamente com a variável count que existe dentro do quadro para main? </font><font style="vertical-align: inherit;">É aqui que chega a hora dos ponteiros. </font><font style="vertical-align: inherit;">Os ponteiros têm um propósito - compartilhar um valor com uma função para que a função possa ler e gravar esse valor, mesmo que o valor não exista diretamente dentro de seu quadro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você acha que não precisa "compartilhar" o valor, não precisa usar um ponteiro. </font><font style="vertical-align: inherit;">Ao aprender dicas, é importante pensar que usando um dicionário limpo, não operadores ou sintaxe. </font><font style="vertical-align: inherit;">Lembre-se de que os ponteiros devem ser compartilhados e, ao ler o código, substitua o operador &amp; pela frase "compartilhamento".</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipos de ponteiros</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para cada tipo que você declarou ou que foi declarado diretamente pelo próprio idioma, você obtém um tipo de ponteiro gratuito que pode ser usado para compartilhar. Já existe um tipo interno chamado int, portanto, existe um tipo de ponteiro chamado * int. Se você declarar um tipo chamado Usuário, receberá um tipo de ponteiro chamado * Usuário gratuitamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos os tipos de ponteiros têm duas características idênticas. Primeiro, eles começam com o caractere *. Em segundo lugar, todos eles têm o mesmo tamanho na memória e uma representação ocupando 4 ou 8 bytes que representam o endereço. Em arquiteturas de 32 bits (por exemplo, no playground), os ponteiros requerem 4 bytes de memória e, em arquiteturas de 64 bits (por exemplo, no seu computador), exigem 8 bytes de memória. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na especificação, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipos de ponteiro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">são considerados </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">literais de tipo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o que significa que são tipos sem nome compostos de um tipo existente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acesso indireto à memória</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veja este pequeno programa que faz uma chamada de função, passando o endereço "por valor". </font><font style="vertical-align: inherit;">Isso dividirá a variável count do quadro da pilha principal com a função de incremento: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 10:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">04</span>
<span class="hljs-number">05</span>    <span class="hljs-comment">// Declare variable of type int with a value of 10.</span>
<span class="hljs-number">06</span>    count := <span class="hljs-number">10</span>
<span class="hljs-number">07</span>
<span class="hljs-number">08</span>    <span class="hljs-comment">// Display the "value of" and "address of" count.</span>
<span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\t\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>    <span class="hljs-comment">// Pass the "address of" count.</span>
<span class="hljs-number">12</span>    increment(&amp;count)
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\t\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">15</span> }
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc *<span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">19</span>
<span class="hljs-number">20</span>    <span class="hljs-comment">// Increment the "value of" count that the "pointer points to". (dereferencing)</span>
<span class="hljs-number">21</span>    *inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]\tValue Points To["</span>, *inc, <span class="hljs-string">"]"</span>)
<span class="hljs-number">23</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Três mudanças interessantes foram feitas no programa original. </font><font style="vertical-align: inherit;">A primeira alteração está na linha 12: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 11:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">12</span>    increment(&amp;count)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desta vez, na linha 12, o código não copia e passa o "valor" para a variável count, mas passa a contagem para o seu "endereço". Agora você pode dizer: "Estou compartilhando" a contagem de variáveis ​​com o incremento da função. É isso que o operador &amp; diz: "compartilhar". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entenda que isso ainda está "passando por valor" e a única diferença é que o valor que você passa é o endereço, não o número inteiro. Endereços também são valores; é isso que é copiado e passado através da borda do quadro para chamar a função. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como o valor do endereço é copiado e passado, você precisa de uma variável dentro do quadro de incremento para obter e salvar esse endereço inteiro. Uma declaração de variável de ponteiro inteiro está na linha 18. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 12:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc *<span class="hljs-keyword">int</span>)</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você passou o endereço do valor do tipo Usuário, a variável teria que ser declarada como * Usuário. Apesar de todas as variáveis ​​de ponteiro armazenarem valores de endereço, elas não podem receber nenhum endereço, apenas endereços associados ao tipo de ponteiro. O princípio básico de compartilhamento de um valor é que a função de recebimento deve ler ou gravar nesse valor. Você precisa de informações sobre o tipo de qualquer valor para ler e gravar nele. O compilador garantirá que apenas os valores associados ao tipo de ponteiro correto sejam usados ​​com esta função. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está a aparência da pilha depois de chamar a função de incremento: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figura 5:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uk/ak/zj/ukakzj1mpr_9m3thjmv2i04e_hw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A Figura 5 mostra a aparência da pilha quando a "passagem por valor" é realizada usando o endereço como valor. A variável de ponteiro dentro do quadro para a função de incremento agora aponta para a variável de contagem, localizada dentro do quadro para principal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, usando a variável ponteiro, a função pode executar uma operação de leitura e alteração indireta para a variável count localizada dentro do quadro para main. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 13:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">21</span>    *inc++</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desta vez, o caractere * atua como um operador e é aplicado à variável do ponteiro. Usar * como operador significa "o valor que o ponteiro aponta". Uma variável de ponteiro fornece acesso indireto à memória fora do quadro da função que a utiliza. Às vezes, essa leitura ou escrita indireta é chamada de desreferenciamento de ponteiro. A função de incremento ainda precisa ter uma variável de ponteiro em seu quadro, que ela pode ler diretamente para executar o acesso indireto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A Figura 6 mostra a aparência da pilha após a linha 21. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figura 6: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ph/vi/rnphvi1x69rrhspljslmvxilauq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está a saída final deste programa: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listagem 14:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]              Addr Of[ <span class="hljs-number">0x10429fa4</span> ]<font></font>
inc:    Value Of[ <span class="hljs-number">0x10429fa4</span> ]      Addr Of[ <span class="hljs-number">0x10429f98</span> ]   Value Points To[ <span class="hljs-number">11</span> ]<font></font>
count:  Value Of[ <span class="hljs-number">11</span> ]              Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode perceber que o "valor" da variável inc ponteiro corresponde ao "endereço" da variável count. </font><font style="vertical-align: inherit;">Isso estabelece um relacionamento de compartilhamento que permite acesso indireto à memória fora do quadro. </font><font style="vertical-align: inherit;">Assim que a função de incremento grava no ponteiro, a alteração fica visível para a função principal quando o controle é retornado a ela.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variáveis ​​de ponteiro não são especiais</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Variáveis ​​de ponteiro não são especiais porque são as mesmas variáveis ​​que qualquer outra variável. </font><font style="vertical-align: inherit;">Eles têm uma alocação de memória e contêm significado. </font><font style="vertical-align: inherit;">Aconteceu que todas as variáveis ​​de ponteiro, independentemente do tipo de valor para o qual possam apontar, sempre têm o mesmo tamanho e apresentação. </font><font style="vertical-align: inherit;">O que pode ser confuso é que o caractere * atua como um operador dentro do código e é usado para declarar um tipo de ponteiro. </font><font style="vertical-align: inherit;">Se você pode distinguir uma declaração de tipo de uma operação de ponteiro, isso pode ajudar a eliminar algumas confusões.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta postagem descreve o objetivo dos ponteiros, a operação da pilha e a mecânica dos ponteiros no Go. </font><font style="vertical-align: inherit;">Este é o primeiro passo para entender a mecânica, os princípios de design e as técnicas de uso necessárias para escrever código coerente e legível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No final, aqui está o que você aprendeu:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As funções são executadas dentro dos limites do quadro, que fornecem um espaço de memória separado para cada função correspondente.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando uma função é chamada, ocorre uma transição entre dois quadros.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A vantagem da transmissão de dados "por valor" é a legibilidade.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pilha é importante porque fornece espaço de memória física para os limites do quadro que são atribuídos a cada função individual.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toda a memória da pilha abaixo do quadro ativo é inválida, mas a memória do quadro ativo e acima é válida.</font></font></li>
<li>   ,         .</li>
<li>    ,   ,      .</li>
<li>    —    ,        ,         .</li>
<li>   ,  ,   ,     ,      .</li>
<li>-          ,   .</li>
<li>-   - ,      ,     .     ,    .</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt496832/index.html">Tour fotográfico: o que eles estão fazendo no laboratório de nanofotônica híbrida e optoeletrônica do New Physics Institute ITMO</a></li>
<li><a href="../pt496836/index.html">QSerializer: solução para serialização JSON / XML simples</a></li>
<li><a href="../pt496838/index.html">Metodologia de implantação de projeto usada pelo Slack</a></li>
<li><a href="../pt496840/index.html">Musk acredita que 12 mil satélites não interferirão nos astrônomos. Sua opinião não é consistente com o modelo</a></li>
<li><a href="../pt496842/index.html">Um modelo epidêmico simples com ferramentas básicas de Python</a></li>
<li><a href="../pt496848/index.html">O resumo de materiais interessantes para o desenvolvedor móvel nº 340 (de 6 a 12 de abril)</a></li>
<li><a href="../pt496850/index.html">Plugin Maven para JPackage a partir de Java 14</a></li>
<li><a href="../pt496852/index.html">Classificação suave</a></li>
<li><a href="../pt496856/index.html">Casa inteligente sem controles remotos, mas com um cubo</a></li>
<li><a href="../pt496858/index.html">FOSS News No. 11 - uma revisão do software livre e de código aberto de 6 a 12 de abril de 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>