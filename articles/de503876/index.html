<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📦 😐 ⛅️ Programmieren eines Spiels für ein eingebettetes Gerät auf ESP32: Laufwerk, Akku, Sound 🧖🏼 👩🏼‍🤝‍👨🏿 ✍🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Start: Montagesystem, Eingabe, Anzeige .
 
 Teil 4: fahren
 Odroid Go verfügt über einen microSD-Kartensteckplatz, der zum Herunterladen von Ressource...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programmieren eines Spiels für ein eingebettetes Gerät auf ESP32: Laufwerk, Akku, Sound</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503876/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/800/42e/44b80042e94aa2f2da9da2d2296461ad.jpg" alt="Bild"></div><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start: Montagesystem, Eingabe, Anzeige</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 4: fahren</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go verfügt über einen microSD-Kartensteckplatz, der zum Herunterladen von Ressourcen (Sprites, Sounddateien, Schriftarten) und möglicherweise sogar zum Speichern des Spielstatus nützlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Kartenleser ist über SPI verbunden, aber IDF erleichtert die Interaktion mit der SD-Karte, indem SPI-Anrufe abstrahiert und Standard- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POSIX-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktionen </font><font style="vertical-align: inherit;">wie </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fopen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fread</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fwrite verwendet werden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . All dies basiert auf der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FatFs-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek </font><font style="vertical-align: inherit;">, daher muss die SD-Karte im Standard-FAT-Format formatiert sein.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist mit demselben SPI-Bus wie das LCD verbunden, verwendet jedoch eine andere Chipauswahlleitung. </font><font style="vertical-align: inherit;">Wenn wir auf die SD-Karte lesen oder schreiben müssen (und dies kommt nicht sehr oft vor), schaltet der SPI-Treiber das CS-Signal vom Display zum SD-Kartenleser und führt dann den Vorgang aus. </font><font style="vertical-align: inherit;">Dies bedeutet, dass beim Senden von Daten an das Display keine Vorgänge mit der SD-Karte ausgeführt werden können und umgekehrt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Moment machen wir alles in einem Thread und blockieren die Übertragung über SPI zum Display, sodass keine gleichzeitigen Transaktionen mit der SD-Karte und dem LCD-Display möglich sind. </font><font style="vertical-align: inherit;">In jedem Fall besteht eine hohe Wahrscheinlichkeit, dass wir alle Ressourcen zum Startzeitpunkt laden.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Änderung von ESP-IDF</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir versuchen, die Schnittstelle der SD-Karte nach der Initialisierung des Displays zu initialisieren, tritt ein Problem auf, das das Laden von Odroid Go unmöglich macht. </font><font style="vertical-align: inherit;">ESP-IDF v4.0 unterstützt bei Verwendung mit einer SD-Karte keinen gemeinsamen Zugriff auf den SPI-Bus. </font><font style="vertical-align: inherit;">Vor kurzem haben Entwickler diese Funktionalität hinzugefügt, sie befindet sich jedoch noch nicht in einer stabilen Version. Daher werden wir die IDF selbst geringfügig ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kommentieren Sie die Zeile 303 aus. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esp-idf / components / driver / sdspi_host.c</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Initialize SPI bus</span>
<span class="hljs-keyword">esp_err_t</span> ret = spi_bus_initialize((<span class="hljs-keyword">spi_host_device_t</span>)slot, &amp;buscfg,<font></font>
    slot_config-&gt;dma_channel);<font></font>
<span class="hljs-keyword">if</span> (ret != ESP_OK) {<font></font>
    ESP_LOGD(TAG, <span class="hljs-string">"spi_bus_initialize failed with rc=0x%x"</span>, ret);
    <span class="hljs-comment">//return ret;</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dieser Änderung wird während der Initialisierung immer noch ein Fehler angezeigt, der ESP32 wird jedoch nicht mehr neu gestartet, da sich der Fehlercode oben nicht ausbreitet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierung</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57f/4f8/b0f/57f4f8b0fcca66e243637eeb68b39ff7.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/554/eae/9ec/554eae9ec4a3e850eb44e817e8b7b181.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir müssen IDF mitteilen, welche ESP32-Pins mit dem MicroSD-Lesegerät verbunden sind, damit der zugrunde liegende SPI-Treiber, der tatsächlich mit dem Lesegerät kommuniziert, korrekt konfiguriert wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die allgemeinen Hinweise </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VSPI.XXXX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden wieder im </font><strong><font style="vertical-align: inherit;">Diagramm verwendet</font></strong><font style="vertical-align: inherit;"> , aber wir können sie zu den tatsächlichen Kontaktnummern auf ESP32 durchgehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Initialisierung ähnelt der Initialisierung des LCD, aber anstelle der allgemeinen SPI-Konfigurationsstruktur verwenden wir </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdspi_slot_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das für eine über den SPI-Bus angeschlossene SD-Karte entwickelt wurde. Wir konfigurieren die entsprechenden Kontaktnummern und Kartenmontageeigenschaften im FatFS-System. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der IDF-Dokumentation wird die Verwendung der Funktion </font><strong><font style="vertical-align: inherit;">esp_vfs_fat_sdmmc_mount</font></strong><font style="vertical-align: inherit;"> nicht empfohlen</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Code des fertigen Programms. Dies ist eine Wrapper-Funktion, die für uns viele Operationen ausführt, aber bisher ganz normal funktioniert, und wahrscheinlich wird sich in Zukunft nichts ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Parameter </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"/ sdcard"</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dieser Funktion legt den virtuellen Einhängepunkt der SD-Karte fest, den wir dann bei der Arbeit mit Dateien als Präfix verwenden. Wenn wir eine Datei mit dem Namen "test.txt" auf unserer SD-Karte hätten, wäre der Pfad, den wir zum Verknüpfen verwenden würden, "/sdcard/test.txt". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach der Initialisierung der Schnittstelle der SD-Karte ist die Interaktion mit den Dateien trivial: Wir können einfach Standardaufrufe für </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POSIX-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktionen verwenden </font><font style="vertical-align: inherit;">, was sehr praktisch ist.</font></font><br>
<br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">   8.3</a>,              .    ,   <b>fopen</b>   .        <b>make menuconfig</b>,       ,     <b>8.3</b>.</blockquote><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/62f/94a/d9462f94aeec7fbdce989e34967e637d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich </font><font style="vertical-align: inherit;">habe </font><font style="vertical-align: inherit;">in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aseprite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (schrecklich) ein 64x64-Sprite </font><strong><font style="vertical-align: inherit;">erstellt</font></strong><font style="vertical-align: inherit;"> , das nur zwei Farben verwendet: vollständig schwarz (Pixel deaktiviert) und vollständig weiß (Pixel aktiviert). Aseprite hat nicht die Möglichkeit, RGB565-Farben zu speichern oder als Roh-Bitmap zu exportieren (d. H. Ohne Komprimierung und Bildheader), daher habe ich das Sprite in ein temporäres PNG-Format exportiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann habe </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ich</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit </font><strong><font style="vertical-align: inherit;">ImageMagick</font></strong><font style="vertical-align: inherit;"> die Daten in eine PPM-Datei konvertiert, die das Bild mit einem einfachen Header in unkomprimierte Rohdaten umwandelte. Als nächstes öffnete ich das Bild in einem Hex-Editor, löschte den Header und konvertierte die 24-Bit-Farbe in 16-Bit. Dabei löschte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ich</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alle Vorkommen </font><strong><font style="vertical-align: inherit;">0x000000</font></strong><font style="vertical-align: inherit;"> bis </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und alle Vorkommen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bis </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Bytereihenfolge ist hier kein Problem, da sich </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beim Ändern der Bytereihenfolge nicht ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Rohdatei kann hier heruntergeladen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">FILE* spriteFile = fopen(<span class="hljs-string">"/sdcard/key"</span>, <span class="hljs-string">"r"</span>);<font></font>
assert(spriteFile);<font></font>
<font></font>
<span class="hljs-keyword">uint16_t</span>* sprite = (<span class="hljs-keyword">uint16_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">64</span> * <span class="hljs-number">64</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>));<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i)<font></font>
{<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; ++j)<font></font>
	{<font></font>
		fread(sprite, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>), <span class="hljs-number">64</span> * <span class="hljs-number">64</span>, spriteFile);<font></font>
	}<font></font>
}<font></font>
<font></font>
fclose(spriteFile);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst öffnen wir die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlüsseldatei</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit den Rohbytes und lesen sie in den Puffer ein. </font><font style="vertical-align: inherit;">In Zukunft werden wir Sprite-Ressourcen anders laden, aber für eine Demo ist dies völlig ausreichend.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> spriteRow = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = y; row &lt; y + <span class="hljs-number">64</span>; ++row)<font></font>
{<font></font>
	spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = x; col &lt; x + <span class="hljs-number">64</span>; ++col)<font></font>
	{<font></font>
		<span class="hljs-keyword">uint16_t</span> pixelColor = sprite[<span class="hljs-number">64</span> * spriteRow + spriteCol];<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pixelColor != <span class="hljs-number">0</span>)<font></font>
		{<font></font>
			gFramebuffer[row * LCD_WIDTH + col] = color;<font></font>
		}<font></font>
<font></font>
		++spriteCol;<font></font>
	}<font></font>
<font></font>
	++spriteRow;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ein Sprite zu zeichnen, durchlaufen wir iterativ seinen Inhalt. </font><font style="vertical-align: inherit;">Wenn das Pixel weiß ist, zeichnen wir es in der von den Schaltflächen ausgewählten Farbe. </font><font style="vertical-align: inherit;">Wenn es schwarz ist, betrachten wir es als Hintergrund und zeichnen nicht.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ihr Browser unterstützt kein HTML5-Video.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_4/media/sprite_drawing.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kamera meines Telefons verzerrt die Farben erheblich. </font><font style="vertical-align: inherit;">Und tut mir leid, dass ich sie geschüttelt habe. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Aufnahme des Bildes zu testen, bewegen wir den Schlüssel an eine Stelle auf dem Bildschirm, ändern seine Farbe und schreiben dann den Bildspeicher auf die SD-Karte, damit er auf dem Computer angezeigt werden kann.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (input.menu)<font></font>
{<font></font>
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* snapFilename = <span class="hljs-string">"/sdcard/framebuf"</span>;<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Writing snapshot to %s"</span>, snapFilename);<font></font>
<font></font>
	FILE* snapFile = fopen(snapFilename, <span class="hljs-string">"wb"</span>);<font></font>
	assert(snapFile);<font></font>
<font></font>
		fwrite(gFramebuffer, <span class="hljs-keyword">sizeof</span>(gFramebuffer[<span class="hljs-number">0</span>]), LCD_WIDTH * LCD_HEIGHT, snapFile);<font></font>
	}<font></font>
<font></font>
	fclose(snapFile);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Drücken der Menütaste wird der Inhalt des Bildpuffers in einer Datei namens </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">framebuf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gespeichert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ein Rohbildpuffer, sodass die Pixel weiterhin im RGB565-Format mit umgekehrter Bytereihenfolge verbleiben. </font><font style="vertical-align: inherit;">Wir können ImageMagick wieder verwenden, um dieses Format in PNG zu konvertieren und es auf einem Computer anzuzeigen.</font></font><br>
<br>
<pre><code class="cpp hljs">convert -depth <span class="hljs-number">16</span> -size <span class="hljs-number">320</span>x240+<span class="hljs-number">0</span> -endian msb rgb565:FRAMEBUF snap.png</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich können wir das Lesen / Schreiben im BMP / PNG-Format implementieren und all diese Aufregung mit ImageMagick loswerden, aber dies ist nur ein Demo-Code. </font><font style="vertical-align: inherit;">Bisher habe ich mich noch nicht entschieden, welches Dateiformat ich zum Speichern von Sprites verwenden möchte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bd/09c/e66/0bd09ce669a61276676a87b01c15e6f2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist er! </font><font style="vertical-align: inherit;">Der Odroid Go-Bildspeicher wird auf dem Desktop-Computer angezeigt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid gehen schematisch</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF-Dokumentation: SDMMC</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 5: Batterie</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go verfügt über einen Lithium-Ionen-Akku, sodass wir ein Spiel erstellen können, das Sie auch unterwegs spielen können. </font><font style="vertical-align: inherit;">Dies ist eine verlockende Idee für jemanden, der als Kind den ersten Gameboy gespielt hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher benötigen wir eine Möglichkeit, den Akkuladestand des Odroid Go anzufordern. </font><font style="vertical-align: inherit;">Die Batterie ist mit dem Kontakt des ESP32 verbunden, sodass wir die Spannung ablesen können, um eine ungefähre Vorstellung von der verbleibenden Betriebszeit zu erhalten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planen</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f2/ceb/13b/1f2ceb13bf408d8773f22047464e4e66.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Diagramm zeigt </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das an die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spannung </font><font style="vertical-align: inherit;">angeschlossen ist, </font><font style="vertical-align: inherit;">nachdem es über einen Widerstand gegen Masse gezogen wurde. Zwei Widerstände ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R21</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R23</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) bilden einen Spannungsteiler ähnlich dem am Kreuz des Gamepads verwendeten. Die Widerstände haben wieder den gleichen Widerstand, so dass die Spannung die Hälfte des Originals beträgt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund des Spannungsteilers </font><font style="vertical-align: inherit;">liest </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Spannung, die der halben </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT entspricht</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies liegt wahrscheinlich daran, dass die ADC-Kontakte am ESP32 die Hochspannung des Lithium-Ionen-Akkus (4,2 V bei maximaler Ladung) nicht lesen können. Wie dem auch sei, dies bedeutet, dass Sie die vom ADC (ADC) gelesene Spannung verdoppeln müssen, um die wahre Spannung zu erhalten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Lesen des Werts von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36 erhalten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir einen digitalen Wert, verlieren jedoch den analogen Wert, den er darstellt. Wir brauchen eine Möglichkeit, einen digitalen Wert mit einem ADC in Form einer physikalischen analogen Spannung zu interpretieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit IDF können Sie den ADC kalibrieren, der versucht, einen Spannungspegel basierend auf der Referenzspannung zu erhalten. Diese Referenzspannung ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vref</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) beträgt standardmäßig 1100 mV, aber aufgrund der physikalischen Eigenschaften unterscheidet sich jedes Gerät geringfügig. ESP32 in Odroid Go verfügt über eine manuell definierte Vref, die in eFuse „geflasht“ ist und die wir als genauere Vref verwenden können.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verfahren ist wie folgt: Zuerst konfigurieren wir die ADC-Kalibrierung, und wenn wir die Spannung ablesen möchten, nehmen wir eine bestimmte Anzahl von Proben (zum Beispiel 20), um die Durchschnittswerte zu berechnen; dann verwenden wir die IDF, um diese Messwerte in Spannung umzuwandeln. Die Berechnung des Durchschnitts eliminiert Rauschen und liefert genauere Messwerte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider besteht kein linearer Zusammenhang zwischen Spannung und Batterieladung. Wenn die Ladung abnimmt, fällt die Spannung ab, wenn sie zunimmt, steigt sie an, jedoch auf unvorhersehbare Weise. Alles, was gesagt werden kann: Wenn die Spannung unter etwa 3,6 V liegt, wird die Batterie entladen, aber es ist überraschend schwierig, den Spannungspegel genau in einen Prozentsatz der Batterieladung umzuwandeln.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für unser Projekt ist dies nicht besonders wichtig. </font><font style="vertical-align: inherit;">Wir können eine grobe Annäherung implementieren, um den Spieler über die Notwendigkeit zu informieren, das Gerät schnell aufzuladen, aber wir werden nicht leiden, wenn wir versuchen, den genauen Prozentsatz zu erhalten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status-LED</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/0ad/2d6/b520ad2d63e2a4c59924debb6c3613bc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der Vorderseite unter dem Odroid Go-Bildschirm befindet sich eine blaue LED (LED), die wir für jeden Zweck verwenden können. Sie können ihnen zeigen, dass das Gerät eingeschaltet ist und funktioniert. In diesem Fall leuchtet jedoch im Dunkeln eine hellblaue LED in Ihrem Gesicht. Daher werden wir es verwenden, um eine niedrige Batterieladung anzuzeigen (obwohl ich dafür eine rote oder bernsteinfarbene Farbe bevorzugen würde). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die LED zu verwenden, müssen Sie </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als Ausgang </font><strong><font style="vertical-align: inherit;">einstellen</font></strong><font style="vertical-align: inherit;"> und dann ein </font><strong><font style="vertical-align: inherit;">High-</font></strong><font style="vertical-align: inherit;"> oder Low-Signal </font><strong><font style="vertical-align: inherit;">anlegen,</font></strong><font style="vertical-align: inherit;"> um die LED </font><strong><font style="vertical-align: inherit;">ein-</font></strong><font style="vertical-align: inherit;"> und auszuschalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, dass ein 2-kΩ- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widerstand</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><strong><font style="vertical-align: inherit;">Strombegrenzungswiderstand</font></strong><font style="vertical-align: inherit;"> ) ausreicht, damit wir die LED nicht verbrennen und zu viel Strom vom GPIO-Pin liefern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die LED hat einen relativ geringen Widerstand. Wenn also 3,3 V an sie angelegt werden, wird sie durch Ändern des Stroms verbrannt. </font><font style="vertical-align: inherit;">Zum Schutz ist in der Regel ein Widerstand in Reihe mit der LED geschaltet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Strombegrenzungswiderstände für LEDs sind jedoch normalerweise viel kleiner als 2 kΩ, daher verstehe ich nicht, warum der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R7-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Widerstand </font><font style="vertical-align: inherit;">ein solcher Widerstand ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierung</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> BATTERY_READ_PIN = ADC1_GPIO36_CHANNEL;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BATTERY_LED_PIN = GPIO_NUM_2;<font></font>
<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">esp_adc_cal_characteristics_t</span> gCharacteristics;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeBatteryReader</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-comment">// Configure LED</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; BATTERY_LED_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure ADC</span><font></font>
	{<font></font>
		adc1_config_width(ADC_WIDTH_BIT_12);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
<font></font>
    	<span class="hljs-keyword">esp_adc_cal_value_t</span> type = esp_adc_cal_characterize(<font></font>
    		ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_12, <span class="hljs-number">1100</span>, &amp;gCharacteristics);<font></font>
<font></font>
    	assert(type == ESP_ADC_CAL_VAL_EFUSE_VREF);<font></font>
    }<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Battery reader initialized"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst setzen wir die GPIO-LED als Ausgang, damit wir sie bei Bedarf umschalten können. </font><font style="vertical-align: inherit;">Dann konfigurieren wir den ADC-Pin wie bei einem Cross - mit einer Bitbreite von 12 und minimaler Dämpfung. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_characterize</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> führt Berechnungen durch, um den ADC zu charakterisieren, damit wir die digitalen Messwerte später in physischen Stress umwandeln können.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Batterie lesen</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">Odroid_ReadBatteryLevel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SAMPLE_COUNT = <span class="hljs-number">20</span>;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> raw = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sampleIndex = <span class="hljs-number">0</span>; sampleIndex &lt; SAMPLE_COUNT; ++sampleIndex)<font></font>
	{<font></font>
		raw += adc1_get_raw(BATTERY_READ_PIN);<font></font>
	}<font></font>
<font></font>
	raw /= SAMPLE_COUNT;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> voltage = <span class="hljs-number">2</span> * esp_adc_cal_raw_to_voltage(raw, &amp;gCharacteristics);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> voltage;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir nehmen zwanzig Rohproben des ADC aus dem Kontakt des ADC und teilen sie dann, um den Durchschnittswert zu erhalten. Wie oben erwähnt, hilft dies, das Rauschen der Messwerte zu reduzieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann verwenden wir </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_raw_to_voltage</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um den Rohwert in die reale Spannung umzuwandeln. Aufgrund des oben erwähnten Spannungsteilers verdoppeln wir den Rückgabewert: Der Lesewert ist die Hälfte der tatsächlichen Batteriespannung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstatt knifflige Möglichkeiten zu finden, um diese Spannung in einen Prozentsatz der Batterieladung umzuwandeln, geben wir eine einfache Spannung zurück. Lassen Sie die aufrufende Funktion selbst entscheiden, was mit der Spannung geschehen soll - ob sie in einen Prozentsatz der Ladung umgewandelt oder einfach als hoher oder niedriger Wert interpretiert werden soll.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Wert wird in Millivolt zurückgegeben, daher muss die aufrufende Funktion die entsprechende Konvertierung durchführen. </font><font style="vertical-align: inherit;">Dies verhindert einen Überlauf des Schwimmers.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED-Einstellung</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_EnableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_DisableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese beiden einfachen Funktionen reichen aus, um die LED zu verwenden. </font><font style="vertical-align: inherit;">Wir können das Licht entweder ein- oder ausschalten. </font><font style="vertical-align: inherit;">Lassen Sie die aufrufende Funktion entscheiden, wann sie ausgeführt werden soll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir könnten eine Aufgabe erstellen, die die Batteriespannung regelmäßig überwacht und den Status der LED entsprechend ändert. Ich sollte jedoch die Batteriespannung in unserem Hauptzyklus abfragen und dann entscheiden, wie die Batteriespannung von dort aus eingestellt werden soll.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint32_t</span> batteryLevel = Odroid_ReadBatteryLevel();<font></font>
<font></font>
<span class="hljs-keyword">if</span> (batteryLevel &lt; <span class="hljs-number">3600</span>)<font></font>
{<font></font>
	Odroid_EnableBatteryLight();<font></font>
}<font></font>
<span class="hljs-keyword">else</span><font></font>
{<font></font>
	Odroid_DisableBatteryLight();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können einfach den Batteriestand im Hauptzyklus anfordern. Wenn die Spannung unter dem Schwellenwert liegt, schalten Sie die LED ein, um anzuzeigen, dass ein Ladevorgang erforderlich ist. </font><font style="vertical-align: inherit;">Aufgrund der untersuchten Materialien kann ich sagen, dass 3600 mV (3,6 V) ein gutes Zeichen für eine geringe Ladung von Lithium-Ionen-Batterien sind, aber die Batterien selbst sind komplex.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid gehen schematisch</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF-Dokumentation: ADC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Batterieeigenschaften</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 6: Ton</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der letzte Schritt, um eine vollständige Schnittstelle zu aller Odroid Go-Hardware zu erhalten, besteht darin, eine Soundebene zu schreiben. Wenn wir damit fertig sind, können wir beginnen, uns einer allgemeineren Programmierung des Spiels zuzuwenden, die weniger mit der Programmierung für Odroid zu tun hat. Alle Interaktionen mit Peripheriegeräten werden über die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktionen ausgeführt </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund meiner mangelnden Erfahrung mit Soundprogrammierung und des Mangels an guter Dokumentation seitens IDF nahm die Implementierung von Sound bei der Arbeit an einem Projekt die meiste Zeit in Anspruch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Letztendlich war nicht so viel Code erforderlich, um den Sound abzuspielen. Die meiste Zeit wurde damit verbracht, die Audiodaten in den gewünschten ESP32 zu konvertieren und den ESP32-Audiotreiber so zu konfigurieren, dass er der Hardwarekonfiguration entspricht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundlagen des digitalen Klangs</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digitaler Sound besteht aus zwei Teilen: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufnahme</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiedergabe</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufzeichnung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Ton auf einem Computer aufzunehmen, müssen wir ihn zuerst aus dem Raum eines kontinuierlichen (analogen) Signals in den Raum eines diskreten (digitalen) Signals konvertieren. </font><font style="vertical-align: inherit;">Diese Aufgabe wird mit einem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analog-Digital-Wandler (ADC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erledigt </font><font style="vertical-align: inherit;">(über den wir in Teil 2 bei der Arbeit mit dem Kreuz gesprochen haben). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der ADC empfängt eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probe der</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eingehenden Welle und digitalisiert den Wert, der dann in einer Datei gespeichert werden kann.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abspielen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine digitale Audiodatei kann mithilfe eines </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digital-Analog-Wandlers (DAC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vom digitalen in den analogen Raum zurückgegeben werden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">DAC kann Werte nur in einem bestimmten Bereich wiedergeben. </font><font style="vertical-align: inherit;">Beispielsweise kann ein 8-Bit-DAC mit einer 3,3-V-Quelle analoge Spannungen im Bereich von 0 bis 3,3 mV in Schritten von 12,9 mV (3,3 V geteilt durch 256) ausgeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der DAC nimmt digitale Werte auf und wandelt sie wieder in Spannung um, die an einen Verstärker, Lautsprecher oder ein anderes Gerät übertragen werden kann, das ein analoges Audiosignal empfangen kann.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abtastrate</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Aufnahme von analogem Ton über den ADC werden Samples mit einer bestimmten Frequenz aufgenommen, und jedes Sample ist zu einem bestimmten Zeitpunkt eine „Momentaufnahme“ des Tonsignals. Dieser Parameter wird als </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abtastfrequenz bezeichnet</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hertz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gemessen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je höher die Abtastfrequenz, desto genauer werden die Frequenzen des ursprünglichen Signals wiederhergestellt. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Satz von Nyquist-Shannon (Kotelnikov)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt (in einfachen Worten), dass die Abtastfrequenz doppelt so hoch sein sollte wie die höchste Signalfrequenz, die wir aufzeichnen möchten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das menschliche Ohr kann ungefähr im Bereich </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von 20 Hz bis 20 kHz hören</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , daher wird die Abtastfrequenz von </font><strong><font style="vertical-align: inherit;">44,1 kHz</font></strong><font style="vertical-align: inherit;"> am häufigsten verwendet, um qualitativ hochwertige Musik wiederherzustellen</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist etwas mehr als das Doppelte der maximalen Frequenz, die das menschliche Ohr erkennen kann. Dies stellt sicher, dass ein vollständiger Satz von Instrumentenfrequenzen und Stimmen neu erstellt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes Sample nimmt jedoch Platz in der Datei ein, sodass wir nicht die maximale Sampling-Rate auswählen können. Wenn Sie jedoch nicht schnell genug probieren, können Sie wichtige Informationen verlieren. Die ausgewählte Abtastfrequenz sollte von den Frequenzen abhängen, die im neu erstellten Ton vorhanden sind. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wiedergabe sollte mit derselben Abtastfrequenz wie die Quelle erfolgen, da sonst der Klang und die Dauer unterschiedlich sind.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, zehn Sekunden Ton wurden mit einer Abtastfrequenz von 16 kHz aufgezeichnet. </font><font style="vertical-align: inherit;">Wenn Sie es mit einer Frequenz von 8 kHz spielen, ist der Ton niedriger und die Dauer beträgt 20 Sekunden. </font><font style="vertical-align: inherit;">Wenn Sie es mit einer Abtastfrequenz von 32 kHz spielen, ist der hörbare Ton höher und der Ton selbst dauert fünf Sekunden. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Video zeigt den Unterschied in den Abtastraten anhand von Beispielen.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bittiefe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Abtastfrequenz ist nur die halbe Miete. Der Sound hat auch eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bittiefe, dh</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Anzahl der Bits pro Sample. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der ADC ein Sample eines Audiosignals erfasst, muss er diesen analogen Wert in einen digitalen Wert umwandeln. Der Bereich der erfassten Werte hängt von der Anzahl der verwendeten Bits ab. 8 Bit (256 Werte), 16 Bit (65.526 Werte), 32 Bit (4.294.967.296 Werte) usw. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anzahl der Bits pro Abtastung hängt mit dem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamikbereich des</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klangs zusammen, d.h. mit den lautesten und leisesten Teilen. Die häufigste Bittiefe für Musik beträgt 16 Bit. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Während der Wiedergabe muss die gleiche Bittiefe wie bei der Quelle angegeben werden, da sich sonst der Klang und die Dauer ändern.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie haben beispielsweise eine Audiodatei mit vier Samples, die als 8 Bit gespeichert sind: [0x25, 0xAB, 0x34, 0x80]. </font><font style="vertical-align: inherit;">Wenn Sie versuchen, sie so abzuspielen, als wären sie 16-Bit, erhalten Sie nur zwei Samples: [0x25AB, 0x3480]. </font><font style="vertical-align: inherit;">Dies führt nicht nur zu falschen Werten von Klangbeispielen, sondern halbiert auch die Anzahl der Abtastwerte und damit die Dauer des Klangs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist auch wichtig, das Format der Proben zu kennen. </font><font style="vertical-align: inherit;">8-Bit ohne Vorzeichen, 8-Bit ohne Vorzeichen, 16-Bit ohne Vorzeichen, 16-Bit ohne Vorzeichen usw. </font><font style="vertical-align: inherit;">Normalerweise sind 8-Bit vorzeichenlos und 16-Bit vorzeichenlos. </font><font style="vertical-align: inherit;">Wenn sie verwirrt sind, wird der Ton stark verzerrt. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Video zeigt den Unterschied in der Bittiefe anhand von Beispielen.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WAV-Dateien</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am häufigsten werden rohe Audiodaten auf einem Computer im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WAV-Format gespeichert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das einen einfachen Header enthält, der das Audioformat (Abtastfrequenz, Bittiefe, Größe usw.) beschreibt, gefolgt von den Audiodaten selbst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Sound wird überhaupt nicht komprimiert (im Gegensatz zu Formaten wie MP3), sodass wir ihn problemlos abspielen können, ohne dass eine Codec-Bibliothek erforderlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Hauptproblem bei WAV-Dateien besteht darin, dass sie aufgrund der fehlenden Komprimierung sehr groß sein können. Die Dateigröße steht in direktem Zusammenhang mit der Dauer, der Abtastrate und der Bittiefe. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Größe = Dauer (in Sekunden) x Abtastrate (Abtastwerte / s) x Bittiefe (Bit / Abtastwert)</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Abtastfrequenz wirkt sich am meisten auf die Dateigröße aus. Der einfachste Weg, Platz zu sparen, besteht darin, einen ausreichend niedrigen Wert auszuwählen. </font><font style="vertical-align: inherit;">Wir werden einen Old-School-Sound erzeugen, daher passt eine niedrige Abtastfrequenz zu uns.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I2S</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32 verfügt über Peripheriegeräte, aufgrund derer es relativ einfach ist, eine Schnittstelle mit Audiogeräten bereitzustellen: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inter-IC Sound (I2S)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das I2S-Protokoll ist recht einfach und besteht aus nur drei Signalen: einem Taktsignal, einer Auswahl von Kanälen (links oder rechts) und auch der Datenleitung selbst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Taktfrequenz hängt von der Abtastfrequenz, der Bittiefe und der Anzahl der Kanäle ab. Die Beats werden für jedes Datenbit ersetzt. Für eine ordnungsgemäße Klangwiedergabe müssen Sie daher die Taktfrequenz entsprechend einstellen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taktfrequenz = Abtastfrequenz (Samples / s) x Bittiefe (Bits / Sample) x Anzahl der Kanäle</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der ESP32-Mikrocontroller-I2S-Treiber verfügt über zwei mögliche Modi: Er kann entweder Daten an Kontakte ausgeben, die an einen externen I2S-Empfänger angeschlossen sind, der das Protokoll decodieren und Daten an den Verstärker übertragen kann, oder er kann Daten an einen internen ESP32-DAC übertragen, der ein analoges Signal ausgibt, an das gesendet werden kann Verstärker. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go hat keinen I2S-Decoder auf der Karte, daher müssen wir den internen 8-Bit-ESP32-DAC verwenden, dh wir müssen 8-Bit-Sound verwenden. </font><font style="vertical-align: inherit;">Das Gerät verfügt über zwei DACs, von denen einer an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und der andere an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26 angeschlossen ist</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verfahren sieht folgendermaßen aus:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir übertragen Audiodaten an den I2S-Treiber</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der I2S-Treiber sendet Audiodaten an den internen 8-Bit-DAC</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der interne DAC gibt ein analoges Signal aus</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das analoge Signal wird an den Tonverstärker übertragen</font></font></li>
<li>      </li>
<li>  </li>
</ol><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/d93/a8e/2d9d93a8ed6eceb35846c0f31e336ec9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir uns die Audio- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schaltung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">der Odroid Go-Schaltung ansehen</font></a><font style="vertical-align: inherit;"> , sehen wir zwei GPIO-Pins ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), die mit den Eingängen des Tonverstärkers ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAM8304A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) verbunden sind. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25 ist</font></font></strong><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
auch mit dem Signal </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD des</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verstärkers </font><font style="vertical-align: inherit;">verbunden, </font><strong><font style="vertical-align: inherit;">dh</font></strong><font style="vertical-align: inherit;"> dem Kontakt, </font><strong><font style="vertical-align: inherit;">der den</font></strong><font style="vertical-align: inherit;"> Verstärker </font><strong><font style="vertical-align: inherit;">ein-</font></strong><font style="vertical-align: inherit;"> oder ausschaltet (niedriges Signal bedeutet Abschalten). Die Verstärkerausgänge sind mit einem Lautsprecher ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) verbunden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> daran, dass </font><strong><font style="vertical-align: inherit;">IO25</font></strong><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausgänge von 8-Bit-ESP32-DACs sind, dh ein DAC ist mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und der andere mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN + verbunden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Differenzeingänge des</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tonverstärkers. Differenzeingänge werden verwendet, um durch </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elektromagnetische Störungen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verursachte </font><strong><font style="vertical-align: inherit;">Störungen</font></strong><font style="vertical-align: inherit;"> zu reduzieren </font><font style="vertical-align: inherit;">. Jedes in einem Signal vorhandene Rauschen ist auch in einem anderen vorhanden. Ein Signal wird von einem anderen subtrahiert, wodurch Rauschen vermieden wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">technischen Daten des Tonverstärkers</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ansehen </font><font style="vertical-align: inherit;">, verfügt er über eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">typische Anwendungsschaltung. Dies</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die vom Hersteller empfohlene Art, den Verstärker zu verwenden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/044/d2a/323/044d2a323366c5ddb3c3b87f918bf5f9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Er empfiehlt, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit Masse, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dem Eingangssignal und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dem Ein / Aus-Signal zu verbinden. Wenn es ein Geräusch von 0,005 V, dann mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- </font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0V + 0,005 V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gelesen werden </font><font style="vertical-align: inherit;">, und mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN + 0,005 V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die Eingangssignale müssen voneinander subtrahiert werden und erhalten den wahren Signalwert ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ohne Rauschen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Entwickler von Odroid Go verwendeten jedoch nicht die empfohlene Konfiguration. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir uns noch einmal die Odroid Go-Schaltung ansehen, sehen wir, dass die Entwickler den DAC-Ausgang mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- verbunden haben</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und dass derselbe DAC-Ausgang mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD verbunden ist</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist ein Abschaltsignal mit einem aktiven niedrigen Pegel. Damit der Verstärker funktioniert, müssen Sie ein hohes Signal einstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass wir zur Verwendung des Verstärkers den </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25 nicht</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als DAC verwenden dürfen, sondern als GPIO-Ausgang mit einem immer hohen Signal. In diesem Fall wird jedoch ein hohes Signal auf </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- gesetzt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was von der Spezifikation des Verstärkers nicht empfohlen wird (es muss geerdet sein). Dann müssen wir den an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angeschlossenen DAC </font><strong><font style="vertical-align: inherit;">verwenden</font></strong><font style="vertical-align: inherit;"> , da unser I2S-Ausgang </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zugeführt werden muss </font><font style="vertical-align: inherit;">. Dies bedeutet, dass wir nicht die notwendige Rauschunterdrückung erreichen, da </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht mit Masse verbunden ist. Von den Lautsprechern geht ständig ein leises Geräusch aus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir müssen die korrekte Konfiguration des I2S-Treibers sicherstellen, da wir nur den an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angeschlossenen DAC verwenden </font><strong><font style="vertical-align: inherit;">möchten</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn wir einen an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angeschlossenen DAC verwenden </font><strong><font style="vertical-align: inherit;">würden</font></strong><font style="vertical-align: inherit;"> , würde dies das Signal des Verstärkers ständig ausschalten und der Ton wäre schrecklich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zu dieser Verrücktheit erfordert der I2S-Treiber im ESP32 bei Verwendung eines internen 8-Bit-DAC die Übertragung von 16-Bit-Samples, sendet jedoch nur das High-Byte an den 8-Bit-DAC. </font><font style="vertical-align: inherit;">Daher müssen wir unseren 8-Bit-Sound in einen doppelt so großen Puffer einfügen, während der Puffer halb leer ist. </font><font style="vertical-align: inherit;">Dann übergeben wir es an den I2S-Treiber und es übergibt dem DAC das High-Byte jedes Samples. </font><font style="vertical-align: inherit;">Leider bedeutet dies, dass wir für 16 Bit „bezahlen“ müssen, aber wir können nur 8 Bit verwenden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multitasking</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider kann das Spiel nicht auf einem Kern funktionieren, wie ich es ursprünglich wollte, da es einen Fehler im I2S-Treiber zu geben scheint. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der I2S-Treiber muss DMA verwenden (wie der SPI-Treiber), dh wir können einfach die Übertragung von I2S initiieren und dann unsere Arbeit fortsetzen, während der I2S-Treiber Audiodaten überträgt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen ist die CPU für die Dauer des Sounds blockiert, was für das Spiel völlig ungeeignet ist. Stellen Sie sich vor, Sie drücken die Sprungtaste und das Sprite des Players pausiert seine Bewegung für 100 ms, während der Sprungton abgespielt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dieses Problem zu lösen, können wir die Tatsache nutzen, dass sich an Bord des ESP32 zwei Kerne befinden. </font><font style="vertical-align: inherit;">Wir können im zweiten Kern eine Aufgabe (d. H. Einen Thread) erstellen, die sich mit der Tonwiedergabe befasst. </font><font style="vertical-align: inherit;">Dank dessen können wir den Zeiger auf den Soundpuffer von der Hauptaufgabe des Spiels auf die Soundaufgabe übertragen, und die Soundaufgabe initiiert die Übertragung von I2S und ist für die Dauer der Soundwiedergabe blockiert. </font><font style="vertical-align: inherit;">Die Hauptaufgabe auf dem ersten Kern (mit Eingabeverarbeitung und Rendering) wird jedoch weiterhin ohne Blockierung ausgeführt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir dies wissen, können wir den I2S-Treiber ordnungsgemäß initiieren. </font><font style="vertical-align: inherit;">Dazu benötigen Sie nur wenige Codezeilen. Die Schwierigkeit besteht jedoch darin, herauszufinden, welche Parameter Sie für eine ordnungsgemäße Klangwiedergabe einstellen müssen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> AUDIO_AMP_SD_PIN = GPIO_NUM_25;<font></font>
<font></font>
<span class="hljs-keyword">static</span> QueueHandle_t gQueue;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlayTask</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span>
</span>{
	<span class="hljs-keyword">for</span>(;;)<font></font>
	{<font></font>
		QueueData data;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (xQueueReceive(gQueue, &amp;data, <span class="hljs-number">10</span>))<font></font>
		{<font></font>
			<span class="hljs-keyword">size_t</span> bytesWritten;<font></font>
			i2s_write(I2S_NUM_0, data.buffer, data.length, &amp;bytesWritten, portMAX_DELAY);<font></font>
			i2s_zero_dma_buffer(I2S_NUM_0);<font></font>
		}<font></font>
<font></font>
		vTaskDelay(<span class="hljs-number">1</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeAudio</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-comment">// Configure the amplifier shutdown signal</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; AUDIO_AMP_SD_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
<font></font>
		gpio_set_level(AUDIO_AMP_SD_PIN, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure the I2S driver</span><font></font>
	{<font></font>
		<span class="hljs-keyword">i2s_config_t</span> i2sConfig= {};<font></font>
<font></font>
		i2sConfig.mode = I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN;<font></font>
		i2sConfig.sample_rate = <span class="hljs-number">5012</span>;<font></font>
		i2sConfig.bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT;<font></font>
		i2sConfig.communication_format = I2S_COMM_FORMAT_I2S_MSB;<font></font>
		i2sConfig.channel_format = I2S_CHANNEL_FMT_ONLY_LEFT;<font></font>
		i2sConfig.dma_buf_count = <span class="hljs-number">8</span>;<font></font>
		i2sConfig.dma_buf_len = <span class="hljs-number">64</span>;<font></font>
<font></font>
		ESP_ERROR_CHECK(i2s_driver_install(I2S_NUM_0, &amp;i2sConfig, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>));<font></font>
		ESP_ERROR_CHECK(i2s_set_dac_mode(I2S_DAC_CHANNEL_LEFT_EN));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Create task for playing sounds so that our main task isn't blocked</span><font></font>
	{<font></font>
		gQueue = xQueueCreate(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(QueueData));<font></font>
		assert(gQueue);<font></font>
<font></font>
		BaseType_t result = xTaskCreatePinnedToCore(&amp;PlayTask, <span class="hljs-string">"I2S Task"</span>, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>);<font></font>
		assert(result == pdPASS);<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst konfigurieren wir </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (das mit dem Ausschaltsignal des Verstärkers verbunden ist) als Ausgang, damit er den Klangverstärker steuern kann, und legen ein hohes Signal an, um den Verstärker einzuschalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes konfigurieren und installieren wir den I2S-Treiber selbst. </font><font style="vertical-align: inherit;">Ich werde jeden Teil der Konfiguration Zeile für Zeile analysieren, da jede Zeile einer Erklärung bedarf:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modus</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir setzen den Treiber als Master (Steuerung des Busses), als Sender (weil wir Daten an die Empfänger übertragen) und konfigurieren ihn für die Verwendung des integrierten 8-Bit-DAC (weil die Odroid Go-Karte keinen externen DAC hat).</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispielrate</font></font><ul>
<li>    5012,      ,   ,      .   ,      ,          .    -,           2500 .</li>
</ul></li>
<li>bits_per_sample<ul>
<li>  ,    ESP32  8-,   I2S ,      16    ,   8     .</li>
</ul></li>
<li>communication_format<ul>
<li>      ,   ,   -   ,   8-      16- .</li>
</ul></li>
<li>channel_format<ul>
<li> GPIO,    <strong>IN+</strong>   —  <strong>IO26</strong>,       «»   I2S.  ,  I2S      ,      <strong>IO25</strong>,      ,          .</li>
</ul></li>
<li>dma_buf_count  dma_buf_len<ul>
<li>  DMA-   ( )  ,        ,   ,        IDF.       ,     .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann erstellen wir eine Warteschlange - auf diese Weise sendet FreeRTOS Daten zwischen Aufgaben. Wir stellen Daten in die Warteschlange einer Aufgabe und extrahieren sie aus der Warteschlange einer anderen Aufgabe. Erstellen Sie eine Struktur namens </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die den Zeiger auf den </font><strong><font style="vertical-align: inherit;">Soundpuffer</font></strong><font style="vertical-align: inherit;"> und die Länge des Puffers zu einer einzigen Struktur kombiniert, die in die Warteschlange gestellt werden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie als Nächstes eine Aufgabe, die auf dem zweiten Kern ausgeführt wird. Wir verbinden es mit der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">, die die Tonwiedergabe durchführt. Die Aufgabe selbst ist eine Endlosschleife, die ständig überprüft, ob sich Daten in der Warteschlange befinden. Wenn dies der Fall ist, sendet sie sie an den I2S-Treiber, damit sie abgespielt werden können. Der </font><strong><font style="vertical-align: inherit;">i2s_write-</font></strong><font style="vertical-align: inherit;"> Aufruf wird blockiert</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und das passt zu uns, weil die Aufgabe auf einem vom Hauptthread des Spiels getrennten Kernel ausgeführt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Aufruf von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i2s_zero_dma_buffer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist erforderlich, damit nach Abschluss der Wiedergabe keine Töne mehr aus den Lautsprechern kommen. </font><font style="vertical-align: inherit;">Ich weiß nicht, ob dies ein Fehler des I2S-Treibers oder des erwarteten Verhaltens ist, aber ohne diesen gibt der Lautsprecher nach Beendigung der Wiedergabe des Soundpuffers ein Müllsignal aus.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ton abspielen</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_PlayAudio</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span>* buffer, <span class="hljs-keyword">size_t</span> length)</span>
</span>{<font></font>
	QueueData data = {};<font></font>
<font></font>
	data.buffer = buffer;<font></font>
	data.length = length;<font></font>
<font></font>
	xQueueSendToBack(gQueue, &amp;data, portMAX_DELAY);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund der Tatsache, dass die gesamte Konfiguration bereits abgeschlossen wurde, ist der Aufruf der Soundpuffer-Wiedergabefunktion selbst äußerst einfach, da die Hauptarbeit in einer anderen Aufgabe erledigt wird. </font><font style="vertical-align: inherit;">Wir setzen den Zeiger auf den Puffer und die Länge des Puffers in die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><font style="vertical-align: inherit;">und setzen ihn dann in die Warteschlange, die von der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion verwendet wird </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund dieses Betriebsmusters muss ein Soundpuffer die Wiedergabe abschließen, bevor der zweite Puffer gestartet werden kann. </font><font style="vertical-align: inherit;">Wenn also ein Sprung und ein Schießen gleichzeitig stattfinden, wird der erste Ton vor dem zweiten und nicht gleichzeitig damit abgespielt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Höchstwahrscheinlich werde ich in Zukunft verschiedene Frame-Sounds in den Soundpuffer mischen, der an den I2S-Treiber übertragen wird. </font><font style="vertical-align: inherit;">Auf diese Weise können Sie mehrere Sounds gleichzeitig abspielen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden unsere eigenen Soundeffekte mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsfxr erzeugen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , einem Tool, das speziell entwickelt wurde, um die Art von Spiel-Sounds zu erzeugen, die wir benötigen. </font><font style="vertical-align: inherit;">Wir können die Abtastfrequenz und die Bittiefe direkt einstellen und dann die WAV-Datei ausgeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe einen einfachen Sprung-Soundeffekt erstellt, der dem Klang von Marios Sprung ähnelt. </font><font style="vertical-align: inherit;">Es hat eine Abtastfrequenz von 5012 (wie wir es während der Initialisierung konfiguriert haben) und eine Bittiefe von 8 (da der DAC 8-Bit ist).</font></font><br>
<br>
<div class="oembed"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://austinmorlan.com/posts/embedded_game_programming_6/media/jump.wav</font></font></a></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstatt die WAV-Datei direkt im Code zu analysieren, werden wir etwas Ähnliches tun, wie wir das Sprite in der Demo von Teil 4 geladen haben: Wir werden den WAV-Header mit dem Hex-Editor aus der Datei entfernen. Dank dessen sind die von der SD-Karte gelesenen Dateien nur Rohdaten. Außerdem werden wir die Dauer des Sounds nicht lesen, sondern in den Code schreiben. In Zukunft werden wir Soundressourcen anders laden, aber das reicht für die Demo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Rohdatei kann hier heruntergeladen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Load sound effect</span>
<span class="hljs-keyword">uint16_t</span>* soundBuffer;
<span class="hljs-keyword">int</span> soundEffectLength = <span class="hljs-number">1441</span>;<font></font>
{<font></font>
	FILE* soundFile = fopen(<span class="hljs-string">"/sdcard/jump"</span>, <span class="hljs-string">"r"</span>);<font></font>
	assert(soundFile);<font></font>
<font></font>
	<span class="hljs-keyword">uint8_t</span>* soundEffect = <span class="hljs-built_in">malloc</span>(soundEffectLength);<font></font>
	assert(soundEffect);<font></font>
<font></font>
	soundBuffer = <span class="hljs-built_in">malloc</span>(soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	assert(soundBuffer);<font></font>
<font></font>
	fread(soundEffect, soundEffectLength, <span class="hljs-number">1</span>, soundFile);<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; soundEffectLength; ++i)<font></font>
    {<font></font>
        <span class="hljs-comment">// 16 bits required but only MSB is actually sent to the DAC</span>
        soundBuffer[i] = (soundEffect[i] &lt;&lt; <span class="hljs-number">8u</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir laden die 8-Bit-Daten in den 8-Bit- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SoundEffect-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puffer </font><font style="vertical-align: inherit;">und kopieren diese Daten dann in den 16-Bit- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SoundBuffer-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puffer </font><font style="vertical-align: inherit;">, in dem die Daten in den hohen acht Bits gespeichert werden. </font><font style="vertical-align: inherit;">Ich wiederhole - dies ist aufgrund der Funktionen der IDF-Implementierung erforderlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir einen 16-Bit-Puffer erstellt haben, können wir den Klang eines Knopfdrucks wiedergeben. </font><font style="vertical-align: inherit;">Es wäre logisch, hierfür die Lautstärketaste zu verwenden.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> lastState = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (;;)<font></font>
{<font></font>
	[...]<font></font>
<font></font>
	<span class="hljs-keyword">int</span> thisState = input.volume;<font></font>
<font></font>
	<span class="hljs-keyword">if</span> ((thisState == <span class="hljs-number">1</span>) &amp;&amp; (thisState != lastState))<font></font>
	{<font></font>
		Odroid_PlayAudio(soundBuffer, soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	}<font></font>
<font></font>
	lastState = thisState;<font></font>
<font></font>
	[...]<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir überwachen den Status der Schaltfläche, damit Sie versehentlich mit einem Klick auf die Schaltfläche nicht versehentlich </font><font style="vertical-align: inherit;">mehrmals </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid_PlayAudio</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufrufen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ihr Browser unterstützt kein HTML5-Video.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_6/media/demo.mp4" type="video/mp4"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der gesamte Quellcode ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid gehen schematisch</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenblatt für Audioverstärker</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF-Dokumentation: DAC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF-Dokumentation: I2S</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WAVE-Dateiformat</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video: Erklärung der Bittiefe</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video: Erklärung zur Abtastrate</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de503854/index.html">Verwenden Sie SIL maximal</a></li>
<li><a href="../de503858/index.html">Das Buch "Terraform: Infrastruktur auf Codeebene"</a></li>
<li><a href="../de503860/index.html">Einrichten der neuronalen Netzwerkumgebung Maske R-CNN</a></li>
<li><a href="../de503864/index.html">Flavours Organization bei Flutter</a></li>
<li><a href="../de503866/index.html">Veröffentlichte Roadmap-Entwicklung Zextras Suite für 2020</a></li>
<li><a href="../de503880/index.html">Wie ich gelernt habe, mir keine Sorgen zu machen und die Bildverarbeitung liebte</a></li>
<li><a href="../de503884/index.html">Wie man lernt, asynchron zu arbeiten</a></li>
<li><a href="../de503888/index.html">AdaBoost-Algorithmus</a></li>
<li><a href="../de503890/index.html">Die Geschichte, wie ich Azure AD B2C für React and React Native konfiguriert habe Teil 1 (Tutorial)</a></li>
<li><a href="../de503892/index.html">Mitap: Quarantäne, geh weg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>