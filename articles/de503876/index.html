<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì¶ üòê ‚õÖÔ∏è Programmieren eines Spiels f√ºr ein eingebettetes Ger√§t auf ESP32: Laufwerk, Akku, Sound üßñüèº üë©üèº‚Äçü§ù‚Äçüë®üèø ‚úçüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Start: Montagesystem, Eingabe, Anzeige .
 
 Teil 4: fahren
 Odroid Go verf√ºgt √ºber einen microSD-Kartensteckplatz, der zum Herunterladen von Ressource...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programmieren eines Spiels f√ºr ein eingebettetes Ger√§t auf ESP32: Laufwerk, Akku, Sound</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503876/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/800/42e/44b80042e94aa2f2da9da2d2296461ad.jpg" alt="Bild"></div><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start: Montagesystem, Eingabe, Anzeige</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 4: fahren</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go verf√ºgt √ºber einen microSD-Kartensteckplatz, der zum Herunterladen von Ressourcen (Sprites, Sounddateien, Schriftarten) und m√∂glicherweise sogar zum Speichern des Spielstatus n√ºtzlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Kartenleser ist √ºber SPI verbunden, aber IDF erleichtert die Interaktion mit der SD-Karte, indem SPI-Anrufe abstrahiert und Standard- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POSIX-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktionen </font><font style="vertical-align: inherit;">wie </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fopen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fread</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fwrite verwendet werden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . All dies basiert auf der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FatFs-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek </font><font style="vertical-align: inherit;">, daher muss die SD-Karte im Standard-FAT-Format formatiert sein.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist mit demselben SPI-Bus wie das LCD verbunden, verwendet jedoch eine andere Chipauswahlleitung. </font><font style="vertical-align: inherit;">Wenn wir auf die SD-Karte lesen oder schreiben m√ºssen (und dies kommt nicht sehr oft vor), schaltet der SPI-Treiber das CS-Signal vom Display zum SD-Kartenleser und f√ºhrt dann den Vorgang aus. </font><font style="vertical-align: inherit;">Dies bedeutet, dass beim Senden von Daten an das Display keine Vorg√§nge mit der SD-Karte ausgef√ºhrt werden k√∂nnen und umgekehrt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Moment machen wir alles in einem Thread und blockieren die √úbertragung √ºber SPI zum Display, sodass keine gleichzeitigen Transaktionen mit der SD-Karte und dem LCD-Display m√∂glich sind. </font><font style="vertical-align: inherit;">In jedem Fall besteht eine hohe Wahrscheinlichkeit, dass wir alle Ressourcen zum Startzeitpunkt laden.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñnderung von ESP-IDF</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir versuchen, die Schnittstelle der SD-Karte nach der Initialisierung des Displays zu initialisieren, tritt ein Problem auf, das das Laden von Odroid Go unm√∂glich macht. </font><font style="vertical-align: inherit;">ESP-IDF v4.0 unterst√ºtzt bei Verwendung mit einer SD-Karte keinen gemeinsamen Zugriff auf den SPI-Bus. </font><font style="vertical-align: inherit;">Vor kurzem haben Entwickler diese Funktionalit√§t hinzugef√ºgt, sie befindet sich jedoch noch nicht in einer stabilen Version. Daher werden wir die IDF selbst geringf√ºgig √§ndern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kommentieren Sie die Zeile 303 aus. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esp-idf / components / driver / sdspi_host.c</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Initialize SPI bus</span>
<span class="hljs-keyword">esp_err_t</span> ret = spi_bus_initialize((<span class="hljs-keyword">spi_host_device_t</span>)slot, &amp;buscfg,<font></font>
    slot_config-&gt;dma_channel);<font></font>
<span class="hljs-keyword">if</span> (ret != ESP_OK) {<font></font>
    ESP_LOGD(TAG, <span class="hljs-string">"spi_bus_initialize failed with rc=0x%x"</span>, ret);
    <span class="hljs-comment">//return ret;</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dieser √Ñnderung wird w√§hrend der Initialisierung immer noch ein Fehler angezeigt, der ESP32 wird jedoch nicht mehr neu gestartet, da sich der Fehlercode oben nicht ausbreitet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierung</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57f/4f8/b0f/57f4f8b0fcca66e243637eeb68b39ff7.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/554/eae/9ec/554eae9ec4a3e850eb44e817e8b7b181.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir m√ºssen IDF mitteilen, welche ESP32-Pins mit dem MicroSD-Leseger√§t verbunden sind, damit der zugrunde liegende SPI-Treiber, der tats√§chlich mit dem Leseger√§t kommuniziert, korrekt konfiguriert wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die allgemeinen Hinweise </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VSPI.XXXX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden wieder im </font><strong><font style="vertical-align: inherit;">Diagramm verwendet</font></strong><font style="vertical-align: inherit;"> , aber wir k√∂nnen sie zu den tats√§chlichen Kontaktnummern auf ESP32 durchgehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Initialisierung √§hnelt der Initialisierung des LCD, aber anstelle der allgemeinen SPI-Konfigurationsstruktur verwenden wir </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdspi_slot_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das f√ºr eine √ºber den SPI-Bus angeschlossene SD-Karte entwickelt wurde. Wir konfigurieren die entsprechenden Kontaktnummern und Kartenmontageeigenschaften im FatFS-System. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der IDF-Dokumentation wird die Verwendung der Funktion </font><strong><font style="vertical-align: inherit;">esp_vfs_fat_sdmmc_mount</font></strong><font style="vertical-align: inherit;"> nicht empfohlen</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Code des fertigen Programms. Dies ist eine Wrapper-Funktion, die f√ºr uns viele Operationen ausf√ºhrt, aber bisher ganz normal funktioniert, und wahrscheinlich wird sich in Zukunft nichts √§ndern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Parameter </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"/ sdcard"</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dieser Funktion legt den virtuellen Einh√§ngepunkt der SD-Karte fest, den wir dann bei der Arbeit mit Dateien als Pr√§fix verwenden. Wenn wir eine Datei mit dem Namen "test.txt" auf unserer SD-Karte h√§tten, w√§re der Pfad, den wir zum Verkn√ºpfen verwenden w√ºrden, "/sdcard/test.txt". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach der Initialisierung der Schnittstelle der SD-Karte ist die Interaktion mit den Dateien trivial: Wir k√∂nnen einfach Standardaufrufe f√ºr </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POSIX-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktionen verwenden </font><font style="vertical-align: inherit;">, was sehr praktisch ist.</font></font><br>
<br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">   8.3</a>,              .    ,   <b>fopen</b>   .        <b>make menuconfig</b>,       ,     <b>8.3</b>.</blockquote><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/62f/94a/d9462f94aeec7fbdce989e34967e637d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich </font><font style="vertical-align: inherit;">habe </font><font style="vertical-align: inherit;">in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aseprite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (schrecklich) ein 64x64-Sprite </font><strong><font style="vertical-align: inherit;">erstellt</font></strong><font style="vertical-align: inherit;"> , das nur zwei Farben verwendet: vollst√§ndig schwarz (Pixel deaktiviert) und vollst√§ndig wei√ü (Pixel aktiviert). Aseprite hat nicht die M√∂glichkeit, RGB565-Farben zu speichern oder als Roh-Bitmap zu exportieren (d. H. Ohne Komprimierung und Bildheader), daher habe ich das Sprite in ein tempor√§res PNG-Format exportiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann habe </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ich</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit </font><strong><font style="vertical-align: inherit;">ImageMagick</font></strong><font style="vertical-align: inherit;"> die Daten in eine PPM-Datei konvertiert, die das Bild mit einem einfachen Header in unkomprimierte Rohdaten umwandelte. Als n√§chstes √∂ffnete ich das Bild in einem Hex-Editor, l√∂schte den Header und konvertierte die 24-Bit-Farbe in 16-Bit. Dabei l√∂schte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ich</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alle Vorkommen </font><strong><font style="vertical-align: inherit;">0x000000</font></strong><font style="vertical-align: inherit;"> bis </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und alle Vorkommen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bis </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Bytereihenfolge ist hier kein Problem, da sich </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beim √Ñndern der Bytereihenfolge nicht √§ndern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Rohdatei kann hier heruntergeladen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">FILE* spriteFile = fopen(<span class="hljs-string">"/sdcard/key"</span>, <span class="hljs-string">"r"</span>);<font></font>
assert(spriteFile);<font></font>
<font></font>
<span class="hljs-keyword">uint16_t</span>* sprite = (<span class="hljs-keyword">uint16_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">64</span> * <span class="hljs-number">64</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>));<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i)<font></font>
{<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; ++j)<font></font>
	{<font></font>
		fread(sprite, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>), <span class="hljs-number">64</span> * <span class="hljs-number">64</span>, spriteFile);<font></font>
	}<font></font>
}<font></font>
<font></font>
fclose(spriteFile);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst √∂ffnen wir die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schl√ºsseldatei</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit den Rohbytes und lesen sie in den Puffer ein. </font><font style="vertical-align: inherit;">In Zukunft werden wir Sprite-Ressourcen anders laden, aber f√ºr eine Demo ist dies v√∂llig ausreichend.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> spriteRow = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = y; row &lt; y + <span class="hljs-number">64</span>; ++row)<font></font>
{<font></font>
	spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = x; col &lt; x + <span class="hljs-number">64</span>; ++col)<font></font>
	{<font></font>
		<span class="hljs-keyword">uint16_t</span> pixelColor = sprite[<span class="hljs-number">64</span> * spriteRow + spriteCol];<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pixelColor != <span class="hljs-number">0</span>)<font></font>
		{<font></font>
			gFramebuffer[row * LCD_WIDTH + col] = color;<font></font>
		}<font></font>
<font></font>
		++spriteCol;<font></font>
	}<font></font>
<font></font>
	++spriteRow;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ein Sprite zu zeichnen, durchlaufen wir iterativ seinen Inhalt. </font><font style="vertical-align: inherit;">Wenn das Pixel wei√ü ist, zeichnen wir es in der von den Schaltfl√§chen ausgew√§hlten Farbe. </font><font style="vertical-align: inherit;">Wenn es schwarz ist, betrachten wir es als Hintergrund und zeichnen nicht.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ihr Browser unterst√ºtzt kein HTML5-Video.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_4/media/sprite_drawing.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kamera meines Telefons verzerrt die Farben erheblich. </font><font style="vertical-align: inherit;">Und tut mir leid, dass ich sie gesch√ºttelt habe. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Aufnahme des Bildes zu testen, bewegen wir den Schl√ºssel an eine Stelle auf dem Bildschirm, √§ndern seine Farbe und schreiben dann den Bildspeicher auf die SD-Karte, damit er auf dem Computer angezeigt werden kann.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (input.menu)<font></font>
{<font></font>
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* snapFilename = <span class="hljs-string">"/sdcard/framebuf"</span>;<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Writing snapshot to %s"</span>, snapFilename);<font></font>
<font></font>
	FILE* snapFile = fopen(snapFilename, <span class="hljs-string">"wb"</span>);<font></font>
	assert(snapFile);<font></font>
<font></font>
		fwrite(gFramebuffer, <span class="hljs-keyword">sizeof</span>(gFramebuffer[<span class="hljs-number">0</span>]), LCD_WIDTH * LCD_HEIGHT, snapFile);<font></font>
	}<font></font>
<font></font>
	fclose(snapFile);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Dr√ºcken der Men√ºtaste wird der Inhalt des Bildpuffers in einer Datei namens </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">framebuf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gespeichert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ein Rohbildpuffer, sodass die Pixel weiterhin im RGB565-Format mit umgekehrter Bytereihenfolge verbleiben. </font><font style="vertical-align: inherit;">Wir k√∂nnen ImageMagick wieder verwenden, um dieses Format in PNG zu konvertieren und es auf einem Computer anzuzeigen.</font></font><br>
<br>
<pre><code class="cpp hljs">convert -depth <span class="hljs-number">16</span> -size <span class="hljs-number">320</span>x240+<span class="hljs-number">0</span> -endian msb rgb565:FRAMEBUF snap.png</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich k√∂nnen wir das Lesen / Schreiben im BMP / PNG-Format implementieren und all diese Aufregung mit ImageMagick loswerden, aber dies ist nur ein Demo-Code. </font><font style="vertical-align: inherit;">Bisher habe ich mich noch nicht entschieden, welches Dateiformat ich zum Speichern von Sprites verwenden m√∂chte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bd/09c/e66/0bd09ce669a61276676a87b01c15e6f2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist er! </font><font style="vertical-align: inherit;">Der Odroid Go-Bildspeicher wird auf dem Desktop-Computer angezeigt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid gehen schematisch</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF-Dokumentation: SDMMC</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 5: Batterie</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go verf√ºgt √ºber einen Lithium-Ionen-Akku, sodass wir ein Spiel erstellen k√∂nnen, das Sie auch unterwegs spielen k√∂nnen. </font><font style="vertical-align: inherit;">Dies ist eine verlockende Idee f√ºr jemanden, der als Kind den ersten Gameboy gespielt hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher ben√∂tigen wir eine M√∂glichkeit, den Akkuladestand des Odroid Go anzufordern. </font><font style="vertical-align: inherit;">Die Batterie ist mit dem Kontakt des ESP32 verbunden, sodass wir die Spannung ablesen k√∂nnen, um eine ungef√§hre Vorstellung von der verbleibenden Betriebszeit zu erhalten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planen</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f2/ceb/13b/1f2ceb13bf408d8773f22047464e4e66.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Diagramm zeigt </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das an die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spannung </font><font style="vertical-align: inherit;">angeschlossen ist, </font><font style="vertical-align: inherit;">nachdem es √ºber einen Widerstand gegen Masse gezogen wurde. Zwei Widerst√§nde ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R21</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R23</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) bilden einen Spannungsteiler √§hnlich dem am Kreuz des Gamepads verwendeten. Die Widerst√§nde haben wieder den gleichen Widerstand, so dass die Spannung die H√§lfte des Originals betr√§gt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund des Spannungsteilers </font><font style="vertical-align: inherit;">liest </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Spannung, die der halben </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT entspricht</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies liegt wahrscheinlich daran, dass die ADC-Kontakte am ESP32 die Hochspannung des Lithium-Ionen-Akkus (4,2 V bei maximaler Ladung) nicht lesen k√∂nnen. Wie dem auch sei, dies bedeutet, dass Sie die vom ADC (ADC) gelesene Spannung verdoppeln m√ºssen, um die wahre Spannung zu erhalten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Lesen des Werts von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36 erhalten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir einen digitalen Wert, verlieren jedoch den analogen Wert, den er darstellt. Wir brauchen eine M√∂glichkeit, einen digitalen Wert mit einem ADC in Form einer physikalischen analogen Spannung zu interpretieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit IDF k√∂nnen Sie den ADC kalibrieren, der versucht, einen Spannungspegel basierend auf der Referenzspannung zu erhalten. Diese Referenzspannung ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vref</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) betr√§gt standardm√§√üig 1100 mV, aber aufgrund der physikalischen Eigenschaften unterscheidet sich jedes Ger√§t geringf√ºgig. ESP32 in Odroid Go verf√ºgt √ºber eine manuell definierte Vref, die in eFuse ‚Äûgeflasht‚Äú ist und die wir als genauere Vref verwenden k√∂nnen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verfahren ist wie folgt: Zuerst konfigurieren wir die ADC-Kalibrierung, und wenn wir die Spannung ablesen m√∂chten, nehmen wir eine bestimmte Anzahl von Proben (zum Beispiel 20), um die Durchschnittswerte zu berechnen; dann verwenden wir die IDF, um diese Messwerte in Spannung umzuwandeln. Die Berechnung des Durchschnitts eliminiert Rauschen und liefert genauere Messwerte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider besteht kein linearer Zusammenhang zwischen Spannung und Batterieladung. Wenn die Ladung abnimmt, f√§llt die Spannung ab, wenn sie zunimmt, steigt sie an, jedoch auf unvorhersehbare Weise. Alles, was gesagt werden kann: Wenn die Spannung unter etwa 3,6 V liegt, wird die Batterie entladen, aber es ist √ºberraschend schwierig, den Spannungspegel genau in einen Prozentsatz der Batterieladung umzuwandeln.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr unser Projekt ist dies nicht besonders wichtig. </font><font style="vertical-align: inherit;">Wir k√∂nnen eine grobe Ann√§herung implementieren, um den Spieler √ºber die Notwendigkeit zu informieren, das Ger√§t schnell aufzuladen, aber wir werden nicht leiden, wenn wir versuchen, den genauen Prozentsatz zu erhalten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status-LED</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/0ad/2d6/b520ad2d63e2a4c59924debb6c3613bc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der Vorderseite unter dem Odroid Go-Bildschirm befindet sich eine blaue LED (LED), die wir f√ºr jeden Zweck verwenden k√∂nnen. Sie k√∂nnen ihnen zeigen, dass das Ger√§t eingeschaltet ist und funktioniert. In diesem Fall leuchtet jedoch im Dunkeln eine hellblaue LED in Ihrem Gesicht. Daher werden wir es verwenden, um eine niedrige Batterieladung anzuzeigen (obwohl ich daf√ºr eine rote oder bernsteinfarbene Farbe bevorzugen w√ºrde). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die LED zu verwenden, m√ºssen Sie </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als Ausgang </font><strong><font style="vertical-align: inherit;">einstellen</font></strong><font style="vertical-align: inherit;"> und dann ein </font><strong><font style="vertical-align: inherit;">High-</font></strong><font style="vertical-align: inherit;"> oder Low-Signal </font><strong><font style="vertical-align: inherit;">anlegen,</font></strong><font style="vertical-align: inherit;"> um die LED </font><strong><font style="vertical-align: inherit;">ein-</font></strong><font style="vertical-align: inherit;"> und auszuschalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, dass ein 2-kŒ©- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widerstand</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><strong><font style="vertical-align: inherit;">Strombegrenzungswiderstand</font></strong><font style="vertical-align: inherit;"> ) ausreicht, damit wir die LED nicht verbrennen und zu viel Strom vom GPIO-Pin liefern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die LED hat einen relativ geringen Widerstand. Wenn also 3,3 V an sie angelegt werden, wird sie durch √Ñndern des Stroms verbrannt. </font><font style="vertical-align: inherit;">Zum Schutz ist in der Regel ein Widerstand in Reihe mit der LED geschaltet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Strombegrenzungswiderst√§nde f√ºr LEDs sind jedoch normalerweise viel kleiner als 2 kŒ©, daher verstehe ich nicht, warum der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R7-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Widerstand </font><font style="vertical-align: inherit;">ein solcher Widerstand ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierung</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> BATTERY_READ_PIN = ADC1_GPIO36_CHANNEL;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BATTERY_LED_PIN = GPIO_NUM_2;<font></font>
<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">esp_adc_cal_characteristics_t</span> gCharacteristics;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeBatteryReader</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-comment">// Configure LED</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; BATTERY_LED_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure ADC</span><font></font>
	{<font></font>
		adc1_config_width(ADC_WIDTH_BIT_12);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
<font></font>
    	<span class="hljs-keyword">esp_adc_cal_value_t</span> type = esp_adc_cal_characterize(<font></font>
    		ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_12, <span class="hljs-number">1100</span>, &amp;gCharacteristics);<font></font>
<font></font>
    	assert(type == ESP_ADC_CAL_VAL_EFUSE_VREF);<font></font>
    }<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Battery reader initialized"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst setzen wir die GPIO-LED als Ausgang, damit wir sie bei Bedarf umschalten k√∂nnen. </font><font style="vertical-align: inherit;">Dann konfigurieren wir den ADC-Pin wie bei einem Cross - mit einer Bitbreite von 12 und minimaler D√§mpfung. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_characterize</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºhrt Berechnungen durch, um den ADC zu charakterisieren, damit wir die digitalen Messwerte sp√§ter in physischen Stress umwandeln k√∂nnen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Batterie lesen</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">Odroid_ReadBatteryLevel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SAMPLE_COUNT = <span class="hljs-number">20</span>;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> raw = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sampleIndex = <span class="hljs-number">0</span>; sampleIndex &lt; SAMPLE_COUNT; ++sampleIndex)<font></font>
	{<font></font>
		raw += adc1_get_raw(BATTERY_READ_PIN);<font></font>
	}<font></font>
<font></font>
	raw /= SAMPLE_COUNT;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> voltage = <span class="hljs-number">2</span> * esp_adc_cal_raw_to_voltage(raw, &amp;gCharacteristics);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> voltage;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir nehmen zwanzig Rohproben des ADC aus dem Kontakt des ADC und teilen sie dann, um den Durchschnittswert zu erhalten. Wie oben erw√§hnt, hilft dies, das Rauschen der Messwerte zu reduzieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann verwenden wir </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_raw_to_voltage</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um den Rohwert in die reale Spannung umzuwandeln. Aufgrund des oben erw√§hnten Spannungsteilers verdoppeln wir den R√ºckgabewert: Der Lesewert ist die H√§lfte der tats√§chlichen Batteriespannung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstatt knifflige M√∂glichkeiten zu finden, um diese Spannung in einen Prozentsatz der Batterieladung umzuwandeln, geben wir eine einfache Spannung zur√ºck. Lassen Sie die aufrufende Funktion selbst entscheiden, was mit der Spannung geschehen soll - ob sie in einen Prozentsatz der Ladung umgewandelt oder einfach als hoher oder niedriger Wert interpretiert werden soll.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Wert wird in Millivolt zur√ºckgegeben, daher muss die aufrufende Funktion die entsprechende Konvertierung durchf√ºhren. </font><font style="vertical-align: inherit;">Dies verhindert einen √úberlauf des Schwimmers.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED-Einstellung</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_EnableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_DisableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese beiden einfachen Funktionen reichen aus, um die LED zu verwenden. </font><font style="vertical-align: inherit;">Wir k√∂nnen das Licht entweder ein- oder ausschalten. </font><font style="vertical-align: inherit;">Lassen Sie die aufrufende Funktion entscheiden, wann sie ausgef√ºhrt werden soll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnten eine Aufgabe erstellen, die die Batteriespannung regelm√§√üig √ºberwacht und den Status der LED entsprechend √§ndert. Ich sollte jedoch die Batteriespannung in unserem Hauptzyklus abfragen und dann entscheiden, wie die Batteriespannung von dort aus eingestellt werden soll.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint32_t</span> batteryLevel = Odroid_ReadBatteryLevel();<font></font>
<font></font>
<span class="hljs-keyword">if</span> (batteryLevel &lt; <span class="hljs-number">3600</span>)<font></font>
{<font></font>
	Odroid_EnableBatteryLight();<font></font>
}<font></font>
<span class="hljs-keyword">else</span><font></font>
{<font></font>
	Odroid_DisableBatteryLight();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen einfach den Batteriestand im Hauptzyklus anfordern. Wenn die Spannung unter dem Schwellenwert liegt, schalten Sie die LED ein, um anzuzeigen, dass ein Ladevorgang erforderlich ist. </font><font style="vertical-align: inherit;">Aufgrund der untersuchten Materialien kann ich sagen, dass 3600 mV (3,6 V) ein gutes Zeichen f√ºr eine geringe Ladung von Lithium-Ionen-Batterien sind, aber die Batterien selbst sind komplex.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid gehen schematisch</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF-Dokumentation: ADC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Batterieeigenschaften</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 6: Ton</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der letzte Schritt, um eine vollst√§ndige Schnittstelle zu aller Odroid Go-Hardware zu erhalten, besteht darin, eine Soundebene zu schreiben. Wenn wir damit fertig sind, k√∂nnen wir beginnen, uns einer allgemeineren Programmierung des Spiels zuzuwenden, die weniger mit der Programmierung f√ºr Odroid zu tun hat. Alle Interaktionen mit Peripherieger√§ten werden √ºber die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktionen ausgef√ºhrt </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund meiner mangelnden Erfahrung mit Soundprogrammierung und des Mangels an guter Dokumentation seitens IDF nahm die Implementierung von Sound bei der Arbeit an einem Projekt die meiste Zeit in Anspruch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Letztendlich war nicht so viel Code erforderlich, um den Sound abzuspielen. Die meiste Zeit wurde damit verbracht, die Audiodaten in den gew√ºnschten ESP32 zu konvertieren und den ESP32-Audiotreiber so zu konfigurieren, dass er der Hardwarekonfiguration entspricht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundlagen des digitalen Klangs</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digitaler Sound besteht aus zwei Teilen: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufnahme</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiedergabe</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufzeichnung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Ton auf einem Computer aufzunehmen, m√ºssen wir ihn zuerst aus dem Raum eines kontinuierlichen (analogen) Signals in den Raum eines diskreten (digitalen) Signals konvertieren. </font><font style="vertical-align: inherit;">Diese Aufgabe wird mit einem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analog-Digital-Wandler (ADC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erledigt </font><font style="vertical-align: inherit;">(√ºber den wir in Teil 2 bei der Arbeit mit dem Kreuz gesprochen haben). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der ADC empf√§ngt eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probe der</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eingehenden Welle und digitalisiert den Wert, der dann in einer Datei gespeichert werden kann.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abspielen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine digitale Audiodatei kann mithilfe eines </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digital-Analog-Wandlers (DAC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vom digitalen in den analogen Raum zur√ºckgegeben werden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">DAC kann Werte nur in einem bestimmten Bereich wiedergeben. </font><font style="vertical-align: inherit;">Beispielsweise kann ein 8-Bit-DAC mit einer 3,3-V-Quelle analoge Spannungen im Bereich von 0 bis 3,3 mV in Schritten von 12,9 mV (3,3 V geteilt durch 256) ausgeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der DAC nimmt digitale Werte auf und wandelt sie wieder in Spannung um, die an einen Verst√§rker, Lautsprecher oder ein anderes Ger√§t √ºbertragen werden kann, das ein analoges Audiosignal empfangen kann.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abtastrate</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Aufnahme von analogem Ton √ºber den ADC werden Samples mit einer bestimmten Frequenz aufgenommen, und jedes Sample ist zu einem bestimmten Zeitpunkt eine ‚ÄûMomentaufnahme‚Äú des Tonsignals. Dieser Parameter wird als </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abtastfrequenz bezeichnet</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hertz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gemessen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je h√∂her die Abtastfrequenz, desto genauer werden die Frequenzen des urspr√ºnglichen Signals wiederhergestellt. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Satz von Nyquist-Shannon (Kotelnikov)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt (in einfachen Worten), dass die Abtastfrequenz doppelt so hoch sein sollte wie die h√∂chste Signalfrequenz, die wir aufzeichnen m√∂chten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das menschliche Ohr kann ungef√§hr im Bereich </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von 20 Hz bis 20 kHz h√∂ren</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , daher wird die Abtastfrequenz von </font><strong><font style="vertical-align: inherit;">44,1 kHz</font></strong><font style="vertical-align: inherit;"> am h√§ufigsten verwendet, um qualitativ hochwertige Musik wiederherzustellen</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist etwas mehr als das Doppelte der maximalen Frequenz, die das menschliche Ohr erkennen kann. Dies stellt sicher, dass ein vollst√§ndiger Satz von Instrumentenfrequenzen und Stimmen neu erstellt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes Sample nimmt jedoch Platz in der Datei ein, sodass wir nicht die maximale Sampling-Rate ausw√§hlen k√∂nnen. Wenn Sie jedoch nicht schnell genug probieren, k√∂nnen Sie wichtige Informationen verlieren. Die ausgew√§hlte Abtastfrequenz sollte von den Frequenzen abh√§ngen, die im neu erstellten Ton vorhanden sind. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wiedergabe sollte mit derselben Abtastfrequenz wie die Quelle erfolgen, da sonst der Klang und die Dauer unterschiedlich sind.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, zehn Sekunden Ton wurden mit einer Abtastfrequenz von 16 kHz aufgezeichnet. </font><font style="vertical-align: inherit;">Wenn Sie es mit einer Frequenz von 8 kHz spielen, ist der Ton niedriger und die Dauer betr√§gt 20 Sekunden. </font><font style="vertical-align: inherit;">Wenn Sie es mit einer Abtastfrequenz von 32 kHz spielen, ist der h√∂rbare Ton h√∂her und der Ton selbst dauert f√ºnf Sekunden. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Video zeigt den Unterschied in den Abtastraten anhand von Beispielen.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bittiefe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Abtastfrequenz ist nur die halbe Miete. Der Sound hat auch eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bittiefe, dh</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Anzahl der Bits pro Sample. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der ADC ein Sample eines Audiosignals erfasst, muss er diesen analogen Wert in einen digitalen Wert umwandeln. Der Bereich der erfassten Werte h√§ngt von der Anzahl der verwendeten Bits ab. 8 Bit (256 Werte), 16 Bit (65.526 Werte), 32 Bit (4.294.967.296 Werte) usw. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anzahl der Bits pro Abtastung h√§ngt mit dem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamikbereich des</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klangs zusammen, d.h. mit den lautesten und leisesten Teilen. Die h√§ufigste Bittiefe f√ºr Musik betr√§gt 16 Bit. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hrend der Wiedergabe muss die gleiche Bittiefe wie bei der Quelle angegeben werden, da sich sonst der Klang und die Dauer √§ndern.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie haben beispielsweise eine Audiodatei mit vier Samples, die als 8 Bit gespeichert sind: [0x25, 0xAB, 0x34, 0x80]. </font><font style="vertical-align: inherit;">Wenn Sie versuchen, sie so abzuspielen, als w√§ren sie 16-Bit, erhalten Sie nur zwei Samples: [0x25AB, 0x3480]. </font><font style="vertical-align: inherit;">Dies f√ºhrt nicht nur zu falschen Werten von Klangbeispielen, sondern halbiert auch die Anzahl der Abtastwerte und damit die Dauer des Klangs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist auch wichtig, das Format der Proben zu kennen. </font><font style="vertical-align: inherit;">8-Bit ohne Vorzeichen, 8-Bit ohne Vorzeichen, 16-Bit ohne Vorzeichen, 16-Bit ohne Vorzeichen usw. </font><font style="vertical-align: inherit;">Normalerweise sind 8-Bit vorzeichenlos und 16-Bit vorzeichenlos. </font><font style="vertical-align: inherit;">Wenn sie verwirrt sind, wird der Ton stark verzerrt. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Video zeigt den Unterschied in der Bittiefe anhand von Beispielen.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WAV-Dateien</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am h√§ufigsten werden rohe Audiodaten auf einem Computer im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WAV-Format gespeichert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das einen einfachen Header enth√§lt, der das Audioformat (Abtastfrequenz, Bittiefe, Gr√∂√üe usw.) beschreibt, gefolgt von den Audiodaten selbst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Sound wird √ºberhaupt nicht komprimiert (im Gegensatz zu Formaten wie MP3), sodass wir ihn problemlos abspielen k√∂nnen, ohne dass eine Codec-Bibliothek erforderlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Hauptproblem bei WAV-Dateien besteht darin, dass sie aufgrund der fehlenden Komprimierung sehr gro√ü sein k√∂nnen. Die Dateigr√∂√üe steht in direktem Zusammenhang mit der Dauer, der Abtastrate und der Bittiefe. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√∂√üe = Dauer (in Sekunden) x Abtastrate (Abtastwerte / s) x Bittiefe (Bit / Abtastwert)</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Abtastfrequenz wirkt sich am meisten auf die Dateigr√∂√üe aus. Der einfachste Weg, Platz zu sparen, besteht darin, einen ausreichend niedrigen Wert auszuw√§hlen. </font><font style="vertical-align: inherit;">Wir werden einen Old-School-Sound erzeugen, daher passt eine niedrige Abtastfrequenz zu uns.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I2S</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32 verf√ºgt √ºber Peripherieger√§te, aufgrund derer es relativ einfach ist, eine Schnittstelle mit Audioger√§ten bereitzustellen: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inter-IC Sound (I2S)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das I2S-Protokoll ist recht einfach und besteht aus nur drei Signalen: einem Taktsignal, einer Auswahl von Kan√§len (links oder rechts) und auch der Datenleitung selbst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Taktfrequenz h√§ngt von der Abtastfrequenz, der Bittiefe und der Anzahl der Kan√§le ab. Die Beats werden f√ºr jedes Datenbit ersetzt. F√ºr eine ordnungsgem√§√üe Klangwiedergabe m√ºssen Sie daher die Taktfrequenz entsprechend einstellen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taktfrequenz = Abtastfrequenz (Samples / s) x Bittiefe (Bits / Sample) x Anzahl der Kan√§le</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der ESP32-Mikrocontroller-I2S-Treiber verf√ºgt √ºber zwei m√∂gliche Modi: Er kann entweder Daten an Kontakte ausgeben, die an einen externen I2S-Empf√§nger angeschlossen sind, der das Protokoll decodieren und Daten an den Verst√§rker √ºbertragen kann, oder er kann Daten an einen internen ESP32-DAC √ºbertragen, der ein analoges Signal ausgibt, an das gesendet werden kann Verst√§rker. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go hat keinen I2S-Decoder auf der Karte, daher m√ºssen wir den internen 8-Bit-ESP32-DAC verwenden, dh wir m√ºssen 8-Bit-Sound verwenden. </font><font style="vertical-align: inherit;">Das Ger√§t verf√ºgt √ºber zwei DACs, von denen einer an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und der andere an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26 angeschlossen ist</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verfahren sieht folgenderma√üen aus:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir √ºbertragen Audiodaten an den I2S-Treiber</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der I2S-Treiber sendet Audiodaten an den internen 8-Bit-DAC</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der interne DAC gibt ein analoges Signal aus</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das analoge Signal wird an den Tonverst√§rker √ºbertragen</font></font></li>
<li>      </li>
<li>  </li>
</ol><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/d93/a8e/2d9d93a8ed6eceb35846c0f31e336ec9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir uns die Audio- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schaltung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">der Odroid Go-Schaltung ansehen</font></a><font style="vertical-align: inherit;"> , sehen wir zwei GPIO-Pins ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), die mit den Eing√§ngen des Tonverst√§rkers ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAM8304A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) verbunden sind. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25 ist</font></font></strong><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
auch mit dem Signal </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD des</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verst√§rkers </font><font style="vertical-align: inherit;">verbunden, </font><strong><font style="vertical-align: inherit;">dh</font></strong><font style="vertical-align: inherit;"> dem Kontakt, </font><strong><font style="vertical-align: inherit;">der den</font></strong><font style="vertical-align: inherit;"> Verst√§rker </font><strong><font style="vertical-align: inherit;">ein-</font></strong><font style="vertical-align: inherit;"> oder ausschaltet (niedriges Signal bedeutet Abschalten). Die Verst√§rkerausg√§nge sind mit einem Lautsprecher ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) verbunden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> daran, dass </font><strong><font style="vertical-align: inherit;">IO25</font></strong><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausg√§nge von 8-Bit-ESP32-DACs sind, dh ein DAC ist mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und der andere mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN + verbunden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Differenzeing√§nge des</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tonverst√§rkers. Differenzeing√§nge werden verwendet, um durch </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elektromagnetische St√∂rungen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verursachte </font><strong><font style="vertical-align: inherit;">St√∂rungen</font></strong><font style="vertical-align: inherit;"> zu reduzieren </font><font style="vertical-align: inherit;">. Jedes in einem Signal vorhandene Rauschen ist auch in einem anderen vorhanden. Ein Signal wird von einem anderen subtrahiert, wodurch Rauschen vermieden wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">technischen Daten des Tonverst√§rkers</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ansehen </font><font style="vertical-align: inherit;">, verf√ºgt er √ºber eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">typische Anwendungsschaltung. Dies</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die vom Hersteller empfohlene Art, den Verst√§rker zu verwenden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/044/d2a/323/044d2a323366c5ddb3c3b87f918bf5f9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Er empfiehlt, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit Masse, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dem Eingangssignal und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dem Ein / Aus-Signal zu verbinden. Wenn es ein Ger√§usch von 0,005 V, dann mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- </font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0V + 0,005 V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gelesen werden </font><font style="vertical-align: inherit;">, und mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN + 0,005 V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die Eingangssignale m√ºssen voneinander subtrahiert werden und erhalten den wahren Signalwert ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ohne Rauschen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Entwickler von Odroid Go verwendeten jedoch nicht die empfohlene Konfiguration. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir uns noch einmal die Odroid Go-Schaltung ansehen, sehen wir, dass die Entwickler den DAC-Ausgang mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- verbunden haben</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und dass derselbe DAC-Ausgang mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD verbunden ist</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist ein Abschaltsignal mit einem aktiven niedrigen Pegel. Damit der Verst√§rker funktioniert, m√ºssen Sie ein hohes Signal einstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass wir zur Verwendung des Verst√§rkers den </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25 nicht</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als DAC verwenden d√ºrfen, sondern als GPIO-Ausgang mit einem immer hohen Signal. In diesem Fall wird jedoch ein hohes Signal auf </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- gesetzt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was von der Spezifikation des Verst√§rkers nicht empfohlen wird (es muss geerdet sein). Dann m√ºssen wir den an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angeschlossenen DAC </font><strong><font style="vertical-align: inherit;">verwenden</font></strong><font style="vertical-align: inherit;"> , da unser I2S-Ausgang </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zugef√ºhrt werden muss </font><font style="vertical-align: inherit;">. Dies bedeutet, dass wir nicht die notwendige Rauschunterdr√ºckung erreichen, da </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht mit Masse verbunden ist. Von den Lautsprechern geht st√§ndig ein leises Ger√§usch aus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir m√ºssen die korrekte Konfiguration des I2S-Treibers sicherstellen, da wir nur den an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angeschlossenen DAC verwenden </font><strong><font style="vertical-align: inherit;">m√∂chten</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn wir einen an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angeschlossenen DAC verwenden </font><strong><font style="vertical-align: inherit;">w√ºrden</font></strong><font style="vertical-align: inherit;"> , w√ºrde dies das Signal des Verst√§rkers st√§ndig ausschalten und der Ton w√§re schrecklich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zus√§tzlich zu dieser Verr√ºcktheit erfordert der I2S-Treiber im ESP32 bei Verwendung eines internen 8-Bit-DAC die √úbertragung von 16-Bit-Samples, sendet jedoch nur das High-Byte an den 8-Bit-DAC. </font><font style="vertical-align: inherit;">Daher m√ºssen wir unseren 8-Bit-Sound in einen doppelt so gro√üen Puffer einf√ºgen, w√§hrend der Puffer halb leer ist. </font><font style="vertical-align: inherit;">Dann √ºbergeben wir es an den I2S-Treiber und es √ºbergibt dem DAC das High-Byte jedes Samples. </font><font style="vertical-align: inherit;">Leider bedeutet dies, dass wir f√ºr 16 Bit ‚Äûbezahlen‚Äú m√ºssen, aber wir k√∂nnen nur 8 Bit verwenden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multitasking</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider kann das Spiel nicht auf einem Kern funktionieren, wie ich es urspr√ºnglich wollte, da es einen Fehler im I2S-Treiber zu geben scheint. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der I2S-Treiber muss DMA verwenden (wie der SPI-Treiber), dh wir k√∂nnen einfach die √úbertragung von I2S initiieren und dann unsere Arbeit fortsetzen, w√§hrend der I2S-Treiber Audiodaten √ºbertr√§gt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen ist die CPU f√ºr die Dauer des Sounds blockiert, was f√ºr das Spiel v√∂llig ungeeignet ist. Stellen Sie sich vor, Sie dr√ºcken die Sprungtaste und das Sprite des Players pausiert seine Bewegung f√ºr 100 ms, w√§hrend der Sprungton abgespielt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dieses Problem zu l√∂sen, k√∂nnen wir die Tatsache nutzen, dass sich an Bord des ESP32 zwei Kerne befinden. </font><font style="vertical-align: inherit;">Wir k√∂nnen im zweiten Kern eine Aufgabe (d. H. Einen Thread) erstellen, die sich mit der Tonwiedergabe befasst. </font><font style="vertical-align: inherit;">Dank dessen k√∂nnen wir den Zeiger auf den Soundpuffer von der Hauptaufgabe des Spiels auf die Soundaufgabe √ºbertragen, und die Soundaufgabe initiiert die √úbertragung von I2S und ist f√ºr die Dauer der Soundwiedergabe blockiert. </font><font style="vertical-align: inherit;">Die Hauptaufgabe auf dem ersten Kern (mit Eingabeverarbeitung und Rendering) wird jedoch weiterhin ohne Blockierung ausgef√ºhrt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir dies wissen, k√∂nnen wir den I2S-Treiber ordnungsgem√§√ü initiieren. </font><font style="vertical-align: inherit;">Dazu ben√∂tigen Sie nur wenige Codezeilen. Die Schwierigkeit besteht jedoch darin, herauszufinden, welche Parameter Sie f√ºr eine ordnungsgem√§√üe Klangwiedergabe einstellen m√ºssen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> AUDIO_AMP_SD_PIN = GPIO_NUM_25;<font></font>
<font></font>
<span class="hljs-keyword">static</span> QueueHandle_t gQueue;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlayTask</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span>
</span>{
	<span class="hljs-keyword">for</span>(;;)<font></font>
	{<font></font>
		QueueData data;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (xQueueReceive(gQueue, &amp;data, <span class="hljs-number">10</span>))<font></font>
		{<font></font>
			<span class="hljs-keyword">size_t</span> bytesWritten;<font></font>
			i2s_write(I2S_NUM_0, data.buffer, data.length, &amp;bytesWritten, portMAX_DELAY);<font></font>
			i2s_zero_dma_buffer(I2S_NUM_0);<font></font>
		}<font></font>
<font></font>
		vTaskDelay(<span class="hljs-number">1</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeAudio</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-comment">// Configure the amplifier shutdown signal</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; AUDIO_AMP_SD_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
<font></font>
		gpio_set_level(AUDIO_AMP_SD_PIN, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure the I2S driver</span><font></font>
	{<font></font>
		<span class="hljs-keyword">i2s_config_t</span> i2sConfig= {};<font></font>
<font></font>
		i2sConfig.mode = I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN;<font></font>
		i2sConfig.sample_rate = <span class="hljs-number">5012</span>;<font></font>
		i2sConfig.bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT;<font></font>
		i2sConfig.communication_format = I2S_COMM_FORMAT_I2S_MSB;<font></font>
		i2sConfig.channel_format = I2S_CHANNEL_FMT_ONLY_LEFT;<font></font>
		i2sConfig.dma_buf_count = <span class="hljs-number">8</span>;<font></font>
		i2sConfig.dma_buf_len = <span class="hljs-number">64</span>;<font></font>
<font></font>
		ESP_ERROR_CHECK(i2s_driver_install(I2S_NUM_0, &amp;i2sConfig, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>));<font></font>
		ESP_ERROR_CHECK(i2s_set_dac_mode(I2S_DAC_CHANNEL_LEFT_EN));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Create task for playing sounds so that our main task isn't blocked</span><font></font>
	{<font></font>
		gQueue = xQueueCreate(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(QueueData));<font></font>
		assert(gQueue);<font></font>
<font></font>
		BaseType_t result = xTaskCreatePinnedToCore(&amp;PlayTask, <span class="hljs-string">"I2S Task"</span>, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>);<font></font>
		assert(result == pdPASS);<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst konfigurieren wir </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (das mit dem Ausschaltsignal des Verst√§rkers verbunden ist) als Ausgang, damit er den Klangverst√§rker steuern kann, und legen ein hohes Signal an, um den Verst√§rker einzuschalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes konfigurieren und installieren wir den I2S-Treiber selbst. </font><font style="vertical-align: inherit;">Ich werde jeden Teil der Konfiguration Zeile f√ºr Zeile analysieren, da jede Zeile einer Erkl√§rung bedarf:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modus</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir setzen den Treiber als Master (Steuerung des Busses), als Sender (weil wir Daten an die Empf√§nger √ºbertragen) und konfigurieren ihn f√ºr die Verwendung des integrierten 8-Bit-DAC (weil die Odroid Go-Karte keinen externen DAC hat).</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispielrate</font></font><ul>
<li>    5012,      ,   ,      .   ,      ,          .    -,           2500 .</li>
</ul></li>
<li>bits_per_sample<ul>
<li>  ,    ESP32  8-,   I2S ,      16    ,   8     .</li>
</ul></li>
<li>communication_format<ul>
<li>      ,   ,   -   ,   8-      16- .</li>
</ul></li>
<li>channel_format<ul>
<li> GPIO,    <strong>IN+</strong>   ‚Äî  <strong>IO26</strong>,       ¬´¬ª   I2S.  ,  I2S      ,      <strong>IO25</strong>,      ,          .</li>
</ul></li>
<li>dma_buf_count  dma_buf_len<ul>
<li>  DMA-   ( )  ,        ,   ,        IDF.       ,     .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann erstellen wir eine Warteschlange - auf diese Weise sendet FreeRTOS Daten zwischen Aufgaben. Wir stellen Daten in die Warteschlange einer Aufgabe und extrahieren sie aus der Warteschlange einer anderen Aufgabe. Erstellen Sie eine Struktur namens </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die den Zeiger auf den </font><strong><font style="vertical-align: inherit;">Soundpuffer</font></strong><font style="vertical-align: inherit;"> und die L√§nge des Puffers zu einer einzigen Struktur kombiniert, die in die Warteschlange gestellt werden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie als N√§chstes eine Aufgabe, die auf dem zweiten Kern ausgef√ºhrt wird. Wir verbinden es mit der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">, die die Tonwiedergabe durchf√ºhrt. Die Aufgabe selbst ist eine Endlosschleife, die st√§ndig √ºberpr√ºft, ob sich Daten in der Warteschlange befinden. Wenn dies der Fall ist, sendet sie sie an den I2S-Treiber, damit sie abgespielt werden k√∂nnen. Der </font><strong><font style="vertical-align: inherit;">i2s_write-</font></strong><font style="vertical-align: inherit;"> Aufruf wird blockiert</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und das passt zu uns, weil die Aufgabe auf einem vom Hauptthread des Spiels getrennten Kernel ausgef√ºhrt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Aufruf von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i2s_zero_dma_buffer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist erforderlich, damit nach Abschluss der Wiedergabe keine T√∂ne mehr aus den Lautsprechern kommen. </font><font style="vertical-align: inherit;">Ich wei√ü nicht, ob dies ein Fehler des I2S-Treibers oder des erwarteten Verhaltens ist, aber ohne diesen gibt der Lautsprecher nach Beendigung der Wiedergabe des Soundpuffers ein M√ºllsignal aus.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ton abspielen</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_PlayAudio</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span>* buffer, <span class="hljs-keyword">size_t</span> length)</span>
</span>{<font></font>
	QueueData data = {};<font></font>
<font></font>
	data.buffer = buffer;<font></font>
	data.length = length;<font></font>
<font></font>
	xQueueSendToBack(gQueue, &amp;data, portMAX_DELAY);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund der Tatsache, dass die gesamte Konfiguration bereits abgeschlossen wurde, ist der Aufruf der Soundpuffer-Wiedergabefunktion selbst √§u√üerst einfach, da die Hauptarbeit in einer anderen Aufgabe erledigt wird. </font><font style="vertical-align: inherit;">Wir setzen den Zeiger auf den Puffer und die L√§nge des Puffers in die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><font style="vertical-align: inherit;">und setzen ihn dann in die Warteschlange, die von der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion verwendet wird </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund dieses Betriebsmusters muss ein Soundpuffer die Wiedergabe abschlie√üen, bevor der zweite Puffer gestartet werden kann. </font><font style="vertical-align: inherit;">Wenn also ein Sprung und ein Schie√üen gleichzeitig stattfinden, wird der erste Ton vor dem zweiten und nicht gleichzeitig damit abgespielt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√∂chstwahrscheinlich werde ich in Zukunft verschiedene Frame-Sounds in den Soundpuffer mischen, der an den I2S-Treiber √ºbertragen wird. </font><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen Sie mehrere Sounds gleichzeitig abspielen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden unsere eigenen Soundeffekte mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsfxr erzeugen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , einem Tool, das speziell entwickelt wurde, um die Art von Spiel-Sounds zu erzeugen, die wir ben√∂tigen. </font><font style="vertical-align: inherit;">Wir k√∂nnen die Abtastfrequenz und die Bittiefe direkt einstellen und dann die WAV-Datei ausgeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe einen einfachen Sprung-Soundeffekt erstellt, der dem Klang von Marios Sprung √§hnelt. </font><font style="vertical-align: inherit;">Es hat eine Abtastfrequenz von 5012 (wie wir es w√§hrend der Initialisierung konfiguriert haben) und eine Bittiefe von 8 (da der DAC 8-Bit ist).</font></font><br>
<br>
<div class="oembed"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://austinmorlan.com/posts/embedded_game_programming_6/media/jump.wav</font></font></a></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstatt die WAV-Datei direkt im Code zu analysieren, werden wir etwas √Ñhnliches tun, wie wir das Sprite in der Demo von Teil 4 geladen haben: Wir werden den WAV-Header mit dem Hex-Editor aus der Datei entfernen. Dank dessen sind die von der SD-Karte gelesenen Dateien nur Rohdaten. Au√üerdem werden wir die Dauer des Sounds nicht lesen, sondern in den Code schreiben. In Zukunft werden wir Soundressourcen anders laden, aber das reicht f√ºr die Demo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Rohdatei kann hier heruntergeladen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Load sound effect</span>
<span class="hljs-keyword">uint16_t</span>* soundBuffer;
<span class="hljs-keyword">int</span> soundEffectLength = <span class="hljs-number">1441</span>;<font></font>
{<font></font>
	FILE* soundFile = fopen(<span class="hljs-string">"/sdcard/jump"</span>, <span class="hljs-string">"r"</span>);<font></font>
	assert(soundFile);<font></font>
<font></font>
	<span class="hljs-keyword">uint8_t</span>* soundEffect = <span class="hljs-built_in">malloc</span>(soundEffectLength);<font></font>
	assert(soundEffect);<font></font>
<font></font>
	soundBuffer = <span class="hljs-built_in">malloc</span>(soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	assert(soundBuffer);<font></font>
<font></font>
	fread(soundEffect, soundEffectLength, <span class="hljs-number">1</span>, soundFile);<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; soundEffectLength; ++i)<font></font>
    {<font></font>
        <span class="hljs-comment">// 16 bits required but only MSB is actually sent to the DAC</span>
        soundBuffer[i] = (soundEffect[i] &lt;&lt; <span class="hljs-number">8u</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir laden die 8-Bit-Daten in den 8-Bit- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SoundEffect-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puffer </font><font style="vertical-align: inherit;">und kopieren diese Daten dann in den 16-Bit- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SoundBuffer-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puffer </font><font style="vertical-align: inherit;">, in dem die Daten in den hohen acht Bits gespeichert werden. </font><font style="vertical-align: inherit;">Ich wiederhole - dies ist aufgrund der Funktionen der IDF-Implementierung erforderlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir einen 16-Bit-Puffer erstellt haben, k√∂nnen wir den Klang eines Knopfdrucks wiedergeben. </font><font style="vertical-align: inherit;">Es w√§re logisch, hierf√ºr die Lautst√§rketaste zu verwenden.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> lastState = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (;;)<font></font>
{<font></font>
	[...]<font></font>
<font></font>
	<span class="hljs-keyword">int</span> thisState = input.volume;<font></font>
<font></font>
	<span class="hljs-keyword">if</span> ((thisState == <span class="hljs-number">1</span>) &amp;&amp; (thisState != lastState))<font></font>
	{<font></font>
		Odroid_PlayAudio(soundBuffer, soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	}<font></font>
<font></font>
	lastState = thisState;<font></font>
<font></font>
	[...]<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir √ºberwachen den Status der Schaltfl√§che, damit Sie versehentlich mit einem Klick auf die Schaltfl√§che nicht versehentlich </font><font style="vertical-align: inherit;">mehrmals </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid_PlayAudio</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufrufen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ihr Browser unterst√ºtzt kein HTML5-Video.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_6/media/demo.mp4" type="video/mp4"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der gesamte Quellcode ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid gehen schematisch</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenblatt f√ºr Audioverst√§rker</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF-Dokumentation: DAC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF-Dokumentation: I2S</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WAVE-Dateiformat</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video: Erkl√§rung der Bittiefe</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video: Erkl√§rung zur Abtastrate</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de503854/index.html">Verwenden Sie SIL maximal</a></li>
<li><a href="../de503858/index.html">Das Buch "Terraform: Infrastruktur auf Codeebene"</a></li>
<li><a href="../de503860/index.html">Einrichten der neuronalen Netzwerkumgebung Maske R-CNN</a></li>
<li><a href="../de503864/index.html">Flavours Organization bei Flutter</a></li>
<li><a href="../de503866/index.html">Ver√∂ffentlichte Roadmap-Entwicklung Zextras Suite f√ºr 2020</a></li>
<li><a href="../de503880/index.html">Wie ich gelernt habe, mir keine Sorgen zu machen und die Bildverarbeitung liebte</a></li>
<li><a href="../de503884/index.html">Wie man lernt, asynchron zu arbeiten</a></li>
<li><a href="../de503888/index.html">AdaBoost-Algorithmus</a></li>
<li><a href="../de503890/index.html">Die Geschichte, wie ich Azure AD B2C f√ºr React and React Native konfiguriert habe Teil 1 (Tutorial)</a></li>
<li><a href="../de503892/index.html">Mitap: Quarant√§ne, geh weg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>