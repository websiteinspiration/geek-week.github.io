<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüëß‚Äçüë¶ üê§ ‚õèÔ∏è Berapa banyak metode yang harus di kelas? üåµ üî∫ üíÉüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mungkin ini adalah salah satu masalah paling penting yang dihadapi oleh pengembang menggunakan kelas. Kami memiliki prinsip-prinsip SOLID, kami memili...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Berapa banyak metode yang harus di kelas?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506736/"><div style="text-align:center;"><img width="400" src="https://habrastorage.org/webt/ht/bc/ds/htbcds3dl1emxblkn29nn5cqr0w.png"></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin ini adalah salah satu masalah paling penting yang dihadapi oleh pengembang menggunakan kelas. Kami memiliki prinsip-prinsip SOLID, kami memiliki visi kami sendiri tentang perbedaan yang indah dan besar. Saya tidak berharap memberikan jawaban yang lengkap "berapa banyak metode yang harus di kelas Anda". Tetapi saya akan membagikan pemikiran saya tentang mengapa harus ada lebih sedikit metode di kelas, apalagi. Hingga 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk tingkat yang lebih besar, alasan saya menyangkut layanan (objek stateless), yang menurut saya menang atas jenis objek lain dalam proyek nyata. Kelas tidak seharusnya menyimpan sendiri gado-gado metode hanya karena implementasi yang sama!</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah mengetahui dasar-dasar OOP, pemula mengasosiasikan kelas dan benda dengan kucing dan anjing. Artinya, di bawah kesan pertama, objek dianggap sebagai proyeksi dunia nyata atau beberapa model yang berisi serangkaian metode yang diperlukan untuk menyelesaikan masalah. Dan ini pendapat yang bagus tentang OOP, lebih tepatnya dari yang seharusnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi setelah beberapa proyek komersial, tampilan runtuh. Perusahaan dikuasai oleh model layanan dan anemia. Saya tidak tahu apakah itu baik atau buruk, tapi itu kenyataan. Oleh karena itu, dalam praktiknya, kelas tebal sering diperoleh yang tidak memiliki analogi dengan dunia nyata dan tidak setuju dengan generalisasi yang tidak ambigu. Seringkali mereka disebut layanan, seringkali mereka membentuk lapisan. Dan pemahaman objek turun ke level - sekelompok metode dengan tujuan yang sama. Atau metode yang bekerja dengan data serupa. Atau sesuatu yang serupa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap kali saya mulai menulis layanan, saya berpikir untuk waktu yang lama tentang namanya ... Berarti Layanan Lain lagi dan lagi. </font><font style="vertical-align: inherit;">Tetapi bagaimana jika tidak ada kata benda? </font><font style="vertical-align: inherit;">Bagaimana nama layanan mencerminkan gado-gado permintaan yang dikumpulkan di dalam? </font><font style="vertical-align: inherit;">Siapa yang biasanya menggunakan metode ini sekaligus? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh refactoring dari Paman Bob tidak membiarkan saya pergi untuk waktu yang lama [Clean Code, p. 177]:</font></font><br>
<br>
<pre><code class="plaintext hljs">class Sql {<font></font>
    constructor(private table: string, private columns: Column[]) {}<font></font>
<font></font>
    public create(): string;<font></font>
    public insert(fields: object[]): string;<font></font>
    public selectAll(): string;<font></font>
    public select(criteria: Criteria): string;<font></font>
<font></font>
    // ...<font></font>
}<font></font>
</code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas Sql berubah ketika jenis perintah baru ditambahkan. </font><font style="vertical-align: inherit;">Selain itu, itu akan berubah ketika mengubah rincian implementasi dari jenis perintah yang ada ... Dua alasan untuk perubahan berarti bahwa kelas Sql melanggar prinsip tanggung jawab yang seragam.</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah hasil konversi.</font></font><br>
<br>
<pre><code class="plaintext hljs">abstract class Sql {<font></font>
    constructor(private table: string, private columns: Column[]) {}<font></font>
<font></font>
    public abstract generate(): string;<font></font>
}<font></font>
<font></font>
class CreateSql extends Sql {<font></font>
    public generate(): string;<font></font>
}<font></font>
<font></font>
class SelectSql extends Sql {<font></font>
    public generate(): string;<font></font>
}<font></font>
<font></font>
// ...<font></font>
</code></pre><br>
<blockquote>      . ,    ,    .  ,       ,  .            ,       .<br>
<br>
   ,      Update,         !<br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheka berulang kali menyebutkan bahwa kelas harus kompak. Tetapi contoh ini menyenangkan dengan kekhususannya, dan ini sungguh menakjubkan! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya pikir, karena ada begitu banyak keuntungan dari pemisahan, mengapa pada kenyataannya kelas yang membengkak menang? Karena kita akan memecah kelas ke tingkat fungsi dan akan menjadi lebih sulit untuk memahami gambaran besarnya? (Tapi apakah FP-Schnicks kompleks tentang ini?) Atau karena enkapsulasi akan keluar dari layanan-layanan lemak kita? Tampak bagi saya bahwa ada sisi gelap yang menjaga rahasia kelas besar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang diberikan kelas dalam hal konstruksi bahasa program, jika kita membuang romansa? Kelas memiliki sisi terang - metode publik yang secara otomatis membentuk antarmuka objek. Antarmuka membentuk abstraksi, yang seharusnya menyederhanakan program. Ini romansa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi jika Anda melihat secara pragmatis, maka kelas hanya mengumpulkan dependensi yang diperlukan melalui konstruktor, menyimpan anggota pribadi yang tidak digunakan di tempat lain dan menyediakan klien dengan serangkaian fungsi menempel (publik). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan ini adalah sisi gelap - bidang pribadi, metode pribadi, dan dependensi. Inilah yang paling sering dipandu oleh pengembang dengan menggabungkan metode dalam layanan. Kadang-kadang tampaknya jika kelas berisi semua anggota yang diperlukan, maka ini adalah tempat terbaik untuk metode baru! Dan layanan berubah menjadi penjaga dependensi dan metode yang membutuhkan dependensi ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejak kapan ketergantungan bersama harus menyatukan sesuatu? </font><font style="vertical-align: inherit;">Kesamaan implementasi internal bukan alasan untuk membuat abstraksi. </font><font style="vertical-align: inherit;">Dengan kata lain, menambahkan metode baru ke layanan karena "sangat mirip dengan metode lain" dalam implementasinya, kami melanggar enkapsulasi, SRP, OCP, dan ISP. </font><font style="vertical-align: inherit;">Tapi saya terus-menerus menemukan ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, dalam praktiknya, arsitektur layanan tidak membentuk abstraksi tingkat tinggi, tetapi hanya mewakili analogi proseduralisme. </font><font style="vertical-align: inherit;">Selain itu, analogi terburuknya, karena prosedur tidak memiliki entitas berlebihan dalam bentuk nama layanan semu-generik dan tidak menarik dependensi yang tidak digunakan. </font><font style="vertical-align: inherit;">(Suatu tempat FPShniki suram). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat contoh dari dokumentasi resmi Angular.</font></font><br>
<br>
<pre><code class="javascript hljs">@Injectable({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroService</span> </span>{<font></font>
 private heroesUrl = <span class="hljs-string">'api/heroes'</span>;<font></font>
 private httpOptions = { <span class="hljs-attr">headers</span>: <span class="hljs-keyword">new</span> HttpHeaders({ <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> }) };<font></font>
 <font></font>
 <span class="hljs-keyword">constructor</span>(private http: HttpClient, private messageService: MessageService) {}<font></font>
 <font></font>
 getHero(id: number): Observable&lt;Hero&gt; {<font></font>
   <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.heroesUrl}</span>/<span class="hljs-subst">${id}</span>`</span>;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.get&lt;Hero&gt;(url).pipe(<font></font>
     tap(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> <span class="hljs-keyword">this</span>.log(<span class="hljs-string">`fetched hero id=<span class="hljs-subst">${id}</span>`</span>)),<font></font>
     catchError(<span class="hljs-keyword">this</span>.handleError&lt;Hero&gt;(<span class="hljs-string">`getHero id=<span class="hljs-subst">${id}</span>`</span>)),<font></font>
   );<font></font>
 }<font></font>
 <font></font>
 addHero(hero: Hero): Observable&lt;Hero&gt; {<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.post&lt;Hero&gt;(<span class="hljs-keyword">this</span>.heroesUrl, hero, <span class="hljs-keyword">this</span>.httpOptions).pipe(<font></font>
     tap(<span class="hljs-function">(<span class="hljs-params">newHero: Hero</span>) =&gt;</span> <span class="hljs-keyword">this</span>.log(<span class="hljs-string">`added hero w/ id=<span class="hljs-subst">${newHero.id}</span>`</span>)),<font></font>
     catchError(<span class="hljs-keyword">this</span>.handleError&lt;Hero&gt;(<span class="hljs-string">'addHero'</span>)),<font></font>
   );<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">// ...</span><font></font>
 <font></font>
 private handleError&lt;T&gt;(operation = <span class="hljs-string">'operation'</span>, result?: T) {
   <span class="hljs-keyword">return</span> (error: any): Observable&lt;T&gt; =&gt; {
     <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> send the error to remote logging infrastructure</span>
     <span class="hljs-built_in">console</span>.error(error); <span class="hljs-comment">// log to console instead</span>
     <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> better job of transforming error for user consumption</span>
     <span class="hljs-keyword">this</span>.log(<span class="hljs-string">`<span class="hljs-subst">${operation}</span> failed: <span class="hljs-subst">${error.message}</span>`</span>);
     <span class="hljs-keyword">return</span> <span class="hljs-keyword">of</span>(result <span class="hljs-keyword">as</span> T);<font></font>
   };<font></font>
 }<font></font>
}<font></font>
</code></pre><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HeroService sepenuhnya</font></font></b>
                        <div class="spoiler_text"><pre><code class="javascript hljs">@Injectable({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroService</span> </span>{<font></font>
 <font></font>
 private heroesUrl = <span class="hljs-string">'api/heroes'</span>;  <span class="hljs-comment">// URL to web api</span><font></font>
 <font></font>
 httpOptions = {<font></font>
   <span class="hljs-attr">headers</span>: <span class="hljs-keyword">new</span> HttpHeaders({ <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> })<font></font>
 };<font></font>
 <font></font>
 <span class="hljs-keyword">constructor</span>(<font></font>
   private http: HttpClient,<font></font>
   private messageService: MessageService) { }<font></font>
 <font></font>
 <span class="hljs-comment">/** GET heroes from the server */</span><font></font>
 getHeroes(): Observable&lt;Hero[]&gt; {<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.get&lt;Hero[]&gt;(<span class="hljs-keyword">this</span>.heroesUrl)<font></font>
     .pipe(<font></font>
       tap(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-keyword">this</span>.log(<span class="hljs-string">'fetched heroes'</span>)),<font></font>
       catchError(<span class="hljs-keyword">this</span>.handleError&lt;Hero[]&gt;(<span class="hljs-string">'getHeroes'</span>, []))<font></font>
     );<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">/** GET hero by id. Will 404 if id not found */</span><font></font>
 getHero(id: number): Observable&lt;Hero&gt; {<font></font>
   <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.heroesUrl}</span>/<span class="hljs-subst">${id}</span>`</span>;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.get&lt;Hero&gt;(url).pipe(<font></font>
     tap(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-keyword">this</span>.log(<span class="hljs-string">`fetched hero id=<span class="hljs-subst">${id}</span>`</span>)),<font></font>
     catchError(<span class="hljs-keyword">this</span>.handleError&lt;Hero&gt;(<span class="hljs-string">`getHero id=<span class="hljs-subst">${id}</span>`</span>))<font></font>
   );<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">/* GET heroes whose name contains search term */</span><font></font>
 searchHeroes(term: string): Observable&lt;Hero[]&gt; {<font></font>
   <span class="hljs-keyword">if</span> (!term.trim()) {
     <span class="hljs-comment">// if not search term, return empty hero array.</span>
     <span class="hljs-keyword">return</span> <span class="hljs-keyword">of</span>([]);<font></font>
   }<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.get&lt;Hero[]&gt;(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.heroesUrl}</span>/?name=<span class="hljs-subst">${term}</span>`</span>).pipe(<font></font>
     tap(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.length ?
        <span class="hljs-keyword">this</span>.log(<span class="hljs-string">`found heroes matching "<span class="hljs-subst">${term}</span>"`</span>) :
        <span class="hljs-keyword">this</span>.log(<span class="hljs-string">`no heroes matching "<span class="hljs-subst">${term}</span>"`</span>)),<font></font>
     catchError(<span class="hljs-keyword">this</span>.handleError&lt;Hero[]&gt;(<span class="hljs-string">'searchHeroes'</span>, []))<font></font>
   );<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">//////// Save methods //////////</span><font></font>
 <font></font>
 <span class="hljs-comment">/** POST: add a new hero to the server */</span><font></font>
 addHero(hero: Hero): Observable&lt;Hero&gt; {<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.post&lt;Hero&gt;(<span class="hljs-keyword">this</span>.heroesUrl, hero, <span class="hljs-keyword">this</span>.httpOptions).pipe(<font></font>
     tap(<span class="hljs-function">(<span class="hljs-params">newHero: Hero</span>) =&gt;</span> <span class="hljs-keyword">this</span>.log(<span class="hljs-string">`added hero w/ id=<span class="hljs-subst">${newHero.id}</span>`</span>)),<font></font>
     catchError(<span class="hljs-keyword">this</span>.handleError&lt;Hero&gt;(<span class="hljs-string">'addHero'</span>))<font></font>
   );<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">/** DELETE: delete the hero from the server */</span><font></font>
 deleteHero(hero: Hero | number): Observable&lt;Hero&gt; {<font></font>
   <span class="hljs-keyword">const</span> id = <span class="hljs-keyword">typeof</span> hero === <span class="hljs-string">'number'</span> ? hero : hero.id;
   <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.heroesUrl}</span>/<span class="hljs-subst">${id}</span>`</span>;<font></font>
 <font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.delete&lt;Hero&gt;(url, <span class="hljs-keyword">this</span>.httpOptions).pipe(<font></font>
     tap(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-keyword">this</span>.log(<span class="hljs-string">`deleted hero id=<span class="hljs-subst">${id}</span>`</span>)),<font></font>
     catchError(<span class="hljs-keyword">this</span>.handleError&lt;Hero&gt;(<span class="hljs-string">'deleteHero'</span>))<font></font>
   );<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">/** PUT: update the hero on the server */</span><font></font>
 updateHero(hero: Hero): Observable&lt;any&gt; {<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.put(<span class="hljs-keyword">this</span>.heroesUrl, hero, <span class="hljs-keyword">this</span>.httpOptions).pipe(<font></font>
     tap(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-keyword">this</span>.log(<span class="hljs-string">`updated hero id=<span class="hljs-subst">${hero.id}</span>`</span>)),<font></font>
     catchError(<span class="hljs-keyword">this</span>.handleError&lt;any&gt;(<span class="hljs-string">'updateHero'</span>))<font></font>
   );<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">/**
  * Handle Http operation that failed.
  * Let the app continue.
  * <span class="hljs-doctag">@param <span class="hljs-variable">operation</span></span> - name of the operation that failed
  * <span class="hljs-doctag">@param <span class="hljs-variable">result</span></span> - optional value to return as the observable result
  */</span>
 private handleError&lt;T&gt;(operation = <span class="hljs-string">'operation'</span>, result?: T) {
   <span class="hljs-keyword">return</span> (error: any): Observable&lt;T&gt; =&gt; {<font></font>
 <font></font>
     <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> send the error to remote logging infrastructure</span>
     <span class="hljs-built_in">console</span>.error(error); <span class="hljs-comment">// log to console instead</span><font></font>
 <font></font>
     <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> better job of transforming error for user consumption</span>
     <span class="hljs-keyword">this</span>.log(<span class="hljs-string">`<span class="hljs-subst">${operation}</span> failed: <span class="hljs-subst">${error.message}</span>`</span>);<font></font>
 <font></font>
     <span class="hljs-comment">// Let the app keep running by returning an empty result.</span>
     <span class="hljs-keyword">return</span> <span class="hljs-keyword">of</span>(result <span class="hljs-keyword">as</span> T);<font></font>
   };<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">/** Log a HeroService message with the MessageService */</span><font></font>
 private log(message: string) {<font></font>
   <span class="hljs-keyword">this</span>.messageService.add(<span class="hljs-string">`HeroService: <span class="hljs-subst">${message}</span>`</span>);<font></font>
 }<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah layanan khas. </font><font style="vertical-align: inherit;">(Saya bahkan akan mengatakan "praktik terbaik"). </font><font style="vertical-align: inherit;">Dan sekilas semuanya baik-baik saja dengannya. </font><font style="vertical-align: inherit;">HeroService bekerja dengan entitas Hero, tidak lebih. </font><font style="vertical-align: inherit;">Banyak yang berlebihan! </font><font style="vertical-align: inherit;">Tidak ada klien yang menggunakan antarmuka secara konsisten - hanya di beberapa bagian. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang harus dilakukan ketika metode API baru untuk Pahlawan muncul? </font><font style="vertical-align: inherit;">Kapan Anda perlu berhenti melipat semuanya menjadi satu dan memecah kelas? </font><font style="vertical-align: inherit;">Saya yakin semua orang menanyakan pertanyaan-pertanyaan ini. </font><font style="vertical-align: inherit;">Tetapi kehadiran layanan ini dalam proyek hanya membingungkan para pengembang, mendorong mereka untuk menulis kode melalui perubahan, bukan ekstensi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat apa yang membuat metode yang ada di dalam HeroService ‚Äúmirip‚Äù dan bagaimana ia rusak.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua metode menggunakan url umum - diselesaikan dengan meletakkan BASE_HERO_API_URL ke dalam konstanta.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa metode menggunakan header http yang sama - diputuskan dengan menempatkannya di interceptor. </font><font style="vertical-align: inherit;">Atau Anda dapat memilih HttpClient khusus yang akan membungkus metode get, post, put, delete dengan opsi yang diperlukan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">handleError - diselesaikan dengan menempatkannya ke kelas yang terpisah, yang akan berfungsi sebagai orang yang bertanggung jawab untuk menangani kesalahan.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ternyata semua faktor pemersatu adalah detail opsional dari implementasi, yang bisa berbeda jika bukan karena kehendak keadaan acak. </font><font style="vertical-align: inherit;">Tidak ada alasan eksternal untuk merger. </font><font style="vertical-align: inherit;">Kami menulis web, dan aneh ketika satu tombol pertama kali memanggil addHero, dan kemudian menggunakan fungsi HeroService lainnya.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tunjukkan kodenya!</font></font></b>
                        <div class="spoiler_text"><pre><code class="javascript hljs">@Injectable({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetHeroesOperation</span> </span>{
 <span class="hljs-keyword">constructor</span>(<font></font>
   private http: HeroHttpClient,<font></font>
   private messageService: MessageService,<font></font>
   private errorHandler: ErrorHandler,<font></font>
 ) {}<font></font>
 <font></font>
 execute(): Observable&lt;Hero[]&gt; {<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.get&lt;Hero[]&gt;().pipe(<font></font>
     tap(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> <span class="hljs-keyword">this</span>.messageService.add(<span class="hljs-string">'fetched heroes'</span>)),<font></font>
     catchError(<span class="hljs-keyword">this</span>.errorHandler.handleError&lt;Hero[]&gt;(<span class="hljs-string">'getHeroes'</span>, [])),<font></font>
   );<font></font>
 }<font></font>
}<font></font>
 <font></font>
@Injectable({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddHeroOperation</span> </span>{
 <span class="hljs-keyword">constructor</span>(<font></font>
   private http: HeroHttpClient,<font></font>
   private messageService: MessageService,<font></font>
   private errorHandler: ErrorHandler,<font></font>
 ) {}<font></font>
 <font></font>
 execute(hero: Hero): Observable&lt;Hero&gt; {<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.post&lt;Hero&gt;(<span class="hljs-string">''</span>, hero).pipe(<font></font>
     tap(<span class="hljs-function">(<span class="hljs-params">newHero: Hero</span>) =&gt;</span> <span class="hljs-keyword">this</span>.logAddedHero(newHero)),<font></font>
     catchError(<span class="hljs-keyword">this</span>.errorHandler.handleError&lt;Hero&gt;(<span class="hljs-string">'addHero'</span>)),<font></font>
   );<font></font>
 }<font></font>
 <font></font>
 private logAddedHero(newHero: Hero): <span class="hljs-keyword">void</span> {
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.messageService.add(<span class="hljs-string">`AddHeroOperation: added hero w/ id=<span class="hljs-subst">${newHero.id}</span>`</span>);<font></font>
 }<font></font>
}<font></font>
 <font></font>
@Injectable({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorHandler</span> </span>{
 <span class="hljs-keyword">constructor</span>(private messageService: MessageService) {}<font></font>
 <font></font>
 handleError&lt;T&gt;(operation: string, result?: T) {<font></font>
   <span class="hljs-keyword">return</span> (error: any): Observable&lt;T&gt; =&gt; {
     <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> send the error to remote logging infrastructure</span>
     <span class="hljs-built_in">console</span>.error(error); <span class="hljs-comment">// log to console instead</span><font></font>
 <font></font>
     <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> better job of transforming error for user consumption</span>
     <span class="hljs-keyword">this</span>.messageService.add(<span class="hljs-string">`<span class="hljs-subst">${operation}</span> failed: <span class="hljs-subst">${error.message}</span>`</span>);<font></font>
 <font></font>
     <span class="hljs-comment">// Let the app keep running by returning an empty result.</span>
     <span class="hljs-keyword">return</span> <span class="hljs-keyword">of</span>(result <span class="hljs-keyword">as</span> T);<font></font>
   };<font></font>
 }<font></font>
}<font></font>
 <font></font>
@Injectable({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroHttpClient</span> </span>{<font></font>
 private httpOptions = { <span class="hljs-attr">headers</span>: <span class="hljs-keyword">new</span> HttpHeaders({ <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> }) };<font></font>
 <font></font>
 <span class="hljs-keyword">constructor</span>(@Inject(BASE_HERO_API_URL) private baseUrl: string, private http: HttpClient) {}<font></font>
 <font></font>
 get&lt;T&gt;(endpoint = <span class="hljs-string">''</span>): Observable&lt;T&gt; {
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.get&lt;T&gt;(<span class="hljs-keyword">this</span>.getUrl(endpoint));<font></font>
 }<font></font>
 <font></font>
 private getUrl(endpoint: string): string {<font></font>
   <span class="hljs-keyword">return</span> Location.joinWithSlash(<span class="hljs-keyword">this</span>.baseUrl, endpoint);<font></font>
 }<font></font>
 <font></font>
 post&lt;T&gt;(endpoint = <span class="hljs-string">''</span>, <span class="hljs-attr">data</span>: unknown): Observable&lt;T&gt; {
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.post&lt;T&gt;(<span class="hljs-keyword">this</span>.getUrl(endpoint), data, <span class="hljs-keyword">this</span>.httpOptions);<font></font>
 }<font></font>
 <font></font>
 put&lt;T&gt;(endpoint = <span class="hljs-string">''</span>, <span class="hljs-attr">data</span>: unknown): Observable&lt;T&gt; {
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.put&lt;T&gt;(<span class="hljs-keyword">this</span>.getUrl(endpoint), data, <span class="hljs-keyword">this</span>.httpOptions);<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-keyword">delete</span>&lt;T&gt;(endpoint = <span class="hljs-string">''</span>): Observable&lt;T&gt; {
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.delete&lt;T&gt;(<span class="hljs-keyword">this</span>.getUrl(endpoint), <span class="hljs-keyword">this</span>.httpOptions);<font></font>
 }<font></font>
}<font></font>
 <font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak mencoba (dan tidak ingin) membuat pernyataan, seperti: "Kelas tidak boleh memiliki lebih dari metode 1!". Tentu saja, mungkin ketika suatu objek memiliki keadaan, aturan lain berlaku. Juga, saya tidak menentang untuk memasukkan metode yang harus digunakan secara konsisten di kelas: isExecutable, validateParams, jalankan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang saya katakan adalah tentang layanan monster. Karena layanan paling sering bukan merupakan abstraksi yang waras. Dan akan lebih baik jika penekanan bergeser ke arah penurunan mereka. Bagi saya sendiri, saya merumuskan prinsip berikut: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas tidak boleh berisi sekumpulan metode hanya karena penerapannya yang serupa.</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengikuti aturan ini, Anda dapat mendeteksi elemen sistem yang hilang yang tersembunyi dalam metode pribadi. </font><font style="vertical-align: inherit;">Pendekatan ini akan membantu untuk mematuhi OCP dan ISP secara harfiah. </font><font style="vertical-align: inherit;">Ketika fitur Anda benar-benar memperluas program, dan jangan menambahkan metode dalam 10 kelas dalam 10 lapisan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya harap Anda menikmatinya. </font><font style="vertical-align: inherit;">Terima kasih! </font><font style="vertical-align: inherit;">Sampai!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id506716/index.html">Daftar Lini Multithreaded: Masalah Keberadaan Elemen, Peningkatan Kinerja, dan Hubungan STL</a></li>
<li><a href="../id506726/index.html">Pengalaman dalam menggunakan teknologi Rutoken untuk registrasi dan otorisasi pengguna dalam sistem (bagian 2)</a></li>
<li><a href="../id506730/index.html">Mendengus atau Suricata. Bagian 1: pilih IDS / IPS gratis untuk melindungi jaringan perusahaan</a></li>
<li><a href="../id506732/index.html">Penggunaan kembali komponen UI di seluruh organisasi</a></li>
<li><a href="../id506734/index.html">Perhitungan sementara dalam jaringan listrik</a></li>
<li><a href="../id506740/index.html">Cara menggunakan Microsoft SQL untuk laporan di Power BI. Pada contoh Mindbox</a></li>
<li><a href="../id506742/index.html">Mengapa pusat piksel harus di (0,5; 0,5)</a></li>
<li><a href="../id506748/index.html">Siapa yang memiliki penjualan karantina yang tumbuh?</a></li>
<li><a href="../id506758/index.html">Produk menyelenggarakan konferensi dengan prinsip open-source, dan selama 10 tahun setiap peserta adalah penyelenggara</a></li>
<li><a href="../id506762/index.html">Security Week 25: Kumpulan pemecahan rekor Microsoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>