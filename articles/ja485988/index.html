<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍲 🧔🏻 🔕 【ロコマイザケース】ヒートマップの計算を2年半で2万倍高速化する方法 👈🏼 👴🏾 🕵🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事はCase Locomizerシリーズの続きです。
 
 

- ユーザー座標で匿名化されたデータセットから実際に抽出できる知識
- Open One Ring-クラウド内のSparkで複雑なデータ処理プロセスを柔軟に構成するためのツールキット
 こんにちは。
 
 
 
 死後のことを知っ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>【ロコマイザケース】ヒートマップの計算を2年半で2万倍高速化する方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485988/"><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事はCase Locomizerシリーズの続きです。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザー座標で匿名化されたデータセットから実際に抽出できる知識</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open One Ring-クラウド内のSparkで複雑なデータ処理プロセスを柔軟に構成するためのツールキット</font></font></a></li>
</ul></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
こんにちは。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fj/uo/jz/fjuojzz4hen-a54ybf62phjmlvk.png" alt="効率：TC、EMR、アイデア" title="効率：TC、EMR、アイデア"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
死後のことを知っていますか？そんな人生にたどり着いた物語です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたについてはわかりませんが、高度に専門化されたソフトウェアや低レベルのソフトウェアの開発プロセスに関するストーリーを読むのは好きです。同僚には興味深いアイデアがあり、プロトタイプから、なじみのない分野で魔法をかける成熟した製品まで、プログラムに何が起こったかを常に知りたいと思っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、そのようなソフトウェアを使用してリポジトリへのリンクを投げるだけでは、誰がそれが何で、なぜであるか、そしてどのタスクを解決するのに役立つかもしれないかの手がかりを得ることができる可能性は低いです。私が英語から翻訳したとしても、開始のための3ダースの指示書です。それでも、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Spark</font></a><font style="vertical-align: inherit;">フレームワーク</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは角の上の別の工芸品ではありません</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">著者がなぜこのように書いたのかを</font><s><font style="vertical-align: inherit;">喫煙者が喫煙した</font></s><font style="vertical-align: inherit;">ことを理解する必要が</font><font style="vertical-align: inherit;">あります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、One Ringの歴史的な紹介です。</font><font style="vertical-align: inherit;">その中にコードはなく、物語は科学よりも人気があります。</font><font style="vertical-align: inherit;">しかし、開発についてのみであり、2年半の開発を除いて、他のものについては何もない。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回、中間バンドの匿名化されたデータセットからデータを抽出することの難しさについて十分詳細に説明しました（結局のところ十分です）、結局私は強い陰謀に追いつきました。</font><font style="vertical-align: inherit;">最後にその解決策を残しておきましょう。本日は、メインツールの完成までの長く困難な道について話します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビッグデータは大きい</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちのケースは非標準です</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C＃とPostGISでのプロトタイプ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hadoop MapReduceへの最初のアプローチ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CIとSparkの登場</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeoSparkでの3番目の近似</font></font></li>
<li>     Azure  AWS</li>
<li>  ,   ,   ,  - !!</li>
<li>    Uber H3</li>
<li>   </li>
</ul><br>
<h3>Big Data is big</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビッグデータはサイズについてではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Greater Londonリージョンの月次データセットには、数千、さらには数億のレコードが存在する可能性がありますが、それだけではありません。それらの最初から最後までの1回の反復は、ディスクからの線形読み取りの速度に依存します。ドライブがSSDの場合、数秒で完了します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（問題のデータセットは、プロバイダーに固有の一連のフィールドを持つCSVファイルのセットであることを思い出します。匿名ユーザーの座標を持つレコードのファイルへのグループ化は、国、都道府県、または市の行政区の境界に沿って行われます。ファイル自体は、選択した日付、毎日または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">毎月。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">詳細はすべて前の部分で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">説明さ</font></a><font style="vertical-align: inherit;">れてい</font><font style="vertical-align: inherit;">ます。十分なコンテキストがない場合は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、斜め</font></a><font style="vertical-align: inherit;">に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">実行してください</font></a><font style="vertical-align: inherit;">。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのプロセスは多段階です。単一の反復モードでのみ機能する初期の生データエンリッチメントヒューリスティックは高速であり、少なくともPythonで、少なくともC ++で、PHPでもそれらを書き込むことができます。弱い機械でも処理が速くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データセットがクラウド内のどこかにある場合、ハンドラーが同じクラウド内に配置されていれば、そこにアクセスして行き、結果を横に保存しても特に問題はありません。さらに、たいていの場合ファイルはすでに存在しています。これは、喜んでデータプロバイダーがアーカイブをクラウドストレージにアップロードし、ダウンロードリンクを提供するためです。あとは仮想マシンをデプロイするだけで、リポジトリにアクセスするためのすべてのライブラリはベンダーによって慎重に配置され、すべてのアクセスキーが登録され、APIを手に持って使用するだけです。それも速くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、最初のステップで、すべてが明確です。彼らはファイルを取り、数回実行し、処理済みのバージョンを元に戻しました。しかし、アルゴリズムの後続のステップで、各レコードに対して若干複雑な計算のセットが必要な場合はどうなりますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
座標のペア間の距離を決定するようなものを取ります。非常に高速な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haversine</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">（ホールのバージョンに応じて「haversinuses」）があります。これは、短い距離で許容可能な精度を提供し</font><font style="vertical-align: inherit;">、計算がはるかにゆっくりと実行さ</font><font style="vertical-align: inherit;">れる</font></font><abbr title="World Geodetic System '84、現在は標準のジオイド"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WGS84</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジオイドを取得できないように</font><font style="vertical-align: inherit;">します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それ自体、そのような計算は、それが単一である場合、それほどコストがかからないことがわかりました。そして、それらが数千万存在するとしても、これは原則としてナンセンスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、選択したカテゴリから各信号から各POIまでの距離を計算する必要がある場合に、特許取得済みのアルゴリズムの事例を取り上げ、0.5 kmを超えるもの（歩きやすい距離など）を破棄します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グレーターロンドン地域の場合、</font><font style="vertical-align: inherit;">約100万の施設が、店舗およびアウトレットカテゴリの</font><font style="vertical-align: inherit;">対象</font></font><abbr title="興味のあるポイント"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POI</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に分類されます。</font><font style="vertical-align: inherit;">そして私が言ったように、毎月の数十のデータセットで、何億ものレコードが彼のために来ます。</font><font style="vertical-align: inherit;">そして、私たちは...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,000,000 POI×N、000,000信号= N、000,000,000,000距離。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あ、来て </font><font style="vertical-align: inherit;">何兆もの距離計算としきい値定数の比較。</font><abbr title=",          "><font style="vertical-align: inherit;">デカルト積</font></abbr></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の古典的な状況</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">特に強力ではない2つの個別のセットは、N×10 </font><sup><font style="vertical-align: inherit;">12を</font></sup><font style="vertical-align: inherit;">簡単に与える</font></font><abbr title=",          "><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暫定結果、1つの地域で1か月のみです。そのような量はすでに品質になっています。中間結果のサイズはメモリに完全に収まらないため、すでに深刻な問題であるだけでなく、受信した場所ですぐに処理する必要がありますが、それを取得するために必要な計算の数は、非常に多くのコンピュータ時間を必要とします。また、1つのレコードの場合、ネットワーク経由の伝送におけるすべての遅延とその他のオーバーヘッドコストを考慮して、100ナノ秒しか費やされない場合、数百万秒は1つのストリームでの計算の日と週です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、「特定の地域に住んでいるユーザーの関心を考慮に入れない」という条件など、一般的な母集団からセグメントを破棄する必要がある場合は、地域全体のエンリッチメントデータセットの各レコードのdevice_idを、数十万のレコードが含まれるセットと比較する必要があります。このエリアのdevice_id居住者を除外しました。</font><font style="vertical-align: inherit;">そして、これらは多くの点で文字列比較であり、2つのintほど高速ではありません。</font><font style="vertical-align: inherit;">繰り返しになりますが、1つの単純な操作の評価にはある種の異常な数のゼロがあり、ダース以上の平均的なプロジェクトのヒューリスティックの完全なセットに対してゼロがあります。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビッグデータとは、そのサイズのために、処理が不適切または非実用的であるため、特別なアルゴリズム手法を直接使用する必要があるデータです。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...計算の最終結果がExcelテーブルの1つの画面に折りたたまれている場合でも。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計算を実行するマシンで利用可能な仮想プロセッサの数によって、「単純な」ハンドラーを並列化することができます。データセットを断片に分割し、クラウド内のダースの仮想マシンでラインストーンの計算を実行できます。しかし、これらすべてが質的に優れた結果をもたらすわけではありません。 「幅内」にスケーリング</font><font style="vertical-align: inherit;">すると、特定の幅から始まる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リターン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">減少します</font></a><font style="vertical-align: inherit;">。また、同期とパーティショニングの問題は確実に出てきます。仮想マシン全体を管理すると、時間と費用がかかります。それらを常にオンにしておくことはコストがかかり、オンデマンドでの開始と停止は労働集約的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ビッグデータの場合、すでにスケールコントロールが設定されているHadoopエコシステムの特別なソフトウェアパッケージと、天文学的な量の中間データを窒息させるリスクなしにマンモスが小さな部分を食べることができる特別なアルゴリズムセットが使用され、ビッグデータ開発者の生活を大幅に簡素化します。</font><font style="vertical-align: inherit;">ただし、Hadoopを使い始めることはできません。</font><font style="vertical-align: inherit;">まず、計画を立てる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に…</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちのケースは非標準です</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大規模なデータセットの分析に携わるオフィスがプロセスを構築する方法を尋ねると、2つの主要なアプローチが世界の実践で使用されていることがわかります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプローチ番号1。</font><font style="vertical-align: inherit;">データレイク</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間の経過とともに蓄積され、永久に関連し続ける</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ために、いわゆる「</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">データレイク</font></a><font style="vertical-align: inherit;">」</font><font style="vertical-align: inherit;">と呼ばれる特別なタイプのストレージが設計されてい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなリポジトリのアーキテクチャは、迅速なランダムアクセスのために最適化されています。収集されたデータセットの多くは、列セットによる複数基準の選択とスライスをすばやく実行できる特殊な形式に変換されます。従来のリレーショナルデータベースやドキュメント指向データベースとは異なり、列ストレージはデータレイクで使用されます。通常、それらは最終的なものです。つまり、データを含むコンテナの形式は、データの入力とインデックス作成の後に、同じデータセット内のデータが再び変更されることはありません。たとえば、変更を必要としない寄木細工のファイル。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、データの群衆- </font><abbr title="scientist"><font style="vertical-align: inherit;">悪魔主義者は</font></abbr><font style="vertical-align: inherit;">急いでいます</font></font><abbr title="scientist"><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはデータ</font></font><abbr title="analyst"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナリスト</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、および専用ソフトウェア（Jupyterのような「ラップトップ」）で統計、指標などを収集します。</font><font style="vertical-align: inherit;">オンライン。</font><font style="vertical-align: inherit;">これらの統計情報は、湖の外のどこかでアンロードされるか、後続の集計のために同じ最終ファイルの形式で単に一緒に追加されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプローチ番号2。</font><font style="vertical-align: inherit;">データストリーミング</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リアルタイムで到着し、迅速に処理する必要のあるデータ（ストリーミングデータなど）に対しては、データバスまたはメッセージキューが設計されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データバスを備えたインフラストラクチャでは、一端にジェネレータがあり、他端にコンシューマがあり、データストリーム自体はイベントで構成されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレータが生成され、コンシューマはリアルタイムまたはほぼリアルタイムでイベントを分析し、最終結果を蓄積します。これにより、次のアグリゲータのセットが同じバスを介して消費するイベントが生成され、最終結果が得られるまで続きます。最終結果のリポジトリに折りたたまれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Apache KafkaとAerospikeのような高速ストレージによって駆動されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちのケース</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私たちのケースはこれら2つのアプローチに適合しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、データセットが1年以上続くことはめったになく（2019年の2016年のユーザートラックは誰も必要としなくなったため）、データレイクを保持しても意味がありません。また、蓄積されたすべてのデータの完全に予測不可能な部分が顧客に必要になるたびに。また、母集団とカテゴリーの各セグメントに対して独自のテンプレートが作成されるという事実により、必要な部分のみを取得することを余儀なくされ、それらを共通の湖にマージすることはあまり意味がありません。毎月の各データセットを元の形式で保存する方が簡単です-CSVファイルは個別のディレクトリにあります。ファイルへのパスが取得されます... /プロバイダー/国/地域/サブリージョン/年/月/データセットファイル。サブセットは、ファイル名マスクによって単に選択されます。たとえば、... / Tamoco / UK / Greater_London / * / 2019 / {6、 7.8} / *。Csv。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二に、データセットの性質はストリーミングではなく、離散的です。もちろん、ネットワークストレージへのアップロードプロセスでいくつかの指標を直接計算することもできますが、モスクワ地域と隣接地域のモスクワ地域の完成したヒートマップは、モスクワと地域を組み合わせた地域の完成したヒートマップと相関しません（あまりにも多くの人がこの地域に住んでいてモスクワで働いているという事実のために）、そして私たちはまだどの地域が必要になるかを前もって知りません。たぶん、モスクワもモスクワ地域もではなく、一部の都市17。ヒューリスティックを駆使してすべてのデータセットのインジケーターを計算するには、非常にコストがかかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、蓄積されたデータセットのサブセットをすばやく選択し、電力に適したコンピューティングファームをすばやく展開し、独自の標準化された計算プロセスをすばやく実行し、結果を吐き出さなければなりません。おそらく、再びこのサイズのサブセットまたはファームに戻ることはありません。 、テンプレートではありません。また、適切に調整されたパフォーマンスクラスターを独自のハードウェア上に維持することは絶対に不可能です。これにより、すべてのプロジェクトのニーズが最も小さいものから最も難しいものまでカバーされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはそれほどユニークではないと思います。同僚との会話では、同様の</font><abbr title="!,  , ,    .."><font style="vertical-align: inherit;">バースト</font></abbr><font style="vertical-align: inherit;">を計測する必要性</font><abbr title="!,  , ,    .."><font style="vertical-align: inherit;">が</font></abbr><font style="vertical-align: inherit;">定期的に現れます。</font></font><abbr title="!,  , ,    .."><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-ケース、しかしここでは誰もが独自の方法でプロセスを構築します。</font><font style="vertical-align: inherit;">通常、非標準の場合のソリューションは、側面のアプローチNo. 1またはNo. 2から既存のコンベヤーに取り付けられます。</font><font style="vertical-align: inherit;">私たちのプロセスは完全にプライベートプロジェクトで構成されており、「バースト」などのすべてのタスクがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そう。</font><font style="vertical-align: inherit;">2年間とペニーの間、私は私の仕事をできるだけ自動化するためのツールキットを思いつくことができました、そして私は私の物語の第3部で一般的な使用のためにそれを紹介します。</font><font style="vertical-align: inherit;">それまでの間、進化と、それらのすべての間違いや問題について話しましょう。私たちが経験によって持続可能なプロセスに到達した問題を修正して解決します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C＃とPostGISでのプロトタイプ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはすべて数年前に始まりました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aleksey PolyakovとAleksey Polyakov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という2人の非常に賢い人物</font><font style="vertical-align: inherit;">-笑わないでください、彼らは実際には同名ですが、生物学者とマーケティング担当者である世界のさまざまな場所から、実験によりマウスまでの細胞培養における細胞集団の集団的行動に論文からの方法を適用することにしました、広告とマーケティングに。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは人々に働きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ロコマイザープロジェクトが始まりました。</font><abbr title=",  -"><font style="vertical-align: inherit;">LLCの</font></abbr><font style="vertical-align: inherit;">スタートアップのようなものなので、「プロジェクト」と言います</font></font><abbr title=",  -"><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">契約を結ぶが、完全ではない。私たちのチームメンバーは世界中に散らばっており、フリーランサーまたはアウトソーサーとして（そしてフルタイムではなく）さまざまな場所やオフィスで働いています。また、注文を受けたり見つけたりするときに、さまざまなやり取りのモデルを持つ非常にさまざまなお客様にアルゴリズムを使用しています。サブスクリプションがありますが、よりプライベートな1回限りのタスクです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それは今です。そして数年前は、すべてがさらに混沌としていました。速度を計算するための最初のソフトウェア実装をだれが書いたか、私は一般に知りません。 （これらの未知の英雄を突然知ったら、彼らに挨拶してください。）最後の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">記事の</font></a><font style="vertical-align: inherit;">終わりに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定の都市でのプログラマーのキャリアについて、私は文字通り次のように書いています。「私は現在働いている場所と話をするようになり、PMは敷居からプロジェクトは地獄だと述べました。</font><font style="vertical-align: inherit;">何もない。</font><font style="vertical-align: inherit;">繰り返しになりますが、GISのみ、計算はすべてMapReduce（およびSparkで必要です）、ArcGISのマップに基づいており、これはすべて、誰も考案できない雲の中で回転しています。</font><font style="vertical-align: inherit;">私の意見では、素晴らしいオプションです！」</font><font style="vertical-align: inherit;">-その時はすでにそうでした、そして私はコードでプロジェクトの形成の最初の段階を思い出すことによってのみ復元できます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mitra_kun</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自分自身が1年前にプロジェクトに出演した人。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生データセットを処理するための基本的なヒューリスティックはPHP、Python、C ++で記述されており、ヒートマップの速度の主な計算はC＃のプログラムによって実行されました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ni/yp/qc/niypqcxxu3ugnbt1mx16ecnuhds.png" alt="   C#" title="   C#" align="right"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼女はこのように働きました：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず、データセットファイルから文字列を配列に直接読み込みます。</font></font></li>
<li>  foreach’,  -  .</li>
<li> POI —      PostgreSQL  PostGIS-   GEOMETRY,           POI      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">ST_DISTANCE</a>,    -     .</li>
<li>   foreach      interest score     .</li>
<li>  ,    .</li>
<li>  ,         ,     CSV…</li>
<li>…    ,   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">ArcGIS</a>.</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最大処理量がマシンで利用可能なメモリによって制限されていることは明らかであり、データベースへの単一クエリの速度は特定のアラームを引き起こします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hadoop MapReduceへの最初のアプローチ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ローカルプロトタイプで何らかの計算が行われ、データセットの準備とヒートマップの作成に適用された処理の妥当性が確認され、作業をどのように運用するかという疑問が生じました。</font><font style="vertical-align: inherit;">まあ、手動で日没に対処するのではなく、産業クジラによって作成されたプラットフォームの機能を使用し、少なくとも最小限にスケーリングすることが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先ほど言ったように、標準のビッグデータ処理プラットフォームはHadoopエコシステムです。分散ファイルシステム、タスクを並列化するためのシェダー、map-reduceに対する比較的便利な抽象化、クエリを実行するためのエンジン、さらにはデータ分析のための膨大なものさえも含む、異種ライブラリの大規模なセット。また、このソフトウェアインフラストラクチャはすべて、さまざまなベンダーのクラウドで統合パッケージの形で利用でき、自動化されますが、その詳細については後で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OK Google、Hadoopを検索して。私の前任者たちはプロトタイプを取り、主要な計算をC＃からJavaに書き直し、文字通りすべてのforeachを対応するHadup MapperおよびReducerで置き換え、すべての手順を実行してスクリプト言語の個別のユーティリティにデータセットを強化し、より速く開発できるようにしました。顧客アルゴリズムは活発に進化し始めました。私たちは、SpringでWeb UIのバックエンド（以前のJava開発の経験がない場合は、PHPで書くほうがよい）ではなく、Node.jsの前面にArcGISからのマップ統合を個別に記述し始めました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oq/i3/ye/oqi3yehxn8ybmjbh0j1g0f4sqj4.png" alt="    Java" title="    Java" align="left"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このケースでは、Microsoft Azureの5つの仮想マシンでHadoopの「大規模クラスター」を調達しました。 Azureを選ぶ理由まず、新興企業にとって、最初の数年間は大きな割引があります。次に、マップの視覚化用のArcGIS Desktop for Windowsは、このクラウドにすでに導入されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hadoopクラスターは手動でデプロイされ、対応するAzure HDInsightサービスからではなく、構成が困難でした。それぞれのクラスターマシンで、Postgre + PostGIS（MRとベースがプロセッサをめぐって競争し始めているため、かなり疑わしい決定）を発生させ、別のサーバーに距離を置かないようにしました。クラスタのノード全体にPOIデータベースのレプリカを分散させる小さなスクリプトを作成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトはまだプロトタイプであり、もう少し進んでいます。ジオフェンシングが登場したためPostGISがまだ使用されていましたが、彼らは最小限の労力でそれを他にどのように実装できるかをまだ知りませんでした。すべてがひどく遅いように感じられ、手作業で行わなければならないステップの数は12を超えました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私がその小さな町で非常に知られていないITタウン（イジェフスクには、開発スタッフを擁する7ダース以上のオフィスがあり、約3000人のプログラマーが働いている）からの提案に興味を持ったのはそのときでした。突然、理由もなく、配備と自動化の豊富な経験を持つシニアJava開発者が必要となり、少なくともビッグデータとクラウドについて耳から聞いた。さて、クラウドとビッグデータについて少し聞いたときです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のすべてについては、私は十分な経験を持っています:(したがって、コードとプロセスの状態を見たときに最初に言ったのは、アルテミー・レベデフの最高の伝統であり、大声で多くのことでした。それを繰り返すことはしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、コードとプロセスが理解できる品質であれば、間違いなく最適化を行う場所があります。手始めに、少なくとも一度に1つずつPostGISにリクエストを送信できますが、バッチでは一度に約5000ポイントを送信できます。データベースは、原則として、デカルト積の解決のために最適化されています。言われています-完了しました。ST_DISTANCE呼び出しを使用したスト​​レージは、ポイントのパッケージの大きな配列をすぐに返すように書き直されました。また、データベースへの接続をそれほど頻繁に確立する必要がなくなったため、最初から計算がすぐに40倍高速化され、インデックスも非常に多くなりました。 POIを使用したテーブル内のジオメトリについては、非常にセンスよく機能し始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確かに、プロトタイプがC＃からJavaに完全に正しく移植されていないため、厄介な難解なエラーが計算に含まれていました。連中は1つの重要な変数のポイントを逃し、プロトタイプの正式なTKはまったく到達せず、途中でどこかに負けました。その後、断片的な説明からすべてのアルゴリズムを復元しましたが、これはすでに非常に遅れていました。ただし、このエラーは全体として計算結果を損なうものではなく、ヒートマップのコントラストを低下させるだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、マッパーはHDFSからデータを読み取り、それを書き戻すため、MapReduceのパフォーマンスはそれほど向上しません。チェーン内の次のレデューサーも同じように続き、すべての手順が完了するまで続きます。</font><font style="vertical-align: inherit;">また、特に設定によりアルゴリズムに分岐がある場合は、マルチステッププロセスを管理するのも非常に不便です。</font><font style="vertical-align: inherit;">アルゴリズム全体はハードコードであり、どういうわけかステップを並べ替える場合は、独自のランチャーを使用してそれらを個別のモジュールに移動し、何らかのロジックを外部でラップする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、クラスター内の各ノードでデータベースを複製したとしても、計算内からPostGISを引き出すことは、非常に骨の折れる考えです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CIとSparkの登場</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-自動化してください！ - </font><font style="vertical-align: inherit;">ヒキガエルの</font><font style="vertical-align: inherit;">enterprayznogo </font><b><font style="vertical-align: inherit;">n</font></b><font style="vertical-align: inherit;"> rogrammirovaniyaに</font><font style="vertical-align: inherit;">続く</font><font style="vertical-align: inherit;">私の2番目の主要な</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイテム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rofessionalnyの興味</font><font style="vertical-align: inherit;">...そしていいえ。 2番目-それは</font><b><font style="vertical-align: inherit;">n</font></b><font style="vertical-align: inherit;"> itstsa、</font><b><font style="vertical-align: inherit;">n</font></b><font style="vertical-align: inherit;"> asta、</font><b><font style="vertical-align: inherit;">n</font></b><font style="vertical-align: inherit;"> udingiで、3番目は</font><b><font style="vertical-align: inherit;">-n</font></b><font style="vertical-align: inherit;"> stop </font><b><font style="vertical-align: inherit;">n</font></b><font style="vertical-align: inherit;">プロセスとその自動化です。 （Iとして、</font><font style="vertical-align: inherit;">シェフ</font><b><font style="vertical-align: inherit;">のp</font></b><font style="vertical-align: inherit;">オヴァール、オンに愛のすべて</font><b><font style="vertical-align: inherit;">のp</font></b><font style="vertical-align: inherit;">。ハッシュタグ＃</font><b><font style="vertical-align: inherit;">P</font></b><font style="vertical-align: inherit;">クッキー。）</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手仕事はあまりにも多くの危険を伴います。同じことをしたとしても、人々は信頼性が低く、間違いを犯すことが多いため、プロジェクトの全体的な流れを形式化し、ユーティリティを呼び出して長期ストレージからオンラインストレージにデータセットをコピーするときに失敗せず、ステップの順序を混同しないスクリプトを書くことは、はるかに効率的です。熊手を歩き続けるより。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイクウォーキングは、最初に解決しなければならない最も深刻な問題でした。まず、別の小さな仮想</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">TeamCity</font></a><font style="vertical-align: inherit;">に展開しました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そしてすべてのテストを実行してアセンブリをセットアップし、チェックされたアーティファクトが常に手元にあるようにし、手動でクラスターにスローする必要がないようにします。 2番目のステップは、ラッパーを作成して、指定されたデータセットとクラスターのパラメーターのセットで1つのMRタスクを同じTCから直接開始し、元のデータセットのクラスターへの同じ自動コピーと結果ストアの計算結果を使用することでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、習慣から多くの時間を費やした3番目のステップは、クラスター自体のデプロイを自動化し、パラメーターを調整し、Azure Blob Storageに組み込まれたデータセットで計算を開始することでした。突然、5つの仮想マシンの静的クラスターが失われ始めたプロジェクトや、HDFS上の古いファイルのダンプとデータセットを混合しないプロジェクトがありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Azure HDInsightは実際には</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hortonworks HDP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（彼のために安心してください）、およびその設定の一部はAPIで行われ、一部は</font><abbr title="Web UI  , ,    Web UI"><font style="vertical-align: inherit;">Ambari</font></abbr><font style="vertical-align: inherit;">を通じてのみ登録できます</font></font><abbr title="Web UI  , ,    Web UI"><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">クラウドの負荷に応じてクラスターをデプロイするのに最大で1時間かかる場合があり、チューニングサイクル、つまりコードのパフォーマンスに対する設定の影響をチェックするのに丸一日かかる場合があります。</font><font style="vertical-align: inherit;">仮想マシンのローカルバージョンのHDPサンドボックスは11 GBのRAMを消費し、ディスクサブシステムに膨大な負荷がかかるため、ローカルデバッグでも非常に不快であり、その設定はクラウドバージョンとわずかに異なります。</font><font style="vertical-align: inherit;">私は実験に多くの時間を費やしましたが、少なくともすべてがどのように機能するか、そして次のOOMで計算が途中で突然ハングした場合の対処法を理解しました。手動でログを解析することも非常に不愉快だからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私がHDPを扱っている間に、別のプログラマーがApache Sparkでデータセットを準備するさまざまな段階を統合し始めました。 Sparkは、1つの計算のステップ間で発生する中間データを絶えず書き込み/読み取りする問題を解決しました。通常、Sparkは、MRのすべての悪い場所を考慮して設計されており、箱から出して何度でも実行できます。そして、Sparkの遅延</font></font><abbr title="Resilient Distributed Dataset,     ,    Spark"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RDD</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は非常に便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、PowerShellでAzureテンプレートをスクリプト化してPostGISのエッジノードを構成しました-クラスター内の独立した太いノーズインスタンスで、リクエストを高速化するためのコアとメモリの束と、ローカルディスクに最初に追加されたデータセットを準備するための準備手順を実行します。次に、クラスターのHDFSにロードされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、対話的にもバッチモードでもTCで個別のビルドとして機能すると考えられていたスクリプトバインディングは、HDInsightスイートからは使用しなかったMR、Spark、およびその他のソフトウェアパッケージで任意のステップの組み合わせを起動する方法を徐々に学びましたが、まだ初歩的なパラメータ化が行われています。ただし、ビルドパラメータを一連の.iniファイル（各プラットフォームコンポーネントおよび各プロセスステップ）を使用して隣接するリポジトリに転送し、このリポジトリのブランチでプロセステンプレートを維持することは、私たちが引き続きそれを使用する便利な方法であることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに進行中です。手動ルーチンの自動化により、計算の準備時間は4分の1に短縮されました。ヒューマンエラーは言うまでもなく、はるかに少なくなりました。しかし、それはまだ計算自体の時ではありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeoSparkでの3番目の近似</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
約半年かかりました。</font><font style="vertical-align: inherit;">この時点までに、デバッグおよびテスト済みのヒューリスティックのセットは徐々に蓄積されており、スクリプトではなく、Spark上の別のアプリケーションですでに実行されており、いくつかの典型的なプロセステンプレートが開発されました。</font><font style="vertical-align: inherit;">今、それらを最適化する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チームまたは企業でこれまでに経験がなかった2人目のプログラマーは、モジュールを非常に簡単に操作しました。1つのヒューリスティックをSparkに転送した後、プロジェクト全体をコピーし、古いアルゴリズムを新しいアルゴリズムに置き換え始めました。その結果、そのような並列モジュールが8つあり、それぞれに類似しているがわずかに異なるパラメーターセットがあり、呼び出しのセマンティクスがいくらか優れており、サービスコードが重複しているため、別の問題が発生し始めました。コードが多ければ多いほど、コードのサポートにかかる時間が長くなります。特に、コードの進化が止まらない場合はなおさらです。そして、継続的なコピーと貼り付けにより、未使用のパラメーターやその他のゴミがそれらに蓄積され始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動化の書き込み問題を終了し、クラスターの構成を処理したので、データ準備モジュールとヒューリスティックスをすでに取り上げることができました。まず、すべての繰り返しコードを個別のCommonsプロジェクトに取り込み、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gitサブモジュール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">としてプラグインし</font><font style="vertical-align: inherit;">ました。計算モジュールでは、混乱が数倍少なくなりました。典型的なヒューリスティックのテンプレートをアセンブルしました。コードの一部を置き換える必要もなく、コミットの履歴に不要なゴミを残さずに、新しいプロジェクトがすでにそこから生まれました。開発が速くなり始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
打ち負かされる次の大きな問題は、デカルト積×POI信号を計算するというロジックそのものから来ました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バッチ処理だけでデータベースに転送されますが、データベースがインデックスとクエリの最適化を効率的に適用しても、操作の数は減りません。必要なしきい値を明らかに超えているペアの距離は考慮しないことが論理的です。しかし、この距離を計算せずに、しきい値を超える距離を持つペアを破棄する方法は？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回答：</font><font style="vertical-align: inherit;">信号とPOIの両方をジオメトリックグリッドに</font></font><abbr title="   Spark —  RDD  ,       ,      "><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分割し</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、ヒートマップはすでにポリゴンのグリッドで構成されています。そして、このグリッドのセルサイズを正しい方法で選択すると、選択したポリゴンからのPOIごとに、同じポリゴンに入る信号、その隣接するセルまでの距離を計算することだけに制限できます。残りは破棄できますが、それらは確かに関連性の範囲外になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sparkには、グリッドを操作するための既製のツール、</font></font><abbr title="  .       :("><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeoSparkがすでにあり</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。 2人目のプログラマがそれを使い始め、「グリッドにデータセットをプルする」という予備操作が現れました。しかし、それはそれほど良くはなりませんでした。ある深刻な問題が別の深刻な問題に置き換えられました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、これは「ロングテール」の問題でした-ユーザー、何百万もの信号の数。それらの多くはありませんが、POIが高いダウンタウンに蓄積され、運が良ければそれらがそこに蓄積される場合、ジオメトリで分割する方法に関係なく（少なくとも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voronoi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、少なくとも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quadtree）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、比較の数が妥当な量を超えるポリゴンが引き続き存在します。ただし、密度が同じである隣接するポリゴンもチェックする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、彩度の低いポリゴンを含むパーティションの99％がすぐに機能する場合、高密度のセルを備えたSparkのワークステーションの1％が勝利するまでハングし続け、無意識のようにメモリを消費し、すべてのラズベリーを台無しにします。 Sparkはすべてを考慮に入れようとしますが、RDDのパーティションのサイズに大きな変動がある場合、メモリ消費のすべてのチューニングは、最大のもののために行われる必要があるため、ドレインを使い果たします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計算の99％が数百回の幾何学的分割により加速され、ロングテールの1％が最適化全体をほとんど何もしないことになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、GeoSparkへの移行により5倍の利益が得られましたが、非常にメモリ効率の悪いエグゼキューターのサイズと、それに応じて高価な仮想マシンを備えたクラスターのサイズのみでした。</font><font style="vertical-align: inherit;">つまり、高密度ジオデータの幾何学的分割は行き止まりであることが判明しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、日本最大の電気通信の分析デスクの人に幸福がありました。</font><font style="vertical-align: inherit;">主要企業が収集した地理位置情報データに基づく小規模な子会社ビジネス。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">日本のアナリストとAzureからAWSへの移行</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
日本人は面白い考え方をしています。彼ら自身は急いでいませんが、外人だけが指を噛むように与えられると、両手は切り刻まれます。日本の特定の日付を決して与えないでください！そして、あなたが電話した場合、少なくとも3回の補給を受けてください。委託条件を調整することは、途方もなく長く、困難であり、有名な日本人の細心の注意だけでなく、考え方の違いも妨げられます。 TORの最終バージョンを実装する時間が残っていない可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
日本の電気通信の「娘」と統合するプロジェクトは、ほとんど私たちのプロジェクトを殺しました。非常識な日本の広告市場のための独占的なデータプロバイダーになる見通しが輝いており、ビジネスは少しです...ええと、私はコメントなしで行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、Azureはありません。 AWSのみ、ハードコアのみ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二に、フロントは彼らのニーズに合うように修正されなければならず、それはプロジェクトを通して絶えず変化していました。このオフィスのマーケティング担当者は、自分たちが確実に知らない何かを常に望んでおり、明確に表現することはできず、ステージごとに10回再計算して、次の新しいインジケーターの計算ロジックをオンザフライで変更する必要がありました。</font><font style="vertical-align: inherit;">
ある時点で、私は少しびっくりして、一連の「基本操作」を行いました-結合、マッピング、デフォルト値の配置、列値の合計などの基本的なメソッドの呼び出しなど、RDDで約15のプリミティブアクション—その他のこのような小さな操作— SQLステートメントのセットであるかのように、計算チェーンのロジックを変更します。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/3n/oy/y1/3noyy1wt6pjuqik6ukzfnmcmy9a.png" alt="  ,   -,   " title="  ,   -,   "></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（通常のSpark SQLは、厳密な型指定または厳密なフィールドセットがないため、この場合は適用できません。データセットでは、いつでも好きなだけフィールドを追加でき、プロセスフロー中に変更されます猿はきつすぎるため、絶えず変化する状況でメタデータを書き込むことはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高レベルのタスクは、日本の任意の地域を選択し、埋立地のインジケーターのタフなヒープを持つ任意のカテゴリのセットを使用して、任意の期間のヒートマップを作成することでした。どのようなインジケーター、それらをカウントする方法-お客様自身はこれを本当に理解していませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが技術を計算しなければならなかった2016-2017のユーザー信号を含むテスト（つまり、小さい）データセットは、5テラバイトのデータ、14,000,000,000レコードです。東京だけで数百万のPOIがあり、北海道地域のグリッドでは160万セルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、47の日本の完全版それぞれの2000のカテゴリすべてのカードは、クラウドサービスとして販売されるため、「オンザフライ」と見なされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
脳を壊す素晴らしい仕事。 「計算速度」と「データ量」の点で、当時の機能よりも3〜4桁高い。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも悲しくなったため、各地域（神道の神々のおかげで、日本人は地域を統一する必要がなかった）と1か月の事前計算を行うことにしました。これにより、事前に準備されたスコアに従ってヒートマップが作成されました。リアルタイムではなく、数分から数十分（東京の中心部の場合）分です。事前計算には、東京AWSリージョンで利用可能な25の最も強力な仮想マシンのクラスターで数か月かかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、AWSで実行するには、まずAWS APIで自動化を書き換える必要がありました。また、異なるクラウドは、外見上同様のサービスを提供しますが、内部的には完全に異なります。この時点でPowerShellはすでにリリース候補バージョン6に達していて、クラスターをデプロイして計算を実行するためのAzurバインディングスクリプトをLinux TeamCityに移植して大胆に実行できることは良いことです（AWSでWindowsにサーバーをデプロイすることはアイデアなので） ）より正確には、移植せずに、あるモニターで既存のスクリプトを開き、別のクラウドの別のモニターで並列実装を記述します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、AWSははるかに古く、Azureより古く、構造的であり、インフラストラクチャの低レベルを構成するための手作業がはるかに多くなっています。また、コンピューティングリソースの販売のためのローカルオークションは、適切なサイズの車が希望の価格でなく、顧客が計算に予算を全額割り当てていない場合に頭痛の種になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、Amazonの化身であるHadoopエコシステム自体（EMR）はバニラにより近いものであり、HDInsightよりも簡単に操作できます。まあ、少なくとも何かが簡単になりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、S3ではありません。ここで彼らが待たなかったところからトラブルが起こりました。 S3には文書化されていない制限があります。たとえば、APIの深いところのどこかで、各リクエストごとに辞書式の順序でキーをソートし、それに割り当てられたバッファがソートを許可しないため、1つのバケットに最大11,000,000オブジェクトを超えることはできません。特に長い場合は、行数を増やします。計算を高速化するために、最後にパーティションをマージせず、ある時点でこの制限に達しました。その後、プロセスは単に停止しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
心によれば、マージを行う必要があり、s3-dist-cpユーティリティというツールさえありますが、その使用は別の頭痛の種です。エイリアンのための捕食者は確かにユーティリティを書いた、それは直感に反するように振る舞う。そして、それは致命的な欠陥を持っています-マージされたファイルの下には、元のファイルと同じだけの容量がHDFS上に必要です。また、25台のマシンのクラスターに分散した数百バイトから数十メガバイトのサイズの数万のパーティションファイルをマージするには、非常に長い時間がかかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、バケット内に既に100万のオブジェクトが存在するため、S3は要求を静かにトロットし始めます。そして、最終的な一貫性のある状況では、これは一般的に災害です。Sparkは、合意された回数、次のデスクを待たずに落ちる可能性があります。解決策があります-EMRFS独自のAmazonアドオンを使用しますが、非常に高価なDynamoDBの上で動作します。また、1秒あたりのリクエスト数に独自の制限があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要するに、時間がまったくない状況で、静的スキームにロールバックすることを決めました-比較的小さいサイズのインスタンスに永続的なクラスターをデプロイします（ただし、DynamoDBよりも安価ですが）、元のデータセットと計算されたデータセットのすべてのテラバイトをHDFSにマージし、カードをローカルで読み取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、次のプロットのひねりは、日本人が生成された六角形グリッドから</font></font><abbr title="再度リンクを張ることはありません。このグリッドの情報は日本語では見つかりません。また、1人のオンライン翻訳者がこのドキュメントを正常に処理することはできません。 東京に拠点を置くアレクセイポリャコフは日本人です。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">日本メッシュ</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に切り替えることの要件でした</font><font style="vertical-align: inherit;">-ポイントの座標のみに依存する長方形のセルで地理的に分割するそれらの標準的な方法。 「グリッドに信号を引き寄せる」という計算が難しいステップを放棄できるので、非常に良いことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不利な点は、Japan Meshメッシュが日本とそれが歴史的にそうであると主張する島の領土にのみ適用可能であり、他の世界には適用できないことです。しかし、少なくとも日本人にとっては、遅いGeoSparkを放棄し、外部のジオメトリを参照せずに信号を均等に分割することが可能になりました。そして、「ロングテール」の逸脱により、計算はすぐに再び10で加速しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たち全員が六角形を理解し、多くのお金と時間を無駄に費やした後でこれが起こったのは残念です。テラバイトの準備されたデータセットを含むクラスターは、単純に破棄する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いずれにしても、作業の途中で、日本人はまだインフラストラクチャ全体を1つのAWSアカウントから別のAWSアカウントに移行するように求めていました。そして、あたかもセットアップで行われたすべての作業を気にしないでください。ええと、移行の時までにCloudFormationテンプレートにスクリプトを作成することができたので、移行は多かれ少なかれスムーズに進みました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ケーキの最後のチェリーとして、日本人はフロントが彼らをあきらめないことを最終的に決定しました、そして彼らは彼らの顧客の要求で手動で計算を引っ張るでしょう、それでアルゴリズムに感謝します（初めて私たちはそれらすべてを詳細に文書化しました-そしていくつかを見つけましたエラー）、そして今のところ。</font><font style="vertical-align: inherit;">ええと...幸運と後でお会いしましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブラー </font><font style="vertical-align: inherit;">私はこのプロジェクトを恐怖と身震いで思い出します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ash Nazg Durbatuluk、Ash Nazg Gimbatul、Ash Nazg Trakatuluk、Ag Burzum Ishi Krimpatul !!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ポジティブから、すべてのアルゴリズムを文書化することに加えて、一般的な計画にも改善がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはJava Juniorの学生を学び、彼は一連の地理ライブラリの調査を行った結果、最終的に適切なライブラリを選択してPostGIS環境から捨てることができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
精度が低いため、以前の試みは失敗しました。半径3 kmでは、Haversinsはすでに顕著なエラーを示しています。最初から取得しようとしたライブラリのほとんどは、グリッドに穴または二重の重なりが生じた結果として、サンクトペテルブルクの北の緯度でひどいものでした。そして私たちフィンランド人は頻繁に顧客であるため、すべてが緯度で正しく機能することが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のジオイド（できればPostGIS、WGS84と同じ）のライブラリが必要であることがわかるまで、結果は期待される結果と一致しませんでした。しかし、GeographicLibに切り替えた後、Postgre接続の形でのボトルネックは解消され、速度の計算の最終段階は40倍に加速されました。 Golovnyakは、ベースの下に別のRDSインスタンスの追加構成を残し、POIダンプでそれを埋め、S3の通常のデータセットに移動しました。統一！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、同じ生徒がカードを発見して修正し、カードが実際よりも薄く見える原因となったまさしくその間違いを修正しました。さて、時間制限のない課題があると、学生が羨ましいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の重要なポイント。かつて100度目に、Sparkモジュールを次々と呼び出すバインディングスクリプトを見ていたのですが、どのような悪魔とそれらを短絡させるのでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のモジュールの最後のRDDをチェーン内の次のモジュールの入力に単純にリダイレクトできる場合に、S3またはHDFSで毎回中間結果を保存する理由。 MetaRunnerの完成は、数時間後に書かれたものです。コモンズの存在は非常に役立ちました。特に、各モジュールのパラメーターがすでに同じtasks.iniにあり、キーのプレフィックスがその名前に対応しているため、モジュールはそれまでにかなり標準化されました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたの注意は、基本操作に書かれたマップのブロック図（正面に発行する前の最終ステップですが、最終バージョンではありません）で示されます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/al/ke/4h/alke4hk9txojjq8j8lwauoihvqs.png" alt="ヒートマップ準備プロセスのフローチャート" title="ヒートマップ準備プロセスのフローチャート"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HDFSへの24の中間呼び出しを取り除くと、特にこの計算は約50倍高速化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、プロパティストアのパラメーターを変更するたびにtasks.iniを再生成する必要がないように、プロセステンプレートに変数サポートを追加するとどうなるでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-アッシュナズグ！私は叫びました。同僚は困惑してお互いを見た。これらの日本人のために男は屋根を持っていますが、まあ、それは起こります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「Ash nazg ... burzum-ishi krimpatul」私はうなり声を上げ（うまくいかなかった）、PMに行き、15個すべて（ヒューリスティックスと補助ユーティリティの数は徐々に増えていった）の計算モジュールを1つのリポジトリに統合することについて話し合いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでにモジュールを互いに短絡している場合は、スパークのクラスパス内のすべての個々のJARのライニングに手を煩わせず、特許を取得したLocomizerロジック（および私たちの補助操作）のパッケージ全体を1つの太いJARに組み立てます。同時に、ローカルで、クラスターなしで実行できるようになります。そして重要なのは、tasks.iniを解析するためのロジックをPowerShellバインディングからJavaコードに転送できることです。この場合、変数の置換がはるかに簡単になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトを「全能の指輪」と呼ぶ提案について近づいている同僚-一つの指輪ですが、少し健康な悲しみが害を及ぼすことは決してありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TKの無限の調整の次のラウンドの瞬間を前面にとらえたので、私はすべてのモジュールをヒープに集めました。 Mavenはマルチモジュールプロジェクトの依存関係を解決する高度なツールであるため、重複するコードの最後の部分を一掃し、すべてのライブラリのバージョンを統合し、ローカルおよびクラウド環境用のビルドオプションを作成することがわかりました。さらに、各モジュールは独自のサブプロジェクトに残り、その作成者は、他のモジュールに干渉することなく、非常に独立して作業できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、私は、抽象レベルを事前に設計して特定のタスクで実装するよりも、抽象化の結晶化と既存の同種のエンティティのセットからある種のアーキテクチャを構築するアプローチを検討しています。確立されたプラクティスと使用パターンがなければ、アーキテクチャを設計することは無意味です。すべてのケースを事前に予見することはできず、システムのユーザーの動作のオプションは、設計者のアイデアと根本的に異なる場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータを処理する統一されたロジックを使用して、モジュール構成の明確な統一オブジェクトモデルを作成し、同じプロセス内でモジュールの構成の相互の有効性と整合性を通常どおりチェックすることができました。これは、CSV形式のデータセットで特に重要です。各RDDレコードのフィールドの数と順序の制御、および1つのモジュールの出力から後続のいくつかの入力へのデータセット自体の転送の正確さは、完全に呼び出し側にあります。そして、コントロールポイントが1つあれば、それはすでにうまくいくことができます。</font></font><br>
<blockquote>         RDD,   ?    ,     Spark SQL.   ,   Spark —  ,   ,    white paper,    Python,           .       ,     .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...開発者の手が肩から伸び、頭が明るい場合。理論的には。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの条件では、元のCSVの行をコンパクトなHadoupネイティブテキスト（内部では単なるバイトの配列です）の形式で駆動し、現在の操作で認識されている列のみを記述する方がはるかに簡単であることがわかります。また、実験の結果によると、データフレームは、各操作の入力でCSVを解析し、出力でテキストに圧縮する必要よりも、メモリ消費のオーバーヘッドが大きくなります。さて、それでも-ストレージの新しいデータセットはそれらと混合する可能性があるため（これは図にはっきりと表示されています）、各ステップの後で中間RDDを手動でパーティション分割する機能を維持することが重要です。そのため、どのようにレベルを維持したいかに関係なく、1レベル下に移動する必要があります。論理白書。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、Javaの「低レベル」コードには、プラスもあります。たとえば、メタデータで操作パラメーター（および予期されるRDDと生成されるRDD）を記述する場合、ドキュメントとその構成例の両方を自動的に生成でき、手動で作成する必要がなくなります。そして、各ビルドの後、ドックは常に適切です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各モジュールの異種のパラメーターセットからのtasks.ini構成ファイル自体は、一種の宣言型プログラミング言語のプログラムにすぐに変換されます。あまり美しくありませんが、内部的には論理的で、人間が読める形式です。独自の構文で実際のDSLに仕上げることは問題ありませんが、私はそれを不必要に実行しませんでした。しかし、少し後に、ビジュアルエディターを使用して、将来に向けてJSONにビューを追加しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短絡したプロセスは、平均して、個々のSparkジョブの呼び出しのチェーンよりもさらに3〜5倍速く受信しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
100回ではありません。同じSparkジョブのフレームワーク内で、計算の複雑さとデータの飽和が異なるタスクのステップが混在する可能性があるためです。その結果、マルチステッププロセスの各部分のクラスターパラメーターを細かく調整しても、実用的な意味がなくなりました。しかし、徐々に、このオプションでは、初期データセットのサイズと処理プロセステンプレートの合計ステップ数に基づいて、クラスターサイズのプリセットを選択できるようにするいくつかの一般的なパターンが見つかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階を要約すると、日本人との作業が終了するまでに、かなり開発されたツールボックスがすでにありました。</font></font><br>
<br>
<ul>
<li>         ,           ,</li>
<li>,    ,             DSL  ,</li>
<li>  ,    —   ,</li>
<li>     AWS,           .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかしうまくいかなかったのは前線でした。</font><font style="vertical-align: inherit;">古いLocomizer Web UIは絶望的に時代遅れであり、新しい日本語を完全に放棄する前に正常な状態に仕上げることができませんでした。</font><font style="vertical-align: inherit;">そして、このUI自体のバックエンドコードは、暗い10月の夜に左後ろ足で書かれましたが、ボリュームが大きいために、完全にコームできませんでした。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uber H3による最適化とジオカタルシス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
吐き出した後、私たちは民間のプロジェクトに戻りました。日本人の後の気分は、正直言って、チーム全体がまあまあだった。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私はようやく、Bogomersssky、holm、holm、springを使用して、フロントでバックアップを維持する必要性を取り除きました。 （これは私の個人的な意見です。EE、自動性と暗黙のデフォルトが少ないので、少し嫌いではありません。そのため、RESTを作成するために何がひどい企業であるかは問題ではありません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中毒で各モジュールの内部を見る時間がありました。</font></font><br>
<blockquote>    —        ,       .            ,    ,    ,       .   -      .       —            .       ,         —    .</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前は同僚のコードを注意深く見ていなかっただろう。誰もが彼に与えられたタスクに従事しているだけであり、それが望ましい結果で彼によって実行されている間、開発者が彼の仕事をしていることに干渉しないでください。アルゴリズムが正しく動作し、これがテストで確認された場合、すべて問題ありません。作業の速度に応じて、それは許容可能か、それ以外の場合は、決定はPMによって行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいタスクを実装するときに開発者が下した決定をさらにサポートする高いリスクを認識するまで、私は介入しません。そして、長い間プロジェクトを去っていたが、ビジネスに必要な誰かによってツァーロ・ゴロフの下で書かれた古くて醜いモジュールは、それがどれほど臭いがあったとしても、そのまま実用可能なレベルで維持されます。皮肉に聞こえますが、私は実用主義者であり、理想主義者ではありません。作業の結果は、コードの美しさよりも重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、時々、彼がプロジェクトを自分の重みで埋めないようにするために、技術的負債を廃棄する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sparkは非常に高レベルのライブラリです。これにより、同じ結果が得られるさまざまな同義の方法でRDDの操作を実行できます。各メソッドには、わずかに異なるオプションがいくつかあります。それぞれの説明を注意深く読み、疑わしい場合はソースを調べて、どちらが最適であるかを理解する必要があります。結果は同じですが、計算速度の違いは数倍になる可能性があり、あるヒューリスティックのロジックがSparkで100行のコードを展開する場合、データを変換するための最も適切な方法を使用するように特に注意する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高水準言語-それらはあなたに抽象的な思考をさせるようなものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、同時に、開発者は抽象化にどれほどの高さがあるとしても、低レベルに注意する必要があります。たとえば、.map（）メソッドに渡されたラムダは、内部で太字のオブジェクトにメモリが割り当てられており、各レコードに対して再度呼び出され、同じオブジェクトを再割り当てします。既存のJVMは、太字の繰り返し割り当てを好みません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードのサポートについて考える場合、内部ロジックによって接続されているアルゴリズムの一部を用意するのは良いことですが、同時に一部のパラメーター値で完全に分離し、特にこれらの部分がアルゴリズムの最初または最後にある場合は、コードの残りの部分から分離します。一般に、それらは別の操作で完全に取り出すことができます。同時に、すべてのケースを完全にカバーするテストは短くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は最適化に対処するには時期尚早でしたが、今がその時期になりました。数か月間、同僚によって2年間にわたってプロファイリングコードが記述されたプロファイリングコードのある計算モジュールの内部に魅了されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私がそこでダイビングしたとき、One Ringには29の操作がありました（一部のモジュールには複数の操作が含まれています）。それが現れたとき-43、そしてそれぞれが数パーセントから数十倍、オリジナルよりも速い。しかし、より貴重なことに、以前は10,000要素のパーティションのデータで窒息していた操作が、今では100万レコードの断片を簡単に噛み砕きました。一部の場所では、コードの柔軟性と可読性を犠牲にする必要があり、一部の場所では.map（）を.mapPartition（）に単純に置き換える必要がありましたが、コードがクラッシュしなくなりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボトルネックは1つだけでした-任意の地域でのジオフェンシング。それはまだ外部メッシュを持つ奇妙なハイブリッドソリューションでした。 Japan Meshを日本で使用することは可能でしたが、それ以外の地域では、動的グリッドの適切なバリアントを探す必要がありました。これは、ポイントの座標のみに依存し、使いやすいものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなオプションが見つかりました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-Uber H3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が理解しているように、六角形のツリーはH3という名前で暗号化されています。これは優れた機能を持つ地理グリッドです。座標範囲全体で安定しており、途方もなく高速です（ネイティブコードが呼び出されます）。ランド全体にギャップのない均一なサイズのセルが得られ、ポリゴン、ポイント、パスをカバーするためのさまざまなオプションを作成できます。また、六角形グリッドのセルには最小数の隣接セルがあり、次のレベルは、下にあるセルの中心の真上にある前のセルの7つのセルをカバーします。これは、集約マップを構築するときに便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H3への移行とともに、パズルは完全に発展したようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.5年前の最初の状態と比較すると、データセットの1つの不幸なヒートマップに費やされた週から数百万の信号までを比較すると、データセットを備えた数十枚のカードに費やされた数分に到達しました。データアナリストはもうあまり注意を払っていません（S3への結果の書き込みに計算自体よりも時間がかかる場合、クラスターサイズに対してプリセットを高く設定しすぎると、つぶやく必要があります）。そして、彼はもはやTC自身を見るのではなく、自宅のどこかにパラメーターマトリックスを詰まらせ、Pythonを使用して必要な数の必要なビルドをプルするだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいオペレーションを追加します。必要なのは、オペレーションクラスを正しく実装し（必要に応じてScalaを使用することもできます）、メタデータで包み、構成に含めれば、One Ringは新しいヒューリスティックを呼び出しているのか、チェーンで正しく処理しているのかを判断します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、それはすべてローカルでもAWSでも機能します。</font><font style="vertical-align: inherit;">S3をサポートしていれば、他のクラウドにも存在し、Sparkは</font></font><abbr title="Spark用RESTランチャー"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Livy</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を介してプルすることができます</font><font style="vertical-align: inherit;">-そして、他のすべての外部依存関係を取り除きました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真っ白に</font></font></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-ガンダルフ？！</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
しかし、まだ柔軟なプロセスを開始する前線はありません。そして、そのようなプロセスのテンプレート自体は、昔ながらの方法-VSCodeで手動で作成する必要がありますが、Visioのようなエディターでマウスになりたかったのです。このようなもの：</font><font style="vertical-align: inherit;">
私はOne Ringの一部として小さなRESTサービスを作成しました。これには、そのようなエディターを作成するために必要なすべてが含まれていますが、私が最後にフロントで作業したのは約10年前のことであり、現在の傾向のコースではありません。私がそれをリベットするのはJSFのためではありません、それはレトロでさえありませんが、すでにある種のネクロです。それを何か新しいものの静的なSPAにするといいでしょう。私だけが何なのか分かりません。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ワンリングの</font></a><font style="vertical-align: inherit;">コードを明らかにすることへの</font><font style="vertical-align: inherit;">
私の</font><s><font style="vertical-align: inherit;">利己</font></s><font style="vertical-align: inherit;">的</font><s><font style="vertical-align: inherit;">な</font></s><font style="vertical-align: inherit;">個人</font><s><font style="vertical-align: inherit;">的</font></s><font style="vertical-align: inherit;">な関心</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/g2/su/hr/g2suhrumf4-lmrwasnribe2zokc.png" alt="プロセスを編集するためのモーションキャプチャインターフェース" title="プロセスを編集するためのモーションキャプチャインターフェース"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><s><font style="vertical-align: inherit;"></font></s><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（コンテンツでリポジトリを完成させますが、今それを見ることができます）、私はそれが明確であることを願っています。</font><font style="vertical-align: inherit;">そして、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このタスク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に取り組むのに十分な勇敢な人がいるなら</font><font style="vertical-align: inherit;">、私は仕様で正気な技術的なタスクを書きます。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、一般に、データエンジニアチームは、完成したツールをクローゼットに保管したくありません。</font><font style="vertical-align: inherit;">私たちは確信しています：それは私たちだけでなく役立つでしょう。</font><font style="vertical-align: inherit;">また、GISのニーズだけでなく、一般に、パラメータ化可能な処理ステップによるデータセットのバースト処理。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後の記事（またはいくつかの記事、繰り返しになりますが、時間がかかりすぎる）では、研究タスクにOne Ringを構築、実行、拡張、および使用する方法を説明します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* One Ring OSSソースコードには、独自仕様のLocomizerヒューリスティックアルゴリズムは含まれていません。</font><font style="vertical-align: inherit;">しかし、そのリポジトリには、これらのヒューリスティックの無料実装をクリーンルームメソッドを使用して、つまり、コードに関する私の側からのプロンプトなしで再作成できるインターフェースと説明が含まれます。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">謝辞</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font><font style="vertical-align: inherit;">主題に関する実質的なコメントを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">求め</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て同僚のグレゴリー・</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ポマチン</font></a><font style="vertical-align: inherit;">に、そして</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シコフ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> テキストの読みやすさ、およびアントンの独立した評価のため </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダルトフ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> シリーズの前の記事に対する予期しないフィードバックに対するZadorozhny。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja485974/index.html">Raspberry PiおよびSIM7600E 4G HATモデム</a></li>
<li><a href="../ja485976/index.html">隆起モデリングチュートリアル。パート2</a></li>
<li><a href="../ja485980/index.html">隆起モデリングチュートリアル。パート1</a></li>
<li><a href="../ja485982/index.html">デザインレッスン。主題領域とその数学モデル</a></li>
<li><a href="../ja485984/index.html">Warcraft IIIが新しいジャンルを生み出し、フランチャイズの顔を変え、リマスターを受け取った方法</a></li>
<li><a href="../ja485990/index.html">自動化は殺すのか？</a></li>
<li><a href="../ja485994/index.html">ImportExportDataSql-無料のMSSQLデータコンバーター</a></li>
<li><a href="../ja485996/index.html">アプリのElastic APM</a></li>
<li><a href="../ja485998/index.html">LyX：総論。パート2</a></li>
<li><a href="../ja486000/index.html">ADSM3。IPAM / DCIMシステム</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>