<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👁‍🗨 🍢 📟 Vueプロジェクトの負担を軽減するための10行のコード 🧜🏻 🕴🏿 🚍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="...または統合されたイベントバスの例としてのVue JSプラグインの知識
 について少し...
 みなさん、こんにちは！すぐに予約します。私は本当にVueJSが大好きで、2年以上積極的に執筆しており、それを開発することで少なくともある程度は害になるとは思いません:)
 一方、私たちは常に機械作業に...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Vueプロジェクトの負担を軽減するための10行のコード</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odin_ingram_micro/blog/488422/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...または統合されたイベントバスの例としてのVue JSプラグインの知識</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について少し...</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
みなさん、こんにちは！</font><font style="vertical-align: inherit;">すぐに予約します。</font><font style="vertical-align: inherit;">私は本当にVueJSが大好きで、2年以上積極的に執筆しており、それを開発することで少なくともある程度は害になるとは思いません:)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、私たちは常に機械作業に費やす時間を減らし、本当に興味深いものにより多くを費やすのに役立つ普遍的な解決策を見つけようと常に努力しています。時には、解決策は特に成功します。これらの1つを皆さんと共有したいと思います。説明する10行（ネタバレ：最後にもう少しあります）は、400以上のコンポーネントを持つかなり大きなアプリケーションであるCloud Blue-Connectプロジェクトでの作業の過程で生まれました。私たちが見つけたソリューションはすでにシステムのさまざまなポイントに統合されており、半年以上にわたって修正を必要とすることはなかったため、安定性のテストに成功したと考えることができます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後。</font><font style="vertical-align: inherit;">ソリューションに直接進む前に、Vueコンポーネント間の3種類の相互作用について説明します。単方向フローの原則、ストアのパターン、およびイベントバスです。</font><font style="vertical-align: inherit;">この説明が不要な（または退屈な）場合は、ソリューションのセクションに直接進んでください。すべてが可能な限り簡潔で技術的なものです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vueコンポーネントが相互に通信する方法について少し</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、最初のコンポーネントを作成した人が提起する最初の質問は、仕事用のデータをどのように受信し、受信したデータを「送信」するかということです。</font><font style="vertical-align: inherit;">Vue JSフレームワークで採用されている相互作用の原則は...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単方向データストリーム</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、この原則は「プロパティ-ダウン、イベント-アップ」のように聞こえます。つまり、外部から（「上から」）データを受信するために、フレームワークが必要に応じて「外部」から取得したデータを書き込むコンポーネント内に特別なプロパティを登録します。データを「上」に転送するために、コンポーネント内の適切な場所で、特別な$エミットフレームワークメソッドを呼び出します。このメソッドは、データを親コンポーネントのハンドラーに渡します。同時に、Vue JSでは、無制限の深さまでイベントを「ブロードキャスト」することはできません（Angular 1.xなど）。それは、直接の親に対して、1つのレベルだけを「ポップアップ」します。イベントについても同様です。それらを次のレベルに転送するには、それぞれについて、特別なインターフェイス（「メッセージ」をさらに送信するプロパティとイベント）を登録する必要もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、労働者が自分のフロアから隣のフロアに（上下に）移動することしかできないオフィスビルと言えます。したがって、「署名用の文書」を5階から2階に転送するには、5階から2階にそれを届ける3人の労働者のチェーンが必要であり、さらに5階にそれを届ける3人の労働者が必要になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「しかし、これは不便です！」もちろん、これは開発の観点からは必ずしも便利ではありませんが、各コンポーネントのコードを見ると、何が誰に渡されるかがわかります。コンポーネントがイベントに「進んでいる」かどうかを理解するために、アプリケーションの全体的な構造を覚えておく必要はありません。これは、親コンポーネントから確認できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの利点は理解できますが、コンポーネントの凝集力が高いという明らかな欠点もあります。</font><font style="vertical-align: inherit;">簡単に言うと、構造にコンポーネントを配置するために、その状態を管理するために必要なインターフェースでコンポーネントをオーバーレイする必要があります。</font><font style="vertical-align: inherit;">この接続を減らすために、彼らはしばしば「状態管理ツール」を使用します。</font><font style="vertical-align: inherit;">おそらく、Vueで最も人気のあるツールは...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vuex（側面）</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vuex Storは、オフィスビルディングとの類似性を継続して、内部の郵便サービスです。オフィスの各フロアに小包を出し入れするための窓があると想像してください。 5階では署名用に文書11を送信し、2階では定期的に「署名用の文書はありますか？」と尋ね、既存の文書に署名して返却します。 5番目の質問では、「署名者はいますか？」同時に、従業員は他のフロアや他の部屋に移動することができます-メールの作業中に作業の原則は変わりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この原則により、Storeと呼ばれるパターンも機能します。 Vuexインターフェースを使用して、グローバルデータウェアハウスが登録および構成され、コンポーネントがサブスクライブします。また、アピールが発生した構造のどのレベルでも問題はありません。ストアは常に適切な情報を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これですべての問題はすでに解決されているようです。しかし、私たちの比喩的な建物のある時点で、1人の従業員が昼食のために別の従業員に電話したい...または何らかの間違いを報告したいと考えています。そして、ここで奇妙なことが始まります。メッセージ自体は、そのまま送信する必要はありません。ただし、メールを使用するには、何かを転送する必要があります。次に、従業員がコードを作成します。 1つの緑色のボール-昼食に行く、2つの赤い立方体-アプリケーションエラーE-981273が発生した、3つの黄色いコイン-メールを確認するなど。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この厄介なメタファーの助けを借りて、別のコンポーネントで発生したイベントへのコンポーネントの応答を保証する必要がある状況を説明しますが、それ自体はデータストリームとは一切接続されていません。</font><font style="vertical-align: inherit;">新しいアイテムの保存が完了しました-コレクションを再取得する必要があります。</font><font style="vertical-align: inherit;">403未承認エラーが発生しました-ユーザーのログアウトなどを開始する必要があります。</font><font style="vertical-align: inherit;">この場合の通常の（そしてベストからはほど遠い）プラクティスは、ストア内にフラグを作成するか、ストアされたデータとその変更を間接的に解釈することです。</font><font style="vertical-align: inherit;">これはすぐに、ストア自体とその周りのコンポーネントのロジックの両方の汚染につながります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、コンポーネントのチェーン全体をバイパスして、イベントを直接渡す方法について考え始めます。</font><font style="vertical-align: inherit;">そして、ドキュメントで少しグーグルまたはくるくると、パターンに出くわします...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントバス</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
技術的な観点から見ると、イベントバスは1つの特別なメソッドを使用して「イベント」を起動し、別のメソッドを使用してサブスクライブすることを可能にするオブジェクトです。つまり、eventAイベントにサインアップすると、このオブジェクトは渡されたハンドラー関数をその構造内に格納します。この関数は、アプリケーションのどこかでeventAキーを持つ起動メソッドが呼び出されたときに呼び出されます。署名または実行するだけで、インポートまたは参照によってアクセスできます。これで完了です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比喩的に言えば、私たちの「建物」では、バスはメッセンジャーの一般的なチャットです。コンポーネントは、他のコンポーネントがメッセージを送信する「一般的なチャット」にサブスクライブします。コンポーネントがサブスクライブしている「チャット」に「メッセージ」が表示されるとすぐに、ハンドラーが起動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントバスを作成するには、さまざまな方法があります。</font><font style="vertical-align: inherit;">自分で作成することも、既成のソリューションを使用することもできます。同じRxJSは、イベントのストリーム全体を操作するための巨大な機能を提供します。</font><font style="vertical-align: inherit;">しかし、ほとんどの場合、VueJSを操作するとき、奇妙なことに、VueJS自体を使用します。</font><font style="vertical-align: inherit;">コンストラクターによって作成されたVueインスタンス（新しいVue（））は、公式ドキュメントに記載されている、美しく簡潔なイベントインターフェイスを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで次の質問に近づきます...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私達何が欲しいの？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、アプリケーションでイベントバスを構築したいと考えています。</font><font style="vertical-align: inherit;">ただし、さらに2つの要件があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのコンポーネントで簡単にアクセスできる必要があります。</font><font style="vertical-align: inherit;">数十のコンポーネントのそれぞれへの個別のインポートは、私たちにとって冗長であるように見えます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュール式である必要があります。</font><font style="vertical-align: inherit;">「item-created」イベントがアプリケーション全体からハンドラーを起動する状況を回避するために、すべてのイベント名を覚えておく必要はありません。</font><font style="vertical-align: inherit;">したがって、コンポーネントツリーの小さなフラグメントを別のモジュールに簡単に分離し、そのイベントをモジュールの内部ではなく外部にブロードキャストできるようにしたいと考えています。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような印象的な機能を実装するために、VueJSが提供する強力なプラグインインターフェイスを使用します。</font><font style="vertical-align: inherit;">あなたは、より詳細にそれを理解することができ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公式ドキュメントのページに。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まずプラグインを登録しましょう。</font><font style="vertical-align: inherit;">これを行うには、Vueアプリケーションの初期化ポイントの直前（Vueを呼び出す前に$ Mount（））に次のブロックを配置します。</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { }, <font></font>
});<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、Vueプラグインは、アプリケーションレベル全体でフレームワークの機能を拡張する方法です。プラグインインターフェースはコンポーネントに統合するいくつかの方法を提供しますが、今日はミックスインインターフェースを紹介します。このメソッドは、アプリケーションでライフサイクルを開始する前に、各コンポーネントの記述子を拡張するオブジェクトを受け入れます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ここで記述するコンポーネントコードは、コンポーネント自体ではなく、その動作と、フレームワークがライフサイクルのさまざまな段階で使用するロジックの特定の部分のカプセル化の記述です。プラグインの初期化は、コンポーネントのライフサイクルの外側にあり、その前にあるので、コンポーネントではなく「ディスクリプタ」と言い、ファイルに記述されているコードであり、フレームワークの成果物であるエンティティではないコード）がプラグインのミックスインセクションに転送されることを強調します）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({<font></font>
  install(vue) {     <font></font>
    vue.mixin({}); <span class="hljs-comment">// &lt;--</span><font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントの拡張を含むのはこの空のオブジェクトです。しかし、まず第一に、別のストップ。この場合、各コンポーネントのレベルでバスにアクセスするためのインターフェースを作成します。 「$ broadcast」フィールドを記述子に追加してみましょう。バスへのリンクが格納されます。これを行うには、Vue.prototypeを使用します。</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <span class="hljs-comment">// &lt;--</span><font></font>
    vue.mixin({}); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでバス自体を作成する必要がありますが、まずモジュール性の要件を思い出して、コンポーネント記述子で「$ module」フィールドにテキスト値を含む新しいモジュールを宣言するとします（後で少し必要になります）。</font><font style="vertical-align: inherit;">$モジュールフィールドがコンポーネント自体で指定されている場合は、そのバスを作成します。指定されていない場合は、$親フィールドを介して親にリンクを渡します。</font><font style="vertical-align: inherit;">記述子フィールドは、$オプションフィールドから使用できることに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バスの作成は、可能な限り早い段階（beforeCreateフック）に配置します。</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({<font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <font></font>
    vue.mixin({<font></font>
      beforeCreate() {  <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {  <span class="hljs-comment">// &lt;--</span><font></font>
         <font></font>
 	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) {  <span class="hljs-comment">// &lt;--</span><font></font>
         <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、論理的なブランチを埋めましょう。</font><font style="vertical-align: inherit;">記述子に新しいモジュールの宣言が含まれている場合は、新しいバスインスタンスを作成します。含まれていない場合は、$親からリンクを取得します。</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue();  <span class="hljs-comment">// &lt;--</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast;  <span class="hljs-comment">// &lt;--</span><font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラグインのアナウンスメントを破棄します。私が約束したように、... 1、2、3、4 ... 10行を検討します！ </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もっと上手くできる？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、我々はできます。</font><font style="vertical-align: inherit;">このコードは簡単に拡張できます。</font><font style="vertical-align: inherit;">たとえば、この例では、$ブロードキャストに加えて、$ rootBroadcastインターフェースを追加することにしました。これにより、アプリケーション全体で単一のバスにアクセスできます。</font><font style="vertical-align: inherit;">ユーザーが$ブロードキャストバスで実行するイベントは$ rootBroadcastバスで複製されるため、特定のモジュールのすべてのイベント（この場合、イベント名は最初の引数としてハンドラーに渡されます）またはすべてのアプリケーションイベント（通常はモジュール名は最初の引数でハンドラーに渡され、イベント名は2番目の引数で渡され、イベントで送信されるデータは次の引数で渡されます）。</font><font style="vertical-align: inherit;">この設計により、モジュール間の相互作用を確立し、異なるモジュールのイベントで単一のハンドラーをハングさせることができます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// This one emits event  </span>
<span class="hljs-keyword">this</span>.$broadcast.$emit(‘my-event’, ‘PARAM_A’); 
<span class="hljs-comment">// This is standard subscription inside module </span>
<span class="hljs-keyword">this</span>.$broadcast.$on(‘my-event’, (paramA) =&gt; {…}); 
<span class="hljs-comment">// This subscription will work for the same event </span>
<span class="hljs-keyword">this</span>.$rootBroadcast.$on(‘my-event’, (<span class="hljs-built_in">module</span>, paramA) =&gt; {…}); 
<span class="hljs-comment">// This subscription will also work for the same event </span>
<span class="hljs-keyword">this</span>.$rootBroadcast.$on(‘*’, (event, <span class="hljs-built_in">module</span>, paramA) =&gt; {…});
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを実現する方法を見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、$ rootBroadcastを介してアクセスされる単一のバスを作成し、フィールド自体にリンクを設定します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue(); <span class="hljs-comment">// &lt;--</span><font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus; <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue(); <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast; <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、各コンポーネントのモジュールメンバーシップが必要なので、次のようにモジュール性の定義を拡張します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue(); <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast; <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、モジュール式のローカルバス上のイベントをルートに反映する必要があります。</font><font style="vertical-align: inherit;">これを行うには、最初に単純なプロキシインターフェイスを作成し、バス自体を$ busの条件付きプライベートプロパティに配置する必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <span class="hljs-comment">// &lt;--</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };  <span class="hljs-comment">// &lt;--</span><font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、オブジェクトにプロキシメソッドを追加します。$ブロードキャストフィールドはバスへの直接アクセスを提供しないためです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };<font></font>
        } <font></font>
        <span class="hljs-comment">// &gt;&gt;&gt;</span>
        <span class="hljs-keyword">this</span>.$broadcast.$emit = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$emit(…attrs);           
          <span class="hljs-keyword">const</span> [event, …attributes] = attrs; 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)); 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(‘*’, event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)<font></font>
        };<font></font>
        <font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$on = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {           
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$on(…attrs);<font></font>
        };<font></font>
        <span class="hljs-comment">// &lt;&lt;&lt;</span><font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、最後の仕上げとして、閉じることでバスにアクセスできることを思い出しましょう。つまり、一度追加されたハンドラーはコンポーネントでクリアされず、アプリケーションで作業している間ずっと有効です。これは不快な副作用を引き起こす可能性があるため、コンポーネントのライフサイクルの最後にリスナーのクリーンアップ関数をバスに追加しましょう。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeDestroy() {                               <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">this</span>.$broadcast.$off(<span class="hljs-keyword">this</span>.$broadcastEvents);  <span class="hljs-comment">// &lt;--</span><font></font>
      },<font></font>
<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">this</span>.$broadcastEvents = [];  <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };<font></font>
        } <font></font>
<font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$emit = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {
          <span class="hljs-keyword">this</span>.$broadcastEvents.push(attrs[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$emit(…attrs);           
          <span class="hljs-keyword">const</span> [event, …attributes] = attrs; 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)); 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(‘*’, event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)<font></font>
        };<font></font>
        <font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$on = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {           
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$on(…attrs);<font></font>
        };<font></font>
<font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$off =: <span class="hljs-function">(<span class="hljs-params">...attrs</span>) =&gt;</span> {  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$off(...attrs);   <span class="hljs-comment">// &lt;--</span><font></font>
        };<font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、このオプションは簡潔ではありませんが、より興味深い機能を提供します。</font><font style="vertical-align: inherit;">これにより、コンポーネント間の代替通信の完全なシステムを実装できます。</font><font style="vertical-align: inherit;">さらに、彼は完全に私たちの管理下にあり、外部の依存関係をプロジェクトに持ち込みません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vueプラグインの知識を習得または更新した後、そして次にアプリケーションにいくつかの汎用機能を追加する必要があるときに、外部依存関係を追加することなく、より効率的に実装できることを願っています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja488408/index.html">STM32 Ethernet-RS485 IoTゲートウェイ</a></li>
<li><a href="../ja488410/index.html">開発の10年で学んだ7つの教訓</a></li>
<li><a href="../ja488412/index.html">discord.jsに基づくDiscordボットの作成</a></li>
<li><a href="../ja488416/index.html">SLAE-Security Linux Assembly Expert Exam</a></li>
<li><a href="../ja488418/index.html">Spring SecurityとMongoDBを使用したREST API認証</a></li>
<li><a href="../ja488424/index.html">2020年にITSMはどうなりますか？</a></li>
<li><a href="../ja488426/index.html">コードレビューを行う方法は？パート2：ナビゲーション、速度、コメント、競合を確認する</a></li>
<li><a href="../ja488428/index.html">Yandex検索の将来をどのように予測するか：バグ修正から発見クエリまで</a></li>
<li><a href="../ja488432/index.html">Snoop Projectは、RuNetユーザーが長い間待ち望んでいた、インターネットインテリジェンスのための素晴らしいツールです。</a></li>
<li><a href="../ja488436/index.html">オープンソースのチップチューン音楽をすばやく作成</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>