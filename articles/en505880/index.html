<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼 🌤️ 😉 How to write your index in Tarantool 🧑🏻‍🤝‍🧑🏻 👏 👨‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tarantool is an application server and database. The server part is written in C, and the user is provided with a Lua-interface for working with it. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>How to write your index in Tarantool</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/505880/"><img src="https://habrastorage.org/webt/_w/oc/me/_wocmecfrb1lnc7gdoodtf3j3y4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantool is an application server and database. </font><font style="vertical-align: inherit;">The server part is written in C, and the user is provided with a Lua-interface for working with it. </font><font style="vertical-align: inherit;">In addition, Tarantool is an opensource product, which means that the source code is in the public domain, and you can freely develop and distribute software based on Tarantool. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But today the story will be a little different: about the experiment, about trying to write your own data structure for the search (Z-order curve) and integrate it into the existing Tarantool ecosystem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I am a developer in the Tarantool Solution Team, I am not directly involved in the development of Tarantool, but am an active user. </font><font style="vertical-align: inherit;">Therefore, for me this experiment is an attempt to understand how Tarantool works at a low level.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is Tarantool and where does it store data?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is Tarantool? In the world of databases, it is positioned as an in-memory technology. The memtx engine allows you to store all your data in RAM, while meeting all the principles of ACID. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The analog of relational tables in Tarantool are space, which are designed to store tuples (tuples). Unlike relational tables, tuples in a space can generally be of arbitrary length. To store them, a search data structure must be created, and the search key is the primary key, always unique.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can also build additional structures - secondary indexes that store only a pointer to a tuple. </font><font style="vertical-align: inherit;">The secondary index may not be unique, however, this is only the external behavior visible to the user. </font><font style="vertical-align: inherit;">Primary index fields are implicitly added to any non-unique index. </font><font style="vertical-align: inherit;">This ensures the stability of sorting tuples within the index. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantool supports different types of indexes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-Tree</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (and if absolutely precisely, then B + * - Tree). </font><font style="vertical-align: inherit;">A lot of [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-Tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] has been </font><font style="vertical-align: inherit;">written about the structure of B-trees </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">I only note that the data is stored in sorted form, in addition, you can search by the prefix of the indexed key.</font></font></li>
<li>   <strong>hash-</strong>. ,      .    .    B-,      ,  .    .</li>
<li><strong>R-Tree</strong>.      .    «» , ,  .       — .     ,       .        .   ,      ,    .</li>
<li><strong>Bitset</strong>. ,     .   ,            ,   .</li>
</ul><br>
<h3> Z-,   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Where did the idea to write your index come from, and quite exotic? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Once I came across Amazon articles [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1, 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ], which talked about such a structure as the Z-order curve, or the Morton curve. This is a recipe for the location of "multidimensional" data inside a flat structure (Z-order curve), which then fits into a B-tree. Such an approach should help to avoid continuous data scanning. In general, information about any object with a certain set of characteristics can be considered multidimensional data. For example, height, weight, foot size, etc. person. Most databases use R-Tree for this purpose. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A little about how the Z-order curve is structured.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/363/a10/2c9/363a102c99adb088e19052945e6298fb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A Z-order curve, also known as a Morton curve, is obtained by interleaving bits of the coordinates of a point in space. </font><font style="vertical-align: inherit;">Thus obtained Z-addresses have the property of locality. </font><font style="vertical-align: inherit;">Points located nearby in multidimensional space will still be located nearby when displayed on a flat line. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schematically similar mixing looks like this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/04c/f2b/6eb04cf2b6ac3f0b26613a774c8f479d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How it works? </font><font style="vertical-align: inherit;">We limit a certain region in space — a hypercube (there will be a rectangle in two-dimensional space) —with the help of two points lying on the diagonal, which are displayed at two points on the line. </font><font style="vertical-align: inherit;">And we get an unpleasant side effect: some of the points go beyond the bounding box:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/991/fd9/889/991fd9889fa6f3b4b30fd7adecfcd436.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, we cannot just iterate along this curve. But, armed with a special algorithm, we can make a jump when going abroad, returning back to the search area. As soon as we go beyond the extreme point of the curve (let's call it upper_bound), the search is over. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When working with the B-Tree, we would have a set of intervals, and this request would lead to a sequential scan of the B-tree, which would take a lot of time with a large data set. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My interest was fueled by other publications about this curve. For example, how it was integrated into TransBase [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ], a proprietary database. And, unfortunately to my own, I did not find any open source implementations of this structure.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The underlying B-Tree curve has several advantages over the R-Tree. </font><font style="vertical-align: inherit;">For example, better occupancy and compactness. </font><font style="vertical-align: inherit;">Disadvantages: most of the algorithms used are processor limited. </font><font style="vertical-align: inherit;">For comparison, I decided to use Tarantool: I was interested in reading / inserting speeds, as well as memory consumption. </font><font style="vertical-align: inherit;">It is impossible not to mention that a similar topic has already been raised on Habré, but for small dimensions (2-3) and in relation to the PostgreSQL disk database [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZcurvePostgres</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ].</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What was required to embed in Tarantool?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I found simple implementations of this structure for a dimension of 2-3, but I wanted to compare performance with the existing R-Tree index, so I did not want to limit myself to small dimensions. I chose the same dimension as R-Tree - 20. For this, I needed a bitmap with support for some primitive operations: extracting / modifying a bit, shifting, OR / AND logical operations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the prototype, I took the found open source implementation, but pretty quickly came to the conclusion that I did not need a general-purpose bitmap: the key length is always a multiple of 64, so some operations are greatly simplified. I wrote my own implementation based on what I had. In addition, instead of using the system functions for allocating memory, I started using special allocators implemented in Tarantool [</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhaps the heart of the index is a set of algorithms for working with the Z-curve. </font><font style="vertical-align: inherit;">Namely, calculating the Z-address (using special lookup tables), checking that the Z-address belongs to the search area and detecting the first occurrence in the search area, starting from the specified point. </font><font style="vertical-align: inherit;">If you search the web well, then you can find scientific publications describing these algorithms, so all I had to do was implement them, debug them and, if possible, optimize them. </font><font style="vertical-align: inherit;">It was supposed to store Z-addresses inside the already implemented B-tree used for the TREE-index.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How is data handling organized?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the most general case, tuple comes to us. This is an array of data in message pack format. And in the ideal case, we would just have to isolate the indexed fields, mix their bits and insert the address with the pointer to the tuple inside the B-tree.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, everything would be so simple if we worked only with the unsigned type, when the sorted bit representations of numbers would correspond to sorted numbers in a natural representation. Signed integers have their own presentation rules, floating-point numbers have their own. And this had to lead to a common denominator. Due to the fact that we store the Z-address separately from the data itself, we can perform any transformations on our keys, the main thing is to maintain the sort order. This can be done using simple bitwise manipulations. For example, for signed integers, you can simply invert the high byte. For other types, there are similar, albeit slightly more complex, transformations.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All numeric types fit into 8 bytes, so the resulting key will be N * 8 bytes in size, where N is the dimension of our space. What to do with strings? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A fairly common situation when working with strings is prefix search. And it is quite possible to support. The first 8 bytes of the string may well be used as a key. If the string is shorter, then it can be padded with zeros. String support imposes a fundamental limitation on our index: we lose uniqueness. Even if the lines differ in the ninth byte, then from the point of view of the system they will still be the same. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at the code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The index API consists of a specific set of methods. We will not consider each individually, we will only go through the most basic ones, namely, search and insert operations.</font></font><br>
<br>
<code>get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- search for an item by the full key. Only works for unique indexes. Our index cannot be unique, therefore the function is replaced with a special generic version that returns the error “Unsupported index feature”. </font></font><br>
<br>
<code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- insert an item. Let's consider in more detail.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>
<span class="hljs-title">memtx_zcurve_index_replace</span><span class="hljs-params">(struct index *base, struct tuple *old_tuple,
        struct tuple *new_tuple, <span class="hljs-keyword">enum</span> dup_replace_mode mode,
        struct tuple **result)</span>
</span>{<font></font>
    (<span class="hljs-keyword">void</span>)mode;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_index</span> *<span class="hljs-title">index</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">memtx_zcurve_index</span> *)<span class="hljs-title">base</span>;</span>
    <span class="hljs-keyword">if</span> (new_tuple) {
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_data</span> <span class="hljs-title">new_data</span>;</span><font></font>
        new_data.tuple = new_tuple;<font></font>
        new_data.z_address = extract_zaddress(new_tuple,<font></font>
                &amp;index-&gt;bit_array_pool, index);<font></font>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_data</span> <span class="hljs-title">dup_data</span>;</span>
        dup_data.tuple = <span class="hljs-literal">NULL</span>;<font></font>
        dup_data.z_address = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
        <span class="hljs-keyword">int</span> tree_res = memtx_zcurve_insert(&amp;index-&gt;tree, new_data,<font></font>
                &amp;dup_data);<font></font>
        <span class="hljs-keyword">if</span> (tree_res) {<font></font>
            diag_set(OutOfMemory, MEMTX_EXTENT_SIZE,<font></font>
                     <span class="hljs-string">"memtx_zcurve_index"</span>, <span class="hljs-string">"replace"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (dup_data.tuple != <span class="hljs-literal">NULL</span>) {<font></font>
            *result = dup_data.tuple;<font></font>
            z_value_free(&amp;index-&gt;bit_array_pool, dup_data.z_address);<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (old_tuple) {
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_data</span> <span class="hljs-title">old_data</span>, <span class="hljs-title">deleted_value</span>;</span><font></font>
        old_data.tuple = old_tuple;<font></font>
        old_data.z_address = extract_zaddress(old_tuple,<font></font>
                &amp;index-&gt;bit_array_pool, index);<font></font>
        memtx_zcurve_delete_value(&amp;index-&gt;tree, old_data, &amp;deleted_value);<font></font>
        z_value_free(&amp;index-&gt;bit_array_pool, old_data.z_address);<font></font>
        z_value_free(&amp;index-&gt;bit_array_pool, deleted_value.z_address);<font></font>
    }<font></font>
    *result = old_tuple;<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What you should pay attention to? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In terms of the index, there were no transactions </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">All their logic is executed in this method, which receives the old and new tuples, as well as </font></font><code>mode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">information about whether the index is unique or not. </font><font style="vertical-align: inherit;">Our index cannot be unique, therefore no additional checks are required and you can immediately insert a tuple. </font></font><br>
<br>
<code>memtx_zcurve_insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>memtx_zcurve_delete_value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- B-tree methods, which have already been implemented in Tarantool and are used in the regular TREE index. </font><font style="vertical-align: inherit;">We will not dwell on them separately. </font><font style="vertical-align: inherit;">Unlike ordinary TREE, we store not just a tuple, but also a z-address - the mixed bits of the indexed parts. </font><font style="vertical-align: inherit;">The function is responsible for this </font></font><code>extract_zadress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>create_iterator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- from Lua we refer to this method in the case of </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'a and</font></font><code>pairs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'and.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> struct iterator *
<span class="hljs-title">memtx_zcurve_index_create_iterator</span><span class="hljs-params">(struct index *base, <span class="hljs-keyword">enum</span> iterator_type type,
                                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">uint32_t</span> part_count)</span>
</span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_index</span> *<span class="hljs-title">index</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">memtx_zcurve_index</span> *)<span class="hljs-title">base</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_engine</span> *<span class="hljs-title">memtx</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">memtx_engine</span> *)<span class="hljs-title">base</span>-&gt;<span class="hljs-title">engine</span>;</span><font></font>
<font></font>
    assert(part_count == <span class="hljs-number">0</span> || key != <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (type != ITER_EQ &amp;&amp; type != ITER_ALL &amp;&amp; type != ITER_GE) {<font></font>
        diag_set(UnsupportedIndexFeature, base-&gt;def,<font></font>
                 <span class="hljs-string">"requested iterator type"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">uint8_t</span> index_dim = base-&gt;def-&gt;key_def-&gt;part_count;
    <span class="hljs-keyword">if</span> (part_count == <span class="hljs-number">0</span>) {
        <span class="hljs-comment">/*
         * If no key is specified, downgrade equality
         * iterators to a full range.
         */</span><font></font>
        type = ITER_GE;<font></font>
        key = <span class="hljs-literal">NULL</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index_dim * <span class="hljs-number">2</span> == part_count<font></font>
               &amp;&amp; type != ITER_ALL) {<font></font>
        <span class="hljs-comment">/*
         * If part_count is twice greater than key_def.part_count
         * set iterator to range query
         */</span><font></font>
        type = ITER_GE;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree_iterator</span> *<span class="hljs-title">it</span> = <span class="hljs-title">mempool_alloc</span>(&amp;<span class="hljs-title">memtx</span>-&gt;<span class="hljs-title">zcurve_iterator_pool</span>);</span>
    <span class="hljs-keyword">if</span> (it == <span class="hljs-literal">NULL</span>) {<font></font>
        diag_set(OutOfMemory, <span class="hljs-keyword">sizeof</span>(struct tree_iterator),
                 <span class="hljs-string">"memtx_zcurve_index"</span>, <span class="hljs-string">"iterator"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
    }<font></font>
<font></font>
    iterator_create(&amp;it-&gt;base, base);<font></font>
    it-&gt;pool = &amp;memtx-&gt;zcurve_iterator_pool;<font></font>
    it-&gt;base.next = tree_iterator_start;<font></font>
    it-&gt;base.<span class="hljs-built_in">free</span> = tree_iterator_free;<font></font>
    it-&gt;type = type;<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (part_count == <span class="hljs-number">0</span> || type == ITER_ALL) {<font></font>
        it-&gt;lower_bound = zeros(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
        it-&gt;upper_bound = ones(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == ITER_EQ) {<font></font>
        it-&gt;lower_bound = mp_decode_key(&amp;index-&gt;bit_array_pool,<font></font>
                key, index_dim, index);<font></font>
        it-&gt;upper_bound = <span class="hljs-literal">NULL</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (base-&gt;def-&gt;key_def-&gt;part_count == part_count) {<font></font>
        it-&gt;lower_bound = mp_decode_key(&amp;index-&gt;bit_array_pool,<font></font>
                key, index_dim, index);<font></font>
        it-&gt;upper_bound = ones(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (base-&gt;def-&gt;key_def-&gt;part_count * <span class="hljs-number">2</span> == part_count) {<font></font>
        it-&gt;lower_bound  = z_value_create(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
        it-&gt;upper_bound  = z_value_create(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
        mp_decode_part(key, part_count, index, it-&gt;lower_bound, it-&gt;upper_bound);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        unreachable();<font></font>
    }<font></font>
    it-&gt;tree_iterator = memtx_zcurve_invalid_iterator();<font></font>
    it-&gt;current.tuple = <span class="hljs-literal">NULL</span>;<font></font>
    it-&gt;current.z_address = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> (struct iterator *)it;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depending on the transmitted key, we calculate the lower and upper bounds of the request. </font><font style="vertical-align: inherit;">However, so far this iterator does not point to anything. </font><font style="vertical-align: inherit;">There are several types of iterators in total. </font><font style="vertical-align: inherit;">In our case, this is ALL - getting all the elements; </font><font style="vertical-align: inherit;">EQ - receiving elements whose z-address matches the transmitted one; </font><font style="vertical-align: inherit;">and GE is the selection of elements in the hypercube. </font></font><br>
<br>
<code>destroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- removal of the index. </font><font style="vertical-align: inherit;">In the case of the secondary index, it simply frees the memory that was allocated for the search structure. </font><font style="vertical-align: inherit;">And if the index is primary, then physically deletes the stored tuples. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All code is available at: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/olegrok/tarantool/tree/z-order-curve-index</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Let's see what happened and summarize.</font></font><br>
<br>
<pre><code class="lua hljs">space = box.schema.space.<span class="hljs-built_in">create</span>(<span class="hljs-string">'myspace'</span>, { engine = <span class="hljs-string">'memtx'</span> })<font></font>
pk = space:create_index(<span class="hljs-string">'primary'</span>, { <span class="hljs-built_in">type</span> = <span class="hljs-string">'tree'</span>, parts = {{<span class="hljs-number">1</span>, <span class="hljs-string">'unsigned'</span>}}, unique = <span class="hljs-literal">true</span>})<font></font>
sk = space:create_index(<span class="hljs-string">'secondary'</span>, { <span class="hljs-built_in">type</span> = <span class="hljs-string">'zcurve'</span>, parts = {{<span class="hljs-number">2</span>, <span class="hljs-string">'unsigned'</span>}, {<span class="hljs-number">3</span>, <span class="hljs-string">'unsigned'</span>}}})
<span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>,<span class="hljs-number">5</span> <span class="hljs-keyword">do</span> <span class="hljs-keyword">for</span> j=<span class="hljs-number">0</span>,<span class="hljs-number">5</span> <span class="hljs-keyword">do</span> space:<span class="hljs-built_in">insert</span>{i * <span class="hljs-number">6</span> + j, i, j} <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
<span class="hljs-comment">-- returns all tuples</span>
pk:<span class="hljs-built_in">select</span>{}
<span class="hljs-comment">-- (2 &lt;= x &lt;= 3) and (3 &lt;= y &lt;= 5)</span>
sk:<span class="hljs-built_in">select</span>{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>}
<span class="hljs-comment">---</span>
- — [<span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">21</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">16</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">17</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">23</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<font></font>
…<font></font>
<span class="hljs-comment">-- (x == 2) and (y == 3)</span>
sk:<span class="hljs-built_in">select</span>{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
<span class="hljs-comment">---</span>
- — [<span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-comment">-- (2 &lt;= x &lt;= 3)</span>
sk:<span class="hljs-built_in">select</span>({<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, box.NULL, box.NULL})
<span class="hljs-comment">---</span>
- — [<span class="hljs-number">12</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]<font></font>
  - [<span class="hljs-number">18</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>]<font></font>
  - [<span class="hljs-number">13</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<font></font>
  - [<span class="hljs-number">19</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]<font></font>
  - [<span class="hljs-number">14</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<font></font>
  - [<span class="hljs-number">20</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]<font></font>
  - [<span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">21</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">16</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">17</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">23</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<font></font>
...<font></font>
<span class="hljs-comment">-- (x &gt;= 2) and (y &gt;= 3)</span>
sk:<span class="hljs-built_in">select</span>({<span class="hljs-number">2</span>, box.NULL, <span class="hljs-number">3</span>, box.NULL})
<span class="hljs-comment">---</span>
- — [<span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">21</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">27</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">33</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">16</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">17</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">23</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">28</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">34</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">29</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">35</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]<font></font>
...</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What about performance?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It turned out that everything is not as rosy as I described. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Starting at some point, the Z-order curve begins to sag significantly in terms of data access speed. perf top showed that most of the time is spent on checking that the point belongs to the search area and calculating the next point to which you need to jump. Both operations have linear complexity depending on the key length - as the dimension increases, the length also increases.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70e/338/fd1/70e338fd15af8701c3a5696ebfb3ea2a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From the pleasant - the memory consumption is 2-3 times less and the insertion is slightly faster than the R-Tree. </font><font style="vertical-align: inherit;">Which is not particularly relevant, because the measurements were made with WAL turned off. </font><font style="vertical-align: inherit;">Firstly, in a production environment, in the event of a failure, a disabled WAL can lead to data loss. </font><font style="vertical-align: inherit;">Secondly, despite the fact that writing to the WAL uses the batche approach, it is still writing to disk, which is thousands of times slower than working with RAM.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/e73/e29/9eee73e29d809963c069a9f7414f524a.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c0/8b9/159/2c08b91598dbefe2855ede4d05a593ca.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is also interesting to compare with the B-tree. </font><font style="vertical-align: inherit;">Here, as expected, the curve will be faster than a full scan and checking each point for belonging to a given area. </font><font style="vertical-align: inherit;">Even though the check is more lightweight than in the case of the Z-order curve, where it all comes down to a bitwise comparison. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The numbers on the graph differ in order from the R-Tree - the test has been slightly modified.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/ae5/44d/140ae544d6ba527bffe6bc4d814f609d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the test, I generated a set of points and compared the duration of the query using the Z-curve and conventional scanning.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To summarize</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the in-memory world, this structure has proved to be not the best way, however, it still has advantages:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Takes up less space.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typed, unlike R-Tree (relevant only for Tarantool).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It’s worth a closer look if there is only a B-Tree and you need to make multidimensional queries (not relevant for Tarantool).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It was an interesting experiment. </font><font style="vertical-align: inherit;">It is unlikely that the solution I proposed will ever become part of Tarantool. </font><font style="vertical-align: inherit;">However, do not be afraid to experiment. </font><font style="vertical-align: inherit;">And if you have any suggestions and solutions, then do not be afraid to share them.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sources</font></font></h2><br>
<a name="B-Tree"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[B-Tree]: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indexes in PostgreSQL - 4 / Postgres Professional's blog / Habr </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-tree / Habr </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-tree data structure / OTUS Blog. </font><font style="vertical-align: inherit;">Online education / geek magazine</font></font></a><br>
<br>
<a name="ZcurvePostgres"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ZcurvePostgres]: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About Z-order and R-tree / geek magazine </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z-order vs R-tree, continued / geek magazine</font></font></a><br>
<br>
<a name="1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z-Order Indexing for Multifaceted Queries in Amazon DynamoDB: Part 1 | </font><font style="vertical-align: inherit;">AWS Database Blog</font></font></a><br>
<br>
<a name="1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z-order indexing for multifaceted queries in Amazon DynamoDB: Part 2 | </font><font style="vertical-align: inherit;">AWS Database Blog</font></font></a><br>
<br>
<a name="3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integrating the UB-Tree into a Database System Kernel</font></font></a><br>
<br>
<a name="4"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/tarantool/small</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en505850/index.html">C ++ Concept-Based Polymorphism in Product Code: PassManager in LLVM</a></li>
<li><a href="../en505856/index.html">From Brute-Force to the attempt on privacy - what SaaS providers face</a></li>
<li><a href="../en505860/index.html">Spring Boot, Hibernate and Kotlin for beginners step by step</a></li>
<li><a href="../en505870/index.html">How to promote mobile games and applications in Japan, Korea and China</a></li>
<li><a href="../en505872/index.html">History of unmanned vehicles</a></li>
<li><a href="../en505884/index.html">Spear phishing: experience creating conditionally malicious executable files for phishing emails</a></li>
<li><a href="../en505888/index.html">Parsing YouTube, including uploaded data, without the YouTube API</a></li>
<li><a href="../en505896/index.html">Security Week 24: Zoom and Brave browser privacy</a></li>
<li><a href="../en505898/index.html">Claude Shannon: jack of all trades, joker and father of information theory</a></li>
<li><a href="../en505900/index.html">Personal addictions: full-sized 40 mm, without wire, for 72 hours for 8000 rubles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>