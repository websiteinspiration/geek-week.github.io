<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➖ ✈️ 🤱🏼 Distribusi Data di Apache Ignite 👨🏾‍🤝‍👨🏻 🆓 👨🏿‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo! Posting ini adalah versi yang sedikit dipersingkat dari ceramah eponim saya pada pertemuan komunitas Apache Ignite . Anda dapat menonton versi v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Distribusi Data di Apache Ignite</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/gridgain/blog/489962/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo! </font><font style="vertical-align: inherit;">Posting ini adalah versi yang sedikit dipersingkat dari ceramah eponim saya pada pertemuan komunitas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache Ignite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Anda dapat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menonton</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> versi video lengkap bersama dengan pertanyaan dan jawaban di </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">sini</font></a><font style="vertical-align: inherit;"> , dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unduh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> slide di </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">sini</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dalam laporan itu, saya mencoba menunjukkan dengan contoh bagaimana data didistribusikan di Apache Ignite.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa Anda perlu mendistribusikan apa pun</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejarah standar yang cukup dari pengembangan sistem apa pun yang membutuhkan penyimpanan dan pemrosesan data adalah pencapaian pagu tertentu. Entah ada banyak data dan mereka tidak secara fisik ditempatkan pada perangkat penyimpanan, atau beban tumbuh pada tingkat yang satu server tidak lagi dapat memproses sejumlah permintaan seperti itu. Ada banyak kasus ketika keduanya terjadi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai aturan, mereka datang ke salah satu dari dua solusi: baik sharding penyimpanan yang ada, atau beralih ke database terdistribusi. Kedua solusi memiliki sejumlah fitur umum, yang paling jelas di antaranya adalah penggunaan lebih dari satu node untuk bekerja dengan data. Selanjutnya, banyak node yang saya sebut topologi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah distribusi data antara node topologi dapat dirumuskan sebagai seperangkat persyaratan yang harus dipenuhi oleh distribusi kami:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diperlukan suatu algoritma yang akan memungkinkan semua node dari topologi dan aplikasi klien untuk sampai pada kesimpulan yang sama tentang node atau node mana objek tertentu (atau kunci) aktif.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keseragaman distribusi. </font><font style="vertical-align: inherit;">Semakin merata data didistribusikan di antara node, semakin banyak beban pada node ini akan didistribusikan. </font><font style="vertical-align: inherit;">Di sini saya membuat asumsi bahwa node kami memiliki sumber daya yang kira-kira sama.</font></font></li>
<li>  .      ,       ,    .   ,       ,       ,     .<br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mencapai dua persyaratan pertama cukup mudah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendekatan yang akrab, sering digunakan ketika menyeimbangkan beban antara server yang setara secara fungsional, membagi modulo N, di mana N adalah jumlah node dalam topologi dan kami memiliki korespondensi satu-ke-satu antara nomor node dan pengenalnya. Maka semua yang perlu kita lakukan adalah merepresentasikan kunci objek sebagai nilai numerik menggunakan fungsi hash dan mengambil sisa pembagian dengan nilai N dari nilai yang diperoleh.Diagram </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zi/7x/ii/zi7xiiu8xmrjgaeghuc8xkekubk.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
menunjukkan distribusi 16 kunci lebih dari 3 node. Dapat dilihat bahwa distribusi ini seragam, dan algoritma untuk mendapatkan node untuk objek sederhana dan menjamin bahwa jika semua node dari topologi menggunakan algoritma ini, maka hasil yang sama akan diperoleh untuk kunci yang sama dan N. yang sama</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi apa yang terjadi jika kita memperkenalkan simpul ke-4 ke dalam topologi? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/82/ro/-i/82ro-ipa6d3lw8stb_fx7e9_wos.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi kami telah berubah, sekarang kami mengambil sisa divisi dengan 4, bukan oleh 3. Dan jika fungsi telah berubah, maka distribusinya telah berubah, dan sangat banyak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini, lokasi objek sebelumnya untuk versi sebelumnya dari topologi tiga node ditunjukkan dengan warna merah, dan posisi objek untuk versi baru dari topologi empat node masing-masing berwarna hijau. Ini sangat mirip dengan file diff biasa, tetapi alih-alih file kita memiliki node. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sangat mudah untuk melihat bahwa data telah pindah tidak hanya ke node baru, tetapi juga ada pertukaran data antara node yang sudah ada dalam topologi. Itu kami mengamati lalu lintas palsu antara node dan persyaratan perubahan minimal dalam distribusi tidak terpenuhi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua cara populer untuk memecahkan masalah distribusi data, dengan mempertimbangkan persyaratan yang tercantum, adalah sebagai berikut:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hashing yang konsisten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma Bobot Acak Terbesar (HRW), juga dikenal sebagai hashing Rendezvous.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kedua algoritma ini sangat sederhana. </font><font style="vertical-align: inherit;">Deskripsi mereka di Wikipedia sesuai dengan beberapa kalimat. </font><font style="vertical-align: inherit;">Meskipun sulit untuk memanggil mereka dengan jelas. </font><font style="vertical-align: inherit;">Bagi mereka yang tertarik, saya sarankan membaca artikel asli </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hashing konsisten dan Pohon Acak: Protokol Caching Terdistribusi untuk Menghilangkan Hot Spot di World Wide Web</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skema Pemetaan Berbasis Nama untuk Rendezvous</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Yang paling dapat dimengerti, menurut pendapat saya, gagasan algoritma hashing yang konsisten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disampaikan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">kursus Stanford ini</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat algoritma ini lebih terinci.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hashing yang Konsisten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trik yang mendasari algoritma hashing yang konsisten adalah memetakan kedua node dan objek yang disimpan ke ruang pengidentifikasi yang sama. </font><font style="vertical-align: inherit;">Ini membuat entitas, objek, dan node kami yang tampaknya berbeda dapat dibandingkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mendapatkan pemetaan seperti itu, kita cukup menerapkan fungsi hash yang sama untuk kunci-kunci objek dan untuk pengidentifikasi node. </font><font style="vertical-align: inherit;">Hasil dari fungsi hash untuk node akan disebut token, ini akan berguna bagi kita nanti. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mewakili ruang pengenal kami dalam bentuk lingkaran, mis. </font><font style="vertical-align: inherit;">kami hanya berasumsi bahwa nilai pengenal maksimum segera mengikuti nilai pengenal minimum.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, untuk menentukan di simpul mana objek itu hidup, Anda perlu mendapatkan nilai fungsi hash dari kuncinya, dan kemudian hanya bergerak searah jarum jam di sekitar lingkaran sampai kita menemukan token dari simpul di jalan. Arah gerakan tidak penting, tetapi harus diperbaiki. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gerakan searah jarum jam imajiner secara fungsional setara dengan pencarian biner dalam array token simpul yang diurutkan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ca/dh/fy/cadhfyrlc9b_maoinnjw0kvp6fm.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam diagram, setiap sektor dengan warna tertentu mencerminkan ruang pengenal yang bertanggung jawab atas simpul tertentu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita menambahkan simpul baru, maka ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v7/an/3r/v7an3r9bwxn9hnziy-w7umr5viq.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... itu akan membagi salah satu sektor menjadi dua bagian dan sepenuhnya mengambil alih kunci yang sesuai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh ini, simpul 3 mengambil alih bagian dari kunci simpul 1.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, pendekatan ini memberikan distribusi objek yang agak tidak merata di seluruh node, karena itu sangat tergantung pada pengidentifikasi node itu sendiri. Bagaimana pendekatan ini dapat ditingkatkan? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat menetapkan lebih dari satu token ke node (biasanya ratusan). Ini dapat dicapai, misalnya, dengan memperkenalkan banyak fungsi hash untuk node (satu per token) atau berulang kali menerapkan fungsi hash yang sama ke token yang diperoleh pada langkah sebelumnya. Tapi kita jangan lupa tentang tabrakan. Seharusnya tidak ada dua node dengan token yang sama. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7i/m2/ay/7im2ay5cr_ydc5hh62vlwcaqhp0.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh ini, setiap node memiliki 4 token.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa lagi yang penting untuk disebutkan: jika kita ingin memastikan keamanan data jika ada simpul yang meninggalkan topologi, maka kita perlu menyimpan kunci pada beberapa node (disebut replika atau cadangan). </font><font style="vertical-align: inherit;">Dalam kasus algoritma hashing yang konsisten, replika akan menjadi simpul N-1 berikut pada lingkaran, di mana N adalah faktor replikasi. </font><font style="vertical-align: inherit;">Tentu saja, urutan node harus ditentukan oleh token tertentu (misalnya, oleh yang pertama), karena </font><font style="vertical-align: inherit;">saat menggunakan beberapa token untuk masing-masingnya, susunan node mungkin berbeda. </font><font style="vertical-align: inherit;">Perhatikan skema: tidak memiliki pola pengulangan node yang jelas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adapun persyaratan perubahan minimal dalam distribusi ketika mengubah topologi, itu puas karena urutan timbal balik dari node pada lingkaran tidak berubah. </font><font style="vertical-align: inherit;">Itu </font><font style="vertical-align: inherit;">menghapus node dari topologi tidak akan mengubah hubungan urutan antara node yang tersisa.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hashing pertemuan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma hashing Rendezvous tampaknya bahkan lebih sederhana daripada hashing yang konsisten. Algoritma ini didasarkan pada prinsip invarian hubungan keteraturan yang sama. Tetapi alih-alih membuat node dan objek sebanding, kami hanya membuat node untuk objek tertentu yang sebanding. Itu kami menentukan hubungan urutan antara node untuk setiap objek secara independen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekali lagi hashing membantu kita dengan ini. Tapi sekarang, untuk menentukan bobot simpul N untuk objek O yang diberikan, kita akan mencampur pengidentifikasi objek dengan pengidentifikasi simpul dan mengambil hash dari campuran ini. Setelah melakukan operasi ini untuk setiap node, kami mendapatkan satu set bobot yang digunakan untuk mengurutkan node. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Node yang ternyata menjadi yang pertama dan akan bertanggung jawab untuk menyimpan objek.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena semua node topologi menggunakan input data yang sama, hasilnya akan sama. Yang memenuhi persyaratan pertama. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ox/hs/bw/oxhsbwgq8xrlfrirs8xupmx3hww.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan sebuah contoh. Di sini kita memiliki relasi urutan antara tiga node untuk empat kunci yang berbeda. Kuning menunjukkan simpul dengan bobot tertinggi, mis. simpul yang pada akhirnya akan bertanggung jawab untuk kunci tertentu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambahkan node lain ke topologi.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hc/a9/4s/hca94sz_p5pz-lwflppuqlm7c54.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya sengaja meletakkannya di diagonal untuk memperhitungkan semua opsi yang mungkin. Di sini, simpul 3, ditunjukkan dengan warna hijau, memasuki topologi. Oleh karena itu, distribusi bobot node untuk masing-masing kunci telah berubah. Merah menunjukkan node yang telah mengubah lokasi mereka dalam daftar untuk kunci tertentu, karena bobot dari simpul-simpul ini kurang dari berat simpul yang ditambahkan. Namun, perubahan ini hanya mempengaruhi salah satu kunci, K3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita secara tidak sengaja mengambil simpul dari topologi. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ds/gr/d_/dsgrd_q9ai9yi9p5x08ubfgflem.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekali lagi, perubahan hanya mempengaruhi satu kunci, kali ini K1. Objek yang tersisa tidak terpengaruh. Alasannya, seperti dalam kasus hashing yang konsisten, adalah invarian dari hubungan urutan antara setiap pasangan node. Itu persyaratan perubahan minimum dalam distribusi terpenuhi dan tidak ada lalu lintas palsu antara node.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Distribusi untuk pertemuan terlihat cukup bagus dan tidak memerlukan trik tambahan dibandingkan dengan tanda hashing seperti yang konsisten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita ingin mendukung replikasi, maka simpul berikutnya dalam daftar akan menjadi replika pertama untuk objek, simpul berikutnya akan menjadi replika kedua, dll.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana hashing pertemuan digunakan di Apache Ignite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi afinitas disebut bertanggung jawab atas distribusi data di Apache Ignite (lihat antarmuka </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AffinityFunction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Implementasi standarnya adalah hashing rendezvous (lihat kelas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RendezvousAffinityFunction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal pertama yang perlu Anda perhatikan adalah bahwa Apache Ignite tidak memetakan objek yang disimpan secara langsung ke node topologi. Sebaliknya, konsep tambahan diperkenalkan - partisi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Partisi adalah wadah untuk objek dan unit replikasi. Selain itu, jumlah partisi untuk cache tertentu (ini adalah analog dari tabel di database yang dikenal) diatur pada tahap konfigurasi dan tidak berubah selama siklus hidup cache.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, kita dapat menampilkan objek pada partisi menggunakan pembagian modulo yang efektif, dan menggunakan hashing rendezvous untuk memetakan partisi ke node. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/wr/vt/wdwrvtuau9ywcgq4uqk0hhqscu8.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena jumlah partisi untuk cache adalah konstan, maka kita dapat menghitung distribusi partisi dengan node sekali dan cache hasilnya sampai topologi diubah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap node menghitung distribusi ini secara independen, tetapi pada semua node dengan data input yang sama distribusi ini akan identik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Partisi dapat memiliki beberapa salinan, kami menyebutnya cadangan. Partisi primer disebut partisi primer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk distribusi kunci terbaik antara partisi dan partisi berdasarkan node, aturan berikut harus dipenuhi: jumlah partisi harus secara signifikan lebih besar dari jumlah node, pada gilirannya, jumlah kunci harus secara signifikan lebih besar daripada jumlah partisi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cache di Ignite dipartisi dan direplikasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam cache yang dipartisi, jumlah cadangan diatur pada tahap pembuatan cache. Partisi - primary dan backup - didistribusikan secara merata di antara node. Cache seperti itu paling cocok untuk bekerja dengan data operasional, seperti memberikan kinerja penulisan terbaik, yang secara langsung tergantung pada jumlah cadangan. Secara umum, semakin banyak cadangan, semakin banyak node harus mengkonfirmasi catatan utama.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hh/fs/_u/hhfs_ujczi2m1p8kl4c5z3p2ra4.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh ini, cache memiliki satu cadangan. </font><font style="vertical-align: inherit;">Itu </font><font style="vertical-align: inherit;">kita bisa kehilangan satu simpul dan tidak kehilangan data, karena </font><font style="vertical-align: inherit;">Cadangan partisi tidak pernah disimpan pada simpul yang sama dengan partisi primer atau cadangan lainnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam cache yang direplikasi, jumlah cadangan selalu sama dengan jumlah node topologi minus 1. Artinya, </font><font style="vertical-align: inherit;">setiap node selalu berisi salinan semua partisi. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n-/fk/by/n-fkbyie-hipm40twvyg_erjjm0.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cache seperti itu paling cocok untuk bekerja dengan data yang jarang berubah (misalnya, direktori) dan menyediakan ketersediaan terbesar, seperti </font><font style="vertical-align: inherit;">kita bisa kehilangan N-1 node (dalam hal ini 3) tanpa kehilangan data. </font><font style="vertical-align: inherit;">Juga dalam opsi ini, kita akan mendapatkan kinerja baca maksimum jika kita mengizinkan untuk membaca data dari partisi primer dan cadangan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colokasi data di Apache Ignite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konsep penting yang perlu diingat untuk kinerja terbaik adalah kolokasi. Colocation adalah penempatan benda apa pun di tempat yang sama. Dalam kasus kami, objek adalah entitas yang disimpan dalam cache, dan tempat adalah simpul. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika objek didistribusikan di seluruh partisi dari fungsi afinitas yang sama, adalah logis bahwa objek dengan kunci afinitas yang sama akan jatuh ke partisi yang sama, dan karenanya, ke node yang sama. Dalam Ignite, ini disebut colocation afinitas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara default, kunci afinitas adalah kunci utama suatu objek. Tapi di Ignite, Anda bisa menggunakan bidang objek apa pun lainnya sebagai kunci afinitas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kolokasi secara signifikan mengurangi jumlah data yang dikirim antara node untuk melakukan perhitungan atau query SQL, yang secara alami mengarah pada pengurangan waktu yang dihabiskan untuk tugas-tugas ini. Pertimbangkan konsep ini dengan contoh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biarkan model data kami terdiri dari dua entitas: order (Pesanan) dan posisi pesanan (OrderItem). Satu pesanan dapat sesuai dengan banyak item. Pengidentifikasi pesanan dan item baris independen, tetapi item baris memiliki kunci asing yang merujuk pada urutan yang sesuai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan kita perlu melakukan beberapa tugas, yang untuk setiap pesanan harus melakukan perhitungan untuk posisi pesanan ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara default, kunci afinitas adalah kunci utama. Oleh karena itu, pesanan dan posisi akan didistribusikan antar node sesuai dengan kunci utama mereka, yang saya ingat, bersifat independen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/q-/vq/tkq-vq1_sbghpcqdsz8ythpehim.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada diagram, pesanan diwakili oleh kuadrat, dan posisi dalam lingkaran. Warna menunjukkan bahwa barang itu milik pesanan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan distribusi data ini, tugas hipotetis kami akan dikirim ke node di mana urutan yang diinginkan berada, dan kemudian akan perlu membaca posisi dari semua node lain, atau mengirim subtugas ke node-node ini dan mendapatkan hasil perhitungan. Ini adalah interaksi jaringan yang tidak perlu yang dapat dan harus dihindari. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana jika kita memberi tahu Ignite bahwa item pesanan harus ditempatkan pada node yang sama dengan pesanan itu sendiri, mis. mengumpulkan data? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai kunci afinitas untuk posisi tersebut, kami akan mengambil kunci asing OrderId dan bidang ini akan digunakan saat menghitung partisi tempat catatan tersebut berada. Selain itu, di dalam partisi, kita selalu dapat menemukan objek kita dengan kunci primer.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/uq/kg/lvuqkgzf9gpoot8gjnr25uxb6ve.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, jika kedua cache (Order dan OrderItem) menggunakan fungsi afinitas yang sama dengan parameter yang sama, data kami akan berada di dekatnya dan kami tidak perlu berkeliling jaringan untuk item pesanan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurasi afinitas di Apache Ignite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam implementasi saat ini, objek fungsi afinitas adalah parameter konfigurasi cache. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi afinitas itu sendiri mengambil argumen berikut saat membuat:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jumlah partisi;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jumlah cadangan (sebenarnya, ini juga merupakan parameter konfigurasi cache);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filter cadangan;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tandai tidak termasuk Tetangga.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengaturan ini tidak dapat diubah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan jumlah partisi dan cadangan, semuanya tampak jelas. Saya akan berbicara tentang filter cadangan dan flag excludeNeighbors beberapa saat kemudian. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat run time, fungsi afinitas input menerima topologi cluster saat ini - pada dasarnya daftar node cluster - dan menghitung distribusi partisi dengan node sesuai dengan contoh yang saya tunjukkan ketika saya berbicara tentang algoritma hashing pertemuan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sedangkan untuk filter cadangan, ini adalah predikat yang memungkinkan Anda untuk melarang fungsi afinitas dari menetapkan partisi cadangan ke sebuah node yang predikatnya kembali salah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai contoh, anggaplah bahwa node fisik kita - server - terletak di pusat data di rak yang berbeda. Biasanya, setiap rak memiliki kekuatan independen ...</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5e/ts/wy/5etswypgpotv2e9exzu3gsyl9f8.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... dan jika kita kehilangan rak, maka kita kehilangan datanya. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nz/hy/5d/nzhy5dzl77t7pxhtxbtqubcbzek.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh ini, kami kehilangan setengah dari partisi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi jika kita mengatur filter cadangan yang benar, maka distribusinya akan berubah sedemikian rupa ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/20/90/gy/2090gyzlg_0-80-dhkw8hvplftm.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... bahwa jika raknya hilang, tidak akan ada kehilangan data dan mereka masih akan tersedia. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/oo/eg/k5/ooegk5vas7xhk7qzrergws5ieli.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bendera excludeNeighbors melakukan fungsi serupa, dan sebenarnya itu adalah singkatan untuk satu kasus tertentu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seringkali beberapa node Ignite dijalankan pada host fisik yang sama. Kasus ini sangat mirip dengan contoh dengan rak di pusat data, hanya sekarang kita berjuang kehilangan data dengan hilangnya tuan rumah, bukan rak. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/ze/wn/tkzewnmjc5iigjd_appzyvfoheo.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sisanya sama. Anda dapat menerapkan perilaku ini menggunakan filter cadangan. Bendera ini adalah warisan sejarah dan dapat dihapus dalam rilis utama berikutnya dari Ignite.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tampaknya saya berbicara tentang fungsi afinitas dan distribusi data segala sesuatu yang perlu diketahui oleh pengembang menggunakan Apache Ignite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai kesimpulan, mari kita lihat contoh distribusi 16 partisi sesuai dengan topologi 3 node. Untuk kesederhanaan dan kejelasan, kami percaya bahwa partisi tidak memiliki cadangan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya hanya mengambil dan menulis sebuah tes kecil yang membawa saya pada distribusi yang sebenarnya: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yy/lm/np/yylmnpenoifogzoo0lig3kzw_5g.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, keseragaman distribusi tidak ideal. Tetapi kesalahan akan terasa lebih rendah dengan peningkatan jumlah node dan partisi. Aturan utama yang harus diperhatikan adalah jumlah partisi secara signifikan lebih besar dari jumlah node. Sekarang di Ignite jumlah default partisi untuk cache yang dipartisi adalah 1024. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang tambahkan node baru ke topologi.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xd/xf/sp/xdxfspt29ky3x0gfceqi_xiswv0.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagian pihak pindah kepadanya. Pada saat yang sama, persyaratan perubahan minimal dalam distribusi diamati: node baru menerima bagian dari partisi, sementara node lain tidak bertukar partisi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menghapus dari topologi, simpul yang ada di dalamnya pada tahap awal: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ym/b5/il/ymb5ilednyy4dxf6ynojfva7gao.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang semua partisi yang terkait dengan simpul nol didistribusikan kembali di antara simpul-simpul topologi lainnya, tanpa melanggar persyaratan distribusi kami.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, solusi untuk masalah-masalah kompleks seringkali didasarkan pada ide-ide yang sepele, meskipun tidak sepenuhnya jelas. </font><font style="vertical-align: inherit;">Solusi yang dijelaskan digunakan di sebagian besar database terdistribusi dan melakukan pekerjaan dengan baik. </font><font style="vertical-align: inherit;">Tetapi keputusan ini diacak dan karena itu keseragaman distribusi jauh dari ideal. </font><font style="vertical-align: inherit;">Bisakah keseragaman ditingkatkan tanpa mengorbankan kinerja dan persyaratan distribusi lainnya? </font><font style="vertical-align: inherit;">Pertanyaannya tetap terbuka.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id489952/index.html">Wallpaper desktop hidup dan memotivasi</a></li>
<li><a href="../id489954/index.html">Seagate SkyHawk AI - besar dan pendendam</a></li>
<li><a href="../id489956/index.html">Kami menghidupkan RecyclerView dengan mudah tanpa beralih ke ViewPager2</a></li>
<li><a href="../id489958/index.html">Penjelasan: mengapa wc pada Haskell ternyata “lebih cepat” daripada analog pada C</a></li>
<li><a href="../id489960/index.html">Pembuatan otomatis dari aplikasi Delphi</a></li>
<li><a href="../id489968/index.html">Kami menangkap degradasi baterai AA dan AAA pada arus 0,3 dari kapasitansi</a></li>
<li><a href="../id489970/index.html">Programmer, Pack dan John Steinbeck</a></li>
<li><a href="../id489974/index.html">Kha vs HTML5: Kompilasi JavaScript di C ++</a></li>
<li><a href="../id489984/index.html">AMA tentang udalenka: tanyakan - kami jawab</a></li>
<li><a href="../id489986/index.html">Utilitas Desainer Panggung Power - Alat Pengembang Power Electronics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>