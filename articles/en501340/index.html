<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëø ‚úùÔ∏è üëºüèª Why is Flutter winning? üöñ üéÖüèΩ ü§òüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last year, I have been writing Flutter apps for iOS and Android anyway. Before that, I had and have 5 years of experience with Xamarin. It has been a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Why is Flutter winning?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501340/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Last year, I have been writing Flutter apps for iOS and Android anyway. </font><font style="vertical-align: inherit;">Before that, I had and have 5 years of experience with Xamarin. </font><font style="vertical-align: inherit;">It has been a wonderful 5 years. </font><font style="vertical-align: inherit;">Thanks to Xamarin and my love for this framework, I, in principle, moved to the camp of developers, this tool helped me earn a lot of money, knowledge and find wonderful colleagues. </font><font style="vertical-align: inherit;">So why am I writing on Flutter now? </font><font style="vertical-align: inherit;">Short answer, because Flutter covers all the needs of cross-platform development.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qo/ua/rw/qouarwd80cvkhylqpiukpop86n8.jpeg"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A bit of history</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Correct me if I'm wrong, but 2009 was in many respects key for mobile development in general and cross-platform development in particular. In 2009, iPhone 3gs was released, which allowed you to run third-party applications from the AppStore. For the first time this opportunity appeared a year earlier in the iPhone 3g, but 3gs has become a truly massive, ‚Äúpopular‚Äù iPhone. Again, a year earlier, in September 2008, Android was introduced to the public and in 2009 many phone manufacturers began trying Android for their new phone models. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In spring</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2009, Nitobi introduced PhoneGap, a new framework for creating cross-platform applications based on HTML5, CSS and JS. In the same year, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in September</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ximian released MonoTouch, which allowed you to write iOS applications using Mono and C #. In the same 2009, in December, Rovio Entertainment released a game for iOS and, for a moment, Maemo, which in many ways marked the beginning of the mobile game industry - Angry Birds. The last example here is not accidental.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first cross-platform framework "for the people" can be considered PhoneGap (Qt developers, do not throw stones). It was a wonderful and very obvious idea - to bring the web into the world of mobile development. By 2009, the capabilities of the web had already begun to extend beyond the browser ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hello</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> node.js), while writing web applications in JS was pretty straightforward. The second, no less important point is the rendering of the UI. The way the rendering happens lies with the browser engine and all these engines more or less follow the W3C standards for HTML, CSS and DOM. Any web developer who has made up a site expects that his site will look </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">almost</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identical in any browser, on any platform. This, in my opinion, is the most important aspect of the web as an open platform. Why should I learn a new language / framework for drawing UI for each of the platforms, if for a long time there is a standard for modeling UI for different browsers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After that, Cordova spun off from PhoneGap, and from it Ionic. It would seem that this is an ideal framework, but there were 2 points: performance and OS integration. One of the main goals or, if you want, application benchmarks, written on cross-platform solutions was their "nativeness". Those. Ideally, 100% of users should consider that your cross-platform application is native. And this means that it should look like native, work like native and have all possible integration with the OS. In the beginning, all these points for PhoneGap were unattainable, the capacities of smartphones 10 years ago were not enough for the 60 fps UI render, integration with the OS was minimal. Now there are quite a few applications on Ionic that are difficult to distinguish from native ones, but mimicking a native application is still a taskand not given as such. Let's summarize a little. Writing web applications, or rather hybrid applications on iOS and Android, is possible and convenient. It‚Äôs convenient because the UI rendering mechanism lies entirely on the WebView platform, plus there is an already trained layer of programmers who are well versed in the web.</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, in hybrid applications, performance and OS integration may be lame.</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
At the same time as PhoneGap, MonoTouch was launched in 2009, which was later renamed Xamarin.iOS. Also, in the same year, Titanium was released, which in turn also allowed writing iOS applications on javascript. At first, Titanium worked in exactly the same paradigm as PhoneGap - relying on WebView. But then they adopted the Xamarin approach. What is this approach? It can be seen as something in the middle. The approach of Xamarin / Titanium / React.Native is that instead of trying to create / migrate your / existing UI render, the framework simply integrates with the existing, native.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instead of drawing a form in HTML, Xamarin calls a native UI element for this (UITextField, TextEdit, etc). Indeed, why reinvent the wheel? All the necessary UI elements exist in native SDKs and runtimes, you just need to learn how to communicate with them from your VMs (mono, v8, etc). At the same time, as you already guessed, you can use your favorite C #, JS, TS, F #, Kotlin, etc, and at the same time code that does not directly interact with the UI is 100% cross-platform. You can go even further. The same UITextField and TextEdit are conceptually identical entities, they have quite a few similar properties and interaction interfaces, and therefore, you can create an abstract Entry (hello Xamarin.Forms) and work only with it, for rare ( </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not very</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) exception going down to the platform UI element. I don‚Äôt mention that if your vm can work with the UI natively, most likely your vm can call any platform APIs. This seems like the perfect option. Native UI, native performance (hi Bridges in React.Native), 100% OS integration. Is this really perfect? Most likely - no, and the problem is that </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in reality these solutions do not solve the problem of cross-platform development - a single UI. They disguise her</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. I want to write once, run everywhere. This is far from the best motto for all types of programs and problems, but it fits well with the UI. I want to write UI the same for everyone, regardless of platform. Why can a web developer allow himself to use HTML and CSS to write a site that will then be displayed the same way in Safari on iOS and Chrome on Android, but no native developer?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, programmers have long written a high-performance UI with a common code base for iOS and Android. These programmers are called game developers. Angry Birds was written on Cocos2d-x engine, Cuphead on Unity, and Fortnite on Unreal Engine. If game engines are able to show breathtaking scenes on your phone, then buttons and lists with smooth animation will definitely be able to. So why no one uses them in this vein? The answer is simple and banal, they are not intended for this. When you open the game, it‚Äôs absolutely up to the flashlight how much the UI looks like a native one, you almost never need to interact with geolocation, push-buttons, a video camera, etc. While you play, you live a different life in your small world that is rendered through Canvas in your UIViewController / Activity. therefore</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">game engines have relatively poor integration with the OS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so there is no (or I have not seen) mimicking the native UI top engine.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Subtotals</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For an ideal cross-platform framework, we need:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Native UI mapping </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Native UI Performance </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% ability to call any OS API, as if it were a native application </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You now think that I will begin to fail under Flutter, but I already hear angry comments: ‚ÄúWhere is Qt !? </font><font style="vertical-align: inherit;">He can do all this! ‚Äù </font><font style="vertical-align: inherit;">Indeed, Qt to one degree or another fits these criteria. </font><font style="vertical-align: inherit;">Although I strongly doubt the first of them. </font><font style="vertical-align: inherit;">But the main problem of Qt is not the difficulty of writing a native UI, the main problem is C ++. </font><font style="vertical-align: inherit;">Then I‚Äôm already wiping my face from the spit of labor-encoders on the pluses. </font><font style="vertical-align: inherit;">Pros is a Swiss knife on anabolic steroids, on the pros you can do everything. </font><font style="vertical-align: inherit;">But I, as a frontend developer, do not need this all. </font><font style="vertical-align: inherit;">I need a simple and understandable language that works with UI and I / O. </font><font style="vertical-align: inherit;">So, to our three points above was added:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Easy to learn and quite expressive language </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rantime that fits well in the frontend development paradigm </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, now that we have highlighted some metrics of a good cross-platform tool for developing mobile applications, we can go over each of them and see how it is implemented in Flutter.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Native UI mapping</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ir/oi/wf/iroiwftbrxuuh_35cjdasl7sgkc.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As we found out earlier, there are two opposite approaches to working with UI in cross-platform frameworks. </font><font style="vertical-align: inherit;">This is a UI render using WebView or native UI element calls on each platform. </font><font style="vertical-align: inherit;">Each approach has advantages and disadvantages. </font><font style="vertical-align: inherit;">But they do not cover the full range of developer needs: look indistinguishable from native UI + native performance. </font><font style="vertical-align: inherit;">Flutter covers all these needs with a head. </font><font style="vertical-align: inherit;">The Flutter team spent a certain amount of resources on creating ‚Äúnative‚Äù elements in the framework itself. </font><font style="vertical-align: inherit;">All widgets in Flutter are divided into three large categories:</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cupertino Widgets</font></font></a> </li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material widgets</font></font></a> </li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Other generalized widgets</font></font></a> </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you go to the cupertino section, you will see that these widgets are indistinguishable from native iOS elements. </font><font style="vertical-align: inherit;">As a developer who has been using Flutter for a while, I can confirm that they are indistinguishable. </font><font style="vertical-align: inherit;">If you use CupertinoDatePicker, for example, when scrolling you will feel exactly the same, nice feedback from the Taptic / Haptic engine on your iPhone as if it were a native element of the native application. </font><font style="vertical-align: inherit;">I will say more, periodically I open the application of the site realtor.com on my iPhone and until recently I had no idea that it was written in Flutter (or on something not native).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter not only allows you to use "native" widgets for 2 platforms, but also create your own, and it is very easy! The whole paradigm is that everything is widget works. You can create amazingly complex UI elements and animations in a short time. The charms and wisdom of the approach to working with the UI in Flutter have recently been described in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> article on Habr, I recommend reading. Because all this works on a single graphics engine that directly renders all of this for each platform (we'll talk about it later), you can be sure that everything will be displayed as you planned.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another pretty amazing point. </font><font style="vertical-align: inherit;">Flutter supports platforms starting with iOS 8 and Android API v16. </font><font style="vertical-align: inherit;">From a UI rendering perspective, Flutter doesn't really matter which APIs are available on a particular platform. </font><font style="vertical-align: inherit;">He would have the opportunity to work with Canvas and some kind of interaction with the graphics subsystem. </font><font style="vertical-align: inherit;">And this means that we can draw the latest UI elements from AndroidX, for example, on a phone 8 years old. </font><font style="vertical-align: inherit;">There certainly is a question of the performance of this approach on the oldest supported platforms, but this is another question.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Native UI Performance</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/bs/as/ld/bsasld-hwweszsjqmucvaavtkyu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, Flutter's approach to UI rendering is closer to that of hybrid apps like Ionic. </font><font style="vertical-align: inherit;">We have a single engine for rendering UI on all platforms, this is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Graphics Library. </font><font style="vertical-align: inherit;">Google bought Skia as a product in 2005 and turned it into an Open Source project. </font><font style="vertical-align: inherit;">This at least suggests that this is a fairly mature product. </font><font style="vertical-align: inherit;">Some Skia performance features:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copy-on-write</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for graphic elements and other data types</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using stack memory wherever possible to reduce fragmentation </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread-safety, for better parallelization</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I did not find convincing Skia performance tests compared to similar libraries (see </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cairo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), but some tests show a 50% performance gain on average, except in some specific situations. Yes, this is not particularly important, because these tests are based on the use of OpenGL on desktops, and ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skia can interact with many GPU backends. Since </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time on iOS, since version 11, Flutter uses Metal as the backend GPU by default. On Android, starting with API 24 - Vulkan. For versions below - OpenGL. All this gives us an obvious gain in productivity. On other "hardware" platforms, as I understand it, Skia / Flutter uses OpenGL, which in principle does not prevent us from writing applications with sufficient graphics performance. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Web stands apart. At the moment, the entire UI render still lays on the Canvas / HTML bundle. Therefore, Skia is in no way involved in this process. Plus, the Dart VM does not interact directly with the DOM. First comes the conversion to js. All this does not have the best effect on productivity and it is directly noticeable to the naked eye. However, </font><font style="vertical-align: inherit;">work </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> underway to implement </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CanvasKit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Flutter, which in turn will allow Skia to be used in browsers via WebGL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, C # programmers have been using SkiaSharp for a relatively long time - a wrapper over Skia for Mono / .Net x. </font><font style="vertical-align: inherit;">And the Xamarin community uses this lib to draw custom UI elements and this is a very popular library. </font><font style="vertical-align: inherit;">If this is not a victory, then I do not know what it is.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% ability to call any API OS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Flutter there are 2 principles of interaction with the "outside" world:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platform channels</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foreign function interface</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Platform Channels allow you to interact with the native runtime / API through a messaging system. From an architectural point of view, this can be seen as follows. Visually, Flutter is just a Canvas, which is stretched to full screen in the only Activity / UIViewController of your native application. This is exactly the same approach that I use game developers (game engines). Those. You can open the iOS / Android project of your application and add any other functionality to Swift / Kotlin / etc. The problem is that the native runtime and the Dart VM will not know anything about each other (in addition to the fact that the native runtime will know that the application has Canvas and something is displayed there). Further, if you, for example, open the MainActivity.kt file of your Android project, you will see something like this:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span>: <span class="hljs-type">FlutterActivity</span></span>() {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<font></font>
    GeneratedPluginRegistrant.registerWith(<span class="hljs-keyword">this</span>)<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Have you noticed that your Activity inherits from FlutterActivity? This gives us the opportunity to configure the mechanism for sending messages directly to Flutter / DartVM. To do this, we need to override the </font><i><font style="vertical-align: inherit;">configureFlutterEngine</font></i><font style="vertical-align: inherit;"> method</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and it will determine the name of the called method and the name of the channel for sending asynchronous messages. All. This makes it possible to write us any native code and call any native API! At the same time, there are already a large number of plugins (packages) that save you from writing native code, you can use only Dart. This is just wonderful! You write the UI separately and once for any platform, use DartVM to work with UI, I / O and just as a computing component, use plugins that implement native features and which cover 99% of all functionality. And if this is not enough, you write natively and communicate through the message mechanism. Story.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second mechanism is a Foreign function interface or FFI. This is a fairly common term for iterope mechanism with other languages, mainly C. In the .Net world, this mechanism is called P / Invoke, for the JVM it is JNI. In short, this is the ability to interact with libraries written in C / C ++ / etc. At the time of the .Net Framework, for example, there was no software written in C # and the vast majority of software was written in C / C ++, so a mechanism was needed to work with these libraries. The same applies to JVM, Python, you name it. FFI is one way or another used in all cross-platform mobile frameworks. More recently, DartVM has also started supporting FFI for interoperation with C and JavaScript! While this feature is in a beta branch, but is already available for use (at your own peril and risk).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, Flutter and DartVM cover 100% of the possibilities on native platforms, and even more.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Easy to learn and quite expressive language</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I admit honestly, while Dart for me remains not the best language in the world. There is no strict type system, there are no functional buns, such as Pattern Matching or Immutability features (like they will be delivered soon), etc. About the type system, Dart was originally conceived as a ‚Äúwithout a typical‚Äù language, ala JS, but for normal support for AOT compilation it was nevertheless necessary to bring the type system to a more strict, although not completely, I would say. It still annoys me to work with method signatures, namely with arguments. All these brackets, </font></font><code>@required</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for some reason </font><font style="vertical-align: inherit;">, are enraging </font><font style="vertical-align: inherit;">. But dart is a very easy-to-learn language. In syntax, this is a cross between Java and JS for me. Dart forgives a lot, like JS. In general, this is a fairly easy to learn language, I have not experienced any significant problems.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rantime that fits well in the frontend development paradigm</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's talk about Dart VM. </font><font style="vertical-align: inherit;">In general, Dart VM includes a lot of things, from GC to Profiler and Observatory. </font><font style="vertical-align: inherit;">Here I want to talk only about GC and conditional runtime. </font><font style="vertical-align: inherit;">You can familiarize yourself with how the runtime works and what it consists of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">I am not an expert in this field, but for myself, I noted some of the advantages of Dart VM, which I will try to describe. </font><font style="vertical-align: inherit;">Prior to this, I would like to note that Dart and the corresponding VM were initially developed as a replacement for JS, which, as it were, hints at the focus on frontend development. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isolates</font></font></b><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_s/_n/kl/_s_nklwnaygqk8dey70z0yerdco.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dart VM has the Isolate concept. Isolate is a combination of one main thread that runs directly on the Dart code and the isolated heap, where the objects from the Dart code are actually allocated. This is a simplified structure. Isolate also has auxiliary / system threads, there are OS threads that can enter and exit Isolate, etc. The stack is also present in Isolate but you, as a user, do not operate on it. The main thing that needs to be emphasized here is that if you look at one Isolate, then this is a single-thread environment. By default, Flutter uses one default Isolate. Doesn‚Äôt resemble anything? Yes this is JS environment. Just like in JS, Dart programmers cannot work with multithreading. Someone might think that this is a mess, simplification and infringement of the rights of real developers, but I think that when working with UI,when you operate with a conditional DOM (and do not draw polygons on the screen), you don‚Äôt need to, it‚Äôs dangerous to operate with several threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here, of course, I was cunning, if you really want to, then you can use the separately launched Isolate to perform parallel tasks (hello WebWorkers) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you can see in detail how you can work with additional Isolate in Flutter. In general, Isolates, as the name implies, do not know anything about each other, do not keep links to each other and communicate through a message system.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to the single-thread approach, the fact that a separate heap is allocated for each Isolate without the ability to manipulate the stack of this thread is, in my opinion, a very good approach. If you are writing a server application that manipulates a huge number of lines, for example, and these lines are stored in a heap, where they appear and disappear at a tremendous speed, while fragmenting memory and adding GC jobs, any way of transferring these lines, or at least part, from heaps on the stack will save resources and improve performance. An example is so-so, but you understand me. But when working with UI, where there is possibly a sufficient number of UI elements that can have a short lifetime (for example, animation), but only one client and the amount of processed data is negligible compared to the server application,the ability to directly work with the stack is simply unnecessary. I'm not talking about boxing / unboxing, which could be in this case and which is absolutely pointless. And it should be noted that objects in Dart VM are allocated quite often. Even to output the double amount from the Dart method, the VM separately allocates a piece on the heap. How does the GC handle this load? Let's get a look.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Young Space Scavenger (and Parallel Mark Sweep)</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
First, like all GCs, the GC in the Dart VM has generations. Also, the GC in the Dart VM can be divided according to the principle of work into 2 components: Young Space Scavenger and Parallel Mark Sweep. I will not dwell on the last principle, this is a fairly popular principle of memory cleaning, which is implemented almost everywhere and does not give Flutter a special advantage. We are interested in the first. The working principle of Young Space Scavenger is well illustrated in the following picture:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d3/yq/ik/d3yqikji__3j3f9zehdkrm4-t0a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It clearly demonstrates the advantages of this approach. Young Space Scavenger works for the newest objects in memory, we can say that for the first / zero generation of objects. Often, and this is characteristic of the Flutter / Dart VM, most new objects have a short life. In a situation where you allocate a lot of objects that do not live long, the memory can be very fragmented. In this case, you will have to pay either memory or processor time to fix the problem (although you should not fix the problem with such methods). Young Space Scavenger solves this problem. If you look at the picture above, then there really is no 6 step, you do not need to clear the first memory chunk, by default we think that this chunk is empty after copying objects to the second. Well, when copying surviving objects into the second chunk,we naturally set them one by one without creating fragmentation. All this allows VM to allocate a lot of new objects at a rather low price.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idle Time GC</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
As you understand, the Flutter and Dart VM teams work closely together and the result of this cooperation can be considered the Idle Time GC. As the name implies, this is garbage collection at the moment when nothing happens. In the context of Flutter, at the moment when the application visually does not change anything. There is no animation, scrolling or user interaction. At these moments, Flutter sends messages to the Dart VM that now, in principle, is a good time to start garbage collection. Next, the garbage collector decides whether he should start his work. Of course, garbage collection in this regard occurs for older objects that are managed through the Parallel Mark Sweep, which in itself is a rather expensive process and Idle Time GC is a very useful mechanism in this regard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are other things like</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sliding Compaction</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compressed Pointers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The first is the memory defragmentation mechanism after running Parallel Mark Sweep. </font><font style="vertical-align: inherit;">This is also an expensive process and only works if there is Idle Time. </font><font style="vertical-align: inherit;">The second approach, Compressed Pointers, compresses 64-bit pointers into 32 bits, which saves memory (I think this is much more useful in a server environment than in a mobile one).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summary</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you read up to this line, then, firstly, congratulations, and secondly, I have to say that I have no experience writing articles, so I don‚Äôt quite understand if I managed to get my point across. And the idea is simple, when you write a mobile application with Flutter, it turns out native. And in the form of a bonus you get a very decent application development speed. Hot Reload / Restart is simply an indispensable thing in Frontend development. Can you imagine some typesetter who would need to build / compile the entire project for each browser, for example, with every color change of a button? Of course not. In general, Hot Reload / Restart deserves a separate article. But I was distracted.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My experience with Flutter tells me that this framework will be dominant in the near future. </font><font style="vertical-align: inherit;">Periodically, I go through interviews for a Flutter developer position and in half the cases, companies that are looking for a Flutter developer actually have a staff of mobile native developers. </font><font style="vertical-align: inherit;">They just tried Flutter on interior / side projects, were satisfied / delighted and were slowly moving to Flutter. </font><font style="vertical-align: inherit;">This is a real victory, it seems to me. </font><font style="vertical-align: inherit;">What can not be said about Xamarin, unfortunately. </font><font style="vertical-align: inherit;">Quite often, the decision to choose Xamarin is simply due to the fact that the rest of the stack is written in .Net, and this is a slippery slope. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To summarize, I want to say that if you are thinking about which side to approach when developing your new mobile application, look at Flutter.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en501328/index.html">Introducing Visual Studio Codespaces: Cloud Development, Wherever You Are</a></li>
<li><a href="../en501330/index.html">Microservices in C ++. Fiction or reality?</a></li>
<li><a href="../en501332/index.html">Meetings are easy. Three daily practice tips</a></li>
<li><a href="../en501336/index.html">FOSS News No. 15 - a review of free and open source news for May 4-10, 2020</a></li>
<li><a href="../en501338/index.html">Inside the Python virtual machine. Part 1</a></li>
<li><a href="../en501342/index.html">Microsoft Online Certification - Field Notes</a></li>
<li><a href="../en501344/index.html">Supply ventilation combined with duct air conditioning (part 1 - electric)</a></li>
<li><a href="../en501346/index.html">Overview of the mechanical keyboard Vortex Core RGB</a></li>
<li><a href="../en501352/index.html">Kafka strikes back</a></li>
<li><a href="../en501354/index.html">A new look at code style</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>