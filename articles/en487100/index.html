<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥘 👋🏼 🚩 State-of-the-art immutable data structures 👴 👎🏾 👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For years, experts in C ++ have been discussing the semantics of values, immutability, and resource sharing through communication. About a new world w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>State-of-the-art immutable data structures</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/487100/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For years, experts in C ++ have been discussing the semantics of values, immutability, and resource sharing through communication. </font><font style="vertical-align: inherit;">About a new world without mutexes and races, without Command and Observer patterns. </font><font style="vertical-align: inherit;">In fact, everything is not so simple. </font><font style="vertical-align: inherit;">The main problem is still in our data structures.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/pu/18/6opu18ei6gi5dbo8dvcsgopyebq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Immutable data structures do not change their values. To do something with them, you need to create new values. The old values ​​remain in the same place, so they can be read from different streams without problems and locks. As a result, resources can be shared more rationally and orderly, because old and new values ​​can use common data. Thanks to this, they are much faster to compare with each other and compactly store the history of operations with the possibility of cancellation. All this fits perfectly on multi-threaded and interactive systems: such data structures simplify the architecture of desktop applications and allow services to scale better. Immutable structures are the secret to the success of Clojure and Scala, and even the JavaScript community now takes advantage of them, because they have the Immutable.js library,written in the bowels of the company Facebook.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Under the cut - video and translation of the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> report </font><font style="vertical-align: inherit;">from the C ++ Russia 2019 Moscow conference. </font><font style="vertical-align: inherit;">Juan talks about </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a library of immutable structures for C ++. </font><font style="vertical-align: inherit;">In the post:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">architectural advantages of immunity;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creation of an effective persistent vector type based on RRB trees;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analysis of architecture on the example of a simple text editor.</font></font></li>
</ul><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/dbFfpTp3EhA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The tragedy of value-based architecture</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To understand the importance of immutable data structures, we discuss the semantics of values. This is a very important feature of C ++, I consider it one of the main advantages of this language. For all this, it is very difficult to use the semantics of values ​​as we would like. I believe that this is the tragedy of value-based architecture, and the road to this tragedy is paved with good intentions. Suppose we need to write interactive software based on a data model with a representation of a user-editable document. When architecture based on the values at the heart of this model uses simple and convenient types of values that already exist in the language: </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>tuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Application logic is created from functions that take documents by value and return a new version of a document by value. This document may change inside the function (as it happens below), but the semantics of values ​​in C ++, applied to the argument by value and the return type by value, ensure that there are no side effects. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/7e/0y/fh7e0ybdwuqnh3iona30quev4ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This feature is very easy to analyze and test. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/5c/4x/cb5c4xq-hps1x76mn-fmweshklu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since we are working with values, we will try to implement the undo of the action. This can be difficult, but with our approach it is a trivial task: we have </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with different states various copies of the document.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d-/vh/nd/d-vhndh9j8leugdcjoyf3b4yhqq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose we also have a UI, and to ensure its responsiveness, the mapping of the UI needs to be done in a separate thread. The document is sent to another stream by message, and the interaction also takes place on the basis of messages, and not through the sharing of state using </font></font><code>mutexes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When the copy is received by the second stream, there you can perform all the necessary operations. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/xx/kc/toxxkcwck44iayev1hywf-wqllk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saving a document to disk is often very slow, especially if the document is large. Therefore, using </font></font><code>std::async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this operation is performed asynchronously. We use a lambda, put an equal sign inside it to have a copy, and now you can save without other primitive types of synchronization.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ey/jj/veeyjjijubbrc49-ghusxnuft4e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further, suppose we also have a sound control flow. As I said, I worked a lot with music software, and sound is another representation of our document, it must be in a separate stream. Therefore, a copy of the document is also required for this stream. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, we got a very beautiful, but not too realistic scheme. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dj/w2/hu/djw2hu7q55lbi2nmgmwok1i_cb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It constantly has to copy documents, the action history for cancellation takes gigabytes, and for each rendering of the UI you need to make a deep copy of the document. In general, all interactions are too costly.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uq/sv/8-/uqsv8-sx3hphtcm9wvozi1z83fs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is the C ++ developer doing in this situation? Instead of accepting a document by value, the application logic now accepts a link to the document and updates it if necessary. In this case, you do not need to return anything. But now we are not dealing with values, but with objects and locations. This creates new problems: if there is a link to the state with shared access, you need it </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is extremely costly, so there will be some representation of our UI in the form of an extremely complex tree from various Widgets.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All of these elements should receive updates when a document changes, so some queuing mechanism is needed for change signals. Further, the history of the document is no longer a set of states; it will be an implementation of the Team pattern. The operation must be implemented twice, in one direction and in the other, and make sure that everything is symmetrical. Saving in a separate thread is already too difficult, so this will have to be abandoned. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dl/lr/sj/dllrsjhkvqxxckjx1r69lflqck4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Users are already used to the hourglass picture, so it's okay if they wait a bit. Another thing is scary - the pasta monster now rules our code.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At what point did everything go downhill? </font><font style="vertical-align: inherit;">We designed our code very well, and then we had to compromise due to copying. </font><font style="vertical-align: inherit;">But in C ++, copying is required to pass by value only for mutable data. </font><font style="vertical-align: inherit;">If the object is immutable, then the assignment operator can be implemented so that it copies only the pointer to the internal representation and nothing more.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider a data structure that could help us. </font><font style="vertical-align: inherit;">In the vector below, all methods are marked as </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so it is immutable. </font><font style="vertical-align: inherit;">At execution </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the vector does not update; instead, a new vector is returned, to which the transferred data is added. </font><font style="vertical-align: inherit;">Unfortunately, we cannot use square brackets with this approach because of how they are defined. </font><font style="vertical-align: inherit;">Instead, you can use the function</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which returns a new version with an updated item. Our data structure now has a property that is called persistence in functional programming. It means not that we save this data structure to the hard drive, but the fact that when it is updated, the old content is not deleted - instead, a new fork of our world is created, that is, the structure. Thanks to this, we can compare past values ​​with present - this is done with the help of two </font></font><code>assert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-keyword">const</span> auto v1 = v0.push_back(<span class="hljs-number">15</span>);
<span class="hljs-keyword">const</span> auto v2 = v1.push_back(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> auto v3 = v2.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">42</span>);<font></font>
<font></font>
assert(v2.size() == v0.size() + <span class="hljs-number">2</span>);<font></font>
assert(v3[<span class="hljs-number">0</span>] - v1[<span class="hljs-number">0</span>] == <span class="hljs-number">27</span>);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Changes can now be directly checked, they are no longer hidden properties of the data structure. This feature is especially valuable in interactive systems where we constantly have to change data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another important property is structural sharing. Now we are not copying all the data for each new version of the data structure. Even with </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not all data is copied, but only a small part of it. All our forks have common access to a compact view, which is proportional to the number of changes, not the number of copies. It also follows that the comparison is very fast: if everything is stored in one memory block, in one pointer, then you can simply compare the pointers and not examine the elements that are inside them, if they are equal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since such a vector, it seems to me, is extremely useful, I implemented it in a separate library: this is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a library of immutable structures, an open source project.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When writing it, I wanted its use to be familiar to C ++ developers. </font><font style="vertical-align: inherit;">There are many libraries that implement the concepts of functional programming in C ++, but it gives the impression that the developers write for Haskell, and not for C ++. </font><font style="vertical-align: inherit;">This creates inconvenience. </font><font style="vertical-align: inherit;">In addition, I achieved good performance. </font><font style="vertical-align: inherit;">People use C ++ when available resources are limited. </font><font style="vertical-align: inherit;">Finally, I wanted the library to be customizable. </font><font style="vertical-align: inherit;">This requirement is related to the performance requirement.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In search of a magic vector</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the second part of the report, we will consider how this immutable vector is structured. The easiest way to understand the principles of such a data structure is by starting with a regular list. If you are a little familiar with functional programming (using Lisp or Haskell as an example), you know that lists are the most common immutable data structures. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ou/d6/rnoud6a8vaqpet2jg-n18be85fk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To begin, let us assume that we have a list with a single node </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When adding new elements to the top of the list, new nodes are created, each of which has a pointer to an existing node. Therefore, in the example on the slide, we have not three copies of one list, but three elements in memory, that is, </font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">they </font></font><code>v0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicate different elements. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/nf/bh/bmnfbhtdmbu_kdm_xlpuxleld2w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can also create a fork of reality, that is, create a new list that has the same ending, but a different beginning.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Such data structures have been studied for a long time: Chris Okasaki wrote the fundamental work of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Purely Functional Data Structures</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In addition, the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finger Tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> data structure proposed by Ralf Hinze and Ross Paterson is very interesting </font><font style="vertical-align: inherit;">. But for C ++, such data structures do not work well. They use small nodes, and we know that in C ++ small nodes mean a lack of caching efficiency. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, they often rely on properties that C ++ does not have, such as laziness. Therefore, the work of Phil Bagwell on immutable data structures is much more useful for us - a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> written in the early 2000s, as well as the work of Rich Hickey - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, author of Clojure. Rich Hickey created a list, which is actually not a list, but based on modern data structures: vectors and hash maps. These data structures have caching efficiency and interact well with modern processors, for which it is undesirable to work with small nodes. Such structures can be used in C ++. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How to build an immune vector? At the heart of any structure, even remotely resembling a vector, there must be an array. But the array does not have structural sharing. To change any element of the array, without losing the persistence property, you must copy the entire array. In order not to do this, the array can be split into separate pieces.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, when updating a vector element, we need to copy only one piece, and not the entire vector. But such pieces themselves are not a data structure; they must be combined in one way or another. Put them in another array. Once again, the problem arises that the array can be very large, and then copying it again will take too much time.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We divide this array into pieces, place them again in a separate array, and repeat this procedure until there is only one root array. The resulting structure is called a residual tree. This tree is described by the constant M = 2B, that is, the branching factor. This branch indicator should be a power of two, and we will very soon find out why. In the example on the slide, blocks of four characters are used, but in practice, blocks of 32 characters are used. There are experiments with which you can find the optimal block size for a particular architecture. This allows you to achieve the best ratio of structural shared access to access time: the lower the tree, the less access time.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reading this, developers writing in C ++ probably think: but any tree-based structures are very slow! Trees grow with an increase in the number of elements in them, and because of this, access times are degraded. That is why programmers prefer </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, rather than </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. I hasten to reassure you: our tree grows very slowly. A vector containing all possible values ​​of a 32-bit int is only 7 levels high. It can be experimentally shown that with this data size, the ratio of the cache to the load volume significantly affects performance than the depth of the tree. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see how an access to an element of a tree is performed. Suppose you need to turn to element 17. We take a binary representation of the index and divide it into groups the size of a branching factor.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c1/gz/o1/c1gzo1qqm9pycpehqerzzkvwvwm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In each group, we use the corresponding binary value and thus go down the tree. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, suppose we need to make a change in this data structure, that is, execute the method </font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/l8/xi/3y/l8xi3yorosfghnwt9gmcijtk83a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To do this, first you need to copy the block in which the element is located, and then copy each internal node on the way to the element. On the one hand, quite a lot of data has to be copied, but at the same time a significant part of this data is common, this compensates for their volume. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By the way, there is a much older data structure that is very similar to the one I described. These are memory pages with a page table tree. Her management is also carried out using a call </font></font><code>fork</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's try to improve our data structure. Suppose we need to connect two vectors. The data structure described so far has the same limitations </font></font><code>std::vector:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as it has empty cells in its rightmost part. Since the structure is perfectly balanced, these empty cells cannot be in the middle of the tree. Therefore, if there is a second vector that we want to combine with the first, we will need to copy the elements to empty cells, which will create empty cells in the second vector, and in the end we will have to copy the whole second vector. Such an operation has computational complexity O (n), where n is the size of the second vector.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will try to achieve a better result. There is a modified version of our data structure called relaxed radix balanced tree. In this structure, nodes that are not on the left-most path may have empty cells. Therefore, in such incomplete (or relaxed) nodes, it is necessary to calculate the size of the subtree. Now you can perform a complex but logarithmic join operation. This operation of constant time complexity is O (log (32)). Since the trees are shallow, the access time is constant, albeit relatively long. Due to the fact that we have such a union operation, a relaxed version of this data structure is called confluent: in addition to being persistent, and you can fork it, two such structures can be combined into one.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qr/rj/hz/qrrjhzfbr-22n0cdr-vvhke1pvq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the example that we have worked with so far, the data structure is very neat, but in practice, the implementations in Clojure and other functional languages ​​look different. They create containers for each value, that is, each element in the vector is in a separate cell, and leaf nodes contain pointers to these elements. But this approach is extremely inefficient, in C ++ usually do not put every value in a container. Therefore, it would be better if these elements are located in nodes directly. Then another problem arises: different elements have different sizes. If the element is the same size as the pointer, our structure will look like the one shown below:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/78/s4/_k/78s4_kqqdc_fi8_ydkopktou0m4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But if the elements are large, then the data structure loses the properties we measured (access time O (log (32) ()), because copying one of the sheets now takes longer. Therefore, I changed this data structure so that with increasing size the number of elements contained in it decreased the number of these elements in the leaf nodes.On the contrary, if the elements are small, they can now fit more.The new version of the tree is called embedding radix balanced tree.It is described not by one constant, but by two: one of them describes internal nodes, and the second - leafy .. Implementation of the tree in C ++ can calculate the optimal size of the leaf element depending on the size of the pointers and the elements themselves.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our tree is already working quite well, but it can still be improved. Take a look at a function similar to a function </font></font><code>iota</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = v.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It takes an input </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, executes </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the end of the vector for each integer between </font></font><code>first</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>last</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and returns what happened. Everything is in order with the correctness of this function, but it works inefficiently. Each call </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copies the leftmost block unnecessarily: the next call pushes another element and the copy is repeated again, and the data copied by the previous method is deleted. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can try another implementation of this function, in which we abandon persistence within the function. Can be used </font></font><code>transient vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a mutable API that is compatible with the regular API </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Within such a function, each call </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changes the data structure.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    auto t = v.transient();<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        t.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> t.persistent();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This implementation is more efficient, and it allows you to reuse new elements on the right path. At the end of the function, a call </font></font><code>.persistent()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is made that returns immutable </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Possible side effects remain invisible from outside the function. The original one </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was and remains immutable, only the data created inside the function is changed. As I said, an important advantage of this approach is that you can use </font></font><code>std::back_inserter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">standard algorithms that require mutable APIs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider another example.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        <font></font>
            .push_back(<span class="hljs-string">'i'</span>)        <font></font>
            .push_back(<span class="hljs-string">'!'</span>);       <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The function does not accept and returns </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but a call chain is executed inside </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Here, as in the previous example, unnecessary copying inside the call may occur </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Note that the first value that is executed </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the named value, and the rest is r-value, that is, anonymous links. If you use reference counting, the method </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can refer to reference counters for nodes for which memory is allocated in the tree. And in the case of r-value, if the number of links is one, it becomes clear that no other part of the program accesses these nodes. Here the performance is exactly the same as in the case with </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        ⟵ named <span class="hljs-keyword">value</span>: v<font></font>
            .push_back(<span class="hljs-string">'i'</span>)        ⟵ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span>
            .push_back(<span class="hljs-string">'!'</span>);       ⟵ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further, to help the compiler, we can execute it </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, since it </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is not used anywhere else in the function. We had an important advantage, which was not in the </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variant: if we pass the returned value of another say_hi to the say_hi function, then there will be no extra copies. In the case of c, </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there are boundaries at which excess copying can occur. In other words, we have a persistent, immutable data structure, the performance of which depends on the actual amount of shared access in runtime. If there is no sharing, then the performance will be the same as that of a mutable data structure. This is an extremely important property. The example that I already showed you above can be rewritten with a method </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = std::move(v).push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So far we have talked about vectors, and in addition to them there are also hash maps. They are dedicated to a very useful report by Phil Nash: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The holy grail. A hash array mapped trie for C ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It describes hash tables implemented based on the same principles that I just talked about. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I am sure many of you have doubts about the performance of such structures. Do they work quickly in practice? I have done many tests, and in short my answer is yes. If you want to learn more about the test results, they are published in my article for the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">International Conference of Functional Programming 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Now, I think, it is better to discuss not absolute values, but the effect that this data structure has on the system as a whole. </font><font style="vertical-align: inherit;">Of course, updating our vector is slower because you need to copy several data blocks and allocate memory for other data. </font><font style="vertical-align: inherit;">But bypassing our vector is performed at almost the same speed as a normal one. </font><font style="vertical-align: inherit;">It was very important for me to achieve this, since reading data is performed much more often than changing it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, due to the slower update, there is no need to copy anything, only the data structure is copied. </font><font style="vertical-align: inherit;">Therefore, the time spent on updating the vector is, as it were, amortized for all copies performed in the system. </font><font style="vertical-align: inherit;">Therefore, if you apply this data structure in an architecture similar to the one that I described at the beginning of the report, performance will increase significantly.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ewig</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will not be unfounded and demonstrate my data structure using an example. </font><font style="vertical-align: inherit;">I wrote a small text editor. </font><font style="vertical-align: inherit;">This is an interactive tool called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in which documents are represented by immutable vectors. </font><font style="vertical-align: inherit;">I have a copy of the entire Wikipedia in Esperanto saved on my disk, it weighs 1 gigabyte (at first I wanted to download the English version, but it is too big). </font><font style="vertical-align: inherit;">Whatever text editor you use, I am sure that he will not like this file. </font><font style="vertical-align: inherit;">And when you download this file in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , you can immediately edit it, because the download is asynchronous. </font><font style="vertical-align: inherit;">File navigation works, nothing hangs, no </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no synchronization. </font><font style="vertical-align: inherit;">As you can see, the downloaded file takes 20 million lines of code.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before considering the most important properties of this tool, let's pay attention to a funny detail. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eb/kt/eq/ebkteqmtvnbkncoxlb91z0g6qpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the beginning of the line, highlighted in white at the bottom of the image, you see two hyphens. This UI is most likely familiar to emacs users; hyphens there mean that the document has not been modified in any way. If you make any changes, then asterisks are displayed instead of hyphens. But, unlike other editors, if you </font><font style="vertical-align: inherit;">erase these changes </font><font style="vertical-align: inherit;">in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (do not undo it, just delete it), then hyphens will be displayed instead of asterisks because </font><font style="vertical-align: inherit;">all previous versions of the text are saved </font><font style="vertical-align: inherit;">in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Thanks to this, a special flag is not needed to show whether the document has been changed: the presence of changes is determined by comparison with the original document.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider another interesting property of the tool: copy the entire text and paste it a couple of times in the middle of the existing text. </font><font style="vertical-align: inherit;">As you can see, this happens instantly. </font><font style="vertical-align: inherit;">Joining vectors here is a logarithmic operation, and the logarithm of several millions is not such a long operation. </font><font style="vertical-align: inherit;">If you try to save this huge document to your hard drive, it will take much longer, because the text is no longer presented as a vector obtained from the previous version of this vector. </font><font style="vertical-align: inherit;">When saving to disk, serialization occurs, so persistence is lost.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Return to value-based architecture</font></font></h2><br>
<img src="https://habrastorage.org/webt/wf/o7/b7/wfo7b78ha0wnqjzcjjeky_esh0g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with how you can’t return to this architecture: using the usual Java-style Controller, Model and View, which are most often used for interactive applications in C ++. There is nothing wrong with them, but they are not suitable for our problem. On the one hand, the Model-View-Controller pattern allows for separation of tasks, but on the other, each of these elements is an object, both from an object-oriented point of view and from the point of view of C ++, that is, these are memory areas with mutable condition. View knows about Model; which is much worse - Model indirectly knows about View, because there is almost certainly a callback through which the View is notified when the Model changes. Even with the best implementation of object-oriented principles, we get a lot of mutual dependencies.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/07/so/xq/07soxqkandixucwhzk6mvfr1e84.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As the application grows and new Model, Controller, and View are added, a situation arises when, to change a segment of the program, you need to know about all parts associated with it, about all View that receive notification through </font></font><code>callback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, etc. As a result, for all the familiar pasta monster begins to peer through these dependencies. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Is another architecture possible? There is an alternative approach to the Model-View-Controller pattern called “Unidirectional Data Flow Architecture”. This concept was not invented by me, it is used quite often in web development. On Facebook, this is called the Flux architecture, but in C ++, it is not yet applied.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/z6/p2/tyz6p2hutpnjwusi0edhbcwvo0s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elements of such an architecture are already familiar to us: Action, Model and View, but the meaning of blocks and arrows is different. Blocks are values, not objects and not regions with mutable states. This applies even to View. Further, arrows are not links, because without objects there can be no links. Here the arrows are functions. Between Action and Model, there is an update function that accepts the current Model, that is, the current state of the world, and Action, which is a representation of an event, for example, a mouse click, or an event of another level of abstraction, for example, an element or symbol is inserted into a document. The update function updates the document and returns the new state of the world. Model connects to the View function render, which takes the Model and returns the view. This requires a framework in which View can be represented as values.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In web development, React does this, but in C ++ there is nothing like it yet, although who knows, if there are people who want to pay me to write something like this, it may soon appear. In the meantime, you can use the Immediate mode API, in which the draw function allows you to create a value as a side effect. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, the View should have a mechanism that allows the user or other event sources to send Action. There is an easy way to implement this, it is presented below:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">application <span class="hljs-title">update</span>(<span class="hljs-params">application state, action ev</span>)</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fname</span>)</span><font></font>
{<font></font>
    auto term  = terminal{};<font></font>
    auto state = application{load_buffer(fname), key_map_emacs};<font></font>
    <span class="hljs-keyword">while</span> (!state.done) {<font></font>
        draw(state);<font></font>
        auto act = term.next();<font></font>
        state = update(state, act);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With the exception of saving and loading asynchronously, this is the code that is used in the editor just presented. There is an object here </font></font><code>terminal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that allows you to read and write from the command line. Further, </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is the value of Model, it stores the entire state of the application. As you can see at the top of the screen, there is a function that returns a new version </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The cycle inside the function is executed until the application needs to close, that is, until </font></font><code>!state.done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In the loop, a new state is drawn, then the next event is requested. Finally, the state is stored in a local variable </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the loop starts again. This code has a very important advantage: only one mutable variable exists throughout the execution of the program, it is an object </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Clojure developers call this single-atom architecture: there is one single point across the entire application through which all changes are made. </font><font style="vertical-align: inherit;">The application logic does not participate in updating this point in any way; this makes a specially designed cycle for this. </font><font style="vertical-align: inherit;">Thanks to this, the application logic consists entirely of pure functions, like functions </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With this approach to writing applications, the way of thinking about software is changing. </font><font style="vertical-align: inherit;">Work now begins not with the UML diagram of interfaces and operations, but with the data itself. </font><font style="vertical-align: inherit;">There are some similarities with data-oriented design. </font><font style="vertical-align: inherit;">True, data-oriented design is usually used to obtain maximum performance, here, in addition to speed, we strive for simplicity and correctness. </font><font style="vertical-align: inherit;">The emphasis is slightly different, but there are important similarities in the methodology.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> index = <span class="hljs-keyword">int</span>;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> coord<font></font>
{<font></font>
    index row = {};<font></font>
    index col = {};<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">using</span> line = immer::flex_vector&lt;<span class="hljs-keyword">char</span>&gt;;
<span class="hljs-keyword">using</span> text = immer::flex_vector&lt;line&gt;;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> file<font></font>
{<font></font>
    immer::box&lt;std::<span class="hljs-keyword">string</span>&gt; name;<font></font>
    text content;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> snapshot<font></font>
{<font></font>
    text content;<font></font>
    coord cursor;<font></font>
};<font></font>
 <font></font>
<span class="hljs-keyword">struct</span> buffer<font></font>
{<font></font>
    file <span class="hljs-keyword">from</span>;<font></font>
    text content;<font></font>
    coord cursor;<font></font>
    coord scroll;<font></font>
    std::optional&lt;coord&gt; selection_start;<font></font>
    immer::vector&lt;snapshot&gt; history;<font></font>
    std::optional&lt;std::size_t&gt; history_pos;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> application<font></font>
{<font></font>
    buffer current;<font></font>
    key_map keys;<font></font>
    key_seq input;<font></font>
    immer::vector&lt;text&gt; clipboard;<font></font>
    immer::vector&lt;message&gt; messages;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> action { key_code key; coord size; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Above are the main data types of our application. The main body of the application consists of </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is flex_vector, and flex_vector is </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one for which you can perform a join operation. Next </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the vector in which it is stored </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As you can see, this is a very simple representation of the text. </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stored with the help </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of which has a name, that is, an address in the file system, and actually </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used another type, a simple but very useful: </font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is a single element container. It allows you to put in a heap and move an object, copying which may be too resource-intensive. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another important type: </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Based on this type, a cancel function is active. It contains a document (in the form</font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and cursor position (coord). This allows you to return the cursor to the position in which it was during editing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next type is </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is a term from vim and emacs, as open documents are called there. In </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there is a file from which the text was downloaded, as well as the content of the text - this allows you to check for changes in the document. To highlight part of the text, there is an optional variable </font></font><code>selection_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicating the beginning of the selection. The vector from </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the story of the text. Note that we do not use the Team pattern; history consists only of states. Finally, if the cancellation has just been completed, we need a position index in the state history </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next type: </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It contains an open document (buffer), </font></font><code>key_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>key_seq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for keyboard shortcuts, as well as a vector from </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the clipboard and another vector for messages displayed at the bottom of the screen. </font><font style="vertical-align: inherit;">So far, in the debut version of the application there will be only one thread and one type of action that takes input </font></font><code>key_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>coord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most likely, many of you are already thinking about how to implement these operations. </font><font style="vertical-align: inherit;">If taken by value and returned by value, then in most cases the operations are quite simple. </font><font style="vertical-align: inherit;">The code of my text editor is posted on </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so you can see how it actually looks. </font><font style="vertical-align: inherit;">Now I will dwell in detail only on the code that implements the undo function.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Correctly writing a cancellation without the appropriate infrastructure is not so simple. In my editor, I implemented it along the lines of emacs, so first a couple of words about its basic principles. The return command is missing here, and thanks to this, you can not lose your job. If a return is necessary, any change is made to the text, and then all cancellation actions become again part of the cancellation history.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/4z/j_/s04zj_sia6mzw8reywkbznlhlem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This principle is depicted above. The red rhombus here shows a position in history: if a cancellation has just not been completed, the red rhombus is always at the very end. If you cancel, the rhombus will move one state back, but at the same time another state will be added to the end of the queue - the same as the user currently sees (S3). If you cancel again and return to state S2, state S2 is added to the end of the queue. If now the user makes some kind of change, it will be added to the end of the queue as a new state of S5, and a rhombus will be moved to it. Now, when undoing past actions, the previous undo actions will be scrolled first. To implement such a cancellation system, the following code is enough:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">buffer <span class="hljs-title">record</span>(<span class="hljs-params">buffer before, buffer after</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (before.content != after.content) {<font></font>
        after.history = after.history.push_back({before.content, before.cursor});<font></font>
        <span class="hljs-keyword">if</span> (before.history_pos == after.history_pos)<font></font>
            after.history_pos = std::nullopt;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> after;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">buffer <span class="hljs-title">undo</span>(<span class="hljs-params">buffer buf</span>)</span><font></font>
{<font></font>
    auto idx = buf.history_pos.value_or(buf.history.size());<font></font>
    <span class="hljs-keyword">if</span> (idx &gt; <span class="hljs-number">0</span>) {<font></font>
        auto restore = buf.history[--idx];<font></font>
        buf.content = restore.content;<font></font>
        buf.cursor = restore.cursor;<font></font>
        buf.history_pos = idx;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> buf;<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are two actions, </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">performed during any operation. This is very convenient since we don’t need to know if any editing of the document has occurred. The function is transparent to the application logic. After any action, the function checks if the document has changed. If a change has occurred, the </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contents and cursor position for are </font><font style="vertical-align: inherit;">executed </font></font><code>history</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If the action did not lead to a change </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(that is, the input received is </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not caused by the cancel action), then </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a value is assigned </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If necessary </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we check </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If it has no meaning, we consider it to </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">be at the end of the story. If the cancellation history is not empty (i.e.</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not at the very beginning of the story), cancellation is performed. </font><font style="vertical-align: inherit;">The current content and cursor are replaced and changed </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The irrevocability of a cancel operation is achieved by a function </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is also called during the cancel operation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we have an operation </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that takes up 10 lines of code, and which without changes (or with minimal changes) can be used in almost any other application.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time travel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
About time travel. As we will see now, this is a topic related to cancellation. I will demonstrate the work of a framework that will add useful functionality to any application with a similar architecture. The framework here is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig-debug</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This version of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> includes some debugging features. Now from the browser you can open the debugger, in which you can examine the state of the application.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dy/ba/7x/dyba7xjocwgjjmqvayinlfwx0y4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We see that the last action was resizing, because I opened a new window, and my window manager automatically resized the already open window. Of course, for automatic serialization in JSON, I had to add annotation for struct from the special reflection library. But the rest of the system is quite universal, it can be connected to any similar application. Now in the browser you can see all the completed actions. Of course, there is an initial state that has no action. This is the state that was before the download. Moreover, by double-clicking I can return the application to its previous state. This is a very useful debugging tool that allows you to track the occurrence of a malfunction in the application.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you are interested, you can listen to my report on CPPCON 19, The most valuable values, there I will examine this debugger in detail. </font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/_oBx_NbLghY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, value-based architecture is discussed in more detail there. </font><font style="vertical-align: inherit;">In it, I also tell you how to implement actions and organize them hierarchically. </font><font style="vertical-align: inherit;">This ensures the modularity of the system and eliminates the need to keep everything in one big update function. </font><font style="vertical-align: inherit;">In addition, that report talks about asynchrony and multi-threaded file downloads. </font><font style="vertical-align: inherit;">There is another version of this report in which half an hour of additional material is Postmodern immutable data structures.</font></font><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/y_m0ce1rzRI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To summarize</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I think it's time to take stock. I will quote Andy Wingo - he is an excellent developer, he devoted a lot of time to V8 and compilers in general, finally, he is engaged in supporting Guile, implementing Scheme for GNU. Recently, he wrote on his Twitter: “To achieve a slight acceleration of the program, we measure every small change and leave only those that give a positive result. But we really achieve significant acceleration, blindly, investing a lot of effort, not having 100% confidence and guided only by intuition. What a strange dichotomy. ”</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It seems to me that C ++ developers are succeeding in the first genre. </font><font style="vertical-align: inherit;">Give us a closed system, and we, armed with our tools, will squeeze out everything that is possible from it. </font><font style="vertical-align: inherit;">But in the second genre we are not used to working. </font><font style="vertical-align: inherit;">Of course, the second approach is more risky, and often it leads to a waste of great effort. </font><font style="vertical-align: inherit;">On the other hand, by completely rewriting a program, it can often be made easier and faster. </font><font style="vertical-align: inherit;">I hope I managed to convince you to at least try this second approach.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente spoke at the C ++ Russia 2019 Moscow conference and talked about data structures that allow you to do interesting things. </font><font style="vertical-align: inherit;">Part of the magic of these structures lies in copy elision - this is what </font><font style="vertical-align: inherit;">Anton Polukhin and Roman Rusyaev </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will talk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about at the upcoming conference </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Follow the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">program</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> updates </font><font style="vertical-align: inherit;">on the site.</font></font></blockquote></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/en487100/">https://habr.com/ru/post/en487100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en487090/index.html">A new level of Windows optimization</a></li>
<li><a href="../en487092/index.html">Modeling business processes as part of an ERP system implementation project</a></li>
<li><a href="../en487094/index.html">Reprocessing events received from Kafka</a></li>
<li><a href="../en487096/index.html">Snippets. How to make the process of working with documentation easier</a></li>
<li><a href="../en487098/index.html">Draw with ants: procedural images using ant colony optimization algorithms</a></li>
<li><a href="../en487106/index.html">PVS-Studio analyzer RunUO check</a></li>
<li><a href="../en487108/index.html">Mobile Gamer Profile: MyTracker Research</a></li>
<li><a href="../en487110/index.html">Slurm SRE. A complete experiment with experts from Booking.com and Google.com</a></li>
<li><a href="../en487112/index.html">Edge of Madness: The Basic Circle</a></li>
<li><a href="../en487116/index.html">Why Discord Migrates from Go to Rust</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>