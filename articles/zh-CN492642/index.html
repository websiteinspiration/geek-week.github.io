<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🎤 🦖 👶🏻 使用动态微服务创建可扩展的弹性架构 ☝🏼 💼 🏔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="再一次问好。如您所知，OTUS在三月推出了有关建筑和设计模式的全新课程。在课程开始之前，已经为您翻译了许多有关使用动态微服务创建可伸缩且具有弹性的体系结构的材料。享受阅读！
 
 
 
 注解
 工业体系结构中最重要的趋势之一是微服务的使用，从而损害了正在逐渐消失的单片架构。借助云架构，微服务系统的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>使用动态微服务创建可扩展的弹性架构</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/492642/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再一次问好。</font><font style="vertical-align: inherit;">如您所知，OTUS在三月推出了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关建筑和设计模式的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全新课程</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在课程开始之前，已经为您翻译了许多有关使用动态微服务创建可伸缩且具有弹性的体系结构的材料。</font><font style="vertical-align: inherit;">享受阅读！</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/aw/ws/kg/awwskgrciq1fkykr-snivzihfds.png"><br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注解</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
工业体系结构中最重要的趋势之一是微服务的使用，从而损害了正在逐渐消失的单片架构。</font><font style="vertical-align: inherit;">借助云架构，微服务系统的部署更加高效，灵活且具有成本效益。</font><font style="vertical-align: inherit;">即便如此，许多公司已经开始从一种架构过渡到另一种架构，但这仍处于起步阶段。</font><font style="vertical-align: inherit;">在本文中，我们解决了由于需要开发基于微服务的可伸缩且容错系统而引起的问题。</font><font style="vertical-align: inherit;">在我们的实验中，我们考虑了两种类型的微服务，简单的和高级的，并表明所提出的解决方案基于其动态行为是创新的。</font></font><a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.简介</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
近几十年来，编程语言和计算机科学范式的历史一直以对分发和模块化的关注日益增强为特征，以提高代码的重用性和可靠性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
需要增加软件的数量和质量[1]。澄清与创新设计相关的各种分歧的关键因素之一是使用各种工具进行更高级软件系统的设计和开发是否足够[2]。最近，基于微服务的系统[3]证明了该过程的巨大成功，这是一种专注于各种应用程序（例如，针对残疾人）的体系结构范例[3]。在微服务的支持下，对架构和设计的兴趣正在增长。质量属性（例如，可伸缩性，性能和错误容忍度）或模型选择，例如“契约式服务” [5]或API网关，不再违反YAGNI原则（“您将不再需要它”-“遭受BDUF错误的折磨”（“预先进行大设计”-“首先进行大规模设计”）。本文旨在回答的主要研究问题是，我们如何才能开发一种基于微服务的系统，而该系统具有与整体系统相同的简单性？而且，从上一主题开始，我们如何创建一个环境，在客户端之间动态分配计算能力？我们的研究假设建议使用结合了分布式计算和微服务的客户端-服务器系统架构来解决这些问题。本文旨在回答的主要研究问题是，我们如何才能开发一种基于微服务的系统，而该系统具有与整体系统相同的简单性？而且，从上一主题开始，我们如何创建一个环境，在客户端之间动态分配计算能力？我们的研究假设建议使用结合了分布式计算和微服务的客户端-服务器系统架构来解决这些问题。本文旨在回答的主要研究问题是，我们如何才能开发一种基于微服务的系统，而该系统具有与整体系统相同的简单性？而且，从上一主题开始，我们如何创建一个环境，在客户端之间动态分配计算能力？我们的研究假设建议使用结合了分布式计算和微服务的客户端-服务器系统架构来解决这些问题。哪个可以在客户端之间动态分配计算能力？我们的研究假设建议使用结合了分布式计算和微服务的客户端-服务器系统架构来解决这些问题。哪个可以在客户端之间动态分配计算能力？我们的研究假设建议使用结合了分布式计算和微服务的客户端-服务器系统架构来解决这些问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该文档的结构如下：第2节简要介绍了当前文献，解释了微服务的重要性，其中包括Azure提供的两种众所周知的服务，第3节讨论了所建议的体系结构。</font><font style="vertical-align: inherit;">第四部分在最后一部分得出结论之前，讨论了对该系统的评估。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.微服务的文献综述</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
得益于云架构，微服务系统的部署更加高效，灵活且具有成本效益[6]。但是，齐默尔曼（Zimmermann）指出，微服务是一个敏感的话题，主要在学术界[7]和行业中正在研究。 “微服务”一词在2011年5月于意大利举行的软件架构师研讨会上首次进行了讨论，以描述与会人员认为这是许多人最近探索的一种通用架构风格。一年后，同一小组确认“微服务”一词是最合适的名称。实际上，开发微服务是为了解决整体应用程序或面向服务的体系结构中的问题，这些问题使正在开发的应用程序的可伸缩性，复杂性和依赖性变得复杂，以及使用轻量级的通信机制[8-9]。由于整体是一个软件应用程序，其模块无法独立执行，因此我们应该考虑基于微服务的解决方案，因为它是唯一能够彼此独立执行指令的解决方案[10-11]。大型整料随着时间的流逝变得难以维护，并且由于其复杂性而难以评估，但是主要缺点是它们限制了产品的可扩展性。另一个问题是它们不提供容错能力，并且在另一个组件不起作用时不允许系统的单个组件工作，这在面向微服务的体系结构中是可能的。由于整体是一个软件应用程序，其模块无法独立执行，因此我们应该考虑基于微服务的解决方案，因为它是唯一能够彼此独立执行指令的解决方案[10-11]。大型整料随着时间的流逝变得难以维护，并且由于其复杂性而难以评估，但是主要缺点是它们限制了产品的可扩展性。另一个问题是它们不提供容错能力，并且在另一个组件不起作用时不允许系统的单个组件工作，这在面向微服务的体系结构中是可能的。由于整体是一个不能独立执行模块的软件应用程序，因此我们应该考虑一种基于微服务的解决方案，因为它是唯一能够彼此独立执行指令的解决方案[10-11]。大型整料随着时间的流逝变得难以维护，并且由于其复杂性而难以评估，但是主要缺点是它们限制了产品的可扩展性。另一个问题是它们不提供容错能力，并且在另一个组件不起作用时不允许系统的单个组件工作，这在面向微服务的体系结构中是可能的。能够执行彼此独立的指令[10-11]。大型整料随着时间的流逝变得难以维护，并且由于其复杂性而难以评估，但是主要缺点是它们限制了产品的可扩展性。另一个问题是它们不提供容错能力，并且在另一个组件不起作用时不允许系统的单个组件工作，这在面向微服务的体系结构中是可能的。能够执行彼此独立的指令[10-11]。大型整料随着时间的流逝变得难以维护，并且由于其复杂性而难以评估，但是主要缺点是它们限制了产品的可扩展性。另一个问题是它们不提供容错能力，并且在另一个组件不起作用时不允许系统的单个组件工作，这在面向微服务的体系结构中是可能的。并且它们不允许系统的单个组件在另一个组件不起作用时工作，这在面向微服务的体系结构中是可能的。并且它们不允许系统的单个组件在另一个组件不起作用时工作，这在面向微服务的体系结构中是可能的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在SOA（面向服务的体系结构）中，主要服务使用两种方法进行协调：编排（其中有一个中央微服务，它将向其他服务发送请求并通过发送和接收响应来控制整个过程）和编排（不涉及任何集中化，但每个服务都事先知道应该做什么）[1]。与单片架构和SOA架构一样，最困难的问题仍然是将系统划分为服务[12]。同样，在任何情况下您都不应忽略通过不受控制的服务分配来提供机密信息的问题[13]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的体系结构将分布式计算与微服务结合在一起，以创建一个环境，使客户端之间能够动态分配计算。所谓分布式计算，是指在云中处理和存储大量数据的可用性，这是IT领域内外现代行业中的关键要素。分布式存储系统旨在满足具有广泛适用性，可伸缩性和高性能的分布式和计算高级应用程序的需求。一种著名的解决方案是MapReduce [14]，它通过对分布式服务器进行排序来协调计算，同时管理各种任务，系统各部分之间的所有通信和数据传输，提供冗余和容错能力。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Azure Batch是另一种编程模型，用于高效地以并行或大规模模式运行计算机化的应用程序，而无需手动配置或基础结构管理，并具有更强大的高性能计算群集（HPC-高性能计算）[15]。为了说明这些想法，让我们使您想起SaaS（软件即服务）或需要广泛执行的客户端应用程序[16]。实际上，各种IT公司都对SaaS表现出了越来越大的兴趣，他们希望降低其运营支出，从而提高其业务灵活性[17]。主要云服务提供商提供的另一项服务是Azure Functions，它允许按需启动，而无需显式提供或管理基础结构[18]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这也增加了应用程序对在云中轻松启动小段代码或“功能”的兴趣。</font><font style="vertical-align: inherit;">对物联网（IoT）的日益增长的兴趣使Azure Functions [19]成为用于数据处理，系统集成以及创建简单API和微服务的出色解决方案。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.方法论</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结构上建议的系统可以分为3个不同的区域：（1）客户-将执行服务器分配的任务； （2）服务器-与客户端的接口，整体应用程序的大脑； （3）客户端-服务器通信管理区域，其中封装了与从服务器到客户端的执行转移相关的所有详细信息。客户端和服务器之间通过网络传输的所有信息均使用DES（数据加密标准）算法加密，并使用Diffie-Hellman协议更改密钥[20]，尽管该协议在某些情况下易受攻击，尚未在各种Internet安全解决方案中实施。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1。系统架构</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的系统很大程度上基于动态微服务系统的体系结构。该体系结构以客户端-服务器为基础，其中服务器对应于大量客户端。服务器和客户端均执行Web微服务，通信协议为HTTP，数据格式为JSON。此体系结构对于在客户端之间分配和动态重新分配资源很有用。这种架构模型用于构建大型，复杂且可水平扩展的应用程序，这些应用程序由使用API​​相互交互的小型，独立且独立的进程组成[21]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在图。图1显示了服务器如何为其客户端分发功能包。根据客户端的数量，可能有一些指令不会分配给任何客户端，也可能是同一组指令分配给多个客户端。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yd/-j/hk/yd-jhkvmw4m4mjb0lskder-k9bg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。 1.向客户分发服务。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
应用程序体系结构是使用Microsoft的ASP.NET MVC框架构建的。在中央部分，我们看到服务器本身上的服务器微服务，在左侧和右侧，有许多客户端正在等待从服务器启动任务。编排的服务组件一方面提供服务器与客户端之间的通信，向客户端发送任务，另一方面，它监视这些请求的状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种体系结构允许一个微服务调用另一个微服务（因此我们获得了扩展（扩展）微服务）或互相调用，这可能导致循环依赖，应在用户级别上防止这种依赖。</font><font style="vertical-align: inherit;">客户端-服务器通信协议按以下步骤执行：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户端连接到服务器并启动密钥交换协议。</font><font style="vertical-align: inherit;">他还将把它们提供给它们所对应的服务器和端口。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务器将下一个要执行的任务通知客户端（该任务由一对（微服务，输入数据）表示）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户端接收到该作业，然后通知服务器传输和下载已成功完成或未成功完成。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一旦建立了两个对象之间的连接，服务器就会将使用DES加密的JSON格式的数据发送到客户端进行处理。</font></font></li>
<li>      ( ,       )    JSON,    DES.</li>
<li>      ,         .</li>
<li>         —            .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种交互的一种特殊情况是一种场景，当一个客户端执行一项任务，而其结果需要另一个客户端的结果。</font><font style="vertical-align: inherit;">对于这种情况，评估了两个现有的可能性：编排和编排。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在编排的情况下，我们发现了几个障碍：（a）服务器应该已经将可用于执行外部任务的客户端列表发送给客户端，并且保持此更新值列表通常会导致信息交换网络上的负载增加; </font><font style="vertical-align: inherit;">（b）两个客户之间的通讯容易受到攻击。</font><font style="vertical-align: inherit;">通过业务流程解决了两种情况。</font><font style="vertical-align: inherit;">实际上，所有管理工作都在服务器上，而客户端只是易于使用的简单对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于扩展的微服务选项，客户端与客户端交互的阶段如下：</font></font><br>
<br>
<ol>
<li>          .    ,     .      ,     DES.</li>
<li>  , ,   .   ,    ,  ,    ,         .     ,     (  . .).</li>
<li>      ,       (   ),   ,        .</li>
<li>        .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户端使用一次性密码解密结果并继续执行。</font></font></li>
</ol><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2。</font><font style="vertical-align: inherit;">应用程序</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
为了测试和评估该体系结构，我们实现了一些微服务，这些微服务每次都需要检查。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_l/ye/uc/_lyeucntwjhoj0xlbenxz4nygjs.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。</font><font style="vertical-align: inherit;">2.界面。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一个实验中，我们使用了以下3种微服务：（1）对两个数字执行数学运算的微服务（使用LibraryMath），（2）告诉我们该数字是否为正数（MasterOfNumbers）的微服务，以及（3）扩展微服务，当它收到两个数字时，它将调用第一个微服务，结果将发送到第二个微服务以提取有关该数字的信息（UniverseOfSuperMath）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图2显示了我们如何使用提出的微服务获得数学计算。在界面级别，仅显示数学运算的结果，其余信息可以看作是服务器通过按下等号键接收到AJAX调用的结果（两个结果均为肯定）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我们将考虑应用程序的主要功能，该功能着重于当有一个，两个或多个连接的客户端时发生的情况。在图3中，我们看到在实验中我们如何在本地计算机上启动更多客户端，并为每个客户端使用不同的端口。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/94/nq/a9/94nqa9rzhinodyiixedizjaul8m.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。 3.界面。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们有6个字段：ClientToken-与每个客户端关联的唯一令牌（当调用是本地且具有localhost值时）；日期-提出要求的时间； IP＆端口=客户端的IP地址和进行通信的端口；函数-被调用函数的名称；成功-布尔值标志，指示呼叫成功。例如，我们注意到在第一次调用时（h：8:38:21客户端未连接到服务器，该过程由服务器执行）。在第二个呼叫中，我们观察到系统的动态行为，其中一项任务由客户端之一执行，其他两项由服务器执行。更具体地说，将调用UniverserOfSuperMath（在本地-客户端无法执行此任务），依次调用另外两个微服务，一个是本地的，一个是通过委托使用特定指令的客户端来调用的，等等。d。</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">容错能力</font></font></b></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
创建此体系结构时，我考虑的另一个功能与系统的容错能力有关。根据前一种情况，我们可以观察到一个或多个客户端选择离开系统时会发生什么。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在右侧的图3中，在8:46的呼叫演示了这种情况。端口8390和8827上的客户端出现本地或网络问题，或者只是关闭与服务器的连接，服务器没有及时收到将其从列表中删除的通知。服务器将尝试与客户端联系并运行命令，但是如果它们未及时响应，则服务器将执行其任务并返回请求的结果。为了确认，将在一段时间后再次请求客户，如果他们继续不响应，则将从可用客户列表中将其删除。下一个呼叫（8:47）将不再无用地请求不再可用的客户端，并且由可用客户端跳过的任务将由服务器执行。</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拟议解决方案的优缺点</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种体系结构的优势显而易见：托管成本低，分布式网络中提供的微服务是动态的，并且可以自动扩展（当客户提供的计算能力不断提高时，系统的计算能力也会提高）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
应该同样强调这些限制：当计算能力曲线与客户能力曲线不匹配时。我们还对在任何操作系统上运行此应用程序的能力有所限制。为此，我们决定将负担得起的解决方案从.NET转换为Java。但是，该解决方案相对于原始解决方案具有一些缺点（与.NET相比，Java提供了更低的数据处理速度和更少的动态数据包传输）。我们当前正在使用此解决方案，因为Microsoft提供的.Net Core在多个平台上都可以使用，但它不是一个成熟的解决方案，并且不提供标准.NET平台的所有功能。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3。客户端-服务器组件</font></font></b><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3.1。顾客</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此体系结构中，客户端是Windows Presentation Foundation（WPF）桌面应用程序，专门用于与服务器通信并执行从服务器接收的各种任务。由于该应用程序是不需要安装的可执行文件，因此操作系统必须与.Net Framework一起使用。本质上，Web微服务将与另一个Web微服务交互。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，客户端在并行线程中启动任务调度程序，该线程每分钟将尝试通知服务器其存在。一个任务可以有两种状态：（1）有一个任务要执行（代码包的初始化已经完成）-在这种情况下，它仅通知服务器它的存在； （2）或要求用服务器初始化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用服务器进行的初始化首先包括任意选择的代码和端口来启动服务器，然后使用Diffie-Hellman密钥交换协议（IKE）将其发送给服务器。在两个对象之间建立连接后，服务器将立即向客户端提供一揽子安装说明。客户端的主要作用是从服务器接收指令包，将其加载到内存中，处理从服务器接收的信息，然后返回通过执行此指令包获得的结果。客户端执行的第一步是与服务器联系以获取指令包。此说明包是ZIP存档。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解压缩该软件包之前，请从“ process”文件夹（如果存在）中删除带有说明的先前目录，然后将新内容提取到该文件夹​​中并将其加载到内存中。内存加载一次开始，无论客户端收到多少呼叫。这是可能的，因为会话中的三个属性保持不变：assembly，methodInfo和type。程序集存储到加载的DLL的链接，methodInfo属性包含从DLL调用的方法，类型描述DLL的类型。 install.zip文件是从服务器接收的指令包，其中包含DLL，XML，图像，配置文件等，以及将在以后的过程中执行的所有已编译代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此步骤标志着客户端和服务器之间执行特定任务的通信的开始。</font><font style="vertical-align: inherit;">一旦客户端成功初始化以执行特定任务，服务器将仅发送加密形式的数据包（必须对其进行处理），并且还将等待加密形式的响应。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过执行从服务器接收的代码，系统被“锁定”，客户端可以连接到数据库，调用其他API，尤其是调用执行相同或不同指令的其他客户端。</font><font style="vertical-align: inherit;">在业务流程系统中建立连接，在该系统中，服务器搜索下一个可用的客户端，请求结果，服务器将其响应重定向回该客户端。</font><font style="vertical-align: inherit;">这种微服务编排称为“ ExtendedService”，并且在客户端级别的唯一区别是对加密进行了优化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
技术上的问题是用另一个要执行的指令包重新初始化客户端。由于在特殊上下文（Web服务器）中加载内存是静态的，因此只有重新启动整个过程以处理加载到内存中的DLL才有可能。为此，我们在Windows中创建了事件，这些事件是从在桌面应用程序中运行的Web应用程序运行的。这是必要的，因为我们在两个不同的执行线程中处理两个不同的上下文。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3.2。服务器</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
嵌入式微服务具有ILibraryMath接口，该接口提供SimpleMath方法，并且该接口由LibraryMath类实现。 LibraryMath类扩展了通用抽象类MicroCore，该类具有两个用于输入和输出的对应参数。扩展此抽象类，应实现ProcessTask方法，在其中编写所有要执行的代码，并在扩展的抽象类中调用Run函数以在SimpleMath方法中执行此代码。因此，可以定义接口和方法，而不仅限于任何特定的名称，但是通过将代码传递给抽象类，我们将获得对代码的完全控制，可以在不同的客户端之间进行分配。在此类中，我们可以轻松拥有更多功能和导入的库，如果将它们分组在一个包中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一步是将该接口写入SimpleInjector，该库可简化具有松散耦合组件的依赖项注入模式的部署。除了在Simple Injector容器中记录交错的类之外，为了打破应用程序级别之间的依赖性（引入模板依赖性），我们需要在微服务存储容器中注册该类，该类将由应用程序进行缩放。完成此步骤后，我们将能够使用接口提供的功能来实现创建目的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Service1实现IService1并扩展了抽象的MicroCore类，然后在此容器中向MicroContainer.RegisterMicro注册。值得一提的是，localohst / DynamicMicros / {Service}中存在可用的API，客户端通过这些API与服务器进行通信。通过这些API可以使用的重要操作：客户端连接，客户端将其活动通知服务器，微服务扩展等。接下来，我们介绍MicroCore和MicroContainer类，它们共同构成我们应用程序的基础。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MicroCore类是一个抽象的通用类，负责从ProcessTask虚拟方法调用代码。</font><font style="vertical-align: inherit;">这是通过调用Run方法来完成的，该方法又调用了公共TaskManager方法。</font><font style="vertical-align: inherit;">请注意，微服务又会调用此方法。</font><font style="vertical-align: inherit;">将ZIP包发送到客户端以加载到内存中并执行时，它会连同其所有依赖项（包括用于管理客户端微服务的此类）一起发送。</font><font style="vertical-align: inherit;">执行控制包括反序列化/序列化要发送的数据包，调用代码本身，调用其他API等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
返回服务器端，控制代码的执行包括以下步骤：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果是ExtendedService调用，则将调用服务器来应答。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果有客户请求，它将被发送给他以处理结果。</font><font style="vertical-align: inherit;">在否定的情况下，服务器本身将处理数据。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们要求客户进行数据处理。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果客户端有问题，我们将再次要求确认可用性，但发送服务器响应（以避免停机和漫长的等待时间）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们注册当前活动。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MicroContainer类是整个嵌入式微系统的管理空间。</font><font style="vertical-align: inherit;">在这里，连接应用程序（服务器）的客户端进行连接，并且存在一些函数调用，这些函数扩展了MicroCore抽象类的“高级服务”。</font><font style="vertical-align: inherit;">这是一个静态类，其中在微服务上执行的任务列表，连接的客户端列表以及执行这些任务的客户端任务列表存储在字典中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
启动后，将使用RegisterMicro注册该类以集成到微服务中。在初始化期间，这只会发生一次。 AddNewClient方法为我们提供了新客户端的注册，密钥交换，服务器IP地址的注册以及它将在其上运行的端口。新客户端收到的令牌将在插入客户端列表之前进行检查，以确认其唯一性。与客户端建立连接后，服务器将调用InstallService方法，该方法将打包数据并将其发送，并在客户端响应后将其添加到此任务的字典中。将分配给每个客户的服务时间取决于所使用的策略。在服务器和客户端（使用ExtendedService）上启动抽象的MicroCore微服务时，使用GetNextClient函数为请求的任务提供可用客户端的请求。该操作将非常频繁地执行，其复杂性将直接影响应用程序的响应时间。这就是为什么我们的方法是随机选择一个客户。这是快速完成的，并且根据我们的实验可确保平均分配呼叫。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个选择是实现循环列表，该解决方案的缺点是，在大型客户端I / O流的情况下，更新循环列表将需要更多的时间和复杂性，我们试图避免这种情况。当客户端不响应收到的请求时，将调用RecordClientError方法。回答此问题后，决定保存或删除此客户端，客户端由初始化期间客户端发送的令牌代码唯一标识，每个微服务均由名称空间和类名标识。所有资源（客户端，代码）都通过此统一单元进行管理，该统一单元为必要的操作提供支持。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于系统安全性，已采取措施来防止攻击，拦截和数据保护。服务器和客户端之间发送的所有消息都使用对称DES密钥算法和客户端与服务器之间的Diffie-Hellman密钥交换（在客户端初始化期间发生）进行加密。可用的客户端和正在运行的程序存储在服务器内存中。我们选择此解决方案是因为它是最佳选择，因为它提供了对数据的高速访问，信息可能会经常更改，并且存储区域非常难以攻击。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4。微服务系统的动态行为</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，客户端将在其上使用的所有计算机可以在相同或不同的网络中。优先考虑两个因素：（a）花费在数据传输上的时间； （b）系统为数据管理而增加的开销（例如，客户搜索，加密，解密，错误处理等）。我们主要对系统在本地（LAN）和全球（WAN）网络中的行为感兴趣（图4）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1p/lc/fe/1plcfehcmqd4zkcgmuuuvd07cgq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。 4.记录在局域网（日志的第一列）和全局（日志的第二列）中工作的系统的记录。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“任务名称”列包含客户端调用为每个任务进行的所有注册，“日志”列是每个任务处理的小时数和持续时间（以毫秒为单位）（在本地网络的左侧，在全局网络的右侧）。请注意，任务对第一个调用的响应时间最长，然后减少。自然，因为所有内存下载，保存地址等通常都是在首次调用时完成的。前三个任务是简单的数学运算，通常在几毫秒内执行-这也是我们系统所需的时间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于本地网络，每个任务平均需要20到30毫秒，这是通过网络上的加密，日志记录和传输（即使它是本地的）来实现的。这种LAN通信模型也用于云中，因为计算机位于同一位置（数据中心），并且它们之间的通信是通过光纤进行的，因此网络延迟最小。结果如图1所示。 4在日志的左列。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了测试我们的WAN应用程序，我们将路由器配置为将呼叫从端口80路由到：</font></font><code>http://192.168.1.160/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（网络地址）和IIS（Internet信息服务）启动了该应用程序，可以从本地网络外部的任何位置访问该应用程序。</font><font style="vertical-align: inherit;">要在客户端级别运行该应用程序，需要使用端口8000：9000（任意端口）的权限。</font><font style="vertical-align: inherit;">客户端被安排在任意位置，并通过API确定与公共IP的连接：</font></font><code>https://api.ipify.org/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">结果如图1所示。</font><font style="vertical-align: inherit;">4在右侧的日志列中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在图所示的结果中。</font><font style="vertical-align: inherit;">4，对于前三个任务（不与其他微服务通讯），日志右栏中的值比日志左栏中的值高16-17％;对于从Internet下载文档或与数据库进行交互的微服务，±10％特定的服务器。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.评估</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本研究中，我们在本地网络（通过无线网络连接5台计算机）和全球网络（使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mihaidm.ddns.net</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命名空间</font><font style="vertical-align: inherit;">）中</font><font style="vertical-align: inherit;">监视了系统的行为</font><font style="vertical-align: inherit;">，将我们的系统与整体系统进行了比较，这些操作在相同的位置执行计算机（请参阅表1）。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表1.网络的系统额定值。</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算（毫秒）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写入数据库（毫秒）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pdf生成（ms）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本地主机</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.458</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.449</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lan</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.408</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16.415</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wan</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">54</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.826</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">29.309</font></font></td>
</tr>
</tbody></table></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在具有5个连接的客户端的一台设备上顺序进行测试以进行网络测试。</font><font style="vertical-align: inherit;">每个任务完成了100次，评估所有调用中的总毫秒数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为数值计算，它是两个数字的乘积。微服务不与其他微服务交互，通过网络传输的信息量很小，并且可以最大限度地降低复杂性，以严格研究在服务器，客户端和网络管理任务上花费的时间。如果计算是由服务器（本地主机）执行的，则首先检查是否有可用的客户端，并且由于未连接客户端，因此服务器将处理结果。在以下情况下，本地网络中客户端的存在表明在非常快速的网络操作条件下任务已完成，并且从处理方面进行加密/解密，以找到客户端的响应。对于100次执行，完成操作所需的平均时间为25 ms，考虑到灵活性/速度比，这是一个很有希望的值。如果是WAN，时间是原来的两倍比本地网络中的时间（54毫秒）要多，这是由于加密过程中的传输成本，但实际执行需要半毫秒。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们调查的另一个任务是写入数据库。特别是，将要写入数据库的单词作为参数。我们对客户将如何快速联系位于本地区域之外的数据库感兴趣（对于本研究而言，该数据库位于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.my.gearhost.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。请注意，LAN和localhost上的运行时值是关闭的。在全球网络中，差异非常明显，因为处理，管理数据和客户端所需的时间不及连接数据库以插入值的客户端所需的时间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这项研究中执行的最后一项任务是创建PDF文件，我们的重点是估计系统中数据的传输时间。</font><font style="vertical-align: inherit;">为此，我们从</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.pdf-archive.com/2018/05/14/diploma/diploma.pdf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载PDF文件</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">已加载到内存中。</font><font style="vertical-align: inherit;">系统会将名称写到特定位置，然后将结果（以字节向量的形式）返回给服务器。</font><font style="vertical-align: inherit;">对于本地主机和本地网络，相差约1000毫秒表示本地加密和传输PDF文件所需的时间。</font><font style="vertical-align: inherit;">对于WAN，由于字节向量的传输成本非常高，因此结果值较高。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.结论和今后的工作</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于服务器和客户端都执行相同的代码，因此在服务器端的工作中呈现的系统体系结构的一般性和抽象性使设计变得困难。我们可以说，当前的体系结构是紧凑，简单，易于理解和扩展的。客户端可以执行服务器分配的任务，服务器是一个独立的客户端接口。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所提出的体系结构使创建新的微服务非常容易，然后将其自动集成到嵌入式系统中。该体系结构的创新元素：它可以非常容易地扩展，每个新客户端都根据所采用的策略（最昂贵的任务，最常见的，之前列出的两个策略的组合，或者仅仅是一个任意策略）从服务器接收任务。实际上，我们拥有具有微服务系统灵活性的整体。服务器处理客户端之间的任务的动态分配，并基于多个参数（任务的调用次数，其执行时间或其组合）提供动态扩展。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
未来的方向之一是考虑到该系统可以成功地集成到具有明显应用性的网站或API系统中。</font><font style="vertical-align: inherit;">由于可用于多个平台（例如，移动电话），因此可以随时改进和扩展建议的体系结构。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们正在考虑的未来的另一个方向今天被认为是极具吸引力的-用户提供计算能力以换取费用（例如BITCOIN系统），我们的应用程序被开发为在某些计算机上运行微服务。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">源链接</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这项研究是在POC-A1-A1.2.3-G-2015计划的支持下发布的，这是PrivateSky项目（P_40_371 / 13/01/01/2016）和README项目“用于评估罗马尼亚文本可读性和改进用户的交互式创新应用程序”的一部分写作风格”，合同号 </font><font style="vertical-align: inherit;">114 / 09.15.2017，MySMIS 2014代码119286。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[1] Dragoni，N.，Giallorenzo，S.，Lluch-Lafuente，AL，Mazzara，M.，Montesi，F.，Mustafin，R.（2017a）“微服务：昨天，今天和明天”。 Mazzara M.，Meyer B.（编辑），《现在与未来》软件工程。施普林格</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[2] Mazzara，M.，Khanda，K.，Mustafin，R.，Rivera，V.，Safina，L.和Silitti，A.（2018）“微服务科学与工程”。在：P。Ciancarini，S。Litvinov，A。Messina，A.，Sillitti，G。Succi（编），第五届国防应用软件工程国际会议论文集，SEDA 2016，Springer，10-20。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[3] N. Dragoni，I。Lanese，ST拉森，Mazzara，M。Mustafin，R。和Safina，L.（2017b）“微服务：如何使您的应用规模扩大”。在：Petrenko A.，Voronkov A.（eds。）Systems Informatics的观点中。 PSI2017。计算机科学讲座，10742。Springer，Cham。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[4] Melis，A.，Mirri，S.，Prandi，C.，Prandini，M.，Salomoni，P。和Callegati，F。（2016年），《残疾人微服务架构使用案例》。在第二届EAI社会对象智能对象和技术国际会议上，DOI：10.1007 / 978-3-319-61949-1_5。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[5] Zimmermann，O.（2017）“微服务原则：服务开发和部署的敏捷方法，计算机科学-研究与开发”，32（3-4）：301-310。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[6]夏长春，张玉英，王林，Soleman S.和刘玉英（2018年），“基于微服务的智能太空云机器人系统，用于智能空间”。于：机器人技术与自治系统110，DOI：10.1016 / j.robot.2018.10.001。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[7] Bogner，J.，Fritzsch，J.，Wagner，S.和Zimmermann，A.（2019）“工业微服务：对技术，特性和软件质量的洞察力”。在2019年IEEE国际软件体系结构研讨会（ICSAW）上，位于德国汉堡。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[8] E. Akentev，A. Tchitchigin，L.和Mzzara，M.（2017）“ Jolie编程语言的经过验证的类型检查器”，https：//arXiv.org/pdf/1703.05186.pdf。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[9]Černý，T.，Donahoo，MJ和Trnka，M.（2018）“对微服务架构的上下文理解：当前和未来的方向”。 ACM SIGAPP应用计算评论17（4）：29-45，DOI：10.1145 / 3183628.3183631。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[10] Larucces，X.，I. Santamaria，R. Colomo-Palacios，和Ebert，C.（2018）“微服务”。于：IEEE软件，35/3：96-100。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[11] Kalske，M.（2017）“将整体架构转变为微服务架构”。理学硕士大学论文赫尔辛基。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[12] Lenarduzzi，V.和Taibi，D.（2016）“解释的MVP：关于最小可行产品定义的系统映射研究”。在第42届Euromicro会议上，软件工程和高级应用程序（SEAA），第112-119页。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[13] Taibi，D.，Lenarduzzi，V.，Janes，A.，Liukkunen，K.和Ahmad，MO（2017）“比较Scrum中的需求分解，Scrum与Kanban，XP和Banana开发过程”。在：Baumeister H.，Lichter H.，Riebisch M.（编辑）软件工程和极限编程中的敏捷过程中。商业信息处理讲义，283。Springer，Cham。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[14] A.Gómez，A。Benelallam和M. Tisi（2015）“分布式计算的分散模型持久性”。在第三届BigMDE研讨会上，意大利拉奎拉。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[15] Kandave，KR（2018）“ Azure上的高性能计算”。 Nanette Ray（编辑），AzureCAT，Microsoft Corporation。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[16] Sreenivas，V.，SriHarsha，S.和Narasimham，C.（2012）“实施SaaS的云模型”。在：Advanced Materials Research 341-342，瑞士Trans Tech Publications，499-503中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[17] Badidi，E.（2013）“软件即服务选择和供应框架”。于：国际计算机网络与通信杂志（IJCNC），5（3）：189-200。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[18] Lynn，T.，Rosati，P.，Lejeune，A.和Emeakaroha，V.（2017）“企业无服务器云计算（功能即服务）平台的初步回顾”。在2017年IEEE第9届云计算技术和科学国际会议上，162-169。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[19] Adzic，G.和Chatley，R.（2017）“无服务器计算：经济和架构影响。”在：ESEC / FSE'17,2017年9月4日至8日，德国帕德博恩，ACM。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[20] Diffie，W.和Hellman，M.（1976）“密码学的新方向”。</font><font style="vertical-align: inherit;">在：IEEE Transactions on，信息论，22（6）：644–654。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[21] Kratzke，N.（2015）“关于微服务，容器及其对网络性能的低估影响”。</font><font style="vertical-align: inherit;">在云计算中。</font><font style="vertical-align: inherit;">2015年，180 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arxiv.org/abs/1710.04049</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解有关该课程的更多信息</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN492616/index.html">Packer，Terraform和Ansible：在一小时内部署Kubernetes集群</a></li>
<li><a href="../zh-CN492628/index.html">冠状病毒患者数量的置信区间（死亡率计算）</a></li>
<li><a href="../zh-CN492632/index.html">隔离小企业：恐慌是理性的敌人</a></li>
<li><a href="../zh-CN492636/index.html">有效意味着什么？</a></li>
<li><a href="../zh-CN492638/index.html">用鸭子缩放Redux应用程序</a></li>
<li><a href="../zh-CN492652/index.html">两个M5Stack上的纸牌游戏“傻瓜”</a></li>
<li><a href="../zh-CN492658/index.html">我去了遥控器-发起了播客：初学者应该读的书-5本行之有效的书</a></li>
<li><a href="../zh-CN492660/index.html">全世界对抗冠状病毒。英特尔故事</a></li>
<li><a href="../zh-CN492662/index.html">我是如何第一次流传大学讲座的</a></li>
<li><a href="../zh-CN492666/index.html">Maltego第4部分。VK，Instagram，LinkedIN和其他出色的生物</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>