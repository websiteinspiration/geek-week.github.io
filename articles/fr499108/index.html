<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📆 🥗 👨🏾‍✈️ Rouille. Emprunter le vérificateur via des itérateurs 😤 👭 👋🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 
 
 J'étudie depuis environ un an et, pendant mon temps libre, j'écris sur le rast. J'aime la façon dont ses auteurs ont résolu le prob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Rouille. Emprunter le vérificateur via des itérateurs</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499108/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'étudie depuis environ un an et, pendant mon temps libre, j'écris sur le rast. </font><font style="vertical-align: inherit;">J'aime la façon dont ses auteurs ont résolu le problème de la gestion de la mémoire et évité le ramasse-miettes - grâce au concept d'emprunt. </font><font style="vertical-align: inherit;">Dans cet article, j'aborderai cette idée à travers des itérateurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dernièrement, la scala est ma langue principale, il y aura donc des comparaisons avec elle, mais il n'y en a pas beaucoup et tout est intuitif, sans magie :) L' </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
article est conçu pour ceux qui ont entendu quelque chose sur la rouille, mais qui ne sont pas entrés dans les détails. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lu/ju/o1/lujuo1lkziqqcu6fpfxiuuuaquy.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
photos prises </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'ici</font></font></a><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Préface</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les langages jvm, il est habituel de masquer le travail avec les liens, c'est-à-dire que nous travaillons presque toujours avec les types de données de référence, nous avons donc décidé de masquer l'esperluette (&amp;). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le rasta, il existe des liens explicites, par exemple vers un entier - `&amp; i32`, le lien peut être déréférencé via` *`, il peut également y avoir un lien vers le lien et ensuite il devra être déréférencé deux fois **.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itérateur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de l'écriture de code, vous devez très souvent filtrer la collection par une condition (prédicat). </font><font style="vertical-align: inherit;">Dans la roche, prendre même des éléments ressemblerait à ceci:</font></font><br>
<br>
<pre><code class="scala hljs">    <span class="hljs-keyword">val</span> vec = <span class="hljs-type">Vector</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
    <span class="hljs-keyword">val</span> result = vec.filter(e =&gt; e % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons les sortes:</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-keyword">private</span>[scala] <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filterImpl</span></span>(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>, isFlipped: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Repr</span> = {
    <span class="hljs-keyword">val</span> b = newBuilder
    <span class="hljs-keyword">for</span> (x &lt;- <span class="hljs-keyword">this</span>)
      <span class="hljs-keyword">if</span> (p(x) != isFlipped) b += x<font></font>
<font></font>
    b.result<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sans entrer dans les détails de `newBuilder`, il est clair qu'une nouvelle collection est en cours de création, nous itérons sur l'ancienne et si le prédicat retourne vrai, alors ajoutez un élément. </font><font style="vertical-align: inherit;">Malgré le fait que la collection soit nouvelle, ses éléments sont en fait des liens vers des éléments de la première collection, et si, soudainement, ces éléments sont modifiables, leur modification sera commune aux deux collections. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons maintenant de faire de même dans le rast. </font><font style="vertical-align: inherit;">Je vais immédiatement donner un exemple de travail, puis je considérerai les différences.</font></font><br>
<br>
<pre><code class="rust hljs">    <span class="hljs-keyword">let</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
    <span class="hljs-keyword">let</span> result: <span class="hljs-built_in">Vec</span>&lt;&amp;<span class="hljs-built_in">i32</span>&gt; = v.iter().filter(|e| **e % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).collect();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wow, wow quoi? </font><font style="vertical-align: inherit;">Déréférencement de double pointeur? </font><font style="vertical-align: inherit;">Juste pour filtrer le vecteur? </font><font style="vertical-align: inherit;">Difficile :( Mais il y a des raisons à cela. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment ce code diffère du rock:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> obtenir explicitement l'itérateur sur le vecteur (`iter ()`) </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans la fonction prédicat, pour une raison quelconque, nous déréférencer le pointeur deux fois </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> appelez `collect ()` </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cela a également donné lieu à un vecteur de types de référence Vec &lt;&amp; i32&gt;, et non à des nombres ordinaires </font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vérificateur d'emprunt</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi appeler explicitement `iter ()` sur la collection? </font><font style="vertical-align: inherit;">Il est clair pour tout rockman que si vous appelez `.filter (...)` alors vous devez parcourir la collection. </font><font style="vertical-align: inherit;">Pourquoi dans un rast écrire explicitement ce qui peut être fait implicitement? </font><font style="vertical-align: inherit;">Parce qu'il y a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trois</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> itérateurs différents! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6t/vw/-m/6tvw-mzsdc6ce1caxkzl-custrw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour comprendre pourquoi trois? </font><font style="vertical-align: inherit;">besoin de toucher sur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emprunter </font></font></b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(emprunter, emprunter) </font></font></i> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vérificateur</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 'a. </font><font style="vertical-align: inherit;">La raison même pour laquelle le rast fonctionne sans GC et sans allocation / désallocation de mémoire explicite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi est-il nécessaire?</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour éviter les situations où plusieurs pointeurs pointent vers la même zone mémoire, ce qui vous permet de la modifier. </font><font style="vertical-align: inherit;">C'est une condition de course.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afin de ne pas désallouer plusieurs fois la même mémoire.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment y parvient-on? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En raison du concept de propriété. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, le concept de propriété est simple - un seul peut posséder quelque chose (même l'intuition). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le propriétaire peut changer, mais il est toujours seul. Lorsque nous écrivons `let x: i32 = 25`, cela signifie qu'il y avait une allocation de mémoire pour 32bit int et qu'un certain` x` en est propriétaire. L'idée de propriété n'existe que dans l'esprit du compilateur, dans le vérificateur d'emprunt. Lorsque le propriétaire, dans ce cas, «x» quitte la portée (sort de la portée), la mémoire dont il est propriétaire sera effacée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un code que le vérificateur d'emprunt ne manquera pas:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span></span>; <span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span> </span>() -&gt; X {
    <span class="hljs-keyword">let</span> first = X; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second = first; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> third = first; <span class="hljs-comment">//   ,   first   </span>
<span class="hljs-comment">//    value used here after move</span><font></font>
<font></font>
    <span class="hljs-keyword">return</span> third;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
`struct X` est quelque chose comme` case class X ()` - une structure sans bordure. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce comportement est super contre-intuitif, je pense, pour tout le monde. </font><font style="vertical-align: inherit;">Je ne connais pas d'autres langues dans lesquelles il serait impossible "d'utiliser" deux fois la même "variable". </font><font style="vertical-align: inherit;">Il est important de ressentir ce moment. </font><font style="vertical-align: inherit;">le premier n'est pas du tout une référence à X, c'est son </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriétaire</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En changeant le propriétaire, nous tuons en quelque sorte le précédent, le vérificateur d'emprunt ne permettra pas son utilisation.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi avez-vous eu besoin de créer votre propre structure, pourquoi ne pas utiliser un entier régulier?</font></font></b>
                        <div class="spoiler_text">    —       (`struct X`),  , ,   integer.   ,     ,     :<br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span> </span>() -&gt; <span class="hljs-built_in">i32</span> {
    <span class="hljs-keyword">let</span> first = <span class="hljs-number">32</span>;
    <span class="hljs-keyword">let</span> second = first; 
    <span class="hljs-keyword">let</span> third = first; <font></font>
<font></font>
    <span class="hljs-keyword">return</span> third;<font></font>
}<font></font>
</code></pre><br>
  ,   borrow checker,            ,   .     Copy,      .      `i32` second     ,   (   ), -  third   .   X     Copy,      .<br>
<br>
     .   ,              ,      «»            .        Clone,    ,     .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">copy</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">clone</a>.<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revenons aux itérateurs. </font><font style="vertical-align: inherit;">Le concept de «capture» parmi eux est </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntoIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il «avale» la collection, en donnant possession de ses éléments. </font><font style="vertical-align: inherit;">Dans le code, cette idée sera reflétée comme ceci:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-keyword">let</span> coll_1 = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> coll_2: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = coll_1.into_iter().collect();
<span class="hljs-comment">//coll_1 doesn't exists anymore</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En appelant `into_iter ()` à coll_1, nous l'avons "transformé" en itérateur, absorbé tous ses éléments, comme dans l'exemple précédent, "second" absorbé "premier". </font><font style="vertical-align: inherit;">Après cela, tous les appels à coll_1 seront punis par le vérificateur d'emprunt lors de la compilation. </font><font style="vertical-align: inherit;">Ensuite, nous avons collecté ces éléments avec la fonction `collect`, créant un nouveau vecteur. </font><font style="vertical-align: inherit;">La fonction `collect` est nécessaire pour collecter une collection à partir d'un itérateur, pour cela vous devez spécifier explicitement le type de ce que nous voulons collecter. </font><font style="vertical-align: inherit;">Par conséquent, coll_2 indique clairement le type. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'accord, en général, ce qui est décrit ci-dessus est suffisant pour un langage de programmation, mais il ne sera pas très efficace de copier / cloner des structures de données chaque fois que nous voulons les transférer, et vous devez également pouvoir changer quelque chose. </font><font style="vertical-align: inherit;">Nous passons donc aux pointeurs.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pointeurs</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le propriétaire, comme nous l'avons découvert, ne peut être qu'un seul. </font><font style="vertical-align: inherit;">Mais vous pouvez avoir n'importe quel nombre de liens.</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Y</span></span>; <span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span></span>() -&gt; Y {
    <span class="hljs-keyword">let</span> first = Y; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second: &amp;Y = &amp;first; <span class="hljs-comment">//   ,     </span>
    <span class="hljs-keyword">let</span> third = &amp;first; <span class="hljs-comment">//    </span><font></font>
<font></font>
<span class="hljs-comment">// </span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, second);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, third);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> first;<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce code est déjà valide, car le propriétaire en est toujours un. Toute la logique de propriété est vérifiée uniquement au stade de la compilation, sans affecter l'allocation / le déplacement de la mémoire. De plus, vous pouvez voir que le type de seconde a changé en «&amp; Y»! Autrement dit, la sémantique de la propriété et des liens se reflète dans les types, ce qui vous permet de vérifier lors de la compilation, par exemple, l'absence de condition de concurrence. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment puis-je me protéger contre les conditions de concurrence lors de la compilation? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fixant une limite au nombre de liens mutables! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un lien mutable à un moment donné peut être un et un seul (sans immuable). C'est-à-dire soit un / plusieurs immuable, soit un mutable. Le code ressemble à ceci:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-comment">// </span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span></span> {<font></font>
    x: <span class="hljs-built_in">i32</span>,<font></font>
} <font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span></span>() -&gt; X {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> first = X { x: <span class="hljs-number">20</span> }; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second: &amp;<span class="hljs-keyword">mut</span> X = &amp;<span class="hljs-keyword">mut</span> first; <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">let</span> third: &amp;<span class="hljs-keyword">mut</span> X = &amp;<span class="hljs-keyword">mut</span> first; <span class="hljs-comment">//    .        `second`        - .</span>
<span class="hljs-comment">//    second.x = 33;  //    ,             ,    </span>
    third.x = <span class="hljs-number">33</span>;<font></font>
<font></font>
    <span class="hljs-keyword">return</span> first;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons en revue les changements dans l'exemple précédent relatif. Tout d'abord, nous avons ajouté un champ à la structure afin qu'il y ait quelque chose à changer, car nous avons besoin de mutabilité. Deuxièmement, `mut` est apparu dans la déclaration de la variable` let mut first = ...`, c'est un marqueur pour le compilateur sur la mutabilité, comme `val` &amp;` var` dans la roche. Troisièmement, tous les liens ont changé leur type de `&amp; X` à` &amp; mut X` (cela semble, bien sûr, monstrueux. Et cela est sans durée de vie ...), maintenant nous pouvons changer la valeur stockée par le lien.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais j'ai dit que nous ne pouvons pas créer plusieurs liens mutables, ils disent que le vérificateur d'emprunt ne donnera pas cela, mais j'en ai créé deux moi-même! Oui, mais les vérifications y sont très délicates, c'est pourquoi il n'est parfois pas évident pourquoi le compilateur jure. Il s'efforce de s'assurer que votre programme compile et s'il n'y a absolument aucune option pour respecter les règles, alors une erreur, et peut-être pas celle que vous attendez, mais celle qui viole sa dernière tentative, la plus désespérée et pas évidente pour un débutant: ) Par exemple, vous êtes informé que la structure n'implémente pas le trait Copier, bien que vous n'ayez appelé aucune copie nulle part. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, l'existence de deux liens mutables en même temps est autorisée car nous n'en utilisons qu'un, c'est-à-dire que le second peut être jeté et rien ne changera. «Second» peut également être utilisé </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jusqu'à</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">créer un "troisième" et tout ira bien. </font><font style="vertical-align: inherit;">Mais, si vous décommentez `second.x = 33;`, il s'avère que deux liens mutables existent simultanément et vous ne pouvez pas sortir d'ici de toute façon - erreur de compilation.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itérateurs</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc trois types de transmission:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Absorption, emprunt, déménagement</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lien</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lien mutable</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque type a besoin de son propre itérateur.</font></font><br>
<br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntoIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> absorbe les objets de la collection originale</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s'exécute sur des liens d'objet</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IterMut</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s'exécute sur des références d'objets mutables</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La question se pose - quand utiliser lequel. </font><font style="vertical-align: inherit;">Il n'y a pas de solution miracle - vous devez vous entraîner, lire le code, les articles de quelqu'un d'autre. </font><font style="vertical-align: inherit;">Je vais donner un exemple illustrant l'idée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons qu'il y ait une école, une classe et des élèves dans la classe.</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-meta">#[derive(PartialEq, Eq)]</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Sex</span></span> {<font></font>
    Male,<font></font>
    Female<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Scholar</span></span> {<font></font>
    name: <span class="hljs-built_in">String</span>,<font></font>
    age: <span class="hljs-built_in">i32</span>,<font></font>
    sex: Sex<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = ...;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons pris le vecteur des écoliers en interrogeant la base de données, par exemple. </font><font style="vertical-align: inherit;">Ensuite, je devais compter le nombre de filles dans la classe. </font><font style="vertical-align: inherit;">Si nous «avalons» le vecteur via «into_iter ()», après le comptage, nous ne pouvons plus utiliser cette collection pour compter les garçons:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bad_idea</span></span>() {
    <span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();
    <span class="hljs-keyword">let</span> girls_c = scholars<font></font>
        .into_iter()<font></font>
        .filter(|s| (*s).sex == Sex::Female)<font></font>
        .count();<font></font>
<font></font>
    <span class="hljs-keyword">let</span> boys_c = scholars <font></font>
        .into_iter()<font></font>
        .filter(|s| (*s).sex == Sex::Male)<font></font>
        .count();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y aura une erreur «valeur utilisée ici après le déménagement» sur la ligne pour compter les garçons. </font><font style="vertical-align: inherit;">Il est également évident que l'itérateur mutable ne nous est d'aucune utilité. </font><font style="vertical-align: inherit;">C'est pourquoi c'est juste `iter ()` et travailler avec un double lien:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">good_idea</span></span>() {
    <span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();
    <span class="hljs-keyword">let</span> girls_c = scholars.iter().filter(|s| (**s).sex == Sex::Female).count();
    <span class="hljs-keyword">let</span> boys_c = scholars.iter().filter(|s| (**s).sex == Sex::Male).count();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, pour augmenter le nombre de recrues potentielles dans le pays, un itérateur mutable est déjà requis:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">very_good_idea</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();<font></font>
    scholars.iter_mut().for_each(|s| (*s).sex = Sex::Male);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En développant l'idée, nous pouvons faire des soldats des «gars» et démontrer l'itérateur «absorbant»:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-keyword">impl</span> Scholar {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">to_soldier</span></span>(<span class="hljs-keyword">self</span>) -&gt; Soldier {<font></font>
        Soldier { forgotten_name: <span class="hljs-keyword">self</span>.name, number: some_random_number_generator() }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Soldier</span></span> {<font></font>
    forgotten_name: <span class="hljs-built_in">String</span>,<font></font>
    number: <span class="hljs-built_in">i32</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">good_bright_future</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();<font></font>
    scholars.iter_mut().for_each(|s| (*s).sex = Sex::Male);<font></font>
    <span class="hljs-keyword">let</span> soldiers: <span class="hljs-built_in">Vec</span>&lt;Soldier&gt; = scholars.into_iter().map(|s| s.to_soldier()).collect();
    <span class="hljs-comment">//   scholars,    </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur cette merveilleuse note, c'est peut-être tout. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La dernière question demeure - d'où vient le double déréférencement des liens dans «filtre». </font><font style="vertical-align: inherit;">Le fait est qu'un prédicat est une fonction qui prend une référence à un argument (pour ne pas le capturer):</font></font><br>
<br>
<pre><code class="rust hljs">
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">filter</span></span>&lt;P&gt;(<span class="hljs-keyword">self</span>, predicate: P) -&gt; Filter&lt;<span class="hljs-keyword">Self</span>, P&gt; <span class="hljs-keyword">where</span>
        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>, P: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item) -&gt; <span class="hljs-built_in">bool</span>,
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
le prédicat est FnMut (en gros, une fonction), qui prend une référence à son (auto) élément et renvoie bool. </font><font style="vertical-align: inherit;">Comme nous avions déjà un lien depuis l'itérateur `.iter ()`, le second est apparu dans le filtre. </font><font style="vertical-align: inherit;">Lorsqu'il est absorbé par un itérateur (`into_iter`), le double déréférencement du lien se transforme en un lien régulier.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'ai pas beaucoup d'expérience dans la rédaction d'articles, donc je serai heureux de critiquer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si cela m'intéresse, je peux continuer. </font><font style="vertical-align: inherit;">Options pour les sujets:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comment et quand la désallocation de mémoire se produit </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durée de vie du lien </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> programmation asynchrone </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> écrire un petit service web, vous pouvez même proposer des api </font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liens</font></font></h3><br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">livre de rouille</font></font></a> </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En raison du concept de propriété, la mise en œuvre d'éléments de base tels que, par exemple, une liste chaînée n'est plus anodine. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plusieurs façons de les implémenter.</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr499092/index.html">Modèle de référence BIAN. Quelles sont les nouveautés et l'utilité de l'architecture d'entreprise de la banque?</a></li>
<li><a href="../fr499096/index.html">Logique floue dans de belles images. Surfaces de réponse pour différentes fonctions d'appartenance</a></li>
<li><a href="../fr499102/index.html">Kubernetes, microservices, CI / CD et Dockers pour rétrogrades: conseils d'apprentissage</a></li>
<li><a href="../fr499104/index.html">L'IoT à vos blessures: pourquoi l'Internet des objets est le bienvenu à l'ère des coronavirus</a></li>
<li><a href="../fr499106/index.html">HTML avancé</a></li>
<li><a href="../fr499110/index.html">Le Big Brother essaie de servir le bien. Comment les collecteurs de données et les sociétés de programme sont impliqués dans la lutte contre les coronavirus</a></li>
<li><a href="../fr499112/index.html">Système avancé d'autorisation des ressources à Laravel. Partie 3. Lecture / écriture des attributs, propres modèles</a></li>
<li><a href="../fr499114/index.html">Exportation du plan de numérotation de l'Agence fédérale des communications vers une base de données relationnelle</a></li>
<li><a href="../fr499118/index.html">Comment créer une vidéo virale</a></li>
<li><a href="../fr499120/index.html">[Signet] CSS: Utilisation de l'indentation et de l'indentation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>