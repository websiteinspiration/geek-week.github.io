<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✖️ 👩🏼‍🤝‍👩🏻 🧔 PRESENT - Ultraleichte Blockverschlüsselung (Übersetzung des Originals PRESENT: Eine ultraleichte Blockverschlüsselung) 🌟 🧝🏽 🧑🏿‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Hier ist die Übersetzung des Originalartikels „PRÄSENTIEREN: Eine ultraleichte Blockchiffre“ von Robert B. Weide Bogdanov, Kreditgeber, Pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PRESENT - Ultraleichte Blockverschlüsselung (Übersetzung des Originals PRESENT: Eine ultraleichte Blockverschlüsselung)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487542/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font><font style="vertical-align: inherit;">Hier ist die Übersetzung des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Originalartikels „PRÄSENTIEREN: Eine</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ultraleichte </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Blockchiffre“</font></a><font style="vertical-align: inherit;"> von </font></font><strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Robert B. Weide</font></font></strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bogdanov, Kreditgeber, Paar, Poshman, Robshav, Seurin und Wikkelsoy.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/n7/eg/txn7egneg1_32856cpillz8r9_a.jpeg" width="400"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anmerkung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Einführung von </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><abbr title="Advanced Encryption Standard"><font style="vertical-align: inherit;">AES ist der</font></abbr></a><font style="vertical-align: inherit;"> Bedarf an neuen Blockverschlüsselungsalgorithmen gesunken, da </font><acronym><font style="vertical-align: inherit;">AES</font></acronym><font style="vertical-align: inherit;"> in den meisten Fällen </font><font style="vertical-align: inherit;">eine großartige Lösung ist. </font><font style="vertical-align: inherit;">Trotz seiner einfachen Implementierung ist </font><acronym><font style="vertical-align: inherit;">AES jedoch</font></acronym><font style="vertical-align: inherit;"> nicht für extrem eingeschränkte Umgebungen wie </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><abbr title="Radio Frequency IDentification"><font style="vertical-align: inherit;">RFID-</font></abbr></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"> Tags und Lesegeräte</font></a><font style="vertical-align: inherit;"> geeignet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dieser Artikel beschreibt den ultraleichten Blockverschlüsselungsalgorithmus PRESENT. </font><font style="vertical-align: inherit;">Bei der Entwicklung dieses Algorithmus wurden sowohl die Effizienz der Implementierung in Eisen als auch die Zuverlässigkeit der Verschlüsselung berücksichtigt. </font><font style="vertical-align: inherit;">Infolgedessen ist das Ergebnis der Systemanforderungen mit den heute führenden Kompaktstrom-Chiffren vergleichbar.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"> <abbr title="Fortgeschrittener Verschlüsselungsstandard"><font style="vertical-align: inherit;"></font></abbr></a><font style="vertical-align: inherit;"></font><acronym><font style="vertical-align: inherit;"></font></acronym><font style="vertical-align: inherit;"></font><acronym><font style="vertical-align: inherit;"></font></acronym><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><abbr title="Radiofrequenz-Identifikation"><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Einleitung</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hauptkurs in der IT des aktuellen Jahrhunderts ist die Entwicklung kleiner Computergeräte, die nicht nur in Konsumgütern verwendet werden, sondern auch einen integralen und unsichtbaren Bestandteil der Kommunikationsinfrastruktur der Umwelt bilden. Es wurde bereits festgestellt, dass solche Implementierungen eine ganze Reihe sehr spezifischer Sicherheitsbedrohungen verursachen. Gleichzeitig sind verfügbare kryptografische Lösungen, auch eher primitive, häufig nicht für die Verwendung in Umgebungen mit stark begrenzten Ressourcen geeignet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel bieten wir einen neuen, hardwareoptimierten Blockverschlüsselungsalgorithmus an, der mit den maximal möglichen Größen- und Leistungsbeschränkungen entwickelt wurde. Gleichzeitig haben wir versucht, Datenkompromisse zu vermeiden. Um dies zu erreichen, haben wir die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><abbr title="Datenverschlüsselungsstandard - Algorithmus für symmetrische Verschlüsselung"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DES-</font></font></abbr></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erfahrung genutzt </font><font style="vertical-align: inherit;">und die Eigenschaften ergänzt</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><abbr title="Finalistischer Algorithmus für AES-Wettbewerbe"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serpent</font></font></abbr></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat eine erstaunliche Leistung in der Hardware gezeigt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht lohnt es sich zu erklären, warum wir uns für die Entwicklung einer neuen Blockverschlüsselung entschieden haben, da die allgemein akzeptierte Tatsache ist, dass Stream-Chiffren möglicherweise kompakter sind. In der Tat haben wir uns am Anfang bemüht, das Design kompakter Stream-Chiffren während der Arbeit am</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eSTREAM-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projekt</font><font style="vertical-align: inherit;">sowie einige andere vielversprechende Annahmen</font><font style="vertical-align: inherit;">zu verstehen, die</font><font style="vertical-align: inherit;">schnell zu wirken scheinen. Wir haben jedoch mehrere Gründe festgestellt, warum wir uns dennoch für eine Blockverschlüsselung entschieden haben. Erstens ist die Blockverschlüsselung universell und primitiv und wird im</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschlüsselungsmodus verwendet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d.h. Wenn wir die bereits verschlüsselten Blöcke verwenden, um Folgendes zu verschlüsseln, erhalten wir eine Streaming-Verschlüsselung. Zweitens und vielleicht hauptsächlich scheinen die Feinheiten der Funktionsprinzipien von Blockchiffren besser untersucht zu sein als die Funktionsprinzipien von Stream-Verschlüsselungsalgorithmen. Während es beispielsweise eine umfangreiche Theorie gibt, die auf der Verwendung von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schieberegistern mit linearer Rückkopplung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> basiert </font><font style="vertical-align: inherit;">, ist es nicht so einfach, diese Blöcke so zu kombinieren, dass ein sicheres Angebot erhalten wird. Wir gehen davon aus, dass eine ordentlich gestaltete Blockverschlüsselung sicherer ist als eine frisch erstellte Stream-Verschlüsselung. Daher finden wir, dass eine Blockverschlüsselung, die so viel Eisenressourcen benötigt wie eine kompakte Stream-Verschlüsselung, sehr interessant sein kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wichtig zu beachten, dass wir bei der Erstellung eines neuen Blockverschlüsselungsalgorithmus, insbesondere mit auffälliger Leistung, nicht nur Innovationen verfolgen. Im Gegenteil, die Entwicklung und Implementierung der Chiffre gehen Hand in Hand und enthüllen einige grundlegende Grenzen und inhärente Grenzen. Beispielsweise legt eine bestimmte Sicherheitsstufe Einschränkungen für die Mindestschlüssel- und Blocklängen fest. Selbst die Verarbeitung eines 64-Bit-Status mit einem 80-Bit-Schlüssel begrenzt die minimale Gerätegröße. Sie können auch feststellen, dass die Ausführungsform in der Hardware - insbesondere die Kompaktheit der Hardware-Implementierung - zur Wiederholbarkeit beiträgt. Selbst kleine Änderungen können die Lautstärke des Geräts beeinträchtigen. Kryptoanalytiker legen jedoch auch Wert auf Wiederholbarkeit und suchen nach mathematischen Strukturen, die sich in vielen Runden leicht multiplizieren lassen.Wie viele einfache sich wiederholende Strukturen können verwendet werden, ohne die Systemsicherheit zu beeinträchtigen?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel wird also die kompakte Blockverschlüsselung PRESENT beschrieben. </font><font style="vertical-align: inherit;">Nach einer kurzen Überprüfung der vorhandenen Literatur haben wir den Rest des Artikels in einer Standardform gestaltet. </font><font style="vertical-align: inherit;">Der Code wird in Abschnitt 3 beschrieben, in Abschnitt 4 werden Entwurfsentscheidungen beschrieben. </font><font style="vertical-align: inherit;">In Abschnitt 5 werden wir die Sicherheit betrachten, während Abschnitt 6 eine detaillierte Analyse der Leistung enthält. </font><font style="vertical-align: inherit;">Diese Arbeit endet mit unseren Schlussfolgerungen.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Bestehende Arbeiten</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während das Arbeitsvolumen für billige Kryptographie stetig wächst, ist die Anzahl der Artikel für superleichte Chiffren überraschend gering. Wenn wir uns auf das Protokollgerät konzentrieren, werden wir uns nicht mehr auf Arbeiten zu billigen Kommunikations- und Identifikationsprotokollen beziehen. Eine der umfangreichsten Arbeiten zur kompakten Implementierung ist derzeit mit dem eSTREAM-Projekt verbunden. Im Rahmen eines Teils dieses Projekts wurden neue Stream-Chiffren vorgeschlagen, die für eine effektive Implementierung in Hardware angepasst sind. Im Rahmen dieser Arbeit werden vielversprechende Kandidaten vorgestellt. Bisher sind die Verhältnisse ungefähr, aber aus den Implementierungsbroschüren geht hervor, dass für kompakte Chiffren des eSTREAM-Projekts etwa 1300-2600 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GE (Gate-Äquivalente)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erforderlich sind </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter den Blockchiffren wurde eine der weithin bekannten, nämlich DES, unter Berücksichtigung der Effizienz der Ausrüstung erstellt. Angesichts des sehr begrenzten Zustands von Halbleitern in den frühen 1970er Jahren ist es nicht überraschend, dass DES sehr wettbewerbsfähige Implementierungseigenschaften aufweist. Während der Entwicklung wurden 3000GE für DES ausgegeben, und nach der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serialisierung fiel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diese Zahl auf 2300GE. Die DES-Schlüssellänge schränkt jedoch ihre Nützlichkeit in vielen Anwendungen ein und führt dazu, dass spezielle Modifikationen auf ihrer Basis entwickelt werden, beispielsweise mit erhöhter kryptografischer Stärke oder einem erweiterten Schlüssel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Bezug auf moderne Blockchiffren bietet </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieser Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine gründliche Analyse kostengünstiger </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AES</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Implementierung erfordert jedoch etwa 3.600 GE, was eine indirekte Folge des Entwurfs von Bußgeldern für 8- und 32-Bit-Prozessoren ist. </font><font style="vertical-align: inherit;">Die Systemanforderungen &lt;a href = " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TEA sind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht bekannt, erfordern jedoch Schätzungen zufolge etwa 2100 GE. Es gibt 4 weitere Lösungen, die für kostengünstige Geräte ausgelegt sind: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mCRYPTON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (hat eine exakte Ausführung von 2949 GE), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HIGHT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (etwa 3000 GE), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (etwa) 2280 GE) und CGEN (ebenfalls um 2280 GE), obwohl letzteres nicht als Blockchiffre konzipiert wurde.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Verschlüsselung PRÄSENTIEREN</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PRESENT ist ein Sonderfall des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SP-Netzwerks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und besteht aus 31 Runden. Die Blocklänge beträgt 64 Bit, und die Schlüssel werden in 2 Versionen unterstützt, 80- und 128-Bit. Dieses Schutzniveau sollte für Anwendungen mit geringer Sicherheit ausreichen, die normalerweise für die Bereitstellung basierend auf Tags verwendet werden. Darüber hinaus stimmt PRESENT in seinen Designmerkmalen weitgehend mit den Stream-Chiffren des eSTREAM-Projekts überein, die für eine effektive Implementierung in Hardware geschärft wurden, sodass wir einen angemessenen Vergleich ermöglichen können ihr. </font></font><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sicherheitsanforderungen und Betriebseigenschaften von 128-Bit-Versionen finden Sie im Anhang zum Originalartikel.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Jede der 31 Runden besteht aus einer XOR-Operation zur Eingabe des Schlüssels K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für 1 ≤ i ≤ 32, für den K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet wird</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bleichen des Schlüssels</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lineare bitweise Permutation und nichtlineare Substitutionsschicht (oder einfacher Erhöhung der Verschlüsselungsstärke). Die nichtlineare Schicht verwendet separate 4-Bit- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S-Blöcke</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die in jeder Runde 16 Mal parallel angewendet werden. Die durch den Pseudocode beschriebene Verschlüsselung ist in der Abbildung dargestellt: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/39/jf/bc/39jfbcgtriqxlsbdkyojjycyc_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun wird jede Stufe nacheinander bestimmt. Die Entwurfsbegründungen sind in Abschnitt 4 angegeben, und die Bits sind überall von Grund auf neu nummeriert, beginnend mit dem richtigen in einem Block oder Wort. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinzufügen eines runden Schlüssels (addRoundKey).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der runde Schlüssel K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wobei 1 ≤ i ≤ 32 ist, sowie der aktuelle Zustand b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Das Hinzufügen eines runden Schlüssels zum aktuellen Zustand erfolgt modulo 2 (b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ⊕ k </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wobei 0 ≤ j ≤ 63). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S-Box-Schicht (sBoxlayer).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die in PRESENT verwendeten S-Blöcke ordnen 4-Bit-Blöcke 4-Bit-Blöcken zu. Die Wirkung dieses Blocks im Hexadezimalzahlensystem ist in der folgenden Tabelle gezeigt: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5d/dv/2a/5ddv2ahldslwpoziqdpth4a5dwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die S-Blockschicht ist der aktuelle Zustand b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16 4-Bit-Wörter w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wobei w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i + 3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> || b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i + 2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> || b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> || b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für 0 ≤ i ≤ 15. Rahmenausgang S [w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">] gibt aktualisierte Statuswerte auf offensichtliche Weise zurück. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permutationsschicht (pLayer).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bitweise Permutation verwendet PRESENT in der folgenden Tabelle definiert (der Zustand von Bit i wird auf die Position P (i) verschoben): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/et/bh/ng/etbhngoueocjgcnf0hhswl-lobs.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlüsselkonvertierung ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schlüsselplan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRESENT kann 80- und 128-Bit-Schlüssel verwenden, wir werden uns jedoch auf die 80-Bit-Version konzentrieren. Der vom Benutzer bereitgestellte Schlüssel wird in dem Schlüsselregister K gespeichert, das als k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 dargestellt ist</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In der i-ten Runde ist ein 64-Bit-Rundenschlüssel K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">62</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bestehend aus 64 linken Bits des aktuellen Inhalts des Registers K. Somit haben wir in der i-ten Runde: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">62</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Auspacken des runden Schlüssels K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i wird das</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schlüsselregister K = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie folgt aktualisiert: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] = [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">77</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">76</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] = S [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">77</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">76</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] = [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] ⊕ round_counter </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Registrieren </font><font style="vertical-align: inherit;">Sie sich </font><font style="vertical-align: inherit;">daher Der Schlüssel wird um 61 Positionen nach links verschoben, die 4 am weitesten links liegenden Bits werden durch den S-Block geleitet, und round_counter, der Wert von i, wird modulo 2 mit den Bits k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font><sub><font style="vertical-align: inherit;">15</font></sub><font style="vertical-align: inherit;"> addiert</font></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von K mit dem niedrigstwertigen Bit von round_counter nach rechts. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/jl/5d/o1/jl5do1gwvqcgmezpu_id0cdsxhi.png"><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Schlüsselkonvertierung für einen 128-Bit-Algorithmus finden Sie im Anhang zum Originalartikel.</font></font></em><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Designmerkmale von PRESENT</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neben Sicherheit und effizienter Implementierung ist die Hauptleistung von PRESENT die Einfachheit. </font><font style="vertical-align: inherit;">Daher ist es nicht verwunderlich, dass ähnliche Projekte unter anderen Umständen angenommen und sogar als Lehrbuch für Studenten verwendet wurden. </font><font style="vertical-align: inherit;">In diesem Abschnitt werden wir die Entscheidungen begründen, die wir beim Entwerfen von PRESENT getroffen haben. </font><font style="vertical-align: inherit;">Zunächst beschreiben wir jedoch die erwarteten Anwendungsanforderungen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1. </font><font style="vertical-align: inherit;">Zweck und Anwendungsumgebung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Entwerfen einer Blockverschlüsselung, die in Umgebungen mit engen Einschränkungen anwendbar ist, ist es wichtig zu verstehen, dass wir keine Blockverschlüsselung erstellen, die sicherlich in vielen Situationen anwendbar ist - dafür gibt es AES. </font><font style="vertical-align: inherit;">Im Gegenteil, wir zielen auf eine sehr spezifische Anwendung ab, für die AES nicht geeignet ist. </font><font style="vertical-align: inherit;">Das Vorstehende bestimmt die folgenden Eigenschaften.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Verschlüsselung wird "in Hardware" implementiert.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendungen sind nur erforderlich, um die Sicherheitsstufe anzupassen. </font><font style="vertical-align: inherit;">Daher wäre ein 80-Bit-Schlüssel eine robuste Lösung. </font><font style="vertical-align: inherit;">Beachten Sie, dass die Entwickler von Stream-Chiffren des eSTREAM-Projekts an derselben Position festhalten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendungen erfordern keine Verschlüsselung großer Datenmengen. </font><font style="vertical-align: inherit;">Somit kann eine Implementierung hinsichtlich Leistung oder Platz optimiert werden, ohne zu viele Änderungen vorzunehmen.</font></font></li>
<li>     ,      .   ,       (       ).</li>
<li>      ,  ,         , , ,      .</li>
<li>  ,      ,        (encryption-only mode).  ,      - (challenge-response)  , ,    ,          ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"> </a>.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund dieser Überlegungen haben wir beschlossen, PRESENT als 64-Bit-Blockverschlüsselung mit einem 80-Bit-Schlüssel zu erstellen. Verschlüsselung und Entschlüsselung haben in diesem Fall ungefähr die gleichen physischen Anforderungen. Mit der Fähigkeit, sowohl Verschlüsselung als auch Entschlüsselung zu unterstützen, ist PRESENT kompakter als nur AES-Verschlüsselung. Und im Fall einer Ausführung nur mit Verschlüsselung ist unsere Verschlüsselung ganz einfach. Encryption </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschlüssel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird auf dem Sprung berechnet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Literatur gibt es viele Beispiele </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für Kompromissangriffe zwischen Zeit, Datum und Erinnerung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder Angriffe mit dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geburtstagsparadoxon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beim Verschlüsseln großer Datenmengen. </font><font style="vertical-align: inherit;">Diese Angriffe hängen jedoch nur von den Parametern der Verschlüsselung ab und verwenden nicht die interne Struktur. </font><font style="vertical-align: inherit;">Unser Ziel ist es, diese Angriffe so gut wie möglich gegen uns zu machen. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kanalangriffe von Drittanbietern</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und direkte Chip-Breaking-Angriffe bedrohen PRESENT ebenso wie andere </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kryptografische Grundelemente</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Für wahrscheinliche Anwendungen machen moderate Sicherheitsanforderungen die Vorteile für einen Angreifer in der Praxis jedoch sehr begrenzt. </font><font style="vertical-align: inherit;">Bei der Risikobewertung werden solche Bedrohungen nicht als wesentlicher Faktor wahrgenommen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2. </font><font style="vertical-align: inherit;">Permutationsschicht</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Auswahl einer Schlüsselmischschicht erfordert unsere Aufmerksamkeit für die Hardwareeffizienz eine lineare Schicht, die mit einer minimalen Anzahl von Steuerelementen (z. B. Transistoren) implementiert werden kann. </font><font style="vertical-align: inherit;">Dies führt zu einer bitweisen Permutation. </font><font style="vertical-align: inherit;">Aus Gründen der Einfachheit haben wir uns für eine regelmäßige bitweise Permutation entschieden, um eine transparente Sicherheitsanalyse durchzuführen (siehe Abschnitt 5).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3. </font><font style="vertical-align: inherit;">S-Blöcke.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei PRESENT verwenden wir separate S-Blöcke, die 4 Bit in 4 Bit übersetzen (F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> → F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Dies ist eine direkte Folge unseres Wunsches nach Hardwareeffizienz, und die Implementierung eines solchen S-Blocks ist normalerweise viel kompakter als die eines 8-Bit-S-Blocks. Da wir die Bitmap-Permutation für eine lineare Diffusionsschicht verwenden, sind AES-ähnliche Diffusionstechnologien für unsere Verschlüsselung keine Option. Daher stellen wir einige zusätzliche Bedingungen an S-Blöcke, um den sogenannten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Lawineneffekt“</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu reduzieren </font><font style="vertical-align: inherit;">. Genauer gesagt erfüllen die S-Blöcke für PRESENT die folgenden Bedingungen, wobei wir den Fourier-Koeffizienten S mit </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (a) = ∑ (-1) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;b, S (x)&gt; + &lt;a, x&gt;</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , x∈F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 bezeichnen</font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1. Für jede feste Eingangsvorspannung ungleich Null ∆ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∈ F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und jede feste Eingangsvorspannung ungleich Null ∆ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∈ F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> innerhalb des S-Blocks benötigen wir </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
# {x ∈ F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | S (x) + S (x + ∆ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = ∆ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> } ≤ 4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Für jede feste Eingangsdifferenz ungleich Null ∆ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∈ F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und jede feste Ausgangsdifferenz ungleich Null ∆ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∈ F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so dass wt (∆ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = wt (∆ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = 1 haben wir </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{x ∈ F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">| S (x) + S (x + ∆ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = ∆ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> } = ∅ </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. Für alle ungleich Null a ∈ F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und alle ungleich Null b ∈ F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gilt | S </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (a) | </font><font style="vertical-align: inherit;">≤ 8 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. Für alle ungleich Null a ∈ F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und alle ungleich Null b ∈ F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4,</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so dass wt (a) = wt (b) = 1 gilt, gilt S </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (a) = ± 4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie aus Abschnitt 5 hervorgeht, Diese Bedingungen stellen sicher, dass PRESENT gegen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">differentielle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">lineare Angriffe</font></a><font style="vertical-align: inherit;"> resistent ist</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Unter Verwendung der Klassifizierung aller 4-Bit-S-Blöcke, die die obigen Bedingungen erfüllen, haben wir den S-Block ausgewählt, der besonders für eine effiziente Hardware-Implementierung geeignet ist.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Sicherheitsanalyse</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt werden wir die Ergebnisse der PRESENT-Sicherheitsanalyse präsentieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Differenzielle und lineare Kryptoanalyse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die differentielle und lineare Kryptoanalyse sind einige der leistungsfähigsten Methoden, die Kryptoanalytikern zur Verfügung stehen. </font><font style="vertical-align: inherit;">Um den gegenwärtigen Widerstand gegen differentielle und lineare Kryptoanalyse zu messen, setzen wir die Untergrenze für die Anzahl der sogenannten aktiven S-Blöcke, die an der differentiellen (oder linearen) Charakteristik beteiligt sind.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Differenzielle Kryptoanalyse</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Fall der differentiellen Kryptoanalyse wird durch den folgenden Satz abgedeckt. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satz 1. </font></font></b> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Fünfkreis-Differentialkennlinie von PRESENT hat mindestens 10 aktive S-Blöcke. </font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Satz 1 ist in Anhang 3 des Originalartikels bewiesen, und wir setzen die Beobachtungen fort. </font><font style="vertical-align: inherit;">Wir teilen 16 S-Blöcke in 4 Gruppen ein: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cu/vb/xb/cuvbxb5bl5psjid8dpwqxjwpkiq.png"><br>
<br>
<sub><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zahlen am Eingang (oben) geben die Nummer des S-Blocks im vorherigen Schritt und am Ausgang (unten) an - beim nächsten</font></font></em></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Beachten Sie Folgendes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Eingangsbits zum S-Block stammen von 4 verschiedenen S-Blöcken derselben Gruppe.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingangsbits für Gruppen von vier S-Blöcken stammen aus 16 verschiedenen S-Blöcken.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vier Ausgangsbits eines bestimmten S-Blocks sind in vier verschiedenen S-Blöcken enthalten, von denen jeder in der nächsten Runde zu einer separaten Gruppe von S-Blöcken gehört.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ausgangsbits von S-Blöcken in verschiedenen Gruppen gehen zu verschiedenen S-Blöcken.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gemäß Satz 1 muss jede Differentialcharakteristik für mehr als 25 Runden von PRESENT mindestens 5 × 10 = 50 aktive S-Blöcke haben. Die maximale Differentialwahrscheinlichkeit des PRESENT S-Blocks beträgt 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und daher ist die Wahrscheinlichkeit einer einzelnen 25-Runden-Differentialkennlinie auf 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-100 begrenzt</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fortgeschrittene Methoden ermöglichen es dem Kryptoanalytiker, externe Runden aus der Chiffre zu entfernen, um eine kürzere Eigenschaft zu verwenden. Selbst wenn wir dem Angreifer erlauben, sechs Runden aus der Chiffre zu entfernen, was eine beispiellose Situation darstellt, überschreiten die Daten, die zur Verwendung der verbleibenden 25-Runden-Differenzcharakteristik erforderlich sind, die verfügbare Menge. </font><font style="vertical-align: inherit;">Sicherheitsgrenzen sind daher mehr als zuverlässig. </font><font style="vertical-align: inherit;">Wir haben jedoch praktisch bestätigt, dass die Grenze der Anzahl der aktiven S-Blöcke in Satz 1 eng ist.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Praktische Bestätigung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können Merkmale definieren, die zehn S-Blöcke über fünf Runden umfassen. Das nächste iterative Merkmal für zwei Runden umfasst zwei S-Blöcke pro Runde und gilt mit einer Wahrscheinlichkeit von 2 bis </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für fünf Runden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Komplexere Eigenschaften werden mit einer Wahrscheinlichkeit von 2 bis </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für 5 Runden gehalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl die Wahrscheinlichkeit dieses zweiten Merkmals sehr nahe an der Grenze von 2 bis </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20 liegt</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist nicht iterativ und hat wenig praktischen Wert. </font><font style="vertical-align: inherit;">Stattdessen haben wir experimentell die Wahrscheinlichkeit eines iterativen Differentials mit zwei Runden bestätigt. </font><font style="vertical-align: inherit;">In Experimenten mit mehr als 100 unabhängigen Unterschlüsseln unter Verwendung von 223 ausgewählten Klartextpaaren wurde die beobachtete Wahrscheinlichkeit vorhergesagt. </font><font style="vertical-align: inherit;">Dies scheint darauf hinzudeuten, dass für dieses spezielle Merkmal kein gleichzeitiger signifikanter Unterschied besteht. </font><font style="vertical-align: inherit;">Das Ausmaß eines Differentialeffekts zu bestimmen, ist jedoch eine komplexe und zeitaufwändige Aufgabe, obwohl unsere vorläufige Analyse ermutigend war.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lineare Kryptoanalyse</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Fall der linearen PRESENT-Kryptoanalyse wird im folgenden Satz betrachtet, in dem wir die beste lineare Annäherung an die vier Runden von PRESENT analysieren. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satz 2.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sei E </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4R</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die maximale lineare Verschiebung der Vier-Runden-Näherung mit PRESENT. Dann ist E </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4R</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ≤ 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Beweis des Satzes ist in Anhang 4 des Originalartikels enthalten.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dann beträgt die maximale Verschiebung für 28 Runden </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × E </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4R </font></font></sub><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × (2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-43</font></font></sup><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter der Annahme, dass ein Kryptoanalytiker nur etwa 28 der 31 Runden in PRESENT benötigt, um einen Schlüsselwiederherstellungsangriff auszulösen, erfordert eine lineare Kryptoanalyse einer Chiffre etwa 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">84</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bekannte Klartexte / Chiffretexte. </font><font style="vertical-align: inherit;">Diese Datenanforderungen überschreiten den verfügbaren Text.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige fortgeschrittene differentielle / lineare Angriffe</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die PRESENT-Struktur ermöglicht es uns, einige der verschiedenen Formen von Angriffen zu betrachten. Keiner von ihnen führte jedoch zu einem Angriff, der weniger Text als die Untergrenze der Textanforderungen für die lineare Kryptoanalyse erforderte. Unter den ausgezeichneten Angriffen haben wir einen betrachtet, der palindromische Unterschiede verwendet, da symmetrische Unterschiede mit einer Wahrscheinlichkeit von eins (d. H. Immer) über der Diffusionsschicht bestehen, sowie einige fortgeschrittene Versionen von differentiell-linearen Angriffen. Obwohl die Angriffe für mehrere Runden vielversprechend erschienen, verloren sie schnell ihren praktischen Wert und es ist unwahrscheinlich, dass sie in der gegenwärtigen Kryptoanalyse nützlich sind. Wir fanden auch heraus, dass eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verkürzte differentielle Kryptoanalyse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wahrscheinlich von begrenztem Wert ist, obwohl die nächsten beiden Runden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine abgeschnittene Erweiterung wird mit einer Wahrscheinlichkeit von eins durchgeführt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst wenn die Länge der bereits identifizierten Differentialmerkmale verringert wird, bleiben die Datenanforderungen übermäßig hoch. </font><font style="vertical-align: inherit;">Eine Rangfolgeerweiterung wird mit einer Wahrscheinlichkeit von eins durchgeführt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2. </font><font style="vertical-align: inherit;">Strukturelle Angriffe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Strukturelle Angriffe wie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">integrierte Kryptoanalyse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die Engpassanalyse eignen sich gut zur Analyse von AES-ähnlichen Chiffren. </font><font style="vertical-align: inherit;">Solche Chiffren haben starke wortähnliche Strukturen, wobei Wörter normalerweise Bytes sind. Die Darstellungskonstruktion ist jedoch fast ausschließlich bitweise, und obwohl die Permutationsoperation etwas regelmäßig ist, wird die Entwicklung und Verteilung von Wortstrukturen durch die in der Chiffre verwendeten bitweisen Operationen gestört.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3. </font><font style="vertical-align: inherit;">Algebraische Angriffe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algebraische Angriffe wurden verwendet </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um den Erfolg bei der Anwendung auf Stream-Chiffren </font><b><font style="vertical-align: inherit;">zu</font></b><font style="vertical-align: inherit;"> verringern, als um sie zu blockieren. Die einfache Struktur von PRESENT bedeutet jedoch, dass sie ernsthaft untersucht werden müssen. Der PRESENT S-Block wird durch 21 quadratische Gleichungen für acht Eingangs- / Ausgangsbitvariablen über Feld G (2) beschrieben. Dies ist nicht überraschend, da bekannt ist, dass jeder Vier-Bit-S-Block durch mindestens 21 solcher Gleichungen beschrieben werden kann. Dann kann die gesamte Chiffre durch quadratische Gleichungen e = n × 21 in den Variablen v = n × 8 beschrieben werden, wobei n die Anzahl der S-Blöcke im Verschlüsselungs- und Schlüsseltransformationsalgorithmus ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für PRESENT haben wir n = (31 × 16) + 31, also besteht das gesamte System aus 11.067 quadratischen Gleichungen in 4.216 Variablen. Das allgemeine Problem der Lösung eines Systems mehrdimensionaler quadratischer Gleichungen ist NP-hart. Die für Blockchiffren erhaltenen Systeme sind jedoch sehr selten, da sie aus n kleinen Systemen bestehen, die durch einfache lineare Schichten verbunden sind. Es ist jedoch nicht klar, ob diese Tatsache für den sogenannten algebraischen Angriff verwendet werden kann. Es wurden einige spezielle Methoden vorgeschlagen, wie z. B. XL und XSL, obwohl bei beiden Methoden Mängel festgestellt wurden. Stattdessen wurden die einzigen praktischen Ergebnisse zur algebraischen Kryptoanalyse von Blockchiffren durch Anwendung der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buchberger-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">F4-</font></a><font style="vertical-align: inherit;"> Algorithmen erhalten.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als Teil von Magma. Die Modellierung an kleinen Versionen von AES zeigte, dass für alle außer den kleinsten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SP-Netzwerken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schnell Schwierigkeiten sowohl in Bezug auf die Zeit als auch auf die Speicherkomplexität auftreten. Gleiches gilt für PRESENT. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Praktische Bestätigung.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben Simulationen mit kleinen Versionen unter Verwendung des F4-Algorithmus in Magma durchgeführt. </font><font style="vertical-align: inherit;">Wenn es einen S-Block gibt, dh einen sehr kleinen Block mit einer Größe von vier Bits, kann Magma das resultierende Gleichungssystem in vielen Runden lösen. </font><font style="vertical-align: inherit;">Wenn jedoch die Blockgröße zunimmt und S-Blöcke zusammen mit der entsprechenden Variante der linearen Diffusionsschicht hinzugefügt werden, wird das Gleichungssystem bald zu groß. </font><font style="vertical-align: inherit;">Selbst wenn wir ein System in Betracht ziehen, das aus sieben S-Blöcken besteht, dh eine Blockgröße von 28 Bit hat, konnten wir nicht innerhalb einer angemessenen Zeit eine Lösung für die verkürzte Verschlüsselungsversion finden, die zwei Runden bestanden hat. </font><font style="vertical-align: inherit;">Unsere Analyse zeigt, dass algebraische Angriffe wahrscheinlich keine Bedrohung für PRESENT darstellen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.4. </font><font style="vertical-align: inherit;">Key Conversion-Angriffe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da es keine festgelegten Richtlinien für die Entwicklung von Schlüsseltransformationen gibt, gibt es sowohl eine Vielzahl von Projekten als auch eine Vielzahl von Angriffen, die auf den Merkmalen des Projekts basieren. </font><font style="vertical-align: inherit;">Die effektivsten Angriffe fallen unter die allgemeine Überschrift </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angriff auf verwandte Schlüssel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scherangriff</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und beide basieren auf der Konstruktion identifizierbarer Beziehungen zwischen verschiedenen Sätzen von Unterschlüsseln. </font><font style="vertical-align: inherit;">Um dieser Bedrohung entgegenzuwirken, verwenden wir einen rundenabhängigen Zähler, sodass Unterschlüsselsätze nicht einfach „verschoben“ werden können, und wir verwenden eine nichtlineare Operation, um den Inhalt des Schlüsselregisters K zu mischen. Insbesondere:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Bits im Schlüsselregister sind eine nichtlineare Funktion des 80-Bit-Schlüssels, den der Benutzer für Runde 21 bereitgestellt hat.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dass jedes Bit im Schlüsselregister nach Runde 21 von mindestens vier der vom Benutzer bereitgestellten Schlüsselbits abhängt, und</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis wir K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32 erhalten</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sind sechs Bits Ausdrücke des zweiten Grades von 80 vom Benutzer bereitgestellten Schlüsselbits, 24 Bits sind Grad drei, während die verbleibenden Bits eine Funktion der vom Benutzer bereitgestellten Schlüsselbits des Grades sechs oder neun sind.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir glauben, dass diese Eigenschaften ausreichen, um Schlüsselangriffen auf der Grundlage der Schlüsselkonvertierung standzuhalten.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Produktivität von "Eisen"</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben PRESENT-80 in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VHDL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementiert </font><font style="vertical-align: inherit;">und es für die standardmäßige Virtual Silicon Cell Library (VST) basierend auf der UMC L180 0.18 μ 1P6M Logic angepasst. Wir verwendeten die Mentor Graphics Modelsim SE PLUS 5.8 c für die Simulation und Synopsys Design Compilerversion Y-2006.06 für die Synthese und Modellierung des Stromverbrauchs. Es wurden typische Werte für die Gießerei verwendet (1,8 Volt für die Kernspannung und 25 ° C für die Temperatur), und das vorgeschlagene Modell der Drahtbelastung wurde zur Modellierung der Leistung verwendet. Bitte beachten Sie, dass eine solche Simulation für Strukturen um 10.000 GE vorgesehen ist, sodass die Leistungsergebnisse für viel kleinere Strukturen pessimistisch sind. Auf dem Bild</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tt/8i/bg/tt8ibga5aprmwzqrrckekekzv2a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der gezeigte Datenpfad ist platzoptimiert PRESENT-80 ohne die Möglichkeit der Entschlüsselung (nur Verschlüsselung), die eine Runde pro Zyklus ausführt, dh der Datenpfad ist 64 Bit breit. Bitte beachten Sie, dass wir in der Entwurfsphase von PRESENT 16 Mal denselben S-Block verwenden, anstatt 16 verschiedene S-Blöcke zu haben, und dies erleichtert die weitere Serialisierung des Projekts, d. H. Mit einem 4-Bit-Datenkanal. Unsere Implementierung erfordert 32 Taktzyklen zum Verschlüsseln von 64-Bit-Klartext mit einem 80-Bit-Schlüssel, benötigt 1570 GE und hat einen Stromverbrauch von 5 MikW bei der Modulation. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ek/7o/xq/ek7oxqtiawboi4wjqqrivgxvzmy.png"><br>
<br>
<em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Räumliche Anforderungen PRÄSENTIEREN</font></font></sup></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der größte Teil des Bereichs wird von Triggern zum Speichern des Schlüssel- und Datenstatus belegt, gefolgt von der S-Schicht und der XOR-Schlüsselabteilung. </font><font style="vertical-align: inherit;">Einfache Permutationsbitpermutationen vergrößern den Bereich nur, wenn die Implementierung die Orts- und Routenstufe erreicht. </font><font style="vertical-align: inherit;">Beachten Sie, dass das Hauptziel unserer Implementierung eine kleine Menge an Hardware war. Wir haben jedoch auch einen auf Leistung optimierten Prozess synthetisiert. </font><font style="vertical-align: inherit;">Für weitere 53 GE erreichen wir einen Energieverbrauch von nur 3,3 μW, und der Strom 128 wird eine geschätzte Fläche von 1886 GE einnehmen. </font><font style="vertical-align: inherit;">Zusätzlich zu seiner sehr geringen Größe hat PRESENT einen ziemlich hohen Durchsatz und liefert eine gute Energie pro Bit. </font><font style="vertical-align: inherit;">Der Vergleich mit anderen Chiffren ist in der Tabelle angegeben:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m9/yt/7j/m9yt7jonvvcpkjnluz273z1ksga.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Fazit</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel haben wir die neue PRESENT-Blockverschlüsselung beschrieben. </font><font style="vertical-align: inherit;">Unser Ziel war eine ultraleichte Verschlüsselung, die ein Sicherheitsniveau bietet, das der Größe eines 64-Bit-Blocks und eines 80-Bit-Schlüssels entspricht. </font><font style="vertical-align: inherit;">Infolgedessen hat PRESENT ähnliche Implementierungsanforderungen wie viele kompakte Stream-Chiffren. </font><font style="vertical-align: inherit;">Wir glauben daher, dass dies sowohl von theoretischem als auch von praktischem Interesse ist. </font><font style="vertical-align: inherit;">Wie bei allen neuen Vorschlägen empfehlen wir nicht die sofortige Einführung von PRESENT, sondern fordern dessen Analyse.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bekenntnis</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die in diesem Dokument vorgestellten Arbeiten wurden teilweise von der Europäischen Kommission durch STREP UbiSec &amp; Sens des EU-Rahmenprogramms 6 für Forschung und Entwicklung (www.ist-ubisecsens.org) unterstützt. </font><font style="vertical-align: inherit;">Die in diesem Dokument enthaltenen Meinungen und Schlussfolgerungen sind die der Autoren und sollten nicht als offizielle Politik oder Bestätigung interpretiert werden, die vom UbiSec &amp; Sens-Projekt oder der Europäischen Kommission zum Ausdruck gebracht oder gebilligt wird.</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de487524/index.html">Warum braucht ein Hardware-Startup-Hackathon?</a></li>
<li><a href="../de487528/index.html">Изменения в пользовательском соглашении и политике конфиденциальности на сервисах Хабра</a></li>
<li><a href="../de487534/index.html">etcd 3.4.3: Speicherzuverlässigkeits- und Sicherheitsforschung</a></li>
<li><a href="../de487538/index.html">.NET Interactive ist da! | .NET Notebooks Vorschau 2</a></li>
<li><a href="../de487540/index.html">HighLoad ++, Anastasia Tsymbalyuk, Stanislav Tselovalnikov (Sberbank): Wie wir zu MDA wurden</a></li>
<li><a href="../de487544/index.html">.NET-Dokumentation: Was ist neu im Januar?</a></li>
<li><a href="../de487548/index.html">Neues Experiment: Aufrufen von .NET gRPC-Diensten über einen Browser mit gRPC-Web</a></li>
<li><a href="../de487550/index.html">3D-Bild in Python mit (fast) normaler Leistung</a></li>
<li><a href="../de487552/index.html">Swift 5.2 - was ist neu?</a></li>
<li><a href="../de487556/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 497 (21.01.2020 - 27.01.2020)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>