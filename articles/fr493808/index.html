<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóª üë®üèø‚Äç‚öïÔ∏è üéâ Lin√©arisation de code asynchrone avec de la corutine üçÇ ü§Æ üîí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En plus d'utiliser coroutine pour cr√©er des g√©n√©rateurs, vous pouvez essayer de les utiliser pour lin√©ariser le code asynchrone existant. Essayons de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Lin√©arisation de code asynchrone avec de la corutine</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/493808/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98e/c7c/314/98ec7c314c49b57c2d8af8d53508b211.jpg" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus d'utiliser coroutine pour cr√©er des g√©n√©rateurs, vous pouvez essayer de les utiliser pour lin√©ariser le code asynchrone existant. </font><font style="vertical-align: inherit;">Essayons de le faire avec un petit exemple. </font><font style="vertical-align: inherit;">Prenez le code √©crit sur le framework d'acteur et r√©√©crivez une fonction de ce code sur les coroutines. </font><font style="vertical-align: inherit;">Pour construire le projet, nous utiliserons gcc de la branche </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coroutines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre objectif est d'obtenir des rappels de nouilles:</font></font><br>
<br>
<pre><code class="cpp hljs">    abActor.getA(ABActor::GetACallback([<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
        abActor.getB(ABActor::GetBCallback([a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {<font></font>
            abActor.saveAB(a - b, a + b, ABActor::SaveABCallback([<span class="hljs-keyword">this</span>](){<font></font>
                abActor.getA(ABActor::GetACallback([<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
                    abActor.getB(ABActor::GetBCallback([a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
                    }));<font></font>
                }));<font></font>
            }));<font></font>
        }));<font></font>
    }));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sorte de:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync();
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync();
<span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(a - b, a + b);
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync();
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync();
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, commen√ßons.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acteurs</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, nous devons cr√©er un cadre d'acteur simple. </font><font style="vertical-align: inherit;">La cr√©ation d'un cadre d'acteur √† part enti√®re est une t√¢che difficile et importante, nous n'en impl√©mentons donc qu'une sorte. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cr√©ez d'abord une classe de base:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actor</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> Task = <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt;;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~Actor();
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Task &amp;task)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tryRunTask</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;Task&gt; <span class="hljs-built_in">queue</span>;
    <span class="hljs-keyword">mutable</span> <span class="hljs-built_in">std</span>::mutex mutex;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'id√©e est fondamentalement simple: nous mettons des t√¢ches qui sont des objets fonctionnels dans une file d'attente, et lorsque nous essayons RunTask, nous essayons de terminer cette t√¢che. </font><font style="vertical-align: inherit;">La mise en place du cours confirme nos intentions:</font></font><br>
<br>
<pre><code class="cpp hljs">Actor::~Actor() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Actor::addTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Task &amp;task)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;
    <span class="hljs-built_in">queue</span>.push(task);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Actor::tryRunTask</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>.empty()) {
        <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">const</span> Task task = <span class="hljs-built_in">queue</span>.front();
    <span class="hljs-built_in">queue</span>.pop();<font></font>
    lock.unlock();<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::invoke(task);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe suivante est le "fil" auquel nos acteurs appartiendront:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actor</span>;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActorThread</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
    ~ActorThread();<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addActor</span><span class="hljs-params">(Actor &amp;actor)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::reference_wrapper&lt;Actor&gt;&gt; actors;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici aussi, tout est simple: au tout d√©but du programme, nous ¬´lions¬ª nos acteurs au thread en utilisant la m√©thode addActor, puis nous d√©marrons le thread en utilisant la m√©thode run.</font></font><br>
<br>
<pre><code class="cpp hljs">ActorThread::~ActorThread() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ActorThread::addActor</span><span class="hljs-params">(Actor &amp;actor)</span> </span>{<font></font>
    actors.emplace_back(actor);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ActorThread::run</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">for</span> (Actor &amp;actor: actors) {<font></font>
            actor.tryRunTask();<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors du d√©marrage du thread, nous entrons dans une boucle infinie et essayons d'effectuer une t√¢che de chaque acteur. </font><font style="vertical-align: inherit;">Ce n'est pas la meilleure solution, mais cela fera l'affaire pour une d√©monstration. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant le repr√©sentant de la classe d'acteurs:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABActor</span>:</span> <span class="hljs-keyword">public</span> Actor {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> GetACallback = Callback&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> result)&gt;;
    <span class="hljs-keyword">using</span> GetBCallback = Callback&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> result)&gt;;
    <span class="hljs-keyword">using</span> SaveABCallback = Callback&lt;<span class="hljs-keyword">void</span>()&gt;;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getA</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getB</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveAB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getAProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getBProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveABProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette classe stocke 2 nombres en elle-m√™me - a et b, et, sur demande, renvoie leurs valeurs ou les remplace. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En rappel, il accepte un objet fonctionnel avec les param√®tres n√©cessaires. </font><font style="vertical-align: inherit;">Mais faisons attention au fait que diff√©rents acteurs peuvent √™tre lanc√©s dans diff√©rents threads. </font><font style="vertical-align: inherit;">Et par cons√©quent, si √† la fin du travail, nous appelons simplement le rappel pass√© √† la m√©thode, ce rappel sera appel√© dans le thread ex√©cutable actuel, et non dans le thread qui a appel√© notre m√©thode et cr√©√© ce rappel. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons cr√©er un wrapper sur le rappel qui r√©soudra cette situation:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Callback</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Functor&gt;
    <span class="hljs-title">Callback</span><span class="hljs-params">(Actor &amp;sender, <span class="hljs-keyword">const</span> Functor &amp;callback)</span>
        : <span class="hljs-title">sender</span><span class="hljs-params">(sender)</span>
        , <span class="hljs-title">callback</span><span class="hljs-params">(callback)</span>
    </span>{}
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Args&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(Args&amp;&amp; ...args)</span> <span class="hljs-keyword">const</span> </span>{<font></font>
        sender.addTask(<span class="hljs-built_in">std</span>::bind(callback, <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...));<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:<font></font>
    Actor &amp;sender;<font></font>
    <span class="hljs-built_in">std</span>::function&lt;C&gt; callback;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce wrapper se souvient de l'acteur d'origine, et lorsque vous essayez de vous ex√©cuter, il ajoute simplement un v√©ritable rappel √† la file d'attente des t√¢ches de l'acteur d'origine. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par cons√©quent, l'impl√©mentation de la classe ABActor ressemble √† ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getA</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getAProcess, <span class="hljs-keyword">this</span>, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getAProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ABActor::GetACallback &amp;callback)</span> </span>{
    <span class="hljs-built_in">std</span>::invoke(callback, a);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getB</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getBProcess, <span class="hljs-keyword">this</span>, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getBProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ABActor::GetBCallback &amp;callback)</span> </span>{
    <span class="hljs-built_in">std</span>::invoke(callback, b);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::saveAB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::saveABProcess, <span class="hljs-keyword">this</span>, a, b, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::saveABProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> ABActor::SaveABCallback &amp;callback)</span> </span>{
    <span class="hljs-keyword">this</span>-&gt;a = a;
    <span class="hljs-keyword">this</span>-&gt;b = b;
    <span class="hljs-built_in">std</span>::invoke(callback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la m√©thode d'interface de la classe, nous lions simplement les arguments pass√©s au ¬´slot¬ª correspondant de la classe, cr√©ant ainsi une t√¢che, et pla√ßons cette t√¢che dans la file d'attente des t√¢ches de cette classe. </font><font style="vertical-align: inherit;">Lorsque le thread de t√¢che commence √† ex√©cuter la t√¢che, il appellera ainsi le ¬´slot¬ª correct, qui effectuera toutes les actions dont il a besoin et appellera le rappel, qui √† son tour enverra le rappel r√©el √† la file d'attente de la t√¢che qui l'a provoqu√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√âcrivons un acteur qui utilisera la classe ABActor:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABActor</span>;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WokrerActor</span>:</span> <span class="hljs-keyword">public</span> Actor {
<span class="hljs-keyword">public</span>:<font></font>
    WokrerActor(ABActor &amp;actor)<font></font>
        : abActor(actor)<font></font>
    {}<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">workProcess</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:<font></font>
    ABActor &amp;abActor;<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::work</span><span class="hljs-params">()</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;WokrerActor::workProcess, <span class="hljs-keyword">this</span>));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{<font></font>
    abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    }));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et tout mettre ensemble:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<font></font>
    ABActor abActor;<font></font>
    <span class="hljs-function">WokrerActor <span class="hljs-title">workerActor</span><span class="hljs-params">(abActor)</span></span>;<font></font>
<font></font>
    ActorThread thread;<font></font>
    thread.addActor(abActor);<font></font>
    thread.addActor(workerActor);<font></font>
<font></font>
    workerActor.work();<font></font>
<font></font>
    thread.run();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suivons toute la cha√Æne de code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au d√©but, nous cr√©ons les objets n√©cessaires et √©tablissons des connexions entre eux. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous ajoutons la t√¢che workProcess √† la file d'attente des t√¢ches d'acteur Worker. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque le thread d√©marre, il trouvera notre t√¢che dans la file d'attente et commencera √† l'ex√©cuter. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le processus d'ex√©cution, nous appelons la m√©thode getA de la classe ABActor, pla√ßant ainsi la t√¢che correspondante dans la file d'attente de la classe ABActor, et terminons l'ex√©cution. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, le thread prendra la t√¢che nouvellement cr√©√©e de la classe ABActor et l'ex√©cutera, ce qui conduira √† l'ex√©cution du code getAProcess.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce code appellera un rappel, en lui passant l'argument n√©cessaire - la variable a. Mais puisque le rappel qu'il poss√®de est un wrapper, en fait, un vrai rappel avec des param√®tres remplis sera mis dans la file d'attente de la classe Worker. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et lorsque, √† la prochaine it√©ration du cycle, le thread se retire et ex√©cute notre rappel de la classe Worker, nous verrons la sortie de la ligne ¬´R√©sultat 10¬ª</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le framework d'acteur est un moyen assez pratique d'interagir avec des classes dispers√©es √† travers diff√©rents flux physiques. La particularit√© de la conception des classes, comme vous auriez d√ª en √™tre convaincu, est qu'au sein de chaque acteur individuel, toutes les actions sont ex√©cut√©es enti√®rement et dans un seul fil. Le seul point de synchronisation des flux est fait dans les d√©tails d'impl√©mentation du framework acteur et n'est pas visible pour le programmeur. Ainsi, un programmeur peut √©crire du code √† un seul thread sans se soucier de boucler les mutex et de suivre les situations de course, les blocages et autres maux de t√™te. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, cette solution a un prix. √âtant donn√© que le r√©sultat de l'ex√©cution d'un autre acteur n'est accessible qu'√† partir du rappel, t√¥t ou tard le code de l'acteur se transforme en quelque chose comme ceci:</font></font><br>
<br>
<pre><code class="cpp hljs">    abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
        abActor.getB(ABActor::GetBCallback(*<span class="hljs-keyword">this</span>, [a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {<font></font>
            abActor.saveAB(a - b, a + b, ABActor::SaveABCallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](){<font></font>
                abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
                    abActor.getB(ABActor::GetBCallback(*<span class="hljs-keyword">this</span>, [a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
                    }));<font></font>
                }));<font></font>
            }));<font></font>
        }));<font></font>
    }));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons si nous pouvons √©viter cela en utilisant l'innovation de C ++ 20 - coroutines. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais d'abord, nous pr√©ciserons les limitations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Naturellement, nous ne pouvons en aucun cas changer le code du framework acteur. </font><font style="vertical-align: inherit;">De plus, nous ne pouvons pas modifier les signatures des m√©thodes publiques et priv√©es des instances de la classe Actor - ABActor et WorkerActor. </font><font style="vertical-align: inherit;">Voyons voir si nous pouvons sortir de cette situation.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutines. </font><font style="vertical-align: inherit;">Partie 1. Awaiter</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'id√©e principale de la corutine est que lors de la cr√©ation de la coroutine, un cadre de pile distinct est cr√©√© pour elle sur le tas, √† partir duquel nous pouvons "quitter" √† tout moment, tout en conservant la position d'ex√©cution actuelle, les registres du processeur et d'autres informations n√©cessaires. Ensuite, nous pouvons √©galement √† tout moment revenir √† l'ex√©cution de la coroutine suspendue et la terminer jusqu'√† la fin ou jusqu'√† la prochaine suspension. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'objet std :: coroutine_handle &lt;&gt; est responsable de la gestion de ces donn√©es, qui repr√©sentent essentiellement un pointeur vers le cadre de pile (et d'autres donn√©es n√©cessaires), et qui a une m√©thode de reprise (ou son analogue, l'op√©rateur ()), qui nous renvoie √† l'ex√©cution de la coroutine . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur la base de ces donn√©es, √©crivons d'abord la fonction getAAsync, puis essayons de g√©n√©raliser.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, supposons que nous ayons d√©j√† une instance de la classe coro std :: coroutine_handle &lt;&gt;, que devons-nous faire? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez appeler la m√©thode ABActor :: getA d√©j√† existante, ce qui r√©soudra la situation au besoin, mais vous devez d'abord cr√©er un rappel pour la m√©thode getA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rappelons qu'un rappel est renvoy√© au rappel de la m√©thode getA - le r√©sultat de la m√©thode getA. En outre, ce rappel est appel√© dans le thread de travail du thread. Ainsi, √† partir de ce rappel, nous pouvons continuer en toute s√©curit√© √† ex√©cuter la coroutine, qui a √©t√© cr√©√©e uniquement √† partir du thread Worker et qui continuera √† ex√©cuter sa s√©quence d'actions. Mais aussi, nous devons quelque part sauvegarder le r√©sultat retourn√© dans le rappel, cela, bien s√ªr, nous sera utile plus loin.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> callback = GetACallback(returnCallbackActor, [&amp;value, coro](<span class="hljs-keyword">int</span> result) {<font></font>
        value = result;<font></font>
        <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
 });<font></font>
getA(callback);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, maintenant vous devez prendre une instance de l'objet coroutine_handle quelque part et un lien o√π vous pouvez enregistrer notre r√©sultat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä l'avenir, nous verrons que coroutine_handle nous est transmis suite √† l'appel de la fonction. </font><font style="vertical-align: inherit;">En cons√©quence, tout ce que nous pouvons en faire est de le transmettre √† une autre fonction. </font><font style="vertical-align: inherit;">Pr√©parons cette fonction en tant que lambda. </font><font style="vertical-align: inherit;">(Nous transmettrons le lien √† la variable o√π le r√©sultat du rappel sera stock√© dans l'entreprise).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> storeCoroToQueue = [&amp;returnCallbackActor, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">auto</span> &amp;value, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro) {
    <span class="hljs-keyword">auto</span> callback=GetACallback(returnCallbackActor, [&amp;value, coro](<span class="hljs-keyword">int</span> result){<font></font>
        value = result;<font></font>
        <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
    });<font></font>
    getA(callback);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous enregistrerons cette fonction dans la classe suivante.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorAwaiterSimple</span> {</span>
    <span class="hljs-keyword">int</span> value;<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> &amp;value,<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; forwardCoroToCallback;<font></font>
<font></font>
    ActorAwaiterSimple(<font></font>
        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> &amp;value, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; &amp;forwardCoroToCallback<font></font>
    )<font></font>
        : forwardCoroToCallback(forwardCoroToCallback)<font></font>
    {}<font></font>
<font></font>
    ActorAwaiterSimple(<span class="hljs-keyword">const</span> ActorAwaiterSimple &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> ActorAwaiterSimple &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple(ActorAwaiterSimple &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple&amp; <span class="hljs-keyword">operator</span>=(ActorAwaiterSimple &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
<span class="hljs-comment">// ...</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de l'objet fonctionnel, nous tiendrons √©galement ici la m√©moire (sous forme de valeur variable) de la valeur qui nous attend dans le rappel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque nous maintenons la m√©moire sous la valeur ici, nous voulons √† peine que l'instance de cette classe soit copi√©e ou d√©plac√©e quelque part. Imaginez, par exemple, que quelqu'un copie cette classe, enregistre la valeur sous la variable de valeur dans l'ancienne instance de la classe, puis essaie de la lire √† partir de la nouvelle instance. Et ce n'est naturellement pas l√†, car la copie a eu lieu avant l'enregistrement. D√©sagr√©able. Par cons√©quent, nous nous prot√©geons de ce probl√®me en interdisant les constructeurs et les op√©rateurs de copie et de d√©placement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Continuons √† √©crire cette classe. La prochaine m√©thode dont nous avons besoin est:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il r√©pond √† la question de savoir si notre sens est pr√™t √† √™tre √©mis. </font><font style="vertical-align: inherit;">Naturellement, au premier appel, notre valeur n'est pas encore pr√™te, et √† l'avenir, personne ne nous posera de questions √† ce sujet, alors renvoyez simplement false. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'instance coroutine_handle nous sera transmise dans la m√©thode void wait_suspend (std :: coroutine_handle &lt;&gt; coro), appelons-y notre foncteur pr√©par√©, en y passant √©galement un lien m√©moire sous value:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro)</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-built_in">std</span>::invoke(forwardCoroToCallback, <span class="hljs-built_in">std</span>::ref(value), coro);<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le r√©sultat de l'ex√©cution de la fonction sera demand√© au bon moment en appelant la m√©thode expect_resume. </font><font style="vertical-align: inherit;">Nous ne refuserons pas au demandeur:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> value;<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, notre m√©thode peut √™tre appel√©e √† l'aide du mot cl√© co_await:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce qui va se passer ici, nous le repr√©sentons d√©j√† √† peu pr√®s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, un objet de type ActorAwaiterSimple sera cr√©√©, qui sera transf√©r√© √† "l'entr√©e" de co_await. Il demandera d'abord (en appelant attend_ready) si nous avons accidentellement un r√©sultat fini (nous n'en avons pas), puis appellera wait_suspend, en passant dans un contexte (en fait, un pointeur vers le cadre de pile de coroutine actuel) et interrompra l'ex√©cution. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä l'avenir, lorsque l'acteur ABActor terminera son travail et appellera le rappel du r√©sultat, ce r√©sultat (d√©j√† dans le thread de thread de travail) sera enregistr√© dans la seule instance (restant sur la pile de coroutine) d'ActorAwaiterSimple et la poursuite de la coroutine commencera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Corutin poursuivra l'ex√©cution, prendra le r√©sultat enregistr√© en appelant la m√©thode expect_resume et passera ce r√©sultat √† la variable a</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä l'heure actuelle, la limitation de l'Awaiter actuel est qu'il ne peut fonctionner qu'avec des rappels avec un param√®tre de type int. </font><font style="vertical-align: inherit;">Essayons d'√©tendre l'application d'Awaiter:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorAwaiter</span> {</span><font></font>
<font></font>
    <span class="hljs-built_in">std</span>::tuple&lt;T...&gt; values;<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-built_in">std</span>::tuple&lt;T...&gt; &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; storeHandler;<font></font>
<font></font>
    ActorAwaiter(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-built_in">std</span>::tuple&lt;T...&gt; &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; &amp;storeHandler)<font></font>
        : storeHandler(storeHandler)<font></font>
    {}<font></font>
<font></font>
    ActorAwaiter(<span class="hljs-keyword">const</span> ActorAwaiter &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> ActorAwaiter &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter(ActorAwaiter &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter&amp; <span class="hljs-keyword">operator</span>=(ActorAwaiter &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro)</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-built_in">std</span>::invoke(storeHandler, <span class="hljs-built_in">std</span>::ref(values), coro);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len==<span class="hljs-number">0</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-keyword">void</span> await_resume() <span class="hljs-keyword">noexcept</span> {<font></font>
<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len==<span class="hljs-number">1</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-keyword">auto</span> await_resume() <span class="hljs-keyword">noexcept</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">0</span>&gt;(values);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len!=<span class="hljs-number">1</span> &amp;&amp; len!=<span class="hljs-number">0</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-built_in">std</span>::tuple&lt;T...&gt; await_resume() <span class="hljs-keyword">noexcept</span> {
        <span class="hljs-keyword">return</span> values;<font></font>
    }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous utilisons std :: tuple afin de pouvoir enregistrer plusieurs variables √† la fois. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sfinae est impos√© √† la m√©thode wait_resume de sorte qu'il est possible de ne pas retourner un tuple dans tous les cas, mais en fonction du nombre de valeurs se trouvant dans le tuple, return void, exactement 1 argument ou le tuple entier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les enveloppes pour cr√©er Awaiter lui-m√™me ressemblent maintenant √† ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> MakeCallback, <span class="hljs-keyword">typename</span>... ReturnArgs, <span class="hljs-keyword">typename</span> Func&gt;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">makeCoroCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Func &amp;func, Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> [&amp;returnCallback, func](<span class="hljs-keyword">auto</span> &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro) {
        <span class="hljs-keyword">auto</span> callback = MakeCallback(returnCallback, [&amp;values, coro](ReturnArgs&amp;&amp; ...result) {<font></font>
            values = <span class="hljs-built_in">std</span>::make_tuple(<span class="hljs-built_in">std</span>::forward&lt;ReturnArgs&gt;(result)...);
            <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
        });<font></font>
        func(callback);<font></font>
    };<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> MakeCallback, <span class="hljs-keyword">typename</span>... ReturnArgs, <span class="hljs-keyword">typename</span> Func&gt;
<span class="hljs-keyword">static</span> ActorAwaiter&lt;ReturnArgs...&gt; <span class="hljs-title">makeActorAwaiter</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Func &amp;func, Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> storeCoroToQueue = makeCoroCallback&lt;MakeCallback, ReturnArgs...&gt;(func, returnCallback);
    <span class="hljs-keyword">return</span> ActorAwaiter&lt;ReturnArgs...&gt;(storeCoroToQueue);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getAAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;GetACallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getA, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getBAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;GetBCallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getB, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;&gt; <span class="hljs-title">ABActor::saveABAsync</span><span class="hljs-params">(Actor &amp;returnCallback, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;SaveABCallback&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::saveAB, <span class="hljs-keyword">this</span>, a, b, _1), returnCallback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant comment utiliser le type cr√©√© directement dans coroutine.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutines. </font><font style="vertical-align: inherit;">Partie 2. Reprise</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Du point de vue du C ++, une fonction qui contient les mots co_await, co_yield ou co_return est consid√©r√©e comme coroutine. Mais une telle fonction devrait √©galement renvoyer un certain type. Nous avons convenu que nous ne changerons pas la signature des fonctions (ici, je veux dire que le type de retour fait √©galement r√©f√©rence √† la signature), nous devrons donc en sortir d'une mani√®re ou d'une autre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cr√©ons une coroutine lambda et appelons-la depuis notre fonction:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Pourquoi ne pas capturer cela dans la liste de capture des lambdas? Ensuite, tout le code √† l'int√©rieur serait un peu plus facile. Mais il se trouve que, apparemment, les lambda-coroutines du compilateur ne sont pas encore enti√®rement prises en charge, donc ce code ne fonctionnera pas.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, notre le code de rappel effrayant est maintenant devenu un code lin√©aire assez agr√©able. </font><font style="vertical-align: inherit;">Il ne nous reste plus qu'√† inventer la classe ActorResumable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinons-la.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorResumable</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">promise_type</span> {</span>
        <span class="hljs-keyword">using</span> coro_handle = <span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>{ 
            <span class="hljs-comment">//  ,    ActorResumable   promise_type</span>
            <span class="hljs-keyword">return</span> coro_handle::from_promise(*<span class="hljs-keyword">this</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//      </span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::suspend_never();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//      . </span>
            <span class="hljs-comment">// ,     </span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::suspend_never();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//   ,       </span>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">terminate</span>();<font></font>
        }<font></font>
    };<font></font>
<font></font>
    ActorResumable(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;) {}<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le pseudocode de la corutine g√©n√©r√©e √† partir de notre lambda ressemble √† ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ActorResumable <span class="hljs-title">coro</span><span class="hljs-params">()</span> </span>{<font></font>
    promise_type promise;<font></font>
    ActorResumable retobj = promise.get_return_object();<font></font>
    <span class="hljs-keyword">auto</span> intial_suspend = promise.initial_suspend();
    <span class="hljs-keyword">if</span> (initial_suspend == <span class="hljs-built_in">std</span>::suspend_always)  {
          <span class="hljs-comment">// yield</span><font></font>
    }<font></font>
    <span class="hljs-keyword">try</span> { 
        <span class="hljs-comment">//  .</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    } <span class="hljs-keyword">catch</span>(...) { <font></font>
        promise.unhandled_exception();<font></font>
    }<font></font>
final_suspend:<font></font>
    <span class="hljs-keyword">auto</span> final_suspend = promise.final_suspend();
    <span class="hljs-keyword">if</span> (final_suspend == <span class="hljs-built_in">std</span>::suspend_always)  {
         <span class="hljs-comment">// yield</span>
    } <span class="hljs-keyword">else</span> {<font></font>
         cleanup();<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce n'est qu'un pseudo-code, certaines choses sont intentionnellement simplifi√©es. </font><font style="vertical-align: inherit;">Voyons n√©anmoins ce qui se passe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous cr√©ons d'abord une promesse et ActorResumable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s initial_suspend (), nous ne faisons pas de pause, mais continuons. </font><font style="vertical-align: inherit;">Nous commen√ßons √† ex√©cuter la partie principale du programme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque nous arrivons √† co_await, nous comprenons que nous devons faire une pause. </font><font style="vertical-align: inherit;">Nous avons d√©j√† examin√© cette situation dans la section pr√©c√©dente, vous pouvez y revenir et l'examiner. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s avoir poursuivi l'ex√©cution et affich√© le r√©sultat √† l'√©cran, l'ex√©cution de la coroutine se termine. </font><font style="vertical-align: inherit;">Nous v√©rifions final_suspend et effa√ßons tout le contexte de la coroutine.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutines. </font><font style="vertical-align: inherit;">Partie 3. T√¢che</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Souvenons-nous du stade que nous avons atteint.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il a l'air bien, mais il est facile de voir que le code:</font></font><br>
<br>
<pre><code class="cpp hljs">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
r√©p√©t√© 2 fois. </font><font style="vertical-align: inherit;">Est-il possible de refactoriser ce moment et de le mettre dans une fonction distincte? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons √† quoi cela pourrait ressembler:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">CoroTask&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">WokrerActor::readAB</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> abActor.getAAsync2(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> abActor.getBAsync2(*<span class="hljs-keyword">this</span>);
    <span class="hljs-function"><span class="hljs-keyword">co_return</span> <span class="hljs-title">std::make_pair</span><span class="hljs-params">(a, b)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workCoroProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [a, b] = <span class="hljs-keyword">co_await</span> actor.readAB();
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync2(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [newA, newB] = <span class="hljs-keyword">co_await</span> actor.readAB();
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il ne nous reste plus qu'√† inventer le type CoroTask. </font><font style="vertical-align: inherit;">R√©fl√©chissons-y. </font><font style="vertical-align: inherit;">Tout d'abord, co_return est utilis√© √† l'int√©rieur de la fonction readAB, ce qui signifie que CoroTask doit satisfaire l'interface Resumable. </font><font style="vertical-align: inherit;">Mais aussi, un objet de cette classe est utilis√© pour entrer co_await d'une autre coroutine. </font><font style="vertical-align: inherit;">Cela signifie que la classe CoroTask doit √©galement satisfaire l'interface Awaitable. </font><font style="vertical-align: inherit;">Impl√©mentons ces deux interfaces dans la classe CoroTask:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">void</span>&gt;<font></font>
struct CoroTask {<font></font>
    struct promise_type {<font></font>
        T result;<font></font>
        <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; waiter;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> CoroTask{*<span class="hljs-keyword">this</span>};<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">return_value</span><span class="hljs-params">(T value)</span> </span>{<font></font>
            result = value;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">terminate</span>();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-built_in">std</span>::suspend_always <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> {};<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">final_awaiter</span> {</span>
                <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>{}
                <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt; me)</span> </span>{
                    <span class="hljs-keyword">return</span> me.promise().waiter;<font></font>
                }<font></font>
            };<font></font>
            <span class="hljs-keyword">return</span> final_awaiter{};<font></font>
        }<font></font>
    };<font></font>
<font></font>
    CoroTask(CoroTask &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask&amp; <span class="hljs-keyword">operator</span>=(CoroTask&amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask(<span class="hljs-keyword">const</span> CoroTask&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> CoroTask&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
    ~CoroTask() {<font></font>
        <span class="hljs-keyword">if</span> (h) {<font></font>
            h.destroy();<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CoroTask</span><span class="hljs-params">(promise_type &amp; p)</span>
        : <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;::from_promise(p))</span>
    </span>{}<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">T <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">auto</span> &amp;result = h.promise().result;
        <span class="hljs-keyword">return</span> result;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; waiter)</span> </span>{<font></font>
        h.promise().waiter = waiter;<font></font>
        h.resume();<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt; h;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Je recommande fortement d'ouvrir l'image d'arri√®re-plan de ce message. √Ä l'avenir, cela vous aidera grandement.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, voyons ce qui se passe ici. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Acc√©dez √† la coroutine lambda et cr√©ez imm√©diatement la coroutine WokrerActor :: readAB. Mais apr√®s avoir cr√©√© cette coroutine, nous ne commen√ßons pas √† l'ex√©cuter (initial_suspend == suspend_always), ce qui nous oblige √† interrompre et revenir √† la coroutine lambda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. co_await lambda v√©rifie si readAB est pr√™t. Le r√©sultat n'est pas pr√™t (wait_ready == false), ce qui l'oblige √† passer son contexte √† la m√©thode CoroTask :: attendant_suspend. Ce contexte est enregistr√© dans CoroTask et la reprise des coroutines readAB </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. </font><font style="vertical-align: inherit;">est lanc√©e </font><font style="vertical-align: inherit;">. Une fois que readAB coroutine a termin√© toutes les actions n√©cessaires, il atteint la ligne:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">co_return</span> <span class="hljs-title">std::make_pair</span><span class="hljs-params">(a, b)</span></span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
en cons√©quence, la m√©thode CoroTask :: promise_type :: return_value est appel√©e et la paire de nombres cr√©√©e est enregistr√©e dans CoroTask :: promise_type </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. Puisque la m√©thode co_return a √©t√© appel√©e, l'ex√©cution de la coroutine prend fin, ce qui signifie qu'il est temps d'appeler la m√©thode CoroTask :: promise_type :: final_suspend . Cette m√©thode renvoie une structure auto-√©crite (n'oubliez pas de regarder l'image), qui vous oblige √† appeler la m√©thode final_awaiter :: attendant_suspend, qui retourne le contexte lambda coroutine stock√© √† l'√©tape 2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi ne pourrions-nous pas simplement retourner suspend_always ici? Apr√®s tout, dans le cas de la suspension initiale de cette classe, avons-nous r√©ussi? Le fait est que dans initial_suspend nous avons r√©ussi parce que cette coroutine a √©t√© appel√©e par notre coroutine lambda, et nous y sommes revenus. Mais au moment o√π nous avons atteint l'appel final_suspend, notre coroutine a tr√®s probablement continu√© √† partir d'une autre pile (en particulier, √† partir du lambda que la fonction makeCoroCallback a pr√©par√©), et si nous renvoyions suspend_always ici, nous y retournerions, et non √† la m√©thode workCoroProcess. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5. Puisque la m√©thode final_awaiter :: attendant_suspend nous a renvoy√© le contexte, cela force le programme √† continuer d'ex√©cuter le contexte retourn√©, c'est-√†-dire la coroutine lambda. Depuis que l'ex√©cution est revenue au point:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [a, b] = <span class="hljs-keyword">co_await</span> actor.readAB();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nous devons ensuite isoler le r√©sultat enregistr√© en appelant la m√©thode CoroTask :: attendant_resume. Le r√©sultat est re√ßu, transmis aux variables a et b, et maintenant l'instance de CoroTask est d√©truite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6. L'instance CoroTask a √©t√© d√©truite, mais qu'est-il arriv√© au contexte WokrerActor :: readAB? Si nous, de CoroTask :: promise_type :: final_suspend, renverrions suspend_never (plus pr√©cis√©ment, renverrions cela √† la question en attente_deviendrait vrai), alors √† ce moment le contexte coroutine serait nettoy√©. Mais comme nous ne l'avons pas fait, l'obligation de clarifier le contexte nous est transf√©r√©e. Nous allons effacer ce contexte dans le destructeur CoroTask, √† ce stade, il est d√©j√† s√ªr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7. La coroutine readAB est ex√©cut√©e, le r√©sultat en est obtenu, le contexte est effac√©, la lambda coroutine continue de fonctionner ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ouf, en quelque sorte r√©gl√©. </font><font style="vertical-align: inherit;">Vous souvenez-vous qu'√† partir des m√©thodes ABActor :: getAAsync () et similaires, nous retournons une structure auto-√©crite? </font><font style="vertical-align: inherit;">En fait, la m√©thode getAAsync peut √©galement √™tre transform√©e en coroutine en combinant les connaissances acquises lors de l'impl√©mentation des classes CoroTask et ActorAwaiter et en obtenant quelque chose comme:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">CoroTaskActor&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getAAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">co_return</span> makeCoroCallback&lt;GetACallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getA, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mais je laisse cela pour l'auto-analyse.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©sultats</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, avec l'aide de coroutine, vous pouvez assez bien lin√©ariser le code de rappel asynchrone. </font><font style="vertical-align: inherit;">Certes, le processus d'√©criture des types et fonctions auxiliaires ne semble pas encore trop intuitif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout le code est disponible dans le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©f√©rentiel. Je</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
vous recommande √©galement de consulter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ces conf√©rences</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour une immersion plus compl√®te dans le sujet </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un grand nombre d'exemples sur le th√®me de la coroutine du m√™me auteur sont </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et vous pouvez √©galement regarder cette </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conf√©rence.</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr493796/index.html">4 meilleurs mod√®les de conception pour les tests automatis√©s (et 86 autres)</a></li>
<li><a href="../fr493798/index.html">Il n'y a pas de conception dans 1C UX / UI</a></li>
<li><a href="../fr493800/index.html">Probabilit√© empirique</a></li>
<li><a href="../fr493802/index.html">Comprendre l'activit√© Android launchMode: standard, singleTop, singleTask et singleInstance</a></li>
<li><a href="../fr493804/index.html">Joueur parlant sur framboise</a></li>
<li><a href="../fr493810/index.html">Cinq ans de d√©veloppement intensif du march√© de la reconnaissance de documents</a></li>
<li><a href="../fr493814/index.html">Comment nous menons des entretiens √† Barcelone</a></li>
<li><a href="../fr493816/index.html">Git Guide Partie num√©ro 1: tout ce que vous devez savoir sur le r√©pertoire .git</a></li>
<li><a href="../fr493818/index.html">Git Guide Partie num√©ro 2: la r√®gle d'or et autres bases de rebase</a></li>
<li><a href="../fr493820/index.html">√âquilibrage de charge et mise √† l'√©chelle de connexions √† longue dur√©e de vie Kubernetes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>