<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüç≥ üíó üçö Blitz.Engine: Asset System ü§π üçµ üóùÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Before we understand how the asset system of the Blitz.Engine engine works , we need to decide what asset is and what exactly we mean by asset system....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Blitz.Engine: Asset System</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498300/"><img src="https://habrastorage.org/webt/yk/rv/sv/ykrvsv2-nadxe5rvvs7gj8iw-9w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before we understand how the asset system of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blitz.Engine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> engine </font><b><font style="vertical-align: inherit;">works</font></b><font style="vertical-align: inherit;"> , we need to decide what asset is and what exactly we mean by asset system. According to Wikipedia, a game asset is a digital object, mainly consisting of the same data, an indivisible entity that represents part of the game content and has certain properties. From the point of view of the program model, an asset can appear as an object created on some data set. Assets can be stored as a separate file. In turn, an asset system is a lot of program code responsible for loading and operating assets of various types.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, an asset system is a large part of the game engine, which can become a loyal assistant for game developers or turn their lives into hell. </font><font style="vertical-align: inherit;">In my opinion, the logical decision was to concentrate this ‚Äúhell‚Äù in one place, carefully protecting other team developers from it. </font><font style="vertical-align: inherit;">We will tell you about what we did in this series of articles - let's go!</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Planned articles on the topic:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statement of requirements and architecture overview</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asset Life Cycle</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detailed AssetManager class overview</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integration in ECS</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GlobalAssetCache</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requirements and Reasons</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Asset loading system requirements were born between a rock and a hard place. </font><font style="vertical-align: inherit;">An anvil was the desire to do something enclosed in itself so that it would work without writing external code. </font><font style="vertical-align: inherit;">Well, or almost without writing external code. </font><font style="vertical-align: inherit;">The hammer became reality. </font><font style="vertical-align: inherit;">And here's what we ended up with:</font></font><br>
<br>
<ol>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatic memory management</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which means there is no need to call the release function for the asset. </font><font style="vertical-align: inherit;">That is, as soon as all external objects using the asset are destroyed, the asset is destroyed. </font><font style="vertical-align: inherit;">The motivation here is simple - write less code. </font><font style="vertical-align: inherit;">Less code means fewer errors.</font></font></li>
<li><i> <b></b>  </i>,           (    AssetManager‚Äôa).   ,      .   ‚Äî      .       ,     ¬´¬ª    .<br>
    ,      ,       ().       ‚Äî    ,  . ,     ,              .         ,      ,    .        ,   ,    .</li>
<li><i>   </i>      .  :        .         ,         .</li>
<li><i> (shared)  </i>. ,         .  ,    .           ¬´¬ª ,               .</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prioritize asset loading</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">There are only 3 priority levels: High, Medium, Low. </font><font style="vertical-align: inherit;">Within the same priority, assets are loaded in the order of the request. </font><font style="vertical-align: inherit;">Imagine a situation: a player clicks ‚ÄúTo battle‚Äù, and the loading of the level begins. </font><font style="vertical-align: inherit;">Along with this, the task of preparing the sprite of the loading screen falls into the download queue. </font><font style="vertical-align: inherit;">But since some of the level assets got into the queue before the sprite, the player looks at the black screen for quite some time.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, we formulated a simple rule for ourselves: "Everything that can be done on the AssetManager thread must be done on the AssetManager thread." </font><font style="vertical-align: inherit;">For example, preparing a partition of the landscape and texture of normals based on a height map, linking a GPU program, etc.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some implementation details</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before we begin to understand how the asset loading system works, we need to familiarize ourselves with two classes that are widely used in the Blitz.Engine engine:</font></font><br>
<br>
<ul>
<li><code>Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: runtime information about some type. </font><font style="vertical-align: inherit;">This type is similar to the type </font></font><code>Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the C # language, with the exception that it does not provide access to the fields and methods of the type. </font><font style="vertical-align: inherit;">Contains: type name, a number of signs like </font></font><code>is_floating, is_pointer, is_const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, etc. </font><font style="vertical-align: inherit;">The method </font></font><code>Type::instance&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns a constant within one application launch </font></font><code>const Type*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which allows you to do checks of the form</font></font><code>if (type == Type::instance&lt;T&gt;())</code></li>
<li><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: allows you to package the value of any movable or copyable type. </font><font style="vertical-align: inherit;">The knowledge of what type is packaged is </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stored as const </font></font><code>Type*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">knows how to calculate a hash according to its contents, and also knows how to compare contents for equality. </font><font style="vertical-align: inherit;">Along the way, it allows you to make conversions from the current type to another. </font><font style="vertical-align: inherit;">This is a kind of rethinking of the any class from the standard library or boost library.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All assets list loading system is based on three classes: </font></font><code>AssetManager, AssetBase, IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">However, before proceeding to the description of these classes, it must be said that the external code uses an alias </font></font><code>Asset&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is declared like this:</font></font><br>
<br>
<pre><code class="cpp hljs">Asset = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
where T is an AssetBase or a specific type of asset. Using shared_ptr everywhere, we achieve the fulfillment of requirement number 1 (Automatic memory management). </font></font><br>
<br>
<code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- This is a finite class that does not have heirs. This class defines the life cycle of an asset and sends out messages about changes in the state of an asset. It also </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stores a dependency tree between assets and an asset binding to files on disk, listens </font></font><code>FileWatcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and implements an asset reload. And most importantly, it </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">launches a separate thread, implements a task queue for preparing the asset, and encapsulates all synchronization with other application threads (the asset request can be executed from any application thread, including the download stream). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the same time </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operates with an abstract asset</font></font><code>AssetBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, delegating the task of creating and loading an asset of a specific type to the heir from </font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">I will tell you more about how this happens in subsequent articles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As part of requirement number 4 (Asset sharing), one of the hottest questions was ‚Äúwhat to use as an asset identifier?‚Äù </font><font style="vertical-align: inherit;">The simplest and seemingly obvious solution would be to use the path to the file to be downloaded. </font><font style="vertical-align: inherit;">However, this decision imposes a number of serious limitations:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create an asset, the latter must be represented as a file on disk, which removes the ability to create runtime assets based on other assets.</font></font></li>
<li>    . ,    GPUProgram     (defines).      ,       .</li>
<li>         ,   .</li>
<li>        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We did not consider paragraphs 3 and 4 as an argument at the very beginning, since there was not even a thought that this might come in handy. However, these features subsequently greatly facilitated the development of the editor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, we decided to use the asset key as an identifier, which at the level </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is represented by the type </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heir knows </font><font style="vertical-align: inherit;">how to interpret </font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Itself </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">knows only the relationship between the type of key and the heir </font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The code that requests an asset usually knows what type of asset it needs and operates with a key of a specific type. It all goes something like this:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Texture</span>:</span> <span class="hljs-keyword">public</span> AssetBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PathKey</span>
    {</span><font></font>
        FilePath path;<font></font>
        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">hash</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PathKey&amp; other);<font></font>
    };<font></font>
<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryKey</span>
    {</span>
        u32 width = <span class="hljs-number">1</span>;<font></font>
        u32 height = <span class="hljs-number">1</span>;<font></font>
        u32 level_count = <span class="hljs-number">1</span>;<font></font>
        TextureFormat format = RBGA8;<font></font>
        TextureType type = TEX_2D;<font></font>
        <span class="hljs-function">Vector&lt;Vector&lt;u8*&gt;&gt; data</span>; <span class="hljs-comment">// Face&lt;MipLevels&lt;Image&gt;&gt;</span><font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">hash</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> MemoryKey&amp; other);<font></font>
    };<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextureSerializer</span>:</span> <span class="hljs-keyword">public</span> IAssetSerializer<font></font>
{<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AssetManager</span> <span class="hljs-title">final</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    Asset&lt;T&gt; <span class="hljs-title">get_asset</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Any&amp; key, ...)</span></span>;
    <span class="hljs-function">Asset&lt;AssetBase&gt; <span class="hljs-title">get_asset</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Any&amp; key, ...)</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
   ...<font></font>
   <span class="hljs-function">Texture::PathKey <span class="hljs-title">key</span><span class="hljs-params">(<span class="hljs-string">"/path_to_asset"</span>)</span></span>;<font></font>
   Asset&lt;Texture&gt; asset = asset_manager-&gt;get_asset&lt;Texture&gt;(key);<font></font>
   ...<font></font>
<font></font>
   Texture::MemoryKey mem_key;<font></font>
   mem_key.width = <span class="hljs-number">128</span>;<font></font>
   mem_key.format = <span class="hljs-number">128</span>;<font></font>
   mem_key.level_count = <span class="hljs-number">1</span>;<font></font>
   mem_key.format = A8;<font></font>
   mem_key.type = TEX_2D;<font></font>
   Vector&lt;u8*&gt;&amp; mip_chain = mem_key.data.emplace_back();<font></font>
   mip_chain.push_back(generage_sdf_font());<font></font>
   <font></font>
   Asset&lt;Texture&gt; sdf_font_texture = asset_manager-&gt;get_asset&lt;Texture&gt;(mem_key);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The method </font></font><code>hash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and comparison operator inside </font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are needed for the functioning of the corresponding class operations </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but we will not dwell on this in detail. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, what happens in the code above: at the time of the call, the </font></font><code>get_asset(key)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">key will be copied to a temporary object of the type </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which, in turn, will be passed to the method </font></font><code>get_asset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Next, </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">take the type of key from the argument. In our case, it will be:</font></font><br>
<br>
<pre><code class="cpp hljs">Type::instance&lt;MyAsset::PathKey&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By this type, he will find the serializer object and delegate to the serializer all subsequent operations (creation and loading). </font></font><br>
<br>
<code>AssetBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- This is the base class for all types of assets in the engine. </font><font style="vertical-align: inherit;">This class stores the asset key, the current state of the asset (loaded, queued, etc.), as well as the error text if the asset loading failed. </font><font style="vertical-align: inherit;">In fact, the internal structure is a little more complicated, but we will consider this together with the asset life cycle. </font></font><br>
<br>
<code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as the name implies, is the base class for the entity that is preparing the asset. </font><font style="vertical-align: inherit;">In fact, the heir to this class is not only loading the asset:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allocation and deallocation of an asset object of a specific type.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loading an asset of a specific type.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compiling a list of file paths on the basis of which the asset is built. </font><font style="vertical-align: inherit;">This list is needed for the asset reload mechanism when a file changes. </font><font style="vertical-align: inherit;">The question arises: why the list of paths, and not one path? </font><font style="vertical-align: inherit;">Simple assets, like textures, can really be built on the basis of a single file. </font><font style="vertical-align: inherit;">However, if we look at the shader, we will see that the reboot should occur not only if the shader text is changed, but also if the file connected to the shader is changed via the include directive.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saving asset to disk. </font><font style="vertical-align: inherit;">It is actively used both when editing assets and in preparing assets for the game.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reports the types of keys that it supports.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the last question I want to cover in the framework of this article: why might you need to have several types of keys for one serializer / asset? </font><font style="vertical-align: inherit;">Let's sort it out in turn.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One serializer - several types of keys</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's take an example of an asset </font></font><code>GPUProgram</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(that is, a shader). </font><font style="vertical-align: inherit;">In order to load a shader in our engine, the following information is required:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The path to the shader file.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List of preprocessor definitions.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The stage for which the shader is assembled and compiled (vertex, fragment, compute).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The name of the entry point.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gathering this information together, we get the shader key, which is used in the game. However, during the development of a game or engine, it is often necessary to display some debugging information on the screen, sometimes with a specific shader. And in this situation it can be convenient to write the text of the shader directly in the code. To do this, we can get the second type of key, which instead of the path to the file and the list of preprocessor definitions will contain the text of the shader. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider another example: texture. The easiest way to create a texture is to load it from disk. To do this, we need the path to the file ( </font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). But we can also generate the contents of the texture algorithmically and create a texture from an array of bytes ( </font></font><code>MemoryKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). The third type of key can be a key to create a </font></font><code>RenderTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texture ( </font></font><code>RTKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depending on the type of key, various glyph rasterization engines can be used: stb (StbFontKey), FreeType (FTFontKet) or a self-signed signed distance field font generator (SDFFontKey). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keyframe animation can be loaded ( </font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) or generated by code ( </font></font><code>MemoryKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One asset - several types of keys</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine that we have an </font></font><code>ParticleEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asset that describes the rules for particle generation. In addition, we have a convenient editor for this asset. At the same time, the level editor and particle editor are one multi-window application. This is convenient because you can open a level, place a particle source in it and look at the effect in the environment of the level, while editing the effect itself. If we have one type of key, then the effect object that is used in the world of effect editing and in the level world is one and the same. All changes made in the effect editor will immediately be visible in the level. At first glance, this might seem like a cool idea, but let's look at the following scenarios:</font></font><br>
<br>
<ol>
<li>    ,   ,    ,    .   ,            . </li>
<li>-       ,    .        ,            .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, a situation is possible in which we create two different types of assets from one file on a disk using two different types of keys. </font><font style="vertical-align: inherit;">Using the ‚Äúgame‚Äù type of key, we create a data structure optimized for quick work in the game. </font><font style="vertical-align: inherit;">Using the "editorial" type of key, we create a data structure that is convenient for editing. </font><font style="vertical-align: inherit;">In about this way, our editor implements editing </font></font><code>BlendTree</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for skeletal animations. </font><font style="vertical-align: inherit;">Based on one type of key, the asset system builds us an asset with an honest tree inside and a bunch of signals about changing topology, which is very convenient when editing, but rather slowly in the game. </font><font style="vertical-align: inherit;">Using a different type of key, the serializer creates another type of asset: the asset has no methods for changing the tree, and the tree itself is turned into an array of nodes, where the link to the node is an index in the array.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Epilogue</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Summing up, I would like to concentrate your attention on the solutions that have most of all influenced the further development of the engine:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using a custom structure as an asset key, not a file path.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asset loading only in asynchronous mode.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A flexible scheme for managing asset sharing (one asset - several types of keys).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ability to receive assets of the same type using different data sources (support for several types of keys in one serializer).</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You will learn how exactly these decisions influenced the implementation of both the internal code and the external one in the next series. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Author:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exmix</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en498290/index.html">Procedural hydrology: dynamic simulation of rivers and lakes</a></li>
<li><a href="../en498292/index.html">Save a lot of money on large volumes in PostgreSQL</a></li>
<li><a href="../en498294/index.html">Object Detection Recognize and rule. Part 1</a></li>
<li><a href="../en498296/index.html">Design at the system level. Part 1. From idea to system</a></li>
<li><a href="../en498298/index.html">Firms use bug bounties to buy hacker silence</a></li>
<li><a href="../en498302/index.html">ILO Advanced License. Why is it needed right now?</a></li>
<li><a href="../en498304/index.html">Automate VMware vSphere API Administration Tasks Using Ansible</a></li>
<li><a href="../en498308/index.html">Python genetic algorithm for finding global extrema</a></li>
<li><a href="../en498310/index.html">Three pitfalls of machine learning and how to avoid them</a></li>
<li><a href="../en498312/index.html">Development of an aircraft electrical network using model-oriented design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>