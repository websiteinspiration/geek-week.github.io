<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äç‚úàÔ∏è üì° üèÇüèΩ Olya, Tests und Fabrik - der Weg zu sch√∂ner Architektur und sauberem Code üë©üèæ‚Äçü§ù‚Äçüë®üèΩ üéΩ üë¥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der Testautomatisierung gibt es viele verschiedene Ans√§tze, L√∂sungen und Methoden. Am h√§ufigsten und unverzichtbar ist das Muster "Seitenobjekt" (B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Olya, Tests und Fabrik - der Weg zu sch√∂ner Architektur und sauberem Code</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/507048/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Testautomatisierung gibt es viele verschiedene Ans√§tze, L√∂sungen und Methoden. </font><font style="vertical-align: inherit;">Am h√§ufigsten und unverzichtbar ist das Muster "Seitenobjekt" (Bildschirmobjekt). </font><font style="vertical-align: inherit;">Bei der Arbeit mit diesem Muster bin ich auf zwei Ans√§tze gesto√üen: mit einer Fabrik f√ºr meine Seitenobjekte und ohne. </font><font style="vertical-align: inherit;">In diesem Artikel vergleichen wir am Beispiel unserer Autotests beide Ans√§tze, ihre Vor- und Nachteile. </font><font style="vertical-align: inherit;">Lassen Sie mich Ihnen zeigen, wie unsere Fabrik f√ºr Seitenobjekte aussieht. </font><font style="vertical-align: inherit;">Ich werde auch √ºber die Probleme sprechen, die bei Autotests mit der Fabrik aufgetreten sind, und wie sie gel√∂st wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde alle Beispiele im Artikel in Swift zitieren, aber f√ºr Android-Autotests funktioniert alles auf die gleiche Weise.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ci/5e/br/ci5ebr0v9onedivfawpjjy-ux0c.png"></div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr den Anfang</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hallo, mein Name ist Olya. Ich bin ein Tester f√ºr mobile Anwendungen bei hh.ru. F√ºr zwei Jahre mit einem Schwanz haben wir 90% der manuellen Tests auf automatisiert √ºbertragen. In dieser Zeit ist es uns gelungen, viele Male auf verschiedene Fallstricke zu sto√üen, Hunderte von Streitigkeiten zu diskutieren, und jetzt m√∂chte ich unsere Erfahrungen mit der Welt teilen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schreiben Autotests auf Android (Kotlin, Kaspresso) und iOS (Swift, XCUITest). Wir versuchen, UI-Tests klein zu machen und nur einzelne Skripte zu √ºberpr√ºfen. Der Nutzen von Eisen reicht daf√ºr aus, und die Regression von ~ 300-400 UI-Autotests auf jeder Plattform dauert durchschnittlich 30-40 Minuten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unseren Autotests verwenden wir das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seitenobjektmuster</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tausende Artikel wurden √ºber ihn geschrieben, daher werden wir nicht n√§her darauf eingehen.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Vergangenheit haben wir beim Erstellen der ersten Autotests unter iOS und Android verschiedene Ans√§tze f√ºr die Arbeit mit Seitenobjekten gew√§hlt. </font><font style="vertical-align: inherit;">Unter Android folgen wir einfach dem Muster und unter iOS haben wir auch eine Factory mit Seitenobjekten erstellt. </font><font style="vertical-align: inherit;">Eine Factory ist der Ort, an dem alle Seitenobjekte initialisiert werden. </font><font style="vertical-align: inherit;">Mit diesen Methoden in unseren Bildschirmen k√∂nnen wir andere Seitenobjekte √ºbertragen und so Interaktionsketten aufbauen, die dem Verhalten der Anwendung √§hneln.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ben√∂tigt die Fabrik Seitenobjekte?&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir Hunderte von Testf√§llen erstellt hatten, kamen wir zu dem Schluss, dass die Verwendung der Factory von Seitenobjekten f√ºr den Tester, der Autotests schreibt, Geschmackssache ist. Bei der Arbeit mit unterschiedlichen Ans√§tzen gibt es keinen Unterschied in Leistung und Stabilit√§t. Um jedoch in Zukunft nicht unter nativem Code zu leiden, m√ºssen Sie so schnell wie m√∂glich entscheiden, ob in der Architektur von Autotests ein Platz f√ºr die Page Object Factory vorhanden ist oder nicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Klarheit halber werde ich zwei Beispiele f√ºr denselben Test geben: geschrieben mit und ohne Fabrik.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was dieser Test bewirkt: √úber den Hauptbildschirm der Anwendung versucht der Benutzer, zur Registerkarte Profil zu wechseln. Im Profil w√§hlt er "Login", dann die Login-Methode per Login, gibt seinen Benutzernamen und sein Passwort ein und klickt dann auf die Schaltfl√§che "Login".</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//   </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{
   <span class="hljs-keyword">let</span> mainScreen = <span class="hljs-type">MainScreen</span>()
   <span class="hljs-keyword">let</span> profileScreen = <span class="hljs-type">ProfileScreen</span>()
   <span class="hljs-keyword">let</span> authorizationScreen = <span class="hljs-type">AuthorizationScreen</span>()
   <span class="hljs-keyword">let</span> loginScreen = <span class="hljs-type">LoginScreen</span>()<font></font>
 <font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser()<font></font>
 <font></font>
        mainScreen.openProfileTab()<font></font>
        profileScreen.goToAuthorization()<font></font>
        authorizationScreen.goToLogin()<font></font>
        loginScreen<font></font>
           .enterLogin(user.login)<font></font>
           .enterPassword(user.password)<font></font>
           .logIn()   <font></font>
   }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-comment">//   </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser()<font></font>
 <font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openProfileTab()<font></font>
            .goToAuthorization()<font></font>
            .goToLogin()<font></font>
            .enterLogin(user.login)<font></font>
            .enterPassword(user.password)<font></font>
            .logIn()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie nach diesem Beispiel entscheiden, dass Tests ohne Factory gut aussehen, greifen Sie einfach zu und schreiben Sie ohne. </font><font style="vertical-align: inherit;">Dieser Tipp ist besonders relevant, wenn Sie keine sehr gro√üe Anwendung mit unterschiedlichen, sich nicht wiederholenden Inhalten und Elementen haben. </font><font style="vertical-align: inherit;">Oder wenn Sie Tests schreiben, in denen nicht mehr als 10-15 Schritte erforderlich sind. </font><font style="vertical-align: inherit;">In diesem Fall wird die Fabrik das Wetter nicht tun.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wenn dies nicht der Fall ist oder wenn die Werkstests in Ihrem Herzen reagiert haben, dann ist dieser Artikel f√ºr Sie.&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qe/g4/zc/qeg4zcjbcn8z9yrhq83bmteoz8k.jpeg"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie sieht unsere Fabrik aus?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns herausfinden, wozu die Seitenobjektfabrik dient, wie sie aussieht und was sie tut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Standardtestfall besteht aus einer Reihe von Schritten:</font></font><br>
<blockquote><ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starte die Anwendung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ñffnen Sie den Profilbildschirm</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tippen Sie auf "Login".</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hlen Sie eine Anmeldemethode mit Login und Passwort</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzerdaten eingeben (Benutzername und Passwort)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tippen Sie auf die Schaltfl√§che "Anmelden"</font></font></li>
</ol><br>
</blockquote><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Screencast-Test</font></font></b>
                        <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/nYHsgZiJgo8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Schritt des Testfalls entspricht einem Schritt im Autotest. Sie k√∂nnen auch sagen, dass jeder Schritt eine separate Seitenobjektmethode des entsprechenden Bildschirms ist.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir diesen Testfall im Autotest genau in Schritten wiederholen m√∂chten, dieselbe ununterbrochene Kette von Methodenaufrufen erstellen m√∂chten, ben√∂tigen wir jede Methode, um das Seitenobjekt des n√§chsten Bildschirms zur√ºckzugeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Erstellen eines Seitenobjekts muss es initialisiert werden. Es stellt sich heraus, dass, wenn wir Seitenobjekte in anderen erstellen m√∂chten, in jedem Seitenobjekt viele identische Initialisierungen vorhanden sind. Um dies nicht zu tun, werden Initialisierungen aller Seitenobjekte in die Factory verschoben - pageObjectFactory (oder screenFactory usw.). Am Ende jeder Methode bitten wir die Fabrik, den Bildschirm zu erstellen, den wir ben√∂tigen.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfilePageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goToAuthScreen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AuthPageObject</span> {<font></font>
        openAuthButton.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeAuthPageObject()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Seitenobjekte werden von BasePageObject geerbt, das die Hauptparameter enth√§lt. </font><font style="vertical-align: inherit;">Darin m√ºssen wir einen erforderlichen Konstruktor vorschreiben, damit die Fabrik jeden ihrer Erben schaffen kann. </font><font style="vertical-align: inherit;">In unserem Fall sieht die Basisklasse folgenderma√üen aus:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePageObject</span> </span>{
    <span class="hljs-keyword">let</span> pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>
    <span class="hljs-keyword">let</span> application: <span class="hljs-type">XCUIApplication</span><font></font>
 <font></font>
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>,<font></font>
                       application: <span class="hljs-type">XCUIApplication</span>) {
        <span class="hljs-keyword">self</span>.pageObjectsFactory = pageObjectsFactory
        <span class="hljs-keyword">self</span>.application = application<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Initialisierung der Bildschirme in der Fabrik sieht daher folgenderma√üen aus:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageObjectsFactory</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initializePageObject</span>&lt;PageObject: BasePageObject&gt;<span class="hljs-params">(ofType type: PageObject.<span class="hljs-keyword">Type</span>)</span></span> -&gt; <span class="hljs-type">PageObject</span> {
        <span class="hljs-keyword">return</span> type.<span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-keyword">self</span>, application: application)<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeAuthPageObject</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AuthPageObject</span> {
        <span class="hljs-keyword">return</span> initializePageObject(ofType: <span class="hljs-type">AuthPageObject</span>.<span class="hljs-keyword">self</span>)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen k√∂nnen wir in der Methode eines beliebigen Seitenobjekts die Factory-Methode zum Erstellen eines Bildschirms aufrufen, der es initialisiert.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pluspunkte des Lebens eines Testers ohne Fabrik</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Aus dem Test geht immer hervor, auf welchem ‚Äã‚ÄãBildschirm die Aktion ausgef√ºhrt wird</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ohne Fabrik sind in jeder Zeile </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur des</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Testpunkts der Bildschirm und die darauf ablaufende Aktion eindeutig registriert. </font><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen Sie nicht den gesamten Testcode von Anfang an lesen, z. B. beim Debuggen und bei Korrekturen. </font><font style="vertical-align: inherit;">Das Fehlen einer Fabrik erh√∂ht die Lesbarkeit, insbesondere wenn Aktionen oder √úberpr√ºfungen auf einem Bildschirm ausgef√ºhrt werden.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span> : <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
<font></font>
    <span class="hljs-comment">//   ,   </span>
    <span class="hljs-keyword">let</span> mainScreen = <span class="hljs-type">MainScreen</span>()
    <span class="hljs-keyword">let</span> profileScreen = <span class="hljs-type">ProfileScreen</span>()
    <span class="hljs-keyword">let</span> authorizationScreen = <span class="hljs-type">AuthorizationScreen</span>()
    <span class="hljs-keyword">let</span> loginScreen = <span class="hljs-type">LoginScreen</span>()<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser() <span class="hljs-comment">//   </span><font></font>
 <font></font>
        mainScreen.openProfileTab() <span class="hljs-comment">//      </span>
        profileScreen.goToAuthorization() <span class="hljs-comment">//     ""</span>
        authorizationScreen.goToLogin() <span class="hljs-comment">//          </span>
        loginScreen <span class="hljs-comment">//           </span><font></font>
            .enterLogin(user.login)<font></font>
            .enterPassword(user.password)<font></font>
            .login()   <font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch wenn Sie nicht in alle Feinheiten der Anwendung vertieft sind, wird aus dem obigen Beispiel sofort ersichtlich, dass die Aktionen enterLogin / enterPassword auf demselben Bildschirm ausgef√ºhrt werden. </font><font style="vertical-align: inherit;">Der Test mit der Fabrik wird nicht so klar sein - Sie k√∂nnten denken, dass die enterLogin-Aktion den Benutzer zum n√§chsten Bildschirm weitergeleitet hat.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Es ist bequemer, Tests mit Aktionen zu schreiben, die zu unterschiedlichen Bildschirmen f√ºhren k√∂nnen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie Tests ohne Factory schreiben, m√ºssen Sie nicht daran denken, dass sich Benutzeraktionen je nach Status der Anwendung unterschiedlich verhalten k√∂nnen. Sie beschreiben lediglich die Logik des Geschehens:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//        </span><font></font>
    vacancyScreen.tapResponseButton()<font></font>
    authScreen.authUser(user)<font></font>
    responseScreen.checkScreenIsOpened()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
oder</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//       	</span><font></font>
    vacancyScreen.tapResponseButton()<font></font>
    responseScreen.checkScreenIsOpened()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Factory-Seitenobjekten m√ºssen Sie dar√ºber nachdenken, wie Sie je nach Berechtigung des Benutzers den gew√ºnschten Bildschirm in der tapResponseButton () -Methode zur√ºckgeben (oder eine Methode wie tapResponseButtonAndLogin () duplizieren k√∂nnen.)</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tapResponseButton</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ResponseSendPageObject</span> {<font></font>
        responseButton.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeResponseSendPageObject()<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tapResponseButtonAndLogin</span><span class="hljs-params">(login: String)</span></span> -&gt; <span class="hljs-type">ResponseSendPageObject</span> {<font></font>
        responseButton.tap()<font></font>
        pageObjectsFactory<font></font>
            .makeAuthorizationPageObject()<font></font>
            .goToLogin()<font></font>
            .logIn(login)<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeResponseSendPageObject()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben 6 √§hnliche Methoden auf diesem Bildschirm, obwohl alle auf dieselbe Schaltfl√§che tippen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Sie m√ºssen nicht jede Aktion und jeden Check in eine separate Methode einschlie√üen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Methoden von Seitenobjekten ohne Factory m√ºssen nicht den n√§chsten Bildschirm zur√ºckgeben, um die Kette fortzusetzen. F√ºr einzelne Aktionen k√∂nnen Sie keine separaten Methoden erstellen.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel k√∂nnte ein Tippen auf eine Schaltfl√§che in einem Test ohne Fabrik folgenderma√üen aussehen:</font></font><br>
<br>
<pre><code class="swift hljs">    vacancyScreen.responseButton.tap()</code></pre><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Sie m√ºssen nicht √ºber komplexe L√∂sungen nachdenken, sondern zus√§tzlich √ºber die Architektur von Seitenobjekten nachdenken</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach meiner Erfahrung gibt es beim Schreiben von Autotests ohne Factory praktisch keine Probleme mit Seitenobjekten. </font><font style="vertical-align: inherit;">Das Beschreiben eines neuen Seitenobjekts ist ein einfacher und schneller Vorgang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Fabrik f√ºgt zusammen mit ihren F√§higkeiten einige Schwierigkeiten hinzu, die ich sp√§ter diskutieren werde.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die unbestrittenen Vorteile der Fabrik</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. W√§hrend Sie einen Test schreiben, k√∂nnen Sie keinen Schritt √ºberspringen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Methoden von Seitenobjekten sind Glieder einer Kette. Jeder neue Link (Methode) sollte mit den folgenden verkn√ºpft sein. Dies liegt an der Tatsache, dass alle Methoden ein Seitenobjekt (selbst oder ein anderes) zur√ºckgeben, weshalb wir beim Schreiben eines Tests keine M√∂glichkeit haben, die Methode eines Bildschirms auszuw√§hlen, sondern nur die folgenden.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens beschleunigt es das Schreiben Ihres ersten Autotests durch einen neuen Tester erheblich. Die IDE selbst teilt Ihnen mit, welche Aktionen und auf welchem ‚Äã‚ÄãBildschirm Sie weiter ausf√ºhren k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens k√∂nnen Sie mit dieser Architektur von Autotests die Anwendung anhand ihres Schreibens erkennen und nicht umgekehrt. (wieder - eine gute Motivation f√ºr junge Tester).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Drittens gibt es keine M√∂glichkeit, einen Schritt zu √ºberspringen, da die gew√ºnschte Methode erst angezeigt wird, wenn Sie das Skript korrekt √ºbergeben haben. </font><font style="vertical-align: inherit;">Solche Auslassungen treten h√§ufig auf, wenn Sie Tests ohne Factory schreiben, und Sie werden sie erst beim Ausf√ºhren des Tests erfahren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Wenn Sie die Signatur der Seitenobjektmethode √§ndern, werden Sie von der IDE gezwungen, alle mit dem Objekt verkn√ºpften Tests zu √§ndern</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Punkt folgt aus dem vorherigen. </font><font style="vertical-align: inherit;">Alle Seitenobjektmethoden wiederholen die Logik und das Verhalten der Anwendung. </font><font style="vertical-align: inherit;">Wenn die Anwendung die Logik der √úberg√§nge zwischen Bildschirmen √§ndert oder neue hinzuf√ºgt, korrigieren wir die ben√∂tigte Methode und √§ndern ihre R√ºckgabe. </font><font style="vertical-align: inherit;">Bei werkseitigen Selbsttests m√ºssen Sie nicht alle Tests ausf√ºhren, um alle von dieser √Ñnderung betroffenen Tests zu finden. </font><font style="vertical-align: inherit;">Die IDE selbst zeigt auf alle Stellen, an denen die "Kette" gerissen ist. </font><font style="vertical-align: inherit;">Tests ohne Fabrik folgen nicht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Architektur und Code-Sauberkeit leiden nicht unter der Erstellung √ºberfl√ºssiger Bildschirmobjekte&nbsp;</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie keine Factory verwenden und der Test das Skript durch Dutzende von Bildschirmen durchl√§uft, m√ºssen Sie zu Beginn der Klasse mit dem Test einen ganzen Block zum Erstellen von Objekten f√ºr jeden Bildschirm schreiben. </font><font style="vertical-align: inherit;">Und Sie m√ºssen dies jedes Mal f√ºr jede Testklasse tun. </font><font style="vertical-align: inherit;">Noch schlimmer, wenn Sie mehrere Tests in derselben Klasse schreiben. </font><font style="vertical-align: inherit;">Dann wird die Gr√∂√üe dieses ‚ÄûBlocks‚Äú mit der Erstellung aller Seitenobjekte erheblich erh√∂ht.&nbsp;&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Beispiel aus einem realen Test, bei dem der Benutzer auf eine freie Stelle reagiert, sich abmeldet und sich bei einem anderen Benutzer anmeldet. </font><font style="vertical-align: inherit;">Dieser Block wechselt mit geringf√ºgigen √Ñnderungen f√ºr alle √§hnlichen Tests von Klasse zu Klasse.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterUpdateAfterOtherUserLoginTest</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> mainScreen = <span class="hljs-type">MainScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> vacanciesScreen = <span class="hljs-type">VacanciesScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> responseToVacancyScreen = <span class="hljs-type">ResponseToVacancyBottomSheet</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> successResponseBottomSheet = <span class="hljs-type">SuccessResponseBottomSheet</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> settingsScreen = <span class="hljs-type">UserSettingsScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> chooseAuthScreen = <span class="hljs-type">ChooseAuthScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> authScreen = <span class="hljs-type">NativeAuthScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> navigation = <span class="hljs-type">NavigationPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> moreScreen = <span class="hljs-type">MoreScreenPageObject</span>()<font></font>
<font></font>
    ...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es besteht die M√∂glichkeit, die Initialisierung aller Seitenobjekte in der Basisklasse der Tests mithilfe der verz√∂gerten Initialisierung durchzuf√ºhren. </font><font style="vertical-align: inherit;">Dann sind in jedem Test alle Bildschirme verf√ºgbar und es werden keine unn√∂tigen Objekte erstellt. </font><font style="vertical-align: inherit;">Das Problem beim Auflisten vieler Bildschirme tritt jedoch wieder auf, wenn Seitenobjekte in den Seitenobjekten selbst erstellt werden sollen, wenn eine Methode geschrieben werden muss, die einen anderen Bildschirm durchl√§uft. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Fabrik √ºbernimmt die Aufgabe, die erforderlichen Seitenobjekte bei Bedarf zu initialisieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Eine gro√üartige Gelegenheit, tiefer in den Anwendungscode einzutauchen, seine Architektur, Module, ihre Interaktion usw. zu studieren.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um eine Factory von Seitenobjekten zu haben, m√ºssen alle Aktionen mit dem Bildschirm in Methoden eingeschlossen werden, die den n√§chsten Bildschirm zur√ºckgeben. </font><font style="vertical-align: inherit;">Aus diesem Grund werden Seitenobjekte stark erweitert, sodass Sie sich fragen, wie Sie alles sch√∂ner und genauer machen k√∂nnen. </font><font style="vertical-align: inherit;">Aus diesem Grund versuchen Sie, Architekturtechniken zu verwenden, die Implementierung verschiedener Bildschirme im Anwendungscode zu beobachten und die Interaktion von Modulen zu verfolgen, um ein √§hnliches System in Ihren Autotests zu erstellen, das angenehm und bequem zu verwenden ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Bonus erhalten wir von innen Kenntnisse dar√ºber, wie die Anwendung funktioniert. </font><font style="vertical-align: inherit;">Zumindest ist dies f√ºr die Gesamtentwicklung n√ºtzlich und hilft beim Testen oft sehr.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Der Testcode sieht sehr ordentlich und sauber aus.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt keine Kommentare, das ist wirklich aromatisch. </font><font style="vertical-align: inherit;">Wie f√ºr Sie "genauer und sauberer" ist, kann schon das erste Beispiel entscheiden.</font></font><br>
<br>
<p></p><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fallstricke // wie sie stolperten und herumgingen</font></font></h1><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gd/4a/jz/gd4ajzpobkjvg6t4tq1vy-3a-ws.jpeg" width="60%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen daraus schlie√üen, dass es besser ist, beim Schreiben von Autotests die Factory von Seitenobjekten zu verwenden. </font><font style="vertical-align: inherit;">Fragen Sie niemanden, warum sie die Fabrik benutzen, es gibt immer eine Antwort: "Und Sie versuchen, einen Test ohne ihn zu schreiben und zu vergleichen." </font><font style="vertical-align: inherit;">Die Fabrik √ºbernimmt wirklich einen wesentlichen Teil der Aufgaben, die Verantwortung f√ºr das Fehlen von Fehlern in der Reihenfolge des Autotests und so weiter. </font><font style="vertical-align: inherit;">Es er√∂ffnet auch einige interessante M√∂glichkeiten, √ºber die ich oben geschrieben habe.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich m√∂chte jedoch darauf hinweisen, dass mit diesen Funktionen nicht immer alles rosig ist. </font><font style="vertical-align: inherit;">W√§hrend der Automatisierung mit der Fabrik sind wir auf sehr unangenehme Probleme gesto√üen, aber am Ende haben wir sie gel√∂st.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokolle und Elemente, die der gesamten Anwendung gemeinsam sind</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jeder mobilen Anwendung gibt es Elemente, auf die von jedem Bildschirm aus zugegriffen werden kann. Sie k√∂nnen beispielsweise eine Registerkarte (Men√º) verwenden. Es stellt sich die Frage: Wie k√∂nnen Sie jederzeit im Test auf die Methoden der Registerkarten zugreifen, ohne die Aufrufkette f√ºr Seitenobjektmethoden zu unterbrechen?&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die naheliegendste und erste Entscheidung ist, die Basisklasse der Seitenobjekte mit diesen Methoden zu erweitern.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> XCTest<font></font>
 <font></font>
<span class="hljs-comment">/*
      .
 */</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> tabBar = application.tabBars[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.identifier].firstMatch
    <span class="hljs-keyword">var</span> searchTab =  tabBar.buttons[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.searchTab].firstMatch<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span> {<font></font>
        searchTab.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory.makeMainScreenPageObject()<font></font>
    }<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend der Diskussion stellten wir fest, dass die Registerkartenleiste nicht das einzige Element ist, das auf allen Bildschirmen ben√∂tigt wird, und kamen zu dem Schluss, dass wir durch Hinzuf√ºgen von immer mehr Erweiterungen die Basisklasse schnell √ºberladen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer Nachteil dieser L√∂sung besteht darin, dass die Methoden f√ºr alle Seitenobjekte verf√ºgbar werden, was falsch ist. Dies bricht den Vertrag f√ºr Nachfolgeklassen, die theoretisch nur f√ºr sie spezifische Methoden enthalten sollten. Beispielsweise werden f√ºr Seitenwarnobjekte keine Registerkartenmethoden ben√∂tigt.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere endg√ºltige L√∂sung - wir haben das TabBarUsable-Protokoll aus dem Seitenobjekt von Tabbar erstellt (die Benutzeroberfl√§che f√ºr Kotlin ist √§hnlich). Und sie haben die Erweiterung (Erweiterung, Implementierung) geschrieben, mit der Sie den Code nicht duplizieren und gleichzeitig die Vererbung durch die Komposition ersetzen k√∂nnen.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> XCTest<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TabBarUsable</span> </span>{
    <span class="hljs-keyword">var</span> searchTab: <span class="hljs-type">XCUIElement</span> { <span class="hljs-keyword">get</span> }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span><font></font>
    ‚Ä¶<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">TabBarUsable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> tabBar: <span class="hljs-type">XCUIElement</span> { application.tabBars[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.identifier].firstMatch }
    <span class="hljs-keyword">var</span> searchTab: <span class="hljs-type">XCUIElement</span> { tabBar.buttons[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.searchTab].firstMatch }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span> {<font></font>
        searchTab.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory.makeMainScreenPageObject()<font></font>
    }<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr alle Bildschirme mit einer Registerkarte f√ºgen wir die Konformit√§t mit diesem Protokoll hinzu (konform).</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span> </span>{<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dementsprechend stehen auf allen diesen Bildschirmen alle Methoden zum Arbeiten mit einer Registerkarte zur Verf√ºgung.&nbsp;</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleTabbarTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleOpenSearchTab</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy() <span class="hljs-comment">//   .makeVacancyPageObject()</span>
            .openSearchTab() <span class="hljs-comment">//   TabBarUsable </span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleichzeitig bricht die Architektur nicht, die Methoden der Registerkartenleiste sind nur f√ºr die von uns ben√∂tigten Bildschirme verf√ºgbar, und der Code derselben Methoden wird nicht dupliziert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokolle und Code-Revision</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erw√§hnt, werden bei Verwendung der Seitenobjektfactory alle Aktionen und √úberpr√ºfungen in Methoden eingeschlossen. </font><font style="vertical-align: inherit;">Nach einer Weile, wenn Sie den n√§chsten Autotest erstellen, stellen Sie fest, dass Sie f√ºr jedes Seitenobjekt dieselben Methoden schreiben, die sich in den Elementen nicht einmal unterscheiden. </font><font style="vertical-align: inherit;">Beispiele f√ºr solche Methoden k√∂nnen Nullbildpr√ºfungen sein, die mit identischen Listenelementen auf verschiedenen Bildschirmen arbeiten, und so weiter.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/a2/xg/ic/a2xgiczqetidmsoqa2rl2aandjo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen logischen Gedanken: "Ich werde es mir leichter machen ?!" Wie kann ich das Duplizieren von Code beenden? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Methode, √ºber die ich bereits geschrieben habe, besteht darin, alle diese Methoden in die Basisklasse aufzunehmen. Es ist m√∂glich, aber sehr vorsichtig. Erstens ist dieser Prozess sehr faszinierend. Es scheint, dass eine Methode in der Basisklasse nichts ruinieren wird, aber fr√ºher oder sp√§ter wird die Basisklasse zu einem unertr√§glichen, unstrukturierten, √ºberf√ºllten Monster, kurz gesagt, es wird v√∂llig unm√∂glich. Wir haben es versucht, wir wissen. Dieses Monster loszuwerden ist noch schwieriger als es sofort richtig zu machen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Laufe der Zeit haben wir festgestellt, dass das DRY-Prinzip (Don't Repeat Yourself) aus einem bestimmten Grund erfunden wurde. Wir haben begonnen, nach denselben Methoden zu suchen, die in vielen Seitenobjekten verwendet werden. Nachdem sie sie gefunden hatten, diskutierten sie lange dar√ºber, ob diese Methoden wirklich √ºberall gleich angewendet werden und dieselbe Logik haben. Und schlie√ülich entschieden sie, dass, wenn die Methoden in 80% der F√§lle auf die gleiche Weise verwendet werden, sie in einem separaten Protokoll entfernt werden sollten.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine der allerersten gerenderten Methoden war die waitView () -Methode. Wir haben das spezielle Protokoll ViewWaitable und seine Implementierung in der Protokollerweiterung beschrieben. Damit diese Methode im Seitenobjekt verf√ºgbar ist, m√ºssen Sie nur noch die Konformit√§t zum Protokoll hinzuf√ºgen (konform). Da die Ansichtskennungen f√ºr alle Bildschirme unterschiedlich sind, m√ºssen alle Seitenobjekte, die das Protokoll verwenden, eine Ansicht f√ºr sich deklarieren.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewWaitable</span> </span>{
    <span class="hljs-keyword">var</span> view: <span class="hljs-type">XCUIElement</span> { <span class="hljs-keyword">get</span> }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewWaitable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-meta">@discardableResult</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">waitView</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> {<font></font>
        testWaiter.waitForElementToAppear(view)<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span>, <span class="hljs-title">ViewWaitable</span> </span>{<font></font>
 <font></font>
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> view = application.otherElements[<span class="hljs-type">Accessibility</span>.view].firstMatch<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Beispiel aus unserer hh.ru-Anwendung: Wir haben eine Liste von Stellenangeboten, die auf vielen verschiedenen Bildschirmen zu finden sind. Der einzige Unterschied besteht in der Ansichtskennung, auf der diese Liste angezeigt wird. Mit dieser Liste sind viele Aktionen und eine Menge √úberpr√ºfungen verbunden. Multiplizieren Sie sie mit etwa 10 (mit der Anzahl der Bildschirme, auf denen diese Liste angezeigt wird), um den Umfang der Codeduplizierung abzusch√§tzen.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die L√∂sung waren wieder die Protokolle. Um die Protokolle noch verst√§ndlicher und benutzerfreundlicher zu machen, haben wir die Listenelemente (VacancyListContainig), die Zellenelemente (VacancyCellContainig), die Methoden mit Pr√ºfungen (Asserts, Pr√ºfungen) und die Interaktionsmethoden (Aktionen) unterteilt. Diese Trennung l√∂ste perfekt das Problem der Lesbarkeit des Inhalts eines riesigen Seitenobjekts. Die endg√ºltige Architektur sieht folgenderma√üen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sx/zw/_j/sxzw_jfnqwufs2snkgohmzxawb4.png" width="50%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seitenobjekte, f√ºr die eine Liste mit offenen Stellen vorhanden ist, k√∂nnen die Konformit√§t mit dem VacancyListPageObject-Protokoll erh√∂hen. </font><font style="vertical-align: inherit;">Somit werden alle Methoden aus der Implementierung dieses Protokolls ohne Duplizierung des Codes f√ºr den Bildschirm verf√ºgbar.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchResultPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">ViewWaitable</span>, <span class="hljs-title">VacancyListPageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> view = application<font></font>
        .otherElements[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">SearchResults</span>.view].firstMatch
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> listView = application<font></font>
        .tables[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">SearchResults</span>.tableView].firstMatch<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund des DRY-Prinzips haben wir daher sehr saubere, ordentliche Seitenobjekte, dieselben Methodennamen und das Fehlen von zus√§tzlichem Code.&nbsp;</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieselben Warnungen auf verschiedenen Bildschirmen // Quellen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Systemfehler, Warnungen und untere Bl√§tter sind ein wesentlicher Bestandteil von Regressionen, die ich auf jeden Fall mit automatischen Tests behandeln m√∂chte. Fehler und Warnungen treten auf verschiedenen Bildschirmen auf, unterscheiden sich in verschiedenen F√§llen in verschiedenen Anwendungsstatus, aber die Elemente selbst haben im Grunde die gleichen Kennungen und das gleiche Verhalten. Offensichtlich ist dieselbe Art von Warnung mit zwei Schaltfl√§chen (z. B. OK / Abbrechen) = ein separates Seitenobjekt.&nbsp;&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir kehren zu dem Wunsch zur√ºck, die Kette von Methodenaufrufen nicht zu unterbrechen. Wir haben - Dutzende von Bildschirmen, von denen aus wir dieselbe Warnung √∂ffnen k√∂nnen. Wenn wir eine solche Warnung schlie√üen, m√ºssen wir zu dem Seitenobjekt zur√ºckkehren, von dem aus sie ge√∂ffnet wurde. Gleichzeitig m√∂chten wir nicht diese Dutzenden von doppelten Methoden in das Seitenobjekt einer solchen Warnung schreiben, die sich nur im zur√ºckgegebenen Seitenobjekt voneinander unterscheiden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste L√∂sung besteht darin, den Test einmal zu bewerten und abzubrechen. </font><font style="vertical-align: inherit;">Daran ist auch nichts auszusetzen. </font><font style="vertical-align: inherit;">Und so ist das Leben viel einfacher.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExample</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy()<font></font>
            .openAlert()<font></font>
            .closeAlert() <span class="hljs-comment">//      ,     </span><font></font>
        pageObjectFactory<font></font>
            .makeVacancyPageObject() <span class="hljs-comment">//   </span><font></font>
        ‚Ä¶<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere L√∂sung ist komplizierter, aber wie sch√∂n sie ist! </font><font style="vertical-align: inherit;">Wir haben das Seitenobjekt des Alarmtyp-Parameters ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generisch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">hinzugef√ºgt. Dies </font><font style="vertical-align: inherit;">ist der Typ des Seitenobjekts, von dem aus wir den Alarm √∂ffnen. </font><font style="vertical-align: inherit;">In diesem Fall wird das Seitenobjekt dieses Bildschirms bei der Initialisierung an den Seitenobjektalarm √ºbergeben und als generische Quellvariable gespeichert.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Informationen zur Funktionsweise: Wenn Sie eine Warnung √∂ffnen (und initialisieren), √ºbergeben wir den gew√ºnschten Bildschirm in der generischen Quellvariablen. </font><font style="vertical-align: inherit;">Dies erfolgt in der Seitenobjektmethode, die die Warnung √∂ffnet:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openAlert</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AlertPageObject</span>&lt;<span class="hljs-type">VacancyPageObject</span>&gt; {<font></font>
        button.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeAlertPageObject(from: <span class="hljs-keyword">self</span>) <span class="hljs-comment">//  source VacancyPageObject</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als N√§chstes durchl√§uft diese Quelle (in diesem Beispiel VacancyPageObject) alle im Test erforderlichen Methoden und landet in der endg√ºltigen Entlassung von Alert (). </font><font style="vertical-align: inherit;">Infolgedessen gibt die Methode zum Schlie√üen von Warnungen den ben√∂tigten Bildschirm zur√ºck, auf dem wir den Test sofort fortsetzen k√∂nnen.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlertPageObject</span>&lt;<span class="hljs-title">Source</span>: <span class="hljs-title">BasePageObject</span>&gt;: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dismissAlert</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Source</span> {<font></font>
        cancelButton.tap()<font></font>
        <span class="hljs-keyword">return</span> source <span class="hljs-comment">//  ,     ‚Äî VacancyPageObject</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie ich bereits sagte, muss das Seitenobjekt, damit es die erforderlichen Bildschirme (Quellen) empfangen und zur√ºckgeben kann, einen generischen Typ zuweisen, der auf den Basistyp der Seitenobjekte beschr√§nkt ist, und ihn mit einem Seitenobjekt initialisieren, das ganz am Ende zur√ºckgegeben werden muss ::</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlertPageObject</span>&lt;<span class="hljs-title">Source</span>: <span class="hljs-title">BasePageObject</span>&gt;: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-comment">// generic-          </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> source: <span class="hljs-type">Source</span><font></font>
 <font></font>
    <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>,<font></font>
         application: <span class="hljs-type">XCUIApplication</span>,<font></font>
         source: <span class="hljs-type">Source</span>) {
        <span class="hljs-keyword">self</span>.source = source
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(pageObjectsFactory: pageObjectsFactory, application: application)<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-comment">//  BasePageObject   ,      </span>
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>, application: <span class="hljs-type">XCUIApplication</span>) {
        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"init(pageObjectsFactory:application:) has not been implemented. Use another init"</span>)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Initialisierung des generischen Seitenobjekts in der Factory sieht folgenderma√üen aus:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageObjectsFactory</span> </span>{<font></font>
    ‚Ä¶<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeAlertPageObject</span>&lt;Source: BasePageObject&gt;<span class="hljs-params">(
        from source: Source
    )</span></span> -&gt; <span class="hljs-type">AlertPageObject</span>&lt;<span class="hljs-type">Source</span>&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-type">AlertPageObject</span>(pageObjectsFactory: <span class="hljs-keyword">self</span>,<font></font>
                                          application: application,<font></font>
                                          source: source)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ta-daa! </font><font style="vertical-align: inherit;">Alles ist fertig und jetzt k√∂nnen wir den Test fortsetzen, ohne die Anrufkette zu unterbrechen.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleSourcesTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleSource</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy()<font></font>
            .openAlert()<font></font>
            .dismissAlert()<font></font>
            .checkVacancyScreenIsOpened() <span class="hljs-comment">//       ,         </span><font></font>
        ‚Ä¶<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gn/rt/hs/gnrthsrb0jerc7jtimpsmfqeryw.jpeg" width="70%"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Riesiges Seitenobjekt, wie man es versteht</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt Bildschirme (obwohl es solche gibt), auf denen viele verschiedene Inhalte, verschiedene Schnittstellenelemente und einzelne logische Bl√∂cke platziert sind. Gleichzeitig befinden sich alle auf demselben Bildschirm, und ich m√∂chte √ºber das Seitenobjekt, das diesen Bildschirm beschreibt, mit ihnen interagieren.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen Sie zum Beispiel den Hauptbildschirm unserer mobilen Anwendung.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/2a/bc/v8/2abcv8sw0r9idx5m53mrj7hcf8u.jpeg" width="40%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Bildschirm kann in drei v√∂llig unabh√§ngige Abschnitte unterteilt werden: die Suchleiste, den Suchverlaufsblock und die Registerkarten mit Stellenangeboten. Es w√§re m√∂glich, alles in einem Seitenobjekt-e zu beschreiben (schlie√ülich ist dies ein separater, vollwertiger Bildschirm), aber es ist nicht sehr bequem, es zu verwenden, da jeder Abschnitt seine eigene Logik, seine eigenen Pr√ºfungen usw. hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Erweitern von Seitenobjekten tritt fr√ºher oder sp√§ter das Problem der Methodennamen auf. Es gibt viele verschiedene Zellen, Titel, Untertitel usw., daher m√ºssen Sie anstelle einfacher Namen lange Namen angeben und klarstellen, worauf sie sich genau beziehen. Das Schreiben von Tests wird sehr unpraktisch und schwierig. Jedes Mal, wenn Sie eine Methode im Test ausw√§hlen, m√ºssen Sie den Seitenobjektcode √∂ffnen und sorgf√§ltig darauf eingehen, um keinen Fehler zu machen.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyListPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertHistoryListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertHistoryListCellByTitleExists</span><span class="hljs-params">(title: String)</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertRecommendationsListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertVacancyNearbyListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }<font></font>
    ‚Ä¶  <font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/ia/_g/zwia_gz_wjygrw7tpmis1_gnx8q.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste L√∂sung besteht darin, das Problem nicht zu erkennen. Egal wie gro√ü das Seitenobjekt sein mag, Sie k√∂nnen es trotzdem verwenden (insbesondere, wenn Sie sich daran gew√∂hnt haben). Aber ich m√∂chte mich nicht daran gew√∂hnen, aber ich m√∂chte, dass es sch√∂n und bequem ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au√üerdem k√∂nnen diese "Abschnitte" verschiedene Module im Code sein, was bedeutet, dass sie auf verschiedenen Bildschirmen der Anwendung wiederverwendet werden k√∂nnen. Wenn wir eine √§hnliche Architektur mit Seitenobjekten erstellen, k√∂nnen wir sie auch wiederverwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eine willensstarke Entscheidung getroffen - jetzt schreiben wir f√ºr solche Abschnitte verschiedene Klassen von Seitenobjekten. Zu jedem von ihnen f√ºgen wir Korrespondenz zum vereinheitlichenden leeren MainScreenSection-Protokoll hinzu: BasePageObject {}. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen Sie zum Beispiel den Abschnitt Suchverlauf auf dem Hauptbildschirm. Das Seitenobjekt sieht folgenderma√üen aus:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchHistoryPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">MainScreenSection</span> </span>{
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grunds√§tzlich haben wir f√ºr das Seitenobjekt von MainScreenPageObject, das den Hauptbildschirm beschreibt, eine Methode erstellt, mit der wir aus dem Test sagen, in welchem ‚Äã‚ÄãAbschnitt wir jetzt etwas tun werden. </font><font style="vertical-align: inherit;">Es sieht aus wie das.&nbsp;</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainScreenPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span> </span>{<font></font>
    ‚Ä¶<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">section</span>&lt;Section: MainScreenSection&gt;<span class="hljs-params">(<span class="hljs-number">_</span> section: Section.<span class="hljs-keyword">Type</span>)</span></span> -&gt; <span class="hljs-type">Section</span> {
        <span class="hljs-keyword">return</span> section.<span class="hljs-keyword">init</span>(pageObjectsFactory: pageObjectsFactory, application: application)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir √ºbergeben den Abschnitts-Typ an diese Methode. Im Inneren initialisieren wir das Seitenobjekt mit der generischen Factory-Methode.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Ergebnis erhielten wir einen ununterbrochenen Test, das Fehlen unn√∂tiger Initialisierungen gro√üer Seitenobjekte und die Lesbarkeit des Codes.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//        ‚Äú ‚Äù</span>
    .openSearchTab() <span class="hljs-comment">//   MainScreenPageObject</span>
    .section(<span class="hljs-type">SearchHistoryPageObject</span>.<span class="hljs-keyword">self</span>) <span class="hljs-comment">//     </span>
    .waitHistoryIsLoad() <span class="hljs-comment">//   page object-  </span>
    .section(<span class="hljs-type">MainScreenPageObject</span>.<span class="hljs-keyword">self</span>) <span class="hljs-comment">//       </span>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen Autotests ohne eine Factory von Seitenobjekten schreiben. Seitenobjekte mit diesem Ansatz werden sehr schnell und einfach geschrieben, insbesondere wenn sie keine komplexe Initialisierung ben√∂tigen. Andererseits m√ºssen Sie beim Schreiben eines Tests √§u√üerst vorsichtig sein. Die Verantwortung f√ºr die Abfolge der Schritte im Test, die Initialisierung von Seitenobjekten, das Fehlen eines Wrappers f√ºr einige Aktionen usw. liegt beim Tester. Wenn Ihre Anwendung nicht sehr kompliziert ist, lohnt es sich m√∂glicherweise nicht, sie zu komplizieren, und alle aufgef√ºhrten Probleme sind im Allgemeinen unsichtbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie ganz am Anfang ein wenig √ºber die Schaffung der Fabrik sitzen, wird sie in Zukunft zum einen alle oben genannten Aufgaben √ºbernehmen und zum anderen das Schreiben von Autotests sehr einfach und fast fehlerfrei machen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/uc/i6/ta/uci6takmotdv_r0ujdl5kbv3_3a.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da es keine einzige richtige Entscheidung gibt, liegt es an Ihnen, zu entscheiden. </font><font style="vertical-align: inherit;">Wir verwenden weiterhin beide Ans√§tze, und alle f√ºhlen sich wohl und wohl. </font><font style="vertical-align: inherit;">Viel Gl√ºck und sch√∂ne Autotests!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√ºtzliche Links:</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel √ºber das Seitenobjektmuster</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cooler Artikel √ºber die Rolle der Architektur in der Automatisierung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotlin DSL, Fixtures und elegante UI-Tests in Android</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schnittstellen, Protokolle und Erweiterungen / Swift vs. </font><font style="vertical-align: inherit;">Kotlin</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kraft der Generika in Swift</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de507032/index.html">Buch ‚ÄûVerkaufen Sie Ihr Portfolio. Was in Designschulen nicht gelehrt wird "</a></li>
<li><a href="../de507034/index.html">Webstorm NodeJs Interpreter aus Docker-Container</a></li>
<li><a href="../de507040/index.html">So reduzieren Sie die Registrierung von Sch√§den aus der obligatorischen Kfz-Haftpflichtversicherung von wenigen Tagen auf 60 Minuten</a></li>
<li><a href="../de507042/index.html">Ich m√∂chte gamedev: 27 Antworten von 8 Profis</a></li>
<li><a href="../de507044/index.html">Das g√ºnstigste Board zum Experimentieren mit SoC'om MCU & FPGA</a></li>
<li><a href="../de507050/index.html">Analyse des Hollow Knight-Spieldesigns. Teil 1. Vergessene Kreuzung</a></li>
<li><a href="../de507052/index.html">Der coolste Data Scientist verschwendet keine Zeit mit Statistiken</a></li>
<li><a href="../de507066/index.html">10 M√∂glichkeiten zur Automatisierung von Anzeigen in Google Ads</a></li>
<li><a href="../de507068/index.html">Windows Management Instrumentation (WMI) -Handbuch: Grundlegendes zu WMI-Angriffen</a></li>
<li><a href="../de507074/index.html">SIMD-Spickzettel, jetzt f√ºr .NET Core</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>