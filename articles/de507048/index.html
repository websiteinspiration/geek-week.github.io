<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍✈️ 📡 🏂🏽 Olya, Tests und Fabrik - der Weg zu schöner Architektur und sauberem Code 👩🏾‍🤝‍👨🏽 🎽 👴🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der Testautomatisierung gibt es viele verschiedene Ansätze, Lösungen und Methoden. Am häufigsten und unverzichtbar ist das Muster "Seitenobjekt" (B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Olya, Tests und Fabrik - der Weg zu schöner Architektur und sauberem Code</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/507048/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Testautomatisierung gibt es viele verschiedene Ansätze, Lösungen und Methoden. </font><font style="vertical-align: inherit;">Am häufigsten und unverzichtbar ist das Muster "Seitenobjekt" (Bildschirmobjekt). </font><font style="vertical-align: inherit;">Bei der Arbeit mit diesem Muster bin ich auf zwei Ansätze gestoßen: mit einer Fabrik für meine Seitenobjekte und ohne. </font><font style="vertical-align: inherit;">In diesem Artikel vergleichen wir am Beispiel unserer Autotests beide Ansätze, ihre Vor- und Nachteile. </font><font style="vertical-align: inherit;">Lassen Sie mich Ihnen zeigen, wie unsere Fabrik für Seitenobjekte aussieht. </font><font style="vertical-align: inherit;">Ich werde auch über die Probleme sprechen, die bei Autotests mit der Fabrik aufgetreten sind, und wie sie gelöst wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde alle Beispiele im Artikel in Swift zitieren, aber für Android-Autotests funktioniert alles auf die gleiche Weise.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ci/5e/br/ci5ebr0v9onedivfawpjjy-ux0c.png"></div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für den Anfang</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hallo, mein Name ist Olya. Ich bin ein Tester für mobile Anwendungen bei hh.ru. Für zwei Jahre mit einem Schwanz haben wir 90% der manuellen Tests auf automatisiert übertragen. In dieser Zeit ist es uns gelungen, viele Male auf verschiedene Fallstricke zu stoßen, Hunderte von Streitigkeiten zu diskutieren, und jetzt möchte ich unsere Erfahrungen mit der Welt teilen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schreiben Autotests auf Android (Kotlin, Kaspresso) und iOS (Swift, XCUITest). Wir versuchen, UI-Tests klein zu machen und nur einzelne Skripte zu überprüfen. Der Nutzen von Eisen reicht dafür aus, und die Regression von ~ 300-400 UI-Autotests auf jeder Plattform dauert durchschnittlich 30-40 Minuten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unseren Autotests verwenden wir das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seitenobjektmuster</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tausende Artikel wurden über ihn geschrieben, daher werden wir nicht näher darauf eingehen.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Vergangenheit haben wir beim Erstellen der ersten Autotests unter iOS und Android verschiedene Ansätze für die Arbeit mit Seitenobjekten gewählt. </font><font style="vertical-align: inherit;">Unter Android folgen wir einfach dem Muster und unter iOS haben wir auch eine Factory mit Seitenobjekten erstellt. </font><font style="vertical-align: inherit;">Eine Factory ist der Ort, an dem alle Seitenobjekte initialisiert werden. </font><font style="vertical-align: inherit;">Mit diesen Methoden in unseren Bildschirmen können wir andere Seitenobjekte übertragen und so Interaktionsketten aufbauen, die dem Verhalten der Anwendung ähneln.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benötigt die Fabrik Seitenobjekte?&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir Hunderte von Testfällen erstellt hatten, kamen wir zu dem Schluss, dass die Verwendung der Factory von Seitenobjekten für den Tester, der Autotests schreibt, Geschmackssache ist. Bei der Arbeit mit unterschiedlichen Ansätzen gibt es keinen Unterschied in Leistung und Stabilität. Um jedoch in Zukunft nicht unter nativem Code zu leiden, müssen Sie so schnell wie möglich entscheiden, ob in der Architektur von Autotests ein Platz für die Page Object Factory vorhanden ist oder nicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Klarheit halber werde ich zwei Beispiele für denselben Test geben: geschrieben mit und ohne Fabrik.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was dieser Test bewirkt: Über den Hauptbildschirm der Anwendung versucht der Benutzer, zur Registerkarte Profil zu wechseln. Im Profil wählt er "Login", dann die Login-Methode per Login, gibt seinen Benutzernamen und sein Passwort ein und klickt dann auf die Schaltfläche "Login".</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//   </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{
   <span class="hljs-keyword">let</span> mainScreen = <span class="hljs-type">MainScreen</span>()
   <span class="hljs-keyword">let</span> profileScreen = <span class="hljs-type">ProfileScreen</span>()
   <span class="hljs-keyword">let</span> authorizationScreen = <span class="hljs-type">AuthorizationScreen</span>()
   <span class="hljs-keyword">let</span> loginScreen = <span class="hljs-type">LoginScreen</span>()<font></font>
 <font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser()<font></font>
 <font></font>
        mainScreen.openProfileTab()<font></font>
        profileScreen.goToAuthorization()<font></font>
        authorizationScreen.goToLogin()<font></font>
        loginScreen<font></font>
           .enterLogin(user.login)<font></font>
           .enterPassword(user.password)<font></font>
           .logIn()   <font></font>
   }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-comment">//   </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser()<font></font>
 <font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openProfileTab()<font></font>
            .goToAuthorization()<font></font>
            .goToLogin()<font></font>
            .enterLogin(user.login)<font></font>
            .enterPassword(user.password)<font></font>
            .logIn()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie nach diesem Beispiel entscheiden, dass Tests ohne Factory gut aussehen, greifen Sie einfach zu und schreiben Sie ohne. </font><font style="vertical-align: inherit;">Dieser Tipp ist besonders relevant, wenn Sie keine sehr große Anwendung mit unterschiedlichen, sich nicht wiederholenden Inhalten und Elementen haben. </font><font style="vertical-align: inherit;">Oder wenn Sie Tests schreiben, in denen nicht mehr als 10-15 Schritte erforderlich sind. </font><font style="vertical-align: inherit;">In diesem Fall wird die Fabrik das Wetter nicht tun.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wenn dies nicht der Fall ist oder wenn die Werkstests in Ihrem Herzen reagiert haben, dann ist dieser Artikel für Sie.&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qe/g4/zc/qeg4zcjbcn8z9yrhq83bmteoz8k.jpeg"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie sieht unsere Fabrik aus?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns herausfinden, wozu die Seitenobjektfabrik dient, wie sie aussieht und was sie tut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Standardtestfall besteht aus einer Reihe von Schritten:</font></font><br>
<blockquote><ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starte die Anwendung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Öffnen Sie den Profilbildschirm</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tippen Sie auf "Login".</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wählen Sie eine Anmeldemethode mit Login und Passwort</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzerdaten eingeben (Benutzername und Passwort)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tippen Sie auf die Schaltfläche "Anmelden"</font></font></li>
</ol><br>
</blockquote><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Screencast-Test</font></font></b>
                        <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/nYHsgZiJgo8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Schritt des Testfalls entspricht einem Schritt im Autotest. Sie können auch sagen, dass jeder Schritt eine separate Seitenobjektmethode des entsprechenden Bildschirms ist.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir diesen Testfall im Autotest genau in Schritten wiederholen möchten, dieselbe ununterbrochene Kette von Methodenaufrufen erstellen möchten, benötigen wir jede Methode, um das Seitenobjekt des nächsten Bildschirms zurückzugeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Erstellen eines Seitenobjekts muss es initialisiert werden. Es stellt sich heraus, dass, wenn wir Seitenobjekte in anderen erstellen möchten, in jedem Seitenobjekt viele identische Initialisierungen vorhanden sind. Um dies nicht zu tun, werden Initialisierungen aller Seitenobjekte in die Factory verschoben - pageObjectFactory (oder screenFactory usw.). Am Ende jeder Methode bitten wir die Fabrik, den Bildschirm zu erstellen, den wir benötigen.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfilePageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goToAuthScreen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AuthPageObject</span> {<font></font>
        openAuthButton.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeAuthPageObject()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Seitenobjekte werden von BasePageObject geerbt, das die Hauptparameter enthält. </font><font style="vertical-align: inherit;">Darin müssen wir einen erforderlichen Konstruktor vorschreiben, damit die Fabrik jeden ihrer Erben schaffen kann. </font><font style="vertical-align: inherit;">In unserem Fall sieht die Basisklasse folgendermaßen aus:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePageObject</span> </span>{
    <span class="hljs-keyword">let</span> pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>
    <span class="hljs-keyword">let</span> application: <span class="hljs-type">XCUIApplication</span><font></font>
 <font></font>
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>,<font></font>
                       application: <span class="hljs-type">XCUIApplication</span>) {
        <span class="hljs-keyword">self</span>.pageObjectsFactory = pageObjectsFactory
        <span class="hljs-keyword">self</span>.application = application<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Initialisierung der Bildschirme in der Fabrik sieht daher folgendermaßen aus:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageObjectsFactory</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initializePageObject</span>&lt;PageObject: BasePageObject&gt;<span class="hljs-params">(ofType type: PageObject.<span class="hljs-keyword">Type</span>)</span></span> -&gt; <span class="hljs-type">PageObject</span> {
        <span class="hljs-keyword">return</span> type.<span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-keyword">self</span>, application: application)<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeAuthPageObject</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AuthPageObject</span> {
        <span class="hljs-keyword">return</span> initializePageObject(ofType: <span class="hljs-type">AuthPageObject</span>.<span class="hljs-keyword">self</span>)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen können wir in der Methode eines beliebigen Seitenobjekts die Factory-Methode zum Erstellen eines Bildschirms aufrufen, der es initialisiert.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pluspunkte des Lebens eines Testers ohne Fabrik</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Aus dem Test geht immer hervor, auf welchem ​​Bildschirm die Aktion ausgeführt wird</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ohne Fabrik sind in jeder Zeile </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur des</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Testpunkts der Bildschirm und die darauf ablaufende Aktion eindeutig registriert. </font><font style="vertical-align: inherit;">Auf diese Weise können Sie nicht den gesamten Testcode von Anfang an lesen, z. B. beim Debuggen und bei Korrekturen. </font><font style="vertical-align: inherit;">Das Fehlen einer Fabrik erhöht die Lesbarkeit, insbesondere wenn Aktionen oder Überprüfungen auf einem Bildschirm ausgeführt werden.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span> : <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
<font></font>
    <span class="hljs-comment">//   ,   </span>
    <span class="hljs-keyword">let</span> mainScreen = <span class="hljs-type">MainScreen</span>()
    <span class="hljs-keyword">let</span> profileScreen = <span class="hljs-type">ProfileScreen</span>()
    <span class="hljs-keyword">let</span> authorizationScreen = <span class="hljs-type">AuthorizationScreen</span>()
    <span class="hljs-keyword">let</span> loginScreen = <span class="hljs-type">LoginScreen</span>()<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser() <span class="hljs-comment">//   </span><font></font>
 <font></font>
        mainScreen.openProfileTab() <span class="hljs-comment">//      </span>
        profileScreen.goToAuthorization() <span class="hljs-comment">//     ""</span>
        authorizationScreen.goToLogin() <span class="hljs-comment">//          </span>
        loginScreen <span class="hljs-comment">//           </span><font></font>
            .enterLogin(user.login)<font></font>
            .enterPassword(user.password)<font></font>
            .login()   <font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch wenn Sie nicht in alle Feinheiten der Anwendung vertieft sind, wird aus dem obigen Beispiel sofort ersichtlich, dass die Aktionen enterLogin / enterPassword auf demselben Bildschirm ausgeführt werden. </font><font style="vertical-align: inherit;">Der Test mit der Fabrik wird nicht so klar sein - Sie könnten denken, dass die enterLogin-Aktion den Benutzer zum nächsten Bildschirm weitergeleitet hat.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Es ist bequemer, Tests mit Aktionen zu schreiben, die zu unterschiedlichen Bildschirmen führen können</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie Tests ohne Factory schreiben, müssen Sie nicht daran denken, dass sich Benutzeraktionen je nach Status der Anwendung unterschiedlich verhalten können. Sie beschreiben lediglich die Logik des Geschehens:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//        </span><font></font>
    vacancyScreen.tapResponseButton()<font></font>
    authScreen.authUser(user)<font></font>
    responseScreen.checkScreenIsOpened()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
oder</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//       	</span><font></font>
    vacancyScreen.tapResponseButton()<font></font>
    responseScreen.checkScreenIsOpened()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Factory-Seitenobjekten müssen Sie darüber nachdenken, wie Sie je nach Berechtigung des Benutzers den gewünschten Bildschirm in der tapResponseButton () -Methode zurückgeben (oder eine Methode wie tapResponseButtonAndLogin () duplizieren können.)</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    …<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tapResponseButton</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ResponseSendPageObject</span> {<font></font>
        responseButton.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeResponseSendPageObject()<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tapResponseButtonAndLogin</span><span class="hljs-params">(login: String)</span></span> -&gt; <span class="hljs-type">ResponseSendPageObject</span> {<font></font>
        responseButton.tap()<font></font>
        pageObjectsFactory<font></font>
            .makeAuthorizationPageObject()<font></font>
            .goToLogin()<font></font>
            .logIn(login)<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeResponseSendPageObject()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben 6 ähnliche Methoden auf diesem Bildschirm, obwohl alle auf dieselbe Schaltfläche tippen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Sie müssen nicht jede Aktion und jeden Check in eine separate Methode einschließen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Methoden von Seitenobjekten ohne Factory müssen nicht den nächsten Bildschirm zurückgeben, um die Kette fortzusetzen. Für einzelne Aktionen können Sie keine separaten Methoden erstellen.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel könnte ein Tippen auf eine Schaltfläche in einem Test ohne Fabrik folgendermaßen aussehen:</font></font><br>
<br>
<pre><code class="swift hljs">    vacancyScreen.responseButton.tap()</code></pre><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Sie müssen nicht über komplexe Lösungen nachdenken, sondern zusätzlich über die Architektur von Seitenobjekten nachdenken</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach meiner Erfahrung gibt es beim Schreiben von Autotests ohne Factory praktisch keine Probleme mit Seitenobjekten. </font><font style="vertical-align: inherit;">Das Beschreiben eines neuen Seitenobjekts ist ein einfacher und schneller Vorgang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Fabrik fügt zusammen mit ihren Fähigkeiten einige Schwierigkeiten hinzu, die ich später diskutieren werde.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die unbestrittenen Vorteile der Fabrik</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Während Sie einen Test schreiben, können Sie keinen Schritt überspringen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Methoden von Seitenobjekten sind Glieder einer Kette. Jeder neue Link (Methode) sollte mit den folgenden verknüpft sein. Dies liegt an der Tatsache, dass alle Methoden ein Seitenobjekt (selbst oder ein anderes) zurückgeben, weshalb wir beim Schreiben eines Tests keine Möglichkeit haben, die Methode eines Bildschirms auszuwählen, sondern nur die folgenden.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens beschleunigt es das Schreiben Ihres ersten Autotests durch einen neuen Tester erheblich. Die IDE selbst teilt Ihnen mit, welche Aktionen und auf welchem ​​Bildschirm Sie weiter ausführen können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens können Sie mit dieser Architektur von Autotests die Anwendung anhand ihres Schreibens erkennen und nicht umgekehrt. (wieder - eine gute Motivation für junge Tester).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Drittens gibt es keine Möglichkeit, einen Schritt zu überspringen, da die gewünschte Methode erst angezeigt wird, wenn Sie das Skript korrekt übergeben haben. </font><font style="vertical-align: inherit;">Solche Auslassungen treten häufig auf, wenn Sie Tests ohne Factory schreiben, und Sie werden sie erst beim Ausführen des Tests erfahren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Wenn Sie die Signatur der Seitenobjektmethode ändern, werden Sie von der IDE gezwungen, alle mit dem Objekt verknüpften Tests zu ändern</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Punkt folgt aus dem vorherigen. </font><font style="vertical-align: inherit;">Alle Seitenobjektmethoden wiederholen die Logik und das Verhalten der Anwendung. </font><font style="vertical-align: inherit;">Wenn die Anwendung die Logik der Übergänge zwischen Bildschirmen ändert oder neue hinzufügt, korrigieren wir die benötigte Methode und ändern ihre Rückgabe. </font><font style="vertical-align: inherit;">Bei werkseitigen Selbsttests müssen Sie nicht alle Tests ausführen, um alle von dieser Änderung betroffenen Tests zu finden. </font><font style="vertical-align: inherit;">Die IDE selbst zeigt auf alle Stellen, an denen die "Kette" gerissen ist. </font><font style="vertical-align: inherit;">Tests ohne Fabrik folgen nicht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Architektur und Code-Sauberkeit leiden nicht unter der Erstellung überflüssiger Bildschirmobjekte&nbsp;</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie keine Factory verwenden und der Test das Skript durch Dutzende von Bildschirmen durchläuft, müssen Sie zu Beginn der Klasse mit dem Test einen ganzen Block zum Erstellen von Objekten für jeden Bildschirm schreiben. </font><font style="vertical-align: inherit;">Und Sie müssen dies jedes Mal für jede Testklasse tun. </font><font style="vertical-align: inherit;">Noch schlimmer, wenn Sie mehrere Tests in derselben Klasse schreiben. </font><font style="vertical-align: inherit;">Dann wird die Größe dieses „Blocks“ mit der Erstellung aller Seitenobjekte erheblich erhöht.&nbsp;&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Beispiel aus einem realen Test, bei dem der Benutzer auf eine freie Stelle reagiert, sich abmeldet und sich bei einem anderen Benutzer anmeldet. </font><font style="vertical-align: inherit;">Dieser Block wechselt mit geringfügigen Änderungen für alle ähnlichen Tests von Klasse zu Klasse.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterUpdateAfterOtherUserLoginTest</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> mainScreen = <span class="hljs-type">MainScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> vacanciesScreen = <span class="hljs-type">VacanciesScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> responseToVacancyScreen = <span class="hljs-type">ResponseToVacancyBottomSheet</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> successResponseBottomSheet = <span class="hljs-type">SuccessResponseBottomSheet</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> settingsScreen = <span class="hljs-type">UserSettingsScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> chooseAuthScreen = <span class="hljs-type">ChooseAuthScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> authScreen = <span class="hljs-type">NativeAuthScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> navigation = <span class="hljs-type">NavigationPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> moreScreen = <span class="hljs-type">MoreScreenPageObject</span>()<font></font>
<font></font>
    ...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es besteht die Möglichkeit, die Initialisierung aller Seitenobjekte in der Basisklasse der Tests mithilfe der verzögerten Initialisierung durchzuführen. </font><font style="vertical-align: inherit;">Dann sind in jedem Test alle Bildschirme verfügbar und es werden keine unnötigen Objekte erstellt. </font><font style="vertical-align: inherit;">Das Problem beim Auflisten vieler Bildschirme tritt jedoch wieder auf, wenn Seitenobjekte in den Seitenobjekten selbst erstellt werden sollen, wenn eine Methode geschrieben werden muss, die einen anderen Bildschirm durchläuft. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Fabrik übernimmt die Aufgabe, die erforderlichen Seitenobjekte bei Bedarf zu initialisieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Eine großartige Gelegenheit, tiefer in den Anwendungscode einzutauchen, seine Architektur, Module, ihre Interaktion usw. zu studieren.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um eine Factory von Seitenobjekten zu haben, müssen alle Aktionen mit dem Bildschirm in Methoden eingeschlossen werden, die den nächsten Bildschirm zurückgeben. </font><font style="vertical-align: inherit;">Aus diesem Grund werden Seitenobjekte stark erweitert, sodass Sie sich fragen, wie Sie alles schöner und genauer machen können. </font><font style="vertical-align: inherit;">Aus diesem Grund versuchen Sie, Architekturtechniken zu verwenden, die Implementierung verschiedener Bildschirme im Anwendungscode zu beobachten und die Interaktion von Modulen zu verfolgen, um ein ähnliches System in Ihren Autotests zu erstellen, das angenehm und bequem zu verwenden ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Bonus erhalten wir von innen Kenntnisse darüber, wie die Anwendung funktioniert. </font><font style="vertical-align: inherit;">Zumindest ist dies für die Gesamtentwicklung nützlich und hilft beim Testen oft sehr.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Der Testcode sieht sehr ordentlich und sauber aus.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt keine Kommentare, das ist wirklich aromatisch. </font><font style="vertical-align: inherit;">Wie für Sie "genauer und sauberer" ist, kann schon das erste Beispiel entscheiden.</font></font><br>
<br>
<p></p><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fallstricke // wie sie stolperten und herumgingen</font></font></h1><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gd/4a/jz/gd4ajzpobkjvg6t4tq1vy-3a-ws.jpeg" width="60%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können daraus schließen, dass es besser ist, beim Schreiben von Autotests die Factory von Seitenobjekten zu verwenden. </font><font style="vertical-align: inherit;">Fragen Sie niemanden, warum sie die Fabrik benutzen, es gibt immer eine Antwort: "Und Sie versuchen, einen Test ohne ihn zu schreiben und zu vergleichen." </font><font style="vertical-align: inherit;">Die Fabrik übernimmt wirklich einen wesentlichen Teil der Aufgaben, die Verantwortung für das Fehlen von Fehlern in der Reihenfolge des Autotests und so weiter. </font><font style="vertical-align: inherit;">Es eröffnet auch einige interessante Möglichkeiten, über die ich oben geschrieben habe.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte jedoch darauf hinweisen, dass mit diesen Funktionen nicht immer alles rosig ist. </font><font style="vertical-align: inherit;">Während der Automatisierung mit der Fabrik sind wir auf sehr unangenehme Probleme gestoßen, aber am Ende haben wir sie gelöst.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokolle und Elemente, die der gesamten Anwendung gemeinsam sind</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jeder mobilen Anwendung gibt es Elemente, auf die von jedem Bildschirm aus zugegriffen werden kann. Sie können beispielsweise eine Registerkarte (Menü) verwenden. Es stellt sich die Frage: Wie können Sie jederzeit im Test auf die Methoden der Registerkarten zugreifen, ohne die Aufrufkette für Seitenobjektmethoden zu unterbrechen?&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die naheliegendste und erste Entscheidung ist, die Basisklasse der Seitenobjekte mit diesen Methoden zu erweitern.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> XCTest<font></font>
 <font></font>
<span class="hljs-comment">/*
      .
 */</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> tabBar = application.tabBars[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.identifier].firstMatch
    <span class="hljs-keyword">var</span> searchTab =  tabBar.buttons[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.searchTab].firstMatch<font></font>
    …<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span> {<font></font>
        searchTab.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory.makeMainScreenPageObject()<font></font>
    }<font></font>
    …<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während der Diskussion stellten wir fest, dass die Registerkartenleiste nicht das einzige Element ist, das auf allen Bildschirmen benötigt wird, und kamen zu dem Schluss, dass wir durch Hinzufügen von immer mehr Erweiterungen die Basisklasse schnell überladen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer Nachteil dieser Lösung besteht darin, dass die Methoden für alle Seitenobjekte verfügbar werden, was falsch ist. Dies bricht den Vertrag für Nachfolgeklassen, die theoretisch nur für sie spezifische Methoden enthalten sollten. Beispielsweise werden für Seitenwarnobjekte keine Registerkartenmethoden benötigt.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere endgültige Lösung - wir haben das TabBarUsable-Protokoll aus dem Seitenobjekt von Tabbar erstellt (die Benutzeroberfläche für Kotlin ist ähnlich). Und sie haben die Erweiterung (Erweiterung, Implementierung) geschrieben, mit der Sie den Code nicht duplizieren und gleichzeitig die Vererbung durch die Komposition ersetzen können.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> XCTest<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TabBarUsable</span> </span>{
    <span class="hljs-keyword">var</span> searchTab: <span class="hljs-type">XCUIElement</span> { <span class="hljs-keyword">get</span> }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span><font></font>
    …<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">TabBarUsable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> tabBar: <span class="hljs-type">XCUIElement</span> { application.tabBars[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.identifier].firstMatch }
    <span class="hljs-keyword">var</span> searchTab: <span class="hljs-type">XCUIElement</span> { tabBar.buttons[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.searchTab].firstMatch }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span> {<font></font>
        searchTab.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory.makeMainScreenPageObject()<font></font>
    }<font></font>
    …<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für alle Bildschirme mit einer Registerkarte fügen wir die Konformität mit diesem Protokoll hinzu (konform).</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span> </span>{<font></font>
    …<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dementsprechend stehen auf allen diesen Bildschirmen alle Methoden zum Arbeiten mit einer Registerkarte zur Verfügung.&nbsp;</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleTabbarTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleOpenSearchTab</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy() <span class="hljs-comment">//   .makeVacancyPageObject()</span>
            .openSearchTab() <span class="hljs-comment">//   TabBarUsable </span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleichzeitig bricht die Architektur nicht, die Methoden der Registerkartenleiste sind nur für die von uns benötigten Bildschirme verfügbar, und der Code derselben Methoden wird nicht dupliziert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokolle und Code-Revision</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erwähnt, werden bei Verwendung der Seitenobjektfactory alle Aktionen und Überprüfungen in Methoden eingeschlossen. </font><font style="vertical-align: inherit;">Nach einer Weile, wenn Sie den nächsten Autotest erstellen, stellen Sie fest, dass Sie für jedes Seitenobjekt dieselben Methoden schreiben, die sich in den Elementen nicht einmal unterscheiden. </font><font style="vertical-align: inherit;">Beispiele für solche Methoden können Nullbildprüfungen sein, die mit identischen Listenelementen auf verschiedenen Bildschirmen arbeiten, und so weiter.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/a2/xg/ic/a2xgiczqetidmsoqa2rl2aandjo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen logischen Gedanken: "Ich werde es mir leichter machen ?!" Wie kann ich das Duplizieren von Code beenden? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Methode, über die ich bereits geschrieben habe, besteht darin, alle diese Methoden in die Basisklasse aufzunehmen. Es ist möglich, aber sehr vorsichtig. Erstens ist dieser Prozess sehr faszinierend. Es scheint, dass eine Methode in der Basisklasse nichts ruinieren wird, aber früher oder später wird die Basisklasse zu einem unerträglichen, unstrukturierten, überfüllten Monster, kurz gesagt, es wird völlig unmöglich. Wir haben es versucht, wir wissen. Dieses Monster loszuwerden ist noch schwieriger als es sofort richtig zu machen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Laufe der Zeit haben wir festgestellt, dass das DRY-Prinzip (Don't Repeat Yourself) aus einem bestimmten Grund erfunden wurde. Wir haben begonnen, nach denselben Methoden zu suchen, die in vielen Seitenobjekten verwendet werden. Nachdem sie sie gefunden hatten, diskutierten sie lange darüber, ob diese Methoden wirklich überall gleich angewendet werden und dieselbe Logik haben. Und schließlich entschieden sie, dass, wenn die Methoden in 80% der Fälle auf die gleiche Weise verwendet werden, sie in einem separaten Protokoll entfernt werden sollten.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine der allerersten gerenderten Methoden war die waitView () -Methode. Wir haben das spezielle Protokoll ViewWaitable und seine Implementierung in der Protokollerweiterung beschrieben. Damit diese Methode im Seitenobjekt verfügbar ist, müssen Sie nur noch die Konformität zum Protokoll hinzufügen (konform). Da die Ansichtskennungen für alle Bildschirme unterschiedlich sind, müssen alle Seitenobjekte, die das Protokoll verwenden, eine Ansicht für sich deklarieren.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewWaitable</span> </span>{
    <span class="hljs-keyword">var</span> view: <span class="hljs-type">XCUIElement</span> { <span class="hljs-keyword">get</span> }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewWaitable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-meta">@discardableResult</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">waitView</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> {<font></font>
        testWaiter.waitForElementToAppear(view)<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span>, <span class="hljs-title">ViewWaitable</span> </span>{<font></font>
 <font></font>
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> view = application.otherElements[<span class="hljs-type">Accessibility</span>.view].firstMatch<font></font>
    …<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Beispiel aus unserer hh.ru-Anwendung: Wir haben eine Liste von Stellenangeboten, die auf vielen verschiedenen Bildschirmen zu finden sind. Der einzige Unterschied besteht in der Ansichtskennung, auf der diese Liste angezeigt wird. Mit dieser Liste sind viele Aktionen und eine Menge Überprüfungen verbunden. Multiplizieren Sie sie mit etwa 10 (mit der Anzahl der Bildschirme, auf denen diese Liste angezeigt wird), um den Umfang der Codeduplizierung abzuschätzen.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Lösung waren wieder die Protokolle. Um die Protokolle noch verständlicher und benutzerfreundlicher zu machen, haben wir die Listenelemente (VacancyListContainig), die Zellenelemente (VacancyCellContainig), die Methoden mit Prüfungen (Asserts, Prüfungen) und die Interaktionsmethoden (Aktionen) unterteilt. Diese Trennung löste perfekt das Problem der Lesbarkeit des Inhalts eines riesigen Seitenobjekts. Die endgültige Architektur sieht folgendermaßen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sx/zw/_j/sxzw_jfnqwufs2snkgohmzxawb4.png" width="50%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seitenobjekte, für die eine Liste mit offenen Stellen vorhanden ist, können die Konformität mit dem VacancyListPageObject-Protokoll erhöhen. </font><font style="vertical-align: inherit;">Somit werden alle Methoden aus der Implementierung dieses Protokolls ohne Duplizierung des Codes für den Bildschirm verfügbar.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchResultPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">ViewWaitable</span>, <span class="hljs-title">VacancyListPageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> view = application<font></font>
        .otherElements[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">SearchResults</span>.view].firstMatch
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> listView = application<font></font>
        .tables[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">SearchResults</span>.tableView].firstMatch<font></font>
    …<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund des DRY-Prinzips haben wir daher sehr saubere, ordentliche Seitenobjekte, dieselben Methodennamen und das Fehlen von zusätzlichem Code.&nbsp;</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieselben Warnungen auf verschiedenen Bildschirmen // Quellen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Systemfehler, Warnungen und untere Blätter sind ein wesentlicher Bestandteil von Regressionen, die ich auf jeden Fall mit automatischen Tests behandeln möchte. Fehler und Warnungen treten auf verschiedenen Bildschirmen auf, unterscheiden sich in verschiedenen Fällen in verschiedenen Anwendungsstatus, aber die Elemente selbst haben im Grunde die gleichen Kennungen und das gleiche Verhalten. Offensichtlich ist dieselbe Art von Warnung mit zwei Schaltflächen (z. B. OK / Abbrechen) = ein separates Seitenobjekt.&nbsp;&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir kehren zu dem Wunsch zurück, die Kette von Methodenaufrufen nicht zu unterbrechen. Wir haben - Dutzende von Bildschirmen, von denen aus wir dieselbe Warnung öffnen können. Wenn wir eine solche Warnung schließen, müssen wir zu dem Seitenobjekt zurückkehren, von dem aus sie geöffnet wurde. Gleichzeitig möchten wir nicht diese Dutzenden von doppelten Methoden in das Seitenobjekt einer solchen Warnung schreiben, die sich nur im zurückgegebenen Seitenobjekt voneinander unterscheiden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste Lösung besteht darin, den Test einmal zu bewerten und abzubrechen. </font><font style="vertical-align: inherit;">Daran ist auch nichts auszusetzen. </font><font style="vertical-align: inherit;">Und so ist das Leben viel einfacher.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExample</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy()<font></font>
            .openAlert()<font></font>
            .closeAlert() <span class="hljs-comment">//      ,     </span><font></font>
        pageObjectFactory<font></font>
            .makeVacancyPageObject() <span class="hljs-comment">//   </span><font></font>
        …<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Lösung ist komplizierter, aber wie schön sie ist! </font><font style="vertical-align: inherit;">Wir haben das Seitenobjekt des Alarmtyp-Parameters ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generisch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">hinzugefügt. Dies </font><font style="vertical-align: inherit;">ist der Typ des Seitenobjekts, von dem aus wir den Alarm öffnen. </font><font style="vertical-align: inherit;">In diesem Fall wird das Seitenobjekt dieses Bildschirms bei der Initialisierung an den Seitenobjektalarm übergeben und als generische Quellvariable gespeichert.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Informationen zur Funktionsweise: Wenn Sie eine Warnung öffnen (und initialisieren), übergeben wir den gewünschten Bildschirm in der generischen Quellvariablen. </font><font style="vertical-align: inherit;">Dies erfolgt in der Seitenobjektmethode, die die Warnung öffnet:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    …<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openAlert</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AlertPageObject</span>&lt;<span class="hljs-type">VacancyPageObject</span>&gt; {<font></font>
        button.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeAlertPageObject(from: <span class="hljs-keyword">self</span>) <span class="hljs-comment">//  source VacancyPageObject</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Nächstes durchläuft diese Quelle (in diesem Beispiel VacancyPageObject) alle im Test erforderlichen Methoden und landet in der endgültigen Entlassung von Alert (). </font><font style="vertical-align: inherit;">Infolgedessen gibt die Methode zum Schließen von Warnungen den benötigten Bildschirm zurück, auf dem wir den Test sofort fortsetzen können.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlertPageObject</span>&lt;<span class="hljs-title">Source</span>: <span class="hljs-title">BasePageObject</span>&gt;: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dismissAlert</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Source</span> {<font></font>
        cancelButton.tap()<font></font>
        <span class="hljs-keyword">return</span> source <span class="hljs-comment">//  ,     — VacancyPageObject</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie ich bereits sagte, muss das Seitenobjekt, damit es die erforderlichen Bildschirme (Quellen) empfangen und zurückgeben kann, einen generischen Typ zuweisen, der auf den Basistyp der Seitenobjekte beschränkt ist, und ihn mit einem Seitenobjekt initialisieren, das ganz am Ende zurückgegeben werden muss ::</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlertPageObject</span>&lt;<span class="hljs-title">Source</span>: <span class="hljs-title">BasePageObject</span>&gt;: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-comment">// generic-          </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> source: <span class="hljs-type">Source</span><font></font>
 <font></font>
    <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>,<font></font>
         application: <span class="hljs-type">XCUIApplication</span>,<font></font>
         source: <span class="hljs-type">Source</span>) {
        <span class="hljs-keyword">self</span>.source = source
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(pageObjectsFactory: pageObjectsFactory, application: application)<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-comment">//  BasePageObject   ,      </span>
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>, application: <span class="hljs-type">XCUIApplication</span>) {
        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"init(pageObjectsFactory:application:) has not been implemented. Use another init"</span>)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Initialisierung des generischen Seitenobjekts in der Factory sieht folgendermaßen aus:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageObjectsFactory</span> </span>{<font></font>
    …<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeAlertPageObject</span>&lt;Source: BasePageObject&gt;<span class="hljs-params">(
        from source: Source
    )</span></span> -&gt; <span class="hljs-type">AlertPageObject</span>&lt;<span class="hljs-type">Source</span>&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-type">AlertPageObject</span>(pageObjectsFactory: <span class="hljs-keyword">self</span>,<font></font>
                                          application: application,<font></font>
                                          source: source)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ta-daa! </font><font style="vertical-align: inherit;">Alles ist fertig und jetzt können wir den Test fortsetzen, ohne die Anrufkette zu unterbrechen.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleSourcesTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleSource</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy()<font></font>
            .openAlert()<font></font>
            .dismissAlert()<font></font>
            .checkVacancyScreenIsOpened() <span class="hljs-comment">//       ,         </span><font></font>
        …<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gn/rt/hs/gnrthsrb0jerc7jtimpsmfqeryw.jpeg" width="70%"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Riesiges Seitenobjekt, wie man es versteht</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt Bildschirme (obwohl es solche gibt), auf denen viele verschiedene Inhalte, verschiedene Schnittstellenelemente und einzelne logische Blöcke platziert sind. Gleichzeitig befinden sich alle auf demselben Bildschirm, und ich möchte über das Seitenobjekt, das diesen Bildschirm beschreibt, mit ihnen interagieren.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen Sie zum Beispiel den Hauptbildschirm unserer mobilen Anwendung.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/2a/bc/v8/2abcv8sw0r9idx5m53mrj7hcf8u.jpeg" width="40%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Bildschirm kann in drei völlig unabhängige Abschnitte unterteilt werden: die Suchleiste, den Suchverlaufsblock und die Registerkarten mit Stellenangeboten. Es wäre möglich, alles in einem Seitenobjekt-e zu beschreiben (schließlich ist dies ein separater, vollwertiger Bildschirm), aber es ist nicht sehr bequem, es zu verwenden, da jeder Abschnitt seine eigene Logik, seine eigenen Prüfungen usw. hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Erweitern von Seitenobjekten tritt früher oder später das Problem der Methodennamen auf. Es gibt viele verschiedene Zellen, Titel, Untertitel usw., daher müssen Sie anstelle einfacher Namen lange Namen angeben und klarstellen, worauf sie sich genau beziehen. Das Schreiben von Tests wird sehr unpraktisch und schwierig. Jedes Mal, wenn Sie eine Methode im Test auswählen, müssen Sie den Seitenobjektcode öffnen und sorgfältig darauf eingehen, um keinen Fehler zu machen.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyListPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    …<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertHistoryListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertHistoryListCellByTitleExists</span><span class="hljs-params">(title: String)</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertRecommendationsListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertVacancyNearbyListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }<font></font>
    …  <font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/ia/_g/zwia_gz_wjygrw7tpmis1_gnx8q.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste Lösung besteht darin, das Problem nicht zu erkennen. Egal wie groß das Seitenobjekt sein mag, Sie können es trotzdem verwenden (insbesondere, wenn Sie sich daran gewöhnt haben). Aber ich möchte mich nicht daran gewöhnen, aber ich möchte, dass es schön und bequem ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Außerdem können diese "Abschnitte" verschiedene Module im Code sein, was bedeutet, dass sie auf verschiedenen Bildschirmen der Anwendung wiederverwendet werden können. Wenn wir eine ähnliche Architektur mit Seitenobjekten erstellen, können wir sie auch wiederverwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eine willensstarke Entscheidung getroffen - jetzt schreiben wir für solche Abschnitte verschiedene Klassen von Seitenobjekten. Zu jedem von ihnen fügen wir Korrespondenz zum vereinheitlichenden leeren MainScreenSection-Protokoll hinzu: BasePageObject {}. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen Sie zum Beispiel den Abschnitt Suchverlauf auf dem Hauptbildschirm. Das Seitenobjekt sieht folgendermaßen aus:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchHistoryPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">MainScreenSection</span> </span>{
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grundsätzlich haben wir für das Seitenobjekt von MainScreenPageObject, das den Hauptbildschirm beschreibt, eine Methode erstellt, mit der wir aus dem Test sagen, in welchem ​​Abschnitt wir jetzt etwas tun werden. </font><font style="vertical-align: inherit;">Es sieht aus wie das.&nbsp;</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainScreenPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span> </span>{<font></font>
    …<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">section</span>&lt;Section: MainScreenSection&gt;<span class="hljs-params">(<span class="hljs-number">_</span> section: Section.<span class="hljs-keyword">Type</span>)</span></span> -&gt; <span class="hljs-type">Section</span> {
        <span class="hljs-keyword">return</span> section.<span class="hljs-keyword">init</span>(pageObjectsFactory: pageObjectsFactory, application: application)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir übergeben den Abschnitts-Typ an diese Methode. Im Inneren initialisieren wir das Seitenobjekt mit der generischen Factory-Methode.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Ergebnis erhielten wir einen ununterbrochenen Test, das Fehlen unnötiger Initialisierungen großer Seitenobjekte und die Lesbarkeit des Codes.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//        “ ”</span>
    .openSearchTab() <span class="hljs-comment">//   MainScreenPageObject</span>
    .section(<span class="hljs-type">SearchHistoryPageObject</span>.<span class="hljs-keyword">self</span>) <span class="hljs-comment">//     </span>
    .waitHistoryIsLoad() <span class="hljs-comment">//   page object-  </span>
    .section(<span class="hljs-type">MainScreenPageObject</span>.<span class="hljs-keyword">self</span>) <span class="hljs-comment">//       </span>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können Autotests ohne eine Factory von Seitenobjekten schreiben. Seitenobjekte mit diesem Ansatz werden sehr schnell und einfach geschrieben, insbesondere wenn sie keine komplexe Initialisierung benötigen. Andererseits müssen Sie beim Schreiben eines Tests äußerst vorsichtig sein. Die Verantwortung für die Abfolge der Schritte im Test, die Initialisierung von Seitenobjekten, das Fehlen eines Wrappers für einige Aktionen usw. liegt beim Tester. Wenn Ihre Anwendung nicht sehr kompliziert ist, lohnt es sich möglicherweise nicht, sie zu komplizieren, und alle aufgeführten Probleme sind im Allgemeinen unsichtbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie ganz am Anfang ein wenig über die Schaffung der Fabrik sitzen, wird sie in Zukunft zum einen alle oben genannten Aufgaben übernehmen und zum anderen das Schreiben von Autotests sehr einfach und fast fehlerfrei machen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/uc/i6/ta/uci6takmotdv_r0ujdl5kbv3_3a.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da es keine einzige richtige Entscheidung gibt, liegt es an Ihnen, zu entscheiden. </font><font style="vertical-align: inherit;">Wir verwenden weiterhin beide Ansätze, und alle fühlen sich wohl und wohl. </font><font style="vertical-align: inherit;">Viel Glück und schöne Autotests!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nützliche Links:</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel über das Seitenobjektmuster</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cooler Artikel über die Rolle der Architektur in der Automatisierung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotlin DSL, Fixtures und elegante UI-Tests in Android</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schnittstellen, Protokolle und Erweiterungen / Swift vs. </font><font style="vertical-align: inherit;">Kotlin</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kraft der Generika in Swift</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de507032/index.html">Buch „Verkaufen Sie Ihr Portfolio. Was in Designschulen nicht gelehrt wird "</a></li>
<li><a href="../de507034/index.html">Webstorm NodeJs Interpreter aus Docker-Container</a></li>
<li><a href="../de507040/index.html">So reduzieren Sie die Registrierung von Schäden aus der obligatorischen Kfz-Haftpflichtversicherung von wenigen Tagen auf 60 Minuten</a></li>
<li><a href="../de507042/index.html">Ich möchte gamedev: 27 Antworten von 8 Profis</a></li>
<li><a href="../de507044/index.html">Das günstigste Board zum Experimentieren mit SoC'om MCU & FPGA</a></li>
<li><a href="../de507050/index.html">Analyse des Hollow Knight-Spieldesigns. Teil 1. Vergessene Kreuzung</a></li>
<li><a href="../de507052/index.html">Der coolste Data Scientist verschwendet keine Zeit mit Statistiken</a></li>
<li><a href="../de507066/index.html">10 Möglichkeiten zur Automatisierung von Anzeigen in Google Ads</a></li>
<li><a href="../de507068/index.html">Windows Management Instrumentation (WMI) -Handbuch: Grundlegendes zu WMI-Angriffen</a></li>
<li><a href="../de507074/index.html">SIMD-Spickzettel, jetzt für .NET Core</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>