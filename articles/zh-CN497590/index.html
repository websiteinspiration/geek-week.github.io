<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏼 🤠 👨🏿‍🏫 我们处理波动函数崩溃算法 🕧 🎋 🦋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="自DeBroglie和Tessera出现以来，我多次被要求解释它们的工作原理。生成可能看起来像魔术，但其背后的规则实际上很简单。
 
 那么什么是波动函数崩溃（WFC）算法？它是由Maxim Gumin开发的，它基于简单的配置或图像样本来创建“平铺”图像。该算法可以做很多事情：浏览Maxim和Twi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>我们处理波动函数崩溃算法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/497590/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/0p/3h/m9/0p3hm9jziz_gbzi9tajbo2p_s3a.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DeBroglie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tessera</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出现以来</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">，</font></a><font style="vertical-align: inherit;">我多次被要求解释它们的工作原理。</font><font style="vertical-align: inherit;">生成可能看起来像魔术，但其背后的规则实际上很简单。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那么什么是波动函数崩溃（WFC）算法？</font><font style="vertical-align: inherit;">它是由</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxim Gumin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开发的，它</font><font style="vertical-align: inherit;">基于简单的配置或图像样本来创建“平铺”图像。</font><font style="vertical-align: inherit;">该算法可以做很多事情：浏览Maxim和Twitter提供的示例</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#wavefunctioncollapse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，观看</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">种类惊人。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://www.boristhebrave.com/wp-content/uploads/2020/04/platformer.webm" type="video/webm"></video></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
README中的Maxim简要解释了WFC的工作，但在我看来，这个问题需要从最基础的角度进行更详细的披露。由于该算法与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束编程</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关</font><font style="vertical-align: inherit;">，因此本文的大部分内容都致力于</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解释约束编程的概念，最后我们将回到WFC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
受限编程是一种指示计算机的方法。与命令式编程不同，当您指定显式函数列表或函数式编程时，当您指定数学函数时，此处为计算机提供了对该问题的严格描述，并且计算机使用内置算法来查找解决方案。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本指南介绍了各种概念，而不是方法和代码。</font><font style="vertical-align: inherit;">如果您对实现更感兴趣，那么可以使用我的WFC开源库（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尽管最好从</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxim</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">实现</font></a><font style="vertical-align: inherit;">开始研究</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果您使用Unity，则可以购买</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tessera</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是我在此引擎中应用WFC的工具。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">迷你数独</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为说明性任务，我选了一个迷你</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数独游戏</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个看起来像4×4网格的谜题，在某些单元格中带有数字。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/079/ce5/2d2079ce585502dbe9329e0a34cfbed8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目标是按照规则用1到4的数字填充每个空单元格：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从1到4的每个数字必须在一个副本中的每一行中出现。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单个副本中的每一列中必须存在1到4之间的每个数字。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单个副本中每个2×2角正方形中必须存在从1到4的每个数字。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据这些规则，解决方案如下：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9e/ebf/927/d9eebf92740912d10aaaf6e63db189f3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能已经轻松解决了这个难题。</font><font style="vertical-align: inherit;">但是我们对计算机如何执行此操作感兴趣。</font><font style="vertical-align: inherit;">该问题可分为两部分：计算机条件的描述，然后是使用算法的解决方案。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件说明</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，为此使用受限制的编程语言。有几种这样的语言，它们的作用原理相似。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们定义</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在这里，它们与常规编程中的不同。在问题解决者的上下文中，变量是一个未知值，必须解决该未知值才能解决问题。在我们的数独示例中，我们将为所有空单元格创建变量。为方便起见，您还可以为填充的单元格创建变量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，为每个变量定义一个</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">域</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：一组可能的值。在我们的数独中，对于每个空单元格，域将为{1、2、3、4}。对于已经输入1的单元格，域将为{1}。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我们设置</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：绑定变量的规则。</font><font style="vertical-align: inherit;">在大多数编程语言中，已经存在具有限制的函数，该函数</font></font><code>all_distinct(..)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要传递唯一值。</font><font style="vertical-align: inherit;">因此Sudoku规则可以转换为12个约束</font></font><code>all_distinct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-每行和每列一个</font><font style="vertical-align: inherit;">约束</font><font style="vertical-align: inherit;">，以及2×2角正方形。</font><font style="vertical-align: inherit;">我们只需要一种约束即可解决此问题，但是，用于满足约束的问题解决程序通常带有一个大型的库，其中包含各种类型的约束来描述您的问题。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：在实践中，编程语言在约束中支持数组，因此有更准确的方式来表达此任务。</font><font style="vertical-align: inherit;">网上有很多关于解决数独问题的文章。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决约束满足问题的算法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有几种不同的解决方案技术。</font><font style="vertical-align: inherit;">但是，我将考虑其中最简单的方法来向您展示其工作原理。</font><font style="vertical-align: inherit;">每个单元的域如下所示：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/192/dd5/6d7/192dd56d7c6fad65e9d0ff0cd672b8b8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些都是可变域中的所有可能值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在采取第一个限制。</font><font style="vertical-align: inherit;">它要求第一行中的所有值都是唯一的。</font><font style="vertical-align: inherit;">在一个单元格中，值4已被内接，因此，在该系列的其他单元格中，该值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能为</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将其从这些细胞的域中删除。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea5/f37/ab8/ea5f37ab81c6fe4e923999a01d9c5b81.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对所有12个限制重复此过程。</font><font style="vertical-align: inherit;">这称为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">限制传播</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为信息是通过限制从一个变量分发到另一个变量的。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c06/08e/1fa/c0608e1fa9d933b28269217ae9678831.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
瞧，我们有变量，在变量域中还剩一个值。</font><font style="vertical-align: inherit;">这些</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是这些变量的正确解决方案。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02e/074/d2c/02e074d2cdcde1220efade75f26d7234.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
似乎我们可以从限制的分配中获得更多的好处：新的红色单位表示我们将在单个域中拥有更多的变量，这也将有助于分配。</font><font style="vertical-align: inherit;">重复该过程，直到解决难题。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f78/94d/b63/f7894db63f3238fab4cf689941bd9d69.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使任务复杂化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，并不是所有的逻辑难题都能这么快解决。</font><font style="vertical-align: inherit;">这是一个大数独，其工作方式相同，不同之处在于，现在我们有9个不同的值，9行，9列和9 3×3正方形。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd2/97d/434/fd297d4345a2593633a88bbf0bf26764.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们尝试应用上述技术，则会陷入困境：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/481/f68/a82/481f68a826b65b43441ddae08821f1ba.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在所有限制都是通用的，但是仍然存在未定义的变量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人将决定这一点，但是计算机算法将无法决定。人们的手册说，现在我们需要寻找越来越复杂的逻辑结论。但是我们不需要计算机算法来执行此操作，因为它很复杂，但是我们需要一种</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法，该算法可以满足任何限制条件，而不仅仅是根据数独规则。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，计算机做的最愚蠢的事情是：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它们假设</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。首先，我们记录拼图的当前状态。然后，我们选择一个任意变量并将其设置为可能的值之一。假设我们将值1分配给中央单元格。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们可以进一步扩展限制。</font><font style="vertical-align: inherit;">这是我在中心栏得到的：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f8b/176/f83/f8b176f83864aad8a4907714b7d0b790.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
蓝色值是我们在假设之后得出的结论。</font><font style="vertical-align: inherit;">如您所见，发生了一些事情。</font><font style="vertical-align: inherit;">我们放下了一些变量，但看看中间的上部单元格。</font><font style="vertical-align: inherit;">它是空的：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在其域中，没有</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">满足限制的</font><strong><font style="vertical-align: inherit;">可能值</font></strong><font style="vertical-align: inherit;">（不能为5，因为该值已经存在于相同的3×3正方形中，并且所有其他数字已经在此列中）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们获得的变量的域为空，则意味着我们无法为其分配任何值。</font><font style="vertical-align: inherit;">即，难题无法解决。</font><font style="vertical-align: inherit;">事实证明，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的假设是错误的</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
面对这样的矛盾，我们执行</font><strong><font style="vertical-align: inherit;">退货搜索</font></strong><font style="vertical-align: inherit;">流程</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（回溯）。首先，我们恢复假设之前的状态。然后，从域中删除用作假设的值-它不再是正确的答案。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1f/6b5/684/b1f6b5684064aab0ed2c355774b3d7aa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
许多工作已经完成，但是他们已经前进了。但是，即使从中央单元格中排除了1，我们仍然处于死角。现在该一次又一次地做一个假设。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里没有很多算法动作。每次我们无法分发限制时，我们都会做一个假设并继续前进。而且由于您在遇到矛盾之前可能会多次陷入困境，因此您将积累一些保存的状态和假设。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每次迭代都返回一个结果，您</font><font style="vertical-align: inherit;">就将</font><font style="vertical-align: inherit;">域至少减少了一个变量，因此，尽管回滚次数众多，该算法</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最终</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仍将完成工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个主题比我描述的要广泛得多。</font><font style="vertical-align: inherit;">在实践中，诸如假设选择，了解何时分发以及何时做出更复杂的逻辑结论之类的优化可能会对程序执行产生巨大影响。</font><font style="vertical-align: inherit;">而且由于约束的问题通常呈指数增长，因此您可以在明天或5000年后得到答案。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们回到波动函数的崩溃</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
波动函数的崩溃是一项棘手的任务，但有一个局限性：存在成千上万种可能的解决方案。如果我们随机进行假设，那么</font><font style="vertical-align: inherit;">我们将使用</font><i><font style="vertical-align: inherit;">生成</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">器</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font><i><font style="vertical-align: inherit;">求解</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">器</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。同时，它仍将遵守所有给定的限制，也就是说，它将比大多数其他程序生成器更易于管理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WFC算法的任务是用图块填充单元，以使图块上的图像相互组合。在上面使用的术语中，每个图块是一个值，每个单元格是一个变量，放置图块的规则是约束。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WFC的作者马克西姆（Maxim）发现，通过合理选择图块和适当的随机化，您几乎不必使用带有返回的破坏，因此无法执行此过程。</font><font style="vertical-align: inherit;">因此，WFC的本质如下：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为每个单元格创建一个布尔数组，该数组表示此变量的域。</font><font style="vertical-align: inherit;">域每个图块包含一个记录，并且所有域都使用value初始化</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果值相等，则图块进入域</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同时，有些单元格中的域包含多个元素：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用“最小熵”的启发式方法选择随机单元。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从单元域中选择一个随机磁贴，然后从其中删除所有其他磁贴。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于此新信息更新其他单元的域是单元限制的传播。</font><font style="vertical-align: inherit;">必须重复进行此操作，因为单元格的更改可能会产生进一步的后果。</font></font></li>
</ul></li>
</ul><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：我的条款与Maxim的条款不同。</font><font style="vertical-align: inherit;">他称域阵列为波，选择随机图块是一种观察。</font><font style="vertical-align: inherit;">也就是说，用量子力学来类比。</font><font style="vertical-align: inherit;">但是比较是肤浅的，因此我们将忽略它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上述原理有许多补充，为算法增加了宽限度和性能。</font><font style="vertical-align: inherit;">但是，让我们先来看一下所描述的步骤。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设我们需要用四种类型的图块填充3 x 3网格：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/749/647/d6b/749647d6ba27126a9e7769a479cd79a5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
限制是：相邻图块的颜色必须彼此匹配。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就像数独示例一样，我将用单色图像说明域的内容。</font><font style="vertical-align: inherit;">当域中仅剩一个元素时，我将其大小增加并以颜色显示。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，在每个单元中，可以放置任何类型的图块：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/780/406/ba9/780406ba92fd3d6cd89234b1aa2b8431.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
运行主WFC循环。</font><font style="vertical-align: inherit;">随机选择一个单元格，例如左上方。</font><font style="vertical-align: inherit;">现在，在域中选择一个图块，然后删除所有其他图块。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6b/053/8a4/c6b0538a47c9355d22fe75fada7252cc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分发限制。</font><font style="vertical-align: inherit;">唯一规则适用于相邻的图块，因此我们需要更新两个单元：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90e/a7f/440/90ea7f440d0b3805b324a4bbaef6a7e3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
鉴于域缩小，我们可以更新其他图块吗？</font><font style="vertical-align: inherit;">是! </font><font style="vertical-align: inherit;">尽管我们不确定第一个图块的选择，但我们看到其余的选项指向右边。</font><font style="vertical-align: inherit;">也就是说，某些类型的图块不能放在右上角。</font><font style="vertical-align: inherit;">左下角也一样。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/4f3/d07/4dc4f3d070fe3268639e9fc3e2877661.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们不再能够分配限制，因此我们重复主循环：单元选择，图块选择和分配。</font><font style="vertical-align: inherit;">这次我们取中间的上单元格：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/44c/01a/b5844c01a98770f203587dd46d02a3df.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个循环：取左中间格。</font><font style="vertical-align: inherit;">在中央单元的限制扩散之后，一个可能的值仍然存在。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/066/f76/a13/066f76a13cda6b5e275a371b3561c02a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般来说，您了解这个想法。</font><font style="vertical-align: inherit;">您可以自己填写其余单元格。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您想尝试一个</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更复杂的交互式示例</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，建议您使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此</font></font></a><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">示例</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小熵</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
选择下一个要填充的单元格时，某些选项将是更可取的。</font><font style="vertical-align: inherit;">如果您从网格中的任意位置随机选择，则可能会在同时填充网格的不同区域时出现这种情况。</font><font style="vertical-align: inherit;">这可能会导致问题：根据可用的图块，无法连接填充区域。</font><font style="vertical-align: inherit;">因此，最好选择将来不太可能导致此类问题的电池。</font><font style="vertical-align: inherit;">换句话说，您需要获取域中具有最少数量的可能值的单元格（但不少于两个值）：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最有可能的是，它们将在已经填充的单元格旁边。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们将它们留给未来使用，那么可能会遇到困难，因为可用的值已经很少了。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果所有图块均具有相同的可能性，则最小域方法会很好地工作。</font><font style="vertical-align: inherit;">但是，如果您从</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加权随机分布中进行</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择</font><font style="vertical-align: inherit;">，则需要考虑其他因素。</font><font style="vertical-align: inherit;">Maxima建议“最小熵”，即选择一个最小化的单元：</font></font><br>
<br>
<p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>e</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>y</mi><mo>=</mo><mo>&amp;#x2014;</mo><mo>&amp;#x2211;</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=&quot;false&quot;>(</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="25.41ex" height="3.634ex" viewBox="0 -1024.6 10940.2 1564.8" role="img" focusable="false" style="vertical-align: -1.255ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-65" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-6E" x="466" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-74" x="1067" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-72" x="1428" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-6F" x="1880" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-70" x="2365" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-79" x="2869" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMAIN-3D" x="3644" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMAIN-2014" x="4422" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJSZ2-2211" x="5589" y="0"></use><g transform="translate(7201,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-70" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-69" x="712" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-6C" x="8048" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-6F" x="8347" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-67" x="8832" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMAIN-28" x="9313" y="0"></use><g transform="translate(9702,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-70" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-69" x="712" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMAIN-29" x="10550" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>e</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>y</mi><mo>=</mo><mo>—</mo><mo>∑</mo><msub><mi>p</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1">entropy = — \sum p_{i}log(p_{i})</script></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是该域中图块的总和 </font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.059ex" height="1.884ex" viewBox="-38.5 -540.2 886.3 811.3" role="img" focusable="false" style="vertical-align: -0.63ex; margin-left: -0.089ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-70" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/company/mailru/blog/497590/&amp;usg=ALkJrhhzPzOWKyF0fa_0his9g7ibLeEQlg#MJMATHI-69" x="712" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>p</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-2">p_{i}</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -此图块的概率。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高效计算</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管我不想详细介绍，但是有两个优化使我可以提高速度，以至于不能忽略它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我们的唯一规则与相邻的图块相关，因此我们只能检查那些可以得出与先前结果不同的限制。也就是说，在更新单元格时，我们将其添加到等待决策的单元格队列中。然后，我们从队列中删除一个单元，每次检查其相邻单元。如果这种检查导致其他单元的更新，它们也将进入队列。重复此过程，直到队列为空，我们确保检查所有限制。但是，直到与这些限制相关联的至少一个单元格的域发生变化，我们才会检查它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，要检查邻接约束，我们需要回答以下问题：“考虑到单元A域中的图块，如果单元相邻，在单元B域中可能有哪些图块？” </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有时，此问题称为单元A的“支持”。对于域B中的给定图块“ b”，很容易计算域A中图块的周期。如果A具有至少一个可以放置在“ b”旁边的图块，则“ b”仍然适用，至少适用于相关问题。如果在A中没有这样的图块，那么您将不能放置域B中的图块“ b”，我们可以将其丢弃。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
循环使在代码中轻松实现这一点变得非常容易，但是循环将非常缓慢。</font><font style="vertical-align: inherit;">而且，如果我们将信息存储在其他数据结构中，则可以根据需要快速回答该问题。</font><font style="vertical-align: inherit;">新数据是一个大型数组，每个单元格的每一侧和每个图块都有条目。</font><font style="vertical-align: inherit;">在我们的示例中，有9个像元，每个像元具有4个面和4种类型的图块。</font><font style="vertical-align: inherit;">所以我们需要9 * 4 * 4记录。</font><font style="vertical-align: inherit;">我们将在阵列中保存支持计数器：对于每个单元格/图块/侧面，我们计算相邻单元域中可以放置在所讨论图块旁边的图块数。</font><font style="vertical-align: inherit;">如果计数器降为零，则无法放置此图块，因为没有人可以与其相邻。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法扩展</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因为WFC基于对约束问题的更一般的了解，所以有很多方法可以通过更改所使用的约束来扩展算法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明显的变化之一是，没有人强迫我们使用正方形单元。 WFC在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">六角形电池，三维</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">甚至更多</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不寻常的表面</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上都可以很好地工作</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/35a/0b9/98f35a0b9ccd9fd4fce689cd7f911d64.png" width="300"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/848/881/d32/848881d3216ac003a312c1fc8cfd56ea.png" width="300"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/497/0d2/706/4970d270636d7203d3e8e1e4bcb4befd.png" width="300"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以引入其他限制：修复某些磁贴，或从多个单元格创建“模块”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从实用的角度来看，附加限制的引入可以发挥非常重要的作用。</font><font style="vertical-align: inherit;">由于WFC仅限制相邻的图块，因此它很少生成大型结构以提供高水平的同质性，并且看起来不寻常。</font><font style="vertical-align: inherit;">该算法在选择图块时效果最佳，但要使用某些大型结构，最好使用其他技术或引入其他限制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一篇文章中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我谈到了如何从WFC中获得最佳结果。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重叠的WFC</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该算法的有趣扩展之一是“重叠” WFC。在以上示例中，主要限制与成对的相邻图块有关。这足以确保线的连接并创建简单的结构（例如洞穴，房间等）。但是同时，丢失了很多信息。例如，如果我们需要红色的块始终位于蓝色的旁边，但从不与其相邻，那么仅凭连续性就很难表达这一点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maxim提出了重叠WFC的概念：我们用新的约束替换了邻接约束，该约束立即影响多个图块。例如，在输出处，每组3×3单元对应于网格样本中的3×3组。样本中存在的模式将在输出端以不同的变化反复进行：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42d/72b/b76/42d72bb7631b24f33858756ade67fa55.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此限制比“简单”邻接限制敏感得多。</font><font style="vertical-align: inherit;">并且由于它取决于给定的样本，因此非常适合解决某些艺术任务。</font><font style="vertical-align: inherit;">到目前为止，我还没有遇到任何有趣的事情。</font><font style="vertical-align: inherit;">可能是因为这样的算法更难以实现，或者算法运行更慢，或者有时它不能很好地再现原始样本，这导致某种自然性和自然性丧失。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一步是什么？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有限制地解决问题是计算机科学领域的一个积极而广阔的发展领域，而我只涉及到它。</font><font style="vertical-align: inherit;">就像其他解决约束问题的程序生成算法一样，WFC仍然是新的。</font><font style="vertical-align: inherit;">我建议阅读</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r / proceduralgeneration</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#wavefunctioncollapse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@exutumno</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@osksta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以了解最近的用例。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您也可以阅读我</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关WFC的文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，尝试使用我的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开源库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity工具</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">不要忘记我有关</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序生成的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他文章</font><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN497578/index.html">AMD致力于在数据中心市场中获得重要份额</a></li>
<li><a href="../zh-CN497580/index.html">硬隔离非常非常糟糕</a></li>
<li><a href="../zh-CN497582/index.html">Habr在用户数字权利排名中排名第一</a></li>
<li><a href="../zh-CN497584/index.html">量化自我：Madrobots如何将Picooc智能体重秤带到俄罗斯</a></li>
<li><a href="../zh-CN497588/index.html">Spring Security-通过BitBucket的OAuth2授权Web应用程序示例</a></li>
<li><a href="../zh-CN497594/index.html">外部数据存储：从IBM 1311到今天。第1部分</a></li>
<li><a href="../zh-CN497596/index.html">PHP万岁</a></li>
<li><a href="../zh-CN497602/index.html">您是否认为自己是签名人？你在跟谁开玩笑</a></li>
<li><a href="../zh-CN497606/index.html">用于Home Assistant，ESP8266和MiFlora的自动花园浇水系统</a></li>
<li><a href="../zh-CN497608/index.html">流量分析系统如何通过MITER ATT＆CK来检测黑客策略，第5部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>