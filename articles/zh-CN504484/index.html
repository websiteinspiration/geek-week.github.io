<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☯️ 👨‍🚀 😼 全能IPSec 👉 👈🏻 👩🏻‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="下午好朋友。众所周知，我们中的许多人至少有一次，但是不得不处理配置VPN的需求。作为Habr的活跃读者，我注意到，尽管有很多关于IPSec的文章，但对于许多人来说，它似乎仍然是一件复杂而繁重的事情。在本文中，我将以我自己的完全有效的配置为例，消除这些神话。在四个示例中，我们将完整地介绍最流行的Lin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>全能IPSec</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504484/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下午好朋友。</font><font style="vertical-align: inherit;">众所周知，我们中的许多人至少有一次，但是不得不处理配置VPN的需求。</font><font style="vertical-align: inherit;">作为Habr的活跃读者，我注意到，尽管有很多关于IPSec的文章，但对于许多人来说，它似乎仍然是一件复杂而繁重的事情。</font><font style="vertical-align: inherit;">在本文中，我将以我自己的完全有效的配置为例，消除这些神话。</font><font style="vertical-align: inherit;">在四个示例中，我们将完整地介绍最流行的Linux（Strongswan）解决方案，从带有使用PSK密钥进行侧面身份验证的简单隧道到基于基于Let's Encrypt的证书进行双方身份验证的主机到主机连接。</font><font style="vertical-align: inherit;">有趣？</font><font style="vertical-align: inherit;">欢迎来到猫！</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初，仅针对在父母的小型路由器与同时充当路由器的家用“床头”服务器之间的通道组织来规划VPN。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短时间后，Keenetic从两个设备添加到该公司。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是一旦开始，它就变得很难停止，很快电话和一台笔记本电脑就出现在图表上，他们想躲开MT_Free和其他未加密的WiFi网络广为人知的广告眼。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，心爱的ILV最终变得更强大了，他难以置信地爱上了四面八方的摇摆人Banhammer，并且为了抵消对凡人的担忧，他不得不</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持外国IT部门在国外</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收购VPS。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，一定公民谁看起来像Shapoklyak，运行到处她的</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手提袋由</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包，可能认为“谁帮助的人，是在浪费时间。</font><font style="vertical-align: inherit;">您不能以善行而出名，“我想偷偷窥视别人的交通，并用铅笔记录下来。</font><font style="vertical-align: inherit;">在这种情况下，我们还必须严格按照医生的命令为自己防御这种未经请求的爱和VPN。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总结一个简短的总结。</font><font style="vertical-align: inherit;">有必要找到一种理想情况下可以一次关闭多个任务的解决方案：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux路由器之间的互连</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在Linux和Keenetic Household之间建立隧道</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使来自不受信任网络的可穿戴设备（电话，笔记本电脑）可以访问家庭资源和Internet</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建到远程VPS的安全加密隧道</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不要忘记奇妙的KISS原理-保持简单，愚蠢。</font><font style="vertical-align: inherit;">涉及的组件越少，每个组件的配置就越容易-越可靠。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现有解决方案概述</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简要回顾一下现在的情况：</font><font style="vertical-align: inherit;">
所有协议的</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPTP</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">祖父列宁。</font><font style="vertical-align: inherit;">死于“霉菌和菩提树蜂蜜的腐烂”。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L2TP</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
除了一个提供程序，任何人都可以使用吗？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wireguard</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
项目正在开发中。</font><font style="vertical-align: inherit;">积极锯。</font><font style="vertical-align: inherit;">在具有静态IP的两个对等点之间创建隧道很容易。</font><font style="vertical-align: inherit;">在其他情况下，拐杖，带方轮的自行车和蓝色胶带总是可以帮助您，但这不是我们的方法。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenVPN</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
优点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 支持多种平台-Windows，Linux，OpenWRT及其衍生版本，Android</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 强大的加密和证书支持。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 定制的灵活性。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 缺点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 完全在用户空间中工作。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 家用路由器的支持有限-Mikrotik上的krenenko-kosenko（在不影响腺体的其他优势的情况下）和OpenWRT中的正常功能。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 设置移动客户端的困难：您需要下载或创建自己的安装程序，将配置复制到某个地方。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果有多个隧道，则在服务器上编辑systemd单元等待舞蹈。</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenConnect（Cisco Anyconnect协议的开源实现）</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
不幸的是，一个非常有趣的解决方案是大量的信息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
优点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 对各种平台的相对广泛的支持-基于商店中基于Cisco Anyconnect本机应用程序的Windows，Android和Mac-是提供对可穿戴设备的内部网络的访问的理想选择。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 强大的加密，证书支持，2FA连接</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该协议本身完全基于TLS（与OpenVPN不同，它很容易在端口443上检测到）。</font><font style="vertical-align: inherit;">除TLS外，还支持DTLS-在建立的会话期间，客户端可以切换为通过UDP传输数据，反之亦然。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用sniproxy在VPN和成熟的Web服务器的一个端口上实现出色的共存。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 易于配置服务器和客户端。</font></font></li>
</ul> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里也并非没有缺点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 完全在用户空间中工作。</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP之上的TCP是一个坏主意。</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 客户级设备不提供支持。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在两个Linux之间安装隧道的复杂性：理论上可行，实际上-最好花一些时间在更有用的东西上。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果有多个隧道，则正在等待具有多个配置和编辑systemd单元的舞蹈。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这似乎是一个死胡同，但是经过仔细研究并花了一些时间研究之后，我意识到基于IKEv2的IPSec能够替代其他所有内容。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IKEv2 IPSEC</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
优点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 随着IKEv2的出现，与以前的版本相比，该协议本身已变得更易于配置，但代价是失去了向后兼容性。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">归功于标准化，可以在任何地方和任何地方提供工作-列表可以无限期维护。</font><font style="vertical-align: inherit;">Linux，Mikrotik（在最新版本的RouterOS中），OpenWRT，Android，iPhone。</font><font style="vertical-align: inherit;">从Windows 7开始，Windows还具有本机支持。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高速：完全在内核空间中进行流量处理。</font><font style="vertical-align: inherit;">用户空间部分仅用于设置连接参数和监视通道的运行状况。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用多种身份验证方法的能力：同时使用PSK和证书，以及任意组合。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几种操作模式：隧道和运输。</font><font style="vertical-align: inherit;">可以阅读它们的不同之处，包括在Habré上。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中间节点的设置要求不高：如果在IKE的第一个版本中存在由NAT引起的问题，则IKEv2具有内置的机制来克服NAT和IKE消息的本机分段，从而使您可以在具有MTU曲线的通道上建立连接。</font><font style="vertical-align: inherit;">展望未来，我要说的是，实际上，我从来没有遇到过WiFi网络，无论客户端可以在哪里建立连接。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，缺点还包括：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 您需要花费一些时间来研究和理解其工作原理。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能会使新手感到困惑的功能：与传统的VPN解决方案不同，IPSec无法创建网络接口。</font><font style="vertical-align: inherit;">仅设置流量处理策略，其他所有内容均通过防火墙解决。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在进行设置之前，我们假设读者已经对基本概念和术语有所了解。</font><font style="vertical-align: inherit;">为了帮助初学者，您可以推荐</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和Habr本人的文章，关于该主题的文章已经非常有趣和有用。</font></font><br>
 <br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始设定</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
决定后，我们继续进行配置。</font><font style="vertical-align: inherit;">在我的情况下，网络图具有以下形式（在扰流板下删除）</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网络图</font></font></b>
                        <div class="spoiler_text"><img src="https://habrastorage.org/webt/g4/vc/ka/g4vckajqxwwmj1i0dalms3lipfm.png"></div>
                    </div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ipsecgw.example.com</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是作为网络中心的主服务器。外部IP 1.1.1.1。内部网络10.0.0.0/23和另一个地址10.255.255.1/30，用于与VPS设置专用BGP会话；</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mama</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一种Linux路由器，它基于父母安装的小型静音上网本。 ISP发出一个动态IP地址。内部网络10.0.3.0/24; </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keenetic-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装了IPSec的</font><b><font style="vertical-align: inherit;">Keenetic</font></b><font style="vertical-align: inherit;">路由器。 ISP发出一个动态IP地址。内部网络10.0.4.0/24; </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">道路战士</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -从不受信任的网络连接的便携式设备。从内部池（10.1.1.0/24）连接时，地址会动态发布给客户端；</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rkn.example.com</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-受尊敬的ILV管辖范围之外的VPS。</font><font style="vertical-align: inherit;">外部IP-5.5.5.5，内部地址10.255.255.2/30，用于设置专用BGP会话。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一步。</font><font style="vertical-align: inherit;">从简单到复杂：使用预共享密钥（PSK）的隧道</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在两个Linux机器上，我们都安装必需的软件包：</font></font><br>
<br>
<pre><code class="plaintext hljs">sudo yum install strongswan</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在两台主机上，打开端口500 / udp，4500 / udp并允许ESP协议通过。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编辑文件/etc/strongswan/ipsec.secrects（在主机端ipsecgw.example.com）并添加以下行：</font></font><br>
<br>
<pre><code class="plaintext hljs">mama@router.home.local: PSK "Very strong PSK"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第二面，类似地：</font></font><br>
<br>
<pre><code class="plaintext hljs">root@root.mama.local: PSK "Very strong PSK"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，该ID是虚拟的电子邮件地址。</font><font style="vertical-align: inherit;">可以在官方</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上找到更多信息</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
秘密已保存，继续前进。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在ipsecgw.example.com主机上，编辑/etc/strongswan/ipsec.conf文件：</font></font><br>
<br>
<pre><code class="cpp hljs">config setup <span class="hljs-comment">//   charon</span>
    charondebug = <span class="hljs-string">"dmn 0, mgr 0, ike 0, chd 0, job 0, cfg 0, knl 0, net 0, asn 0, enc 0, lib 0, esp 0, tls 0, tnc 0, imc 0, imv 0, pts 0"</span> <span class="hljs-comment">//  </span>
conn %<span class="hljs-keyword">default</span> <span class="hljs-comment">//    </span><font></font>
    reauth = yes<font></font>
    rekey = yes<font></font>
    keyingtries = %forever<font></font>
    keyexchange = ikev2 <span class="hljs-comment">//      - IKEv2</span><font></font>
    dpdaction = hold<font></font>
    dpddelay = <span class="hljs-number">5</span>s <span class="hljs-comment">// 5   DPD (Dead Peer Detection)   </span>
    mobike = yes <span class="hljs-comment">// Mobile IKE -     IP    </span>
conn mama <span class="hljs-comment">//  </span>
    left = %defaultroute <span class="hljs-comment">//Left -  .  %defaultroute       IKE- ,    default route</span>
    right = %any <span class="hljs-comment">//     IP-</span>
    authby = psk <span class="hljs-comment">//   -   </span>
    leftid = mama@router.home.local <span class="hljs-comment">// ID,   ipsec.secrets</span>
    rightid = root@router.mama.local <span class="hljs-comment">//ID  </span>
    leftsubnet = <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">23</span>,<span class="hljs-number">10.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> 
    rightsubnet = <span class="hljs-number">10.0</span><span class="hljs-number">.3</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span><font></font>
    type = tunnel <font></font>
    ike = aes256-aes192-aes128-sha256-sha384-modp2048-modp3072-modp4096-modp8192,aes128gcm16-sha384-x25519!<font></font>
    esp = aes256-aes192-aes128-sha256-sha384-modp2048-modp3072-modp4096-modp8192,aes128gcm16-sha256-sha384-x25519! <font></font>
    <span class="hljs-keyword">auto</span> = add <span class="hljs-comment">//  charon        </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同样，我们在远程对等体/etc/strongswan/ipsec.conf上进行编辑：</font></font><br>
<br>
<pre><code class="cpp hljs">config setup<font></font>
    charondebug = <span class="hljs-string">"dmn 0, mgr 0, ike 0, chd 0, job 0, cfg 0, knl 0, net 0, asn 0, enc 0, lib 0, esp 0, tls 0, tnc 0, imc 0, imv 0, pts 0"</span>
conn %<span class="hljs-keyword">default</span><font></font>
    reauth = yes<font></font>
    rekey = yes<font></font>
    keyingtries = %forever<font></font>
    keyexchange = ikev2<font></font>
    dpdaction = restart<font></font>
    dpddelay = <span class="hljs-number">5</span>s<font></font>
    mobike = yes<font></font>
conn mama<font></font>
    left = %defaultroute<font></font>
    right = ipsecgw.example.com<font></font>
    authby = psk<font></font>
    leftid = root@router.mama.local<font></font>
    rightid = mama@router.home.local<font></font>
    leftsubnet = <span class="hljs-number">10.0</span><span class="hljs-number">.3</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>
    rightsubnet = <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">23</span>,<span class="hljs-number">10.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span><font></font>
    type = tunnel<font></font>
    ike = aes128gcm16-sha384-x25519!<font></font>
    esp = aes128gcm16-sha384-x25519!<font></font>
    <span class="hljs-keyword">auto</span> = route
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果比较配置，可以看到它们几乎是镜像的，只有对等方的定义可以互换。</font><b><font style="vertical-align: inherit;">auto = route</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
指令</font><font style="vertical-align: inherit;">使charon为落入left / rightsubnet（流量选择器）指令的流量设置陷阱。</font><font style="vertical-align: inherit;">在给定条件下出现流量之后，将立即开始协调隧道参数和交换密钥。</font><font style="vertical-align: inherit;">
在防火墙设置的ipsecgw.example.com服务器上，我们禁止伪装10.0.3.0/24网络。</font><font style="vertical-align: inherit;">允许在10.0.0.0/23和10.0.3.0/24之间转发数据包，反之亦然。</font><font style="vertical-align: inherit;">在远程主机上，我们通过禁用10.0.0.0/23网络的伪装并设置转发来执行类似的设置。</font><font style="vertical-align: inherit;">
我们在两台服务器上重新启动Strongswan，然后尝试ping中央节点：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs">sudo systemctl restart strongswan<font></font>
ping <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
</code></pre><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确保一切正常：</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function">sudo strongswan status
Security <span class="hljs-title">Associations</span> <span class="hljs-params">(<span class="hljs-number">1</span> up, <span class="hljs-number">0</span> connecting)</span>:
        mama[53]: ESTABLISHED 84 minutes ago, 1.1.1.1[mama@router.home.local]...2.2.2.2[root@router.mama.local]
        mama</span>{<span class="hljs-number">141</span>}:  INSTALLED, TUNNEL, reqid <span class="hljs-number">27</span>, ESP in UDP SPIs: c4eb45fe_i ca5ec6ca_o<font></font>
        mama{<span class="hljs-number">141</span>}:   <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">23</span> <span class="hljs-number">10.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> === <span class="hljs-number">10.0</span><span class="hljs-number">.3</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
确保在所有对等点的/etc/strongswan/strongswan.d/charon.conf文件中将make_before_break参数设置为yes也是有用的。</font><font style="vertical-align: inherit;">在这种情况下，服务于IKEv2协议的charon守护程序不会在密钥更改过程中删除当前的安全关联，而是会首先创建一个新的安全关联。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二步 </font><font style="vertical-align: inherit;">Keenetic的外观</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
令人惊喜的是，官方Keenetic固件中内置了IPSec VPN。</font><font style="vertical-align: inherit;">要激活它，只需转到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KeeneticOS组件设置</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并添加</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPSec VPN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">软件包</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，我们在中央节点上准备设置：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编辑/etc/strongswan/ipsec.secrects并添加新对等方的PSK：</font></font><br>
<br>
<pre><code class="plaintext hljs">keenetic@router.home.local: PSK "Keenetic+PSK"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编辑/etc/strongswan/ipsec.conf并在末尾添加另一个连接：</font></font><br>
<br>
<pre><code class="cpp hljs">conn keenetic<font></font>
    left = %defaultroute<font></font>
    right = %any<font></font>
    authby = psk<font></font>
    leftid = keenetic@router.home.local<font></font>
    rightid = root@router.keenetic.local<font></font>
    leftsubnet = <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">23</span>
    rightsubnet = <span class="hljs-number">10.0</span><span class="hljs-number">.4</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span><font></font>
    type = tunnel<font></font>
    ike = aes256-aes192-aes128-sha256-sha384-modp2048-modp3072-modp4096-modp8192,aes128gcm16-sha384-x25519!<font></font>
    esp = aes256-aes192-aes128-sha256-sha384-modp2048-modp3072-modp4096-modp8192,aes128gcm16-sha256-sha384-x25519!<font></font>
    <span class="hljs-keyword">auto</span> = add
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Keenetic方面，配置是通过以下路径在WebUI中完成的：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internet-&gt; Connections-&gt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Other Connections</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">很简单</font></font><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（3张图片）</font></font></b>
                        <div class="spoiler_text"><img src="https://habrastorage.org/webt/0y/im/lp/0yimlpwidapstotzn9jqrs6f4za.png"><br>
<br>
<img src="https://habrastorage.org/webt/yi/xm/wv/yixmwvbj_fvsde_suu4_6wzooni.png"><br>
<br>
<img src="https://habrastorage.org/webt/fu/x-/6q/fux-6qh4mpc6nkz8ieu2egqpc54.png"><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果计划通过隧道驱动大量流量，则可以尝试启用硬件加速，许多型号都支持这种方式。</font><font style="vertical-align: inherit;">由</font><font style="vertical-align: inherit;">CLI中</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crypto engine hardware</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令启用</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用通用CPU指令禁用和处理加密和哈希过程- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加密引擎软件</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
保存设置后，我们恢复了Strongswan并让Keenetic思考了半分钟。</font><font style="vertical-align: inherit;">然后在终端中，我们看到一个成功的连接：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一切正常：</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function">sudo strongswan status
Security <span class="hljs-title">Associations</span> <span class="hljs-params">(<span class="hljs-number">2</span> up, <span class="hljs-number">0</span> connecting)</span>:
    keenetic[57]: ESTABLISHED 39 minutes ago, 1.1.1.1[keenetic@router.home.local]...3.3.3.3[root@router.keenetic.local]
    keenetic</span>{<span class="hljs-number">146</span>}:  INSTALLED, TUNNEL, reqid <span class="hljs-number">29</span>, ESP SPIs: ca8f556e_i ca11848a_o<font></font>
    keenetic{<span class="hljs-number">146</span>}:   <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">23</span> === <span class="hljs-number">10.0</span><span class="hljs-number">.4</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>
        mama[<span class="hljs-number">53</span>]: ESTABLISHED <span class="hljs-number">2</span> hours ago, <span class="hljs-number">1.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>[mama@router.home.local]..<span class="hljs-number">.2</span><span class="hljs-number">.2</span><span class="hljs-number">.2</span><span class="hljs-number">.2</span>[root@router.mama.local]<font></font>
        mama{<span class="hljs-number">145</span>}:  INSTALLED, TUNNEL, reqid <span class="hljs-number">27</span>, ESP in UDP SPIs: c5dc78db_i c7baafd2_o<font></font>
        mama{<span class="hljs-number">145</span>}:   <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">23</span> <span class="hljs-number">10.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> === <span class="hljs-number">10.0</span><span class="hljs-number">.3</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>
</code></pre><br>
</div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三步 </font><font style="vertical-align: inherit;">保护移动设备</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
阅读了一堆手册和一堆文章之后，我们决定停止从Let's Encrypt获得一堆免费证书，以通过客户端的登录名和密码来认证服务器和经典授权。</font><font style="vertical-align: inherit;">因此，通过在受信任列表中安装自签名证书，我们无需维护自己的PKI基础结构，监视密钥的到期以及对移动设备执行不必要的手势。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
安装缺少的软件包：</font></font><br>
<br>
<pre><code class="plaintext hljs">sudo yum install epel-release<font></font>
sudo yum install certbot</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们获得了独立证书（别忘了先在iptables设置中打开80 / tcp）：</font></font><br>
<br>
<pre><code class="plaintext hljs">sudo certbot certonly --standalone -d ipsecgw.example.com</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
certbot完成工作后，我们必须教Strongswan查看我们的证书：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在目录/etc/strongswan/ipsec.d/cacerts中创建2个符号链接：一个到/ etc / pki / tls / certs中受信任证书的根存储；</font><font style="vertical-align: inherit;">第二个名称为ca.pem，指向/etc/letsencrypt/live/ipsecgw.example.com/chain.pem</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在/etc/strongswan/ipsec.d/certs目录中还创建了两个符号链接：第一个符号名为certificate.pem，它指向文件/etc/letsencrypt/live/ipsecgw.example.com/cert.pem。</font><font style="vertical-align: inherit;">第二个名为fullchain.pem，链接到/etc/letsencrypt/live/ipsecgw.example.com/fullchain.pem</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在/etc/strongswan/ipsec.d/private目录中，将key.pem符号链接指向certbot生成的私钥，并沿着路径/etc/letsencrypt/live/ipsecgw.example.com/privkey.pem放置</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过RSA向ipsec.secrets添加身份验证，并为新用户添加大量登录名/密码：</font></font><br>
<br>
<pre><code class="plaintext hljs">ipsecgw.example.com     : RSA key.pem<font></font>
username phone          : EAP "Q1rkz*qt"<font></font>
username notebook       : EAP "Zr!s1LBz"<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们重新启动Strongswan，当调用sudo strongswan listcerts时，我们应该看到证书信息：</font></font><br>
<br>
<pre><code class="plaintext hljs">List of X.509 End Entity Certificates<font></font>
<font></font>
  subject:  "CN=ipsecgw.example.com"<font></font>
  issuer:   "C=US, O=Let's Encrypt, CN=Let's Encrypt Authority X3"<font></font>
  validity:  not before May 23 19:36:52 2020, ok<font></font>
             not after  Aug 21 19:36:52 2020, ok (expires in 87 days)<font></font>
  serial:    04:c7:70:9c:a8:ce:57:cc:bf:6f:cb:fb:d3:a9:cf:06:b0:a8<font></font>
  altNames:  ipsecgw.example.com<font></font>
  flags:     serverAuth clientAuth<font></font>
  OCSP URIs: http://ocsp.int-x3.letsencrypt.org<font></font>
  certificatePolicies:<font></font>
             2.23.140.1.2.1<font></font>
             1.3.6.1.4.1.44947.1.1.1<font></font>
             CPS: http://cps.letsencrypt.org<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，我们在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ipsec.conf中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述新的连接</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">conn remote-access<font></font>
    dpddelay = <span class="hljs-number">30</span>s <span class="hljs-comment">//   DPD ,     </span><font></font>
    left = %defaultroute<font></font>
    leftid = <span class="hljs-string">"CN=ipsecgw.example.com"</span>
    leftcert = fullchain.pem <span class="hljs-comment">//         </span><font></font>
    leftsendcert = always<font></font>
    leftsubnet = <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">0</span> <span class="hljs-comment">//      </span><font></font>
    right = %any<font></font>
    rightid = %any<font></font>
    rightauth = eap-mschapv2 <span class="hljs-comment">// ,  EAP-MSCHAP2</span><font></font>
    rightsendcert = never<font></font>
    eap_identity = %identity <font></font>
    rightsourceip = <span class="hljs-number">10.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> <span class="hljs-comment">//Strongswan       </span>
    rightdns = <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>,<span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.3</span> <span class="hljs-comment">//   DNS</span><font></font>
    type = tunnel<font></font>
    ike = aes256-aes192-aes128-sha256-sha384-modp2048-modp3072-modp4096-modp8192,aes128gcm16-sha384-x25519!<font></font>
    esp = aes256-aes192-aes128-sha256-sha384-modp2048-modp3072-modp4096-modp8192,aes128gcm16-sha256-sha384-x25519!<font></font>
    <span class="hljs-keyword">auto</span> = add <span class="hljs-comment">//      </span>
    dpdaction = restart <span class="hljs-comment">// ,      DPD</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不要忘记编辑文件/ etc / sysconfig / certbot，这表明我们还将证书更新为独立证书，并在其中添加了CERTBOT_ARGS =“ -standalone”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，不要忘记打开certbot-renew.timer计时器并设置挂钩以在发出新证书的情况下重新启动Strongswan。</font><font style="vertical-align: inherit;">为此，可以在/ etc / letsencrypt / renewal-hooks / deploy /中放置一个简单的bash脚本，或者再次编辑/ etc / sysconfig / certbot文件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们重新启动Strongswan，在iptables中开启对10.1.1.0/24网络的伪装，然后继续配置移动设备。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安卓系统</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从Google Play安装</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strongswan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用程序</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们启动并创建一个新的</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">轮廓</font></font></b>
                        <div class="spoiler_text"><img src="https://habrastorage.org/webt/qg/il/ly/qgilly6_cm-2-7jdlo8gtrkyqum.png"><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们保存了个人资料并连接，一秒钟后，我们不必担心有人会监视我们。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们检查：</font></font></b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">sudo strongswan statusall<font></font>
Security Associations (3 up, 0 connecting):<font></font>
remote-access[109]: ESTABLISHED 2 seconds ago, 1.1.1.1[CN=ipsecgw.example.com]...4.4.4.4[phone]<font></font>
remote-access{269}:  INSTALLED, TUNNEL, reqid 55, ESP in UDP SPIs: c706edd1_i e5c12f1d_o<font></font>
remote-access{269}:   0.0.0.0/0 ::/0 === 10.1.1.1/32<font></font>
        mama[101]: ESTABLISHED 34 minutes ago, 1.1.1.1[mama@router.home.local]...2.2.2.2[root@router.mama.local]<font></font>
        mama{265}:  INSTALLED, TUNNEL, reqid 53, ESP in UDP SPIs: c8c83342_i c51309db_o<font></font>
        mama{265}:   10.0.0.0/23 10.1.1.0/24 === 10.0.3.0/24<font></font>
    keenetic[99]: ESTABLISHED 36 minutes ago, 1.1.1.1[keenetic@router.home.local]...3.3.3.3[root@router.keenetic.local]<font></font>
    keenetic{263}:  INSTALLED, TUNNEL, reqid 52, ESP SPIs: c3308f33_i c929d6f1_o<font></font>
    keenetic{263}:   10.0.0.0/23 === 10.0.4.0/24</code></pre><br>
</div>
                    </div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视窗</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当前版本的Windows令人惊讶。</font><font style="vertical-align: inherit;">通过调用两个PowerShell cmdlet对新VPN进行所有配置：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">Add-VpnConnection</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">"IKEv2"</span> <span class="hljs-literal">-ServerAddress</span> ipsecgw.example.com <span class="hljs-literal">-TunnelType</span> <span class="hljs-string">"IKEv2"</span>
<span class="hljs-built_in">Set-VpnConnectionIPsecConfiguration</span> <span class="hljs-literal">-ConnectionName</span> <span class="hljs-string">"IKEv2"</span> <span class="hljs-literal">-AuthenticationTransformConstants</span> SHA256128 <span class="hljs-literal">-CipherTransformConstants</span> AES128 <span class="hljs-literal">-EncryptionMethod</span> AES128 <span class="hljs-literal">-IntegrityCheckMethod</span> SHA256 <span class="hljs-literal">-PfsGroup</span> PFS2048 <span class="hljs-literal">-DHGroup</span> Group14 <span class="hljs-literal">-PassThru</span> <span class="hljs-literal">-Force</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有一件事，如果将Strongswan配置为向客户端发布IPv6地址（是的，他也可以这样做）：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">Add-VpnConnectionRoute</span> <span class="hljs-literal">-ConnectionName</span> <span class="hljs-string">"IKEv2"</span> <span class="hljs-literal">-DestinationPrefix</span> <span class="hljs-string">"2000::/3"</span></code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第四部分，决赛。</font><font style="vertical-align: inherit;">我们开了通往欧洲的窗户</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看到提供者的存根“该站点因博格扎比县特鲁多耶·莫佐利村的第五副检察官的左脚脚跟的决定而被封锁”，一个小的，不起眼的VPS出现了（域名很好，域名为rkn.example.com），距喜欢用长锤和大小不一的网络波动的猴子一千公里。 /一次16。 NIC.CZ上名为BIRD的同事们创造了这个小型VPS。第一版的鸟因警棍活动而不断死于恐慌，猴子在劳动活动的高峰期禁止近4％的互联网访问，因此在重新配置过程中需要深思熟虑，因此将其更新为2.0.7版。如果读者感兴趣，我将发表一篇有关从BIRD过渡到BIRD2的文章，其中配置格式发生了巨大变化，但是新版本变得更快了，并且使用大量路由进行重新配置没有任何问题。并且由于我们使用动态路由协议，因此必须有一个网络接口，您需要通过该接口来路由流量。默认情况下，IPSec不会创建接口，但是由于其灵活性，我们可以使用经典的GRE隧道，将来我们将对其进行保护。作为奖励，ipsecgw.example.com和rkn.example.com主机将使用Lets Encrypt自我更新证书对彼此进行身份验证。没有PSK，只有证书，只有核心，没有太多的安全性。默认情况下，IPSec不会创建接口，但是由于其灵活性，我们可以使用经典的GRE隧道，将来我们将对其进行保护。作为奖励，ipsecgw.example.com和rkn.example.com主机将使用Lets Encrypt自我更新证书对彼此进行身份验证。没有PSK，只有证书，只有核心，没有太多的安全性。默认情况下，IPSec不会创建接口，但是由于其灵活性，我们可以使用经典的GRE隧道，将来我们将对其进行保护。作为奖励，ipsecgw.example.com和rkn.example.com主机将使用Lets Encrypt自我更新证书对彼此进行身份验证。没有PSK，只有证书，只有核心，没有太多的安全性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们认为已经准备好VPS，已经安装了Strongswan和Certbot。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在ipsecgw.example.com主机（其IP为1.1.1.1）上，我们描述了新的gif0接口：</font></font><br>
<pre><code class="plaintext hljs">sudo vi /etc/sysconfig/network-scripts/ifcfg-gif0<font></font>
DEVICE="gif0"<font></font>
MY_OUTER_IPADDR="1.1.1.1"<font></font>
PEER_OUTER_IPADDR="5.5.5.5"<font></font>
MY_INNER_IPADDR="10.255.255.1/30"<font></font>
PEER_INNER_IPADDR="10.255.255.2/30"<font></font>
TYPE="GRE"<font></font>
TTL="64"<font></font>
MTU="1442"<font></font>
ONBOOT="yes"<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在主机vps.example.com上镜像（其IP为5.5.5.5）：</font></font><br>
<br>
<pre><code class="plaintext hljs">sudo vi /etc/sysconfig/network-scripts/ifcfg-gif0<font></font>
DEVICE="gif0"<font></font>
MY_OUTER_IPADDR="5.5.5.5"<font></font>
PEER_OUTER_IPADDR="1.1.1.1"<font></font>
MY_INNER_IPADDR="10.255.255.2/30"<font></font>
PEER_INNER_IPADDR="10.255.255.1/30"<font></font>
TYPE="GRE"<font></font>
TTL="64"<font></font>
MTU="1442"<font></font>
ONBOOT="yes"<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们提出了接口，但是由于iptables没有允许GRE协议的规则，因此流量不会消失（这是我们所需要的，因为GRE内部没有针对任何立法“程序包”的支持者的保护措施）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">烹饪VPS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们获得另一个域名rkn.example.com的证书。</font><font style="vertical-align: inherit;">如上一节所述，在/etc/strongswan/ipsec.d中创建符号链接。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过向其添加一行来编辑ipsec.secrets：</font></font><br>
<br>
<pre><code class="plaintext hljs">rkn.example.com     : RSA key.pem</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编辑ipsec.conf：</font></font><br>
<br>
<pre><code class="cpp hljs">config setup<font></font>
    charondebug = <span class="hljs-string">"dmn 0, mgr 0, ike 0, chd 0, job 0, cfg 0, knl 0, net 0, asn 0, enc 0, lib 0, esp 0, tls 0, tnc 0, imc 0, imv 0, pts 0"</span><font></font>
    strictcrlpolicy = yes<font></font>
conn %<span class="hljs-keyword">default</span><font></font>
    reauth = yes<font></font>
    rekey = yes<font></font>
    keyingtries = %forever<font></font>
    keyexchange = ikev2<font></font>
    dpdaction = restart<font></font>
    dpddelay = <span class="hljs-number">5</span>s<font></font>
    mobike = yes<font></font>
conn rkn<font></font>
    left = %defaultroute<font></font>
    right = ipsecgw.example.com<font></font>
    authby = pubkey<font></font>
    leftcert = fullchain.pem<font></font>
    leftsendcert = always<font></font>
    leftauth = pubkey<font></font>
    rightauth = pubkey<font></font>
    leftid = <span class="hljs-string">"CN=rkn.example.com"</span>
    rightid = <span class="hljs-string">"CN=ipsecgw.example.com"</span><font></font>
    rightrsasigkey = /etc/strongswan/ipsec.d/certs/ipsecgw.example.com.pem<font></font>
    leftsubnet = %dynamic<font></font>
    rightsubnet = %dynamic<font></font>
    type = transport<font></font>
    ike = aes256gcm16-sha384-x25519!<font></font>
    esp = aes256gcm16-sha384-x25519!<font></font>
    <span class="hljs-keyword">auto</span> = route</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在主机端，还将在设置部分的strictcrlpolicy = yes参数中将ipsecgw.example.com添加到ipsec.conf，其中包括严格的CRL检查。</font><font style="vertical-align: inherit;">并描述另一个连接：</font></font><br>
<br>
<pre><code class="cpp hljs">conn rkn<font></font>
    left = %defaultroute<font></font>
    right = rkn.example.com<font></font>
    leftcert = fullchain.pem<font></font>
    leftsendcert = always<font></font>
    leftauth = pubkey<font></font>
    rightauth = pubkey<font></font>
    rightrsasigkey = /etc/strongswan/ipsec.d/certs/rkn.exapmle.com.pem<font></font>
    leftid = <span class="hljs-string">"CN=ipsecgw.example.com"</span>
    rightid = <span class="hljs-string">"CN=rkn.example.com"</span><font></font>
    leftsubnet = %dynamic<font></font>
    rightsubnet = %dynamic<font></font>
    type = transport<font></font>
    ike = aes256gcm16-sha384-x25519!<font></font>
    esp = aes256gcm16-sha384-x25519!<font></font>
    <span class="hljs-keyword">auto</span> = route<font></font>
    dpdaction = restart<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配置几乎是镜像的。</font><font style="vertical-align: inherit;">细心的读者可能已经注意到了以下几点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">left / rightsubnet =％动态-指示Strongswan对对等体之间的所有流量类型应用策略</font></font></li>
<li>      rightrsasigkey.     IKE SA     IKE AUTH ERROR  ,  Strongswan         RSA-  .        openssl.     (ipsecgw  RKN)  sudo /usr/bin/openssl rsa -in /etc/letsencrypt/live/ipsecgw.example.com/privkey.pem -pubout &gt; ~/ipsecgw.example.com.pem  sudo /usr/bin/openssl rsa -in /etc/letsencrypt/live/rkn.example.com/privkey.pem -pubout &gt; ~/rkn.example.com.pem,     scp       ,   </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不要忘记配置防火墙和自动更新证书。</font><font style="vertical-align: inherit;">在两台服务器上重新启动Strongswan后，开始对GRE隧道的另一端执行ping操作，并看到成功的连接。</font><font style="vertical-align: inherit;">在VPS（rkn）上：</font></font><br>
<br>
<pre><code class="plaintext hljs">sudo strongswan status<font></font>
Routed Connections:<font></font>
         rkn{1}:  ROUTED, TRANSPORT, reqid 1<font></font>
         rkn{1}:   5.5.5.5/32 === 1.1.1.1/32<font></font>
Security Associations (1 up, 0 connecting):<font></font>
         rkn[33]: ESTABLISHED 79 minutes ago, 5.5.5.5[CN=rkn.example.com]...1.1.1.1[CN=ipsecgw.example.com]<font></font>
         rkn{83}:  INSTALLED, TRANSPORT, reqid 1, ESP SPIs: cb4bc3bb_i c4c35a5a_o<font></font>
         rkn{83}:   5.5.5.5/32 === 1.1.1.1/32</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在主机端ipsecgw </font></font><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在扰流板下</font></font></b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">Routed Connections:<font></font>
         rkn{1}:  ROUTED, TRANSPORT, reqid 1<font></font>
         rkn{1}:   1.1.1.1/32 === 5.5.5.5/32<font></font>
Security Associations (4 up, 0 connecting):<font></font>
remote-access[10]: ESTABLISHED 5 seconds ago, 1.1.1.1[CN=ipsecgw.example.com]...4.4.4.4[phone]<font></font>
remote-access{12}:  INSTALLED, TUNNEL, reqid 7, ESP in UDP SPIs: c7a31be1_i a231904e_o<font></font>
remote-access{12}:   0.0.0.0/0 === 10.1.1.1/32<font></font>
    keenetic[8]: ESTABLISHED 22 minutes ago, 1.1.1.1[keenetic@router.home.local]...3.3.3.3[root@router.keenetic.local]<font></font>
    keenetic{11}:  INSTALLED, TUNNEL, reqid 6, ESP SPIs: cfc1b329_i c01e1b6e_o<font></font>
    keenetic{11}:   10.0.0.0/23 === 10.0.4.0/24<font></font>
        mama[4]: ESTABLISHED 83 minutes ago, 1.1.1.1[mama@router.home.local]...2.2.2.2[root@router.mama.local]<font></font>
        mama{8}:  INSTALLED, TUNNEL, reqid 3, ESP in UDP SPIs: c4a5451a_i ca67c223_o<font></font>
        mama{8}:   10.0.0.0/23 10.1.1.0/24 === 10.0.3.0/24<font></font>
         rkn[3]: ESTABLISHED 83 minutes ago, 1.1.1.1[CN=ipsecgw.example.com]...5.5.5.5[CN=rkn.example.com]<font></font>
         rkn{7}:  INSTALLED, TRANSPORT, reqid 1, ESP SPIs: c4c35a5a_i cb4bc3bb_o<font></font>
         rkn{7}:   1.1.1.1/32 === 5.5.5.5/32<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通道已安装，可以ping通，在tcpdump中可以看到主机之间只有ESP。</font><font style="vertical-align: inherit;">似乎很高兴。</font><font style="vertical-align: inherit;">但是，如果不检查所有内容，您将无法放松。</font><font style="vertical-align: inherit;">我们正在尝试重新签发VPS证书并...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">厨师都坏了</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们开始理解并偶然发现Let's Encrypt的一项令人不快的功能，该功能在其他所有功能中都很漂亮-随证书的任何重新发行，与之相关的私钥也会更改。私钥已更改-公钥已更改。乍一看，这种情况对我们来说是无望的：即使我们可以使用certbot中的钩子在重新颁发证书的过程中轻松提取公钥并通过SSH将其传递给远程端，也不清楚如何使远程Strongswan重新读取它。但是帮助来自他们没有等待的地方-systemd可以监视对文件系统的更改并运行与事件关联的服务。这就是我们将要使用的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将在权限最受限制的每个主机上创建一个keywatcher服务用户，为每个主机生成SSH密钥，并在主机之间交换它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在ipsecgw.example.com主机上，创建/ opt / ipsec-pubkey目录，在其中放置2个脚本。</font></font><br>
<br>
<pre><code class="bash hljs">sudo vi /opt/ipsec-pubkey/pubkey-copy.sh</code></pre><br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh</span>
<span class="hljs-keyword">if</span> [ ! -f /home/keywatcher/ipsecgw.example.com.pem ]; <span class="hljs-keyword">then</span>
  /usr/bin/openssl rsa -<span class="hljs-keyword">in</span> /etc/letsencrypt/live/ipsecgw.example.com/privkey.pem -pubout &gt; /home/keywatcher/ipsecgw.example.com.pem;<font></font>
  /usr/bin/chown keywatcher:keywatcher /home/keywatcher/ipsecgw.example.com.pem;<font></font>
  /usr/bin/chmod 0600 /home/keywatcher/ipsecgw.example.com.pem;<font></font>
  sudo -u keywatcher /usr/bin/scp /home/keywatcher/ipsecgw.example.com.pem rkn.example.com:/home/keywatcher/ipsecgw.example.com.pem;<font></font>
  status=$?;<font></font>
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$status</span> -eq 0 ]; <span class="hljs-keyword">then</span><font></font>
    rm -f /home/keywatcher/ipsecgw.example.com.pem;<font></font>
    logger <span class="hljs-string">"Public key ipsecgw.example.com.pem has been successfully uploaded to remote host"</span>;
  <span class="hljs-keyword">else</span>
    logger <span class="hljs-string">"Public key ipsecgw.example.com.pem has not been uploaded to remote host due to error"</span>;
  <span class="hljs-keyword">fi</span>
  <span class="hljs-keyword">else</span>
    logger <span class="hljs-string">"Public key ipsecgw.example.com.pem already exist on /home/keywatcher directory, something went wrong"</span>;
<span class="hljs-keyword">fi</span>
<span class="hljs-built_in">exit</span> 0</code></pre><br>
<pre><code class="bash hljs">sudo vi /opt/ipsec-pubkey/key-updater.sh</code></pre><br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh</span><font></font>
/usr/bin/cp /home/keywatcher/rkn.example.com.pem /etc/strongswan/ipsec.d/certs/rkn.example.com.pem<font></font>
/usr/bin/chown root:root /etc/strongswan/ipsec.d/certs/rkn.example.com.pem<font></font>
/usr/bin/chmod 0600 /etc/strongswan/ipsec.d/certs/rkn.example.com.pem<font></font>
logger <span class="hljs-string">"Public key of server rkn.example.com has been updated, restarting strongswan daemon to re-read it"</span><font></font>
/usr/bin/systemctl restart strongswan<font></font>
<span class="hljs-built_in">exit</span> 0
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在VPS（主机rkn.example.com）上，我们类似地创建一个具有相同名称的目录，在该目录中，我们还创建了相似的脚本，仅更改了密钥的名称。</font><font style="vertical-align: inherit;">代码，以免使文章混乱</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扰流板</font></font></b>
                        <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">须藤vi /opt/ipsec-pubkey/pubkey-copy.sh</font></font><br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh</span>
<span class="hljs-keyword">if</span> [ ! -f /home/keywatcher/rkn.example.com.pem ]; <span class="hljs-keyword">then</span>
  /usr/bin/openssl rsa -<span class="hljs-keyword">in</span> /etc/letsencrypt/live/rkn.example.com/privkey.pem -pubout &gt; /home/keywatcher/rkn.example.com.pem;<font></font>
  /usr/bin/chown keywatcher:keywatcher /home/keywatcher/rkn.example.com.pem;<font></font>
  /usr/bin/chmod 0600 /home/keywatcher/rkn.example.com.pem;<font></font>
  sudo -u keywatcher /usr/bin/scp /home/keywatcher/rkn.example.com.pem ipsecgw.example.com:/home/keywatcher/rkn.example.com.pem;<font></font>
  status=$?;<font></font>
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$status</span> -eq 0 ]; <span class="hljs-keyword">then</span><font></font>
    rm -f /home/keywatcher/rkn.example.com.pem;<font></font>
    logger <span class="hljs-string">"Public key rkn.example.com.pem has been successfully uploaded to remote host"</span>;
  <span class="hljs-keyword">else</span>
    logger <span class="hljs-string">"Public key rkn.example.com.pem has not been uploaded to remote host"</span>;
  <span class="hljs-keyword">fi</span>
  <span class="hljs-keyword">else</span>
    logger <span class="hljs-string">"Public key rkn.example.com.pem already exist on /home/keywatcher directory, something went wrong"</span>;
<span class="hljs-keyword">fi</span>
<span class="hljs-built_in">exit</span> 0
</code></pre><br>
<pre><code class="bash hljs">sudo vi /opt/ipsec-pubkey/key-updater.sh</code></pre><br>
<pre><code class="bash hljs">
<span class="hljs-meta">#!/bin/bash</span><font></font>
/usr/bin/cp /home/keywatcher/ipsecgw.example.com.pem /etc/strongswan/ipsec.d/certs/ipsecgw.example.com.pem;<font></font>
/usr/bin/chown root:root /etc/strongswan/ipsec.d/certs/ipsecgw.example.com.pem<font></font>
/usr/bin/chmod 0600 /etc/strongswan/ipsec.d/certs/ipsecgw.example.com.pem<font></font>
logger <span class="hljs-string">"Public key of server ipsecgw.example.com has been updated, restarting connection"</span><font></font>
/usr/bin/systemctl restart strongswan<font></font>
<span class="hljs-built_in">exit</span> 0
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
需要pubkey-copy.sh脚本来提取密钥的公共部分，并在颁发新证书时将其复制到远程主机。</font><font style="vertical-align: inherit;">为此，请在两台服务器上的/ etc / letsencrypt / renewal-hooks / deploy目录中，创建另一个微脚本：</font></font><br>
<br>
<pre><code class="bash hljs">
<span class="hljs-meta">#!/bin/sh</span><font></font>
/opt/ipsec-pubkey/pubkey-copy.sh &gt; /dev/null 2&gt;&amp;1<font></font>
/usr/bin/systemctl restart strongswan<font></font>
<span class="hljs-built_in">exit</span> 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解决了一半问题，重新颁发了证书，提取了公钥并在服务器之间进行了复制，现在已经有了使用路径单元进行systemd的时间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在/ etc / systemd / system目录中的ipsecgw.example.com服务器上，创建keyupdater.path文件。</font></font><br>
<br>
<pre><code class="plaintext hljs">[Unit]<font></font>
Wants=strongswan.service<font></font>
[Path]<font></font>
PathChanged=/home/keywatcher/rkn.example.com.pem<font></font>
[Install]<font></font>
WantedBy=multi-user.target</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同样在VPS主机上：</font></font><br>
<br>
<pre><code class="bash hljs">[Unit]<font></font>
Wants=strongswan.service<font></font>
[Path]<font></font>
PathChanged=/home/keywatcher/ipsecgw.example.com.pem<font></font>
[Install]<font></font>
WantedBy=multi-user.target</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，在每台服务器上，我们都创建一个与此单元关联的服务，该服务将在满足条件（PathChanged）时启动-更改文件并在记录后关闭它。</font><font style="vertical-align: inherit;">我们创建文件/etc/systemd/system/keyupdater.service并编写：</font></font><br>
<br>
<pre><code class="plaintext hljs">[Unit]<font></font>
Description= Starts the IPSec key updating script<font></font>
Documentation= man:systemd.service<font></font>
[Service]<font></font>
Type=oneshot<font></font>
ExecStart=/opt/ipsec-pubkey/key-updater.sh<font></font>
[Install]<font></font>
WantedBy=multi-user.target</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不要忘记使用sudo systemctl daemon-reload重新读取systemd配置，并通过sudo systemctl enable keyupdater.path &amp;&amp; sudo systemctl start keyupdater将自动启动分配给路径单元。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一旦远程主机将包含公共密钥的文件写入keywatcher用户主目录，并且文件描述符关闭，systemd将自动启动相应的服务，该服务会将密钥复制到所需位置并重新启动Strongswan。</font><font style="vertical-align: inherit;">隧道将使用第二侧的正确公共密钥进行安装。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以呼气并欣赏结果。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如我们刚才看到的</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地狱</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IPSec是不是可怕，因为它是画。</font><font style="vertical-align: inherit;">已描述的全部是当前正在使用的完全可操作的配置。</font><font style="vertical-align: inherit;">即使没有很多知识，您也可以配置VPN并可靠地保护数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，设置iptables的时间仍然不在本文讨论的范围之内，但是文章本身已经足够多了，关于iptables的文章也很多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文章中有几点可以改进，因为它拒绝重新启动Strongswan守护程序，重新读取其配置和证书，但我无法实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，守护进程的重启并不可怕：对等端之间一两个ping丢失，移动客户端自行恢复连接。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
希望评论中的同事会提示正确的解决方案。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN504464/index.html">我们如何提出TableAdapter并简化UITableView的工作</a></li>
<li><a href="../zh-CN504468/index.html">Raspberry Pi性能：添加ZRAM并更改内核参数</a></li>
<li><a href="../zh-CN504472/index.html">我最喜欢的免费开发人员工具</a></li>
<li><a href="../zh-CN504480/index.html">如何找到与之合作将有利可图的营销商？</a></li>
<li><a href="../zh-CN504482/index.html">问我们：DIT将回答问题</a></li>
<li><a href="../zh-CN504486/index.html">流程：创建Vue 3</a></li>
<li><a href="../zh-CN504488/index.html">解决COVID-19问题后，哪些行业和技术将开始快速发展</a></li>
<li><a href="../zh-CN504490/index.html">6月在线活动摘要</a></li>
<li><a href="../zh-CN504492/index.html">按下按钮：电子投票的理论和实践-5月30日的圆桌会议</a></li>
<li><a href="../zh-CN504502/index.html">世界上第一个友好机器人的短暂而奇怪的生活</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>