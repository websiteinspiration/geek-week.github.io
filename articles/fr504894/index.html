<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☕️ 🤙🏿 🍔 GUI en russe, ou terminal VKS faites-le vous-même 👩🏽‍🎓 🐫 👩🏽‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Expérience dans le développement d'une interface graphique C ++ pour le système de vidéoconférence russe (VKS). La synthèse des technologies modernes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GUI en russe, ou terminal VKS faites-le vous-même</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/protei/blog/504894/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expérience dans le développement d'une interface graphique C ++ pour le système de vidéoconférence russe (VKS). </font><font style="vertical-align: inherit;">La synthèse des technologies modernes et des exigences de certification. </font><font style="vertical-align: inherit;">Le principal «rake» du développement et les moyens de les contourner. </font><font style="vertical-align: inherit;">Qu'est-ce que l'interface graphique et le ballet russe ont en commun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première chose que voit l'utilisateur du système de visioconférence est l'interface. </font><font style="vertical-align: inherit;">Et dans la plupart des cas, c'est par son apparence et sa fonctionnalité qu'ils jugent le système. </font><font style="vertical-align: inherit;">Une interface incommode ou tentaculaire ne permettra pas d'évaluer les performances élevées du système ou les fonctionnalités étendues. </font><font style="vertical-align: inherit;">Techniquement, un «beau» système doit être enveloppé dans une coque de travail attrayante et stable. </font><font style="vertical-align: inherit;">Par conséquent, au début du développement du système VKS domestique, ce moment a été immédiatement pris en compte.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mq/zf/vr/mqzfvrwj1mk6anlm3rjpjg44ngw.png" alt="image"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qui sera l'utilisateur du système de vidéoconférence russe?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depuis le printemps 2020, la réponse à la question de l'opportunité de développer un système VKS à part entière est devenue évidente. Les fonctionnaires, les entreprises commerciales, les hôpitaux et les écoles ont besoin de moyens de communication modernes avec un certain niveau de productivité et de sécurité. Vous pouvez parler dans Zoom, mais vaut-il la peine de l'utiliser pour de sérieuses négociations commerciales ou une réunion opérationnelle de managers?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour diverses tâches des entreprises russes, il est devenu nécessaire de créer un système de vidéoconférence national. </font><font style="vertical-align: inherit;">De plus, un système composé non seulement d'un composant logiciel, mais également d'un matériel à part entière. </font><font style="vertical-align: inherit;">Parmi les fournisseurs de renommée mondiale, au moins 5 entreprises proposent des systèmes de visioconférence multifonctionnels. </font><font style="vertical-align: inherit;">Mais en Russie, le concept de substitution des importations commence progressivement à fonctionner. </font><font style="vertical-align: inherit;">De plus, les problèmes de sécurité pour beaucoup sont devenus plus importants que le pays d'origine du produit, et le prix aux taux de change actuels n'est pas à la dernière place. </font><font style="vertical-align: inherit;">Et la «beauté» de l'interface s'est avérée assez réaliste à développer à partir de zéro.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GUI au démarrage</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les principales exigences pour les interfaces modernes sont la rapidité de mise en œuvre, l'apparence à jour et la convivialité totale. </font><font style="vertical-align: inherit;">Ainsi, la première tâche des développeurs de l'interface utilisateur graphique (GUI) a été une définition claire de la fonctionnalité logicielle pour la vidéoconférence. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Du point de vue de l'interface graphique, les exigences suivantes ont été formulées:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Passer des appels vidéo / audio sortants;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Accepter / rejeter les appels entrants;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Répondre automatiquement à un appel entrant à un intervalle de temps personnalisé;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basculer entre deux appareils audio (casque / haut-parleur) pendant et en dehors de l'appel;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Allumez / éteignez le microphone et la caméra pendant et en dehors de l'appel;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Numérotation DTMF pendant un appel;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Réunion de conférence au terminal;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gestion des caméras PTZ, sauvegarde des préréglages PTZ et de leur application;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La capacité de sortie vidéo sur plusieurs fenêtres différentes;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contrôlez la souris, le clavier, la télécommande;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La possibilité de contrôler à distance le terminal depuis l'interface Web.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette liste de fonctions vous permet de résoudre le problème du développement d'une interface de différentes manières. </font><font style="vertical-align: inherit;">De plus, le choix d'un type d'implémentation spécifique a été affecté par les limitations du type de langages de programmation (par exemple, Java n'était pas catégoriquement approprié pour des raisons de certification, CSS / HTML - selon la fonctionnalité), la spécialisation des développeurs et le calendrier. </font><font style="vertical-align: inherit;">Collectivement, le choix a été fait en faveur de C ++ et de l'utilisation du framework Qt5, car, par exemple, la technologie QML plus moderne ne permet pas de rendre la vidéo en utilisant un contexte OpenGL arbitraire, et cela était nécessaire selon les ToR pour les terminaux VKS.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f6/gd/lr/f6gdlr-u2n2ncctyiqjss5zloty.png" alt="image"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rapide et efficace</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier prototype d'interface graphique a été créé pour le softphone de Qt et a utilisé de nombreuses bibliothèques open source. </font><font style="vertical-align: inherit;">Par exemple, pour le protocole SIP, des bibliothèques eXosip / oSIP ont été utilisées, ffmpeg pour l'encodage / décodage vidéo et audio et PortAudio pour travailler avec des périphériques audio. </font><font style="vertical-align: inherit;">Ce softphone fonctionnait sous Linux, Windows, MacOS et était un démonstrateur de technologie, et non un véritable appareil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus tard, un softphone abstrait a été transformé en un véritable projet de visiophone, et la première version du logiciel aurait dû être créée 2 mois après le début. </font><font style="vertical-align: inherit;">Pour résoudre ce problème en si peu de temps, le logiciel du téléphone a été divisé en modules et réparti entre plusieurs groupes de développeurs en fonction des compétences. </font><font style="vertical-align: inherit;">Une telle organisation du processus a permis de développer rapidement et efficacement le projet de visiophone.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Noyau et avant</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour l'unification et la possibilité d'utiliser les développements GUI existants dans d'autres appareils à partir d'un projet existant, la base de code commune se trouve dans un module distinct - le backend GUI, ou le module de base GUI. </font><font style="vertical-align: inherit;">Et les représentations directement, qui sont différentes pour différents appareils, sont implémentées dans des modules frontaux GUI distincts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette architecture des modules GUI s'est avérée avantageuse et a conduit au résultat souhaité: le développement d'interfaces pour les nouveaux composants du système VKS lui-même est devenu relativement rapide et de haute qualité. </font><font style="vertical-align: inherit;">Après tout, les interfaces des terminaux VKS n'avaient plus besoin d'être réécrites à partir de zéro.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tourment et victoire</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur le chemin de la création d'un logiciel, il y a naturellement des difficultés et des problèmes. </font><font style="vertical-align: inherit;">La création d'une interface graphique pour la vidéoconférence n'a pas fait exception. </font><font style="vertical-align: inherit;">Quel que soit le but spécifique du système, ils peuvent être répétés dans n'importe quelle commande. </font><font style="vertical-align: inherit;">Les difficultés et les victoires sur la voie du développement sont intéressantes pour les collègues, et elles permettront peut-être de trouver des solutions efficaces sans notre «rake».</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une cohérence pour toujours</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Historiquement, le tout premier problème intéressant qui s'est posé lors du développement de l'interface graphique pour différents types de terminaux VKS a été le problème de cohérence, c'est-à-dire l'état coordonné de tous les modules. </font><font style="vertical-align: inherit;">Pendant le fonctionnement, l'interface graphique interagit avec plusieurs autres modules: un module d'interaction avec le matériel, un sous-système de gestion des appels, un module de traitement multimédia (MCU) et un sous-système d'interaction utilisateur.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/xp/5b/csxp5bydmvx6vi9eviyuxg8-d3k.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialement, l'interface graphique fonctionnait avec tous ces modules comme indépendants, c'est-à-dire qu'elle pouvait envoyer des demandes à 2 modules différents en même temps. Cela s'est avéré faux et a parfois conduit à des problèmes, car ces modules eux-mêmes n'étaient pas indépendants et interagissaient activement les uns avec les autres. La solution au problème a été la création d'un programme de travail spécial, qui a assuré l'exécution strictement séquentielle des demandes dans tous les modules.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y avait deux difficultés à ajouter: premièrement, certaines (mais pas toutes) les demandes nécessitent une réponse, en prévision de laquelle le terminal est en fait dans un état incohérent, de sorte que d'autres demandes ne peuvent pas être effectuées. Cependant, le blocage de l'interface utilisateur en attendant les réponses est également indésirable. Deuxièmement, les réponses aux requêtes GUI des modules, ainsi que les requêtes des modules à l'interface graphique, viennent dans leurs propres threads, différents de l'interface graphique, mais l'interface graphique doit implémenter tous les changements d'état dans son thread (pour certaines actions, Qt l'exige, mais dans dans certains cas, cela évite des difficultés inutiles pour assurer la synchronisation des threads).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La solution a été trouvée et comprenait deux parties. Tout d'abord, toutes les demandes / réponses d'autres modules ont été redirigées vers le flux GUI en utilisant le mécanisme d'intervalle de signal Qt en conjonction avec QueuedConnection, c'est-à-dire en utilisant la boucle d'événement QApplication globale. Ensuite, pour assurer un traitement cohérent de toutes les demandes, un système Transitions a été développé avec sa propre file d'attente et son propre cycle de traitement (TransitionLoop).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, lorsque l'utilisateur appuie sur un bouton d'action dans l'interface graphique (par exemple, le bouton d'appel), une transition correspondante est créée, qui est placée dans la file d'attente de transition. Après cela, un signal est généré pour le cycle de traitement de transition. TransitionLoop, lors de la réception d'un signal, cherche à voir s'il y a une transition en cours maintenant. Si tel est le cas, l'attente de la fin de la transition en cours se poursuit; sinon, la transition suivante est extraite de la file d'attente de transition et lancée. Lorsqu'une réponse est reçue d'un autre module TransitionLoop utilisant le même signal, la fin de la transition en cours est notifiée et TransitionLoop peut démarrer la transition suivante à partir de la file d'attente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'important ici est que tout le traitement de transition se fait dans un thread GUI. </font><font style="vertical-align: inherit;">Ceci est assuré par l'utilisation du mécanisme d'intervalle de signal Qt dans la variante QueuedConnection, dans lequel un événement est généré pour chaque signal et placé dans le EventLoop principal de l'application.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu OpenGL sur du matériel basse consommation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre difficulté à laquelle nous avons dû faire face était le problème du rendu vidéo. Qt fournit pour le rendu OpenGL une classe QOpenGLWidget spéciale et des classes d'assistance associées, qui étaient à l'origine utilisées pour le rendu vidéo. Les données de rendu (images vidéo décodées) elles-mêmes sont fournies par le module de traitement multimédia (MCU), qui, entre autres, implémente le décodage matériel du flux vidéo (sur le GPU). Sur les processeurs de faible puissance, un "ralentissement" du rendu de la vidéo FullHD a été trouvé. La solution directe était de remplacer le processeur, mais cela nécessiterait un traitement sérieux des composants déjà finis du système de visioconférence et augmenterait le coût des appareils eux-mêmes. Par conséquent, l'ensemble du processus de rendu a été soigneusement analysé pour trouver de plus belles façons de résoudre le problème.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec le rendu OpenGL standard et le décodage matériel, les événements suivants se produisent: les données avec la vidéo encodée proviennent du réseau, elles sont stockées dans la RAM, puis ces données de la RAM sont transférées vers la mémoire vidéo sur le GPU, où elles sont décodées. Ensuite, les données décodées ayant un volume significativement plus grand que les données codées sont à nouveau transférées vers la RAM. Ensuite, un code de rendu entre en jeu, qui transfère ces données de la RAM au GPU directement pour le rendu. Ainsi, des quantités assez importantes de données sont pompées dans les deux sens via le bus mémoire, et le bus ne peut tout simplement pas le faire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les versions modernes d'OpenGL, il existe des extensions spéciales qui vous permettent de spécifier pour le rendu des données qui sont déjà dans la mémoire du GPU, et non des données dans la RAM principale, comme d'habitude. Ce mécanisme a exclu le mouvement des données des trames décodées matériellement du GPU vers la RAM, puis inversement. Ainsi, le problème du rendu sur les processeurs basse consommation a été presque résolu.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ta/gx/rr/tagxrr-ydgiw9vlbucxyvli2jni.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre problème majeur était les contextes OpenGL pris en charge dans Qt. Ils ne vous permettent pas d'utiliser l'extension OpenGL nécessaire, c'est-à-dire que vous ne pouvez pas utiliser QOpenGLWidget avec cette option. La solution consistait à utiliser un QWidget classique, mais a désactivé le pipeline de rendu Qt. Une telle opportunité existe dans Qt. Cependant, une question s'est posée ici, car dans cette option, l'interface graphique est entièrement responsable de tout le rendu dans la zone de ce widget, Qt ne nous aide pas. Ceci est normal pour afficher la vidéo, mais pour utiliser des widgets au-dessus de la vidéo, les outils Qt standard ne peuvent pas être utilisés, car, par exemple, un menu contextuel supplémentaire doit être affiché au-dessus de la vidéo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce problème a été résolu comme suit: à partir du widget existant, son image est obtenue (QWidget a une méthode grab () pour cela), l'image résultante est convertie en texture OpenGL et cette dernière est rendue au-dessus de la vidéo à l'aide des outils OpenGL. </font><font style="vertical-align: inherit;">En ajoutant l'environnement approprié, un mécanisme universel a été mis en œuvre qui peut être utilisé pour afficher tous les widgets standard au-dessus de la vidéo d'une manière non standard.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kiosques et widgets</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tâche de gérer les affichages et de distribuer des fragments de l'interface utilisateur en mode «kiosque» n'a pas été facile. Le terminal VKS peut fonctionner en 2 modes - le mode fenêtre, c'est-à-dire comme toute autre application de fenêtre dans l'environnement de bureau du système d'exploitation, et le «mode kiosque» (c'est-à-dire que le système d'exploitation exécute une seule application avec une interface graphique - VKST - et qu'il n'y a pas d'environnement bureau).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En mode fenêtré, tout est relativement simple: la fenêtre est contrôlée par le gestionnaire de fenêtres de l'environnement de bureau, l'application crée une deuxième fenêtre si nécessaire, et l'utilisateur répartit les fenêtres sur les écrans selon ses besoins. Mais en mode «kiosque», tout est beaucoup plus compliqué, car le système n'a pas de gestionnaire de fenêtres et il ne peut y avoir qu'une seule fenêtre, et l'utilisateur n'a pas la possibilité de la déplacer. Par conséquent, la tâche de détecter automatiquement un événement, par exemple la connexion / déconnexion d'un écran, est apparue. Lorsque cet événement s'est produit, il était nécessaire de configurer automatiquement les affichages et de placer correctement des fragments de l'interface utilisateur dessus.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-x/dm/w_/-xdmw_fvqpxs-frj0pl04wszabg.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La réponse est venue de la bibliothèque système LINUX Xrandr OS, qui est chargée de travailler avec les écrans. Il y a très peu de documentation à ce sujet sur Internet, donc la mise en œuvre a été effectuée à l'aide d'exemples provenant d'Internet, y compris de Habr. De plus, il était nécessaire de trouver un algorithme pour distribuer les fragments d'interface entre les écrans, ainsi que d'intégrer deux fenêtres différentes en une seule. Ce dernier a été implémenté comme suit: ce sont des fenêtres en mode fenêtré, en mode «kiosque» sont des widgets à l'intérieur d'une grande fenêtre, qui s'étend sur 2 écrans (s'il y en a 2). Dans ce cas, il est nécessaire de configurer les positions des écrans afin qu'un espace virtuel continu soit créé (cela se fait à l'aide de la bibliothèque XRandr), puis de définir la géométrie des widgets internes à l'intérieur d'une seule fenêtre globale afinpour que tout le monde soit affiché.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous créons du russe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toute la manière de créer le système de vidéoconférence russe a consisté et comprend de nombreuses étapes, et l'interface graphique n'est que la pointe de l'iceberg. </font><font style="vertical-align: inherit;">Le plus visible et pas le plus difficile. </font><font style="vertical-align: inherit;">Cependant, la complexité de la solution, la combinaison de logiciels et de composants matériels et logiciels, et le désir de créer un système techniquement et esthétiquement «beau» ont créé de nombreuses difficultés en cours de route. </font><font style="vertical-align: inherit;">De nouvelles tâches ont donné naissance à des solutions non standard et ont aidé à créer un produit qui n'a pas honte d'être présenté non seulement en Russie mais aussi à l'étranger.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les développements russes ont depuis longtemps prouvé leurs performances, et dans une belle coque et compétitivité. </font><font style="vertical-align: inherit;">Nos hacks de vie seront utiles à toute personne sérieusement impliquée dans le développement d'interfaces graphiques, et nous espérons qu'ils aideront d'autres développeurs à accélérer et à simplifier le processus de création de shells modernes pour de nouveaux logiciels russes. </font><font style="vertical-align: inherit;">Nous pensons que les décisions russes seront appréciées dans le monde au même titre que le ballet russe ou le caviar noir.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr504880/index.html">Développement, optimisation et sortie de jeux Synthety sur Unity</a></li>
<li><a href="../fr504884/index.html">Périphériques dangereux: comprendre Thunderspy</a></li>
<li><a href="../fr504886/index.html">Selenium WebDriver au service du développeur</a></li>
<li><a href="../fr504888/index.html">"Calme, seulement calme!" ou moins de soucis</a></li>
<li><a href="../fr504890/index.html">Renvoyer la valeur de la commande d'invocation de powershell à l'Agent SQL-Server</a></li>
<li><a href="../fr504902/index.html">Les 9 principales tendances des tests automatisés en 2020</a></li>
<li><a href="../fr504906/index.html">PHP - quelle est la niche du langage et PHP8 aidera-t-il à résoudre les problèmes urgents (spoiler: IMHO pas)</a></li>
<li><a href="../fr504908/index.html">PyTrace - Débogueur de voyage dans le temps pour Python</a></li>
<li><a href="../fr504912/index.html">Fin de partie HackTheBox. Passage du laboratoire Opérations Offensives Professionnelles. Pentest Active Directory</a></li>
<li><a href="../fr504918/index.html">Les services de cours en ligne les plus efficaces pour les étudiants et les enseignants: les cinq premiers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>