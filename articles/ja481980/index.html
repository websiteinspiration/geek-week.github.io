<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙎🏽 🆎 🧓🏾 Unityでスクリプトを最適化した方法 🤰🏾 🖊️ 📕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unityの優れたパフォーマンスに関する記事やチュートリアルは数多くあります。この記事でそれらを置き換えたり、改善したりすることはありません。これは、これらの記事を読んだ後に実行した手順の簡単な要約と、問題を解決するための手順です。少なくともhttps://learn.unity.com/で資料を学...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unityでスクリプトを最適化した方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481980/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unityの優れたパフォーマンスに関する記事やチュートリアルは数多くあります。</font><font style="vertical-align: inherit;">この記事でそれらを置き換えたり、改善したりすることはありません。これは、これらの記事を読んだ後に実行した手順の簡単な要約と、問題を解決するための手順です。</font><font style="vertical-align: inherit;">少なくとも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://learn.unity.com/で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">資料を学習することを強くお勧めします</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲーム開発の過程で、時々ゲームプロセスを阻害する問題が発生しました。</font><font style="vertical-align: inherit;">Unityプロファイラーでしばらく過ごした後、2種類の問題が見つかりました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非最適化シェーダー</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cの最適化されていないスクリプト＃</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの問題は2番目のグループが原因で発生したため、この記事ではC＃スクリプトに焦点を合わせることにしました（おそらく、私の人生で1つのシェーダーを作成していないためです）。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱点を探す</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の目的は、プロファイラーの使用に関するチュートリアルを書くことではありません。私がプロファイリングプロセスで主に興味を持っていることについて話したかっただけです。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unityプロファイラーは</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、スクリプトの遅延の原因</font><strong><font style="vertical-align: inherit;">を</font></strong><font style="vertical-align: inherit;">見つけるため</font><strong><font style="vertical-align: inherit;">の最良の方法</font></strong><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">エディターではなく</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、デバイス</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><strong><font style="vertical-align: inherit;">直接ゲームをプロファイリングする</font></strong><font style="vertical-align: inherit;">ことを強くお勧めし</font><font style="vertical-align: inherit;">ます。私たちのゲームはiOS用に作成されたため、デバイスを接続し、画像に示されているビルド設定を使用する必要がありました。その後、プロファイラーが自動的に接続しました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c7/fad/0e0/5c7fad0e0596f91c183a80ea3d72d1ae.png"></div><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロファイリング用のビルド設定</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
「ランダムラグインユニティ」または他の同様のリクエストをグーグルしようとすると、ほとんどの人</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がガベージコレクション</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><strong><font style="vertical-align: inherit;">集中</font></strong><font style="vertical-align: inherit;">することをお勧め</font><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">オブジェクト（クラスインスタンス）の使用を停止するたびにガベージが生成されます。その後、Unityガベージコレクターは時々混乱をクリーンアップしてメモリを解放します。これには非常に時間がかかり、フレームレートの低下につながります。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ごみの原因となるプロファイラースクリプトを見つける方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CPU Usage-&gt; Choose Hierarchy view-&gt; Sort by GC Allocを選択するだけです</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/aed/605/167aed6059ad0276a4275d5edf2179db.png"></div><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガベージコレクションのプロファイラーオプション</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
あなたの仕事は、ゲームプレイシーンのGC alloc列で1つのゼロを達成することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの良い方法は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、エントリをTime ms</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ランタイム）で</font><strong><font style="vertical-align: inherit;">ソートし</font></strong><font style="vertical-align: inherit;">、スクリプトを最適化して、できるだけ時間がかからないようにすることです。</font><font style="vertical-align: inherit;">このステップには大きな影響がありました。コンポーネントの1つに</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大きなforループが</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">含まれ</font><font style="vertical-align: inherit;">ていて、完了するまでに</font><strong><font style="vertical-align: inherit;">長い</font></strong><font style="vertical-align: inherit;">時間がかかった</font><strong><font style="vertical-align: inherit;">ためです</font></strong><font style="vertical-align: inherit;">（そうです、ループを解消する方法がまだ見つかっていないため）、すべてのスクリプトの実行時間を最適化することが絶対に必要でした。 60 fpsの安定した周波数を維持しながら、この高価なforループでランタイムを節約する必要があったからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロファイリングデータに基づいて、最適化を2つの部分に分けました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ごみの処理</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リードタイムの​​短縮</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1：ゴミとの戦い</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この部分では、私がゴミを取り除くために何をしたかをお話します。</font><font style="vertical-align: inherit;">これは、開発者が理解すべき最も基本的な知識です。</font><font style="vertical-align: inherit;">それらは、すべてのプル/マージリクエストにおける日常の分析の重要な部分となっています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のルール：Updateメソッドに新しいオブジェクトはありません</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的には、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Update、FixedUpdate、およびLateUpdateメソッドにキーワード「new」を含めないでください</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">あなたはいつもあなたがすでに持っているものを使うべきです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合によって</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、新しいオブジェクトの作成</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が一部の内部Unityメソッドで</font><strong><font style="vertical-align: inherit;">隠さ</font></strong><font style="vertical-align: inherit;">れているため、それほど明白ではありません。</font><font style="vertical-align: inherit;">これについては後で話します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目のルール：一度作成して再利用する！</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本質的に、これはStartメソッドとAwakeメソッドでできるすべてのことに対してメモリを割り当てる必要があることを意味します。</font><font style="vertical-align: inherit;">このルールは最初のものと非常によく似ています。</font><font style="vertical-align: inherit;">これは実際には、Updateメソッドから「新しい」キーワードを削除するもう1つの方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それをコード化する：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいインスタンスを作成します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームオブジェクトを探す</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
常にUpdateメソッドからStartまたはAwakeに移動するようにしてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に、変更の例</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を示します。Startメソッドでリストにメモリを割り当て、それらをクリア（Clear）し、必要に応じて再利用します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//Bad code</span>
<span class="hljs-keyword">private</span> List&lt;GameObject&gt; objectsList;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    objectsList = <span class="hljs-keyword">new</span> List&lt;GameObject&gt;();<font></font>
    objectsList.Add(......)<font></font>
}<font></font>
<span class="hljs-comment">//Better Code</span>
<span class="hljs-keyword">private</span> List&lt;GameObject&gt; objectsList;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    objectsList = <span class="hljs-keyword">new</span> List&lt;GameObject&gt;();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    objectsList.Clear();<font></font>
    objectsList.Add(......)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リンクを保存し、次のように再利用します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//Bad code</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> levelObstacles = FindObjectsOfType&lt;Obstacle&gt;();
    <span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">var</span> obstacle <span class="hljs-keyword">in</span> levelObstacles) { ....... }<font></font>
}<font></font>
<span class="hljs-comment">//Better code</span>
<span class="hljs-keyword">private</span> Object[] levelObstacles;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    levelObstacles = FindObjectsOfType&lt;Obstacle&gt;();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">var</span> obstacle <span class="hljs-keyword">in</span> levelObstacles) { ....... }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じことが、FindGameObjectsWithTagメソッドや、新しい配列を返すその他のメソッドにも当てはまります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3番目のルール：文字列に注意し、それらを連結しないでください</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゴミを作成することになると、行はひどいです。最も単純な文字列操作でも、大量のガベージを作成できます。どうして？文字列は単なる配列であり、これらの配列は不変です。つまり、2つの行を連結するたびに、新しい配列が作成され、古い配列はゴミに変わります。さいわい、StringBuilderを使用して、このようなガベージの作成を回避または最小限に抑えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、状況を改善する方法の例です。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//Bad code</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    text = GetComponent&lt;Text&gt;();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    text.text = <span class="hljs-string">"Player "</span> + name + <span class="hljs-string">" has score "</span> + score.toString();<font></font>
}<font></font>
<span class="hljs-comment">//Better code</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    text = GetComponent&lt;Text&gt;();<font></font>
    builder = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">50</span>);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//StringBuilder has overloaded Append method for all types</span>
    builder.Length = <span class="hljs-number">0</span>;<font></font>
    builder.Append(<span class="hljs-string">"Player "</span>);<font></font>
    builder.Append(name);<font></font>
    builder.Append(<span class="hljs-string">" has score "</span>);<font></font>
    builder.Append(score);<font></font>
    text.text = builder.ToString();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例では、すべてが順調ですが、コードを改善する機会はまだたくさんあります。ご覧のとおり、ほとんどの文字列は静的と見なすことができます。文字列を2つのUI.Textオブジェクトの2つの部分に分割します。 1つ目は</font><font style="vertical-align: inherit;">、Startメソッドで割り当てることができる</font><font style="vertical-align: inherit;">静的テキスト</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Player" + name + "has score"のみを</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">含み、2つ目は、各フレームで更新されるスコア値を含みます。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的文字列は常に本当に静的にし、それらをStartまたはAwakeメソッドで生成します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この改善後、ほぼすべてが順調に進んでいますが、Int.ToString（）、Float.ToString（）などを呼び出すと、多少のガベージが生成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するには、可能なすべての行にメモリを生成して事前に割り当てます。</font><font style="vertical-align: inherit;">それは愚かなメモリの無駄遣いのように見えるかもしれませんが、そのような解決策は私たちのニーズに理想的に適し、問題を完全に解決します。</font><font style="vertical-align: inherit;">したがって、最終的に、静的配列を取得しました。この配列には、インデックスを使用して直接アクセスし、数値を示す目的の文字列を取得できます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">string</span>[] NUMBERS_THREE_DECIMAL = {
        <span class="hljs-string">"000"</span>, <span class="hljs-string">"001"</span>, <span class="hljs-string">"002"</span>, <span class="hljs-string">"003"</span>, <span class="hljs-string">"004"</span>, <span class="hljs-string">"005"</span>, <span class="hljs-string">"006"</span>,..........</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4番目のルール：アクセス方法によって返されるキャッシュ値</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に示すような単純なアクセサメソッドでもガベージを生成するため、これは非常に難しい場合があります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//Bad Code</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    gameObject.tag;<font></font>
    <span class="hljs-comment">//or</span><font></font>
    gameObject.name;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Updateメソッドでアクセスメソッドを使用しないようにしてください。</font><font style="vertical-align: inherit;">Startメソッドでアクセスメソッドを1回だけ呼び出し、戻り値をキャッシュします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、Updateメソッドでは文字列アクセスメソッドや配列アクセスメソッドを呼び出さないこと</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をお勧め</font><strong><font style="vertical-align: inherit;">します</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ほとんどの場合、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startメソッドで一度リンクを取得する</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だけで十分</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、最適化されていない別のアクセス方法コードの一般的な例を2つ示します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//Bad Code</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//Allocates new array containing all touches</span>
    Input.touches[<span class="hljs-number">0</span>];<font></font>
}<font></font>
<span class="hljs-comment">//Better Code</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    Input.GetTouch(<span class="hljs-number">0</span>);<font></font>
}<font></font>
<span class="hljs-comment">//Bad Code</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//Returns new string(garbage) and compare the two strings</span>
    gameObject.Tag == <span class="hljs-string">"MyTag"</span>;<font></font>
}<font></font>
<span class="hljs-comment">//Better Code</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    gameObject.CompareTag(<span class="hljs-string">"MyTag"</span>);<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5番目のルール：メモリを割り当てない関数を使用する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のUnity関数では、非メモリの代替が見つかります。</font><font style="vertical-align: inherit;">私たちの場合、これらすべての機能は物理学に関連しています。</font><font style="vertical-align: inherit;">私たちの衝突認識は、</font></font><br>
<br>
<pre><code class="cs hljs">Physics2D. CircleCast();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この特定のケースでは、非メモリ関数を見つけることができます</font></font><br>
<br>
<pre><code class="cs hljs">Physics2D. CircleCastNonAlloc();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の多くの関数にも同様の代替案があるため、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常にNonAlloc関数のドキュメントを確認してください</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6番目のルール：LINQを使用しない</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しないでください。</font><font style="vertical-align: inherit;">つまり、頻繁に実行されるコードで使用する必要はありません。</font><font style="vertical-align: inherit;">LINQを使用するとコードが読みやすくなりますが、多くの場合、そのようなコードのパフォーマンスとメモリ割り当てはひどいものです。</font><font style="vertical-align: inherit;">もちろん、使用されることもありますが、正直なところ、このゲームではLINQをまったく使用していません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第7のルール：一度作成して再利用する、パート2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今回はオブジェクトのプールについて話します。プーリングの詳細については説明しません。たとえば、このチュートリアルをよく検討してください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">//learn.unity.com/tutorial/object-pooling</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このケースでは、次のオブジェクトプーリングスクリプトを使用します。生成されたレベルは、プレイヤーがレベルのこの部分を通過するまでの一定期間存在する障害物で満たされています。このような障害のインスタンスは、特定の条件が満たされた場合にプレハブから作成されます。コードはUpdateメソッド内にあります。このコードは、メモリとランタイムの点で完全に非効率的です。 40個の障害のプールを生成して問題を解決しました。必要に応じて、プールから障害を取得し、オブジェクトが不要になったときにプールに戻します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第8のルール：パッケージ化変換（ボクシング）をさらに注意深く！</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボクシングはゴミを生成します！</font><font style="vertical-align: inherit;">しかし、ボクシングとは何ですか？</font><font style="vertical-align: inherit;">多くの場合、ボックス化は、値タイプ（int、float、boolなど）をObjectタイプのオブジェクトを必要とする関数に渡すときに発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、プロジェクトで修正する必要のあるボクシングの例です</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。プロジェクトに独自のメッセージングシステムを実装しました。</font><font style="vertical-align: inherit;">各メッセージには、無制限の量のデータを含めることができます。</font><font style="vertical-align: inherit;">データは、次のように定義された辞書に格納されます。</font></font><br>
<br>
<pre><code class="cs hljs">Dictionary&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">object</span>&gt; data;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この辞書に値を設定するセッターもあります：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Action <span class="hljs-title">SetAttribute</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> attribute, <span class="hljs-keyword">object</span> <span class="hljs-keyword">value</span></span>)</span><font></font>
{<font></font>
    data[attribute] = <span class="hljs-keyword">value</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでのボクシングはかなり明白です。</font><font style="vertical-align: inherit;">次のように関数を呼び出すことができます。</font></font><br>
<br>
<pre><code class="cs hljs">SetAttribute(<span class="hljs-string">"my_int_value"</span>, <span class="hljs-number">12</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、値「12」がボックス化され、これによりガベージが生成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリミティブ型ごとに個別のデータコンテナーを作成することで問題を解決し、以前のオブジェクトコンテナーは参照型にのみ使用されました。</font></font><br>
<br>
<pre><code class="cs hljs">Dictionary&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">object</span>&gt; data;<font></font>
Dictionary&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">bool</span>&gt; dataBool;<font></font>
Dictionary&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>&gt; dataInt;<font></font>
.......</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、データタイプごとに個別のセッターがあります。</font></font><br>
<br>
<pre><code class="cs hljs">SetBoolAttribute(<span class="hljs-keyword">string</span> attribute, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">value</span>)<font></font>
SetIntAttribute(<span class="hljs-keyword">string</span> attribute, <span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてこれらすべてのセッターは、同じ一般化された関数を呼び出すように実装されています。</font></font><br>
<br>
<pre><code class="cs hljs">SetAttribute&lt;T&gt;(<span class="hljs-keyword">ref</span> Dictionary&lt;<span class="hljs-keyword">string</span>, T&gt; dict, <span class="hljs-keyword">string</span> attribute, T <span class="hljs-keyword">value</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボクシングの問題は解決されました！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この詳細については、記事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/types/boxing-and-unboxingを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照して</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ください</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9番目のルール：サイクルは常に疑わしい</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このルールは、1番目と2番目に非常に似ています。</font><font style="vertical-align: inherit;">パフォーマンスとメモリ上の理由から、ループからオプションのコードをすべて削除してみてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的なケースでは、Updateメソッドでループをなくすように努めていますが、ループなしではループを実行できない場合は、そのようなループでのメモリ割り当てを少なくとも回避します。</font><font style="vertical-align: inherit;">したがって、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルール1〜8</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に従って</font><font style="vertical-align: inherit;">、Updateメソッドだけでなく、一般的</font><strong><font style="vertical-align: inherit;">にループ</font></strong><font style="vertical-align: inherit;">に</font><strong><font style="vertical-align: inherit;">適用し</font></strong><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルール10：外部ライブラリにゴミがない</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ガベージの一部がアセットストアからダウンロードされたコードによって生成されていることが判明した場合、この問題には多くの解決策があります。</font><font style="vertical-align: inherit;">ただし、リバースエンジニアリングとデバッグを行う前に、アセットストアに戻ってライブラリを更新するだけです。</font><font style="vertical-align: inherit;">私たちの場合、使用されたすべてのアセットは、パフォーマンス向上アップデートをリリースし続けた作者によってまだサポートされていたため、これですべての問題が解決されました。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存関係が適切でなければなりません！</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サポートしないままにするよりも、ライブラリを取り除くほうがいいです。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート2：ランタイムの最大化</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のルールの一部は、コードがめったに呼び出されない場合に微妙な違いをもたらします。各フレームで実行されるコードには大きなループが1つあるため、これらの小さな変更でも大きな影響がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの変更の一部は、不適切に使用したり間違った状況で使用したりすると、実行時間がさらに悪化する可能性があります。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードに各最適化を入力した後は、必ずプロファイラーをチェックして、正しい方向に進んでいることを確認してください</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正直なところ、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのルールの</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部は、</font><strong><font style="vertical-align: inherit;">コードの可読性を大幅に低下させ</font></strong><font style="vertical-align: inherit;">、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推奨事項</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><strong><font style="vertical-align: inherit;">違反する</font></strong><font style="vertical-align: inherit;">こともあり</font><font style="vertical-align: inherit;">ます。たとえば、以下のルールの1つで言及されているコードの埋め込みです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのルールの多くは、記事の最初の部分で提示されたものと重複しています。</font><font style="vertical-align: inherit;">通常、ガベージ生成コードのパフォーマンスは、ガベージ生成なしのコードと比較して低くなります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のルール：正しい実行順序</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FixedUpdate、Update、LateUpdateメソッドからStartおよびAwakeメソッドにコードを移動します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">奇妙に聞こえるかもしれませんが、コードを詳しく調べると、一度だけ実行されるメソッドに移動できる数百行のコードが見つかるでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、このコードは通常、</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetComponent &lt;&gt;の呼び出し</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各フレームで実際に同じ結果を返す計算 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じオブジェクトの複数のインスタンス、通常はリスト </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームオブジェクトを検索</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換へのリンクの取得と他のアクセス方法の使用</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、UpdateメソッドからStartメソッドに移動したサンプルコードのリストです。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//There must be a good reason to keep GetComponent in Update</span><font></font>
gameObject.GetComponent&lt;LineRenderer&gt;();<font></font>
gameObject.GetComponent&lt;CircleCollider2D&gt;();<font></font>
<font></font>
<span class="hljs-comment">//Examples of calculations returning same result every frame</span>
Mathf.FloorToInt(Screen.width / <span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> width = <span class="hljs-number">2f</span> * mainCamera.orthographicSize * mainCamera.aspect;
<span class="hljs-keyword">var</span> castRadius = circleCollider.radius * transform.lossyScale.x;
<span class="hljs-keyword">var</span> halfSize = GetComponent&lt;SpriteRenderer&gt;().bounds.size.x / <span class="hljs-number">2f</span>;<font></font>
<font></font>
<span class="hljs-comment">//Finding objects</span>
<span class="hljs-keyword">var</span> levelObstacles = FindObjectsOfType&lt;Obstacle&gt;();
<span class="hljs-keyword">var</span> levelCollectibles = FindGameObjectsWithTag(<span class="hljs-string">"COLLECTIBLE"</span>);<font></font>
<font></font>
<span class="hljs-comment">//References</span><font></font>
objectTransform = gameObject.transform;<font></font>
mainCamera = Camera.main;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目のルール：必要な場合にのみコードを実行する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、これは主にUI更新スクリプトに関連しています。</font><font style="vertical-align: inherit;">レベルで収集されたアイテムの現在の状態を表示するコードの実装を変更した例を次に示します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//Bad code</span><font></font>
Text text;<font></font>
GameState gameState;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    gameState = StoreProvider.Get&lt;GameState&gt;();    <font></font>
    text = GetComponent&lt;Text&gt;();<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    text.text = gameState.CollectedCollectibles.ToString();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各レベルで収集するアイテムは数個しかないため、各フレームでUIのテキストを変更しても意味がありません。</font><font style="vertical-align: inherit;">したがって、数値が変更された場合にのみテキストを変更します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//Better code</span><font></font>
Text text;<font></font>
GameState gameState;<font></font>
<span class="hljs-keyword">int</span> collectiblesCount;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    gameState = StoreProvider.Get&lt;GameState&gt;();    <font></font>
    text = GetComponent&lt;Text&gt;();<font></font>
    collectiblesCount = gameState.CollectedCollectibles;<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">if</span>(collectiblesCount != gameState.CollectedCollectibles) {<font></font>
        <font></font>
        <span class="hljs-comment">//This code is ran only about 5 times each level</span><font></font>
        collectiblesCount = gameState.CollectedCollectibles;<font></font>
        text.text = collectiblesCount.ToString();<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは、特にUIを変更するだけではなく、アクションがはるかに複雑な場合に、はるかに優れています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より包括的なソリューションを探している場合は、</font><font style="vertical-align: inherit;">C＃イベントを使用し</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">てObserverテンプレート</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">実装</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">する</font></a><font style="vertical-align: inherit;">ことをお勧めし</font><font style="vertical-align: inherit;">ます（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とにかく、これではまだ十分ではなく、完全に一般化されたソリューションを実装したかったため</font><font style="vertical-align: inherit;">、Unityで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を実装するライブラリを作成しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これにより、ゲームの状態全体がStoreオブジェクトに格納され、状態が変化するとすべてのUI要素と他のコンポーネントに通知され、Updateメソッドのコードなしでこの変化に対応するという非常にシンプルなソリューションが実現しました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3番目のルール：サイクルは常に疑わしい</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、記事の最初の部分で述べたのとまったく同じ規則です。</font><font style="vertical-align: inherit;">コードに、多数の要素を繰り返しバイパスするある種のループがある場合、ループのパフォーマンスを向上させるには、記事の両方の部分から両方のルールを使用します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4番目のルール：Foreachよりも良い</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Foreachループは非常に簡単に記述できますが、実行は「非常に困難」です。</font><font style="vertical-align: inherit;">Foreachループ内では、Enumeratorを使用してデータセットを繰り返し処理し、値を返します。</font><font style="vertical-align: inherit;">これは、単純なForループでインデックスを反復するよりも複雑です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、このプロジェクトでは、可能な限りForeachループをForに置き換えました。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//Bad code</span>
<span class="hljs-keyword">foreach</span> (GameObject obstacle <span class="hljs-keyword">in</span> obstacles)<font></font>
<font></font>
<span class="hljs-comment">//Better code</span>
<span class="hljs-keyword">var</span> count = obstacles.Count;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {<font></font>
    obstacles[i];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大きなforループの場合、この変更は非常に重要です。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純なforループは、コードを2倍高速化します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5番目のルール：配列はリストよりも優れている</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのコードでは、ほとんどのリストが一定の長さであるか、要素の最大数を計算できることがわかりました。</font><font style="vertical-align: inherit;">したがって、配列に基づいてそれらを再度実装し、場合によっては、これによりデータの反復が2倍に加速されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合によっては、リストやその他の複雑なデータ構造を回避できないことがあります。</font><font style="vertical-align: inherit;">要素を追加または削除しなければならないことがよくあります。この場合、リストを使用することをお勧めします。</font><font style="vertical-align: inherit;">ただし、一般に、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列は常に固定長リストに使用する必要があります</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6番目のルール：浮動小数点演算はベクトル演算よりも優れています</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この違いは、私たちの場合のように、そのような操作を何千回も実行しない場合にはほとんど目立たないため、生産性の向上は著しいことがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様の変更を加えました：</font></font><br>
<br>
<pre><code class="cs hljs">Vector3 pos1 = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<font></font>
Vector3 pos2 = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<font></font>
<font></font>
<span class="hljs-comment">//Bad code</span>
<span class="hljs-keyword">var</span> pos3 = pos1 + pos2;<font></font>
<font></font>
<span class="hljs-comment">//Better code</span>
<span class="hljs-keyword">var</span> pos3 = <span class="hljs-keyword">new</span> Vector3(pos1.x + pos2.x, pos1.y + pos2.y, ......);<font></font>
Vector3 pos1 = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<font></font>
<font></font>
<font></font>
<span class="hljs-comment">//Bad code</span>
<span class="hljs-keyword">var</span> pos2 = pos1 * <span class="hljs-number">2f</span>;<font></font>
<font></font>
<span class="hljs-comment">//Better code</span>
<span class="hljs-keyword">var</span> pos2 = <span class="hljs-keyword">new</span> Vector3(pos1.x * <span class="hljs-number">2f</span>, pos1.y * <span class="hljs-number">2f</span>, ......);</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第7のルール：オブジェクトを正しく検索する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GameObject.Find（）メソッドを本当に使用する必要があるかどうかを常に考えてください。</font><font style="vertical-align: inherit;">この方法は重く、非常に時間がかかります。</font><font style="vertical-align: inherit;">このメソッドをUpdateメソッドで使用しないでください。</font><font style="vertical-align: inherit;">Find呼び出しのほとんどは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、エディターの直接リンクに置き換える</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことができることがわかりました</font><font style="vertical-align: inherit;">。もちろん、これははるかに優れています。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//Bad Code</span><font></font>
GameObject player;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    player = GameObject.Find(<span class="hljs-string">"PLAYER"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//Better Code</span><font></font>
<font></font>
<span class="hljs-comment">//Assign the reference to the player object in editor</span>
[<span class="hljs-meta">SerializeField</span>]<font></font>
GameObject player;<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが不可能な場合は、少なくとも</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タグ（Tag）を使用し、GameObject.FindWithTagを使用してそのラベルでオブジェクトを検索することを検討して</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、一般的なケースでは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接リンク&gt; GameObject.FindWithTag（）&gt; GameObject.Find（）</font></font></strong><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第8のルール：関連するオブジェクトでのみ機能する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、RayCast-s（CircleCastなど）を使用して衝突を認識することが重要でした。</font><font style="vertical-align: inherit;">衝突を認識してコード内で重要なものを決定する代わりに</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ゲームオブジェクトを適切なレイヤーに移動し</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て、必要なオブジェクトのみの衝突を計算できるようにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここに例があります</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//Bad Code</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DetectCollision</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> count = Physics2D.CircleCastNonAlloc(<font></font>
       position, radius, direction, results, distance);<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
       <span class="hljs-keyword">var</span> obj = results[i].collider.transform.gameObject;
       <span class="hljs-keyword">if</span>(obj.CompareTag(<span class="hljs-string">"FOO"</span>)) {<font></font>
           ProcessCollision(results[i]);<font></font>
       }<font></font>
    }<font></font>
}<font></font>
                              <font></font>
<span class="hljs-comment">//Better Code</span>
<span class="hljs-comment">//We added all objects with tag FOO into the same layer</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DetectCollision</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//8 is number of the desired layer</span>
    <span class="hljs-keyword">var</span> mask = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>;
    <span class="hljs-keyword">var</span> count = Physics2D.CircleCastNonAlloc(<font></font>
       position, radius, direction, results, distance, mask);<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {<font></font>
       ProcessCollision(results[i]);<font></font>
    }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9番目のルール：ラベルを正しく使用する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラベルが非常に便利でコードのパフォーマンスを向上できることは間違いありませんが、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトラベルを比較する正しい方法は1つしかないことに注意してください</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//Bad Code</span>
gameObject.Tag == <span class="hljs-string">"MyTag"</span>;<font></font>
<font></font>
<span class="hljs-comment">//Better Code</span>
gameObject.CompareTag(<span class="hljs-string">"MyTag"</span>);</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10番目のルール：カメラのトリックに注意してください！</font></font></h2><br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camera.main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">
とても簡単に使用できます</font><font style="vertical-align: inherit;">が、このアクションのパフォーマンスは非常に低くなります。</font><font style="vertical-align: inherit;">その理由は、Camera.mainへのすべての呼び出しの舞台裏で、Unityエンジンが実際にFindGameObjectsWithTag（）の結果を実行するため、頻繁に呼び出す必要がないことをすでに理解して</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おり、Startメソッドでリンクをキャッシュする</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことによってこの問題を解決するのが最善の</font><strong><font style="vertical-align: inherit;">方法です。</font></strong><font style="vertical-align: inherit;">または目を覚まします。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//Bad code</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    Camera.main.orthographicSize <span class="hljs-comment">//Some operation with camera</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//Better Code</span>
<span class="hljs-keyword">private</span> Camera cam;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    cam = Camera.main;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    cam.orthographicSize <span class="hljs-comment">//Some operation with camera</span>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11番目のルール：LocalPositionはPositionよりも優れています</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能な限り、Transform.Positionの代わりに、ゲッターとセッターにはTransform.LocalPositionを使用してください</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">各Transform.Position呼び出し内では、ゲッター呼び出しの場合はグローバル位置を計算する、セッター呼び出しの場合はグローバルからローカル位置を計算するなど、さらに多くの操作が実行されます。</font><font style="vertical-align: inherit;">私たちのプロジェクトでは、Transform.Positionを使用して99％のケースでLocalPositionsを使用でき、コードに他の変更を加える必要がないことが判明しました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12番目のルール：LINQを使用しない</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これについては、最初の部分ですでに説明しました。</font><font style="vertical-align: inherit;">使用しないでください、それだけです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13番目のルール：ルールを破ることを恐れないでください（ときどき）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純な関数の呼び出しでさえ、コストがかかりすぎることがあります。この場合は、常にコードの埋め込みを検討する必要があります（コードのインライン化）。どういう意味ですか？実際、関数からコードを取得して、関数を使用したい場所に直接コピーし、追加のメソッドを呼び出さないようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、これは効果がありません。コードの埋め込みはコンパイル段階で自動的に実行されるためですが、コンパイラーがコードを埋め込むかどうかを決定する特定のルールがあります（たとえば、仮想メソッドは決して埋め込まれません。詳細については、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">https：を</font></a><font style="vertical-align: inherit;">参照して</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ください）。 //docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity8.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">したがって、プロファイラーを開いて、ターゲットデバイスでゲームを実行し、何か改善できるかどうかを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、特に大規模なforループで、パフォーマンスを向上させるために統合することにしたいくつかの関数がありました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事に記載されているルールを適用すると、iPhone 5Sでも、iOS用のゲームで安定した60 fpsを簡単に達成できました。</font><font style="vertical-align: inherit;">おそらくいくつかのルールは私たちのプロジェクトにのみ固有のものかもしれませんが、それらのほとんどは、将来の問題を避けるためにコードを書いたりチェックしたりするときに覚えておくべきだと思います。</font><font style="vertical-align: inherit;">後で大きなコードフラグメントをリファクタリングするよりも、常にパフォーマンスを考慮してコードを記述する方が常に優れています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja481958/index.html">mail.ruの署名者またはメールインターフェイスでT-34戦車を通過する方法</a></li>
<li><a href="../ja481960/index.html">2.エラスティックスタック：セキュリティログ分析。Logstash</a></li>
<li><a href="../ja481964/index.html">リリースを整理する方法</a></li>
<li><a href="../ja481970/index.html">「忘れられたオーディオフォーマットとメディア」：コンパクトオーディオの時代の始まり、またはボビンの「最初のシフト」</a></li>
<li><a href="../ja481978/index.html">分散レイアウトチームの効果的な作業を整理する方法</a></li>
<li><a href="../ja481988/index.html">Kojiが初心者のKaiOSアプリ作成者にとって完璧なリソースである理由</a></li>
<li><a href="../ja481990/index.html">10年間のマルウェア：2010年最大のボットネット</a></li>
<li><a href="../ja481992/index.html">Tekton Pipeline-Kubernetesネイティブパイプライン</a></li>
<li><a href="../ja481996/index.html">週末のハブラ刑事2.新しいレベル</a></li>
<li><a href="../ja481998/index.html">オートマトンプログラムのモデルとしてのチューリングマシン</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>