<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêüèø ü§ê üßúüèº Como proteger processos e extens√µes de kernel no macOS üöü üë©üèΩ‚Äçüî¨ üë≤üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Hoje eu gostaria de falar sobre como voc√™ pode proteger processos contra invasores no macOS. Por exemplo, √© √∫til para um antiv√≠rus ou sistem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Como proteger processos e extens√µes de kernel no macOS</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/497714/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ol√° Habr! </font><font style="vertical-align: inherit;">Hoje eu gostaria de falar sobre como voc√™ pode proteger processos contra invasores no macOS. </font><font style="vertical-align: inherit;">Por exemplo, √© √∫til para um antiv√≠rus ou sistema de backup, especialmente tendo em conta que no macOS existem v√°rias maneiras de "matar" o processo. </font><font style="vertical-align: inherit;">Leia sobre isso e sobre os m√©todos de prote√ß√£o abaixo de um gato.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/403/e5f/065/403e5f065b7426d384f3c71e8cb3c8a5.jpg" alt="imagem"></a><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira cl√°ssica de matar um processo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A maneira bem conhecida de "matar" um processo √© enviar um sinal sobre um processo SIGKILL. </font><font style="vertical-align: inherit;">Atrav√©s do bash, voc√™ pode chamar o padr√£o "kill -SIGKILL PID" ou "pkill -9 NAME" para matar. </font><font style="vertical-align: inherit;">O comando kill √© conhecido desde o UNIX e est√° dispon√≠vel n√£o apenas no macOS, mas tamb√©m em outros sistemas semelhantes ao UNIX. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como nos sistemas UNIX, o macOS permite interceptar qualquer sinal no processo, exceto dois - SIGKILL e SIGSTOP. </font><font style="vertical-align: inherit;">Neste artigo, o sinal SIGKILL ser√° considerado principalmente como um sinal que originou a morte de um processo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Especificidades do MacOS</font></font><br>
</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No macOS, a chamada do sistema kill no kernel XNU chama a fun√ß√£o psignal (SIGKILL, ...). Vamos tentar ver o que outras a√ß√µes do usu√°rio no espa√ßo do usu√°rio podem chamar de fun√ß√£o psignal. Eliminamos chamadas para a fun√ß√£o psignal nos mecanismos internos do kernel (embora possam n√£o ser triviais, vamos deix√°-las para outro artigo :) - verifica√ß√£o de assinatura, erros de mem√≥ria, processamento de sa√≠da / encerramento, viola√ß√£o de prote√ß√£o de arquivos etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Iniciamos a vis√£o geral com a fun√ß√£o e a chamada de sistema correspondente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminate_with_payload</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pode-se observar que, al√©m da chamada de interrup√ß√£o cl√°ssica, h√° uma abordagem alternativa espec√≠fica ao sistema operacional macOS e n√£o encontrada no BSD. </font><font style="vertical-align: inherit;">Os princ√≠pios operacionais de ambas as chamadas de sistema tamb√©m est√£o pr√≥ximos. </font><font style="vertical-align: inherit;">S√£o chamadas diretas para a fun√ß√£o psignal do kernel. </font><font style="vertical-align: inherit;">Observe tamb√©m que, antes de encerrar um processo, uma verifica√ß√£o de ‚Äúcansignal‚Äù √© realizada - se o processo pode enviar um sinal para outro processo, o sistema n√£o permite que nenhum aplicativo interrompa processos do sistema, por exemplo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>
<span class="hljs-title">terminate_with_payload_internal</span><span class="hljs-params">(struct proc *cur_proc, <span class="hljs-keyword">int</span> target_pid, <span class="hljs-keyword">uint32_t</span> reason_namespace,
				<span class="hljs-keyword">uint64_t</span> reason_code, <span class="hljs-keyword">user_addr_t</span> payload, <span class="hljs-keyword">uint32_t</span> payload_size,
				<span class="hljs-keyword">user_addr_t</span> reason_string, <span class="hljs-keyword">uint64_t</span> reason_flags)</span>
</span>{<font></font>
...<font></font>
	target_proc = proc_find(target_pid);<font></font>
...<font></font>
	<span class="hljs-keyword">if</span> (!cansignal(cur_proc, cur_cred, target_proc, SIGKILL)) {<font></font>
		proc_rele(target_proc);<font></font>
		<span class="hljs-keyword">return</span> EPERM;<font></font>
	}<font></font>
...<font></font>
	<span class="hljs-keyword">if</span> (target_pid == cur_proc-&gt;p_pid) {
		<span class="hljs-comment">/*
		 * psignal_thread_with_reason() will pend a SIGKILL on the specified thread or
		 * return if the thread and/or task are already terminating. Either way, the
		 * current thread won't return to userspace.
		 */</span><font></font>
		psignal_thread_with_reason(target_proc, current_thread(), SIGKILL, signal_reason);<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		psignal_with_reason(target_proc, SIGKILL, signal_reason);<font></font>
	}<font></font>
...<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">launchd</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A maneira padr√£o de criar daemons na inicializa√ß√£o do sistema e controlar sua vida √∫til √© iniciada. </font><font style="vertical-align: inherit;">Vou chamar a aten√ß√£o para o fato de o c√≥digo fonte ser da vers√£o antiga do launchctl antes do macOS 10.10, exemplos de c√≥digo s√£o fornecidos como uma ilustra√ß√£o. </font><font style="vertical-align: inherit;">O launchctl moderno envia sinais launchd atrav√©s do XPC, a l√≥gica do launchctl √© transferida para ele. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos considerar como o aplicativo est√° parado. </font><font style="vertical-align: inherit;">Antes de enviar um sinal SIGTERM, eles tentam parar o aplicativo usando a chamada do sistema proc_terminate.</font></font><br>
<br>
<pre><code class="cpp hljs">&lt;launchctl src/core.c&gt;<font></font>
...<font></font>
	error = proc_terminate(j-&gt;p, &amp;sig);<font></font>
	<span class="hljs-keyword">if</span> (error) {<font></font>
		job_log(j, LOG_ERR | LOG_CONSOLE, <span class="hljs-string">"Could not terminate job: %d: %s"</span>, error, strerror(error));<font></font>
		job_log(j, LOG_NOTICE | LOG_CONSOLE, <span class="hljs-string">"Using fallback option to terminate job..."</span>);<font></font>
		error = kill2(j-&gt;p, SIGTERM);<font></font>
		<span class="hljs-keyword">if</span> (error) {<font></font>
			job_log(j, LOG_ERR, <span class="hljs-string">"Could not signal job: %d: %s"</span>, error, strerror(error));<font></font>
		} <font></font>
...<font></font>
&lt;&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sob o cap√¥, proc_terminate, apesar de seu nome, pode enviar n√£o apenas o sinal com o SIGTERM, mas tamb√©m o SIGKILL.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Morte indireta - limite de recursos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um caso mais interessante pode ser visto em outra chamada do sistema </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">process_policy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O uso padr√£o dessa chamada do sistema s√£o limites de recursos do aplicativo, por exemplo, para o indexador, h√° um limite no tempo do processador e na cota de mem√≥ria para que o sistema n√£o diminua significativamente devido a a√ß√µes de armazenamento em cache do arquivo. Se o aplicativo atingiu o limite de recursos, como pode ser visto na fun√ß√£o proc_apply_resource_actions, o sinal SIGKILL √© enviado ao processo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embora essa chamada do sistema possa potencialmente matar um processo, o sistema n√£o verificou adequadamente os direitos do processo que causou a chamada do sistema. De fato, uma verifica√ß√£o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas √© suficiente usar o sinalizador alternativo PROC_POLICY_ACTION_SET para ignorar essa condi√ß√£o.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, se voc√™ "limitar" a cota de uso da CPU pelo aplicativo (por exemplo, permitir que apenas 1 ns sejam executados), poder√° eliminar qualquer processo no sistema. </font><font style="vertical-align: inherit;">Portanto, o malware pode matar qualquer processo no sistema, incluindo o processo antiv√≠rus. </font><font style="vertical-align: inherit;">Tamb√©m √© interessante o efeito que ocorre quando um processo √© morto com o pid 1 (launchctl) - p√¢nico do kernel ao tentar processar um sinal SIGKILL :)</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/91e/fea/a49/91efeaa490ffd57580d2e5f4a59b4988.png" alt="imagem"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resolver o problema?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A maneira mais direta de impedir que um processo seja morto √© substituir o ponteiro de fun√ß√£o na tabela de chamadas do sistema. Infelizmente, esse m√©todo n√£o √© trivial por v√°rios motivos: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
primeiro, o s√≠mbolo respons√°vel pela posi√ß√£o do sysent na mem√≥ria n√£o √© apenas um s√≠mbolo particular do kernel XNU, mas tamb√©m n√£o pode ser encontrado nos s√≠mbolos do kernel. Voc√™ precisar√° usar m√©todos de pesquisa heur√≠stica, por exemplo, desmontagem din√¢mica de uma fun√ß√£o e procurar um ponteiro nela. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em segundo lugar, a estrutura das entradas na tabela depende dos sinalizadores com os quais o kernel foi constru√≠do. Se o sinalizador CONFIG_REQUIRES_U32_MUNGING for declarado, o tamanho da estrutura ser√° alterado - um campo adicional </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">sy_arg_munge32</font></a><font style="vertical-align: inherit;"> ser√° adicionado</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">√â necess√°rio realizar uma verifica√ß√£o adicional no sinalizador com o qual o kernel foi compilado, como op√ß√£o, comparar os indicadores com as fun√ß√µes conhecidas.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysent</span> {</span>         <span class="hljs-comment">/* system call table */</span>
        <span class="hljs-keyword">sy_call_t</span>       *sy_call;       <span class="hljs-comment">/* implementing function */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> CONFIG_REQUIRES_U32_MUNGING || (__arm__ &amp;&amp; (__BIGGEST_ALIGNMENT__ &gt; 4))</span>
        <span class="hljs-keyword">sy_munge_t</span>      *sy_arg_munge32; <span class="hljs-comment">/* system call arguments munger for 32-bit process */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        <span class="hljs-keyword">int32_t</span>         sy_return_type; <span class="hljs-comment">/* system call return types */</span>
        <span class="hljs-keyword">int16_t</span>         sy_narg;        <span class="hljs-comment">/* number of args */</span>
        <span class="hljs-keyword">uint16_t</span>        sy_arg_bytes;   <span class="hljs-comment">/* Total size of arguments in bytes for
                                         * 32-bit system calls
                                         */</span><font></font>
};<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Felizmente, nas vers√µes modernas do macOS, a Apple fornece uma nova API para trabalhar com processos. </font><font style="vertical-align: inherit;">A API do Endpoint Security permite que os clientes autorizem muitas solicita√ß√µes para outros processos. </font><font style="vertical-align: inherit;">Portanto, voc√™ pode bloquear qualquer sinal nos processos, incluindo o sinal SIGKILL usando a API mencionada acima.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bsm/libbsm.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;EndpointSecurity/EndpointSecurity.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>{
    <span class="hljs-keyword">es_client_t</span>* cli = <span class="hljs-literal">nullptr</span>;<font></font>
    {<font></font>
        <span class="hljs-keyword">auto</span> res = es_new_client(&amp;cli, ^(<span class="hljs-keyword">es_client_t</span> * client, <span class="hljs-keyword">const</span> <span class="hljs-keyword">es_message_t</span> * message) {
            <span class="hljs-keyword">switch</span> (message-&gt;event_type) {
                <span class="hljs-keyword">case</span> ES_EVENT_TYPE_AUTH_SIGNAL:<font></font>
                {<font></font>
                    <span class="hljs-keyword">auto</span>&amp; msg = message-&gt;event.signal;
                    <span class="hljs-keyword">auto</span> target = msg.target;
                    <span class="hljs-keyword">auto</span>&amp; token = target-&gt;audit_token;
                    <span class="hljs-keyword">auto</span> pid = audit_token_to_pid(token);
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"signal '%d' sent to pid '%d'\n"</span>, msg.sig, pid);<font></font>
                    es_respond_auth_result(client, message, pid == getpid() ? ES_AUTH_RESULT_DENY : ES_AUTH_RESULT_ALLOW, <span class="hljs-literal">false</span>);<font></font>
                }<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        });<font></font>
    }<font></font>
<font></font>
    {<font></font>
        <span class="hljs-keyword">es_event_type_t</span> evs[] = { ES_EVENT_TYPE_AUTH_SIGNAL };<font></font>
        es_subscribe(cli, evs, <span class="hljs-keyword">sizeof</span>(evs) / <span class="hljs-keyword">sizeof</span>(*evs));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, getpid());<font></font>
    sleep(<span class="hljs-number">60</span>); <span class="hljs-comment">// could be replaced with other waiting primitive</span><font></font>
<font></font>
    es_unsubscribe_all(cli);<font></font>
    es_delete_client(cli);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da mesma forma, voc√™ pode registrar a Pol√≠tica MAC no kernel, que fornece um m√©todo de prote√ß√£o de sinal (pol√≠tica proc_check_signal), mas a API n√£o √© oficialmente suportada.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prote√ß√£o de Extens√£o do Kernel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m de proteger os processos no sistema, a prote√ß√£o da pr√≥pria extens√£o do kernel (kext) tamb√©m √© necess√°ria. O macOS fornece uma estrutura para os desenvolvedores desenvolverem convenientemente drivers de dispositivo IOKit. Al√©m de fornecer ferramentas para trabalhar com dispositivos, o IOKit fornece m√©todos de empilhamento de driver usando inst√¢ncias de classes C ++. Um aplicativo no espa√ßo do usu√°rio poder√° "encontrar" uma inst√¢ncia registrada da classe para estabelecer uma conex√£o kernel-espa√ßo do usu√°rio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para detectar o n√∫mero de inst√¢ncias de classe no sistema, o utilit√°rio ioclasscount existe.</font></font><br>
<br>
<pre><code class="cpp hljs">my_kext_ioservice = <span class="hljs-number">1</span>
my_kext_iouserclient = <span class="hljs-number">1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qualquer extens√£o do kernel que desejar registrar-se na pilha de drivers deve declarar uma classe herdada do IOService, por exemplo, my_kext_ioservice neste caso.Os aplicativos de usu√°rio conectados criar√£o uma nova inst√¢ncia da classe que herda de IOUserClient, no exemplo my_kext_iouserclient. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao tentar descarregar o driver do sistema (comando kextunload), a fun√ß√£o virtual ‚Äúbool terminate (op√ß√µes IOOptionBits)‚Äù √© chamada. </font><font style="vertical-align: inherit;">√â suficiente retornar false na chamada para a fun√ß√£o de t√©rmino ao tentar descarregar para desativar o kextunload.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Kext::terminate</span><span class="hljs-params">(IOOptionBits options)</span>
</span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!IsUnloadAllowed)<font></font>
  {<font></font>
    <span class="hljs-comment">// Unload is not allowed, returning false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> super::<span class="hljs-built_in">terminate</span>(options);<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O sinalizador IsUnloadAllowed pode ser definido por IOUserClient na inicializa√ß√£o. </font><font style="vertical-align: inherit;">Quando o carregamento √© limitado, o comando kextunload retornar√° a seguinte sa√≠da:</font></font><br>
<br>
<pre><code class="cpp hljs">admin@admins-Mac drivermanager % sudo kextunload ./test.kext<font></font>
Password:<font></font>
(kernel) Can<span class="hljs-number">'</span>t remove kext my.kext.test; services failed to <span class="hljs-built_in">terminate</span> - <span class="hljs-number">0xe00002c7</span>.<font></font>
Failed to unload my.kext.test - (iokit/common) unsupported function.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma prote√ß√£o semelhante deve ser feita para IOUserClient. </font><font style="vertical-align: inherit;">As inst√¢ncias de classe podem ser descarregadas usando a fun√ß√£o de espa√ßo do usu√°rio IOKitLib ‚ÄúIOCatalogueTerminate (mach_port_t, sinalizador uint32_t, descri√ß√£o io_name_t);‚Äù. </font><font style="vertical-align: inherit;">Voc√™ pode retornar false em uma chamada para o comando ‚Äúterminar‚Äù at√© que o espa√ßo do usu√°rio desapare√ßa o aplicativo, ou seja, n√£o haja chamada para a fun√ß√£o clientDied.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prote√ß√£o de arquivo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para proteger arquivos, basta usar a API do Kauth, que permite restringir o acesso aos arquivos. A Apple fornece aos desenvolvedores notifica√ß√µes sobre v√°rios eventos no escopo, as opera√ß√µes KAUTH_VNODE_DELETE, KAUTH_VNODE_WRITE_DATA e KAUTH_VNODE_DELETE_CHILD s√£o importantes para n√≥s. Restringir o acesso aos arquivos √© mais f√°cil ao longo do caminho - usamos a API "vn_getpath" para obter o caminho para o arquivo e comparar o prefixo do caminho. Observe que, para otimizar a renomea√ß√£o dos caminhos das pastas com arquivos, o sistema n√£o autoriza o acesso a cada arquivo, mas apenas √† pr√≥pria pasta, que foi renomeada. √â necess√°rio comparar o caminho pai e restringir KAUTH_VNODE_DELETE para ele.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6e2/ab5/2fb/6e2ab52fb8c17ea8adfe8b63bcf8f611.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A desvantagem dessa abordagem pode ser o baixo desempenho com o aumento do n√∫mero de prefixos. Para que a compara√ß√£o n√£o seja igual a O (prefixo * comprimento), onde prefixo √© o n√∫mero de prefixos, length √© o comprimento da string, voc√™ pode usar uma DFA (m√°quina de estados finitos determin√≠stica) constru√≠da por prefixos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere uma maneira de criar um DFA para esse conjunto de prefixos. Inicializamos os cursores no in√≠cio de cada prefixo. Se todos os cursores apontam para o mesmo caractere, aumentamos cada cursor em um caractere e lembramos que o comprimento da mesma linha √© mais um. Se houver dois cursores com s√≠mbolos diferentes, dividimos os cursores em grupos pelo s√≠mbolo para o qual eles apontam e repetimos o algoritmo para cada grupo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No primeiro caso (todos os caracteres sob os cursores s√£o iguais), obtemos o estado do DFA, que possui apenas uma transi√ß√£o na mesma linha. </font><font style="vertical-align: inherit;">No segundo caso, obtemos uma tabela de transi√ß√£o do tamanho 256 (n√∫mero de caracteres e o n√∫mero m√°ximo de grupos) nos estados subseq√ºentes, obtidos chamando a fun√ß√£o recursivamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere um exemplo. </font><font style="vertical-align: inherit;">Para um conjunto de prefixos (‚Äú/ foo / bar / tmp /‚Äù, ‚Äú/ var / db / foo /‚Äù, ‚Äú/ foo / bar / aba /‚Äù, ‚Äúfoo / bar / aac /‚Äù), voc√™ pode obter o seguinte DFA. </font><font style="vertical-align: inherit;">A figura mostra apenas transi√ß√µes que levam a outros estados, outras transi√ß√µes n√£o ser√£o finais. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/190/d0f/5ec/190d0f5ec1fdd8c03df23387d83db44a.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao passar pelos estados da CAD, pode haver tr√™s casos.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O estado final foi alcan√ßado - o caminho est√° protegido, restringimos as opera√ß√µes KAUTH_VNODE_DELETE, KAUTH_VNODE_WRITE_DATA e KAUTH_VNODE_DELETE_CHILD</font></font></li>
<li>    ,   ‚Äú‚Äù (  -) ‚Äî   ,   KAUTH_VNODE_DELETE. ,   vnode  ,     ‚Äò/‚Äô,         ‚Äú/foor/bar/t‚Äù,  .</li>
<li>    ,   .       ,   .</li>
</ol><br>
<h3></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O objetivo das solu√ß√µes de seguran√ßa desenvolvidas √© aumentar o n√≠vel de seguran√ßa do usu√°rio e de seus dados. Por um lado, este objetivo √© garantido pelo desenvolvimento do produto de software Acronis, que cobre vulnerabilidades em que o pr√≥prio sistema operacional √© "fraco". Por outro lado, n√£o devemos negligenciar o aprimoramento dos aspectos de seguran√ßa que podem ser aprimorados no lado do sistema operacional, especialmente porque o fechamento de tais vulnerabilidades aumenta nossa pr√≥pria estabilidade como produto. A vulnerabilidade foi relatada pela equipe de seguran√ßa do produto Apple e foi corrigida no macOS 10.14.5 (https://support.apple.com/en-gb/HT210119).</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e27/604/c24/e27604c248d5405276235cf613319754.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo isso pode ser feito apenas se o seu utilit√°rio tiver sido oficialmente instalado no kernel. </font><font style="vertical-align: inherit;">Ou seja, n√£o existem brechas para software externo e indesejado. </font><font style="vertical-align: inherit;">No entanto, como voc√™ pode ver, mesmo para proteger programas leg√≠timos, como antiv√≠rus e sistemas de backup, voc√™ precisa trabalhar duro. </font><font style="vertical-align: inherit;">Mas agora, os novos produtos Acronis para macOS ter√£o prote√ß√£o adicional contra o descarregamento do sistema.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt497688/index.html">Como funciona a escola noturna de Kubernetes</a></li>
<li><a href="../pt497696/index.html">Como o Ryuk ransomware que ataca empresas</a></li>
<li><a href="../pt497700/index.html">Mitaps online semanais sobre suporte e DevOps, seguran√ßa e rob√¥s a partir de 17 de abril</a></li>
<li><a href="../pt497702/index.html">Cinco tend√™ncias em armazenamento de dados que voc√™ deve prestar aten√ß√£o em 2020</a></li>
<li><a href="../pt497708/index.html">Convidamos voc√™ a uma s√©rie de semin√°rios on-line da Fujitsu em abril e maio</a></li>
<li><a href="../pt497724/index.html">Preparando um servidor para publicar um aplicativo Web em Python</a></li>
<li><a href="../pt497726/index.html">Escalando testes do Android em Odnoklassniki</a></li>
<li><a href="../pt497728/index.html">Os perigos de "queimar" chips</a></li>
<li><a href="../pt497730/index.html">BDD conveniente: SpecFlow + TFS</a></li>
<li><a href="../pt497736/index.html">Revis√£o de 10 novos motores de combust√£o interna</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>