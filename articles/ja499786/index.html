<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♾ 👩🏼‍🔧 🚧 弱いヒープの並べ替え 🧖🏾 💇 🚇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="動物園の山全体の中で、この構造はおそらく最も珍しいものです。同時に、アルゴリズムの洗練されたシンプルさは、その驚くべき偏心と完全に一致しています。
 
 弱いヒープを使用してソートする場合、通常のヒープを使用するよりも比較と交換が常に少なくなります。つまり、弱いパイルは通常のパイルよりも強力です。
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>弱いヒープの並べ替え</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/499786/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><div style="text-align:center;"><img width="765" height="430" src="https://habrastorage.org/webt/hh/ve/rt/hhvertyrtwsbd99rbboihxxyjjk.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
動物園の山全体の中で、この構造はおそらく最も珍しいものです。</font><font style="vertical-align: inherit;">同時に、アルゴリズムの洗練されたシンプルさは、その驚くべき偏心と完全に一致しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
弱いヒープを使用してソートする場合、通常のヒープを使用するよりも比較と交換が常に少なくなります。</font><font style="vertical-align: inherit;">つまり、弱いパイルは通常のパイルよりも強力です。</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="EDISONソフトウェア-ウェブ開発"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISONソフトウェア-ウェブ開発"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事はEDISONのサポートを得て書かれました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我々は、に従事している</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">組み込みソフトウェアの作成</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だけでなく、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Webアプリケーションやサイトの開発</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムの理論が大好きです！</font><font style="vertical-align: inherit;">;-)</font></font></blockquote><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱い山</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常のヒープは、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">親がその子孫よりも大きい（または等しい）</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ソートツリー</font></a><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">弱いヒープでは、この要件は緩和されます。どの親も、その右側のサブツリーからの子孫よりも大きい（または等しい）だけです。</font><font style="vertical-align: inherit;">左側のサブツリーでは、子孫は親よりも小さくても大きくてもかまいません。幸運です。</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="299" src="https://habrastorage.org/webt/by/f6/ef/byf6efzj8swlst2y_2dvb7onduu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチにより、データセットをヒープ状態に維持するコストを大幅に削減できます。</font><font style="vertical-align: inherit;">結局のところ、「子孫は親にすぎない」という原則を、構造全体ではなく、その半分だけに保証する必要があります。</font><font style="vertical-align: inherit;">同時に、100％ソーティングツリーではない弱いヒープは、通常のヒープよりも悪くはなく、いくつかの点でより優れています。</font><font style="vertical-align: inherit;">戦いの半分をやりました-大胆に歩きましょう！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒープのルートは弱いものであっても、最大の要素を正確に必要とするため、左側のサブツリーのルートは必要ありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比較の数を最小限に抑える</font></font></h2><br>
<img align="left" width="215" height="199" src="https://habrastorage.org/webt/ng/cu/e1/ngcue1zei7olyudhfpge5blkcgu.jpeg"><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムとグラフ理論の専門家であるロナルドD.ダットンは、1993年に弱い束を提示してくれました。概念的に弱いパイルは、通常のパイルよりも理解するのが困難です（ただし、この困難さは、複雑さではない可能性が高いですが、贅沢では、膝を通して意識パターンを壊す必要があります）。したがって、実際的な分布はあまりありません。しかし、ダットンがこの構造を発明したとき、彼は抽象的な抽象化を実践したいだけでなく、完全に実用的な目標を追求しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較の最小数を推定するための理論的な下限があります（これらの比較が広く使用されているソートでは）：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！ = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / ln 2 + O（log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、ここで1 / ln 2 = 1.4426 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
弱いヒープによるソートでは、比較の数は最小化され、下限に十分近くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、長い文字列をソートする場合など、比較にコストがかかるオブジェクトを配置する必要がある場合に実用的に重要です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子孫のジャグリング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
弱いヒープの「左」と「右」は状況的な現象です。サブツリーは、親ノードの左または右の子孫にすることができます。さらに、サブツリーと親のこの「左/右」関係は、プロセス中に1つの値から反対の値に繰り返し切り替えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右の息子がいて左の娘がいる親を示すのは簡単ではありませんが、とても簡単です。これを行うには、子孫を持つノードに追加のビットマップ（0/1の値のみで構成される）が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インデックス</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目の親要素を</font><font style="vertical-align: inherit;">思い出し</font><font style="vertical-align: inherit;">て、通常のパイルでその左側と右側の子孫のインデックスを定義します（ゼロから測定した配列のインデックス）：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左の子孫2× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右の子孫2× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
弱いヒープでは、ケーキの上にチェリーがあります。ルートには正しいサブツリーのみがあり、1の位置に逆シフトを追加することにより、これらの数式を子孫のインデックスに合わせて調整します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左の子孫：2× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
右の子孫：2× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、追加のビットマップ（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ぶ</font><font style="vertical-align: inherit;">）が</font><font style="vertical-align: inherit;">必要でした</font><font style="vertical-align: inherit;">。ここで、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目の要素については、交換がその左サブツリーと右サブツリーの間に配置されるかどうかでした。要素の値が0の場合、交換は行われていません。値が1の場合、左と右の子は逆の順序になります。この場合の式は次のとおりです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左の子孫：2× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右の子孫：2× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは次のようになります。</font><font style="vertical-align: inherit;">子孫が「その逆」にある要素は、青で強調表示されます。</font><font style="vertical-align: inherit;">それら</font><font style="vertical-align: inherit;">の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列の値</font><font style="vertical-align: inherit;">は1です。</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="330" src="https://habrastorage.org/webt/h0/by/bm/h0bybmjxpw21mdj1x3uyamtsyk4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
子孫式の</font><b><font style="vertical-align: inherit;">BIT</font></b><font style="vertical-align: inherit;">配列から</font><font style="vertical-align: inherit;">親値</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と対応する0/1を</font><font style="vertical-align: inherit;">代入することで確認できます</font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">子孫</font><font style="vertical-align: inherit;">のインデックスは必要に応じて判明します。</font><font style="vertical-align: inherit;">
ご覧のように、親が左右のサブツリーを交換するには、配列自体の中で、要素のグループをどこにも移動する必要はありません。</font><b><font style="vertical-align: inherit;">BIT</font></b><font style="vertical-align: inherit;">配列の親の0/1値のみが</font><b><font style="vertical-align: inherit;">切り替えられ</font></b><font style="vertical-align: inherit;">、それだけです。</font><font style="vertical-align: inherit;">
次は-その後の露出と魔法のセッション。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱い山を築く</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左右の子孫の入れ替えは、配列からデータセットをウィークヒープに変換するための主要なツールです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プライマリウィークヒープを形成するプロセスでは、配列の要素を逆の順序で（最後から開始して）並べ替え、各要素について最初の（右）親のブランチを見つけます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素が誰かの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正しい子孫</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">である</font><font style="vertical-align: inherit;">場合、</font><font style="vertical-align: inherit;">遠くに行く必要はありません。</font><font style="vertical-align: inherit;">その直接の親はあなたが必要とするものです：</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="304" src="https://habrastorage.org/webt/tg/_4/01/tg_401fvyqumg-j_nbwm1-n_bna.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素が誰かの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左の子孫</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">である場合、目的の祖父母に出会う前に、いくつかのレベルを上げる必要があります。祖父母は、要素が右側のサブツリーにあります。</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="304" src="https://habrastorage.org/webt/lk/ud/-f/lkud-fixce2hbm1d7ejuil3pnh8.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、上のどこかで見つかった子孫と祖先を比較する必要があります。</font><font style="vertical-align: inherit;">子孫が前駆細胞より大きい場合は、次のことを行う必要があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子孫に子孫がある場合は、左側と右側のサブツリーを交換します（つまり</font><font style="vertical-align: inherit;">、この要素の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">0/1を切り替え</font><font style="vertical-align: inherit;">ます）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子孫ノードと前駆ノードの値を交換します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の例を見てみましょう。</font><font style="vertical-align: inherit;">次の状況が発生したとしましょう：</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/8f/-8/kr/8f-8krbczd6kxh2o-cbbe4hdkdc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] = 87 </font><font style="vertical-align: inherit;">の要素の</font><font style="vertical-align: inherit;">場合、必要な前駆細胞</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1] = 76が見つかりました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
始原</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1]は要素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] </font><font style="vertical-align: inherit;">よりも小さい</font><font style="vertical-align: inherit;">（76 &lt;87）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6]には、左と右のサブツリーがあります（緑の網掛けでマークされています）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのサブツリーを交換する必要があります</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（つまり</font><font style="vertical-align: inherit;">、</font><b><font style="vertical-align: inherit;">BIT</font></b><font style="vertical-align: inherit;">配列の</font><font style="vertical-align: inherit;">要素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] </font><font style="vertical-align: inherit;">の場合、値を0から1に変更します）。</font><font style="vertical-align: inherit;">
要素</font><b><font style="vertical-align: inherit;">A</font></b><font style="vertical-align: inherit;"> [6]と</font><b><font style="vertical-align: inherit;">A</font></b><font style="vertical-align: inherit;"> [1] </font><font style="vertical-align: inherit;">の値を交換することも必要</font><font style="vertical-align: inherit;">です。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
必要なアクションが完了した後：</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/zy/fb/vb/zyfbvbqsvoyyidown3ljp5pe8mk.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6]の場合、左と右のサブツリーが交換されました</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（つまり</font><font style="vertical-align: inherit;">、要素</font><b><font style="vertical-align: inherit;">A</font></b><font style="vertical-align: inherit;"> [6]の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列では、</font><font style="vertical-align: inherit;">0からの値が1に変更されました）。</font><b><font style="vertical-align: inherit;">A</font></b><font style="vertical-align: inherit;"> [6]と</font><b><font style="vertical-align: inherit;">A</font></b><font style="vertical-align: inherit;"> [1]の</font><font style="vertical-align: inherit;">
間でも値の交換がありました</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列を最後から最初に移動し、途中ですべての要素に対してこの手順を実行すると、ヒープが弱くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この奇妙なメカニズムが機能する理由は、記事の終わりに近い説明です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱い山の解析</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最大要素がルートにある場合、ヒープはヒープです。この事実を利用して、すべてのヒープの並べ替えは同じように機能します。ルート（最大値が配置されている場所）は、配列のソートされていない部分の最後の要素と値を交換します。その結果、配列のソートされていない部分が減少し、配列のソートされた部分が増加します。この交換後、現在の最大要素がルートにないため、ヒープはヒープでなくなります。ヒープを復元する必要があります。つまり、結果のツリーを再びヒープにします。別の最大要素を見つけて、ルートに移動します。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ふつうの</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
バイナリヒープを回復する方法</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ふるいを使って</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">わかっ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ています</font></a><font style="vertical-align: inherit;">。しかし、弱いヒープを復元する方法は？これを行うには、以下を実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルートから、左の子孫を（下から右に）降りていきます。</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/ka/d1/t8/kad1t8a7egmsgtgrpuqk6txqajc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、左の子孫を上に移動し、途中で各左の子孫がヒープルートの要素と比較されます。</font><font style="vertical-align: inherit;">そして、次の左の子孫がルートより大きい場合は、前のステージと同じようにします：左の子孫でサブツリーを交換し（サブツリーがある場合）、左の子孫とルートの値を変更します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、弱いヒープが復元されます。残りのツリーにある最大の要素がルートに表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しますが、この神秘的なカルーセルには、相互に置き換わるサブツリーがあります。</font><font style="vertical-align: inherit;">では、成功の秘訣は何でしょうか？</font><font style="vertical-align: inherit;">値を持つノードの交換中に、下位ノードの左と右の子孫が交換されるのはなぜですか？</font><font style="vertical-align: inherit;">答えはその天才で簡単ですが、あなたは推測することはありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱いヒープの並べ替え::弱いヒープの並べ替え</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、最終的なアルゴリズム：</font></font><br>
<br>
<ul>
<li><b>I.     :</b><ul>
<li><b>I.1.</b>    -.</li>
<li><b>I.2.</b>           «» .</li>
<li><b>I.3.</b>       .</li>
<li><b>I.4.</b>       , :<ul>
<li><b>I.4..</b>   ( ⇔ )     ,     .</li>
<li><b>I.4..</b>    «»      .</li>
</ul></li>
</ul></li>
<li><b>II.            ,     :</b><ul>
<li><b>II.1.</b>           .</li>
<li><b>II.2.</b>             .         .</li>
<li><b>II.3.</b>        ,        .   :<ul>
<li><b>II.3..</b>          .</li>
<li><b>II.3..</b>        ,      .</li>
<li><b>II.3..</b>     ,    , :<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.3.c. 1。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（左⇔右）サブツリーを現在の左の子孫が配置されているノードの子孫と交換します。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.3.c.2。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒープルートと現在の左の子を持つノードを変更します。</font></font></li>
</ul></li>
</ul></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.4。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱いヒープのルートには、配列の残りのソートされていない部分の最大の要素があります。</font><font style="vertical-align: inherit;">II.1項に戻り、すべての要素がソートされるまでこのプロセスを繰り返します。</font></font></li>
</ul></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アニメーション（私のアニメーションの配列インデックスは1で始まります）：</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/1l/ay/j-/1layj-xmzm4dl7p5yv7_5iag5pa.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++コード</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「リンク」セクションの下部で、興味のある人は、C ++でのこのソートの実装に慣れることができます。</font><font style="vertical-align: inherit;">ここでは、アルゴリズム自体を示す部分のみを示します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GETFLAG(r, x) ((r[(x) &gt;&gt; 3] &gt;&gt; ((x) &amp; 7)) &amp; 1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TOGGLEFLAG(r, x) (r[(x) &gt;&gt; 3] ^= 1 &lt;&lt; ((x) &amp; 7))</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WeakHeap::WeakHeapMerge</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *r, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>{
  <span class="hljs-keyword">if</span> (wheap[i] &lt; wheap[j]) {<span class="hljs-comment">//""  ?</span>
    <span class="hljs-comment">//  ,   </span>
    <span class="hljs-comment">//( "",   "")</span><font></font>
    TOGGLEFLAG(r, j);<font></font>
    <span class="hljs-comment">//  ""  </span><font></font>
    swap(wheap[i], wheap[j]);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WeakHeap::WeakHeapSort</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> n = Size();
  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>) {<font></font>
		<font></font>
    <span class="hljs-keyword">int</span> i, j, x, y, Gparent;
    <span class="hljs-keyword">int</span> s = (n + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> * r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> [s];<font></font>
		<font></font>
    <span class="hljs-comment">//  ,    </span>
    <span class="hljs-comment">// "",   ""</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">8</span>; ++i) r[i] = <span class="hljs-number">0</span>;<font></font>
		<font></font>
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">for</span>(i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) {<font></font>
      j = i;<font></font>
      <span class="hljs-comment">//    , </span>
      <span class="hljs-comment">//   ""  </span>
      <span class="hljs-keyword">while</span> ((j &amp; <span class="hljs-number">1</span>) == GETFLAG(r, j &gt;&gt; <span class="hljs-number">1</span>)) j &gt;&gt;= <span class="hljs-number">1</span>;
      <span class="hljs-comment">//       ""  </span>
      Gparent = j &gt;&gt; <span class="hljs-number">1</span>;
      <span class="hljs-comment">//  ,   </span>
      <span class="hljs-comment">//   ""</span><font></font>
      WeakHeapMerge(r, Gparent, i);<font></font>
    }<font></font>
		<font></font>
    <span class="hljs-comment">//      --&gt;</span>
    <span class="hljs-comment">//  --&gt;    </span>
    <span class="hljs-keyword">for</span>(i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">2</span>; --i) {
      <span class="hljs-comment">//      </span>
      <span class="hljs-comment">//       </span>
      swap(wheap[<span class="hljs-number">0</span>], wheap[i]);<font></font>
      x = <span class="hljs-number">1</span>;
      <span class="hljs-comment">//    "" </span>
      <span class="hljs-keyword">while</span>((y = <span class="hljs-number">2</span> * x + GETFLAG(r, x)) &lt; i) x = y;
      <span class="hljs-comment">//  ""     </span>
      <span class="hljs-comment">//        </span>
      <span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>) {<font></font>
        WeakHeapMerge(r, <span class="hljs-number">0</span>, x);<font></font>
        x &gt;&gt;= <span class="hljs-number">1</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">//  -   </span>
    <span class="hljs-comment">//    </span>
    swap(wheap[<span class="hljs-number">0</span>], wheap[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">delete</span>[] r;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に、バイナリツリーがビットごとの演算を使用して簡単かつ自然にトラバースされる方法が好きです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">余分なメモリの複雑さ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">よう</font><font style="vertical-align: inherit;">です-追加の配列が必要です。子孫を持つノード（配列内のノードの約半分がある）の場合、左/右サブツリーの順序は固定されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ここでのソートの複雑さは実際にはO（1）であるという意見があります。</font><font style="vertical-align: inherit;">要素の場合、子孫の順序を示すために追加のビットが1つだけ（ゼロ/ 1）必要です。</font><font style="vertical-align: inherit;">たとえば文字列をソートする場合、この追加のビットを要素自体に追加することは非常に現実的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）をO（1）に変換</font><font style="vertical-align: inherit;">するもう1つの方法</font><font style="vertical-align: inherit;">は、フラグを整数で格納することです。</font><font style="vertical-align: inherit;">数値のバイナリ展開-配列のすべての要素のサブツリーの順序を担当するゼロと1のセット。</font><font style="vertical-align: inherit;">配列</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目の要素</font><font style="vertical-align: inherit;">は、数値の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目のビットに</font><font style="vertical-align: inherit;">対応し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間の複雑さ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間までに、O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は通常のヒープと同じです。</font><font style="vertical-align: inherit;">行（特に長い行）をソートする場合、弱いヒープは通常のヒープよりも速くなる可能性があります。</font><font style="vertical-align: inherit;">しかし、これは長い行を並べ替える場合です。</font><font style="vertical-align: inherit;">数字を並べ替えると、噂によると、通常のヒープの方が管理が高速です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フルふるい分け</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の弱いヒープの形成の段階で、通常のヒープとの類推により、大きな要素をできるだけ高く上げるという非常に明白なアイデアが求められます。</font><font style="vertical-align: inherit;">つまり、下位ノードとその前駆細胞の値を交換した場合は、前駆細胞の手順をすぐに繰り返す-彼に最も近い右の前駆細胞を見つけて比較すること（そして、値を交換する必要がある場合+サブツリーの交換も必要です）です。</font><font style="vertical-align: inherit;">そして、可能であれば、大きな要素を根元まで上げます。</font><font style="vertical-align: inherit;">これは、最初の段階での見え方です（アルゴリズムの第2段階でのアクションは変更されていません）。</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/9x/9-/pa/9x9-panzenovigxgpzzal8phtri.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間の複雑さのスコアは変わりません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二項パイル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点までのすべては、欺瞞、幻想です。もちろん、そこではバイナリツリーでいくつかの操作を正式に実行し、ノードを値で変更し、サブツリーを再配置します。ただし、アルゴリズムには二重の底があるので、これを調べます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この種を理解するには、弱いヒープが実際に何であるかを理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素の数が2のべき乗である配列をとると、弱いヒープとそれに基づいて構築された二項ヒープは同型になります。</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="222" src="https://habrastorage.org/webt/nk/ge/qu/nkgequw_s9eaecxl7h9fiz9v2ua.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
弱いヒープはバイナリであり、二項式はバイナリではないという事実を見ないでください。</font><font style="vertical-align: inherit;">弱いヒープでは、左と右のサブツリーは本質的に異なります。</font><font style="vertical-align: inherit;">右側のサブツリーは古典的な意味での子孫ですが、左側のサブツリーはむしろ「兄弟」です。</font><font style="vertical-align: inherit;">そうではありませんが。</font><font style="vertical-align: inherit;">左側のサブツリーは「兄弟」でもなく、ノードが少ない「兄弟」のベクトルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、弱いヒープと二項ヒープは、最も近い親族ですが、100％同じではありません。</font><font style="vertical-align: inherit;">要素数が2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nに</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等しくない配列を取る場合、違いは明白です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そのような配列の二項分解は、いくつかの理想的なヒープの接続リストを提供します（それぞれのノードの数は2のべき乗です）：</font></font><br>
<br>
<div style="text-align:center;"><img width="484" height="222" src="https://habrastorage.org/webt/k_/o8/zk/k_o8zk8rbi4n25ojy9ijrwh8jre.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合の弱いヒープは、不完全なバイナリツリーになります。</font></font><br>
<br>
<div style="text-align:center;"><img width="691" height="188" src="https://habrastorage.org/webt/eb/7a/-y/eb7a-yq54lycrpazacxsu6ci0em.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
二項山と弱い山は双子の兄弟です。</font><font style="vertical-align: inherit;">DNAは同じですが、外見ではわかりません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">秘密のアルゴリズム</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
弱いヒープが暗号二項ヒープであるとすると、サブツリーをシャッフルすると、簡単な説明が突然見つかります。</font></font><br>
<br>
<div style="text-align:center;"><img width="497" height="199" src="https://habrastorage.org/webt/xa/tb/p7/xatbp7kfjag7awytapkrebfwdxk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒープが弱い場合は、疑似バイナリティンセルを一掃して、ノード間の実際の関係を2項式ヒープスタイルで確認します。</font><font style="vertical-align: inherit;">すべてが明らかになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「弱点」はありません。「すべての親はすべての子孫よりも大きい」という原則が達成および維持される、本格的なソート（非バイナリ）ツリーです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての段階で、子孫を祖先ではなく、直接の親と比較します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子孫と祖先の間の値の交換+子孫内のサブツリーの場所の交換-比率自体（子孫/親）の交換であることがわかります。</font><font style="vertical-align: inherit;">親ノードが子孫よりも値が小さい場合、親自体が子孫になり、子孫が親になります。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは正直な視覚化です：</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/s0/zb/m_/s0zbm_vg9ocfnzzgwhldn70v7he.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のシリーズで</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img align="right" width="396" height="590" src="https://habrastorage.org/webt/ig/xb/3c/igxb3c-v8_la--ej_irmsze7dai.gif"></a><br clear="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次にお話ししたいのは、私のお気に入りのデカルト木です。</font><font style="vertical-align: inherit;">これは単なる束ではなく、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二分探索木で</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もあり</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、最初に、次の記事では、BSTツリーについて興味深い点を明確にする必要があります。</font><font style="vertical-align: inherit;">そして、それから初めて、記事を通して、デカルトの話についてです。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アニメーションをクリックすると、この並べ替えでハバストに切り替わります。</font></font></i><br>
<div style="text-align:center;"><img width="770" height="1" src="https://habrastorage.org/webt/mw/wy/cu/mwwycuqpta7m96dxifyx9if7mu8.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱いヒープ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二項ヒープ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二項</font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/fn/cd/py/fncdpynfktllvkdjtmpif0kd1zc.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒープC ++弱いヒープ実装</font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/pt/js/7k/ptjs7kchs12_zg8dfph-ld6yp_4.gif"> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ronald D. Dutton：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personal Page</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UCF Website Profile </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/yv/lm/2t/yvlm2t2kl5affkpm0hzqh7qw5ly.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weak Heaps and Friends：Recent Developments </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Weak-Heap Data Structure：</font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Varianants and Performance on the Performance of WEAK-HEAPSORT </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adaptive </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">heapsort </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">：ソースコード</font></a></font><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/mp/mv/ie/mpmviex2wi0oknklc_zrg5tgfhe.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Kopeliovich-レクチャーホール-弱い山（48:32から1:16:06まで）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリーズ記事：</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExcelアプリケーションAlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交換ソート</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">挿入ソート</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選択順に並べ替え</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒープの並べ替え：Nピラミッド</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒープソート：レオナルド番号</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒープソート：弱いヒープ</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">束のソート：デカルト木</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その他のヒープの並べ替え：ミラーヒープ、ミニヒープ、ふるいにかける</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒープの並べ替え：チョンヒープ</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マージソート</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分布で並べ替え</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハイブリッドソーティング</font></font></a></li>
</ul><br>
<img align="right" width="349" height="264" src="https://habrastorage.org/webt/kf/cj/xj/kfcjxjqyku6wcl2spe8hqzgefz0.png"><br clear="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日のソートは、それを使用する弱い束によってAlgoLabアプリケーションに追加されます-マクロでExcelファイルを更新します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並べ替えの名前を含むセルへのコメントでは、いくつかの設定を指定できます。</font><font style="vertical-align: inherit;">siftup = 1を設定すると、ソートは最初の段階でフルスクリーニングを使用します（デフォルトではsiftup = 0）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
二項式= 1を指定した場合、ツリーは「二項式ヒープ」になります（デフォルトでは、二項式= 0、つまり、弱いヒープです）。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja499770/index.html">自己分離しながら学ぶ</a></li>
<li><a href="../ja499772/index.html">5Gテクノロジーがどのように広告市場を変えるか</a></li>
<li><a href="../ja499774/index.html">スポーツのない日ではない-2：中国のブレスレットの再プログラミング</a></li>
<li><a href="../ja499776/index.html">MSH言語の実装の機能</a></li>
<li><a href="../ja499784/index.html">仮想壁に触れるものは何ですか？</a></li>
<li><a href="../ja499788/index.html">無料のオンラインコース「ITプロジェクトのテクニカルドキュメント」</a></li>
<li><a href="../ja499792/index.html">負荷テストAtlassian Jira、Confluence、Bitbucketパート1</a></li>
<li><a href="../ja499794/index.html">PostgreSQLとJDBCはすべてのジュースを圧迫します。ウラジミール・シトニコフ</a></li>
<li><a href="../ja499796/index.html">アメリカの裁判所がズームを通じてどのように行われているか、なぜこれが問題と見なされているか</a></li>
<li><a href="../ja499798/index.html">お金を稼ぐための2つのタパス：アゼルバイジャンでカードを即時発行できる金融チャットボットを開発した方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>