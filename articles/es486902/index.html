<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏿 💅🏿 😫 Programación Orientada a Protocolo en Swift 5.1 👴 🍰 👾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los protocolos son una propiedad fundamental de Swift. Desempeñan un papel importante en las bibliotecas estándar de Swift y son una forma común de co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programación Orientada a Protocolo en Swift 5.1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486902/"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los protocolos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son una propiedad fundamental de Swift. </font><font style="vertical-align: inherit;">Desempeñan un papel importante en las bibliotecas estándar de Swift y son una forma común de codificar la abstracción. </font><font style="vertical-align: inherit;">En muchos sentidos, son similares a las </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interfaces</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en otros lenguajes de programación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este tutorial, le presentaremos un enfoque de desarrollo de aplicaciones llamado programación orientada al protocolo, que se ha convertido casi en el núcleo de Swift. </font><font style="vertical-align: inherit;">¡Esto es realmente lo que necesitas entender al aprender Swift! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta guía, usted:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entender la diferencia entre la programación orientada a objetos y la programación orientada a protocolos;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entender las implementaciones de protocolo estándar;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aprenda a ampliar la funcionalidad de la biblioteca Swift estándar;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aprenda a extender protocolos con genéricos.</font></font></li>
</ul><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Empezando</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagina que estás desarrollando un juego de carreras. Sus jugadores pueden conducir automóviles, motocicletas y aviones. E incluso volar sobre pájaros, este es un juego, ¿verdad? Lo principal aquí es que hay una dofiga de todo tipo de "cosas" en las que puedes conducir, volar, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un enfoque común para desarrollar tales aplicaciones es la programación orientada a objetos. En este caso, incluimos toda la lógica en algunas clases base, de las cuales heredamos de allí en adelante. Las clases base, por lo tanto, deben contener la lógica de "líder" y "piloto". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comenzamos el desarrollo creando clases para cada vehículo. Pospondremos a los "Pájaros" hasta más tarde, volveremos a ellos un poco más tarde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vemos que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moto</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muy similar en funcionalidad, por lo que creamos la clase base </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MotorVehicle</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El automóvil y la motocicleta se heredarán de MotorVehicle. Del mismo modo, creamos la clase base de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aeronave</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a partir de la cual crearemos la clase </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plane</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Crees que todo está bien, pero ¡bam! - La acción de tu juego tiene lugar en el siglo XXX, y algunos autos ya pueden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">volar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, tuvimos una mordaza. Swift no tiene herencia múltiple. ¿Cómo se pueden heredar sus autos voladores de MotorVehicle y Aircraft? ¿Crear otra clase base que combine ambas funcionalidades? Lo más probable es que no, ya que no existe una forma clara y sencilla de lograrlo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Y qué salvará nuestro juego en esta terrible situación? </font><font style="vertical-align: inherit;">¡La programación orientada al protocolo tiene prisa por ayudar!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo es la programación orientada al protocolo?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los protocolos le permiten agrupar métodos, funciones y propiedades similares para clases, estructuras y enumeraciones. Sin embargo, solo las clases le permiten usar la herencia de la clase base. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La ventaja de los protocolos en Swift es que un objeto puede ajustarse a múltiples protocolos.</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Al usar este método, su código se vuelve más modular. Piense en los protocolos como bloques de construcción de funcionalidad. Cuando agrega una nueva funcionalidad a un objeto, haciéndolo cumplir con un determinado protocolo, no está creando un objeto completamente nuevo desde cero, sería demasiado largo. En su lugar, agrega diferentes bloques de construcción hasta que el objeto esté listo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pasar de una clase base a protocolos resolverá nuestro problema. </font><font style="vertical-align: inherit;">Con protocolos, podemos crear una clase FlyingCar que coincida tanto con MotorVehicle como con Aircraft. </font><font style="vertical-align: inherit;">Buena, ¿eh?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hagamos el codigo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ejecute Xcode, cree un parque infantil, guárdelo como SwiftProtocols.playground, agregue este código:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Bird</span> </span>{
  <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> }
  <span class="hljs-keyword">var</span> canFly: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Flyable</span> </span>{
  <span class="hljs-keyword">var</span> airspeedVelocity: <span class="hljs-type">Double</span> { <span class="hljs-keyword">get</span> }<font></font>
}</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compile con </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Command-Shift-Return</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para asegurarse de que todo esté en orden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí definimos un protocolo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bird</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simple </font><font style="vertical-align: inherit;">, con el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">las propiedades de canFly</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Luego definimos el protocolo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flyable</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con la propiedad </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">airspeedVelocity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la "era previa al protocolo", el desarrollador comenzaría con la clase Flyable como la clase base, y luego, utilizando la herencia, definiría Bird y todo lo demás que podría volar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero en la programación orientada al protocolo, todo comienza con un protocolo. Esta técnica nos permite encapsular un boceto de un funcional sin una clase base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como verá ahora, esto hace que el proceso de diseño de tipo sea mucho más flexible.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determinar el tipo correspondiente al protocolo.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregue este código en la parte inferior del patio de recreo:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlappyBird</span>: <span class="hljs-title">Bird</span>, <span class="hljs-title">Flyable</span> </span>{
  <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
  <span class="hljs-keyword">let</span> flappyAmplitude: <span class="hljs-type">Double</span>
  <span class="hljs-keyword">let</span> flappyFrequency: <span class="hljs-type">Double</span>
  <span class="hljs-keyword">let</span> canFly = <span class="hljs-literal">true</span><font></font>
<font></font>
  <span class="hljs-keyword">var</span> airspeedVelocity: <span class="hljs-type">Double</span> {
    <span class="hljs-number">3</span> * flappyFrequency * flappyAmplitude<font></font>
  }<font></font>
}</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este código define una nueva estructura </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FlappyBird</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que se ajusta tanto al protocolo Bird como al protocolo Flyable. </font><font style="vertical-align: inherit;">Su propiedad AirspeedVelocity es un trabajo de Flappy Frequency y Flappy Amplitude. </font><font style="vertical-align: inherit;">La propiedad canFly devuelve verdadero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora agregue las definiciones de dos estructuras más:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Penguin</span>: <span class="hljs-title">Bird</span> </span>{
  <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
  <span class="hljs-keyword">let</span> canFly = <span class="hljs-literal">false</span><font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwiftBird</span>: <span class="hljs-title">Bird</span>, <span class="hljs-title">Flyable</span> </span>{
  <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> { <span class="hljs-string">"Swift \(version)"</span> }
  <span class="hljs-keyword">let</span> canFly = <span class="hljs-literal">true</span>
  <span class="hljs-keyword">let</span> version: <span class="hljs-type">Double</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> speedFactor = <span class="hljs-number">1000.0</span><font></font>
  <font></font>
  <span class="hljs-keyword">init</span>(version: <span class="hljs-type">Double</span>) {
    <span class="hljs-keyword">self</span>.version = version<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Swift is FASTER with each version!</span>
  <span class="hljs-keyword">var</span> airspeedVelocity: <span class="hljs-type">Double</span> {<font></font>
    version * speedFactor<font></font>
  }<font></font>
}</code></pre><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penguin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un pájaro pero no puede volar. </font><font style="vertical-align: inherit;">¡Es bueno que no usemos la herencia y no hayamos hecho </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">volar a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> todas las aves </font><font style="vertical-align: inherit;">! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al usar protocolos, usted define los componentes de lo funcional y hace que todos los objetos adecuados se ajusten al protocolo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego definimos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwiftBird</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero en nuestro juego hay varias versiones diferentes. </font><font style="vertical-align: inherit;">Cuanto mayor sea el número de versión, mayor será su </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">velocidad de velocidad aérea</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que se define como una propiedad calculada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, hay algo de redundancia. </font><font style="vertical-align: inherit;">Cada tipo de Bird debe definir una definición explícita de la propiedad canFly, aunque tenemos una definición del protocolo Flyable. </font><font style="vertical-align: inherit;">Parece que necesitamos una forma de determinar la implementación predeterminada de los métodos de protocolo. </font><font style="vertical-align: inherit;">Bueno, hay extensiones de protocolo para esto.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extendiendo el protocolo con comportamiento predeterminado</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las extensiones de protocolo le permiten establecer el comportamiento predeterminado del protocolo. </font><font style="vertical-align: inherit;">Escriba este código inmediatamente después de la definición del protocolo Bird:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Bird</span> </span>{
  <span class="hljs-comment">// Flyable birds can fly!</span>
  <span class="hljs-keyword">var</span> canFly: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">self</span> <span class="hljs-keyword">is</span> <span class="hljs-type">Flyable</span> }<font></font>
}</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este código define la extensión del protocolo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bird</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esta extensión determina que la propiedad </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canFly</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> volverá verdadera cuando el tipo se ajuste al protocolo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flyable</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En otras palabras, cualquier pájaro Flyable ya no necesita establecer explícitamente canFly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora elimine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">let canFly = ...</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de las definiciones de FlappyBird, Penguin y SwiftBird. </font><font style="vertical-align: inherit;">Compile el código y asegúrese de que todo esté en orden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hagamos las transferencias</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las enumeraciones en Swift pueden ajustarse a los protocolos. </font><font style="vertical-align: inherit;">Agregue la siguiente definición de enumeración:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">UnladenSwallow</span>: <span class="hljs-title">Bird</span>, <span class="hljs-title">Flyable</span> </span>{
  <span class="hljs-keyword">case</span> african
  <span class="hljs-keyword">case</span> european
  <span class="hljs-keyword">case</span> unknown<font></font>
  <font></font>
  <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> {
    <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {
    <span class="hljs-keyword">case</span> .african:
      <span class="hljs-keyword">return</span> <span class="hljs-string">"African"</span>
    <span class="hljs-keyword">case</span> .european:
      <span class="hljs-keyword">return</span> <span class="hljs-string">"European"</span>
    <span class="hljs-keyword">case</span> .unknown:
      <span class="hljs-keyword">return</span> <span class="hljs-string">"What do you mean? African or European?"</span><font></font>
    }<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">var</span> airspeedVelocity: <span class="hljs-type">Double</span> {
    <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {
    <span class="hljs-keyword">case</span> .african:
      <span class="hljs-keyword">return</span> <span class="hljs-number">10.0</span>
    <span class="hljs-keyword">case</span> .european:
      <span class="hljs-keyword">return</span> <span class="hljs-number">9.9</span>
    <span class="hljs-keyword">case</span> .unknown:
      <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"You are thrown from the bridge of death!"</span>)<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al definir las propiedades apropiadas, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnladenSwallow se</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ajusta a dos protocolos: Bird y Flyable. </font><font style="vertical-align: inherit;">De esta manera, se implementa la definición predeterminada para canFly.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anular el comportamiento predeterminado</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro tipo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnladenSwallow</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , de acuerdo con el protocolo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bird</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , recibió automáticamente una implementación para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canFly</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sin embargo, necesitamos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnladenSwallow.unknown para</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devolver </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para canFly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregue el siguiente código a continuación:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UnladenSwallow</span> </span>{
  <span class="hljs-keyword">var</span> canFly: <span class="hljs-type">Bool</span> {
    <span class="hljs-keyword">self</span> != .unknown<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora solo .african y .european serán verdaderos para canFly. </font><font style="vertical-align: inherit;">¡Echale un vistazo! </font><font style="vertical-align: inherit;">Agregue el siguiente código en la parte inferior de nuestro patio de recreo:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">UnladenSwallow</span>.unknown.canFly         <span class="hljs-comment">// false</span>
<span class="hljs-type">UnladenSwallow</span>.african.canFly         <span class="hljs-comment">// true</span>
<span class="hljs-type">Penguin</span>(name: <span class="hljs-string">"King Penguin"</span>).canFly  <span class="hljs-comment">// false</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compile el patio de juegos y verifique los valores recibidos con los indicados en los comentarios anteriores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, redefinimos propiedades y métodos de la misma manera que usando métodos virtuales en la programación orientada a objetos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocolo de expansión</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También puede hacer que su propio protocolo se ajuste a otro protocolo de la biblioteca estándar de Swift y definir el comportamiento predeterminado. </font><font style="vertical-align: inherit;">Reemplace la declaración del protocolo Bird con el siguiente código:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Bird</span>: <span class="hljs-title">CustomStringConvertible</span> </span>{
  <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> }
  <span class="hljs-keyword">var</span> canFly: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">CustomStringConvertible</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">Bird</span> </span>{
  <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> {<font></font>
    canFly ? <span class="hljs-string">"I can fly"</span> : <span class="hljs-string">"Guess I'll just sit here :["</span><font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El cumplimiento del protocolo CustomStringConvertible significa que su tipo debe tener una propiedad de descripción. </font><font style="vertical-align: inherit;">En lugar de agregar esta propiedad en el tipo Bird y en todos sus derivados, definimos la extensión de protocolo CustomStringConvertible, que se asociará solo con el tipo Bird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escriba </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnladenSwallow.african</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la parte inferior del patio de recreo. </font><font style="vertical-align: inherit;">Compile y verá "Puedo volar".</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocolos en bibliotecas estándar Swift</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, los protocolos son una forma efectiva de extender y personalizar tipos. </font><font style="vertical-align: inherit;">En la biblioteca estándar de Swift, esta propiedad también se usa ampliamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregue este código al patio de recreo:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>]
<span class="hljs-keyword">let</span> slice = numbers[<span class="hljs-number">1</span>...<span class="hljs-number">3</span>]
<span class="hljs-keyword">let</span> reversedSlice = slice.reversed()<font></font>
<font></font>
<span class="hljs-keyword">let</span> answer = reversedSlice.<span class="hljs-built_in">map</span> { $<span class="hljs-number">0</span> * <span class="hljs-number">10</span> }
<span class="hljs-built_in">print</span>(answer)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablemente sepa qué generará este código, pero puede sorprenderse con los tipos utilizados aquí. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, slice no es Array, sino ArraySlice. </font><font style="vertical-align: inherit;">Este es un "contenedor" especial que proporciona una forma eficiente de trabajar con partes de la matriz. </font><font style="vertical-align: inherit;">En consecuencia, reverseedSlice es una ReversedCollection &lt;ArraySlice&gt;. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afortunadamente, la función de mapa se define como una extensión del protocolo de secuencia, que corresponde a todos los tipos de colección. </font><font style="vertical-align: inherit;">Esto nos permite aplicar la función de mapa a Array y ReversedCollection y no notar la diferencia. </font><font style="vertical-align: inherit;">Pronto aprovecharás este útil truco.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En sus marcas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasta ahora, hemos identificado varios tipos que cumplen con el protocolo Bird. </font><font style="vertical-align: inherit;">Ahora agregaremos algo completamente diferente:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Motorcycle</span> </span>{
  <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) {
    <span class="hljs-keyword">self</span>.name = name<font></font>
    speed = <span class="hljs-number">200.0</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>
  <span class="hljs-keyword">var</span> speed: <span class="hljs-type">Double</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este tipo no tiene nada que ver con pájaros y vuelos. </font><font style="vertical-align: inherit;">Queremos organizar una carrera de motos con pingüinos. </font><font style="vertical-align: inherit;">Es hora de traer esta extraña compañía al comienzo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poniendolo todo junto</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para unir de alguna manera a corredores tan diferentes, necesitamos un protocolo común para competir. </font><font style="vertical-align: inherit;">Podemos hacer todo esto sin siquiera tocar todos los tipos que creamos antes, con la ayuda de algo maravilloso llamado modelado retroactivo. </font><font style="vertical-align: inherit;">Solo agregue esto al patio de recreo:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">// 1</span>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Racer</span> </span>{
  <span class="hljs-keyword">var</span> speed: <span class="hljs-type">Double</span> { <span class="hljs-keyword">get</span> }  <span class="hljs-comment">// speed is the only thing racers care about</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// 2</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">FlappyBird</span>: <span class="hljs-title">Racer</span> </span>{
  <span class="hljs-keyword">var</span> speed: <span class="hljs-type">Double</span> {<font></font>
    airspeedVelocity<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">SwiftBird</span>: <span class="hljs-title">Racer</span> </span>{
  <span class="hljs-keyword">var</span> speed: <span class="hljs-type">Double</span> {<font></font>
    airspeedVelocity<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Penguin</span>: <span class="hljs-title">Racer</span> </span>{
  <span class="hljs-keyword">var</span> speed: <span class="hljs-type">Double</span> {
    <span class="hljs-number">42</span>  <span class="hljs-comment">// full waddle speed</span><font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UnladenSwallow</span>: <span class="hljs-title">Racer</span> </span>{
  <span class="hljs-keyword">var</span> speed: <span class="hljs-type">Double</span> {<font></font>
    canFly ? airspeedVelocity : <span class="hljs-number">0.0</span><font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Motorcycle</span>: <span class="hljs-title">Racer</span> </span>{}<font></font>
<font></font>
<span class="hljs-comment">// 3</span>
<span class="hljs-keyword">let</span> racers: [<span class="hljs-type">Racer</span>] =<font></font>
  [<span class="hljs-type">UnladenSwallow</span>.african,
   <span class="hljs-type">UnladenSwallow</span>.european,
   <span class="hljs-type">UnladenSwallow</span>.unknown,
   <span class="hljs-type">Penguin</span>(name: <span class="hljs-string">"King Penguin"</span>),
   <span class="hljs-type">SwiftBird</span>(version: <span class="hljs-number">5.1</span>),
   <span class="hljs-type">FlappyBird</span>(name: <span class="hljs-string">"Felipe"</span>, flappyAmplitude: <span class="hljs-number">3.0</span>, flappyFrequency: <span class="hljs-number">20.0</span>),
   <span class="hljs-type">Motorcycle</span>(name: <span class="hljs-string">"Giacomo"</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es lo que hacemos aquí: primero, defina el protocolo Racer. </font><font style="vertical-align: inherit;">Esto es todo lo que puede participar en las carreras. </font><font style="vertical-align: inherit;">Luego lanzamos todos nuestros tipos creados previamente al protocolo Racer. </font><font style="vertical-align: inherit;">Y finalmente, creamos una matriz que contiene instancias de cada uno de nuestro tipo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compile el patio de juegos para que todo esté en orden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Velocidad máxima</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escribimos una función para determinar la velocidad máxima de los corredores. </font><font style="vertical-align: inherit;">Agregue este código al final del patio de recreo:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topSpeed</span><span class="hljs-params">(of racers: [Racer])</span></span> -&gt; <span class="hljs-type">Double</span> {<font></font>
  racers.<span class="hljs-built_in">max</span>(by: { $<span class="hljs-number">0</span>.speed &lt; $<span class="hljs-number">1</span>.speed })?.speed ?? <span class="hljs-number">0.0</span><font></font>
}<font></font>
<font></font>
topSpeed(of: racers) <span class="hljs-comment">// 5100</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí usamos la función max para encontrar al piloto a la velocidad máxima y devolverlo. </font><font style="vertical-align: inherit;">Si la matriz está vacía, se devuelve 0.0.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacer la función más general</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que la matriz Racers es lo suficientemente grande y necesitamos encontrar la velocidad máxima no en toda la matriz, sino en alguna parte de ella. </font><font style="vertical-align: inherit;">La solución es cambiar topSpeed ​​(of :) para que tome como argumento no específicamente una matriz, sino todo lo que se ajuste al protocolo de secuencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reemplace nuestra implementación de topSpeed ​​(de :) de la siguiente manera:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">// 1</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topSpeed</span>&lt;RacersType: Sequence&gt;<span class="hljs-params">(of racers: RacersType)</span></span> -&gt; <span class="hljs-type">Double</span>
    <span class="hljs-comment">/*2*/</span> <span class="hljs-keyword">where</span> <span class="hljs-type">RacersType</span>.<span class="hljs-type">Iterator</span>.<span class="hljs-type">Element</span> == <span class="hljs-type">Racer</span> {
  <span class="hljs-comment">// 3</span>
  racers.<span class="hljs-built_in">max</span>(by: { $<span class="hljs-number">0</span>.speed &lt; $<span class="hljs-number">1</span>.speed })?.speed ?? <span class="hljs-number">0.0</span>
}</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RacersType es el tipo de argumento genérico de nuestra función. </font><font style="vertical-align: inherit;">Puede ser cualquier cosa que se ajuste al protocolo de secuencia.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donde determina que el contenido de la secuencia debe cumplir con el protocolo Racer.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El cuerpo de la función en sí permanece sin cambios.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verifique agregando esto al final de nuestro patio de recreo:</font></font><br>
<br>
<pre><code class="swift hljs">topSpeed(of: racers[<span class="hljs-number">1</span>...<span class="hljs-number">3</span>]) <span class="hljs-comment">// 42</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora nuestra función funciona con cualquier tipo que cumpla con el protocolo de secuencia, incluido ArraySlice.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacer la función más "rápida"</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secreto: puedes hacerlo aún mejor. </font><font style="vertical-align: inherit;">Agregue esto en la parte inferior:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Sequence</span> <span class="hljs-title">where</span> <span class="hljs-title">Iterator</span>.<span class="hljs-title">Element</span> == <span class="hljs-title">Racer</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topSpeed</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Double</span> {
    <span class="hljs-keyword">self</span>.<span class="hljs-built_in">max</span>(by: { $<span class="hljs-number">0</span>.speed &lt; $<span class="hljs-number">1</span>.speed })?.speed ?? <span class="hljs-number">0.0</span><font></font>
  }<font></font>
}<font></font>
<font></font>
racers.topSpeed()        <span class="hljs-comment">// 5100</span>
racers[<span class="hljs-number">1</span>...<span class="hljs-number">3</span>].topSpeed() <span class="hljs-comment">// 42</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y ahora hemos expandido el protocolo de secuencia con topSpeed ​​(). </font><font style="vertical-align: inherit;">Solo es aplicable cuando Sequence contiene el tipo Racer.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparadores de protocolos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra característica de los protocolos Swift es cómo define los operadores de igualdad de los objetos o su comparación. </font><font style="vertical-align: inherit;">Escribimos lo siguiente:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Score</span> </span>{
  <span class="hljs-keyword">var</span> value: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RacingScore</span>: <span class="hljs-title">Score</span> </span>{
  <span class="hljs-keyword">let</span> value: <span class="hljs-type">Int</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con el protocolo Score, puede escribir código que trate todos los elementos de este tipo de una manera. Pero si obtiene un tipo muy específico, como RacingScore, no lo confundirá con otros derivados del protocolo Score. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Queremos comparar los puntajes para ver quién tiene el puntaje más alto. Antes de Swift 3, los desarrolladores necesitaban escribir funciones globales para definir un operador para un protocolo. Ahora podemos definir estos métodos estáticos en el modelo mismo. Hacemos esto reemplazando las definiciones de Score y RacingScore de la siguiente manera:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Score</span>: <span class="hljs-title">Comparable</span> </span>{
  <span class="hljs-keyword">var</span> value: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RacingScore</span>: <span class="hljs-title">Score</span> </span>{
  <span class="hljs-keyword">let</span> value: <span class="hljs-type">Int</span><font></font>
  <font></font>
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> &lt;(lhs: RacingScore, rhs: RacingScore) -&gt; <span class="hljs-title">Bool</span> </span>{<font></font>
    lhs.value &lt; rhs.value<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos toda la lógica para RacingScore en un solo lugar. </font><font style="vertical-align: inherit;">El protocolo comparable requiere que defina una implementación solo para la función menor que. </font><font style="vertical-align: inherit;">Todas las demás funciones de comparación se implementarán automáticamente, en función de la implementación de la función "menor que" que creamos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pruebas:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">RacingScore</span>(value: <span class="hljs-number">150</span>) &gt;= <span class="hljs-type">RacingScore</span>(value: <span class="hljs-number">130</span>) <span class="hljs-comment">// true</span></code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacer cambios al objeto</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasta ahora, cada ejemplo ha demostrado cómo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funcionalidad. </font><font style="vertical-align: inherit;">Pero, ¿qué </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pasa</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si queremos hacer un protocolo que </font><b><font style="vertical-align: inherit;">cambie</font></b><font style="vertical-align: inherit;"> algo </font><font style="vertical-align: inherit;">en un objeto? </font><font style="vertical-align: inherit;">Esto se puede hacer usando </font><font style="vertical-align: inherit;">métodos de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mutación</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en nuestro protocolo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregar un nuevo protocolo:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Cheat</span> </span>{
  <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">boost</span><span class="hljs-params">(<span class="hljs-number">_</span> power: Double)</span></span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí definimos un protocolo que nos permite hacer trampa. </font><font style="vertical-align: inherit;">¿Cómo? </font><font style="vertical-align: inherit;">Cambiando arbitrariamente el contenido de boost. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora cree una extensión SwiftBird que se ajuste al protocolo Cheat:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">SwiftBird</span>: <span class="hljs-title">Cheat</span> </span>{
  <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">boost</span><span class="hljs-params">(<span class="hljs-number">_</span> power: Double)</span></span> {<font></font>
    speedFactor += power<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí implementamos la función boost (_ :), aumentando el speedFactor por el valor transmitido. </font><font style="vertical-align: inherit;">La </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">palabra clave mutante</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hace que la estructura comprenda que uno de sus valores será cambiado por esta función. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Echale un vistazo!</font></font><br>
<pre><code class="swift hljs"><span class="hljs-keyword">var</span> swiftBird = <span class="hljs-type">SwiftBird</span>(version: <span class="hljs-number">5.0</span>)<font></font>
swiftBird.boost(<span class="hljs-number">3.0</span>)<font></font>
swiftBird.airspeedVelocity <span class="hljs-comment">// 5015</span>
swiftBird.boost(<span class="hljs-number">3.0</span>)<font></font>
swiftBird.airspeedVelocity <span class="hljs-comment">// 5030</span></code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede descargar el código fuente completo para el patio de recreo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aprendió sobre las posibilidades de la programación orientada a protocolos creando protocolos simples y aumentando sus capacidades con la ayuda de extensiones. Usando la implementación predeterminada, le da a los protocolos el "comportamiento" apropiado. Casi como con las clases base, pero solo mejor, ya que todo esto también se aplica a estructuras y enumeraciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También vio que la extensión del protocolo se aplica a los protocolos Swift subyacentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí encontrará la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guía de protocolo oficial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También puede ver una excelente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conferencia de WWDC sobre</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> programación orientada </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">a</font></a><font style="vertical-align: inherit;"> protocolos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como con cualquier paradigma de programación, existe el peligro de dejarse llevar y comenzar a usar los protocolos de izquierda y derecha. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí hay una nota interesante</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre los peligros de las decisiones de estilo bala de plata.</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es486884/index.html">La compañía farmacéutica japonesa comienza a probar drogas sintetizadas usando una red neuronal</a></li>
<li><a href="../es486888/index.html">El libro "Enfoque orientado a objetos. 5to int. ed. "</a></li>
<li><a href="../es486890/index.html">Autodesarrollo: cómo no me senté en dos sillas y encontré un tercero</a></li>
<li><a href="../es486892/index.html">Contact Picker API, o cómo compartir sus contactos con un navegador</a></li>
<li><a href="../es486896/index.html">Autorización UID y Stalker en el MAG250</a></li>
<li><a href="../es486904/index.html">Mostrar a los desarrolladores el estado del control de calidad del código fuente en SonarQube</a></li>
<li><a href="../es486908/index.html">Wulfric Ransomware es un criptor que no existe</a></li>
<li><a href="../es486912/index.html">Lowkiq. ¿Por qué lo hicimos?</a></li>
<li><a href="../es486914/index.html">8. Fortinet Getting Started v6.0. Trabajar con los usuarios</a></li>
<li><a href="../es486918/index.html">Emacs - 6 trucos de productividad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>