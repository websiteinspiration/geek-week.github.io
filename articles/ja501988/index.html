<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏾 🔹 🕝 VKメッセージ画面はどのようにレンダリングされますか？ 🗜️ 🤑 ⏺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="レンダリングラグを減らすためにVKは何をしていますか？非常に大きなメッセージを表示してUiThreadを強制終了しない方法は？RecyclerViewでのスクロール遅延を減らす方法は？
 
 
 
 私の経験は、VK Androidアプリケーションでメッセージ画面を描画する作業に基づいています。UI...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>VKメッセージ画面はどのようにレンダリングされますか？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/501988/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリングラグを減らすためにVKは何をしていますか？</font><font style="vertical-align: inherit;">非常に大きなメッセージを表示してUiThreadを強制終了しない方法は？</font><font style="vertical-align: inherit;">RecyclerViewでのスクロール遅延を減らす方法は？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vs/2s/jg/vs2sjg1iyfq7cdkohrmgpuy5mla.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の経験は、VK Androidアプリケーションでメッセージ画面を描画する作業に基づいています。UIでは、最小限のブレーキで大量の情報を表示する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はほぼ10年間Androidのプログラミングをしてきましたが、以前はPHP / Node.jsのフリーランスでした。</font><font style="vertical-align: inherit;">今-シニアAndroid開発者VKontakte。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カットの下-メビウス2019モスクワ会議からの私のレポートのビデオと筆記録。</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GZkTwgetUWI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レポートは3つのトピックを明らかにします</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準ソリューションは、VKメッセージ画面が機能する方法の基本原則です。 </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非標準のソリューションは、あまり知られていないか、UIラグを最小化できるオリジナルのソリューションです。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代替案は、さまざまなライブラリと実装、およびVK開発者がそれらを使用しなかった理由に関するものです。</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面を見てください：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/he/h2/xj/heh2xjq-ij5pnzsu49cf11uuabu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメッセージは5つの画面のどこかにあります。</font><font style="vertical-align: inherit;">そして、彼らは私たちと一緒にいるかもしれません（メッセージを転送する場合）。</font><font style="vertical-align: inherit;">標準ツールは機能しなくなります。</font><font style="vertical-align: inherit;">トップデバイスであっても、すべてが遅れることがあります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これに加えて、UI自体は非常に多様です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">日付とインジケーターの読み込み</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスメッセージ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テキスト（絵文字、リンク、メール、ハッシュタグ）、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボットキーボード</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添付ファイルを表示する40の方法、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">転送されたメッセージのツリー。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題が発生します：ラグの数を可能な限り小さくするには？</font><font style="vertical-align: inherit;">単純なメッセージの場合とバルクメッセージの場合（上のビデオのエッジケース）の両方。</font></font><br>
<a name="ordinary"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準ソリューション</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecyclerViewとそのアドオン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RecyclerViewにはさまざまなアドオンがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setHasFixedSize（</font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの人は、リストアイテムが同じサイズの場合にこのフラグが必要であると考えています。</font><font style="vertical-align: inherit;">しかし、実際には、ドキュメントで判断すると、その逆が当てはまります。</font><font style="vertical-align: inherit;">これは、RecyclerViewのサイズが一定で、要素に依存しない場合です（大まかに、wrap_contentではありません）。</font><font style="vertical-align: inherit;">フラグを設定すると、RecyclerViewの速度がわずかに向上し、不要な計算が回避されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setNestedScrollingEnabled（</font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NestedScrollサポートを無効にするマイナーな最適化。</font><font style="vertical-align: inherit;">この画面では、NestedScrollに応じてCollapsingToolbarやその他の機能がないため、このフラグを安全にfalseに設定できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setItemViewCacheSize（</font></font><code>cache_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部RecyclerViewキャッシュを設定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの人は、RecyclerViewの仕組みは次のとおりだと考えています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面にViewHolderが表示されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewHolderを格納するRecycledViewPoolがあります。</font></font></li>
<li> ViewHolder    —    RecycledViewPool.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、これら2つの間に中間キャッシュがあるため、すべてが少し複雑になります。</font><font style="vertical-align: inherit;">これは、ItemViewCacheと呼ばれます。</font><font style="vertical-align: inherit;">その本質は何ですか？</font><font style="vertical-align: inherit;">ViewHolderが画面を離れると、RecycledViewPoolではなく中間キャッシュ（ItemViewCache）に配置されます。</font><font style="vertical-align: inherit;">アダプターのすべての変更は、表示されているViewHolderとItemViewCache内のViewHolderの両方に適用されます。</font><font style="vertical-align: inherit;">また、RecycledViewPool内のViewHolderの場合、変更は適用されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
setItemViewCacheSizeを使用して、この中間キャッシュのサイズを設定できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大きいほど、スクロールが短距離で速くなりますが、更新操作には時間がかかります（ViewHolder.onBindなどにより）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RecyclerViewの実装方法とそのキャッシュの構造は、かなり大きくて複雑なトピックです。</font><font style="vertical-align: inherit;">あなたは素晴らしい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">記事</font></a><font style="vertical-align: inherit;">を読むことができます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すべてについて詳細に話します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化OnCreate / OnBind</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の古典的なソリューションは、onCreateViewHolder / onBindViewHolderを最適化することです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単なレイアウト（可能な限りFrameLayoutまたはカスタムViewGroupを使用するようにします）、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重い操作（リンク/絵文字の解析）は、メッセージのロードの段階で非同期に行われます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前、日付などをフォーマットするためのStringBuilder</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの方法の作業時間を短縮するその他のソリューション。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トラッキングAdapter.onFailedToRecyclerView（）</font></font></h3><br>
<img src="https://habrastorage.org/webt/8l/eo/1n/8leo1nki7gxrit4wg8mhhv0q3ua.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの要素（またはその一部）がアルファでアニメーション化されたリストがあります。</font><font style="vertical-align: inherit;">アニメーションの処理中にビューが画面を離れた時点では、RecycledViewPoolには移動しません。</font><font style="vertical-align: inherit;">どうして？</font><font style="vertical-align: inherit;">RecycledViewPoolは、ビューがView.hasTransientStateフラグによってアニメーション化されていることを確認し、単に無視します。</font><font style="vertical-align: inherit;">したがって、次に上下にスクロールしたときに、画像はRecycledViewPoolから取得されず、新しく作成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も正しい決定は、ViewHolderが画面を離れたときに、すべてのアニメーションをキャンセルする必要があることです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-7/1r/rh/-71rrhbw5idwburnf60gtfllcau.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
できるだけ早く修正プログラムが必要な場合、または開発者が遅延している場合は、onFailedToRecycleメソッドで常にtrueを返すだけですべてが機能しますが、そうすることはお勧めしません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/se/ha/iusehamefbgzcvc6miixbtfmfoy.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーバードローとプロファイラーの追跡</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題を検出する古典的な方法は、オーバードローとプロファイラー追跡です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーバードロー-ピクセルの再描画回数：レイヤーが少なく、ピクセルの再描画が少ないほど、高速です。しかし、私の観察によれば、現代の現実では、これはパフォーマンスにそれほど影響しません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0h/-d/fh/0h-dfhogberhs_hsy1eseaexkwa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロファイラー-別名Androidモニター。これはAndroid Studioにあります。その中で、呼び出されたすべてのメソッドを分析できます。たとえば、メッセージを開き、上下にスクロールして、呼び出されたメソッドとそれらにかかった時間を確認します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dz/la/wy/dzlawyqmpqtzxbnpcbezvfoq_ww.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左半分にあるのは、View / ViewHolderの作成/レンダリングに必要なAndroidシステムコールだけです。それらに影響を与えることができないか、多くの努力を費やす必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右半分は、ViewHolderで実行されるコードです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
番号1の呼び出しブロックは、正規表現の呼び出しです。見落としがあり、操作をバックグラウンドスレッドに転送するのを忘れたため、スクロールが約20％遅くなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
番号2のブロックを呼び出す-フレスコ、画像を表示するためのライブラリ。</font><font style="vertical-align: inherit;">一部の地域では最適ではありませんが、このラグの処理方法はまだ明確ではありませんが、それを解決できれば、さらに15％節約できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、これらの問題を修正すると、約35％の増加が得られ、これはかなりクールです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">差分</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの人がDiffUtilを標準形式で使用しています。変更の呼び出し、比較、プッシュの2つのリストがあります。このすべてをメインスレッドで実行すると、リストが非常に大きくなる可能性があるため、少しコストがかかります。そのため、通常、DiffUtilの計算はバックグラウンドスレッドで実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListAdapterとAsyncListDifferがこれを行います。 ListAdapterは通常のアダプタを拡張し、すべてを非同期で開始します。submitListを作成すると、変更の計算全体が内部のバックグラウンドスレッドに飛んでいきます。 ListAdapterは、頻繁な更新の場合を考慮に入れることができます。連続して3回呼び出すと、最後の結果のみが取得されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DiffUtil自体は、一部の構造変更（メッセージの外観、変更、削除）にのみ使用します。</font><font style="vertical-align: inherit;">一部のクイックチェンジデータには適していません。</font><font style="vertical-align: inherit;">たとえば、写真をアップロードしたり、オーディオを再生したりする場合です。</font><font style="vertical-align: inherit;">このようなイベントは頻繁に発生します-1秒間に数回、毎回DiffUtilを実行すると、多くの追加作業が発生します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アニメーション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
むかしむかし、アニメーションフレームワークがありました。</font><font style="vertical-align: inherit;">私たちは次のように彼と協力しました：</font></font><br>
<br>
<pre><code class="java hljs">view.startAnimation(TranslateAnimation(fromX = <span class="hljs-number">0</span>, toX = <span class="hljs-number">300</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、アニメーションの前後でgetTranslationX（）パラメータが同じ値を返すことです。</font><font style="vertical-align: inherit;">これは、アニメーションが視覚的表現を変更したが、物理的プロパティは変更しなかったためです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f0/uu/tw/f0uutwhihhopkcfvps8itszyt_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android 3.0では、Animatorフレームワークが登場しました。これは、オブジェクトの特定の物理プロパティを変更したため、より正確です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/q2/ib/qy/q2ibqywrlcla5cxqpslznxbxxm0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、ViewPropertyAnimatorが登場しましたが、まだ誰もがAnimatorとの違いを理解していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明します。</font><font style="vertical-align: inherit;">平行移動を行う必要があるとしましょう-ビューをx、y軸に沿ってシフトします。</font><font style="vertical-align: inherit;">おそらくあなたは典型的なコードを書くでしょう：</font></font><br>
<br>
<pre><code class="java hljs">val animX = ObjectAnimator.ofFloat(view, “translationX”, <span class="hljs-number">100f</span>)<font></font>
val animY = ObjectAnimator.ofFloat(view, “translationY”, <span class="hljs-number">200f</span>)<font></font>
AnimatorSet().apply {<font></font>
    playTogether(animX, animY)<font></font>
    start()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、あなたはそれを短くすることができます：</font></font><br>
<br>
<pre><code class="java hljs">view.animate().translationX(<span class="hljs-number">100f</span>).translationY(<span class="hljs-number">200f</span>) </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
view.animate（）を実行すると、暗黙的にViewPropertyAnimatorが起動されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜそれが必要なのですか？</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードの読み取りと保守が容易になります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッチ操作のアニメーション。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のケースでは、2つのプロパティを変更しました。アニメーターを介してこれを行うと、アニメーションティックは各アニメーターに対して個別に呼び出されます。つまり、setTranslationXとsetTranslationYは別々に呼び出され、Viewは更新操作を別々に実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ViewPropertyAnimatorの場合、変更は同時に発生するため、操作が少ないため節約され、プロパティの変更自体が最適化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはAnimatorで実現できますが、さらにコードを記述する必要があります。</font><font style="vertical-align: inherit;">さらに、ViewPropertyAnimatorを使用すると、アニメーションが可能な限り最適化されることを確認できます。</font><font style="vertical-align: inherit;">どうして？</font><font style="vertical-align: inherit;">AndroidにはRenderNode（DisplayList）があります。</font><font style="vertical-align: inherit;">非常に大まかに言って、onDrawの結果をキャッシュし、それを再描画時に使用します。</font><font style="vertical-align: inherit;">ViewPropertyAnimatorは、RenderNodeと直接連携してアニメーションを適用し、onDraw呼び出しを回避します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viewプロパティの多くは、RenderNodeに直接影響することもありますが、すべてに影響するわけではありません。</font><font style="vertical-align: inherit;">つまり、ViewPropertyAnimatorを使用すると、最も効率的な方法を使用できることが保証されます。</font><font style="vertical-align: inherit;">ViewPropertyAnimatorでは実行できないアニメーションが突然発生した場合は、それについて考えて変更する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アニメーション：TransitionManager</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、このフレームワークは、あるアクティビティから別のアクティビティに移動するために使用されると人々は言います。実際、これは異なる方法で使用でき、構造のアニメーション変更の実装を大幅に簡素化します。音声メッセージが再生される画面があるとします。十字でそれを閉じ、ダイスが上がります。どうやってするの？アニメーションは非常に複雑です。プレーヤーは、移動せずに移動しながらアルファで閉じますが、高さを変更します。同時に、リストが上がり、高さも変わります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mv/ff/kh/mvffkhe5udzkypeumimmusvhiig.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレーヤーがリストに含まれている場合、アニメーションは非常に単純になります。しかし、私たちにとって、プレーヤーはリストの要素ではなく、完全に独立したビューです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、ある種のAnimatorの作成を開始すると、問題が発生し、クラッシュし、松葉杖の切断が始まり、コードが2倍になります。</font><font style="vertical-align: inherit;">そして、下の画面のようなものを取得します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/0d/k-/wd0dk-urz2lfr6xugvvpmp16rdk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TransitionManagerを使用すると、すべてを簡単にすることができます。</font></font><br>
<br>
<pre><code class="java hljs">TransitionManager.beginDelayedTransition(<font></font>
        viewGroup = &lt;LinearLayoutManager&gt;,<font></font>
        transition = AutoTransition())<font></font>
playerView.visibility = View.GONE</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのアニメーションは自動的に内部で行われます。</font><font style="vertical-align: inherit;">魔法のように見えますが、内部を深く調べてその動作を確認すると、TransitionManagerがすべてのビューをサブスクライブし、プロパティの変更をキャッチし、diffを計算し、必要に応じて必要なアニメーターまたはViewPropertyAnimatorを作成し、可能な限りすべてを効率的に行うことがわかります。</font><font style="vertical-align: inherit;">TransitionManagerを使用すると、メッセージセクションのアニメーションをすばやく簡単に実装できます。</font></font><a name="extrodinary"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カスタムソリューション</font></font></h2><br>
<img src="https://habrastorage.org/webt/u2/rx/ji/u2rxjicmid-zkuhvqsxc4kxbeem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、パフォーマンスとそれに続く問題の基礎となる最も基本的なものです。メッセージが10画面にある場合はどうしますか？あなたが注意を払うなら、私たちのすべての要素はお互いの真下に位置しています。 ViewHolderが1つのメッセージではなく、数十の異なるViewHolderであることを受け入れると、すべてがはるかに簡単になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージが10画面になったことは問題ではありません。具体例では6つのViewHolderのみが表示されているからです。レイアウトが簡単で、コードのメンテナンスが簡単で、1つを除いて特別な問題はありません-これを行う方法は？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/gh/ui/hoghuifbuntyzu3uszyjr6vij_0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンプルなViewHoldersがあります-これらは、古典的な日付セパレーター、さらに読み込むなどです。</font><font style="vertical-align: inherit;">そして、BaseViewHolder-メッセージの条件付きで基本的なViewHolder。</font><font style="vertical-align: inherit;">基本的な実装と、TextViewHolder、PhotoViewHolder、AudioViewHolder、ReplyViewHolderなどの特定の実装があります。</font><font style="vertical-align: inherit;">それらの約70があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BaseViewHolderは何を担当しますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BaseViewHolderは、転送されたメッセージのラインと同様に、アバターと目的のバブルの一部を描画することのみを担当します-左から青。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/yh/ia/6oyhiaag8f94wm6s69vskpv6r4u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテンツの具体的な実装は、他のBaseViewHolderの継承者によって既に実行されています。TextViewHolderはテキスト、FwdSenderViewHolder-転送されたメッセージの作成者、AudioMsgViewHolder-音声メッセージなどを表示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/th/wi/sdthwihnbm9jm4xehrbh4mmrv20.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題があります：幅をどうするか？少なくとも2つの画面のメッセージを想像してください。設定する幅は明確ではありません。半分が表示され、半分が表示されないためです（まだ作成されていません）。それが産むので、絶対にすべてを測定することはできません。残念ながら、私は少し松葉杖を使わなければなりません。メッセージが非常に単純な場合があります：純粋にテキストまたは音声-通常、1つのアイテムで構成されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_q/i0/ov/_qi0ovd7qibtvqzcya0tzv_o4vq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、従来のwrap_contentを使用します。</font><font style="vertical-align: inherit;">複雑なケースでは、メッセージが複数のピースで構成される場合、各ViewHolderを固定幅にして強制します。</font><font style="vertical-align: inherit;">具体的にはここ-220 dp。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fa/5t/yifa5tx6chfyxf2c26zeak-kaeu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テキストが非常に短く、メッセージが転送される場合、右側に空のスペースがあります。</font><font style="vertical-align: inherit;">パフォーマンスがより重要であるため、これからの脱出はありません。</font><font style="vertical-align: inherit;">数年間、不満はありませんでした-誰かが気づいたかもしれませんが、一般的に、誰もがそれに慣れました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/mz/0l/qbmz0lzz-o_lvhongodanb3fh1m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エッジケースがあります。</font><font style="vertical-align: inherit;">メッセージにステッカーで応答する場合、そのような場合に幅を指定して、見栄えをよくすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージのロード段階でViewHoldersに分割します。メッセージのバックグラウンドロードを開始し、アイテムに変換すると、ViewHoldersに直接表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/12/w_/x7/12w_x7wp4a4a4s5f_dqeqrevlbc.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバルRecycledViewPool</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのメッセンジャーを使用するメカニズムは、人々が同じチャットに座っているのではなく、常にそれらの間を行き来するようなものです。</font><font style="vertical-align: inherit;">標準的なアプローチでは、チャットを開始してチャットを終了すると、RecycledViewPool（およびその中のViewHolder）は単純に破棄され、リソースを使用するたびにViewHolderが作成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはグローバルRecycledViewPoolで解決できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションのフレームワーク内では、RecycledViewPoolはシングルトンとして存在します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーが画面間を移動するときにメッセージ画面で再利用されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecyclerView.setRecycledViewPool（プール）として設定します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
落とし穴があります。2つのことを覚えておくことが重要です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面に戻り、戻るをクリックして終了します。</font><font style="vertical-align: inherit;">問題は、画面に表示されていたViewHolderが破棄され、プールに戻されないことです。</font><font style="vertical-align: inherit;">これは次のように修正されています。</font></font><br>
<pre><code class="java hljs">LinearLayoutManager.recycleChildrenOnDetach = <span class="hljs-keyword">true</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecycledViewPoolには制限があります。各ViewTypeに保存できるViewHolderは5つまでです。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9つのTextViewが画面に表示されている場合、5つのアイテムのみがRecycledViewPoolに返され、残りは破棄されます。</font><font style="vertical-align: inherit;">RecycledViewPoolのサイズは変更できます：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RecycledViewPool.setMaxRecycledViews（viewType、size）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、RecycledViewPoolを記述して標準のものを拡張し、それをNoLimitにすることができるので、手で各ViewTypeを処方するのは少し悲しいです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">により、</font><font style="vertical-align: inherit;">完成した実装をダウンロードできます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DiffUtilは常に役立つとは限りません</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが古典的なケースです-オーディオトラックとボイスメッセージをダウンロードして再生します。</font><font style="vertical-align: inherit;">この場合、DiffUtilはスパムを呼び出します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/3o/lt/ho3oltgo6763hgc65xxel-ccopa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BaseViewHolderには、抽象的なupdateUploadProgressメソッドがあります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseViewHolder</span> : <span class="hljs-title">ViewHolder</span> </span>{<font></font>
    …<font></font>
    <span class="hljs-function">fun <span class="hljs-title">updateUploadProgress</span><span class="hljs-params">(attachId: Int, progress: Float)</span>
    …        
}
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントをスローするには、表示されているすべてのViewHolderをバイパスする必要があります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">fun <span class="hljs-title">onUploadProgress</span><span class="hljs-params">(attachId: Int, progress: Float)</span> </span>{<font></font>
    forEachActiveViewHolder {<font></font>
        it.updateUploadProgress(attachId, progress)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは簡単な操作であり、画面に10個を超えるViewHolderが表示されることはほとんどありません。</font><font style="vertical-align: inherit;">このようなアプローチは原則として遅れることはありません。</font><font style="vertical-align: inherit;">可視のViewHolderを見つける方法は？</font><font style="vertical-align: inherit;">素朴な実装は次のようなものです：</font></font><br>
<br>
<pre><code class="java hljs">val firstVisiblePosition = &lt;...&gt;<font></font>
val lastVisiblePosition = &lt;...&gt;<font></font>
<span class="hljs-keyword">for</span> (i in firstVisiblePosition.. lastVisiblePosition) {<font></font>
    val viewHolder = recycler.View.findViewHolderForAdapterPosition(i)<font></font>
    viewHolder.updateUploadProgress(..)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、問題があります。</font><font style="vertical-align: inherit;">前述の中間キャッシュであるItemViewCacheには、単に画面に表示されないアクティブなViewHolderが含まれています。</font><font style="vertical-align: inherit;">上記のコードはそれらに影響を与えません。</font><font style="vertical-align: inherit;">直接、私たちもそれらに対処することはできません。</font><font style="vertical-align: inherit;">そして松葉杖が私たちを助けに来ます。</font><font style="vertical-align: inherit;">ViewHolderへのリンクを格納するWeakSetを作成します。</font><font style="vertical-align: inherit;">さらに、このWeakSetをバイパスするだけで十分です。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> : <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span> </span>{<font></font>
    val activeViewHolders = WeakSet&lt;ViewHolder&gt;()<font></font>
        <font></font>
    <span class="hljs-function">fun <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: ViewHolder, position: Int)</span> </span>{<font></font>
        activeViewHolders.add(holder)<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">fun <span class="hljs-title">onViewRecycled</span><span class="hljs-params">(holder: ViewHolder)</span> </span>{<font></font>
        activeViewHolders.remove(holder)<font></font>
    }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewHolderオーバーレイ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
物語の例を考えてみましょう。以前は、ステッカーでストーリーに反応すると、</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rc/kd/z1/rckdz16ebmfwftxzfpql2lwmsko.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の</font><font style="vertical-align: inherit;">ように表示されました</font><font style="vertical-align: inherit;">。ストーリーは明るい内容で、小さな広場があるので、もっと上手くやりたかったのです。次のようなものを取得したいと思いました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vj/ma/51/vjma51z9m4eqwlhiagc7xvu2kg0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題があります。メッセージがViewHolderに分割され、メッセージは互いに厳密に下に配置されていますが、ここでは重複しています。すぐにこれを解決する方法は明らかではありません。別のViewType「履歴+ステッカー」または「履歴+ボイスメッセージ」を作成できます。したがって、70のViewTypeではなく、140を使用します。いいえ、もっと便利なものを考え出す必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/01/mr/5j/01mr5jqsfdpq_zcq4s3b-vf9pyq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Androidでお気に入りの松葉杖が思い浮かびます。</font><font style="vertical-align: inherit;">たとえば、私たちは何かをしていましたが、Pixel Perfectは収束しません。</font><font style="vertical-align: inherit;">これを修正するには、すべてを削除してゼロから書き込む必要がありますが、怠惰です。</font><font style="vertical-align: inherit;">その結果、margin = -2dp（負）にすることができ、すべてが適切に配置されます。</font><font style="vertical-align: inherit;">しかし、ここではそのようなアプローチは使用できません。</font><font style="vertical-align: inherit;">負のマージンを設定すると、ステッカーは移動しますが、ステッカーが占めていた場所は空のままになります。</font><font style="vertical-align: inherit;">しかし、ItemDecorationがあり、itemOffsetで負の数を作成できます。</font><font style="vertical-align: inherit;">そしてそれはうまくいきます！</font><font style="vertical-align: inherit;">その結果、期待されるオーバーレイが得られると同時に、各ViewHolderが友だちであるというパラダイムが残ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1行で美しいソリューション。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OffsetItemDecoration</span> : <span class="hljs-title">RecyclerViewItemDecoration</span>() </span>{
    <span class="hljs-function">overrride fun <span class="hljs-title">getItemOffsets</span><span class="hljs-params">(offset: Rect, …)</span> </span>{<font></font>
        offset.top = -<span class="hljs-number">100</span>dp<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイドルハンドラー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはアスタリスクの場合であり、複雑であり、実際にはあまり必要ありませんが、そのようなメソッドの存在を知ることは重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、メインのUiThreadスレッドがどのように機能するかを説明します。一般的なスキーム：handler.postを介してタスクが設定されるタスクイベントキューと、このキューを通過する無限ループがあります。つまり、UiThreadはちょうど（真）です。タスクがある場合は実行し、ない場合は表示されるまで待ちます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y3/ee/nn/y3eennjezxs29i4lkbvggnqkgjw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの通常の現実では、ハンドラーはタスクをキューに入れる責任があり、ルーパーは無限にキューをバイパスします。</font><font style="vertical-align: inherit;">UIにとってそれほど重要ではないタスクがあります。</font><font style="vertical-align: inherit;">たとえば、ユーザーがメッセージを読んだ場合-今すぐまたは20ミリ秒後にUIにメッセージを表示する場合、それほど重要ではありません。</font><font style="vertical-align: inherit;">ユーザーは違いに気付かないでしょう。</font><font style="vertical-align: inherit;">次に、このタスクをメインスレッドで実行する価値があるのは、それが空いているときだけでしょうか。</font><font style="vertical-align: inherit;">つまり、awaitNewTask行がいつ呼び出されたかを知っておくと便利です。</font><font style="vertical-align: inherit;">この場合、ルーパーには、tasks.isEmptyコードが起動したときに起動するaddIdleHandlerがあります。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looper.myQueue（）。AddIdleHandler（）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
そして、IdleHandlerの最も単純な実装は次のようになります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@AnyThread</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdleHandler</span> </span>{
    <span class="hljs-keyword">private</span> val handler = Handler(Looper.getMainLooper())<font></font>
<font></font>
    <span class="hljs-function">fun <span class="hljs-title">post</span><span class="hljs-params">(task: Runnable)</span> </span>{<font></font>
        handler.post {<font></font>
            Looper.myQueue().addIdleHandler {<font></font>
                task.run()<font></font>
                <span class="hljs-keyword">return</span><span class="hljs-meta">@addIdleHandler</span> <span class="hljs-keyword">false</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、アプリケーションの正直なコールドスタートを測定できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">絵文字</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムの絵文字ではなく、カスタムの絵文字を使用します。以下は、異なる年に異なるプラットフォームで絵文字がどのように表示されたかの例です。左と右の絵文字はかなり良いですが、真ん中に... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bv/71/m3/bv71m3d7rginefvtev6ogcgwess.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の問題があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dw/-1/nx/dw-1nxxjfpggaxcjo_-idb0ofce.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各行は同じ絵文字ですが、再現する感情は異なります。私は一番下が一番好きですが、それが何を意味するのかまだわかりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VKontakteから自転車があります。 2014年に、1つの絵文字をわずかに変更しました。たぶん誰かが覚えている-「マシュマロ」だった。彼の変化の後、ミニ暴動が始まった。もちろん、彼は「壁に戻る」レベルには達しませんでしたが、反応は非常に興味深いものでした。そして、これは絵文字を解釈することの重要性について教えてくれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
絵文字の作成方法：大きなビットマップがあり、すべてが1つの大きな「アトラス」にまとめられています。</font><font style="vertical-align: inherit;">それらのいくつかがあります-異なるDPIの下で。</font><font style="vertical-align: inherit;">そして、情報を含むEmojiSpanがあります。私は「そのような」絵文字を描画します。それは、そのような場所（x、y）のそのようなビットマップにあります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、スパンの下にテキストの代わりに何かを表示できるReplacementSpanがあります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、テキストで絵文字を見つけ、EmojiSpanでラップすると、システムはシステムの絵文字の代わりに目的の絵文字を描画します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/y5/tq/agy5tq5wl0ys8vbwuqgwhpfeoli.png"><a name="alt"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代替案</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">膨らませる</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
膨らましが遅いので、膨らまないように手でレイアウトを作ってみませんか。</font><font style="vertical-align: inherit;">そして、それにより、100500 ViewHolderを回避することにより、すべてをスピードアップします。</font><font style="vertical-align: inherit;">それは妄想です。</font><font style="vertical-align: inherit;">何かをする前に、それを測定する価値があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AndroidにはDebugクラスがあり、startMethodTracingとstopMethodTracingがあります。</font></font><br>
<br>
<pre><code class="java hljs">Debug.startMethodTracing(“trace»)<font></font>
inflate(...)<font></font>
Debug.stopMethodTracing()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、特定のコードの実行時間に関する情報を収集できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ea/hz/wa/eahzwatykq-cflwr2ul3qnwbvq4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ここでのインフレーション自体は目に見えないほどです。</font><font style="vertical-align: inherit;">ドローアブルのロードに4分の1が費やされ、4分の1がカラーをロードしていました。</font><font style="vertical-align: inherit;">そして、etc部分のどこかだけが私たちの膨張です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XMLレイアウトをコードに変換してみて、約0.5ミリ秒程度保存しました。</font><font style="vertical-align: inherit;">実際、この増加は最も印象的ではありません。</font><font style="vertical-align: inherit;">そして、コードはより複雑になりました。</font><font style="vertical-align: inherit;">つまり、書き換えはあまり意味がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、実際には、多くの場合、この問題はまったく発生しません。これは、通常、アプリケーションが非常に大きくなったときにのみ、長い膨張が発生するためです。</font><font style="vertical-align: inherit;">たとえば、VKontakteアプリケーションでは、約200〜300の異なる画面があり、すべてのリソースのロードがクラッシュします。</font><font style="vertical-align: inherit;">これをどうするかはまだ不明です。</font><font style="vertical-align: inherit;">ほとんどの場合、独自のリソースマネージャを作成する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アンコ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ankoは最近非推奨になりました。</font><font style="vertical-align: inherit;">とにかく、アンコは魔法ではなく、単純な構文糖です。</font><font style="vertical-align: inherit;">同じようにすべてを条件付きの新しいビュー（）に変換します。</font><font style="vertical-align: inherit;">したがって、Ankoのメリットはありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソ/フラッター</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全に無関係な2つのものを組み合わせるのはなぜですか？</font><font style="vertical-align: inherit;">これはテクノロジーについてではなく、テクノロジーへの移行の複雑さについてです。</font><font style="vertical-align: inherit;">ただ借りて新しいライブラリに移動することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これによりパフォーマンスが向上するかどうかは不明です。</font><font style="vertical-align: inherit;">また、完全に異なるデバイスを使用する何百万もの人々が毎分私たちのアプリケーションを使用するため、新しい問題が発生することはありません（おそらく、その4分の1についてさえ聞いたことがないでしょう）。</font><font style="vertical-align: inherit;">さらに、メッセージは非常に大きなコードベースです。</font><font style="vertical-align: inherit;">すべてを瞬時に書き換えることは不可能です。</font><font style="vertical-align: inherit;">そして、テクノロジーの誇大宣伝のためにそれを行うことは愚かです。</font><font style="vertical-align: inherit;">特に、Jetpack Composeがどこか遠くにある場合。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetpackの作成</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グーグルは皆、このライブラリの形で天国からのマナを約束しますが、それはまだアルファ版です。</font><font style="vertical-align: inherit;">そして、それがリリースになるとき-それは明確ではありません。</font><font style="vertical-align: inherit;">現在の形で入手できるかどうかも不明です。</font><font style="vertical-align: inherit;">実験するには早すぎます。</font><font style="vertical-align: inherit;">それを安定版で公開し、主要なバグをクローズします。</font><font style="vertical-align: inherit;">そして、それから初めて私たちは彼の方向を見ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの大きなカスタムビュー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまなインスタントメッセンジャーを使用する人が話す別のアプローチがあります。「複雑な階層構造ではなく、1つの大きなカスタムビューを取得して書き込む」です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
欠点は何ですか？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">維持するのは難しいです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在の現実では意味がありません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android 4.3では、View内の内部キャッシュシステムがポンプされました。</font><font style="vertical-align: inherit;">たとえば、ビューが変更されていない場合、onMeasureは呼び出されません。</font><font style="vertical-align: inherit;">そして、前回の測定結果が使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android 4.3-4.4では、レンダリングをキャッシュするRenderNode（DisplayList）が登場しました。</font><font style="vertical-align: inherit;">例を見てみましょう。</font><font style="vertical-align: inherit;">ダイアログのリストにセルがあるとします：アバター、タイトル、サブタイトル、読み取りステータス、時間、別のアバター。</font><font style="vertical-align: inherit;">条件付き-10要素。</font><font style="vertical-align: inherit;">そして、カスタムビューを作成しました。</font><font style="vertical-align: inherit;">この場合、1つのプロパティを変更すると、すべての要素が再測定されます。</font><font style="vertical-align: inherit;">つまり、追加のリソースを費やすだけです。</font><font style="vertical-align: inherit;">各要素が個別のビューであるViewGroupの場合、1つのビューを変更すると、1つのビューのみが無効になります（このビューが他のビューのサイズに影響する場合を除く）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、標準の最適化でクラシックRecyclerViewを使用することがわかりました。非標準のものの一部があり、最も重要で基本的なのは、メッセージをViewHolderに分割することです。もちろん、これは適用範囲が狭いと言えますが、このアプローチは、たとえば1万文字の大きなテキストなど、他のものに投影することもできます。段落に分割でき、各段落は個別のViewHolderです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
@WorkerThreadのすべてを最大化する価値もあります。リンクの解析、DiffUtils-それにより、@ UiTheadを可能な限りアンロードします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グローバルRecycledViewPoolを使用すると、メッセージ画面間を移動でき、毎回ViewHolderを作成する必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、まだ決定していない他の重要なものがあります。たとえば、長いインフレート、つまりリソー​​スからのデータのロードです。</font></font><br>
<br>
<blockquote>    ,   Mobius 2019 Piter  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>,     .     ,     ,  SQLite,     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Mobius 2020 Piter</a>     .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja501978/index.html">Prometheusヒストグラムはどのように機能しますか？</a></li>
<li><a href="../ja501980/index.html">1つのプロジェクトの歴史、またはアスタリスクとPhpに基づいて7年間のPBXを作成した方法</a></li>
<li><a href="../ja501982/index.html">シェーダーをゲームエンジンからSubstance Painterに転送する方法</a></li>
<li><a href="../ja501984/index.html">検疫で何を確認しますか？テクノストリームからの厳選された資料（パート4）</a></li>
<li><a href="../ja501986/index.html">Apple AirPodsの信じられないほどの成功の秘密</a></li>
<li><a href="../ja501990/index.html">便利な投稿：OpenShiftの2日目の問題を解決してオペレーターを作成する4つのイベント</a></li>
<li><a href="../ja501992/index.html">製品リリースを加速して安定させるためにテストを整理する方法。パート1</a></li>
<li><a href="../ja501994/index.html">MySQLのオーケストレーター：フェイルセーフプロジェクトをプロジェクトなしでは構築できない理由</a></li>
<li><a href="../ja501996/index.html">Zen Go（Pocket Version）</a></li>
<li><a href="../ja501998/index.html">スタイルの高価な価格。Yandexレポート</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>