<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏽 📚 ↙️ Messung der Verzögerung von der Tastatur zum Photon mit einem optischen Sensor 🧛🏻 🤹🏾 👩‍👩‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um die Reaktionszeit oder Latenz auf Computern und Schnittstellen zu messen, verwende ich seit langem die Is It Snappy- App mit einer Hochgeschwindigk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Messung der Verzögerung von der Tastatur zum Photon mit einem optischen Sensor</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505260/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Reaktionszeit oder Latenz auf Computern und Schnittstellen zu messen, verwende ich seit langem die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is It Snappy-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> App </font><font style="vertical-align: inherit;">mit einer Hochgeschwindigkeits-iPhone-Kamera, um Bilder zwischen einem Tastendruck und einem Bildschirmwechsel zu zählen. Das Problem besteht jedoch darin, die genauen Frames für das Timing mit dem Auge zu bestimmen, was bei vielen Tests ärgerlich ist. Es macht es auch schwierig, die Variabilität der Ergebnisse zu messen. Ich habe diese Tests bereits vereinfacht, indem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ich der Tastatur-Firmware einen Modus hinzugefügt habe, der die Farbe der LED nach dem Senden des Ereignisses über USB ändert.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies erhöht jedoch die Geschwindigkeit und Genauigkeit nur geringfügig. Ich hätte gerne etwas besseres. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also trat ich in die Fußstapfen meines Freundes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rafa</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und machte einen Hardware-Verzögerungstester, der Tastaturereignisse sendet und dann mit Hilfe eines optischen Sensors die Zeit misst, die zum Wechseln des Bildschirms benötigt wird! </font><font style="vertical-align: inherit;">Es war ganz einfach, und in diesem Artikel werde ich über einige der Ergebnisse sowie über die Schwierigkeiten beim Testen hoher Verzögerungen und darüber sprechen, wie Sie Ihren eigenen Tester erstellen können.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mein Tester basiert auf einem Lichtsensor bei Amazon. </font><font style="vertical-align: inherit;">Es ist auf einem verstellbaren Stativ montiert, das mit dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teensy LC-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mikrocontroller verbunden </font><font style="vertical-align: inherit;">ist. Dieser drückt 'a' und wartet, bis sich die Lichtstärke ändert, löscht den Buchstaben und sammelt dann weiterhin Proben, während er die Taste gedrückt hält. </font><font style="vertical-align: inherit;">Mit einem kurzen Knopfdruck wird ein schönes Histogramm der Verzögerung angezeigt, das folgendermaßen aussieht:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lat i = 60,3 +/- 9,3, a = 60, d = 59 (n = 65, q = 41) | </font><font style="vertical-align: inherit;">239_ |</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Zeile zeigt die durchschnittliche Verzögerung von Einfügungen ( </font></font><code>i=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), Löschungen ( </font></font><code>d=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und deren Kombination ( </font></font><code>a=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), die Standardabweichung der Einfügungszeit ( </font></font><code>+/-</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), die Anzahl der Messungen ( </font></font><code>n=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und die Qualität ( </font></font><code>q=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) sowie ein kleines ASCII-Histogramm, wobei jedes Symbol ein Fragment (Bucket) darstellt ) in 10 ms, und die Zahlen von 1 bis 9 geben proportional an, wie voll dieser Eimer ist. Das Symbol </font></font><code>_</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet einen Bucket mit mindestens einer Stichprobe, aber es reicht nicht aus, einen neunten Bucket zu füllen. Dies ist also ein Delay-Tail mit einer kleinen Anzahl von Zufallsstichproben. So sieht es aus (die Fotomonitore befanden sich im Hochformat, aber alle Tests wurden im Querformat durchgeführt): </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/415/1f5/016/4151f5016c68014682c8e09eac08b240.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe es auch so gemacht, dass durch erneutes Drücken der Taste beispielsweise alle Messergebnisse angezeigt werden, z.</font></font><code>[35, 35, 33, 44]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">damit Sie ein Diagramm erstellen können:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/326/7b9/7ef/3267b97ef54e907c5d656dd0b7ae75d2.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überwachen Sie die Antwortzeit</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich beginne mit meinen bevorzugten Ergebnissen:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sublime Text, macOS, ablenkungsfreier Vollbildmodus auf zwei 4k-Monitoren:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 35,3 +/- 4,7, a = 36, d = 36 (n = 67, q = 99) | </font><font style="vertical-align: inherit;">193 | </font><font style="vertical-align: inherit;">Dell P2415Q oben</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 52,9 +/- 5,0, a = 53, d = 54 (n = 66, q = 45) | </font><font style="vertical-align: inherit;">_391 | </font><font style="vertical-align: inherit;">Dell P2415Q unten</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 65,1 +/- 5,0, a = 64, d = 63 (n = 109, q = 111) | </font><font style="vertical-align: inherit;">_292 | </font><font style="vertical-align: inherit;">HP Z27 oben</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 79,7 +/- 5,0, a = 80, d = 80 (n = 98, q = 114) | </font><font style="vertical-align: inherit;">89_ | </font><font style="vertical-align: inherit;">HP Z27 unten</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier gibt es etwas zu sehen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zunächst einmal gefällt mir, dass Sie mit dem einzeiligen Format eines Histogramms mit fester Breite alle Ergebnisse nebeneinander in eine Textdatei einfügen und zum Vergleich markieren können.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sehen den erwarteten Unterschied von 16 ms zwischen der Antwortzeit am oberen und unteren Bildschirmrand aufgrund der Abtastzeit der Zeilen für Frames bei 60 Hz.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Standardabweichung unterscheidet sich nicht wesentlich von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4,6 ms</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von einer gleichmäßigen Verteilung der Ergebnisse mit einer Bildschirmaktualisierungszeit von 16 ms.</font></font><br>
</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der HP Z27 hat eine um ca. 30 ms längere Reaktionszeit als der Dell P2415Q! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und diese Messung erfolgt bis zum Beginn der Anzeige des Symbols. </font><font style="vertical-align: inherit;">Ich bin mir ziemlich sicher, dass das volle Display beim Z27 auch länger dauert. </font><font style="vertical-align: inherit;">Das heißt, auf Z27 im Sublime-Editor ist fast die Hälfte der gesamten Verzögerung eine zusätzliche Verzögerung vom Monitor!</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Messungen im Rest dieses Artikels wurden mit meinem Dell P2415Q durchgeführt. </font><font style="vertical-align: inherit;">Beide Monitore haben eine „schnelle“ Reaktionszeit, Z27 hat eine noch schnellere Reaktionszeit, wirkt sich jedoch nur auf die Übergangszeit von Anfang bis Ende (Übergangszeit) aus und führt hässliche Ghost-Tracks ein, ohne die anfängliche Verzögerung zu verringern.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Messschwierigkeiten</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei den meisten bekannten Methoden ist die Messung der Verzögerungsqualität tatsächlich schwieriger als Sie denken. </font><font style="vertical-align: inherit;">Um realistische Ergebnisse zu erzielen, habe ich mich mehr Mühe gegeben als die meisten Experimentatoren, aber die ersten Male ist alles fehlgeschlagen, sodass ich die Fehler beheben musste.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächliche End-to-End-Verzögerungsmessung</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hauptgrund für die Verwendung eines Hardwaretesters besteht darin, dass es viele unvollständige und falsche Methoden zum Messen der End-to-End-Verzögerung gibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen bekannten und wirklich ausgezeichneten Artikel mit dem Titel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Wir drucken gerne".</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit guter Analyse und schönen Grafiken. Es vergleicht die Verzögerung verschiedener Texteditoren auf verschiedenen Betriebssystemen. Der Autor implementierte Messungen jedoch durch Simulation von Eingabeereignissen und Screen Scraping mithilfe von System-APIs. Ich selbst habe keine wiederholten Messungen durchgeführt, daher kann ich nicht auf etwas spezifisch Falsches hinweisen, aber es gibt viele potenzielle Probleme mit diesem Ansatz. Das Überprüfen des Bildschirmpuffers auf der CPU kann beispielsweise Anwendungen, die auf der GPU gerendert werden, ungerechtfertigt benachteiligen, da in einigen Fällen, in denen die Erfassung möglicherweise funktioniert, Kopien des Fensterpuffers vorhanden sind. Die Simulation von Eingaben kann anders ablaufen als echte Tastenanschläge. Trotzdem, selbst bei wirklich hochwertigen Messungen und objektiven Ergebnissen (und wir können uns dessen nicht wirklich sicher sein, ohne sie beim Durchgangstest zu überprüfen),Diese Ergebnisse geben nicht die vollständige Reaktionszeit von Anfang bis Ende an, was für eine echte Erfahrung wichtig ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 Hz USB Polling</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine der Ursachen für Verzögerungen, die Benutzer feststellen, die mein Tester jedoch nicht misst, ist die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tastaturlatenz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Viele Tastaturen können die von mir gemessene Reaktionszeit ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie meine vorherige Tastatur</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) aufgrund von 8-Millisekunden-USB-Abfrageintervallen, geringer Scan-Geschwindigkeit des Tastaturrasters, langsamer Firmware und kontroversem mechanischem Design </font><font style="vertical-align: inherit;">verdoppeln </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um einen Verzögerungstester mit einer geringen Streuung für die Emulation der Tastatur zu erstellen, können Sie nicht einfach einen Mikrocontroller verwenden - normalerweise gibt es eine Standardabfrage mit einer Frequenz von 125 Hz. </font><font style="vertical-align: inherit;">Mein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teensy LC-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mikrocontroller </font><font style="vertical-align: inherit;">ist einer der wenigen, der standardmäßig 1000 Hz verwendet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sicherstellung eines guten Signalpegels</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als ich meinen Tester auf Reaktionszeit ausgelegt habe, habe ich zunächst die Signalstärke überhaupt nicht gemessen. Am Ende war ich verwirrt: In derselben Anwendung, auf demselben Bildschirm in leicht unterschiedlichen Szenarien, wurden völlig unterschiedliche Ergebnisse erzielt. Ich habe einige Tests durchgeführt und festgestellt, dass das Signal bei kleinen Schriftarten mit schlechter Platzierung der Sensoren manchmal sehr schwach ist, sodass der Sensor nur am Ende der Ausgabe des Symbols funktioniert, obwohl er am Anfang funktionieren sollte (dies ist seine eigene schwierige subjektive Wahl).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wusste, dass der Grund die Zeit eines vollständigen Übergangs vom Anfang zum Ende der Anzeige sein sollte, da ich bereits vor dem Schreiben der Firmware jede Millisekunde mit einer einfachen Abfrage des optischen Sensors spielte und die Ergebnisse mit dem Arduino-Plotter ausgab. Geben Sie einfach Zeichen ein und löschen Sie sie, um das Signal anzuzeigen. Möglicherweise stellen Sie fest, dass bei einigen Kombinationen des optischen Sensors und des Monitors der vollständige Übergang fast 100 ms dauert. Die Videoaufnahme mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is It Snappy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erweckt jedoch den Eindruck, dass der vollständige Übergang auf dem Z27-Monitor nur etwa 20 ms dauert. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d32/500/02b/d3250002bac009103ed40a5c47cb56bc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Korrektur habe ich nach einem vollständigen Übergang eine Messung der Signalstärke von Spitze zu Spitze hinzugefügt, um zu überprüfen, ob ich in fünf Schritten vor Beginn des Übergangs eine angemessene Messauflösung für meinen Schwellenwert erhalte. Dies ist die Nummer, nach der Sie sehen</font></font><code>q=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wie sich herausstellte, ist es sehr wichtig, eine große Schriftgröße und eine hohe Bildschirmhelligkeit einzustellen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starke Streuung durch kleine Unterschiede</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist möglich, dass scheinbar unbedeutende Unterschiede im Messobjekt zu ernsthaften Verzögerungsunterschieden führen. Ich wollte zum Beispiel herausfinden, ob es einen signifikanten Unterschied zwischen der Antwortzeit von Sublime und VSCode bei der Auswahl von Text in einer kleinen Datei im Vergleich zu einer großen Datei mit einer komplexen Auswahlgrammatik und einem Popup für die automatische Vervollständigung gibt. Natürlich gibt es einen Unterschied. Als ich jedoch einige Abweichungen bei den Werten bemerkte, führte ich einige weitere Tests durch und stellte fest, dass die Antwortzeit zwischen der Eingabe von 'a' in einer leeren Zeile und der Eingabe von 'a' nach dem vorherigen 'a' ('aa') sehr unterschiedlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind die Ergebnisse der Erstellung einer neuen Zeile nach der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3469.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeile in der großen Datei </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">parser.rs</font></a><font style="vertical-align: inherit;"> mit 6199 Zeilen. Alle Ergebnisse werden nach einer ähnlichen Positionierung des Sensors näher an der Unterseite des Dell-Monitors erhalten.</font></font><br>
<br>
<pre>lat i= 40.2 +/-   4.1, a= 40, d= 39 (n= 38,q= 90) |  _89           | sublime small .txt<font></font>
<font></font>
lat i= 41.2 +/-   6.9, a= 41, d= 42 (n= 54,q= 92) |   992          | sublime aa parser.rs<font></font>
lat i= 43.6 +/-   6.1, a= 43, d= 42 (n= 48,q=100) |   492          |<font></font>
lat i= 52.2 +/-   6.0, a= 52, d= 52 (n= 26,q=100) |    49          |<font></font>
lat i= 44.3 +/-   5.6, a= 43, d= 42 (n= 45,q=100) |   391          |<font></font>
lat i= 42.7 +/-   7.6, a= 42, d= 42 (n= 46,q=100) |  _491          |<font></font>
<font></font>
lat i= 48.1 +/-   6.8, a= 49, d= 50 (n= 43,q= 89) |   269          | sublime a parser.rs<font></font>
lat i= 43.9 +/-   5.4, a= 48, d= 52 (n= 32,q= 97) |   197          |<font></font>
lat i= 47.8 +/-   8.4, a= 49, d= 49 (n= 29,q= 97) |   197_         |<font></font>
lat i= 46.1 +/-   6.8, a= 47, d= 49 (n= 42,q= 97) |   196_         |<font></font>
<font></font>
lat i= 63.3 +/-   9.3, a= 63, d= 62 (n= 68,q=118) |    _963__      | vscode aa parser.rs<font></font>
lat i= 63.6 +/-   7.6, a= 64, d= 65 (n= 71,q=139) |    _49__     _ |<font></font>
lat i= 62.3 +/-   6.3, a= 61, d= 59 (n= 52,q=132) |    _791        |<font></font>
lat i= 62.0 +/-   5.8, a= 61, d= 60 (n= 40,q=111) |    _49_        |<font></font>
lat i= 61.9 +/-   9.7, a= 62, d= 61 (n= 35,q=111) |     981_       |<font></font>
<font></font>
lat i= 53.1 +/-   7.7, a= 51, d= 49 (n= 54,q=116) |   _79__        | vscode a parser.rs<font></font>
lat i= 52.2 +/-   6.3, a= 52, d= 51 (n= 41,q=133) |    692         |<font></font>
lat i= 53.2 +/-   7.8, a= 52, d= 52 (n= 57,q=134) |    591_        |<font></font>
lat i= 52.1 +/-   7.1, a= 52, d= 52 (n= 55,q=134) |    591_        |</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe viele Messungen zu unterschiedlichen Zeiten und mit geringfügigen Abweichungen durchgeführt, um den Effekt zu bestätigen. Wie Sie sehen können, gibt es einige Unterschiede zwischen den Dimensionen im selben Szenario, aber es gibt viel mehr Unterschiede zwischen der einfachen Eingabe von 'a' und dem Hinzufügen von 'a' nach dem vorhandenen 'a'. Schauen Sie sich die Spalte an </font></font><code>a=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Ergebnisse des Einfügens und Löschens enthält, damit das geringste Rauschen auftritt. Sublime gibt das zweite Zeichen in der Sequenz 'aa' schneller als das erste ein und VSCode umgekehrt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In beiden Editoren bewirkt 'aa', dass das Popup-Fenster für die automatische Vervollständigung angezeigt und ausgeblendet wird, um eine Option zwischen den beiden Listen und den Buchstaben 'a' auszuwählen. </font><font style="vertical-align: inherit;">Ich kann davon ausgehen, dass Sublime im Fall von 'a' langsamer ist, da das Öffnen und Schließen des Popup-Fensters für die automatische Vervollständigung einige Zeit in Anspruch nimmt, aber ich habe keine klare Version darüber, warum VSCode im Fall von 'aa' sowohl beim Einfügen als auch beim Löschen langsamer ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rassynchron mit Bildschirmaktualisierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann bemerkte ich, dass die Standardabweichungen verdächtig gering waren. Manchmal betrug die Standardabweichung 1 ms, obwohl sie logischerweise aufgrund von 16 ms Bildschirmaktualisierungsintervallen 4,6 ms überschreiten sollte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich schaute auf meinen Code und stellte fest, dass Messungen versehentlich mit Bildschirmaktualisierungen synchronisiert wurden. Nach jeder Messung wartete die Firmware genau 300 ms, bevor sie erneut 'a' eingab oder das Symbol löschte und die nächste Messung durchführte. Dies bedeutet, dass die Eingabedaten immer ungefähr 300 ms nach der Aktualisierung des Bildschirms gesendet wurden und ziemlich stetig in das gleiche Aktualisierungsintervall fielen. Ich habe dieses Problem behoben, indem ich zwischen den Messungen eine zufällige Verzögerung von 50 ms hinzugefügt habe, was zu einem eigentümlichen Jitter führt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grundsätzlich verursachte dieser Fehler zu geringe Abweichungen, konnte jedoch zu falschen Durchschnittswerten führen, wenn die Anwendung die Frist für das Rendern übersprang, wenn das Eingabeereignis am Ende des Frames eintrifft. </font><font style="vertical-align: inherit;">Ich habe dies beim Testen dieses Artikels festgestellt und konnte nicht mehr alle vorherigen Tests wiederholen. Daher stellen Sie an einigen Stellen möglicherweise Werte mit geringer Abweichung fest. </font><font style="vertical-align: inherit;">Aber ich habe die Durchschnittswerte für wichtige Tests wie Sublime und VSCode erneut überprüft.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texteditoren</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe die Antwortzeit mehrerer Texteditoren in derselben Nur-Text-Datei getestet. </font><font style="vertical-align: inherit;">Aber wie oben erwähnt, wurden die Tests vor der Implementierung des Rassinhrons durchgeführt, wobei der Bildschirm durch Jittering aktualisiert wurde. </font><font style="vertical-align: inherit;">Wiederholte Tests wurden nur für Sublime und VSCode durchgeführt.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lat i = 32,5 +/- 4,0, a = 34, d = 35 (n = 38, q = 78) | </font><font style="vertical-align: inherit;">9_ | </font><font style="vertical-align: inherit;">erhabener Text</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 33,4 +/- 1,4, a = 33, d = 33 (n = 68, q = 23) | </font><font style="vertical-align: inherit;">_9 | </font><font style="vertical-align: inherit;">textedit</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 47,6 +/- 7,0, a = 47, d = 47 (n = 71, q = 130) | </font><font style="vertical-align: inherit;">219 | </font><font style="vertical-align: inherit;">vscode</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 34,2 +/- 3,5, a = 34, d = 33 (n = 57, q = 37) | </font><font style="vertical-align: inherit;">9 _ | </font><font style="vertical-align: inherit;">Chrome HTML-Eingabe</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 33,2 +/- 1,1, a = 33, d = 33 (n = 55, q = 30) | </font><font style="vertical-align: inherit;">9 | </font><font style="vertical-align: inherit;">Lager Mac Emacs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 45,6 +/- 7,0, a = 43, d = 41 (n = 35, q = 56) | </font><font style="vertical-align: inherit;">992_ | </font><font style="vertical-align: inherit;">Atom</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 35,0 +/- 4,7, a = 35, d = 35 (n = 66, q = 11) | </font><font style="vertical-align: inherit;">9__ | </font><font style="vertical-align: inherit;">xi</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angesichts des Mangels an Jitter aufgrund dieser Ergebnisse würde ich sagen, dass alle Editoren außer VSCode und Atom gleich gut funktionieren. </font><font style="vertical-align: inherit;">Und selbst für diese beiden ist bei normaler Eingabe eine geringere Strafe für die Reaktionszeit als für einen Monitor oder eine Tastatur üblich.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terminals</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe auch die Verzögerung in verschiedenen Terminals gemessen. </font><font style="vertical-align: inherit;">Das Apple-Terminal und das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kitty</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> scheinen </font><font style="vertical-align: inherit;">optimale Reaktionszeiten </font><font style="vertical-align: inherit;">zu haben </font><font style="vertical-align: inherit;">, während </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iTerm2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alacritty</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> etwas schlechter aussehen.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lat i = 53,1 +/- 6,6, a = 54, d = 55 (n = 53, q = 59) | </font><font style="vertical-align: inherit;">291 _ | </font><font style="vertical-align: inherit;">iterm2 gpu rendern</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 50,5 +/- 2,5, a = 50, d = 50 (n = 56, q = 59) | </font><font style="vertical-align: inherit;">19_ | </font><font style="vertical-align: inherit;">iterm2 no gpu</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 35,8 +/- 7,0, a = 34, d = 33 (n = 73, q = 48) | </font><font style="vertical-align: inherit;">9___ | </font><font style="vertical-align: inherit;">Apfel-Terminal</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 35,1 +/- 2,5, a = 34, d = 32 (n = 35, q = 52) | </font><font style="vertical-align: inherit;">9_ | </font><font style="vertical-align: inherit;">Apple Terminal Vim</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 50,4 +/- 3,9, a = 50, d = 49 (n = 60, q = 269) | </font><font style="vertical-align: inherit;">_59 | </font><font style="vertical-align: inherit;">alacritty</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lat i = 36,1 +/- 5,6, a = 35, d = 34 (n = 78, q = 199) | </font><font style="vertical-align: inherit;">9__ | </font><font style="vertical-align: inherit;">Kitty</font></font></pre><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie man es macht</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist die Liste der Teile, die ich verwendet habe:</font></font><br>
<br>
<ul>
<li><b>$12</b>: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Teensy LC</a>     Teensy&nbsp;3+.   Arduino,  USB- Teensy     1000&nbsp; ( 1 ),      USB-      125&nbsp; ( 8&nbsp;     ). ,      1000&nbsp;.     ,     ,  Teensy&nbsp;3  .<br>
</li>
<li><b>$12</b>: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">  </a> (Amazon     ,    ).    ,           .<br>
</li>
<li><b>$13</b>: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"></a>         .<br>
</li>
<li>- /   <br>
</li>
<li>    , Teensy  <br>
</li>
<li>    ,     <br>
</li>
<li> USB micro-B   Teensy  </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Gerät kann auf viele Arten zusammengebaut werden. Unter dem Strich müssen Sie nur die drei Drähte (3 V, Masse, Analogausgang) des optischen Sensormoduls mit den entsprechenden Teensy-Pins (3 V, Masse und einem beliebigen Analog-Pin) verbinden. Der einfachste Weg, dies zu tun, der nicht einmal Löten erfordert, wenn Sie Teensy mit vorgelöteten Stiften gekauft haben, besteht darin, drei </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drähte mit Jumpern Mama-Mama zu verbinden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dann brauchen Sie nur noch einen Schalter, um den Test auszuführen. Hier ist ein Pin des Teensy mit Masse und der andere mit dem digitalen E / A-Pin verbunden. Wenn Sie wirklich faul sind, reicht ein Hauch von zwei Drähten!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um sicherzustellen, dass das optische Sensormodul nur einen begrenzten Bereich des Bildschirms sieht, habe ich es in einen kleinen Zylinder mit Klebeband gewickelt - und das Ende vorsichtig mit einer Schere abgeschnitten. Es stellte sich heraus, dass ein kleines rundes Fenster mit einem Stativ auf den Bildschirm gedrückt werden kann, um externe Geräusche zu minimieren und das sauberste Signal zu erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe bereits ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pedalgehäuse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit einem Teensy LC und einer kleinen Platine im Inneren hergestellt und es hatte einen zusätzlichen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TRRS-Anschluss</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an der Seite </font><font style="vertical-align: inherit;">, den ich speziell installiert habe, um auf ein ähnliches Projekt in der Zukunft zu warten, wo es benötigt wird. Daher blieb es, den optischen Sensor an das TRRS-Kabel anzulöten. Dann können Sie eines meiner Pedale verwenden, um die Tests zu steuern!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hatte Glück mit dem Löten, weil ich für ein Projekt gerade Magnetstifte gekauft habe, die auch beim Löten verwendet werden können. Leider stellte sich heraus, dass ich in Wirklichkeit nicht viele große Metallteile habe, an denen sie befestigt werden können. Am Ende nahm ich eine gusseiserne Pfanne zum Löten und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meinen Wolframwürfel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für Operationen auf dem Tisch </font><font style="vertical-align: inherit;">(es stellte sich heraus, dass es leicht war magnetisiert).</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ccf/ae5/836/ccfae58364a964a71628451dcb1e9feb.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich schlage vor, Sie zeigen Ihre Fantasie und tun etwas Interessanteres als nur baumelnde Verbindungsdrähte. Für mein Pedal kaufte ich eine Plastikbox in einem örtlichen Elektronikgeschäft, bohrte ein paar Löcher an den Seiten, steckte Audiobuchsen ein und legte ein kleines Steckbrett ein, um die Verbindungen neu zu konfigurieren. Amazon bietet unzählige Pedale für Tätowiermaschinen und elektrische Klaviere mit 1/4-Zoll-Telefonbuchsen, aus denen Sie auswählen können. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> meine Favoriten für Stille und taktile Empfindungen. Es gibt jedoch billigere Optionen, die unzuverlässig, schwer zu drücken oder unangenehm sein können, um Lärm zu machen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich würde in meinem Beispiel nicht empfehlen, die TRRS-Buchse für das Sensormodul zu verwenden. </font><font style="vertical-align: inherit;">Obwohl es gut und kompakt ist und viele Kabel dafür verfügbar sind, stellte sich später heraus, dass beim Anschließen und Trennen der Stromversorgung zu viele Verbindungen kurzgeschlossen werden. </font><font style="vertical-align: inherit;">Ich habe versucht, dies zu minimieren, indem ich die Stromversorgung und die Erdung an den gegenüberliegenden Enden der Platine getrennt habe. Ich rate Ihnen jedoch, ein Kabel eines besseren Typs zu verwenden, möglicherweise ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Telefonkabel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3d5/fce/cfd/3d5fcecfdc63a4901b487091142a09c1.jpg"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firmware</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Anfang und das Ende der Ausgabe des Zeichens auf dem Bildschirm zu bestimmen, habe ich nicht die modernste Firmware, aber ich habe einige Zeit damit verbracht, sie so einzurichten, dass sie gut funktioniert und verschiedene Funktionen hinzufügt. Ich empfehle daher, damit zu beginnen. </font><font style="vertical-align: inherit;">Installieren Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teensyduino</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dann können Sie meine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arduino-Skizze</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herunterladen </font><font style="vertical-align: inherit;">, die für das Pedal funktioniert. Sie können jedoch unnötige Fragmente </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">auskommentieren</font></a><font style="vertical-align: inherit;"> und </font><font style="vertical-align: inherit;">für die Verwendung der richtigen Kontakte konfigurieren. </font><font style="vertical-align: inherit;">Dann ist alles einfach - ein langer Druck auf die Taste startet die Messung und ein kurzer Druck zeigt die Ergebnisse an!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de505246/index.html">Drucken Sie die erste Tranche mit Upwork</a></li>
<li><a href="../de505252/index.html">Avokado-Projekt</a></li>
<li><a href="../de505254/index.html">Schlangenzucker oder schreiben Sie Ihr Sortiment in JavaScript</a></li>
<li><a href="../de505256/index.html">Erfolgreicher Start. 39. seit Jahresbeginn. 14. aus den USA. Starlink SpaceX-Satelliten</a></li>
<li><a href="../de505258/index.html">Zahnmedizin: Erwartung und Realität</a></li>
<li><a href="../de505264/index.html">Als ich den HTML-Parser in PHP schrieb, und was daraus wurde. Teil eins</a></li>
<li><a href="../de505268/index.html">Persönliche Erfahrung: vom Frontend-Entwickler zum Leader</a></li>
<li><a href="../de505274/index.html">Tödliche Sünden der Site-Sicherheit: Was wir aus den Statistiken des Schwachstellenscanners für das Jahr gelernt haben</a></li>
<li><a href="../de505276/index.html">Wie wir ABBYY FineReader PDF beigebracht haben, ganze Absätze zu bearbeiten</a></li>
<li><a href="../de505278/index.html">39 Abkürzungen in Englisch für Anfänger und Seoshnikov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>