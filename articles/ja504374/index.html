<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔴 🍄 👩🏽‍🎤 トラバーサルのカウント：JavaScriptを例に使用した単純な単語のディープ検索と幅優先検索 🤼 👍🏽 ⛲️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="良い一日。Try Khovによる
 
 記事「Algorithms on Graphs：Let's talk Depth-First Search（DFS）and Breadth-First Search（BFS）」の翻訳を紹介します。
 
 グラフ走査とは何ですか？
 簡単に言うと、グラフ探索とは...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>トラバーサルのカウント：JavaScriptを例に使用した単純な単語のディープ検索と幅優先検索</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504374/"><img src="https://habrastorage.org/webt/_f/kf/kl/_fkfkl3gfkmnwtes2eypbueifxe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
良い一日。</font><font style="vertical-align: inherit;">Try Khovによる</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Algorithms on Graphs：Let's talk Depth-First Search（DFS）and Breadth-First Search（BFS）」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の翻訳を紹介します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラフ走査とは何ですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単に言うと、グラフ探索とは、これらの頂点の接続プロパティを検索する際の、ある頂点から別の頂点への遷移です。</font><font style="vertical-align: inherit;">リンク（頂点を結ぶ線）は、グラフの方向、パス、面、またはエッジと呼ばれます。</font><font style="vertical-align: inherit;">グラフの頂点はノードとも呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの主要なグラフトラバーサルアルゴリズムは、深さ優先検索（DFS）と幅優先検索（BFS）です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
両方のアルゴリズムがグラフのトラバースに使用されるという事実にもかかわらず、それらにはいくつかの違いがあります。</font><font style="vertical-align: inherit;">DFSから始めましょう。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">深さ検索</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DFSは、「深く掘り下げる」という概念に従います。アイデアは、最初のピーク（ポイント、場所）から特定の方向（特定のパスに沿って）に移動し、パスの終点または目的地（目的の頂点）に到達するまでです。パスの終わりに到達したが、それが目的地ではない場合、（分岐または分岐するパスのポイントに）戻って、別のルートに沿って進みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を見てみましょう。次のような有向グラフがあるとします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-d/dk/wt/-ddkwtwgddcvzo4mbrpzeiaklm8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポイント「s」にいて、頂点「t」を見つける必要があります。 DFSを使用して、可能なパスの1つを調査し、それに沿って最後まで移動します。tが見つからない場合は、戻って別のパスを探索します。プロセスは次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/v-/-1/gdv--18wxok-yjflx_zjlwktysi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、パス（p1）に沿って最も近いピークに移動し、これがパスの終わりではないことを確認します。したがって、次のピークに進みます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6q/ia/h-/6qiah-iw-qpybs2fdw072vuvrna.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
p1の終わりに到達しましたが、tが見つからなかったため、sに戻り、2番目のパスに沿って移動します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ck/ui/ad/ckuiadguztc8gx3r6gigroyum_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポイント「s」に最も近いパス「p2」の頂点に到達すると、さらに移動するための3つの方向が表示されます。最初の方向に頂上にあるピークをすでに訪れたので、2番目の方向に沿って移動しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1h/yz/7o/1hyz7ojpnp__g0w9sg5kr9bzeyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再びパスの終わりに到達しましたが、tが見つからなかったため、戻ります。 3番目のパスをたどり、最後に、目的のピーク "t"に到達します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oy/4d/mm/oy4dmm-velx-yladbqyvyqrbkts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがDFSの仕組みです。ある経路に沿って最後まで移動します。パスの終わりが目的のピークである場合、これで完了です。そうでない場合は、戻って別のパスに進み、すべてのオプションを調べます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
訪問したすべての頂点に対してこのアルゴリズムに従います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手順を繰り返し繰り返す必要性は、アルゴリズムを実装するために再帰を使用する必要性を示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptコードは次のとおりです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ,       </span>
<span class="hljs-comment">// , : adj = {A: [B,C], B:[D,F], ... }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">adj, v, t</span>) </span>{
	<span class="hljs-comment">// adj -  </span>
	<span class="hljs-comment">// v -   ()</span>
	<span class="hljs-comment">// t -  </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-comment">//    ,    </span>
	<span class="hljs-keyword">if</span>(v === t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
	<span class="hljs-keyword">if</span>(v.visited) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	v.visited = <span class="hljs-literal">true</span>
	<span class="hljs-comment">//    (  ) v</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> adj[v]) {
		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">if</span>(!neighbor.visited) {
			<span class="hljs-comment">//     ,      </span>
			<span class="hljs-keyword">let</span> reached = dfs(adj, neighbor, t)
			<span class="hljs-comment">//  true,  </span>
			<span class="hljs-keyword">if</span>(reached) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-comment">//   v  t  </span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注：この特別なDFSアルゴリズムを使用すると、ある場所から別の場所に移動できるかどうかを確認できます。</font><font style="vertical-align: inherit;">DFSはさまざまな目的に使用できます。</font><font style="vertical-align: inherit;">これらの目標により、アルゴリズム自体の外観が決まります。</font><font style="vertical-align: inherit;">ただし、一般的な概念はそのとおりです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFS分析</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアルゴリズムを分析してみましょう。各ノードの各「近隣」を迂回し、以前にアクセスしたものを無視するため、ランタイムはO（V + E）になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V + Eの意味の簡単な説明：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vは頂点の総数です。 Eは面（エッジ）の総数です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V * Eを使用する方が適切に思えるかもしれませんが、V * Eの意味を考えてみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V * Eは、各頂点に関して、これらの面が特定の頂点に属しているかどうかに関係なく、グラフのすべての面を調査する必要があることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、V + Eは、各頂点について、隣接するエッジのみを評価することを意味します。</font><font style="vertical-align: inherit;">例に戻ると、各頂点には特定の数の面があり、最悪の場合、すべての頂点を回り（O（V））、すべての面を調べます（O（E））。</font><font style="vertical-align: inherit;">V頂点とE面があるので、V + Eになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、各頂点をトラバースするために再帰を使用するため、これはスタックが使用されることを意味します（無限再帰はスタックオーバーフローエラーを引き起こします）。</font><font style="vertical-align: inherit;">したがって、空間的複雑度はO（V）です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、BFSについて検討します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">広い検索</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BFSは、「拡大して鳥の飛行の高さまで上昇する」という概念に従います（「拡大して、鳥瞰図」）。 BFSでは、特定のパスに沿って最後まで移動するのではなく、一度に1つのネイバーを前方に移動します。これは次のことを意味します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-d/dk/wt/-ddkwtwgddcvzo4mbrpzeiaklm8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パスをたどる代わりに、BFSはsに最も近いネイバーを1回のアクション（ステップ）で訪問し、tが検出されるまでネイバーのネイバーを訪問することを意味します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1u/vb/ny/1uvbnygi83vt6bxqnmv1hbwuzyq.png"><br>
<br>
<img src="https://habrastorage.org/webt/tg/en/jq/tgenjqvsz1zipcv3obsicrhq78a.png"><br>
<br>
<img src="https://habrastorage.org/webt/tf/j9/on/tfj9on04zudfmelpbn00xeh_tpm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DFSとBFSの違いは何ですか？私は、DFSが進んでいて、BFSが急いでいるのではなく、すべてを1つのステップで研究していると思いたいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に問題が発生します。どの隣人が最初に訪問されるべきかをどうやって知るのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、キューからの「先入れ先出し」（先入れ先出し、FIFO）の概念を使用できます。</font><font style="vertical-align: inherit;">最初に最も近いピークをキューに入れ、次にその未訪問のピークをキューに入れ、キューが空になるか、探している頂点が見つかるまでこのプロセスを続けます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがコードです：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ,       </span>
<span class="hljs-comment">// , : adj = {A:[B,C,D], B:[E,F], ... }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">adj, s, t</span>) </span>{
	<span class="hljs-comment">// adj -  </span>
	<span class="hljs-comment">// s -  </span>
	<span class="hljs-comment">// t -  </span><font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">let</span> queue = []
	<span class="hljs-comment">//  s  </span><font></font>
	queue.push(s)<font></font>
	<span class="hljs-comment">//  s         </span>
	s.visited = <span class="hljs-literal">true</span>
	<span class="hljs-keyword">while</span>(queue.length &gt; <span class="hljs-number">0</span>) {
		<span class="hljs-comment">//   ()   </span>
		<span class="hljs-keyword">let</span> v = queue.shift()
		<span class="hljs-comment">// abj[v] -  v</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> adj[v]) {
			<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span>(!neighbor.visited) {
				<span class="hljs-comment">//    </span><font></font>
				queue.push(neighbor)<font></font>
				<span class="hljs-comment">//    </span>
				neighbor.visited = <span class="hljs-literal">true</span>
				<span class="hljs-comment">//     ,  </span>
				<span class="hljs-keyword">if</span>(neighbor === t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
			}<font></font>
		} <font></font>
	}<font></font>
	<span class="hljs-comment">//  t  ,     </span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BFS分析</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BFSの方が遅いようです。ただし、視覚化をよく見ると、それらが同じランタイムを持っていることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キューでは、宛先に到達する前に各頂点を処理します。つまり、最悪の場合、BFSはすべての頂点と面を探索します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BFSは遅く見えるかもしれませんが、実際には高速です。これは、大きなグラフを操作する場合、DFSがパスをたどるのに多くの時間を費やし、最終的には偽であることが判明するためです。 BFSは、2つのピーク間の最短経路を見つけるためによく使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、BFSランタイムもO（V + E）であり、すべての頂点を含むキューを使用するため、空間的な複雑度はO（V）です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実生活の類似</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実生活からの類推を与えれば、これが私がDFSとBFSの仕事を想像する方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DFSといえば、迷路の中でネズミが食べ物を探しているところを想像します。</font><font style="vertical-align: inherit;">ターゲットに到達するために、マウスは何度も行き止まりに遭遇し、戻り、別の方法で移動するなど、迷路や食べ物からの出口が見つかるまで強制されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-e/f3/ji/-ef3ji72zi8egr3xa26zqvt1x4u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純化されたバージョンは次のよう</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kq/hb/dr/kqhbdrkv6xstug0ss3l5bpr1l9k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
になります。BFSについて考えるとき、私は水の上の円を想像します。</font><font style="vertical-align: inherit;">石が水に落ちると、中心からあらゆる方向に乱れ（円）が広がります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pv/lz/zp/pvlzzpnzfssjv8yzpkc49ovtsho.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡略版は次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s-/w9/sc/s-w9scwvyp93tvyk2zwimmfc_um.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">深さおよび幅の検索は、グラフをトラバースするために使用されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFSはエッジに沿って前後に移動し、BFSはターゲットを探してネイバー全体に広がります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFSはスタックを使用し、BFSはキューを使用します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方の実行時間はO（V + E）であり、空間的複雑度はO（V）です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのアルゴリズムは異なる哲学を持っていますが、グラフを操作するためにも同様に重要です。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意 </font><font style="vertical-align: inherit;">あたり::私はアルゴリズムとデータ構造のスペシャリストではないため、エラー、不正確さ、または誤った定式化が見つかった場合は、訂正と明確化のために個人の手紙を書いてください。</font><font style="vertical-align: inherit;">私は感謝するでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清聴ありがとうございました。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja504358/index.html">PuppetConf2016。システム管理者向けのKubernetes。パート2</a></li>
<li><a href="../ja504360/index.html">3Dプリンティング、Lego、Arduino、Raspberry Piを使用して顕微鏡を作る </a></li>
<li><a href="../ja504362/index.html">Google Colabに大量のデータをすばやく読み込む</a></li>
<li><a href="../ja504364/index.html">コンピュータは徐々に常識に近づいています</a></li>
<li><a href="../ja504370/index.html">Office 365とMicrosoft Teams-コラボレーションの利便性とセキュリティへの影響</a></li>
<li><a href="../ja504376/index.html">アウトソーシングから開発まで（パート1）</a></li>
<li><a href="../ja504380/index.html">SSD。内部構造とその構築原理</a></li>
<li><a href="../ja504382/index.html">私（PhD Neurobiology）が6か月でデータサイエンティストになった経緯</a></li>
<li><a href="../ja504384/index.html">TypeScriptをReactプロジェクトに徐々に導入する</a></li>
<li><a href="../ja504386/index.html">Vassbotn H.クラス仮想変数</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>