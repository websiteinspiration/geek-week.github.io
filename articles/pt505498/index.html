<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üé≥ üìπ Como resolvemos o problema de mem√≥ria de pilha n√£o inicializada no Windows üïµüèæ ü•• üôãüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nesta nota, descreverei como a Microsoft elimina as vulnerabilidades associadas √† mem√≥ria n√£o inicializada da pilha e por que fazemos isso.
 
 Para fa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Como resolvemos o problema de mem√≥ria de pilha n√£o inicializada no Windows</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505498/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta nota, descreverei como a Microsoft elimina as vulnerabilidades associadas √† mem√≥ria n√£o inicializada da pilha e por que fazemos isso.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para facilitar a navega√ß√£o, a nota √© dividida em se√ß√µes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabalhando com mem√≥ria n√£o inicializada: hist√≥rico de problemas</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solu√ß√£o para vulnerabilidades de mem√≥ria n√£o inicializadas</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll - inicializa√ß√£o autom√°tica</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observa√ß√µes interessantes relacionadas ao uso do InitAll</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otimiza√ß√µes de desempenho</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor do Usu√°rio</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planos futuros</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este trabalho n√£o teria sido poss√≠vel sem uma estreita colabora√ß√£o entre o Visual Studio, Windows e MSRC.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabalhando com mem√≥ria n√£o inicializada: hist√≥rico de problemas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao criar as linguagens de programa√ß√£o C e C ++, a √™nfase estava na alta velocidade e no controle flex√≠vel do desenvolvedor. </font><font style="vertical-align: inherit;">Por esse motivo, esses idiomas n√£o for√ßam a inicializa√ß√£o de vari√°veis. </font><font style="vertical-align: inherit;">Trabalhar com vari√°veis ‚Äã‚Äãn√£o inicializadas leva a um comportamento indefinido; portanto, elas devem ser inicializadas antes do uso, e a responsabilidade de observar essa regra cabe inteiramente ao desenvolvedor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As vulnerabilidades associadas √† mem√≥ria n√£o inicializada s√£o reduzidas para dois tipos:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divulga√ß√£o de conte√∫do: os dados armazenados em se√ß√µes n√£o inicializadas da mem√≥ria s√£o copiados para fora da √°rea confi√°vel e tornam-se conhecidos por pessoas que n√£o possuem a autoridade apropriada.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uso direto de mem√≥ria n√£o inicializada. </font><font style="vertical-align: inherit;">Exemplo: escreva por ponteiro n√£o inicializado.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â importante entender que problemas podem ocorrer independentemente de a mem√≥ria estar alocada na pilha ou no heap. </font><font style="vertical-align: inherit;">Este post √© sobre pilha de mem√≥ria, e a seguir falaremos sobre heap.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo de uso de mem√≥ria n√£o inicializada</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> size;  <font></font>
GetSize(&amp;size); <span class="hljs-comment">//       ?</span>
<span class="hljs-built_in">memcpy</span>(dest, src, size); <span class="hljs-comment">//  memcpy </span>
                         <span class="hljs-comment">//  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema aqui √© que, se a fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetSize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o atribuir um valor √† vari√°vel 'tamanho' em todas as ramifica√ß√µes do programa, um </font><font style="vertical-align: inherit;">tamanho n√£o inicializado ser√° passado para a </font><font style="vertical-align: inherit;">chamada de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mem√≥ria</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por esse motivo, pode ocorrer um erro de leitura ou grava√ß√£o fora do buffer, se o valor de 'tamanho' for maior que o tamanho do buffer 'src' ou 'dest'.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo de expans√£o de mem√≥ria n√£o inicializada</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span> {</span>
      <span class="hljs-keyword">uint8_t</span> field1;
      <span class="hljs-keyword">uint64_t</span> field2;<font></font>
};<font></font>
mystruct s {<span class="hljs-number">1</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">memcpy</span>(dest, &amp;s, <span class="hljs-keyword">sizeof</span>(s));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que a fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copie uma estrutura fora de uma √°rea confi√°vel (ou seja, do modo kernel para o modo usu√°rio). √Ä primeira vista, a estrutura parece estar totalmente inicializada, mas entre o 'campo1' e 'campo2' o compilador inseriu bytes de espa√ßo reservado que n√£o foram explicitamente inicializados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado da chamada do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytes de espa√ßo reservado ser√£o copiados para fora da √°rea confi√°vel, juntamente com seu conte√∫do n√£o inicializado, gravado anteriormente nesses endere√ßos virtuais. </font><font style="vertical-align: inherit;">Pode ser, por exemplo, uma parte de uma chave de criptografia secreta (que ficar√° vis√≠vel no modo de usu√°rio), um ponteiro (que interromper√° o ASLR) ou qualquer outra coisa. </font><font style="vertical-align: inherit;">Em alguns casos, pode-se facilmente provar que nenhum dado particularmente cr√≠tico √© transmitido; em outros, ser√° muito dif√≠cil. </font><font style="vertical-align: inherit;">Mas, de qualquer forma, descobrir qual √© a gravidade do problema da mem√≥ria n√£o inicializada √© um trabalho ingrato, e far√≠amos de bom grado outra coisa.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estat√≠sticas de erro de mem√≥ria n√£o inicializada</font></font></h3><br>
<p><img src="https://habrastorage.org/webt/hb/la/gn/hblagnxiqxpsgewdennaq6tx8o8.png" alt="Quadro 8"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota: nesta figura, o uso de mem√≥ria n√£o inicializada refere-se aos dois tipos de problemas: uso direto e divulga√ß√£o de conte√∫do. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos √∫ltimos anos, o n√∫mero de tais erros tem aumentado. </font><font style="vertical-align: inherit;">Provavelmente isso se deve em parte ao crescente interesse neles por parte dos pesquisadores e, como resultado, o surgimento de ferramentas eficazes para sua pesquisa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma classifica√ß√£o mais detalhada desses erros revela algumas tend√™ncias mais interessantes.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/od/bg/sq/odbgsqun-kof4vx6j8ws_v9d9f8.png" alt="Quadro 6"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota: neste diagrama, o uso de mem√≥ria n√£o inicializada N√ÉO inclui a divulga√ß√£o de seu conte√∫do.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/rl/ql/ee/rlqleezbmgk3oeo-bxztqaaphry.png" alt="Quadro 5"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observando esses diagramas, podemos tirar as seguintes conclus√µes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entre 2017 e 2018, as vulnerabilidades de mem√≥ria n√£o inicializadas representaram aproximadamente 5 a 10% de todas as vulnerabilidades nos relat√≥rios da Microsoft.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As vulnerabilidades associadas √† aloca√ß√£o de mem√≥ria na pilha e as vulnerabilidades associadas √† aloca√ß√£o de mem√≥ria no heap / pool foram quase iguais.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√° mais casos de divulga√ß√£o do conte√∫do da mem√≥ria n√£o inicializada do que casos de uso de mem√≥ria n√£o inicializada.</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">literatura adicional</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para uma introdu√ß√£o mais completa ao t√≥pico, consulte os seguintes recursos:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/microsoft/MSRC-Security-Research/blob/master/presentations/2019_09_CppCon/CppCon2019%20-%20Killing%20Uninitialized%20Memory.pdf</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://j00ru.vexillium.org/papers/2018/bochspwn_reloaded.pdf</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Flake.pdf</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solu√ß√£o para vulnerabilidades de mem√≥ria n√£o inicializadas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eles tentaram resolver os problemas descritos de v√°rias maneiras.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An√°lise est√°tica (durante a compila√ß√£o e depois)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuzzing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revis√£o de c√≥digo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializa√ß√£o autom√°tica</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An√°lise est√°tica</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A Microsoft usa v√°rios avisos de analisador est√°tico para capturar vari√°veis ‚Äã‚Äãn√£o inicializadas (incluindo C4700, C4701, C4703, C6001, C26494 e C26495). </font><font style="vertical-align: inherit;">Esses diagn√≥sticos s√£o conservadores, ou seja, </font><font style="vertical-align: inherit;">Para reduzir o ru√≠do, eles ignoram alguns padr√µes que podem levar √† mem√≥ria n√£o inicializada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tamb√©m foram escritas v√°rias regras rigorosas para o analisador est√°tico </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semmle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que s√£o executadas em algumas bases de c√≥digo do Windows. </font><font style="vertical-align: inherit;">Mas esses diagn√≥sticos emitem muito ru√≠do e √© dif√≠cil verificar grandes quantidades de c√≥digo. </font><font style="vertical-align: inherit;">Al√©m disso, a conformidade com essas regras e a corre√ß√£o de erros consome muito tempo. </font><font style="vertical-align: inherit;">Como resultado, ficou dif√≠cil e caro us√°-los.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuzzing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Difusa, como voc√™ sabe, √© dif√≠cil de escalar. </font><font style="vertical-align: inherit;">Os bons difusores s√£o caros para manter e exigem personaliza√ß√£o para tarefas espec√≠ficas. </font><font style="vertical-align: inherit;">Com uma base de c√≥digo de tamanhos como a Microsoft, √© muito dif√≠cil garantir sua cobertura total. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mesmo que fosse poss√≠vel cobrir perfeitamente todo o c√≥digo com eles, os difusores n√£o s√£o capazes de detectar a divulga√ß√£o do conte√∫do da mem√≥ria n√£o inicializada, pois isso n√£o causa uma falha no programa. </font><font style="vertical-align: inherit;">Para detectar esses defeitos usando difus√£o, uma das duas solu√ß√µes √© necess√°ria:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazzer, que entende o protocolo e √© capaz de detectar o retorno de mem√≥ria n√£o inicializada (ou melhor, dados inesperados) nele.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um analisador din√¢mico capaz de detectar o acesso √† mem√≥ria n√£o inicializada.</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revis√£o de c√≥digo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A vis√£o geral do c√≥digo n√£o √© escal√°vel e √© extremamente suscet√≠vel a erros. </font><font style="vertical-align: inherit;">O c√≥digo com vulnerabilidades √© revisado, mas eles s√£o t√£o bem disfar√ßados que os programadores n√£o percebem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A parte do c√≥digo em que encontramos a divulga√ß√£o do conte√∫do da mem√≥ria n√£o inicializada foi gravada nos dias do Windows de 32 bits e, portanto, n√£o havia tais erros. </font><font style="vertical-align: inherit;">Quando ocorreu a transi√ß√£o para arquiteturas de 64 bits, o tamanho dos ponteiros aumentou de 32 para 64 bits, e √© por isso que algumas estruturas t√™m campos de espa√ßo reservado n√£o inicializados.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll - Inicializa√ß√£o autom√°tica</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m das abordagens mencionadas, a Microsoft j√° utiliza h√° algum tempo um mecanismo chamado </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ele inicializa automaticamente as vari√°veis ‚Äã‚Äãde pilha no est√°gio de compila√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesta se√ß√£o, descreverei como essa tecnologia √© usada no Windows e por que dessa maneira.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configura√ß√µes atuais do Windows:</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os seguintes tipos s√£o inicializados automaticamente:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escalar (matrizes, ponteiros, n√∫meros de ponto flutuante)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrizes de ponteiro</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estruturas (Estruturas de Dados Simples - POD)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os seguintes tipos n√£o s√£o inicializados automaticamente:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vari√°veis ‚Äã‚Äãvol√°teis</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrizes de tipos diferentes de ponteiros (ou seja, matrizes de n√∫meros inteiros, matrizes de estruturas etc.)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classes que n√£o s√£o POD</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em montagens de varejo otimizadas, as vari√°veis ‚Äã‚Äãs√£o inicializadas com um valor de 0. Para n√∫meros de ponto flutuante, √© usado um valor de 0,0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assemblies de depura√ß√£o (CHK) ou assemblies para desenvolvedores (ou seja, varejistas n√£o otimizados) usam o valor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xE2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">n√∫meros de ponto flutuante s√£o inicializados para 1.0. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se aplica aos seguintes componentes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo o c√≥digo do reposit√≥rio do Windows em execu√ß√£o no modo kernel (ou seja, todo o c√≥digo compilado com a op√ß√£o / KERNEL) </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo o c√≥digo relacionado ao Hyper-V (hypervisor, componentes no modo kernel, componentes no modo usu√°rio)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√°rios outros projetos, como servi√ßos de rede no modo de usu√°rio</font></font></li>
</ol><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll √©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementado no front-end do compilador. </font><font style="vertical-align: inherit;">Todas as vari√°veis ‚Äã‚Äãque atendem aos crit√©rios listados acima e n√£o s√£o inicializadas pelo programador ser√£o inicializadas pelo frontend na declara√ß√£o. </font><font style="vertical-align: inherit;">Uma das vantagens dessa abordagem √© que, do ponto de vista do otimizador, a inicializa√ß√£o autom√°tica n√£o difere da inicializa√ß√£o pelo desenvolvedor. </font><font style="vertical-align: inherit;">Daqui resulta que as otimiza√ß√µes adicionadas para acelerar o trabalho com </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o est√£o vinculadas apenas a esta fun√ß√£o e funcionar√£o nesses casos quando voc√™ mesmo inicializar as vari√°veis ‚Äã‚Äãao declarar (ou antes de usar).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como evitar o problema de bifurca√ß√£o de idiomas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° um problema com a inicializa√ß√£o autom√°tica do zero: zero √© um significado especial em uma linguagem de programa√ß√£o, especialmente para ponteiros. E este √© talvez o valor mais comum que inicializa vari√°veis ‚Äã‚Äãindividuais. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando inicializado como zero, um ponteiro que n√£o foi inicializado corretamente pelo programador pode cair na ramifica√ß√£o do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ponteiro NULL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Como resultado, voc√™ pode obter um programa que n√£o falha, mas n√£o produz os resultados desejados. Se voc√™ inicializar o ponteiro com um valor de lixo, ele n√£o cair√° na ramifica√ß√£o do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ponteiro NULL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e, se voc√™ tentar us√°-lo, causar√° uma falha no programa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resolvemos esse problema usando um valor de inicializa√ß√£o diferente de zero (0xE2) nas constru√ß√µes CHK e nas chamadas constru√ß√µes para desenvolvedores, que geralmente s√£o constru√ß√µes de vers√£o n√£o otimizadas. Por esse motivo, por um lado, √© poss√≠vel manter o alto desempenho do c√≥digo entregue aos clientes e, por outro lado, obter comportamento em assemblies que est√£o sendo testados, o que facilita a observa√ß√£o de inicializa√ß√µes perdidas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observo que o C ++ j√° requer inicializa√ß√£o autom√°tica zero de todos os membros est√°ticos. </font><font style="vertical-align: inherit;">Essa sem√¢ntica ajuda os desenvolvedores. </font><font style="vertical-align: inherit;">Por exemplo, quando voc√™ v√™ uma vari√°vel est√°tica com um valor zero, saber√° que precisa inicializ√°-la, pois esse √© seu primeiro uso. </font><font style="vertical-align: inherit;">InitAll introduz sem√¢ntica semelhante para vari√°veis ‚Äã‚Äãautom√°ticas (pilha) com uma ressalva importante: tentamos n√£o vincular os desenvolvedores a valores iniciais espec√≠ficos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como escolhemos quais componentes usar InitAll</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> planejava usar em dois componentes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥digo do modo do kernel - principalmente devido ao grande n√∫mero de vulnerabilidades observadas associadas √† mem√≥ria n√£o inicializada do kernel.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O c√≥digo Hyper-V √© principalmente devido √† sua import√¢ncia para o Azure e devido √†s estat√≠sticas recentes decepcionantes sobre casos de divulga√ß√£o do conte√∫do da mem√≥ria de pilha n√£o inicializada.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns na Microsoft descobriram o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e come√ßaram a us√°-lo ativamente em seus componentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O motivo de n√£o implantarmos o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> imediatamente em todo o c√≥digo √© porque queremos fazer pelo menos algo bem primeiro, e n√£o falhar, tentando fazer tudo de uma vez. </font><font style="vertical-align: inherit;">Quanto mais c√≥digo processamos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cada vez, mais dif√≠cil √© depurar quedas de desempenho, resolver problemas de compatibilidade etc. </font><font style="vertical-align: inherit;">Agora que implantamos com sucesso a tecnologia nos componentes mais importantes, voc√™ pode executar o restante do c√≥digo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll quebra a an√°lise est√°tica?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A an√°lise est√°tica √© extremamente √∫til, pois lembra os desenvolvedores das vari√°veis ‚Äã‚Äãque eles esqueceram de inicializar antes do uso. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> notifica o analisador </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PREfast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e o back-end do compilador (ambos d√£o avisos sobre vari√°veis ‚Äã‚Äãn√£o inicializadas) sobre as inicializa√ß√µes adicionadas. </font><font style="vertical-align: inherit;">Gra√ßas a isso, os analisadores est√°ticos podem ignorar esses locais e ainda dar seus avisos. </font><font style="vertical-align: inherit;">Quando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll estiver ativado,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> voc√™ ainda receber√° mensagens do analisador est√°tico sobre vari√°veis ‚Äã‚Äãn√£o inicializadas - mesmo que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll as</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inicialize para voc√™.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que n√£o inicializamos todos os tipos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante os testes preliminares, inicializamos com for√ßa todos os tipos de dados alocados na pilha e observamos quedas de desempenho superiores a 10% em v√°rios cen√°rios importantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se apenas estruturas de POD foram inicializadas, o desempenho n√£o diminuiu muito e as otimiza√ß√µes do compilador destinadas a reduzir o n√∫mero de opera√ß√µes de grava√ß√£o desnecess√°rias (dentro das unidades base e entre elas) nos permitiram reduzir ainda mais a desacelera√ß√£o de qualquer n√≠vel percept√≠vel para o n√≠vel de erro em maioria dos testes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Planejamos voltar √† id√©ia de inicializar todos os tipos (especialmente agora que temos otimiza√ß√µes mais poderosas), apenas n√£o chegamos a esse ponto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que inicializamos vari√°veis ‚Äã‚Äãcom zero</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A inicializa√ß√£o para zero fornece os melhores resultados em termos de desempenho (em termos de velocidade e tamanho bin√°rio), bem como em termos de seguran√ßa.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do ponto de vista da seguran√ßa</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A inicializa√ß√£o zero tem as seguintes vantagens:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ponteiro nulo lan√ßar√° uma exce√ß√£o SEH ao fazer a refer√™ncia no Windows (ou seja, na pior das hip√≥teses, isso causar√° um erro de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nega√ß√£o de servi√ßo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas a execu√ß√£o remota de c√≥digo ser√° imposs√≠vel), que geralmente termina com uma falha no programa.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma vari√°vel que especifica um tamanho ou √≠ndice receber√° um valor nulo. </font><font style="vertical-align: inherit;">Isso deve minimizar o risco de passar o tamanho n√£o inicializado para fun√ß√µes como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trabalhando com um buffer cujo tamanho √© fornecido pelo valor da vari√°vel passada.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s verificar o ponteiro nulo, o programa executar√° o ramo correspondente e n√£o tentar√° us√°-lo. </font><font style="vertical-align: inherit;">Portanto, pelo menos, ser√° poss√≠vel processar corretamente os ponteiros que o desenvolvedor esqueceu de inicializar (j√° que uma tentativa de acessar a mem√≥ria usando um ponteiro inicializado automaticamente sempre causar√° uma falha).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vari√°veis ‚Äã‚Äãde um tipo booleano com o valor 0 significam "false", o que nos testes pode indicar um estado de erro.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A inicializa√ß√£o com zero tamb√©m tem algumas desvantagens:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A vari√°vel NTSTATUS ter√° o valor STATUS_SUCCESS </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HRESULT ser√° S_OK </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas os valores retornados podem ser muito diferentes e n√£o existe um valor universal √∫nico para inicializar todos eles, principalmente considerando que ele tamb√©m deve ser usado para tamanhos, √≠ndices, ponteiros etc.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do ponto de vista do desempenho</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A velocidade do programa e o tamanho do c√≥digo tamb√©m dependem do valor de inicializa√ß√£o selecionado. </font><font style="vertical-align: inherit;">N√£o medimos o qu√£o piores foram os resultados ao usar um valor diferente de zero, pois est√°vamos interessados ‚Äã‚Äãprincipalmente nos benef√≠cios de seguran√ßa que a inicializa√ß√£o d√° zero e sab√≠amos que ao mesmo tempo isso teria um efeito positivo no desempenho (velocidade e tamanho do c√≥digo). </font><font style="vertical-align: inherit;">Nossos colegas do Google fizeram medi√ß√µes e mostraram que, no Clang, a inicializa√ß√£o com zero no momento √© visivelmente mais lucrativa do que a inicializa√ß√£o com um valor diferente de zero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abaixo, mostrarei por exemplos porque, ao inicializar com zero, menos c√≥digo √© obtido.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo 1: Inicializa√ß√£o usando registros de uso geral</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializa√ß√£o por zero:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">31</span> c0                            <span class="hljs-keyword">xor</span>    eax,eax
<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>                         mov    QWORD PTR [rcx],rax</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializa√ß√£o com um valor diferente de zero:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">48</span> b8 e2 e2 e2 e2 e2 e2 e2 e2    movabs rax,<span class="hljs-number">0xe2e2e2e2e2e2e2e2</span>
<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>                         mov    QWORD PTR [rcx],rax</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste exemplo, estamos interessados ‚Äã‚Äãem dois pontos: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, definir o registro RAX como zero requer 2 bytes de c√≥digo versus 10 bytes quando definido como um valor diferente de zero. Acontece um ganho tanto no tamanho do c√≥digo quanto na velocidade. Muitos processadores leem instru√ß√µes de 16 bytes por vez, portanto, escrever uma constante fixa no registro usando uma instru√ß√£o de 10 bytes impede a emiss√£o das seguintes instru√ß√µes que podem ser executadas em paralelo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em segundo lugar, antes que seja poss√≠vel gravar o valor no registro RCX, √© necess√°rio aguardar a conclus√£o da grava√ß√£o no RAX, o que pode levar ao processador inativo. </font><font style="vertical-align: inherit;">Sequ√™ncias como ‚Äúxor eax, eax‚Äù s√£o reconhecidas nas primeiras partes do pipeline, e a execu√ß√£o real do comando XOR n√£o √© necess√°ria - os processadores simplesmente redefinem o registro RAX. </font><font style="vertical-align: inherit;">Como resultado, o pipeline fica ocioso por menos tempo e o programa √© executado mais rapidamente.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo 2: Inicializa√ß√£o Usando Registros XMM</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para escrever valores maiores, o compilador geralmente usa registradores XMM (assim como YMM ou ZMM, dependendo se o suporte para os conjuntos de instru√ß√µes AVX ou AVX512 est√° ativado). </font><font style="vertical-align: inherit;">Como regra, os processadores n√£o podem concluir mais de um comando de grava√ß√£o em um ciclo de clock, portanto, seria aconselh√°vel usar comandos que configurem o m√°ximo de bytes poss√≠vel. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializa√ß√£o por zero:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">0f</span> <span class="hljs-number">57</span> c0                         xorps  xmm0,xmm0<font></font>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializa√ß√£o com um valor diferente de zero (carregado de uma vari√°vel global, o que os compiladores geralmente fazem):</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">66</span> <span class="hljs-number">0f</span> <span class="hljs-number">6f</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       movdqa xmm0,XMMWORD PTR ds:<span class="hljs-number">0x0</span>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializa√ß√£o com um valor diferente de zero (carregado de uma constante fixa no c√≥digo, que os compiladores n√£o fazem):</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">48</span> ba e2 e2 e2 e2 e2 e2 e2 e2    movabs rdx,<span class="hljs-number">0xe2e2e2e2e2e2e2e2</span>
<span class="hljs-number">66</span> <span class="hljs-number">48</span> <span class="hljs-number">0f</span> <span class="hljs-number">6</span>e c2                   movq   xmm0,rdx
<span class="hljs-number">0f</span> <span class="hljs-number">16</span> c0                         movlhps xmm0,xmm0<font></font>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como voc√™ pode ver, no caso do XMM registra a mesma imagem √© observada. Quando inicializado como zero, o c√≥digo √© muito pequeno. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o √© poss√≠vel gravar uma constante fixa diretamente no registro XMM. Primeiro, voc√™ deve salv√°-lo no registro geral; da√≠, mova-o para o registro XMM e, em seguida, copie os 64 bits baixos do registro XMM nos 64 bits altos. Como resultado, obtemos um c√≥digo longo e tr√™s comandos, cada um dos quais deve aguardar a conclus√£o do anterior.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para evitar isso, os compiladores, em regra, salvam uma constante fixa na forma de uma vari√°vel global, a partir da qual eles podem ler o valor - isso resulta em muito menos c√≥digo. Infelizmente, √© necess√°rio aguardar at√© o final da grava√ß√£o no registro XMM antes que ele fique dispon√≠vel para uso. Se uma vari√°vel global for descarregada da mem√≥ria, a opera√ß√£o poder√° demorar v√°rios milhares de ciclos de clock. Uma opera√ß√£o de leitura leva v√°rios ciclos de rel√≥gio, mesmo no melhor cen√°rio, quando os dados s√£o armazenados no cache L1. E mesmo nesse caso, o c√≥digo √© muito mais longo do que se voc√™ apenas redefinir o registro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso revela outra vantagem da inicializa√ß√£o zero: resultados mais determin√≠sticos. O tempo de inicializa√ß√£o n√£o depende se a vari√°vel global est√° no cache L1, L2 ou L3, se est√° descarregada da mem√≥ria, etc.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observa√ß√µes interessantes relacionadas ao uso do InitAll</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atua√ß√£o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Windows 10 1903 (lan√ßado na primavera de 2019) foi a primeira vers√£o na qual </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> foi ativado por padr√£o. </font><font style="vertical-align: inherit;">At√© o momento, n√£o recebemos nenhuma reclama√ß√£o sobre a degrada√ß√£o do desempenho devido a isso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compatibilidade</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anticheat</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Logo ap√≥s ativar o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no Windows, come√ßamos a receber reclama√ß√µes sobre falhas no kernel causadas por alguns programas anti-fraude. </font><font style="vertical-align: inherit;">Ap√≥s examinar o problema, descobrimos que esses programas continham drivers no modo kernel que examinavam a imagem do kernel do NT na mem√≥ria e procuravam sequ√™ncias de bytes espec√≠ficas indicando o in√≠cio de fun√ß√µes n√£o documentadas. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adicionou inicializa√ß√µes adicionais (cuja redund√¢ncia n√£o p√¥de ser comprovada) no in√≠cio dessas fun√ß√µes, por causa das quais suas assinaturas foram alteradas. </font><font style="vertical-align: inherit;">Entramos em contato com os desenvolvedores desses antiv√≠rus e, a nosso pedido, eles atualizaram seus drivers para que n√£o causassem mais falhas no kernel.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando mem√≥ria liberada no FAT32</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Logo ap√≥s ativar o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para tipos de dados escalares (ou seja, n√∫meros inteiros, n√∫meros de ponto flutuante etc.), encontramos um problema interessante no driver do sistema de arquivos FAT, que n√£o permitia a atualiza√ß√£o de assemblies internos do Windows a partir de unidades flash USB inicializ√°veis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O c√≥digo no qual o problema ocorreu tinha algo parecido com isto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<font></font>
{<font></font>
      <span class="hljs-keyword">int</span> tmp;<font></font>
      DoStuff(&amp;tmp, i);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° um loop no qual uma vari√°vel √© declarada. Na primeira itera√ß√£o do loop, a fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DoStuff</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inicializa a vari√°vel 'tmp', cujo endere√ßo √© passado como argumento. A cada itera√ß√£o subsequente, a vari√°vel 'tmp' √© usada como par√¢metro de entrada / sa√≠da. Em outras palavras, seu valor √© lido primeiro e depois atualizado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema √© que a vari√°vel em quest√£o no in√≠cio de cada itera√ß√£o do loop entra em seu escopo e a deixa no final da itera√ß√£o. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inicializa essa vari√°vel para zero antes de cada itera√ß√£o. De fato, temos uma vulnerabilidade de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uso ap√≥s livre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Para opera√ß√£o normal do c√≥digo, √© necess√°rio que a vari√°vel 'tmp' retenha seu valor a cada itera√ß√£o, mesmo que, no final da itera√ß√£o, fique fora do escopo. </font><font style="vertical-align: inherit;">Infelizmente, esse problema n√£o levou a uma falha do driver, mas a uma l√≥gica incorreta de sua opera√ß√£o e, como resultado, um comportamento imprevis√≠vel do sistema de arquivos. </font><font style="vertical-align: inherit;">Durante a depura√ß√£o, a equipe do kernel determinou a causa do problema e o corrigiu retirando a vari√°vel do loop. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este caso √© um bom exemplo de como as melhorias de seguran√ßa podem quebrar c√≥digos que n√£o s√£o analisados ‚Äã‚Äãh√° anos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otimiza√ß√µes de desempenho</font></font></h2><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
otimiza√ß√µes de desempenho </font><i><font style="vertical-align: inherit;">do InitAll</font></i><font style="vertical-align: inherit;"> t√™m </font><font style="vertical-align: inherit;">tr√™s objetivos:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fornecer aos desenvolvedores a capacidade de desativar o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para c√≥digo cr√≠tico</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se poss√≠vel, remova opera√ß√µes desnecess√°rias de grava√ß√£o</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acelere o m√°ximo poss√≠vel das opera√ß√µes de grava√ß√£o restantes</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desativando InitAll for Critical Code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As otimiza√ß√µes mais √≥bvias s√£o deixar o c√≥digo:</font></font><ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desativar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll completamente</font></font></i></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desative </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para um tipo espec√≠fico (ou seja, estrutura typedef)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desative </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para todas as opera√ß√µes de aloca√ß√£o de mem√≥ria na fun√ß√£o</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desative </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para uma declara√ß√£o de vari√°vel espec√≠fica em uma fun√ß√£o</font></font></li>
</ol><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
momento, o </font><i><font style="vertical-align: inherit;">InitAll est√°</font></i><font style="vertical-align: inherit;"> desativado (por </font><i><font style="vertical-align: inherit;">motivos de</font></i><font style="vertical-align: inherit;"> desempenho) para um √∫nico tipo - a estrutura _CONTEXT, que armazena os valores de todos os registros. A inicializa√ß√£o for√ßada levou a uma diminui√ß√£o no desempenho nos testes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A estrutura </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_CONTEXT</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tem um tamanho superior a 1000 bytes, e isso √© suficiente para armazenar os valores de todos os registros. Com o log de ETW ativado para rastrear op√ß√µes de contexto, sempre que o contexto √© alterado, os valores de todos os registros s√£o registrados. A estrutura </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_CONTEXT</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">neste caso, ser√° alocada na pilha, preenchida com uma fun√ß√£o assembler e depois passada para o ETW. Devido ao fato de a estrutura ser inicializada por uma fun√ß√£o assembler, o compilador n√£o pode remover a inicializa√ß√£o feita</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Como essa estrutura j√° cont√©m dados cr√≠ticos (o estado de cada registro), √© grande e √© usada em filiais extremamente exigentes em termos de desempenho, decidimos n√£o aplicar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a ele </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para todos os outros tipos, vari√°veis ‚Äã‚Äãe fun√ß√µes, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o </font><i><font style="vertical-align: inherit;">foi desativado</font></i><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Removendo opera√ß√µes de grava√ß√£o desnecess√°rias</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A remo√ß√£o de opera√ß√µes de grava√ß√£o desnecess√°rias √© uma otimiza√ß√£o realizada pelo compilador do Visual Studio, que remove as opera√ß√µes de grava√ß√£o que podem ser redundantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A seguir, exemplos de diferentes tipos de otimiza√ß√£o usados ‚Äã‚Äãpelo Visual Studio.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Removendo v√°rios memset</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link para Godbolt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/Ldu7AP</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
O seguinte padr√£o de c√≥digo (com varia√ß√µes diferentes) √© extremamente comum. As regras de programa√ß√£o inicial do NT exigem que todas as vari√°veis ‚Äã‚Äãsejam declaradas no in√≠cio da fun√ß√£o e inicializadas o mais tarde poss√≠vel. Como resultado, temos casos em que uma vari√°vel √© declarada no in√≠cio de uma fun√ß√£o e √© inicializada apenas em qualquer ramo imediatamente antes do uso. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adiciona sua inicializa√ß√£o de vari√°vel no in√≠cio da fun√ß√£o. O compilador pode remover a duplicata, mas isso nem sempre √© f√°cil de fazer.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">160</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> b = <span class="hljs-literal">true</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
  <font></font>
    <span class="hljs-keyword">if</span> (b) <span class="hljs-comment">//  volatile-,</span>
           <span class="hljs-comment">//        </span>
           <span class="hljs-comment">// (   ,      )</span><font></font>
    {<font></font>
        Dummy();<font></font>
        <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x1</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
        DoStuff(&amp;s);<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/hq/dl/ee/hqdleeuo4icifkr9_ijrp0rt_ps.png" alt="Quadro 4"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que este exemplo simples deve ser facilmente otimizado, no entanto, o GCC 9.3 e o Clang 10.0.0 (as √∫ltimas vers√µes dispon√≠veis no Godbolt) n√£o conseguem, neste caso, remover a chamada extra do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">N√£o estou falando sobre isso para criticar esses compiladores - ambos otimizam o c√≥digo muito bem. </font><font style="vertical-align: inherit;">Eu s√≥ quero mostrar que alguns padr√µes podem causar dificuldades, mesmo para os compiladores mais poderosos. </font><font style="vertical-align: inherit;">Antes do advento do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e das otimiza√ß√µes relacionadas, o Visual Studio n√£o conseguia remover a chamada extra. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um exemplo ainda mais simples:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
entre duas chamadas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">h√° apenas uma chamada de fun√ß√£o sem argumentos. </font><font style="vertical-align: inherit;">Esse padr√£o, como o anterior, √© muito comum no c√≥digo da Microsoft. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link para Godbolt:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/HqFMx_</font></font></a><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">160</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    Dummy();<font></font>
<font></font>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x1</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    DoStuff(&amp;s);<font></font>
<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/fe/qo/7e/feqo7evdydknbjjwx9wwlvxt61a.png" alt="Quadro 3"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC remove o excesso de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> neste exemplo. Clique no 10.0.0 - tamb√©m, mas o GCC 9.3 ainda falha. Parece que esse c√≥digo pode ser facilmente otimizado, mas, para isso, o compilador precisa realizar an√°lises n√£o triviais. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema aqui (no MSVC) √© que o compilador usa a an√°lise de acessibilidade de objetos, independentemente da ramifica√ß√£o ou do fluxo de execu√ß√£o. Do ponto de vista do compilador, a vari√°vel 'escapa' da fun√ß√£o atual (em outras palavras, seu endere√ßo √© passado em algum lugar fora dessa fun√ß√£o), j√° que seu endere√ßo √© passado para a fun√ß√£o 'DoStuff'. O compilador tamb√©m v√™ uma chamada para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's', depois uma chamada para 'Dummy', seguida por outra chamada para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's'.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Do ponto de vista do compilador, como a vari√°vel 's' "escapou" da fun√ß√£o, a fun√ß√£o 'Dummy' poderia teoricamente ler o conte√∫do dos 's' ou modific√°-lo antes de chamar a fun√ß√£o 'DoStuff'. </font><font style="vertical-align: inherit;">Isso significa que uma chamada para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o pode ser exclu√≠da antes ou depois de 'Dummy'. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vimos que, embora a vari√°vel 's' tamb√©m ‚Äúescape‚Äù da fun√ß√£o atual, isso n√£o acontece antes que a fun√ß√£o 'DoStuff' seja chamada. </font><font style="vertical-align: inherit;">O compilador MSVC agora tamb√©m entende isso (em um grau ou outro) e pode remover a primeira chamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redu√ß√£o de tamanho de Memset</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link para Godbolt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/fyLVUF</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
O padr√£o a seguir tamb√©m n√£o √© incomum. </font><font style="vertical-align: inherit;">A estrutura √© parcialmente inicializada e depois transferida para outra fun√ß√£o. </font><font style="vertical-align: inherit;">√â prov√°vel que esta segunda fun√ß√£o inicialize o restante dos dados da estrutura (ou pelo menos n√£o os leia), mas o compilador n√£o pode provar isso.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">320</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> b = <span class="hljs-literal">true</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (b) <span class="hljs-comment">//  volatile-,</span>
           <span class="hljs-comment">//        </span>
           <span class="hljs-comment">// (   ,      )</span><font></font>
    {<font></font>
        Dummy();<font></font>
        <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s)<span class="hljs-number">-0x160</span>);<font></font>
        DoStuff(&amp;s);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/qv/zv/ix/qvzvix4pxzqvazgvfzafdg_zraa.png" alt="Quadro 2"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O MSVC agora pode aparar o tamanho do primeiro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para inicializar apenas os elementos na estrutura que o segundo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o inicializa </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Novamente, o GCC 9.3 e o Clang 10.0.0 ainda n√£o sabem como fazer essa otimiza√ß√£o neste exemplo.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Varredura memset mais eficiente</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link para Godbolt</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
No exemplo a seguir, a chamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o pode ser removida. </font><font style="vertical-align: inherit;">Portanto, deve ser realizado da maneira mais eficiente poss√≠vel.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">12</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
    DoStuff(&amp;s);<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/fm/yf/7v/fmyf7vxnqesyecgskxvarcbgyc4.png" alt="Imagem 1"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O MSVC (como a maioria dos compiladores) pode "implantar" pequenas chamadas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com um tamanho definido estatisticamente e um valor de preenchimento. Ou seja, a chamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© substitu√≠da por uma sequ√™ncia de comandos de grava√ß√£o diretamente na mem√≥ria. Gra√ßas a essa otimiza√ß√£o, o tempo de execu√ß√£o de pequenas chamadas do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (at√© 128 bytes) √© reduzido para um quarto do habitual com uma quantidade menor de c√≥digo (n√£o h√° necessidade de salvar os valores do registro na pilha, chamar o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e restaurar o estado dos registradores). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC usado para implantar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no AMD64 usando registros de uso geral. </font><font style="vertical-align: inherit;">Agora, ele usa registradores vetoriais, o que permite implantar chamadas com o dobro do tamanho. </font><font style="vertical-align: inherit;">Como resultado, obtemos o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mais r√°pido </font><font style="vertical-align: inherit;">e n√£o deixamos o c√≥digo crescer. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementa√ß√µes de memset mais produtivas: analisaremos</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
esse item em detalhes outra vez.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor do Usu√°rio</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desde o lan√ßamento do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , muitas das vulnerabilidades relatadas pelos usu√°rios ao MSRC pararam de ser reproduzidas nas vers√µes recentes do Windows. Gra√ßas ao </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> essas vulnerabilidades </font><i><font style="vertical-align: inherit;">evolu√≠ram</font></i><font style="vertical-align: inherit;"> de "problemas de seguran√ßa" para "defeitos de c√≥digo que atualmente n√£o t√™m consequ√™ncias negativas". Isso significa que n√£o precisamos mais fornecer atualiza√ß√µes de seguran√ßa para os sistemas operacionais j√° lan√ßados com o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instalado </font><font style="vertical-align: inherit;">, o que evita os usu√°rios da dor de cabe√ßa que acompanha a instala√ß√£o dos patches e a Microsoft da dor de cabe√ßa que acompanha o seu desenvolvimento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em nossas ramifica√ß√µes ativas do reposit√≥rio, ainda melhoramos o c√≥digo e corrigimos erros, al√©m de fazer altera√ß√µes nos sistemas operacionais j√° lan√ßados nos quais </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaparecidos e, portanto, ainda vulner√°veis. </font><font style="vertical-align: inherit;">Com o tempo, as vers√µes sem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o ser√£o mais suportadas. </font><font style="vertical-align: inherit;">Quando isso acontece, os erros neutralizados com o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ser√£o corrigidos apenas nas ramifica√ß√µes de desenvolvimento ativas e, nos sistemas atuais, esse tipo de defeito n√£o precisar√° mais ser corrigido.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planos futuros</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No momento, planejamos lidar com duas tarefas principais no contexto de problemas com vari√°veis ‚Äã‚Äãde pilha n√£o inicializadas:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estudar e usar a possibilidade de aplicar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a todos os tipos de dados alocados (ou seja, matrizes de todos os tipos e classes, e n√£o apenas de POD)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implante </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em todo o c√≥digo do Windows.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No futuro, planejamos descobrir se √© poss√≠vel padronizar o processo de elimina√ß√£o dos tipos de problemas descritos em C e C ++. N√£o √© necess√°rio deixar vari√°veis ‚Äã‚Äãn√£o inicializadas por padr√£o por causa do desempenho (especialmente se o compilador puder otimizar opera√ß√µes de grava√ß√£o redundantes). Em vez disso, seria melhor exigir que o desenvolvedor inicialize as vari√°veis ‚Äã‚Äãantes do uso ", se essa necessidade tiver sido comprovada" e permitir que essa regra seja violada apenas se uma palavra-chave especial for usada para vari√°veis ‚Äã‚Äãn√£o inicializadas. Essa solu√ß√£o preservaria o alto desempenho e, ao mesmo tempo, salvaria os programadores de erros desnecess√°rios.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Planejamos publicar outra observa√ß√£o sobre o trabalho em andamento para neutralizar vulnerabilidades de mem√≥ria n√£o inicializadas no mecanismo para alocar um pool de mem√≥ria no kernel do Windows.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coment√°rio do tradutor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O artigo quase n√£o est√° relacionado ao meu t√≥pico nativo de an√°lise de c√≥digo est√°tico, mas parecia interessante para mim e eu queria compartilhar a tradu√ß√£o com um p√∫blico de l√≠ngua russa. </font><font style="vertical-align: inherit;">Por mim, quero acrescentar que os problemas de seguran√ßa associados ao "vazamento" de dados privados geralmente consistem em dois componentes. </font><font style="vertical-align: inherit;">Primeiro: existe um local onde os dados privados devem ser apagados, mas isso n√£o acontece ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V597</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Segundo: dados privados n√£o limpos como parte da mem√≥ria n√£o inicializada podem ser transferidos para algum lugar ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exemplo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt505476/index.html">API CRUD no Deno e PostegreSQL: trabalhando com um dinossauro</a></li>
<li><a href="../pt505478/index.html">Substituindo um sistema CRM por um sistema CRM</a></li>
<li><a href="../pt505488/index.html">12 dicas para implementar o TypeScript em aplicativos React</a></li>
<li><a href="../pt505494/index.html">Desenvolvedor Framing</a></li>
<li><a href="../pt505496/index.html">Flutter Dev Podcast com o CTO Meduza Boris Goryachev: o principal sobre o aplicativo Meduz e o desenvolvimento de m√≠dia</a></li>
<li><a href="../pt505502/index.html">Omnichannel no atendimento ao cliente: o que procurar e como fazer tudo certo?</a></li>
<li><a href="../pt505506/index.html">Ele n√£o morde: como tornar os rob√¥s industriais seguros para os trabalhadores</a></li>
<li><a href="../pt505508/index.html">N√£o apenas tecnologia n√£o tripulada: o futuro da ind√∫stria automotiva</a></li>
<li><a href="../pt505510/index.html">Simplificando a API do Check Point com o Python SDK</a></li>
<li><a href="../pt505516/index.html">Aprendizado de m√°quina: por onde come√ßar ou como construir o primeiro modelo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>