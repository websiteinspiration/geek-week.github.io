<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>〽️ 🕤 ♊️ Python中的Befunge编译器 〽️ 🖱️ ⚒️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在为四年级学生准备“编译器基础”课程时，我学习了各种深奥的编程语言。这是一篇有关该主题的好文章。在我看来，Befunge语言（克里斯出版社，1993年）似乎是最有趣的，我特别注意到它的三个功能：
 
 

1. 程序字段是一个二维圆环，即 实际上，这是符号命令的矩形矩阵，沿着上（下）边界和左（右）列...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Python中的Befunge编译器</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/494132/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在为四年级学生准备“编译器基础”课程时，我学习了各种深奥的编程语言。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一篇有关该主题的好文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在我看来，Befunge语言（克里斯出版社，1993年）似乎是最有趣的，我特别注意到它的三个功能：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序字段是一个二维圆环，即 </font><font style="vertical-align: inherit;">实际上，这是符号命令的矩形矩阵，沿着上（下）边界和左（右）列闭合。</font><font style="vertical-align: inherit;">命令指针在字段中移动（每个命令都是具有x，y坐标的特定字符），执行该命令，然后继续前进。</font><font style="vertical-align: inherit;">可以在所有4个方向上移动（默认情况下，从0,0点开始），并且当您超出“字段”时，指针将显示在相反的一侧。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语言中有两个命令（p，g）会更改字段本身，即 </font><font style="vertical-align: inherit;">该程序在执行过程中是“自我重写”的。</font><font style="vertical-align: inherit;">开头的程序代码可能不等于结尾的代码。</font><font style="vertical-align: inherit;">程序“ 123pgpg ## @”启动，程序“ ABC @ 1 @ 2 @ 3.14”（不是正确的示例）完成工作。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">克里斯·普莱斯（Chris Pressy）指出，他想创建一种尽可能复杂的语言来进行编译。事实上，的确如此，创建了一个使exe文件难以执行的编译器，我发现有人可以用C语言完成此操作的信息...最好创建从该语言到Python代码的翻译器，我仍然称其为为简单起见，编译器。</font></font></li>
</ol><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1993年的计划字段包括25行，每行80个字符。该语言有36个小组，每个小组都是一个ASCII表字符。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关更多信息，请参见Wikipedia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我将在此处进行简要说明：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动命令（9）：</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&gt;右移</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;左移</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
^向上移</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
v向下移</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
_如果堆栈顶部为0，则向右移，否则向左移。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
|如果在堆栈0的顶部，则向下移动，否则向上。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
？沿随机方向移动</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
＃跳过下一个单元格（“跳板”）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
@程序结束</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈操作命令（3）</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
::将顶点副本放在堆栈上</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
\交换顶部和底部</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
$删除顶部</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对程序代码（2）的命令修改：</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
p“ PUT”：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从堆栈中提取</font><font style="vertical-align: inherit;">单元格坐标和位于这些坐标处的字符的ASCII码</font><font style="vertical-align: inherit;">g“ GET”：从堆栈中提取单元格坐标；这些坐标处的符号的ASCII码被</font><b><font style="vertical-align: inherit;">压入</font></b><font style="vertical-align: inherit;">堆栈</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常量命令（2）：</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
0-9将数字放在</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
符号模式</font><font style="vertical-align: inherit;">堆栈的</font><font style="vertical-align: inherit;">开始/结束位置，在该模式下，所有当前程序符号的ASCII码都被</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">压入</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈</font><b><font style="vertical-align: inherit;">。算术运算（5）：</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
+顶点和顶点的</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 加法- </font><font style="vertical-align: inherit;">顶点和顶点的</font><font style="vertical-align: inherit;">减法</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* </font><font style="vertical-align: inherit;">顶点和顶点的</font><font style="vertical-align: inherit;">相乘</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
/整数除法</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
％</font><font style="vertical-align: inherit;">余数</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈命令和逻辑操作（2）</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
：！否定：将顶点上的零替换为1，将非零值替换为0。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比较“大于”：如果顶点大于顶点，则将1放置在堆栈上，否则使用0 </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I / O命令（4）：</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
＆请求用户输入数字并将其放置在堆栈上</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
〜向用户询问一个字符并将其ASCII码放在堆栈上</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。将堆栈顶部打印为整数</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
，</font><font style="vertical-align: inherit;">在堆栈顶部</font><font style="vertical-align: inherit;">打印与ASCII代码相对应的字符</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我决定根据1993年的规则用Python编写Befunge编译器（解释器），但有两个限制：1）该字段不是25x80字符，而是文本块的最小宽度和高度; 2）该字段未循环成圆环，即 </font><font style="vertical-align: inherit;">越过边界跳到另一侧将不被处理。</font><font style="vertical-align: inherit;">这不是懒惰（尽管，我在跟谁开玩笑吗？），举个小例子，一切都很好，并且要完成一个真正的圆环很简单，就会有一种愿望。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该代码不必要地在“额头上”出现在某些地方，但这是由于它是针对学生的，其任务是尽可能清晰，而不是用中文缩写成两行。</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第1部分</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该代码从头到尾都提供了一个例外（将被指定），可以将其复制到文件中并运行。</font><font style="vertical-align: inherit;">全文可在链接</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rentry.co/ivansedov-befunge上找到</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，对我来说在GitHub上提供</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">最好</font></a><font style="vertical-align: inherit;">的东西为时尚早。</font><font style="vertical-align: inherit;">顺便说一下，那里大约有20种Befunge语言实现，但是代码要么是C语言（不是我的语言），要么是Python语言，但它是如此复杂，以至于我不敢涉猎。</font><font style="vertical-align: inherit;">但是，您可以在此处</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">获取</font></a><font style="vertical-align: inherit;">用于测试的示例程序，例如，此处</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/causal-agent/befungee</font></font></a> <br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> *
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> random
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
导入库： </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要sys库才能获取程序文件的名称。</font><font style="vertical-align: inherit;">我的编译器名为bbb.py，这是同一目录1.bf中的测试示例，Python版本3.7本身，因此控制台中的程序调用如下所示：python3 bbb.py 1.bf</font></font></li>
<li> time    ,   ,    0,5-1,0       . </li>
<li> random       «?» ( ),        . -,  Befunge  -    ,     « »     (1 , 2 , 3 , 4 ).    « »     . </li>
</ol><br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pointer</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>, vector=<span class="hljs-number">2</span>, value=None</span>):</span><font></font>
        self.x = x<font></font>
        self.y = y<font></font>
        self.vector = vector<font></font>
        self.value = value<font></font>
        self.stack = []<font></font>
        self.stack_sf = <span class="hljs-number">0</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Point ({},{}) vektor:{} value:{} stack_sf:{} stack:{}'</span>.format(self.x, self.y, self.vector, self.value, self.stack_sf, self.stack)<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">if</span> self.vector == <span class="hljs-number">1</span>:<font></font>
            self.x -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">elif</span> self.vector == <span class="hljs-number">2</span>:<font></font>
            self.y += <span class="hljs-number">1</span>
        <span class="hljs-keyword">elif</span> self.vector == <span class="hljs-number">3</span>:<font></font>
            self.x += <span class="hljs-number">1</span>
        <span class="hljs-keyword">elif</span> self.vector == <span class="hljs-number">4</span>:<font></font>
            self.y -= <span class="hljs-number">1</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self</span>):</span>
	<span class="hljs-comment">#   ,   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
程序中使用的主要类：指针（pointer），具有6个属性和2个方法。属性：1）x坐标（初始= 0），2）y坐标（初始= 0），3）向量（运动方向，初始= 2向右），4）值（位于x，y坐标处的字段值，初始=无），实际上，这是要执行的命令； 5）堆栈（程序堆栈，初始= []）和6）stack_st（用于输入行的标志，初始= 0）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该类有两种方法：1）步骤（）指针步骤，无需进行任何检查和测试，即可根据向量中的方向更改x，y坐标，以及2）action（）是编译器的心脏，执行当前程序命令。我将在第二部分中给出action（）代码，以便它不会偏离逻辑。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># ===============================</span>
<span class="hljs-comment"># =                      =</span>
<span class="hljs-comment"># ===============================</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open_file</span>(<span class="hljs-params">name</span>):</span>
    data = open(name, <span class="hljs-string">'r'</span>).read()
    <span class="hljs-keyword">return</span> data<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">field_print</span>():</span>
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> A:
        <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> row:<font></font>
            print(elem, end=<span class="hljs-string">''</span>)<font></font>
        print()  <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
两个辅助功能：1）open_file（名称）按提交的名称打开文件，读取并返回内容，2）field_print（）打印数组A的内容，程序字符位于该数组中。</font><font style="vertical-align: inherit;">创建数组A如下所示。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># ===========================================</span>
<span class="hljs-comment"># =                       =</span>
<span class="hljs-comment"># ===========================================</span><font></font>
<font></font>
numbers = [<span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span>]<font></font>
operators = [<span class="hljs-string">'+'</span>, <span class="hljs-string">'-'</span>, <span class="hljs-string">'*'</span>, <span class="hljs-string">'/'</span>, <span class="hljs-string">'%'</span>]<font></font>
point = Pointer()                           <span class="hljs-comment">#  </span>
text = open_file(argv[<span class="hljs-number">1</span>]).split(<span class="hljs-string">"\n"</span>)       <span class="hljs-comment">#  </span>
n = len(text)                               <span class="hljs-comment"># n =  </span>
m = <span class="hljs-number">0</span>                                       <span class="hljs-comment"># m =  </span><font></font>
<font></font>
<span class="hljs-comment">#    (   m)</span>
<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> text:
    <span class="hljs-keyword">if</span> len(line) &gt; m:<font></font>
        m = len(line)<font></font>
<font></font>
<span class="hljs-comment">#   ( n  m )</span>
A = [<span class="hljs-string">' '</span>] * n
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):<font></font>
    A[i] = [<span class="hljs-string">' '</span>] * m<font></font>
<font></font>
<span class="hljs-comment">#    </span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(text)):
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(text[i])):<font></font>
        A[i][j] = text[i][j]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本程序设置。</font><font style="vertical-align: inherit;">在数字列表中，我们输入了可以在程序中写入的所有数字（从0到9）（10个不再适合，两个字符）。</font><font style="vertical-align: inherit;">在运算符列表中，我们放置了基本算术运算符。</font><font style="vertical-align: inherit;">创建一个point = Pointer对象（默认设置），我们将一直使用它...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在变量文本中，我们放入了可执行程序的读取文本，并用“换行”符号将其打断。结果，文本由多行不同长度的文本组成，必须将其放置在矩形矩形空间中。很容易找到行数n = len（文本），但必须根据文本中包含的行的最大长度来计算列数。我没有找到另一种方法来完成此额头：遍历所有行，找到长度最大的行。有了n和m（future字段的行数和列数），您可以创建一个二维数组，在其中填充空格，然后遍历文本以将字符放置在它们的位置。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果是一个字符矩形，其间有空格，所有这些都是n×m的二维矩阵。</font><font style="vertical-align: inherit;">完成这些设置后，您可以调用field_print（）函数，并确保所有内容看起来都很漂亮，没有任何浮空且没有违反这种情况。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># ==========================================</span>
<span class="hljs-comment"># =                       =</span>
<span class="hljs-comment"># ==========================================</span><font></font>
<font></font>
<span class="hljs-comment"># field_print()</span><font></font>
<font></font>
<span class="hljs-keyword">while</span> point.value != <span class="hljs-string">'@'</span>:
    <span class="hljs-keyword">try</span>:<font></font>
        point.value = A[point.x][point.y]       <span class="hljs-comment"># 1)    point</span>
        point.action()                          <span class="hljs-comment"># 2)  </span>
        <span class="hljs-comment"># print(point)                            # 3) :  </span>
        <span class="hljs-comment"># time.sleep(0.5)                         # 4) :  0.5 c</span>
    <span class="hljs-keyword">except</span> IndexError:                          <span class="hljs-comment">#     =  </span>
        print(<span class="hljs-string">'     '</span>)
        <span class="hljs-keyword">break</span><font></font>
<font></font>
<span class="hljs-comment"># field_print()</span><font></font>
print()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切都以主程序（循环）结尾，在此之前和之后您可以显示该字段（有时很有用）。</font><font style="vertical-align: inherit;">循环旋转直到指针指向“ @”符号（“＆”，“ dog”，程序结尾）为止。</font><font style="vertical-align: inherit;">在周期内，每次执行4次操作：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在point.value属性中，读取数组A中坐标为point.x，point.y的字符。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用point.action（）方法，在该方法中执行当前（仅读取）命令</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指针显示在屏幕上（所有属性）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在下一次迭代之前进行延迟（0.1秒-0.5秒）</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
项目3和4完全是可选的（甚至被注释掉了），但是我建议使用它们进行测试。</font><font style="vertical-align: inherit;">循环中的所有操作都会捕获IndexError错误（错误超出索引限制），这使您可以截获两个主要的编译器错误：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们转向堆栈，没有任何值</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不小心超出了程序（数组）的宽度或高度</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
需要最后一个空print（），以便在显示输出后，控制台可以从新行开始工作。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第2部分</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在是时候编写最重要的代码了-Pointer类的point.action（）方法的内容。</font><font style="vertical-align: inherit;">下面的所有内容都应插入其编写位置：</font></font><br>
<br>
<pre><code class="python hljs">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params">self</span>):</span>
	<span class="hljs-comment">#   ,   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意缩进：</font></font><br>
<br>
<pre><code class="python hljs">        <span class="hljs-keyword">if</span> self.value == <span class="hljs-string">'"'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:                <span class="hljs-comment"># ,  "</span>
            self.stack_sf = <span class="hljs-number">1</span>
        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'"'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">1</span>:<font></font>
            self.stack_sf = <span class="hljs-number">0</span>
        <span class="hljs-keyword">elif</span> self.stack_sf == <span class="hljs-number">1</span>:                                    <span class="hljs-comment"># "Hello"   </span><font></font>
            self.stack.append(ord(self.value))<font></font>
        <span class="hljs-keyword">elif</span> self.value <span class="hljs-keyword">in</span> numbers <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:
            <span class="hljs-comment"># 123   </span><font></font>
            self.stack.append(int(self.value))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，action（）中的代码有很多条件，当此命令位于指针下方时，将执行每个条件。一切都始于条件“如果当前命令=引号并且行stack_sf的开头的标志= 0”，在这种情况下，标志升至1。我们进入了行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（否则）如果当前命令=引号，并且该标志升至1，则意味着第二次找到引号，并且必须停止输入字符串（stack_sf标志降低为0）。我们不合时宜。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（否则）如果前两个条件不起作用并且标志stack_sf = 1，则我们“位于行内”，需要将当前符号的代码添加到堆栈中。不是字符本身，而是其ASCII代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（否则）如果当前字符在数字元素之间并且标志为stack_sf = 0，则这首先是一个数字，其次我们不在行内，我们需要将当前字符=数字添加到堆栈中。不添加字符代码，而是添加字符本身。仍然记住，有一个数字1，并且她的代码= 49。因此，如果我们在行内，则需要将49添加到堆栈中，如果它只是在程序中，则应将命令1添加到堆栈1中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此后，所有条件都是省略号（否则，如果...），所以我只写它们“如果”。另外，所有条件都是双重的，您需要检查当前字符是否与命令相等，以及我们不在字符串内的事实（在字符串内，所有字符的处理方式均不同）。您可以以更优化的方式编写所有这些内容，但是此解决方案使您可以将注意力集中在此额头上。</font></font><br>
<br>
<pre><code class="python hljs">        <span class="hljs-keyword">elif</span> self.value <span class="hljs-keyword">in</span> operators <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:<font></font>
            b = self.stack.pop()<font></font>
            a = self.stack.pop()<font></font>
            <span class="hljs-keyword">if</span> self.value == <span class="hljs-string">'+'</span>:<font></font>
                res = a + b                                         <span class="hljs-comment"># a+b  </span>
            <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'-'</span>:<font></font>
                res = a - b                                         <span class="hljs-comment"># a-b  </span>
            <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'*'</span>:<font></font>
                res = a * b                                         <span class="hljs-comment"># a*b  </span>
            <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'/'</span>:
                <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:<font></font>
                    res = <span class="hljs-number">0</span>
                <span class="hljs-keyword">else</span>:<font></font>
                    res = a // b                                    <span class="hljs-comment"># a//b  </span>
            <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'%'</span>:<font></font>
                res = a % b                                         <span class="hljs-comment"># a%b  </span><font></font>
            self.stack.append(res)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前字符在运算符之间（并且stack_sf = 0），则意味着我们进入了算术运算。</font><font style="vertical-align: inherit;">它们都是完全相同的：1）将数字b删除（删除），2）将数字a删除（删除），3）res = a和b之间的运算值，4）res被压入堆栈。</font><font style="vertical-align: inherit;">除以0时，答案为0，尽管该语言的作者提供了选择0或1的语言。</font></font><br>
<br>
<pre><code class="python hljs">        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'!'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:<font></font>
            a = self.stack.pop()<font></font>
            <span class="hljs-keyword">if</span> a == <span class="hljs-number">0</span>:<font></font>
                a = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:<font></font>
                a = <span class="hljs-number">0</span>
            <span class="hljs-comment"># 0-&gt;1, 1-&gt;0</span><font></font>
            self.stack.append(a)<font></font>
<font></font>
        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'`'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:<font></font>
            a = self.stack.pop()        <span class="hljs-comment"># </span>
            b = self.stack.pop()        <span class="hljs-comment"># </span>
            <span class="hljs-keyword">if</span> b &gt; a:<font></font>
                res = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:<font></font>
                res = <span class="hljs-number">0</span>
            <span class="hljs-comment"># b&gt;a -&gt; 1|0</span><font></font>
            self.stack.append(res)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前字符为“！”，则需要替换堆栈的头（顶点）：它为0-将变为1，与0有所不同-将为1。如果当前字符为“»”（撇号），则需要检查顶部和书脊：1）如果顶点大于顶点，则为1，2）如果顶点小于（或等于）顶点，则将0放置在堆栈上。请注意，在删除比较对象时，它们将被删除（删除），而不是被复制。</font></font><br>
<br>
<pre><code class="python hljs">        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'?'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:
            <span class="hljs-comment"># ? ( )</span>
            a = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<font></font>
            self.vector = a<font></font>
<font></font>
        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">':'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:              <span class="hljs-comment">#  </span><font></font>
            last = self.stack.pop()<font></font>
            self.stack.append(last)<font></font>
            self.stack.append(last)<font></font>
<font></font>
        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'\\'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:             <span class="hljs-comment"># ab =&gt; ba</span><font></font>
            a = self.stack.pop()<font></font>
            b = self.stack.pop()<font></font>
            self.stack.append(a)<font></font>
            self.stack.append(b)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前字符是“？”，则需要选择一个随机方向并沿其前进。我们使用random.randint（1，4）函数，该函数生成数字1,2,3,4并将新值放入point.vector中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前字符为“：”，则将堆栈顶部的副本（即，读取它，然后将其添加到堆栈两次。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前字符为“ \\”（反斜杠），则需要交换顶点和子顶点。我们得到两个数字，以相反的顺序将它们放在堆栈中。</font></font><br>
<br>
<pre><code class="python hljs">        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'#'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:              <span class="hljs-comment">#  ""</span><font></font>
            self.step()<font></font>
<font></font>
        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">','</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:              <span class="hljs-comment"># =65=A</span><font></font>
            value = self.stack.pop()<font></font>
            print(chr(value), end=<span class="hljs-string">''</span>)<font></font>
<font></font>
        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'.'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:              <span class="hljs-comment"># Print </span><font></font>
            a = self.stack.pop()<font></font>
            print(a, end=<span class="hljs-string">''</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前符号为“＃”（磅），则必须跳过下一个（方向）命令。请注意，在动作（）的末尾有一个无条件的跳转self.step（），它使您可以前进到下一个命令。将self.step（）写入“＃”处理后，我们实际上进行了两次跳转，并在“＃”之后的下一个命令“跳过”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前字符为“，”（逗号），则需要打印其ASCII码位于堆栈顶部的字符。如果存在数字65，则应显示“ A”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前字符为“。” （点），然后您需要打印位于堆栈顶部的数字，就像一个数字一样。如果存在65，则需要显示“ 65”。在这两种情况下，在输出期间都将设置end =''参数，以便不存在新的换行符。</font></font><br>
<br>
<pre><code class="python hljs">        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'_'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:              <span class="hljs-comment">#  "_"</span><font></font>
            test = self.stack.pop()<font></font>
            <span class="hljs-keyword">if</span> test == <span class="hljs-number">0</span>:
                <span class="hljs-comment">#  = 0, (2)</span>
                self.vector = <span class="hljs-number">2</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment">#  !=0, (4)</span>
                self.vector = <span class="hljs-number">4</span><font></font>
<font></font>
        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'|'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:              <span class="hljs-comment">#  "|"</span><font></font>
            test = self.stack.pop()<font></font>
            <span class="hljs-keyword">if</span> test == <span class="hljs-number">0</span>:<font></font>
                self.vector = <span class="hljs-number">3</span>
            <span class="hljs-keyword">else</span>:<font></font>
                self.vector = <span class="hljs-number">1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前字符为“ _”（下划线），则水平检查。我们从堆栈中删除要检查（测试）的数字，如果它等于0，那么我们向右移动（向量= 2），如果它等于0，那么我们向左移动（向量= 4）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前字符=“ |” （垂直条），那么您需要进行垂直检查。我们从堆栈中删除数字（测试），如果它等于0，则向下移动（向量= 3），否则向上移动（向量= 1）。</font></font><br>
<br>
<pre><code class="python hljs">        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'$'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:              <span class="hljs-comment">#  </span><font></font>
            self.stack.pop()<font></font>
<font></font>
        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'~'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:              <span class="hljs-comment"># Input: A =&gt; 65</span>
            val = input(<span class="hljs-string">' : '</span>)<font></font>
            self.stack.append(ord(val[<span class="hljs-number">0</span>]))<font></font>
<font></font>
        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'&amp;'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:              <span class="hljs-comment"># Input: 65 =&gt; 65</span>
            val = int(input(<span class="hljs-string">' : '</span>))<font></font>
            self.stack.append((val))<font></font>
<font></font>
        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'p'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:              <span class="hljs-comment"># x, y, symcode</span>
            x = self.stack.pop()                                    <span class="hljs-comment"># A(x,y) = symcode</span><font></font>
            y = self.stack.pop()<font></font>
            symcode = self.stack.pop()<font></font>
            A[x][y] = chr(symcode)<font></font>
<font></font>
        <span class="hljs-comment"># x, y, value=A(x,y)</span>
        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'g'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:<font></font>
            x = self.stack.pop()                                    <span class="hljs-comment"># ord(value) =&gt; </span><font></font>
            y = self.stack.pop()<font></font>
            value = A[x][y]<font></font>
            self.stack.append(ord(value))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前字符=“ $”，则需要删除顶点。制作简单的pop（）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前字符=“〜”（波浪号），那么我们要求用户输入一个字符并将其ASCII码放在堆栈上。发送用户“ A”（英语）时，必须将65放在堆栈中，以防万一，我们将val [0]放入，否则用户可以输入“ Apple”并将其转换为代码无效。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前字符=“＆”（“＆”号），那么我们要求用户输入一个数字并将该数字放在堆栈中。您输入65，需要将65放入堆栈，</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在是两个最困难的团队。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前字符=“ p”，则需要从堆栈中提取单元格坐标和该字符的ASCII代码，然后将此字符放在字段A的这些坐标中。假设堆栈上有1.2.65，我们得到（1.2）和65，则应在单元格（1.2）中放入符号“ A”。我再次指出：我们得到了三个数字，并在坐标中放置了一个符号。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果当前字符=“ g”，则从堆栈中检索单元格坐标，在字段上搜索该单元格，从那里获取该字符并将其ASCII码压入堆栈中。假设符号“ B”躺在单元格（2,3）中的字段上，当前团队获得“ g”，而我们从堆栈中获得2,3。在这种情况下，我们沿着坐标（2,3），从那里得到符号“ B”，将其转换为数字66（符号代码B），然后将66放入堆栈。</font></font><br>
<br>
<pre><code class="python hljs">        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'&gt;'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:              <span class="hljs-comment"># &gt;</span>
            self.vector = <span class="hljs-number">2</span>
        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'&lt;'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:              <span class="hljs-comment"># &lt;</span>
            self.vector = <span class="hljs-number">4</span>
        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'^'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:              <span class="hljs-comment"># ^</span>
            self.vector = <span class="hljs-number">1</span>
        <span class="hljs-keyword">elif</span> self.value == <span class="hljs-string">'v'</span> <span class="hljs-keyword">and</span> self.stack_sf == <span class="hljs-number">0</span>:              <span class="hljs-comment"># v</span>
            self.vector = <span class="hljs-number">3</span>
        self.step()                                                 <span class="hljs-comment">#  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，这是最后几行代码：跨字段移动指针的组织。</font><font style="vertical-align: inherit;">这里的一切都很简单：我们查看符号并更改方向（矢量）。</font><font style="vertical-align: inherit;">action（）函数的最后是self.step（），它在当前方向上迈出了一步。</font><font style="vertical-align: inherit;">因此，动作（）既是动作的执行，也是下一个字符的步骤。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编写此编译器是一种乐趣。当您向程序中添加特定代码并执行（正确执行）时，带来了多少欢乐。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befungius.aurlien.net</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网站在工作时提供了很多帮助</font><font style="vertical-align: inherit;">，作者在</font><font style="vertical-align: inherit;">该网站</font><font style="vertical-align: inherit;">上发布了Befunge在线解释器（使用JavaScript）。这是他在一些会议</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.youtube.com/watch?v=oCPT3L33848上的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频</font><font style="vertical-align: inherit;">，其中他谈到了这种语言。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于测试，您可以使用Befunge上几乎任何程序，除了需要将字段作为圆环的程序，即朝着世界的不同方向过渡。对于某些程序，您需要查看字段本身（例如，计数器程序会更改坐标A [0] [1]），因此请在屏幕上插入此坐标的输出或在每个步骤之后显示整个矩阵A。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无论如何，这不是一个让人眼花shine乱的程序，而是可以添加和编辑的培训代码。</font><font style="vertical-align: inherit;">打字错误是可能的，尽管我已经测试了很多次。</font><font style="vertical-align: inherit;">批评是不受欢迎的，但也不被禁止。</font><font style="vertical-align: inherit;">祝大家好运，并提供良好的代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
你好，世界！</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-number">0</span><span class="hljs-string">"!dlrow olleH"</span>&gt;:<span class="hljs-comment">#,_@</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
巴兹</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-number">0</span>&gt; <span class="hljs-number">1</span>+:<span class="hljs-number">3</span>%v<font></font>
&gt;^  v%<span class="hljs-number">5</span>:_:<span class="hljs-number">5</span>% v<font></font>
,v.:_v     v0_0<span class="hljs-string">"zzub"</span>v
<span class="hljs-string">"v         #
     &gt;0"</span>zzu<span class="hljs-string">b"v
"</span>   v<span class="hljs-string">"fizz"</span>&lt;         &lt;<font></font>
^&lt;         $&lt;&gt;:<span class="hljs-comment">#,_v</span>
    &gt;      <span class="hljs-comment">#^^#   &lt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
斐波那契</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-number">62</span>*<span class="hljs-number">1</span>+v&gt;<span class="hljs-number">01</span>p001&gt;+v&gt;\:<span class="hljs-number">02</span>p\:<span class="hljs-number">02</span>gv
     <span class="hljs-number">0</span>       ^             &lt;<font></font>
     .         :p<font></font>
     <span class="hljs-string">"         .1
        v 0,"</span> <span class="hljs-string">"&lt;0
     "</span>  &gt;<span class="hljs-number">1</span>g12-+:|<font></font>
     ,          @<font></font>
     &gt;^<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
计数</font></font><br>
<br>
<pre><code class="python hljs">&gt;<span class="hljs-number">91</span>+:<span class="hljs-number">9</span>`v<font></font>
p   v  _v<font></font>
    &gt;$<span class="hljs-number">0</span> v<font></font>
^ <span class="hljs-number">01</span>+*<span class="hljs-number">68</span>&lt;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但这是行不通的</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-number">0</span>&gt;:<span class="hljs-number">00</span>p58*`<span class="hljs-comment">#@_0&gt;:01p78vv$$&lt;</span>
<span class="hljs-meta">@^+1g00,+55_v# !`\+*9&lt;&gt;4v$</span>
<span class="hljs-meta">@v30p20"?~^"&lt; ^+1g10,+*8&lt;$</span>
<span class="hljs-meta">@&gt;p0\&gt;\::*::882**02g*0v &gt;^</span>
`*:*<span class="hljs-string">" d"</span>:+*:-*<span class="hljs-string">"[Z"</span>+g3 &lt; |&lt;<font></font>
v-*<span class="hljs-string">"[Z"</span>+g30*g20**<span class="hljs-number">288</span>\--\&lt;<span class="hljs-comment">#</span>
&gt;<span class="hljs-number">2</span>**<span class="hljs-number">5</span><span class="hljs-comment">#&gt;8*:*/00g"P"*58*:*v^</span>
v*<span class="hljs-number">288</span> p20/**<span class="hljs-number">288</span>:+*<span class="hljs-string">"[Z"</span>+-&lt;:<font></font>
&gt;*%<span class="hljs-number">03</span> p58*:*/<span class="hljs-number">01</span>g<span class="hljs-string">"3"</span>* v&gt;::^<font></font>
   \_^<span class="hljs-comment">#!:-1\+-*2*:*85&lt;^</span>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接和其他材料：</font></font></b><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整代码</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在线版</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">她在用JavaScript</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（英文）</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiki文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（英语）</font></font></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN494118/index.html">COVID-19 Telegram-bot //我们自动回答常见问题</a></li>
<li><a href="../zh-CN494124/index.html">组装8位计算机：如何将芯片数减少到6</a></li>
<li><a href="../zh-CN494126/index.html">最佳科学。二月媒体十：螃蟹僵尸女权主义者，史前Sal和夸张的酒鬼</a></li>
<li><a href="../zh-CN494128/index.html">Hackspace Neuron-莫斯科黑客的聚会场所</a></li>
<li><a href="../zh-CN494130/index.html">在线事件发生了什么：我们的一些统计数据</a></li>
<li><a href="../zh-CN494136/index.html">滴什么东西以免痒</a></li>
<li><a href="../zh-CN494140/index.html">使用思科威胁响应调查DNSpionage活动，包括远程工作</a></li>
<li><a href="../zh-CN494150/index.html">阿维托的ClickHouse：与Alexey Milovidov的现场聚会</a></li>
<li><a href="../zh-CN494152/index.html">HoughNet：搜索与经典算法融合的消失点</a></li>
<li><a href="../zh-CN494154/index.html">我们如何将视频编码加速八倍</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>