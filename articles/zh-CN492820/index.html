<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🚒 🚹 🖤 .Net Core Api：在来自不同来源的请求中获取数据 🍔 🧜🏿 🏴‍☠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".Net Core具有内置的模型绑定机制，该机制不仅允许接受控制器中的输入参数，而且还可以立即接收具有填充字段的对象。这使您可以使用模型验证将所有必要的检查嵌入到这样的对象中。
 
 这些只是API运作所需的数据，而不仅仅是从Query或Body获得的。需要从Headers接收一些数据（在我的情况下...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.Net Core Api：在来自不同来源的请求中获取数据</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492820/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.Net Core具有内置的模型绑定机制，该机制不仅允许接受控制器中的输入参数，而且还可以立即接收具有填充字段的对象。</font><font style="vertical-align: inherit;">这使您可以使用模型验证将所有必要的检查嵌入到这样的对象中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些只是API运作所需的数据，而不仅仅是从Query或Body获得的。</font><font style="vertical-align: inherit;">需要从Headers接收一些数据（在我的情况下，base64中存在json），如果您使用REST，则某些数据应该来自外部服务或ActionRoute。</font><font style="vertical-align: inherit;">您可以使用绑定从那里获取数据。</font><font style="vertical-align: inherit;">没错，这里有一个问题：如果您决定不破坏封装并通过构造函数初始化模型，那么您将不得不进行萨满。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于我自己和子孙后代，我决定写一些类似的说明，以结合使用Binding和萨满教。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
典型的控制器如下所示：</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">HttpGet</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;IActionResult&gt; <span class="hljs-title">GetSomeData</span>(<span class="hljs-params">[FromQuery[IncomeData someData</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> moreData = GetFromHeaderAndDecode(<span class="hljs-string">"X-Property"</span>);
    <span class="hljs-keyword">if</span> (moreData.Id == <span class="hljs-number">0</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> StatusCode(<span class="hljs-number">400</span>, <span class="hljs-string">"Nginx doesnt know your id"</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> externalData = GetFromExternalService(<span class="hljs-string">"http://myservice.com/MoreData"</span>);
    <span class="hljs-keyword">if</span> (externalData == <span class="hljs-literal">null</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> StatusCode(<span class="hljs-number">500</span>, <span class="hljs-string">"Cant connect to external service"</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> finalData = <span class="hljs-keyword">new</span> FinalData(someData, moreData, externalData);
    <span class="hljs-keyword">return</span> _myService.Handle(finalData);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，我们遇到以下问题：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">验证逻辑由请求对象，标头中的请求方法，服务中的请求方法和控制器方法涂抹。</font><font style="vertical-align: inherit;">为确保绝对必要的检查，您需要进行整个调查！</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相邻的控制器方法将具有完全相同的代码。</font><font style="vertical-align: inherit;">攻击中的复制粘贴编程。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，比示例中的检查要多得多，因此，唯一重要的一行（对业务逻辑处理方法的调用）隐藏在代码堆中。</font><font style="vertical-align: inherit;">要见到他并了解这里发生的情况，通常需要付出一些努力。</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自定义绑定（简易模式）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过在请求处理管道中实现您的处理程序，可以解决部分问题。</font><font style="vertical-align: inherit;">为此，首先通过将最终对象立即传递给方法来更正我们的控制器。</font><font style="vertical-align: inherit;">看起来好多了吧？</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">HttpGet</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;IActionResult&gt; <span class="hljs-title">GetSomeData</span>(<span class="hljs-params">[FromQuery]FinalData finalData</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _myService.Handle(finalData);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，为类型MoreData创建活页夹。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MoreDataBinder</span> : <span class="hljs-title">IModelBinder</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">BindModelAsync</span>(<span class="hljs-params">ModelBindingContext bindingContext</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> moreData = GetFromHeaderAndDecode(bindingContext.HttpContext.Request.Headers);
        <span class="hljs-keyword">if</span> (moreData != <span class="hljs-literal">null</span>)<font></font>
        {<font></font>
            bindingContext.Result = ModelBindingResult.Success(moreData);<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> Task.CompletedTask;<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> MoreData <span class="hljs-title">GetFromHeaderAndDecode</span>(<span class="hljs-params">IHeaderDictionary headers</span>)</span> { ... }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我们通过将活页夹绑定添加到该属性来修复FinalData模型：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FinalData</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> SomeDataNumber { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> SomeDataText { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
    [<span class="hljs-meta">ModelBinder(BinderType = typeof(MoreDataBinder))</span>]
    <span class="hljs-keyword">public</span> MoreData MoreData { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它已经好了，但是痔疮增加了：现在您需要知道我们有一个特殊的处理器，并在所有型号中进行注明。</font><font style="vertical-align: inherit;">但这是可以解决的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建您的BinderProvider：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MoreDataBinderProvider</span> : <span class="hljs-title">IModelBinderProvider</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> IModelBinder <span class="hljs-title">GetBinder</span>(<span class="hljs-params">ModelBinderProviderContext context</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> modelType = context.Metadata.UnderlyingOrModelType;
        <span class="hljs-keyword">if</span> (modelType == <span class="hljs-keyword">typeof</span>(MoreData))<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BinderTypeModelBinder(<span class="hljs-keyword">typeof</span>(MoreDataBinder));<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并在启动中注册：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureServices</span>(<span class="hljs-params">IServiceCollection services</span>)</span><font></font>
{<font></font>
    services.AddControllers();<font></font>
    services.AddMvc(options =&gt;<font></font>
    {<font></font>
        options.ModelBinderProviders.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MoreDataBinderProvider());<font></font>
     });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将按队列顺序为每个模型对象调用提供程序。</font><font style="vertical-align: inherit;">如果我们的提供者符合所需的类型，它将返回所需的活页夹。</font><font style="vertical-align: inherit;">如果没有，则默认活页夹将起作用。</font><font style="vertical-align: inherit;">因此，现在无论何时指定MoreData的类型，都将从Header中获取并解码它，并且无需在模型中指定特殊属性。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自定义绑定（硬模式）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这一切都很棒，但是还有一件事：为了使魔术发挥作用，我们的模型必须具有设置的公共属性。</font><font style="vertical-align: inherit;">但是封装呢？</font><font style="vertical-align: inherit;">如果我想将请求数据传输到云中的各个地方并且知道在那里将不会更改该怎么办？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
问题是默认绑定程序不适用于没有默认构造函数的模型。</font><font style="vertical-align: inherit;">但是是什么阻止我们编写自己的呢？</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我为其编写此代码的服务不使用REST，仅通过Query和Body传输参数，并且仅使用两种类型的请求-Get </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 和Post。</font><font style="vertical-align: inherit;">因此，在REST API的情况下，处理逻辑将略有不同。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，代码将保持不变，只有我们的活页夹需要改进，以便它创建一个对象并填充其私有字段。</font><font style="vertical-align: inherit;">此外，我将给出一些带有注释的代码，这些代码不感兴趣-在文章的最后，该类的整个清单。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，让我们确定MoreData是否是该类的唯一属性。</font><font style="vertical-align: inherit;">如果是，那么您需要自己创建对象（hello，Activator），否则，JsonConvert可以完美地完成工作，而我们只需将必要的数据放入属性中即可。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">NeedActivator</span>(<span class="hljs-params">IReflect modelType</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> propFlags = BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance;
    <span class="hljs-keyword">var</span> properties = modelType.GetProperties(propFlags);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> properties.Select(p =&gt; p.Name).Distinct().Count() == <span class="hljs-number">1</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过JsonConvert创建对象很简单，对于使用Body进行查询：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">object</span>? GetModelFromBody(ModelBindingContext bindingContext, Type modelType)<font></font>
{<font></font>
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> StreamReader(bindingContext.HttpContext.Request.Body);
    <span class="hljs-keyword">var</span> jsonString = reader.ReadToEnd();
    <span class="hljs-keyword">var</span> data = JsonConvert.DeserializeObject(jsonString, modelType);
    <span class="hljs-keyword">return</span> data;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是使用查询我不得不放下。</font><font style="vertical-align: inherit;">如果有人可以提出更美丽的解决方案，我将感到非常高兴。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
传递数组时，将获得多个具有相同名称的参数。</font><font style="vertical-align: inherit;">强制转换为平面类型会有所帮助，但是序列化会在数组[]上加上多余的引号，必须手动将其删除。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">object</span>? GetModelFromQuery(ModelBindingContext bindingContext, Type modelType)<font></font>
{<font></font>
    <span class="hljs-keyword">var</span> valuesDictionary = QueryHelpers.ParseQuery(bindingContext.HttpContext.Request.QueryString.Value);
    <span class="hljs-keyword">var</span> jsonDictionary = valuesDictionary.ToDictionary(pair =&gt; pair.Key, pair =&gt; pair.Value.Count &lt; <span class="hljs-number">2</span> ? pair.Value.ToString() : <span class="hljs-string">$"[<span class="hljs-subst">{pair.Value}</span>]"</span>);<font></font>
<font></font>
    <span class="hljs-keyword">var</span> jsonStr = JsonConvert.SerializeObject(jsonDictionary).Replace(<span class="hljs-string">"\"["</span>, <span class="hljs-string">"["</span>).Replace(<span class="hljs-string">"]\""</span>, <span class="hljs-string">"]"</span>);
    <span class="hljs-keyword">var</span> data = JsonConvert.DeserializeObject(jsonStr, modelType);
    <span class="hljs-keyword">return</span> data;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，创建对象时，有必要将我们的数据写入其私有属性。</font><font style="vertical-align: inherit;">我在本文开头谈到的正是这种萨满教。</font><font style="vertical-align: inherit;">我在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到了这个解决方案</font><font style="vertical-align: inherit;">，对此非常感谢作者。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ForceSetValue</span>(<span class="hljs-params">PropertyInfo propertyInfo, <span class="hljs-keyword">object</span> obj, <span class="hljs-keyword">object</span> <span class="hljs-keyword">value</span></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> propName = <span class="hljs-string">$"&lt;<span class="hljs-subst">{propertyInfo.Name}</span>&gt;k__BackingField"</span>;
    <span class="hljs-keyword">var</span> propFlags = BindingFlags.Instance | BindingFlags.NonPublic;<font></font>
            <font></font>
    obj.GetType().GetField(propName, propFlags)?.SetValue(obj, <span class="hljs-keyword">value</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，我们将这些方法合并在一个调用中：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">BindModelAsync</span>(<span class="hljs-params">ModelBindingContext bindingContext</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> moreData = GetFromHeaderAndDecode(bindingContext.HttpContext.Request.Headers);
    <span class="hljs-keyword">if</span> (moreData == <span class="hljs-literal">null</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> Task.CompletedTask;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">var</span> modelType = bindingContext.ModelMetadata.UnderlyingOrModelType;
    <span class="hljs-keyword">if</span> (NeedActivator(modelType))<font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> data = Activator.CreateInstance(modelType, moreData);<font></font>
        bindingContext.Result = ModelBindingResult.Success(data);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> Task.CompletedTask;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">var</span> model = bindingContext.HttpContext.Request.Method == <span class="hljs-string">"GET"</span><font></font>
                            ? GetModelFromQuery(bindingContext, modelType)<font></font>
                            : GetModelFromBody(bindingContext, modelType);<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (model <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"  "</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">var</span> ignoreCase = StringComparison.InvariantCultureIgnoreCase;
    <span class="hljs-keyword">var</span> dataProperty = modelType.GetProperties()<font></font>
                            .FirstOrDefault(p =&gt; p.Name.Equals(<span class="hljs-keyword">typeof</span>(T).Name, ignoreCase));<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (dataProperty != <span class="hljs-literal">null</span>)<font></font>
    {<font></font>
        ForceSetValue(dataProperty, model, moreData);<font></font>
    }<font></font>
<font></font>
    bindingContext.Result = ModelBindingResult.Success(model);<font></font>
    <span class="hljs-keyword">return</span> Task.CompletedTask;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仍然需要修复BinderProvider，以便它以所需的属性响应任何类：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MoreDataBinderProvider</span> : <span class="hljs-title">IModelBinderProvider</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> IModelBinder <span class="hljs-title">GetBinder</span>(<span class="hljs-params">ModelBinderProviderContext context</span>)</span><font></font>
    {<font></font>
       <span class="hljs-keyword">var</span> modelType = context.Metadata.UnderlyingOrModelType;
       <span class="hljs-keyword">if</span> (HasDataProperty(modelType))<font></font>
       {<font></font>
           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BinderTypeModelBinder(<span class="hljs-keyword">typeof</span>(PrivateDataBinder&lt;MoreData&gt;));<font></font>
       }<font></font>
       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">HasDataProperty</span>(<span class="hljs-params">IReflect modelType</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> propFlags = BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance;
        <span class="hljs-keyword">var</span> properties = modelType.GetProperties(propFlags);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> properties.Select(p =&gt; p.Name) .Contains(<span class="hljs-keyword">nameof</span>(MoreData));<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就这样。</font><font style="vertical-align: inherit;">事实证明，活页夹比简单模式下要复杂一些，但是现在我们可以在所有控制器的所有方法中绑定“外部”属性，而无需付出额外的努力。</font><font style="vertical-align: inherit;">缺点：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有私有字段的对象的构造函数必须指定[JsonConstrustor]属性。</font><font style="vertical-align: inherit;">但这完全符合模型的逻辑，并且不会干扰模型的感知。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在某个地方，您可能需要从头文件中获取MoreData。</font><font style="vertical-align: inherit;">但这通过创建一个单独的类来处理。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">团队的其他成员必须意识到魔术的存在。</font><font style="vertical-align: inherit;">但是文档将挽救人性。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成的活页夹的完整列表在这里：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PrivateMoreDataBinder.cs</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PrivateDataBinder</span>&lt;T&gt; : <span class="hljs-title">IModelBinder</span><font></font>
    {<font></font>
        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span><span class="hljs-doctag">&lt;/summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="bindingContext"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">BindModelAsync</span>(<span class="hljs-params">ModelBindingContext bindingContext</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> moreData = GetFromHeaderAndDecode(bindingContext.HttpContext.Request.Headers);
            <span class="hljs-keyword">if</span> (moreData == <span class="hljs-literal">null</span>)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> Task.CompletedTask;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">var</span> modelType = bindingContext.ModelMetadata.UnderlyingOrModelType;
            <span class="hljs-keyword">if</span> (NeedActivator(modelType))<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> data = Activator.CreateInstance(modelType, moreData);<font></font>
                bindingContext.Result = ModelBindingResult.Success(data);<font></font>
<font></font>
                <span class="hljs-keyword">return</span> Task.CompletedTask;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">var</span> model = bindingContext.HttpContext.Request.Method == <span class="hljs-string">"GET"</span><font></font>
                            ? GetModelFromQuery(bindingContext, modelType)<font></font>
                            : GetModelFromBody(bindingContext, modelType);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (model <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>)<font></font>
            {<font></font>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"  "</span>);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">var</span> ignoreCase = StringComparison.InvariantCultureIgnoreCase;
            <span class="hljs-keyword">var</span> dataProperty = modelType.GetProperties()<font></font>
                                        .FirstOrDefault(p =&gt; p.Name.Equals(<span class="hljs-keyword">typeof</span>(T).Name, ignoreCase));<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (dataProperty != <span class="hljs-literal">null</span>)<font></font>
            {<font></font>
                ForceSetValue(dataProperty, model, moreData);<font></font>
            }<font></font>
<font></font>
            bindingContext.Result = ModelBindingResult.Success(model);<font></font>
<font></font>
            <span class="hljs-keyword">return</span> Task.CompletedTask;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">object</span>? GetModelFromQuery(ModelBindingContext bindingContext,<font></font>
                                                 Type modelType)<font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> valuesDictionary = QueryHelpers.ParseQuery(bindingContext.HttpContext.Request.QueryString.Value);<font></font>
<font></font>
            <span class="hljs-keyword">var</span> jsonDictionary = valuesDictionary.ToDictionary(pair =&gt; pair.Key, pair =&gt; pair.Value.Count &lt; <span class="hljs-number">2</span> ? pair.Value.ToString() : <span class="hljs-string">$"[<span class="hljs-subst">{pair.Value}</span>]"</span>);<font></font>
<font></font>
            <span class="hljs-keyword">var</span> jsonStr = JsonConvert.SerializeObject(jsonDictionary)<font></font>
                                     .Replace(<span class="hljs-string">"\"["</span>, <span class="hljs-string">"["</span>)<font></font>
                                     .Replace(<span class="hljs-string">"]\""</span>, <span class="hljs-string">"]"</span>);<font></font>
<font></font>
            <span class="hljs-keyword">var</span> data = JsonConvert.DeserializeObject(jsonStr, modelType);<font></font>
<font></font>
            <span class="hljs-keyword">return</span> data;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">object</span>? GetModelFromBody(ModelBindingContext bindingContext,<font></font>
                                                Type modelType)<font></font>
        {<font></font>
            <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> StreamReader(bindingContext.HttpContext.Request.Body);
            <span class="hljs-keyword">var</span> jsonString = reader.ReadToEnd();
            <span class="hljs-keyword">var</span> data = JsonConvert.DeserializeObject(jsonString, modelType);<font></font>
<font></font>
            <span class="hljs-keyword">return</span> data;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">NeedActivator</span>(<span class="hljs-params">IReflect modelType</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> propFlags = BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance;
            <span class="hljs-keyword">var</span> properties = modelType.GetProperties(propFlags);<font></font>
<font></font>
            <span class="hljs-keyword">return</span> properties.Select(p =&gt; p.Name).Distinct().Count() == <span class="hljs-number">1</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ForceSetValue</span>(<span class="hljs-params">PropertyInfo propertyInfo, <span class="hljs-keyword">object</span> obj, <span class="hljs-keyword">object</span> <span class="hljs-keyword">value</span></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> propName = <span class="hljs-string">$"&lt;<span class="hljs-subst">{propertyInfo.Name}</span>&gt;k__BackingField"</span>;
            <span class="hljs-keyword">var</span> propFlags = BindingFlags.Instance | BindingFlags.NonPublic;<font></font>
            <font></font>
            obj.GetType().GetField(propName, propFlags)?.SetValue(obj, <span class="hljs-keyword">value</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">GetFromHeaderAndDecode</span>(<span class="hljs-params">IHeaderDictionary headers</span>)</span> { <span class="hljs-keyword">return</span> (T)Activator.CreateInstance(<span class="hljs-keyword">typeof</span>(T), <span class="hljs-keyword">new</span> <span class="hljs-keyword">object</span>[] { <span class="hljs-string">"ok"</span> }); }<font></font>
    }<font></font>
</code></pre><br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN492806/index.html">如何将参与度与手机游戏和应用中的获利联系起来</a></li>
<li><a href="../zh-CN492808/index.html">应急灯开关位置传感器</a></li>
<li><a href="../zh-CN492810/index.html">[COVID-19]您的任务是平滑峰</a></li>
<li><a href="../zh-CN492812/index.html">尝试在OpenVINO中运行GAN网络</a></li>
<li><a href="../zh-CN492816/index.html">IntelliJ IDEA技巧和窍门：4.同步和共享设置</a></li>
<li><a href="../zh-CN492822/index.html">CSS开发人员-为什么世界需要它们？</a></li>
<li><a href="../zh-CN492828/index.html">如何在一个封闭的世界中生存</a></li>
<li><a href="../zh-CN492830/index.html">默认情况下，SameSite = Lax-已在Chrome 80稳定版中运行（尽管并非所有人）</a></li>
<li><a href="../zh-CN492832/index.html">用于基于i.MX6和Linux的工业协议的IoT网关</a></li>
<li><a href="../zh-CN492834/index.html">LVM和俄罗斯套娃有什么共同点？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>