<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏾 🤲🏿 😕 アクションの本カフカストリーム。リアルタイムアプリケーションとマイクロサービス» 🕴🏿 🌦️ 🦑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、habrozhiteli！この本は、ストリーミング処理を理解したい開発者に適しています。分散プログラミングを理解すると、KafkaとKafka Streamsをよりよく理解するのに役立ちます。 Kafkaフレームワーク自体を知っておくとよいでしょうが、必ずしもそうである必要はありません。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>アクションの本カフカストリーム。リアルタイムアプリケーションとマイクロサービス»</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/457756/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/na/mw/fb/namwfbeornc4ba8jkaodlvjlm68.jpeg" align="left" alt="画像"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、habrozhiteli！この本は、ストリーミング処理を理解したい開発者に適しています。分散プログラミングを理解すると、KafkaとKafka Streamsをよりよく理解するのに役立ちます。 Kafkaフレームワーク自体を知っておくとよいでしょうが、必ずしもそうである必要はありません。必要なすべてをお伝えします。この本のおかげで、経験豊富なKafka開発者は、初心者と同様に、Kafka Streamsライブラリを使用して興味深いストリーミングアプリケーションを作成する方法を学びます。シリアライゼーションなどの概念にすでに慣れている中級および高レベルのJava開発者は、スキルを適用してKafka Streamsアプリケーションを作成する方法を学びます。この本のソースコードはJava 8で記述されており、基本的にJava 8のラムダ式の構文を使用しているため、ラムダ関数（他のプログラミング言語でも）を操作できると便利です。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抜粋。</font><font style="vertical-align: inherit;">5.3。</font><font style="vertical-align: inherit;">集計とウィンドウ操作</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでは、カフカストリームの最も有望な部分を探索します。</font><font style="vertical-align: inherit;">これまで、カフカストリームの以下の側面について説明しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">処理トポロジーの作成;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーミングアプリケーションでの状態の使用。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データストリーム接続を作成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントストリーム（KStream）と更新ストリーム（KTable）の違い。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の例では、これらの要素をすべて組み合わせます。</font><font style="vertical-align: inherit;">また、ストリーミングアプリケーションのもう1つの優れた機能であるウィンドウ操作についても学びます。</font><font style="vertical-align: inherit;">最初の例は単純な集計です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3.1。</font><font style="vertical-align: inherit;">業界別の株式販売の集計</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
集約とグループ化は、ストリーミングデータを操作するための重要なツールです。多くの場合、個々のレコードが利用可能になったときに調査するだけでは不十分です。データから追加情報を抽出するには、それらのグループ化と組み合わせが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、いくつかの業界の企業の株式の販売量を追跡する必要がある日中トレーダーの訴訟を試す必要があります。特に、各業界で最大の売上高を記録している5社に関心があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような集計では、データを目的の形式（一般的な用語）に変換するために、次のいくつかの手順が必要になります。</font></font><br>
<br>
<ol>
<li>    ,      .      StockTransaction    ShareVolume.   ,   StockTransaction   ,         .</li>
<li>  ShareVolume   .              .  ,   KStream.groupBy    KGroupedStream.    KTable ,    KGroupedStream.reduce.</li>
</ol><br>
<blockquote><b>   KGroupedStream</b><br>
<br>
 KStream.groupBy  KStream.groupByKey   KGroupedStream. KGroupedStream         .         .   KGroupedStream    ,     KTable.       KTable      , , ,         .<br>
<br>
 KTable.groupBy   KGroupedTable —    ,   .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少し休憩してイチジクを見てみましょう。</font><font style="vertical-align: inherit;">5.9、これは私たちが達成したことを示しています。</font><font style="vertical-align: inherit;">このトポロジは、すでにおなじみのはずです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/9v/p3/ne/9vp3ne2cqpquhvlkmjo6wncqwsm.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、このトポロジーのコードを見てみましょう（src / main / java / bbejeck / chapter_5 / AggregationsAndReducingExample.javaファイルにあります）（リスト5.2）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/8w/cz/lz/8wczlzab4gf5y7sjluyyu2f1vdi.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与えられたコードは、簡潔さと、数行で実行される大量のアクションが異なります。</font><font style="vertical-align: inherit;">builder.streamメソッドの最初のパラメーターでは、Consumed.withOffsetResetPolicyメソッドを使用して設定された列挙型AutoOffsetReset.EARLIEST（LATESTもあります）の値に気づくことができます。</font><font style="vertical-align: inherit;">この列挙型を使用すると、KStreamまたはKTableごとにオフセットをリセットする方法を指定できます。これは、構成からのオフセットをリセットするパラメーターよりも優先されます。</font></font><br>
<br>
<blockquote><b>GroupByKey  GroupBy</b><br>
<br>
  KStream      : GroupByKey  GroupBy.   KGroupedTable,        :            ?<br>
<br>
 GroupByKey ,    KStream  .  ,  «  »   .<br>
<br>
 GroupBy ,      ,        true.    GroupBy ,   . .     .<br>
:      GroupByKey,   GroupBy.</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mapValuesとgroupByメソッドの機能は理解できるので、sum（）メソッドを見てください（src / main / java / bbejeck / model / ShareVolume.javaファイルにあります）（リスト5.3）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/va/bb/e5/vabbe54p2ntwmyk1yllak6s4m4q.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ShareVolume.sumメソッドは株式販売量の小計を返し、計算チェーン全体の結果はKTable &lt;String、ShareVolume&gt;オブジェクトです。</font><font style="vertical-align: inherit;">これで、KTableが果たす役割を理解できました。</font><font style="vertical-align: inherit;">ShareVolumeオブジェクトが到着すると、最新の最新の更新が対応するKTableに保存されます。</font><font style="vertical-align: inherit;">すべての更新が以前のshareVolumeKTableに反映されていることを忘れないでください。ただし、すべてがさらに送信されるわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、このKTableを利用して、各業界で最高の売上高を記録した5社を取得するために（販売された株式数による）集計を実行します。</font><font style="vertical-align: inherit;">この場合のアクションは、最初の集約時のアクションと同様です。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別のgroupBy操作を実行して、個々のShareVolumeオブジェクトを業界ごとにグループ化します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShareVolumeオブジェクトの要約に進みます。</font><font style="vertical-align: inherit;">今回は、集約オブジェクトは固定サイズの優先キューです。</font><font style="vertical-align: inherit;">最大の売却株式数を持つ5社だけが、このような固定サイズのキューに保持されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前の段落の行を文字列値で表示し、業界別のシェア数で5つのベストセラーを返します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果を文字列形式でトピックに書き込みます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図では </font><font style="vertical-align: inherit;">5.10に、データ移動のトポロジのグラフを示します。</font><font style="vertical-align: inherit;">ご覧のとおり、2回目の処理は非常に簡単です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/4q/3p/j5/4q3pj5lkggxqnu6lpcmtgo52dqq.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、この2回目の処理の構造が明確に理解できたので、そのソースコードを参照できます（ファイルsrc / main / java / bbejeck / chapter_5 / AggregationsAndReducingExample.javaにあります）（リスト5.4）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この初期化子にはfixedQueue変数があります。これはカスタムオブジェクト-java.util.TreeSetのアダプタで、販売された株式数の降順でN個の最高結果を追跡するために使用されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/03/mn/nm/03mnnmhuvjpivozqptxxzpkdrmu.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
groupByとmapValuesへの呼び出しはすでに発生しているため、ここでは停止しません（KTable.printメソッドは非推奨であるため、KTable.toStreamメソッドを呼び出します）。しかし、KTableバージョンのaggregate（）メソッドはまだ見たことがありません。そのため、これについて少し時間をかけて説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覚えているように、KTableは、同じキーを持つレコードが更新と見なされるという事実によって区別されます。 KTableは古いレコードを新しいレコードに置き換えます。集計は同じ方法で行われます。1つのキーを持つ最後のレコードが集計されます。レコードが到着すると、アダー（集約メソッド呼び出しの2番目のパラメーター）を使用してFixedSizePriorityQueueクラスのインスタンスに追加されますが、同じキーを持つ別のレコードが既に存在する場合、減算器（集約メソッド呼び出しの3番目のパラメーター）を使用して古いレコードが削除されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、アグリゲーターFixedSizePriorityQueueは、1つのキーですべての値を集計するのではなく、ベストセラータイプの株式の数量Nの移動合計を保存します。</font><font style="vertical-align: inherit;">各エントリには、これまでに販売された株式の総数が含まれています。</font><font style="vertical-align: inherit;">KTableは、現在最も売れている企業の株に関する情報を提供します。各更新のローリング集計は必要ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは次の2つの重要なことを行うことを学びました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共通のキーに従ってKTableの値をグループ化します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのグループ化された値に対して、たたみ込みや集計などの便利な操作を実行します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの操作を実行する機能は、Kafka Streamsアプリケーションを移動するデータの意味を理解し、それらが運ぶ情報を把握するために重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、この本で前述した主要な概念のいくつかをまとめました。第4章では、ストリーミングアプリケーションにとってフェールセーフのローカル状態がいかに重要であるかについて説明しました。この章の最初の例は、なぜローカル状態が非常に重要であるかを示しています。これにより、すでに見た情報を追跡することができます。ローカルアクセスはネットワークの遅延を回避し、アプリケーションの生産性とエラー耐性を高めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たたみ込みまたは集約操作を実行するときは、状態ストアの名前を指定する必要があります。</font><font style="vertical-align: inherit;">たたみ込みおよび集約操作はKTableインスタンスを返し、KTableは状態ストアを使用して古い結果を新しい結果に置き換えます。</font><font style="vertical-align: inherit;">ご覧のように、すべての更新がパイプラインを介してさらに送信されるわけではありません。集約操作は最終的な情報を受け取るように設計されているため、これは重要です。</font><font style="vertical-align: inherit;">ローカル状態が適用されていない場合、KTableはさらにすべての集計および畳み込み結果を送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、特定の期間内での集約などの操作の実行、いわゆるウィンドウ操作について見ていきます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3.2。</font><font style="vertical-align: inherit;">ウィンドウ操作</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のセクションでは、「ローリング」畳み込みと集約を紹介しました。</font><font style="vertical-align: inherit;">アプリケーションは、株式販売の継続的な畳み込みを実行し、続いて5つのベストセラー株式を集計しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時々、そのような継続的な集計と結果の畳み込みが必要になります。</font><font style="vertical-align: inherit;">また、特定の期間のみ操作を実行する必要がある場合もあります。</font><font style="vertical-align: inherit;">たとえば、過去10分間に特定の会社の株で行われた証券取引の数を計算します。</font><font style="vertical-align: inherit;">または、過去15分間に何人のユーザーが新しいバナー広告をクリックしたか。</font><font style="vertical-align: inherit;">アプリケーションはそのような操作を複数回実行できますが、結果は指定された時間間隔（時間枠）にのみ関連しています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイヤーごとの交換トランザクションのカウント</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の例では、複数のトレーダー（大規模組織またはスマートシングルファイナンサー）の為替取引の追跡に従事します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この追跡には2つの理由が考えられます。</font><font style="vertical-align: inherit;">その1つは、市場のリーダーが購入/販売しているものを知る必要があることです。</font><font style="vertical-align: inherit;">これらの大企業と洗練された投資家が自分たちに機会を見いだすなら、彼らの戦略に従うことは理にかなっています。</font><font style="vertical-align: inherit;">2番目の理由は、内部情報を使用して違法な取引の兆候に気づきたいという欲求です。</font><font style="vertical-align: inherit;">そのためには、売り上げの急増と重要なプレスリリースとの相関関係を分析する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような追跡は、次のような手順で構成されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">株式取引トピックから読み取るためのストリームを作成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顧客IDと株の銘柄記号による受信レコードのグループ化。</font><font style="vertical-align: inherit;">groupByメソッドを呼び出すと、KGroupedStreamクラスのインスタンスが返されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KGroupedStream.windowedByは、ウィンドウの集約を可能にする一時的なウィンドウによって区切られたデータストリームを返します。</font><font style="vertical-align: inherit;">ウィンドウのタイプに応じて、TimeWindowedKStreamまたはSessionWindowedKStreamが返されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集計操作のトランザクションをカウントします。</font><font style="vertical-align: inherit;">ウィンドウデータストリームは、特定のレコードがこの計算で考慮されるかどうかを決定します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発中に結果をトピックに書き込んだり、コンソールに出力したりします。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプリケーションのトポロジーは単純ですが、その視覚的な画像は害を及ぼしません。</font><font style="vertical-align: inherit;">写真を見てください。</font><font style="vertical-align: inherit;">5.11。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、ウィンドウ操作の機能と対応するコードについて検討します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/1h/bd/fi/1hbdfi2s0x4x4up8kkcomwg_omq.png" alt="画像"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィンドウの種類</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafka Streamsには、3種類のウィンドウがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッション</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タンブリング（タンブリング）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライド/「ジャンプ」（スライド/ホッピング）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どちらを選択するかは、ビジネス要件によって異なります。</font><font style="vertical-align: inherit;">「タンブリング」ウィンドウと「ジャンプ」ウィンドウの時間は制限されていますが、セッション制限はユーザーのアクションに関連付けられています。セッションの継続時間は、ユーザーの行動の度合いによってのみ決まります。</font><font style="vertical-align: inherit;">主なことは、すべてのタイプのウィンドウがシステム時間ではなく、レコードの日付/タイムスタンプに基づいていることを忘れないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、各タイプのウィンドウでトポロジーを実装します。</font><font style="vertical-align: inherit;">完全なコードは最初の例でのみ示され、ウィンドウ操作のタイプを除いて、他のタイプのウィンドウでは何も変更されません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッションウィンドウ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セッションウィンドウは、他のすべてのウィンドウタイプとは大きく異なります。</font><font style="vertical-align: inherit;">これらは、ユーザーアクティビティ（または追跡するエンティティのアクティビティ）ほど時間による制限はありません。</font><font style="vertical-align: inherit;">セッションウィンドウは、非アクティブな期間によって区切られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図5.12は、セッションウィンドウの概念を示しています。</font><font style="vertical-align: inherit;">小さいセッションはその左側のセッションと結合します。</font><font style="vertical-align: inherit;">また、右側のセッションは、長期間の非アクティブ状態が続くため、別のセッションになります。</font><font style="vertical-align: inherit;">セッションウィンドウはユーザーアクションに基づいていますが、レコードの日付/タイムスタンプを適用して、レコードがどのセッションに属しているかを判別します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/js/c7/z5/jsc7z525p9wrj_tlmrfa5e3vj_u.png" alt="画像"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッションウィンドウを使用したExchangeトランザクションの追跡</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セッションウィンドウを使用して、為替取引に関する情報を取得します。セッションウィンドウの実装をリスト5.5に示します（これはsrc / main / java / bbejeck / chapter_5 / CountingWindowingAndKTableJoinExample.javaにあります）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vs/vq/va/vsvqvaqddc3hgy-77fpniuwcbxm.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このトポロジの操作の大部分はすでに満たしているので、ここでそれらを再度考慮する必要はありません。ただし、これから説明する新しい要素もいくつかあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
groupBy操作では、通常、集計操作（集計、畳み込み、またはカウント）が実行されます。累積合計を使用した累積集計、または指定された時間ウィンドウ内でレコードが考慮されるウィンドウ集計のいずれかを実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト5.5のコードは、セッションウィンドウ内のトランザクションの数をカウントします。図では5.13これらのアクションは、段階的に分析されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
windowedBy（SessionWindows.with（twentySeconds）.until（fifteenMinutes））を呼び出すことにより、アイドル間隔が20秒、保持間隔が15分であるセッションウィンドウを作成します。非アクティブ間隔が20秒の場合、アプリケーションには、現在の（アクティブ）セッションの現在のセッションの終了または開始から20秒以内に到着するすべてのレコードが含まれます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/mk/qv/jhmkqvxrrnrd5mxavzltcu-uglq.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、セッションウィンドウで実行する集計操作を指定します。この場合はカウントします。着信レコードが非アクティブ間隔（日付/タイムスタンプのいずれかの側）の外にある場合、アプリケーションは新しいセッションを作成します。保持間隔とは、セッションを特定の時間維持することを意味し、セッションの非アクティブ期間を超えてもアタッチできる遅延データを許可します。さらに、マージの結果として生じる新しいセッションの開始と終了は、最も早くて最も遅い日付/タイムスタンプに対応します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
countメソッドのいくつかのエントリを見て、セッションがどのように機能するかを確認します（表5.1）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/p-/_f/pn/p-_fpnxaicjsj0ivwzrcxthi77g.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レコードを受信すると、同じキーを持つ既存のセッションを探します。終了時刻は現在の日付/タイムスタンプよりも短く、非アクティブな間隔であり、開始時刻は現在の日付/タイムスタンプ+非アクティブな間隔よりも長くなります。これを念頭に置いて、テーブルからの4つのエントリ。 5.1次のように1つのセッションにマージします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.レコード1が最初に来るため、開始時刻は終了時刻と等しく、00：00：00です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.次はレコード2です。23：59：55までに終了し、00：00：35までに開始するセッションを探します。レコード1を見つけ、セッション1と2を結合します。セッション1（以前）の開始時間とセッション2（後で）の終了時間を使用して、新しいセッションが00:00:00で始まり、00：00：15で終わるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.レコード3が到着し、00：00：30から00:01:10の間のセッションを探しましたが、何も見つかりません。</font><font style="vertical-align: inherit;">キー123-345-654、FFBEの2番目のセッションを追加し、00：00：50で開始および終了します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.レコード4が到着し、23：59：45と00:00:25の間のセッションを探します。</font><font style="vertical-align: inherit;">今回は両方のセッション-1と2があります。3つのセッションすべてが1つに結合され、開始時刻は00:00:00、終了時刻は00:00:15です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでの説明から、次の重要なニュアンスを覚えておくことは価値があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッションは固定サイズのウィンドウではありません。</font><font style="vertical-align: inherit;">セッションの期間は、一定期間内のアクティビティによって決まります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データの日付/タイムスタンプは、イベントが既存のセッションに分類されるか、非アクティブな期間に分類されるかを決定します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、次のタイプのウィンドウについて説明します-「宙返り」ウィンドウ。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タンブリングウィンドウ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「タンブリング」ウィンドウは、特定の期間内に該当するイベントをキャプチャします。</font><font style="vertical-align: inherit;">この期間のすべてのイベントを収集するために、20秒ごとに会社のすべての為替取引をキャプチャする必要があると想像してください。</font><font style="vertical-align: inherit;">20秒間隔の終わりに、ウィンドウは「タンブル」し、新しい20秒の観測間隔に切り替わります。</font><font style="vertical-align: inherit;">図5.14はこの状況を示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/sb/jh/gesbjhkrk4wfpsj94edv21lcgzk.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、過去20秒間に受信したすべてのイベントがウィンドウに含まれています。</font><font style="vertical-align: inherit;">この期間の終わりに、新しいウィンドウが作成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト5.6は、タンブリングウィンドウを使用して20秒ごとに交換トランザクションをキャプチャする方法を示すコードを示しています（src / main / java / bbejeck / chapter_5 / CountingWindowingAndKtableJoinExample.javaにあります）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ej/gw/ba/ejgwbaxfd9vzmdok1u6vl7gqjt4.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TimeWindows.ofメソッドの呼び出しに対するこの小さな変更のおかげで、タンブリングウィンドウを使用できます。</font><font style="vertical-align: inherit;">この例では、until（）メソッドへの呼び出しがないため、デフォルトの保存間隔である24時間が使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、最後のウィンドウオプションであるホッピングウィンドウに移ります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライディング（「ジャンプ」）ウィンドウ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スライディング/「ホッピング」ウィンドウは「タンブリング」に似ていますが、若干の違いがあります。</font><font style="vertical-align: inherit;">スライディングウィンドウは、最近のイベントを処理する新しいウィンドウを作成する前に、時間間隔の終了を待ちません。</font><font style="vertical-align: inherit;">ウィンドウ期間より短い待機間隔の後で、新しい計算を開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「宙返り」ウィンドウと「ジャンプ」ウィンドウの違いを説明するために、為替取引の計算の例に戻りましょう。</font><font style="vertical-align: inherit;">以前と同様に、トランザクションの数をカウントすることが目標ですが、カウンターを更新する前に常に待機する必要はありません。</font><font style="vertical-align: inherit;">代わりに、より短い間隔でカウンターを更新します。</font><font style="vertical-align: inherit;">たとえば、図5に示すように、20秒ごとにトランザクション数をカウントし続けますが、5秒ごとにカウンターを更新します。</font><font style="vertical-align: inherit;">5.15。</font><font style="vertical-align: inherit;">同時に、データが重複する3つの結果ウィンドウがあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/f_/rz/km/f_rzkmhyoxehblurxwysauk3j2k.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト5.7はスライディングウィンドウを指定するためのコードを示しています（src / main / java / bbejeck / chapter_5 / CountingWindowingAndKtableJoinExample.javaにあります）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/oa/xr/hn/oaxrhnrcxi78qoylbaatcegq__q.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タンブリングウィンドウは、advanceBy（）メソッドへの呼び出しを追加することでタンブリングウィンドウに変換できます。</font><font style="vertical-align: inherit;">上記の例では、保存間隔は15分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでは、集計結果を時間枠に制限する方法を説明しました。</font><font style="vertical-align: inherit;">特に、このセクションの次の3つのことを覚えておいてください。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッションウィンドウのサイズは、時間間隔ではなく、ユーザーアクティビティによって制限されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「タンブリング」ウィンドウは、一定期間内のイベントのアイデアを提供します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ジャンプ」ウィンドウの期間は固定されていますが、頻繁に更新され、すべてのウィンドウで重複するエントリが含まれる場合があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、接続のためにKTableをKStreamに戻す方法を学びます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3.3。</font><font style="vertical-align: inherit;">KStreamオブジェクトとKTableオブジェクトを結合する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第4章では、2つのKStreamオブジェクトの接続について説明しました。</font><font style="vertical-align: inherit;">次に、KTableとKStreamを接続する方法を学ぶ必要があります。</font><font style="vertical-align: inherit;">これは、次の単純な理由で必要になる場合があります。</font><font style="vertical-align: inherit;">KStreamはレコードのストリームであり、KTableはレコードの更新のストリームですが、KTableからの更新を使用してレコードのストリームに追加のコンテキストを追加する必要がある場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
為替取引の数に関するデータを取得し、それらを関連業界の為替ニュースと組み合わせます。</font><font style="vertical-align: inherit;">既存のコードを考えると、これを実現するために必要なことは次のとおりです。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交換トランザクションの数に関するデータを含むKTableオブジェクトをKStreamに変換し、その後、キーをこの株式の記号に対応する業界を識別するキーに置き換えます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エクスチェンジニュースを含むトピックからデータを読み取るKTableオブジェクトを作成します。</font><font style="vertical-align: inherit;">この新しいKTableは、業界ごとに分類されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニュースの更新と業界別の取引所取引数に関する情報を組み合わせます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、このアクションプランを実装する方法を見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KTableをKStreamに変換</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KTableをKStreamに変換するには、以下を実行する必要があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KTable.toStream（）メソッドを呼び出します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KStream.mapメソッドを呼び出して、キーを業界の名前に置き換え、WindowedインスタンスからTransactionSummaryオブジェクトを抽出します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの操作を次のようにチェーンします（コードはsrc / main / java / bbejeck / chapter_5 / CountingWindowingAndKtableJoinExample.javaにあります）（リスト5.8）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jx/_b/9f/jx_b9frqyde6wj2yvo5nk3palwq.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KStream.map操作を実行するため、返されたKStreamインスタンスの繰り返しパーティション化は、接続で使用されるときに自動的に実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変換プロセスを完了したら、株式ニュースを読み取るためのKTableオブジェクトを作成する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">株式市場ニュースのKTableを作成する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、1行のコードでKTableオブジェクトを作成できます（このコードはsrc / main / java / bbejeck / chapter_5 / CountingWindowingAndKtableJoinExample.javaにあります）（リスト5.9）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vb/g5/2w/vbg52wycfxm6ojk2jgpkochuvii.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
設定では文字列Serdeを使用するため、Serdeオブジェクトを指定する必要がないことに注意してください。</font><font style="vertical-align: inherit;">また、EARLIEST列挙を使用すると、テーブルには最初からレコードが入力されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、最後のステップである労働組合に進むことができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニュースの更新を取引番号にリンクする</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接続の作成は簡単です。</font><font style="vertical-align: inherit;">関連業界の交換ニュースがない場合は、左接続を使用します（必要なコードは、ファイルsrc / main / java / bbejeck / chapter_5 / CountingWindowingAndKtableJoinExample.javaにあります）（リスト5.10）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/8r/zw/nk8rzwzgk7qtaxv0uq3p_sjaipm.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このleftJoinステートメントは非常に単純です。</font><font style="vertical-align: inherit;">第4章の接続とは異なり、KStream-KTableを作成すると、KTableのキーごとに1つのレコードしかないため、JoinWindowメソッドは使用されません。</font><font style="vertical-align: inherit;">そのような接続は時間に制限されていません。レコードはKTableにあるか、存在しません。</font><font style="vertical-align: inherit;">主な結論：KTableオブジェクトを使用すると、更新頻度の低い参照データでKStreamを強化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、KStreamからのイベントを強化するためのより効率的な方法を見ていきます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3.4。</font><font style="vertical-align: inherit;">GlobalKTableオブジェクト</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご理解のとおり、イベントのフローを充実させるか、イベントにコンテキストを追加する必要があります。</font><font style="vertical-align: inherit;">第4章では、2つのKStreamオブジェクトの接続について説明し、前のセクションでは、KStreamとKTableの接続について説明しました。</font><font style="vertical-align: inherit;">これらすべてのケースで、キーを新しいタイプまたは値にマッピングする場合、データストリームの繰り返しパーティションが必要です。</font><font style="vertical-align: inherit;">再パーティション化は明示的に行われる場合もあれば、Kafka Streamsが自動的に行う場合もあります。</font><font style="vertical-align: inherit;">キーが変更され、レコードが新しいセクションにある必要があるため、再パーティション化が必要です。そうしないと、接続が不可能になります（これについては、第4章の4.2.4節の「データの再パーティション化」セクションで説明しました）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再パーティション化にはコストがかかります</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーティション分割を繰り返すにはコストが必要です-中間トピックを作成し、別のトピックに重複データを保存するための追加リソース。</font><font style="vertical-align: inherit;">また、このトピックからの書き込みと読み取りのために遅延が増加することも意味します。</font><font style="vertical-align: inherit;">さらに、複数のアスペクトまたはディメンションで接続を実行する必要がある場合は、接続をチェーンに編成し、新しいキーでレコードを表示して、再度パーティション化のプロセスを実行する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さなデータセットに接続する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合によっては、接続を計画している参照データの量が比較的少ないため、それらの完全なコピーを各ノードのローカルに収めることができます。</font><font style="vertical-align: inherit;">そのような状況に対して、Kafka StreamsはGlobalKTableクラスを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションがすべてのデータを各ノードに複製するため、GlobalKTableインスタンスは一意です。</font><font style="vertical-align: inherit;">また、すべてのデータが各ノードに存在するため、イベントのストリームを参照データキーで分割して、すべてのセクションからアクセスできるようにする必要はありません。</font><font style="vertical-align: inherit;">GlobalKTableオブジェクトは、キーレス接続も実行できます。</font><font style="vertical-align: inherit;">この機能を説明するために、前の例の1つに戻りましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KStreamオブジェクトをGlobalKTableオブジェクトに接続する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5.3.2項では、顧客による為替取引のウィンドウ集約を実行しました。</font><font style="vertical-align: inherit;">この集計の結果は次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">{customerId='074-09-3705', stockTicker='GUTM'}, 17<font></font>
{customerId='037-34-5184', stockTicker='CORK'}, 16</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの結果は目標と一致していましたが、クライアントの名前と会社のフルネームも表示された方が便利です。</font><font style="vertical-align: inherit;">顧客の名前と会社の名前を追加するには、通常の接続を実行できますが、2つのキーマッピングを作成して再パーティション化する必要があります。</font><font style="vertical-align: inherit;">GlobalKTableを使用すると、このような操作のコストを回避できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、リスト5.11のcountStreamオブジェクトを使用します（対応するコードはsrc / main / java / bbejeck / chapter_5 / GlobalKTableExample.javaファイルにあります）、2つのGlobalKTableオブジェクトに接続します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/et/ds/zj/etdszjjzni9snwmxxbi21xph8e4.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これについてはすでに説明したので、繰り返しはしません。</font><font style="vertical-align: inherit;">しかし、私はtoStream（）マップ関数のコードが、埋め込まれたラムダ式ではなく、読みやすくするために関数オブジェクトに抽象化されていることに注意します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップは、GlobalKTableの2つのインスタンスを宣言することです（示されているコードは、src / main / java / bbejeck / chapter_5 / GlobalKTableExample.javaにあります）（リスト5.12）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ut/ca/gd/utcagdf_iab9zjefezaiy2dxt80.png" alt="画像"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トピック名は列挙型を使用して記述されていることに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これですべてのコンポーネントの準備ができたので、接続用のコード（src / main / java / bbejeck / chapter_5 / GlobalKTableExample.javaファイルにあります）を記述します（リスト5.13）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/av/yr/oe/avyroeehcpkzq9rzeiqlernoum8.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードには2つのコンパウンドがありますが、それらの結果は個別に使用されないため、チェーンで構成されています。</font><font style="vertical-align: inherit;">結果は、操作全体の最後に表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の接続操作を開始すると、次の結果が得られます。</font></font><br>
<br>
<pre><code class="plaintext hljs">{customer='Barney, Smith' company="Exxon", transactions= 17}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本質は変わっていませんが、これらの結果はより明確に見えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第4章を数えると、すでにいくつかのタイプの接続が動作しているのを見てきました。</font><font style="vertical-align: inherit;">それらは表にリストされています。</font><font style="vertical-align: inherit;">5.2。</font><font style="vertical-align: inherit;">この表は、Kafka Streamsのバージョン1.0.0に関連する接続を反映しています。</font><font style="vertical-align: inherit;">今後のリリースで変更される予定です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_u/ka/gh/_ukaghteoopcpk9i5ljf4cjrwju.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論として、主なことを思い出します。ローカル状態を使用して、イベントストリーム（KStream）と更新ストリーム（KTable）を接続できます。</font><font style="vertical-align: inherit;">さらに、参照データのサイズが大きすぎない場合は、GlobalKTableオブジェクトを使用できます。</font><font style="vertical-align: inherit;">GlobalKTableは、Kafka Streamsアプリケーションの各ノードにすべてのセクションを複製します。これにより、キーが対応するセクションに関係なく、すべてのデータの可用性が保証されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Kafkaストリームの可能性を確認します。これにより、Kafkaトピックのデータを使用せずに状態の変化を観察できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3.5。</font><font style="vertical-align: inherit;">リクエストのステータス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状態に関連するいくつかの操作を既に実行しており、常に結果をコンソールに出力する（開発目的の場合）か、トピックに書き込みます（工業用の場合）。結果をトピックに書き込むときは、Kafkaコンシューマーを使用して結果を表示する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのトピックからデータを読み取ることは、マテリアライズドビューの一種と考えることができます。このタスクでは、Wikipediaのマテリアライズドビューの定義を使用できます。「...クエリの結果を含む物理データベースオブジェクト。たとえば、削除されたデータのローカルコピー、テーブルや結合結果の行や列のサブセット、集計を使用して取得したピボットテーブルなどがあります”（https://en.wikipedia.org/wiki/Materialized_view）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafka Streamsでは、状態ストアに対してインタラクティブなクエリを実行することもできます。これにより、これらのマテリアライズドビューを直接読み取ることができます。</font><font style="vertical-align: inherit;">状態ストアへの要求は、読み取り専用操作の性質を持つことに注意することが重要です。</font><font style="vertical-align: inherit;">これにより、データ処理中に誤ってアプリケーションの状態を不整合にすることを恐れることはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状態ストアを直接照会する機能は重要です。</font><font style="vertical-align: inherit;">つまり、最初にKafkaコンシューマーからデータを受信する必要のないダッシュボードであるアプリケーションを作成できます。</font><font style="vertical-align: inherit;">データを再度記録する必要がないため、アプリケーションの効率が向上します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データの局所性により、データにすばやくアクセスできます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データは外部ストレージに書き込まれないため、データの重複は除外されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覚えておきたい主なことは、アプリケーションから状態要求を直接実行できることです。</font><font style="vertical-align: inherit;">これがもたらす可能性を過大評価することはできません。</font><font style="vertical-align: inherit;">Kafkaからのデータを使用してアプリケーションのデータベースにレコードを保存する代わりに、同じ結果で状態ストアにクエリを実行できます。</font><font style="vertical-align: inherit;">状態ストアへの直接クエリは、コード（コンシューマーなし）とソフトウェア（結果を格納するためのデータベーステーブルが不要）を削減することを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この章ではかなりの量の情報を取り上げたので、ステートストアへのインタラクティブクエリの説明を一時的に停止します。</font><font style="vertical-align: inherit;">ただし、心配しないでください。第9章では、インタラクティブなクエリを備えた情報パネルである簡単なアプリケーションを作成します。</font><font style="vertical-align: inherit;">インタラクティブなクエリと、それらをKafka Streamsアプリケーションに追加する可能性を示すために、この章と前の章の例をいくつか使用します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KStreamオブジェクトは、データベースの挿入に相当するイベントストリームを表します。</font><font style="vertical-align: inherit;">KTableオブジェクトは更新ストリームを表し、データベースの更新により似ています。</font><font style="vertical-align: inherit;">KTableオブジェクトのサイズは大きくなりません;古いレコードは新しいレコードに置き換えられます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KTableオブジェクトは、集計操作に必要です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィンドウ操作を使用して、集計データをタイムバスケットに分割できます。</font></font></li>
<li>  GlobalKTable          ,     .</li>
<li>     KStream, KTable  GlobalKTable.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでは、高レベルのKStream DSLを使用してKafka Streamsアプリケーションを構築することに焦点を当ててきました。高レベルのアプローチでは、きちんとした簡潔なプログラムを作成できますが、その使用は確実な妥協です。 DSL KStreamを使用するということは、制御の度合いを減らすことによってコードの簡潔さを高めることを意味します。次の章では、ハンドラーノードの低レベルAPIを見て、他のトレードオフを試します。プログラムは今までよりも長くなりますが、必要なほぼすべての処理ノードを作成する機会があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→この本の詳細</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は出版社のウェブサイトでご覧いただけます</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
→Khabrozhiteleyの場合25％割引クーポン-Kafka </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streams</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→紙の本をお支払いいただくと、電子書籍がメールで送信されます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457744/index.html">Qtライブラリでの拡張システムの作成-パート2</a></li>
<li><a href="../ja457746/index.html">気象学とフライト</a></li>
<li><a href="../ja457750/index.html">Symfony 4でJSON RPCを操作する</a></li>
<li><a href="../ja457752/index.html">月面探査機やジョーカーではありません。福島のロボットについて知っていること</a></li>
<li><a href="../ja457754/index.html">Государство и Т-киллеры</a></li>
<li><a href="../ja457758/index.html">エンジニアは森で失われた人々を救うが、森はまだ降伏していない</a></li>
<li><a href="../ja457760/index.html">コンテナーをさらに分離する方法：コンテナーサンドボックステクノロジーのレビュー</a></li>
<li><a href="../ja457762/index.html">CCDルーラー：一緒に食べるもの</a></li>
<li><a href="../ja457764/index.html">若いPOの10の間違い（パートII）</a></li>
<li><a href="../ja457766/index.html">タイルレベルを生成し、プレーヤーから正方形を非表示にします</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>