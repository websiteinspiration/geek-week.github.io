<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µüèæ üòë üçÅ How to protect processes and kernel extensions on macOS üë©üèø‚ÄçüöÄ üåã üîº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! Today I would like to talk about how you can protect processes from intruders in macOS. For example, it is useful for an antivirus or bac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>How to protect processes and kernel extensions on macOS</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/497714/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr! </font><font style="vertical-align: inherit;">Today I would like to talk about how you can protect processes from intruders in macOS. </font><font style="vertical-align: inherit;">For example, it is useful for an antivirus or backup system, especially in light of the fact that under macOS there are several ways to ‚Äúkill‚Äù the process. </font><font style="vertical-align: inherit;">Read about it and about protection methods under a cat.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/403/e5f/065/403e5f065b7426d384f3c71e8cb3c8a5.jpg" alt="image"></a><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The classic way to kill a process</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The well-known way to ‚Äúkill‚Äù a process is to send a signal about a SIGKILL process. </font><font style="vertical-align: inherit;">Through bash, you can call the standard ‚Äúkill -SIGKILL PID‚Äù or ‚Äúpkill -9 NAME‚Äù to kill. </font><font style="vertical-align: inherit;">The kill command has been known since UNIX and is available not only on macOS, but also on other UNIX-like systems. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As in UNIX-like systems, macOS allows you to intercept any signals to the process except two - SIGKILL and SIGSTOP. </font><font style="vertical-align: inherit;">In this article, the SIGKILL signal will be primarily considered as a signal giving rise to the killing of a process.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MacOS specifics</font></font><br>
</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On macOS, the kill system call in the XNU kernel calls the psignal function (SIGKILL, ...). Let's try to see what other user actions in userspace can call the psignal function. We eliminate calls to the psignal function in the internal mechanisms of the kernel (although they may be non-trivial, we will leave them for another article :) - signature verification, memory errors, exit / terminate processing, violation of file protection, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We start the overview with the function and the corresponding system call </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminate_with_payload</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It can be seen that in addition to the classic kill call, there is an alternative approach that is specific to the macOS operating system and is not found in BSD. </font><font style="vertical-align: inherit;">The operating principles of both system calls are also close. </font><font style="vertical-align: inherit;">They are direct calls to the psignal kernel function. </font><font style="vertical-align: inherit;">Also note that before killing a process, a ‚Äúcansignal‚Äù check is performed - whether the process can send a signal to another process, the system does not allow any application to kill system processes for example.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>
<span class="hljs-title">terminate_with_payload_internal</span><span class="hljs-params">(struct proc *cur_proc, <span class="hljs-keyword">int</span> target_pid, <span class="hljs-keyword">uint32_t</span> reason_namespace,
				<span class="hljs-keyword">uint64_t</span> reason_code, <span class="hljs-keyword">user_addr_t</span> payload, <span class="hljs-keyword">uint32_t</span> payload_size,
				<span class="hljs-keyword">user_addr_t</span> reason_string, <span class="hljs-keyword">uint64_t</span> reason_flags)</span>
</span>{<font></font>
...<font></font>
	target_proc = proc_find(target_pid);<font></font>
...<font></font>
	<span class="hljs-keyword">if</span> (!cansignal(cur_proc, cur_cred, target_proc, SIGKILL)) {<font></font>
		proc_rele(target_proc);<font></font>
		<span class="hljs-keyword">return</span> EPERM;<font></font>
	}<font></font>
...<font></font>
	<span class="hljs-keyword">if</span> (target_pid == cur_proc-&gt;p_pid) {
		<span class="hljs-comment">/*
		 * psignal_thread_with_reason() will pend a SIGKILL on the specified thread or
		 * return if the thread and/or task are already terminating. Either way, the
		 * current thread won't return to userspace.
		 */</span><font></font>
		psignal_thread_with_reason(target_proc, current_thread(), SIGKILL, signal_reason);<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		psignal_with_reason(target_proc, SIGKILL, signal_reason);<font></font>
	}<font></font>
...<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">launchd</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The standard way to create daemons at system startup and control their lifetime is launchd. </font><font style="vertical-align: inherit;">I‚Äôll draw attention to the fact that the source code is for the old version of launchctl before macOS 10.10, code examples are given as an illustration. </font><font style="vertical-align: inherit;">The modern launchctl sends launchd signals through XPC, the logic of launchctl is transferred to it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's consider how the application is stopped. </font><font style="vertical-align: inherit;">Before sending a SIGTERM signal, they try to stop the application using the proc_terminate system call.</font></font><br>
<br>
<pre><code class="cpp hljs">&lt;launchctl src/core.c&gt;<font></font>
...<font></font>
	error = proc_terminate(j-&gt;p, &amp;sig);<font></font>
	<span class="hljs-keyword">if</span> (error) {<font></font>
		job_log(j, LOG_ERR | LOG_CONSOLE, <span class="hljs-string">"Could not terminate job: %d: %s"</span>, error, strerror(error));<font></font>
		job_log(j, LOG_NOTICE | LOG_CONSOLE, <span class="hljs-string">"Using fallback option to terminate job..."</span>);<font></font>
		error = kill2(j-&gt;p, SIGTERM);<font></font>
		<span class="hljs-keyword">if</span> (error) {<font></font>
			job_log(j, LOG_ERR, <span class="hljs-string">"Could not signal job: %d: %s"</span>, error, strerror(error));<font></font>
		} <font></font>
...<font></font>
&lt;&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Under the hood, proc_terminate, in spite of its name, can send not only psignal with SIGTERM, but also SIGKILL.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indirect kill - resource limit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A more interesting case can be seen in another </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">process_policy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> system call </font><font style="vertical-align: inherit;">. The standard use of this system call is application resource limits, for example, for the indexer, there is a limit on the processor time and memory quota so that the system does not significantly slow down from file caching actions. If the application has reached the resource limit, as can be seen from the proc_apply_resource_actions function, the SIGKILL signal is sent to the process. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although this system call could potentially kill a process, the system did not adequately check the rights of the process that caused the system call. In fact, a check </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existed</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but it is enough to use the alternative flag PROC_POLICY_ACTION_SET to bypass this condition.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hence, if you ‚Äúlimit‚Äù the CPU usage quota by the application (for example, allow only 1 ns to be executed), then you can kill any process in the system. </font><font style="vertical-align: inherit;">So, the malware can kill any process on the system, including the antivirus process. </font><font style="vertical-align: inherit;">Also interesting is the effect that occurs when a process is killed with pid 1 (launchctl) - kernel panic when trying to process a SIGKILL signal :)</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/91e/fea/a49/91efeaa490ffd57580d2e5f4a59b4988.png" alt="image"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to solve the problem?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most straightforward way to prevent a process from being killed is to replace the function pointer in the system call table. Unfortunately, this method is non-trivial for many reasons </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
. Firstly, the symbol that is responsible for the position of sysent in memory is not only a private symbol of the XNU kernel, but also cannot be found in kernel symbols. You will have to use heuristic search methods, for example, dynamic disassembly of a function and search for a pointer in it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secondly, the structure of the entries in the table depends on the flags with which the kernel was built. If the flag CONFIG_REQUIRES_U32_MUNGING is declared, then the size of the structure will be changed - an additional field </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">sy_arg_munge32</font></a><font style="vertical-align: inherit;"> is added</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It is necessary to carry out an additional check on the flag with which the kernel was compiled, as an option, compare pointers to functions with known ones.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysent</span> {</span>         <span class="hljs-comment">/* system call table */</span>
        <span class="hljs-keyword">sy_call_t</span>       *sy_call;       <span class="hljs-comment">/* implementing function */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> CONFIG_REQUIRES_U32_MUNGING || (__arm__ &amp;&amp; (__BIGGEST_ALIGNMENT__ &gt; 4))</span>
        <span class="hljs-keyword">sy_munge_t</span>      *sy_arg_munge32; <span class="hljs-comment">/* system call arguments munger for 32-bit process */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        <span class="hljs-keyword">int32_t</span>         sy_return_type; <span class="hljs-comment">/* system call return types */</span>
        <span class="hljs-keyword">int16_t</span>         sy_narg;        <span class="hljs-comment">/* number of args */</span>
        <span class="hljs-keyword">uint16_t</span>        sy_arg_bytes;   <span class="hljs-comment">/* Total size of arguments in bytes for
                                         * 32-bit system calls
                                         */</span><font></font>
};<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, in modern versions of macOS, Apple provides a new API for working with processes. </font><font style="vertical-align: inherit;">The Endpoint Security API allows clients to authorize many requests to other processes. </font><font style="vertical-align: inherit;">So, you can block any signals to processes, including the SIGKILL signal using the aforementioned API.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bsm/libbsm.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;EndpointSecurity/EndpointSecurity.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>{
    <span class="hljs-keyword">es_client_t</span>* cli = <span class="hljs-literal">nullptr</span>;<font></font>
    {<font></font>
        <span class="hljs-keyword">auto</span> res = es_new_client(&amp;cli, ^(<span class="hljs-keyword">es_client_t</span> * client, <span class="hljs-keyword">const</span> <span class="hljs-keyword">es_message_t</span> * message) {
            <span class="hljs-keyword">switch</span> (message-&gt;event_type) {
                <span class="hljs-keyword">case</span> ES_EVENT_TYPE_AUTH_SIGNAL:<font></font>
                {<font></font>
                    <span class="hljs-keyword">auto</span>&amp; msg = message-&gt;event.signal;
                    <span class="hljs-keyword">auto</span> target = msg.target;
                    <span class="hljs-keyword">auto</span>&amp; token = target-&gt;audit_token;
                    <span class="hljs-keyword">auto</span> pid = audit_token_to_pid(token);
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"signal '%d' sent to pid '%d'\n"</span>, msg.sig, pid);<font></font>
                    es_respond_auth_result(client, message, pid == getpid() ? ES_AUTH_RESULT_DENY : ES_AUTH_RESULT_ALLOW, <span class="hljs-literal">false</span>);<font></font>
                }<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        });<font></font>
    }<font></font>
<font></font>
    {<font></font>
        <span class="hljs-keyword">es_event_type_t</span> evs[] = { ES_EVENT_TYPE_AUTH_SIGNAL };<font></font>
        es_subscribe(cli, evs, <span class="hljs-keyword">sizeof</span>(evs) / <span class="hljs-keyword">sizeof</span>(*evs));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, getpid());<font></font>
    sleep(<span class="hljs-number">60</span>); <span class="hljs-comment">// could be replaced with other waiting primitive</span><font></font>
<font></font>
    es_unsubscribe_all(cli);<font></font>
    es_delete_client(cli);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Similarly, you can register MAC Policy in the kernel, which provides a signal protection method (policy proc_check_signal), but the API is not officially supported.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kernel Extension Protection</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to protecting processes in the system, protection of the kernel extension itself (kext) is also necessary. macOS provides a framework for developers to conveniently develop IOKit device drivers. In addition to providing tools for working with devices, IOKit provides driver stacking methods using instances of C ++ classes. An application in userspace will be able to ‚Äúfind‚Äù a registered instance of the class to establish a kernel-userspace connection. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To detect the number of class instances in the system, the ioclasscount utility exists.</font></font><br>
<br>
<pre><code class="cpp hljs">my_kext_ioservice = <span class="hljs-number">1</span>
my_kext_iouserclient = <span class="hljs-number">1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Any kernel extension that wishes to register on the driver stack must declare a class inherited from IOService, for example, my_kext_ioservice in this case. Connecting user applications will create a new instance of the class that inherits from IOUserClient, in the example my_kext_iouserclient. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When trying to unload the driver from the system (kextunload command), the virtual function ‚Äúbool terminate (IOOptionBits options)‚Äù is called. </font><font style="vertical-align: inherit;">It is enough to return false on the call to the terminate function when trying to unload to disable kextunload.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Kext::terminate</span><span class="hljs-params">(IOOptionBits options)</span>
</span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!IsUnloadAllowed)<font></font>
  {<font></font>
    <span class="hljs-comment">// Unload is not allowed, returning false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> super::<span class="hljs-built_in">terminate</span>(options);<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The IsUnloadAllowed flag can be set by IOUserClient at boot. </font><font style="vertical-align: inherit;">When loading is limited, the kextunload command will return the following output:</font></font><br>
<br>
<pre><code class="cpp hljs">admin@admins-Mac drivermanager % sudo kextunload ./test.kext<font></font>
Password:<font></font>
(kernel) Can<span class="hljs-number">'</span>t remove kext my.kext.test; services failed to <span class="hljs-built_in">terminate</span> - <span class="hljs-number">0xe00002c7</span>.<font></font>
Failed to unload my.kext.test - (iokit/common) unsupported function.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Similar protection must be done for IOUserClient. </font><font style="vertical-align: inherit;">Class instances can be unloaded using the userspace function IOKitLib ‚ÄúIOCatalogueTerminate (mach_port_t, uint32_t flag, io_name_t description);‚Äù. </font><font style="vertical-align: inherit;">You can return false on a call to the ‚Äúterminate‚Äù command until userspace the application dies, that is, there is no call to the clientDied function.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">File protection</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To protect files, it is enough to use the Kauth API, which allows you to restrict access to files. Apple provides developers with notifications about various events in the scope, the operations KAUTH_VNODE_DELETE, KAUTH_VNODE_WRITE_DATA and KAUTH_VNODE_DELETE_CHILD are important for us. Restricting access to files is easiest along the way - we use the API ‚Äúvn_getpath‚Äù to get the path to the file and compare the path prefix. Note that to optimize the renaming of the paths of folders with files, the system does not authorize access to each file, but only to the folder itself, which was renamed. It is necessary to compare the parent path and restrict KAUTH_VNODE_DELETE for it.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6e2/ab5/2fb/6e2ab52fb8c17ea8adfe8b63bcf8f611.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The disadvantage of this approach may be low performance with increasing number of prefixes. In order for the comparison not to be equal to O (prefix * length), where prefix is ‚Äã‚Äãthe number of prefixes, length is the length of the string, you can use a deterministic finite state machine (DFA) constructed by prefixes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider a way to build a DFA for a given set of prefixes. We initialize the cursors at the beginning of each prefix. If all cursors point to the same character, then we increase each cursor by one character and remember that the length of the same line is more by one. If there are two cursors with different symbols under them, we divide the cursors into groups by the symbol to which they point and repeat the algorithm for each group.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the first case (all characters under the cursors are the same), we get the DFA state, which has only one transition on the same line. </font><font style="vertical-align: inherit;">In the second case, we get a transition table of size 256 (number of characters and the maximum number of groups) in the subsequent states obtained by recursively calling the function. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider an example. </font><font style="vertical-align: inherit;">For a set of prefixes (‚Äú/ foo / bar / tmp /‚Äù, ‚Äú/ var / db / foo /‚Äù, ‚Äú/ foo / bar / aba /‚Äù, ‚Äúfoo / bar / aac /‚Äù) you can get the following DFA. </font><font style="vertical-align: inherit;">The figure shows only transitions leading to other states, other transitions will not be final. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/190/d0f/5ec/190d0f5ec1fdd8c03df23387d83db44a.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When passing through the DKA states, there may be 3 cases.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The final state was reached - the path is protected, we restrict the operations KAUTH_VNODE_DELETE, KAUTH_VNODE_WRITE_DATA and KAUTH_VNODE_DELETE_CHILD</font></font></li>
<li>    ,   ‚Äú‚Äù (  -) ‚Äî   ,   KAUTH_VNODE_DELETE. ,   vnode  ,     ‚Äò/‚Äô,         ‚Äú/foor/bar/t‚Äù,  .</li>
<li>    ,   .       ,   .</li>
</ol><br>
<h3></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The aim of the developed security solutions is to increase the level of security of the user and his data. On the one hand, this goal is ensured by the development of Acronis software product that covers vulnerabilities where the operating system itself is ‚Äúweak‚Äù. On the other hand, we should not neglect the strengthening of those security aspects that can be improved on the OS side, especially since the closure of such vulnerabilities increases our own stability as a product. The vulnerability was reported by the Apple Product Security Team and was fixed in macOS 10.14.5 (https://support.apple.com/en-gb/HT210119).</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e27/604/c24/e27604c248d5405276235cf613319754.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All this can be done only if your utility has been officially installed in the kernel. </font><font style="vertical-align: inherit;">That is, there are no such loopholes for external and unwanted software. </font><font style="vertical-align: inherit;">However, as you can see, even to protect legitimate programs such as antivirus and backup systems, you have to work hard. </font><font style="vertical-align: inherit;">But now, new Acronis products for macOS will have additional protection against unloading from the system.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en497688/index.html">How the Kubernetes Evening School Works</a></li>
<li><a href="../en497696/index.html">How does Ryuk ransomware that attacks enterprises</a></li>
<li><a href="../en497700/index.html">Weekly online mitaps on backing and DevOps, security and robots from April 17</a></li>
<li><a href="../en497702/index.html">Five trends in data storage that you should pay attention to in 2020</a></li>
<li><a href="../en497708/index.html">We invite you to a series of Fujitsu webinars in April and May</a></li>
<li><a href="../en497724/index.html">Preparing a server for publishing a web-app in Python</a></li>
<li><a href="../en497726/index.html">Scaling Android Testing at Odnoklassniki</a></li>
<li><a href="../en497728/index.html">The dangers of ‚Äúburning‚Äù chips</a></li>
<li><a href="../en497730/index.html">Convenient BDD: SpecFlow + TFS</a></li>
<li><a href="../en497736/index.html">Review of 10 new internal combustion engines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>