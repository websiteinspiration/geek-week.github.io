<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👧‍👦 👩🏼‍🍳 👍🏾 Stas Afanasyev. Juno. Pipelines baseados em io.Reader / io.Writer. Parte 2 👩🏼‍🏫 👨🏿‍🔧 📖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No relatório, falaremos sobre o conceito de io.Reader / io.Writer, por que eles são necessários, como implementá-los corretamente e que armadilhas exi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Stas Afanasyev. Juno. Pipelines baseados em io.Reader / io.Writer. Parte 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/491524/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No relatório, falaremos sobre o conceito de io.Reader / io.Writer, por que eles são necessários, como implementá-los corretamente e que armadilhas existem a esse respeito, bem como sobre a construção de pipelines com base em implementações padrão e personalizadas de io.Reader / io.Writer .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rd/nv/uj/rdnvujcjwsukejxq_6a9syayawu.jpeg"><a name="habracut"></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stas Afanasyev. </font><font style="vertical-align: inherit;">Juno. </font><font style="vertical-align: inherit;">Pipelines baseados em io.Reader / io.Writer. </font><font style="vertical-align: inherit;">Parte 1</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bug "na confiança"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra nuance: nesta implementação, há um "bagul". </font><font style="vertical-align: inherit;">Este bug é confirmado pelos desenvolvedores (escrevi a eles sobre isso). </font><font style="vertical-align: inherit;">Talvez alguém saiba o que é esse "bagul"? </font><font style="vertical-align: inherit;">No slide, está a penúltima linha: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c9/kc/xj/c9kcxjodwjtycg7o2n62tfavto0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
está associada a muita confiança no Reader empacotado: se o Reader retornar um número negativo de bytes, o limite que gostaríamos de obter pelo número de bytes subtraídos aumenta. </font><font style="vertical-align: inherit;">E, em alguns casos, esse é um bug muito sério que você não consegue entender imediatamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu escrevi na edição: vamos fazer alguma coisa, vamos consertar! E então uma camada de problemas foi revelada ... Primeiro, eles me disseram que se você adicionar essa verificação agora aqui, precisará adicioná-la em todos os lugares, e há uma dúzia desses lugares. Se queremos mudar isso para o lado do cliente, precisamos determinar um número de regras pelas quais o cliente validará os dados (e também podem haver cinco ou dois). Acontece que tudo isso precisa ser copiado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu concordo que isso não é o ideal. Então vamos a uma versão consistente! Por que temos uma implementação da biblioteca padrão que não confia em nada, enquanto outros confiam em absolutamente tudo?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, enquanto eu escrevia minha opinião cívica, refletindo sobre o assunto, encerramos a questão com comentários: “Não faremos nada. </font><font style="vertical-align: inherit;">Tchau"! </font><font style="vertical-align: inherit;">Eles me fizeram parecer um tipo de idiota ... Educadamente, é claro, você não encontra falhas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, agora temos um problema. </font><font style="vertical-align: inherit;">Consiste no fato de que não está claro quem deve validar os dados do Reader empacotado. </font><font style="vertical-align: inherit;">Ou o cliente, ou confiamos totalmente no contrato ... Temos uma solução! </font><font style="vertical-align: inherit;">Se ainda houver tempo, eu falarei sobre isso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos para o próximo caso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teereader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vimos um exemplo de como agrupar dados do Reader. O próximo exemplo de canal é ultrapassar os dados do Reader no Writer. Existem duas situações. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeira situação Precisamos ler os dados do Reader, copiá-los para o Writer (de forma transparente) e trabalhar com eles como no Reader. Existe uma implementação do TeeReader para isso. É apresentado no trecho de implementação superior: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ef/rl/jy/efrljy0zmyzxqk-7cbsbdkqialw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funciona como a equipe de Tee no Unix. Eu acho que muitos de vocês já ouviram falar disso.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que esta implementação verifica o número de bytes que lê do Reader empacotado. Veja as condições na segunda linha? Porque quando você escreve essa implementação, fica intuitivamente claro: no caso de um número negativo, você entrará em pânico. E este é outro lugar em que confiamos no leitor embrulhado! Lembro que essas são todas as bibliotecas padrão. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos passar para um caso, por exemplo, como usá-lo. O que faremos no trecho inferior? Baixaremos o arquivo robot.txt do golang.org usando o cliente http padrão.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você sabe, o cliente http nos retorna uma estrutura de resposta, na qual o campo Corpo é uma implementação da interface do Reader. </font><font style="vertical-align: inherit;">Deve ser esclarecido dizendo que esta é uma implementação da interface ReadCloser. </font><font style="vertical-align: inherit;">Mas o ReadCloser é apenas uma interface criada a partir do Reader e do Closer. </font><font style="vertical-align: inherit;">Ou seja, este é um Reader, que pode, em geral, ser fechado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste exemplo (no snippet inferior), coletamos o TeeReader, que lerá os dados deste corpo e os gravará em um arquivo. </font><font style="vertical-align: inherit;">A criação do arquivo hoje, infelizmente, permaneceu nos bastidores, porque tudo não se encaixava. </font><font style="vertical-align: inherit;">Mas, novamente, se você olhar para o dendograma, o tipo de arquivo implementa a interface do Writer, ou seja, podemos escrever para ele. </font><font style="vertical-align: inherit;">É óbvio.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Montamos nosso TeeReader e o lemos usando ReadAll. </font><font style="vertical-align: inherit;">Tudo funciona como esperado: subtraímos o corpo resultante, escrevemos em um arquivo e o vemos em Assad.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maneira iniciante</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A segunda situação. </font><font style="vertical-align: inherit;">Só precisamos ler os dados do Reader e gravá-los no Writer. </font><font style="vertical-align: inherit;">A solução é óbvia ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando comecei a trabalhar com o Go, resolvi problemas como em um slide: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yu/yh/wx/yuyhwxfzki71ar1yp2myfgjffdc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
localizei o buffer, preenchi-o com dados do Reader e transferi a fatia preenchida para o Writer. </font><font style="vertical-align: inherit;">Tudo é simples. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dois pontos. </font><font style="vertical-align: inherit;">Em primeiro lugar, não há garantia de que todo o Reader seja subtraído em uma chamada para o método Read, pois pode haver dados restantes (no bom sentido, isso deve ser feito em loop). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo ponto é que esse caminho não é o ideal. </font><font style="vertical-align: inherit;">Aqui está um código bastante padronizado, escrito antes de nós. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para isso, há uma família especial de ajudantes na biblioteca padrão - são Copy, CopyN e CopyBuffer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Copy. </font><font style="vertical-align: inherit;">WriterTo e ReaderFrom</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
io.Copy basicamente faz o que era no slide anterior: ele aloca um buffer padrão de 32 KB e grava dados do Reader no Writer (a assinatura desta cópia é mostrada no snippet superior): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lx/wi/bd/lxwibd_hiz09op5baq0-d77ukrk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além dessa rotina de modelo, ela também contém uma série de otimizações complicadas. </font><font style="vertical-align: inherit;">E antes de falarmos sobre essas otimizações, precisamos nos familiarizar com mais duas interfaces:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WriterTo;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReadFrom.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Situação hipotética. O seu Reader trabalha com um buffer de memória. Ele já o mudou, escreve, lê algo a partir daí, ou seja, um lugar sob ele já foi realocado. Você quer ler este leitor em algum lugar do lado de fora. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Já vimos como isso acontece: um buffer é criado, o buffer é passado, que é passado para o método Read; O Reader, que trabalha com memória, joga-o fora da peça replicada ... Mas isso não é mais o ideal - o local foi reposicionado. Por que fazer de novo? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/0h/sd/0b/0hsd0ba3ikgudka2q1ujxt9rtbc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em algum lugar há 5 a 6 anos (há um link para a lista de alterações), foram feitas duas interfaces: WriteTo e ReadFrom, que são implementadas localmente. O Reader implementa WriteTo e o Writer implementa ReadFrom. Acontece que o Reader, com uma fatia com os dados já replicados, pode evitar um local adicional e aceitar os métodos Write To Writer e passar um buffer disponível no interior.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É assim que a implementação de bytes.Buffer e bufio funciona. </font><font style="vertical-align: inherit;">E se você olhar o dendrograma novamente, verá que essas duas interfaces não são muito populares. </font><font style="vertical-align: inherit;">Eles são implementados apenas para os tipos que trabalham com o buffer interno - onde a memória já foi realocada. </font><font style="vertical-align: inherit;">Isso não ajudará você a evitar eloqüência todas as vezes, mas apenas se você já estiver trabalhando com uma peça realocada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O ReaderFrom funciona de maneira semelhante (é implementado apenas pelo Writer). </font><font style="vertical-align: inherit;">O ReaderFrom lê o Reader inteiro, que é um argumento para ele (antes do EOF) e grava em algum lugar na implementação interna do Writer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementação CopyBuffer</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este trecho mostra a implementação do auxiliar copyBuffer. Este copyBuffer não exportável é usado sob o capô de io.Copy, CopyN e CopyBuffer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E aqui há uma pequena nuance que vale a pena mencionar. CopyN foi recentemente otimizado - desamarrado dessa lógica. Essa é exatamente a otimização sobre a qual falei anteriormente: antes de criar um buffer adicional de 32 KB, é feita uma verificação - talvez a fonte de dados implemente a interface WriterTo e esse buffer adicional não seja necessário? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se isso não acontecer, verificamos: talvez o Writer implemente o ReaderFrom para conectá-los sem esse intermediário? Se isso não acontecer, a última esperança permanece: talvez tenhamos recebido algum tipo de buffer realocado que poderíamos usar? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lz/yr/3q/lzyr3qrkehj5qudwoerwitlr6uq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É assim que a io.Copy funciona.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há uma questão, que é uma semi-proposta, um semi-bug - não está claro o que. </font><font style="vertical-align: inherit;">Está pendurado há um ano e meio. </font><font style="vertical-align: inherit;">Parece assim: CopyBuffer está semanticamente incorreto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, não há assinatura para este copyBuffer, mas ele se parece exatamente com esse método não exportável. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando você chama copyBuffer na esperança de evitar um local adicional, transfere algum tipo de byte de fatia realocado para lá, a seguinte lógica funciona: se o Reader ou o Writer implementarem as interfaces WriterTo e ReaderFrom, não haverá garantia de que você poderá evitar esse local. </font><font style="vertical-align: inherit;">Isso foi aceito como uma proposta e prometeu pensar nisso no Go 2.0. </font><font style="vertical-align: inherit;">Por enquanto, você só precisa saber.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabalhe com io.Pipe. </font><font style="vertical-align: inherit;">PipeReader e pipeWriter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro caso: você precisa obter dados do Writer de alguma forma no Reader. Caso de vida bonito. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine que você já possui alguns dados, eles implementam a interface do Reader - tudo fica claro com isso. Você precisa compactar esses dados, “ajustá-los” e enviá-los ao S3. Qual é a nuance? .. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quem trabalhou com o tipo gzip no pacote compess sabe que o próprio gzip'er é apenas um proxy: ele coleta dados, implementa a interface Writer, grava os dados, algo fará com eles e então eu tenho que deixá-los em algum lugar. No construtor, é necessária uma implementação da interface do Writer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, aqui precisamos de algum tipo de gravador intermediário, onde descartamos os dados já compactados que são arquivados no primeiro estágio. Nosso próximo passo é fazer o upload desses dados para o S3. E o cliente padrão da AWS aceita a interface io.Reader como fonte de dados. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-u/ai/hl/-uaihlpfwlyjeil6iorgelvue2a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O slide mostra o pipeline - mostra como fica: precisamos ultrapassar os dados do Reader para o Writer, do Writer para o Reader. Como fazer isso? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A biblioteca padrão possui um recurso interessante - io.Pipe. Ele retorna dois valores: pipeReader e pipeWriter. Este par está inextricavelmente vinculado. Imagine um “telefone para bebês” em copos com cordas: não faz sentido falar em um copo enquanto ninguém está ouvindo do outro lado ...</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/zm/kj/rfzmkj2jivwatxxbukwdesrxvoe.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que esse io.Pipe faz? </font><font style="vertical-align: inherit;">Ele não será lido até que ninguém grave os dados. </font><font style="vertical-align: inherit;">E vice-versa, ele não escreverá nada até que ninguém leia esses dados do outro lado. </font><font style="vertical-align: inherit;">Aqui está um exemplo de implementação: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fk/qa/ze/fkqazendof7z_uoop8kbfzmtxuk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faremos o mesmo aqui. </font><font style="vertical-align: inherit;">Vamos ler o arquivo robot.txt, que foi lido antes, compactá-lo usando nosso gzip e enviá-lo para o S3.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na primeira linha, um par é criado - pipeReader, pipeWriter. </font><font style="vertical-align: inherit;">Em seguida, precisamos executar pelo menos uma goroutine, que lerá os dados de uma extremidade (um tipo de tubo). </font><font style="vertical-align: inherit;">Neste gorutin, execute o uploader com uma fonte de dados (source - pipeReader).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na próxima etapa, precisamos compactar os dados. </font><font style="vertical-align: inherit;">Nós compactamos os dados e os escrevemos no pipeWriter (será a outra extremidade do pipe), e a goroutine já em execução recebe os dados na outra extremidade do pipe e os lê. </font><font style="vertical-align: inherit;">Quando todo esse sanduíche estiver pronto, tudo o que resta é atear fogo ao pavio ...</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copiar na última linha grava dados do corpo no gzip que criamos (ou seja, do Reader para o Writer). </font><font style="vertical-align: inherit;">Tudo isso funciona como esperado.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este exemplo pode ser resolvido de outra maneira. </font><font style="vertical-align: inherit;">Se você usar qualquer implementação que implemente o Reader e o Writer. </font><font style="vertical-align: inherit;">Você primeiro grava dados nele e depois os lê. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Foi uma demonstração clara de como trabalhar com o io.Pipe.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outras implementações</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é basicamente tudo para mim. Chegamos a implementações interessantes sobre as quais gostaria de falar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ei/9n/wd/ei9nwdzzrqc7ynwdvghvlokaujo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu não disse nada sobre o MultiReader, nem sobre o MultiWriter. E essa é outra implementação interessante da biblioteca padrão, que permite conectar diferentes implementações. Por exemplo, o MultiWriter grava em todos os Writers simultaneamente e o MultiReader lê os Leitores sequencialmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra implementação é chamada limio. Permite definir um limite para subtração. Você pode definir a velocidade em bytes por segundo na qual seu Reader precisa ser lido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra implementação interessante é apenas uma visualização do progresso da leitura - a barra Progress (de algum cara). É chamado ioprogress. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que eu disse tudo isso? O que eu quis dizer com isso?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ha/eq/hq/haeqhquljxa3dyvbxvhpdgn0cvu.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você precisar implementar de repente as interfaces Reader e Writer, faça-o corretamente. </font><font style="vertical-align: inherit;">Ainda não existe uma decisão única sobre quem é responsável pela implementação - assumiremos que todos confiam no contrato. </font><font style="vertical-align: inherit;">Então você precisa cumpri-lo impecavelmente.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o seu caso estiver trabalhando com um buffer reposicionado, não se esqueça das interfaces ReaderFrom e WriterTo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você estiver em um beco sem saída e precisar de exemplos - consulte a biblioteca padrão, existem muitas implementações interessantes nas quais você pode confiar. </font><font style="vertical-align: inherit;">Há documentação lá.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se algo é completamente incompreensível para você, fique à vontade para escrever problemas. </font><font style="vertical-align: inherit;">Os caras lá são adequados, respondem rapidamente, muito educadamente e com competência ajudam você.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/vf/0y/cy/vf0ycy0f6kuyuyuygxoulwpy538.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é tudo para mim. </font><font style="vertical-align: inherit;">Obrigado por vir!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Questões</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pergunta da platéia (B): - Eu tenho uma pergunta simples, eu acho. Conte-nos sobre alguns casos de uso da vida: quais foram usados ​​e por quê? Você disse que o Reader / Writer retorna o tamanho que leu. Você já teve algum problema com isso? quando você exigiu a leitura (não existe apenas ReadAll), mas algo não funcionou? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Devo admitir honestamente que nunca tive casos assim, porque sempre trabalhei com implementações da biblioteca padrão. Mas hipoteticamente, essa situação, é claro, é possível. Em casos específicos, geralmente coletamos tubos multicamadas e, se você permitir um erro desse tipo, o tubo inteiro desmoronará ... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Isso não é um bug. Vamos falar sobre minha pequena experiência. Eu tive um problema com o Booking.com: eles usaram o driver que eu escrevi e eles tiveram um problema - algo não estava funcionando. Existe um protocolo binário padrão que fizemos; localmente, tudo funciona bem, todo mundo está bem, mas descobriu-se que eles têm uma rede muito ruim com um data center. O Reader realmente não retornou tudo (placas de rede ruins, outra coisa). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Mas se ele não devolveu tudo, não deveria ter retornado o sinal do fim (fim) e o cliente deveria voltar. Sob o contrato descrito, o Reader não deve ... Digamos que o Reader, é claro, decide quando ele quer vir, quando ele não quer, no entanto, se ele quiser ler tudo, ele deve esperar pelo EOF. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Mas isso é precisamente por causa da conexão." Esse é exatamente o problema que ocorreu no pacote de rede padrão. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - E ele devolveu o EOF? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ele não devolveu tudo - ele simplesmente não leu tudo. Eu disse a ele: "Leia os próximos 20 bytes". Ele lê. E eu não leio tudo. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Hipoteticamente, isso é possível, porque é apenas uma interface que descreve um protocolo de comunicação. É necessário assistir e desmontar especificamente o estojo. Aqui só posso responder que o cliente, em teoria, deveria ter voltado novamente se não recebesse tudo o que queria. Você pediu uma fatia de 20 bytes, ele subtraiu 15 para você, mas o EOF não veio - você deve voltar ... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Existe um io.ReadFull para esta situação. Foi especialmente projetado para ler a fatia até o fim. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Sim. Eu não disse nada sobre o ReadFull. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Essa é uma situação completamente normal quando o Read não preenche toda a fatia. Você precisa estar preparado para isso. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Este é um caso muito esperado! </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Obrigado pelo relatório - foi interessante. Eu uso os leitores em um proxy pequeno e simples que lê http e grava de outra maneira. Uso o Close Reader para resolver um problema - para fechar o que leio o tempo todo. Preciso confiar cegamente em um contrato? Você disse que pode haver problemas. Ou adicionar verificações adicionais? É teoricamente possível que algo não aconteça completamente neste site. Preciso fazer essas verificações adicionais e não confiar no contrato? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Eu diria o seguinte: se o seu aplicativo tolerar esses erros (por exemplo, se você confiar totalmente no contrato), talvez não. Mas se você não gostaria de ter um "pânico" em si mesmo (como mostrei na leitura negativa no byte.Buffer), ainda assim verificaria. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas isso depende de você. O que posso recomendar para você? Eu acho que apenas pesar os prós e contras. O que acontece se você repentinamente receber um número negativo de bytes? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Obrigado pelo relatório. Infelizmente, não sei nada no Go. Se um "pânico" ocorreu, existe alguma maneira de interceptar essas informações e obter informações sobre o que, onde, como ser tendencioso, para evitar problemas na sexta à noite? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Sim. O mecanismo de recuperação permite "pegar" um pânico e evitá-lo sem cair, relativamente falando. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q_/xq/37/q_xq37jx6hjicmvwwhfhqdmyl7e.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Como suas recomendações para o uso de implementações do Writer e Reader são consistentes com os erros retornados ao implementar soquetes da web. Não vou dar um exemplo concreto, mas o fim do arquivo sempre é usado lá? Tanto quanto me lembro, a mensagem termina com alguns outros significados ... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Essa é uma boa pergunta, porque simplesmente não tenho nada a responder. Deve observar! Se o EOF não vier, o cliente, se ele quiser obter tudo, deverá ir novamente. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Quanto tempo o tubo foi capaz de montar? Existe alguma crença interna de que não vale a pena coletar mais de cinco participantes ou com filiais? Quanto tempo você conseguiu construir uma árvore a partir desses tubos (leitura, gravação)? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Na minha prática, cerca de cinco chamadas consecutivas são ótimas, porque é mais difícil depurar, lembre-se do que flui e para onde vai. Estrutura bastante ramificada é obtida. Mas eu diria em algum lugar 5-7 no máximo. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 5-7 - nesse caso? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Está lendo, por exemplo, alguns dados. Você precisa prometer, e o que faz login, precisa aparar. Prometido - depois de ler esses dados - você precisará enviá-los de volta para algum armazenamento (bem, hipoteticamente). Em qualquer armazenamento implementado pela interface do Writer. Com esse canal, ocorrem de 5 a 6 etapas, embora em uma delas ainda se ramifique para o lado e você continue trabalhando com o Reader. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- De acordo com a maneira Iniciante, você teve um slide interessante. Você pode indicar outros 2-3 pontos interessantes que estavam lá, mas agora é melhor não fazê-los, mas fazê-lo de maneira diferente agora? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Com esse slide, eu queria mostrar exatamente como fazê-lo sem a necessidade de ler o Reader. Nunca me passou pela cabeça que algo parecido com o jeito Iniciante ... Este é provavelmente o principal erro, o principal padrão que deve ser evitado ao trabalhar com Leitores. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apresentador: - Gostaria de acrescentar que é muito importante para um iniciante ler toda a documentação do pacote io, todas as interfaces existentes e compreendê-las. Porque, na verdade, existem muitos deles, e você frequentemente começa a fazer algo por conta própria, embora ele já exista lá e seja implementado corretamente (“certo” - levando em consideração todos os recursos). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pergunta do líder: - Como viver mais?</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Boa pergunta! Prometi dizer se temos tempo. Como resultado da discussão sobre o bug, o LimitedReader teve a seguinte decisão: criar um preservativo de leitor em algum sentido, que proteja contra ameaças externas, envolver um leitor em que você não confia - para impedir que qualquer infecção entre no sistema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E neste Reader, você implementa todas as verificações que não pode fazer: por exemplo, leitura negativa, experimentos com o número de bytes (digamos que você enviou uma fatia de 10 bytes e recuperou 15 - como reagir a isso?) ... Reader e você pode implementar um conjunto dessas verificações. Eu disse: “Talvez vamos adicionar à biblioteca padrão, porque seria útil para todos usarem”?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recebi a resposta de que parece não haver sentido nisso - isso é algo simples que você pode implementar. Todos. Nós vivemos. Confiamos no pessoal do contrato. Mas eu não confiaria. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gj/e0/_c/gje0_c2o6hhots_d3d5hvnfhgnm.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Quando trabalhamos com leitores, gravadores e há uma oportunidade de encontrar uma "bomba" gzip ... Quanto confiamos nos fluxos ReadAll e WriteAll? Ou, no entanto, implementar a leitura do buffer e trabalhar apenas com o buffer? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- O ReadAll em si usa apenas bytes. Bufer sob o capô. </font><font style="vertical-align: inherit;">Quando você quiser usar isso ou aquilo, é aconselhável entrar e ver como essas "tripas" são implementadas. </font><font style="vertical-align: inherit;">Novamente, isso depende dos seus requisitos: se você é intolerante com esses erros que mostrei, precisa verificar se o que vem do Reader empacotado está marcado. </font><font style="vertical-align: inherit;">Se não estiver marcado, use, por exemplo, bufio (lá está tudo marcado). </font><font style="vertical-align: inherit;">Ou faça o que acabei de dizer: um certo proxy Reader, que, de acordo com sua lista de requisitos, verificará esses dados e os devolverá ao cliente ou ao cliente.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ye/of/v1/yeofv1zmhlx3zoyv26wsh5mxway.jpeg"><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/kuyjuGk1USY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um pouco de publicidade :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obrigado por ficar com a gente. Você gosta dos nossos artigos? Deseja ver materiais mais interessantes? Ajude-nos fazendo um pedido ou recomendando aos seus amigos o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPS na nuvem para desenvolvedores a partir de US $ 4,99</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analógico exclusivo de servidores de nível básico que foi inventado por nós para você: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toda a verdade sobre o VPS (KVM) E5-2697 v3 (6 núcleos) 10 GB DDR4 480 GB SSD 1 Gbps de US $ 19 ou como dividir o servidor?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (as opções estão disponíveis com RAID1 e RAID10, até 24 núcleos e até 40GB DDR4). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2 vezes mais barato no data center Equinix Tier IV em Amsterdã?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Somente nós temos </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 TVs Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV a partir de US $ 199</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na Holanda!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - a partir de $ 99! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leia sobre</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como criar um prédio de infraestrutura. </font><font style="vertical-align: inherit;">classe c usando servidores Dell R730xd E5-2650 v4 que custam 9.000 euros por um centavo?</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt491510/index.html">Crie sua imagem com o CentOS 8.1 puro na nuvem da Amazon</a></li>
<li><a href="../pt491512/index.html">Por que Mr. Robot é a melhor série sobre o setor de TI</a></li>
<li><a href="../pt491518/index.html">Notícias do mundo do OpenStreetMap nº 501 (18/02/2020/24/02/2020)</a></li>
<li><a href="../pt491520/index.html">Converter xls em xlsx e xml em c #</a></li>
<li><a href="../pt491522/index.html">Por que as mulheres vivem mais</a></li>
<li><a href="../pt491528/index.html">Minha experiência está realizando 1000 entrevistas. Sinopse do relatório por Yegor Bugaenko</a></li>
<li><a href="../pt491530/index.html">Mais uma vez cerca de 433 MHz transmissores e receptores</a></li>
<li><a href="../pt491532/index.html">Laravel + Docker + Gitlab. Por onde começar</a></li>
<li><a href="../pt491534/index.html">Um breve guia para usar o GDB</a></li>
<li><a href="../pt491536/index.html">YouTube - Erro. Por favor, tente novamente mais tarde. ID de reprodução: <...></a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>