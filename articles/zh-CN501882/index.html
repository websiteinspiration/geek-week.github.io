<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛳️ 🥪 🙅🏻 我们如何使用计算机视觉算法：使用OpenCV.js在移动浏览器中进行视频处理 ☠️ 🏑 🐸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在线识别一个人已经具有了所有可能性，但是到目前为止，很少使用它们。也许我们是率先为用户实现最佳方案的人之一-通过智能手机登录网站，为您的驾驶执照或护照拍照，然后将数据发送到系统。
 
 让我们考虑一下计算机视觉算法如何帮助直接在移动浏览器中识别视频流中的文档。在本文中，我们分享了我们在SimbirS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>我们如何使用计算机视觉算法：使用OpenCV.js在移动浏览器中进行视频处理</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/simbirsoft/blog/501882/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在线识别一个人已经具有了所有可能性，但是到目前为止，很少使用它们。</font><font style="vertical-align: inherit;">也许我们是率先为用户实现最佳方案的人之一-通过智能手机登录网站，为您的驾驶执照或护照拍照，然后将数据发送到系统。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们考虑一下计算机视觉算法如何帮助直接在移动浏览器中识别视频流中的文档。</font><font style="vertical-align: inherit;">在本文中，我们分享了我们在SimbirSoft上如何使用OpenCV.js的经验，可能遇到的困难，如何确保速度并在不减慢速度的情况下获得“流畅的” UX。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jx/y7/u7/jxy7u7brc2ixo10gyheuhr19zcu.png"><br>
<a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任务是什么</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正在开发的算法的业务场景如下。通过手机访问该站点的用户应该能够拍摄其文档并将其发送到系统进行进一步处理。申请使用任何服务时，这可能是身份验证过程的一部分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，Web应用程序比移动应用程序更可取，因为它的可用性和减少的完成操作的时间。该网页不需要安装，可以在加载后立即工作。用户可以在收到链接后立即执行必要的操作-提交应用程序，而不会因其他操作而分心。从业务角度看，这些因素提高了流程的转化率和商业效率。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从体系结构的角度来看，需要该算法直接检测文档的边界并裁剪图像中的多余背景。</font><font style="vertical-align: inherit;">身份验证，身份验证和欺诈检查将由其他组件实施。</font><font style="vertical-align: inherit;">但是，建议至少进行最少的检查，以排除发送名片，空纸矩形和其他明显不相关的图像来处理图像。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为我们项目的一部分，该算法还有以下其他要求：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实时工作能力：在算法运行期间，来自摄像机的视频流不应“变慢”；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有在广泛的对比度和背景纹理下工作的能力：低对比度和对比度，同质和异质背景；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持多种智能手机型号，包括几年前发布的预算型号。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，该项目中没有用于训练机器学习算法的数据集，也无法收集和标记它。</font><font style="vertical-align: inherit;">我们从Google的搜索结果中仅获得了一些测试样本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑到问题的这种表述，我们决定基于opencv库中的经典计算机视觉算法进行开发。</font><font style="vertical-align: inherit;">另一种可能性是使用机器学习算法和神经网络，但是由于性能要求，它已在工作的早期阶段被丢弃：应用后，不可能在所有目标设备上提供实时帧处理。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用方法和算法结构</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该算法的主要思想是参考框架，必须沿着该参考框架对齐文档。</font><font style="vertical-align: inherit;">它的使用可同时追求多个目标。</font><font style="vertical-align: inherit;">首先，它将提供合适的图像尺寸，足以用于文档的进一步处理。</font><font style="vertical-align: inherit;">其次，正如我们稍后将看到的那样，它可以用作搜索文档边框时的候选过滤器之一。</font><font style="vertical-align: inherit;">第三，如果找不到文档的边框，则可用于捕获和裁剪图像。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ru/et/bq/ruetbqsseuefny01b_anvvaa834.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。</font><font style="vertical-align: inherit;">1.算法的一般结构</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该算法的一般结构如图2所示。</font><font style="vertical-align: inherit;">1.视频流中的帧以一个周期进行处理，两次迭代之间的超时设置为符合所需的FPS-我们以每秒30帧的速度停止。</font><font style="vertical-align: inherit;">这样，您可以避免“速度变慢”，并减少处理器的负载和设备的功耗。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个处理的帧都经过预处理，在此期间执行两个主要操作。首先，创建一个固定尺寸为640x480的帧的副本，该算法的其他步骤将通过该副本工作。原始图像也将保留，检测到的文档将被剪切掉。这将保存最终图像的质量。其次，将创建的副本翻译成灰色阴影。该算法将忽略正在处理的文档的颜色，因为该颜色可能因国家/地区而异，甚至在该国家/地区内的不同地区也不同-例如美国的驾驶执照。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
检测文档的第一步是在图像中搜索面部。使用这种启发式方法可以消除名片和其他明显不相关的图像的捕获。使用标准opencv'shash </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CascadeClassifier.detectMultiScale（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和预先</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">训练的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">级联</font><i><font style="vertical-align: inherit;">haarcascade_frontalface_default</font></i><font style="vertical-align: inherit;">进行搜索</font><font style="vertical-align: inherit;">。检测到的面部的最小和最大尺寸受到限制，这可以减少计算成本，并且还进一步限制了图像中文档的比例。当脸部位于参考框内区域的左部分（或护照的左下部分）时，则认为图像中检测到脸部（图2）。这是确保图像中文档正确对齐的附加措施。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文中的示例不包含个人数据。</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/ws/mz/7w/wsmz7wghvpoyfdslngrf59jofms.jpeg"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。 2.图像中人脸的预期位置区域。支撑框显示为红色，预期面部位置区域的边框显示为绿色。</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
检测到面部后，我们继续检测边界。通常在这里使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findContours（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是，这种方法仅在对比情况下才有效，例如，一张纸放在一张黑暗的桌子上。如果对比度较低，或者光线较差，或者某人手里拿着一张纸，用手指覆盖了边框的一部分，则检测到的轮廓会分解为单独的部分，“丢失”重要部分，或者根本无法检测到。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们采取了不同的方法。二值化后，我们首先使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canny（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将图像通过边框过滤器</font><font style="vertical-align: inherit;">，然后使用Huff变换</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HoughLines（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在所得图片中查找线条</font><font style="vertical-align: inherit;">。阈值参数立即设置为足够大，等于30-以过滤检测到的短片段和其他不相关的片段。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
额外地过滤了所得的一组线，仅保留了靠近参考帧的线。为此，我们首先将框架线的方程式转换为极坐标系中的点（rho，theta）-theta始终为0或pi / 2，rho对于每条线都是唯一的。然后，根据欧氏度量，我们从霍夫变换获得的直线中仅选择那些位于控制点附近的直线，同时考虑到值的大小差异。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将过滤后获得的一组线分配到与参考框架的四条线相对应的四组中，找到各组之间成对的线的交点，取平均值并获得四个点的坐标-检测到的文档的角（图3）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zr/7g/lz/zr7glzo5dwn-mofan9fhnthwu8k.jpeg"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。 3.过滤线并定义文档边角。绿线-过滤的结果，黄点-检测到的文档角</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
接下来，您需要确保框架的质量。为此，我们验证框架最后一次保持静止。为此，请使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">absdiff（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从当前帧中减去周期开始时的帧</font><font style="vertical-align: inherit;">，并将其与阈值进行比较。在减法之前，我们还使用高斯滤波器</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GaussianBlur（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平滑图像，</font><font style="vertical-align: inherit;">以减少噪声和其他随机因素的影响。我们还通过计算框架的Laplacian </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laplacian（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，估计其方差并将获得的值与阈值进行比较来</font><font style="vertical-align: inherit;">评估框架的焦点</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果所有检查都成功，则可以进行最后一部分。</font><font style="vertical-align: inherit;">我们将检测到的角度坐标重新计算为原始曝光不足图像的坐标系，并使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">roi（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法切出结果区域</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">成功检测到文档。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实施功能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在算法开发过程中，其主要组件均以python脚本的形式进行组装。之后，将该算法移植到opencv.js和javascript，然后移植到wasm。该方法是在所有阶段都考虑方便性。在python上，我们的团队可以更方便地试验算法的各种变体并进行粗略的参数设置。移植到javascript使得在目标平台（包括各种设备和浏览器）上测试算法的操作成为可能。根据这些检查的结果，对算法参数进行了微调。最后，在wasm上重写代码的关键部分使我们获得了额外的性能提升。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
迁移期间，在OpenCV API中发现了许多差异，从而导致实现方面的微小变化。例如，python中拉普拉斯算子的方差被简单地视为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laplacian（）。Var（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。使用OpenCV.js，无法使用NumPy，但是没有</font><font style="vertical-align: inherit;">提供</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法的替代实现</font><font style="vertical-align: inherit;">。解决方案：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将meanStdDev（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数计算为</font><font style="vertical-align: inherit;">标准偏差（清单1）。</font></font><br>
<br>
<pre><code class="javascript hljs">private isImageBlurry(image: cv.Mat): boolean {
		<span class="hljs-keyword">const</span> laplacian = <span class="hljs-keyword">new</span> cv.Mat();<font></font>
		cv.Laplacian(image, laplacian, cv.CV_64F);<font></font>
		<span class="hljs-keyword">const</span> s_mat = <span class="hljs-keyword">new</span> cv.Mat();<font></font>
		cv.meanStdDev(laplacian, <span class="hljs-keyword">new</span> cv.Mat(), s_mat);
		<span class="hljs-keyword">const</span> s = s_mat.data64F[<span class="hljs-number">0</span>];
		<span class="hljs-keyword">const</span> v = <span class="hljs-built_in">Math</span>.pow(s, <span class="hljs-number">2</span>);
		<span class="hljs-keyword">return</span> (v &lt; <span class="hljs-keyword">this</span>.laplacianVarianceThreshold);<font></font>
	}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单1.通过opencv.js（TypeScript）中拉普拉斯算子的变化来评估对图像的关注度</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
另一个功能是需要减小库的大小。 OpenCV.js原始格式的容量为7.9 MB。通过Internet进行下载会减慢算法的初始化速度。解决此问题的方法是在库组装过程中“修剪”未使用的模块，这可以显着减小输出文件的大小：我们设法实现1.8 MB的大小。可以在配置文件</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">platform / js / opencv_js.config.py</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（清单2）中</font><font style="vertical-align: inherit;">配置程序集中包含的组件</font><font style="vertical-align: inherit;">列表。</font></font><br>
<br>
<pre><code class="javascript hljs">white_list = makeWhiteList([core, imgproc, objdetect, video, dnn, features2d, photo, aruco, calib3d])</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单2.包含在javascript程序集中的opencv模块的原始白名单</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最后，将算法移至Web Worker做出了重要贡献，以确保算法的所需性能。</font><font style="vertical-align: inherit;">此步骤加上FPS的限制，使我们摆脱了算法运行过程中视频流的“减速”，这对UX产生了积极影响。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
捕获和裁剪图像的示例如图2所示。</font><font style="vertical-align: inherit;">4.可以看出，在深色均匀背景下可获得最高品质的裁剪，而在浅色不均匀背景下则可获得最低的品质。</font><font style="vertical-align: inherit;">这是与在不同背景上获得并用于检测文档边界的渐变相关的预期效果。</font><font style="vertical-align: inherit;">在深色背景上，渐变结果要比在浅色背景上大，均匀的背景导致渐变值的变化较小。</font><font style="vertical-align: inherit;">这样可以可靠地检测边界，从而更好地进行裁剪。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/es/my/90/esmy90lihywocpj3-7p5bgttqkg.jpeg"><br>
<img src="https://habrastorage.org/webt/w4/uz/2l/w4uz2lnqlaajyd6eyplijsg72hc.jpeg"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。</font><font style="vertical-align: inherit;">4.使用算法裁剪文档的示例</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文介绍了一种算法，该算法可从适用于移动浏览器的视频流中检测帧上的文档，并考虑使用opencv.js库实现的功能。</font><font style="vertical-align: inherit;">该算法可让您获得足够质量的文档输出图像，以供算法进一步用于身份验证，身份验证等。</font><font style="vertical-align: inherit;">最终实现的速度使您可以获得“流畅的” UX，而不会出现“速度降低”和帧丢失的情况。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">感谢您的关注！</font><font style="vertical-align: inherit;">希望本文对您有所帮助。</font></font></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN501868/index.html">如何不让会计师丢脸，还是我们将1C转移到云端。分步指导</a></li>
<li><a href="../zh-CN501870/index.html">枚举第二部分中的最大值数</a></li>
<li><a href="../zh-CN501872/index.html">控制论系统中的学习地点</a></li>
<li><a href="../zh-CN501874/index.html">现代前端架构（第2部分）</a></li>
<li><a href="../zh-CN501880/index.html">关于没有开始，开始和开始的“开始”和“开始”的翻译</a></li>
<li><a href="../zh-CN501884/index.html">电子医疗信息档案库将如何帮助更有效地诊断疾病</a></li>
<li><a href="../zh-CN501886/index.html">空间并不像听起来那样简单。</a></li>
<li><a href="../zh-CN501888/index.html">如何降低与勒索软件相关的风险</a></li>
<li><a href="../zh-CN501890/index.html">React Native-将照片和视频保存到设备库</a></li>
<li><a href="../zh-CN501892/index.html">不是我的左腿：对木乃伊病患者的大脑结构的分析</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>