<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🚀 👇🏼 👨🏿‍🤝‍👨🏾 Attaque d'un pixel. Ou comment tromper un réseau de neurones 💂 😆 💎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Familiarisons-nous avec l'une des attaques contre le réseau neuronal, qui conduit à des erreurs de classification avec un minimum d'influences externe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Attaque d'un pixel. Ou comment tromper un réseau de neurones</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498114/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Familiarisons-nous avec l'une des attaques contre le réseau neuronal, qui conduit à des erreurs de classification avec un minimum d'influences externes. Imaginez un instant que le réseau neuronal c'est vous. Et pour le moment, en buvant une tasse de café aromatique, vous classez les images de chats avec une précision de plus de 90% sans même soupçonner que «l'attaque d'un pixel» a transformé tous vos «chats» en camions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant, nous allons faire une pause, déplacer le café de côté, importer toutes les bibliothèques dont nous avons besoin et analyser le fonctionnement de ces attaques à un pixel.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le but de cette attaque est de faire que l'algorithme (réseau de neurones) donne une réponse incorrecte. </font><font style="vertical-align: inherit;">Ci-dessous, nous le verrons avec plusieurs modèles différents de réseaux de neurones convolutionnels. </font><font style="vertical-align: inherit;">En utilisant l'une des méthodes d'optimisation mathématique multidimensionnelle - évolution différentielle, nous trouvons un pixel spécial qui peut changer l'image de sorte que le réseau de neurones commence à classer incorrectement cette image (malgré le fait qu'auparavant l'algorithme «reconnaissait» la même image correctement et avec une grande précision). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Importez les bibliothèques:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Python Libraries</span><font></font>
%matplotlib inline<font></font>
<span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> matplotlib
<span class="hljs-keyword">from</span> keras.datasets <span class="hljs-keyword">import</span> cifar10
<span class="hljs-keyword">from</span> keras <span class="hljs-keyword">import</span> backend <span class="hljs-keyword">as</span> K<font></font>
<font></font>
<span class="hljs-comment"># Custom Networks</span>
<span class="hljs-keyword">from</span> networks.lenet <span class="hljs-keyword">import</span> LeNet
<span class="hljs-keyword">from</span> networks.pure_cnn <span class="hljs-keyword">import</span> PureCnn
<span class="hljs-keyword">from</span> networks.network_in_network <span class="hljs-keyword">import</span> NetworkInNetwork
<span class="hljs-keyword">from</span> networks.resnet <span class="hljs-keyword">import</span> ResNet
<span class="hljs-keyword">from</span> networks.densenet <span class="hljs-keyword">import</span> DenseNet
<span class="hljs-keyword">from</span> networks.wide_resnet <span class="hljs-keyword">import</span> WideResNet
<span class="hljs-keyword">from</span> networks.capsnet <span class="hljs-keyword">import</span> CapsNet<font></font>
<font></font>
<span class="hljs-comment"># Helper functions</span>
<span class="hljs-keyword">from</span> differential_evolution <span class="hljs-keyword">import</span> differential_evolution
<span class="hljs-keyword">import</span> helper<font></font>
<font></font>
matplotlib.style.use(<span class="hljs-string">'ggplot'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour notre expérience, nous chargerons l'ensemble de données CIFAR-10 contenant des images du monde réel divisées en 10 classes.</font></font><br>
<br>
<pre><code class="python hljs">(x_train, y_train), (x_test, y_test) = cifar10.load_data()<font></font>
<font></font>
class_names = [<span class="hljs-string">'airplane'</span>, <span class="hljs-string">'automobile'</span>, <span class="hljs-string">'bird'</span>, <span class="hljs-string">'cat'</span>, <span class="hljs-string">'deer'</span>, <span class="hljs-string">'dog'</span>, <span class="hljs-string">'frog'</span>, <span class="hljs-string">'horse'</span>, <span class="hljs-string">'ship'</span>, <span class="hljs-string">'truck'</span>]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons n'importe quelle image par son index. </font><font style="vertical-align: inherit;">Par exemple, ici sur ce cheval.</font></font><br>
<br>
<pre><code class="python hljs">image_id = <span class="hljs-number">99</span> <span class="hljs-comment"># Image index in the test set</span><font></font>
helper.plot_image(x_test[image_id])<font></font>
</code></pre><br>
<img src="https://habrastorage.org/webt/gp/k9/gw/gpk9gwtmh-_e8e5jcni2vhcej70.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devrons rechercher le pixel très puissant qui peut changer la réponse du réseau neuronal, ce qui signifie qu'il est temps d'écrire une fonction pour changer un ou plusieurs pixels de l'image.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">perturb_image</span>(<span class="hljs-params">xs, img</span>):</span>
    <span class="hljs-comment"># If this function is passed just one perturbation vector,</span>
    <span class="hljs-comment"># pack it in a list to keep the computation the same</span>
    <span class="hljs-keyword">if</span> xs.ndim &lt; <span class="hljs-number">2</span>:<font></font>
        xs = np.array([xs])<font></font>
    <font></font>
    <span class="hljs-comment"># Copy the image n == len(xs) times so that we can </span>
    <span class="hljs-comment"># create n new perturbed images</span>
    tile = [len(xs)] + [<span class="hljs-number">1</span>]*(xs.ndim+<span class="hljs-number">1</span>)<font></font>
    imgs = np.tile(img, tile)<font></font>
    <font></font>
    <span class="hljs-comment"># Make sure to floor the members of xs as int types</span><font></font>
    xs = xs.astype(int)<font></font>
    <font></font>
    <span class="hljs-keyword">for</span> x,img <span class="hljs-keyword">in</span> zip(xs, imgs):
        <span class="hljs-comment"># Split x into an array of 5-tuples (perturbation pixels)</span>
        <span class="hljs-comment"># i.e., [[x,y,r,g,b], ...]</span>
        pixels = np.split(x, len(x) // <span class="hljs-number">5</span>)
        <span class="hljs-keyword">for</span> pixel <span class="hljs-keyword">in</span> pixels:
            <span class="hljs-comment"># At each pixel's x,y position, assign its rgb value</span><font></font>
            x_pos, y_pos, *rgb = pixel<font></font>
            img[x_pos, y_pos] = rgb<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> imgs
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vérifiez-le ?! </font><font style="vertical-align: inherit;">Changez un pixel de notre cheval avec les coordonnées (16, 16) en jaune.</font></font><br>
<br>
<pre><code class="python hljs">image_id = <span class="hljs-number">99</span> <span class="hljs-comment"># Image index in the test set</span>
pixel = np.array([<span class="hljs-number">16</span>, <span class="hljs-number">16</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>]) <span class="hljs-comment"># pixel = x,y,r,g,b</span>
image_perturbed = perturb_image(pixel, x_test[image_id])[<span class="hljs-number">0</span>]<font></font>
<font></font>
helper.plot_image(image_perturbed)<font></font>
</code></pre><br>
<img src="https://habrastorage.org/webt/qj/sf/li/qjsflidtymruwiuotebu0r7siby.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour démontrer l'attaque, vous devez télécharger des modèles pré-formés de réseaux de neurones sur notre jeu de données CIFAR-10. </font><font style="vertical-align: inherit;">Nous utiliserons deux modèles lenet et resnet, mais vous pouvez en utiliser d'autres pour vos expériences en décommentant les lignes de code correspondantes.</font></font><br>
<br>
<pre><code class="python hljs">lenet = LeNet()<font></font>
resnet = ResNet()<font></font>
<font></font>
models = [lenet, resnet]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Après avoir chargé les modèles, il est nécessaire d'évaluer les images de test de chaque modèle pour s'assurer que nous n'attaquons que les images correctement classées. </font><font style="vertical-align: inherit;">Le code ci-dessous affiche la précision et le nombre de paramètres pour chaque modèle.</font></font><br>
<br>
<pre><code class="python hljs">network_stats, correct_imgs = helper.evaluate_models(models, x_test, y_test)<font></font>
<font></font>
correct_imgs = pd.DataFrame(correct_imgs, columns=[<span class="hljs-string">'name'</span>, <span class="hljs-string">'img'</span>, <span class="hljs-string">'label'</span>, <span class="hljs-string">'confidence'</span>, <span class="hljs-string">'pred'</span>])<font></font>
<font></font>
network_stats = pd.DataFrame(network_stats, columns=[<span class="hljs-string">'name'</span>, <span class="hljs-string">'accuracy'</span>, <span class="hljs-string">'param_count'</span>])<font></font>
<font></font>
network_stats<font></font>
Evaluating lenet<font></font>
Evaluating resnet<font></font>
<font></font>
Out[<span class="hljs-number">11</span>]:<font></font>
<font></font>
<font></font>
	name        accuracy    param_count<font></font>
<span class="hljs-number">0</span>      lenet        <span class="hljs-number">0.748</span>       <span class="hljs-number">62006</span>
<span class="hljs-number">1</span>      resnet       <span class="hljs-number">0.9231</span>      <span class="hljs-number">470218</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Toutes ces attaques peuvent être divisées en deux classes: WhiteBox et BlackBox. La différence entre eux est que dans le premier cas, nous connaissons tous de manière fiable l'algorithme, le modèle avec lequel nous avons affaire. Dans le cas de la BlackBox, tout ce dont nous avons besoin est une entrée (image) et une sortie (probabilités d'être affectées à l'une des classes). Une attaque pixel fait référence à la BlackBox. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous considérons deux options pour attaquer un seul pixel: non ciblé et ciblé. Dans le premier cas, peu importe à quelle classe le réseau neuronal de notre chat appartiendra, mais surtout pas à la classe des chats. L'attaque ciblée est applicable lorsque nous voulons que notre chat devienne un camion et seulement un camion.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais comment trouver les pixels mêmes dont le changement entraînera un changement de classe de l'image? Comment trouver un pixel en changeant laquelle une attaque de pixel devient possible et réussie? Essayons de formuler ce problème comme un problème d'optimisation, mais seulement en termes très simples: avec une attaque non ciblée, nous devons minimiser la confiance dans la classe souhaitée, et avec ciblé, maximiser la confiance dans la classe cible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de l'exécution de telles attaques, il est difficile d'optimiser la fonction à l'aide d'un gradient. Un algorithme d'optimisation doit être utilisé qui ne repose pas sur la fluidité de la fonction.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rappelons que pour notre expérience, nous utilisons l'ensemble de données CIFAR-10, qui contient des images du monde réel, de 32 x 32 pixels, divisées en 10 classes. </font><font style="vertical-align: inherit;">Cela signifie que nous avons des valeurs discrètes entières de 0 à 31 et des intensités de couleur de 0 à 255, et la fonction ne devrait pas être lisse, mais plutôt irrégulière, comme indiqué ci-dessous: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vs/0k/mv/vs0kmvtq35lowxplx0rsq2-kppw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est pourquoi nous utilisons l'algorithme d'évolution différentielle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais revenons au code et écrivez une fonction qui renvoie la probabilité de fiabilité du modèle. </font><font style="vertical-align: inherit;">Si la classe cible est correcte, nous voulons minimiser cette fonction afin que le modèle soit sûr d'une autre classe (ce qui n'est pas vrai).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict_classes</span>(<span class="hljs-params">xs, img, target_class, model, minimize=True</span>):</span>
    <span class="hljs-comment"># Perturb the image with the given pixel(s) x and get the prediction of the model</span><font></font>
    imgs_perturbed = perturb_image(xs, img)<font></font>
    predictions = model.predict(imgs_perturbed)[:,target_class]<font></font>
    <span class="hljs-comment"># This function should always be minimized, so return its complement if needed</span>
    <span class="hljs-keyword">return</span> predictions <span class="hljs-keyword">if</span> minimize <span class="hljs-keyword">else</span> <span class="hljs-number">1</span> - predictions<font></font>
<font></font>
image_id = <span class="hljs-number">384</span>
pixel = np.array([<span class="hljs-number">16</span>, <span class="hljs-number">13</span>,  <span class="hljs-number">25</span>, <span class="hljs-number">48</span>, <span class="hljs-number">156</span>])<font></font>
model = resnet<font></font>
<font></font>
true_class = y_test[image_id, <span class="hljs-number">0</span>]<font></font>
prior_confidence = model.predict_one(x_test[image_id])[true_class]<font></font>
confidence = predict_classes(pixel, x_test[image_id], true_class, model)[<span class="hljs-number">0</span>]<font></font>
<font></font>
print(<span class="hljs-string">'Confidence in true class'</span>, class_names[true_class], <span class="hljs-string">'is'</span>, confidence)<font></font>
print(<span class="hljs-string">'Prior confidence was'</span>, prior_confidence)<font></font>
helper.plot_image(perturb_image(pixel, x_test[image_id])[<span class="hljs-number">0</span>])<font></font>
<font></font>
Confidence <span class="hljs-keyword">in</span> true <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">bird</span> <span class="hljs-title">is</span> 0.00018887444
<span class="hljs-title">Prior</span> <span class="hljs-title">confidence</span> <span class="hljs-title">was</span> 0.70661753
</span></code></pre><br>
<img src="https://habrastorage.org/webt/re/g3/yn/reg3ync4qxac0hxb5wrr0jus_je.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous aurons besoin de la fonction suivante pour confirmer le critère de réussite de l'attaque, elle retournera True lorsque le changement aura suffi à tromper le modèle.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">attack_success</span>(<span class="hljs-params">x, img, target_class, model, targeted_attack=False, verbose=False</span>):</span>
    <span class="hljs-comment"># Perturb the image with the given pixel(s) and get the prediction of the model</span><font></font>
    attack_image = perturb_image(x, img)<font></font>
    confidence = model.predict(attack_image)[<span class="hljs-number">0</span>]<font></font>
    predicted_class = np.argmax(confidence)<font></font>
    <font></font>
    <span class="hljs-comment"># If the prediction is what we want (misclassification or </span>
    <span class="hljs-comment"># targeted classification), return True</span>
    <span class="hljs-keyword">if</span> verbose:<font></font>
        print(<span class="hljs-string">'Confidence:'</span>, confidence[target_class])
    <span class="hljs-keyword">if</span> ((targeted_attack <span class="hljs-keyword">and</span> predicted_class == target_class) <span class="hljs-keyword">or</span>
        (<span class="hljs-keyword">not</span> targeted_attack <span class="hljs-keyword">and</span> predicted_class != target_class)):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> return None otherwise (not False), due to how Scipy handles its callback function</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons le travail de la fonction critère de succès. </font><font style="vertical-align: inherit;">Afin de démontrer, nous supposons une attaque non ciblée.</font></font><br>
<br>
<pre><code class="python hljs">image_id = <span class="hljs-number">541</span>
pixel = np.array([<span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">185</span>, <span class="hljs-number">36</span>, <span class="hljs-number">215</span>])<font></font>
model = resnet<font></font>
<font></font>
true_class = y_test[image_id, <span class="hljs-number">0</span>]<font></font>
prior_confidence = model.predict_one(x_test[image_id])[true_class]<font></font>
success = attack_success(pixel, x_test[image_id], true_class, model, verbose=<span class="hljs-literal">True</span>)<font></font>
<font></font>
print(<span class="hljs-string">'Prior confidence'</span>, prior_confidence)<font></font>
print(<span class="hljs-string">'Attack success:'</span>, success == <span class="hljs-literal">True</span>)<font></font>
helper.plot_image(perturb_image(pixel, x_test[image_id])[<span class="hljs-number">0</span>])<font></font>
Confidence: <span class="hljs-number">0.07460087</span>
Prior confidence <span class="hljs-number">0.50054216</span>
Attack success: <span class="hljs-literal">True</span>
</code></pre><br>
<img src="https://habrastorage.org/webt/vh/qb/vp/vhqbvpxy3blhf-krbwmmtezadbu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est temps de rassembler tous les puzzles en une seule image. </font><font style="vertical-align: inherit;">Nous utiliserons une petite modification de l'implémentation de l'évolution différentielle dans Scipy.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">attack</span>(<span class="hljs-params">img_id, model, target=None, pixel_count=<span class="hljs-number">1</span>, 
           maxiter=<span class="hljs-number">75</span>, popsize=<span class="hljs-number">400</span>, verbose=False</span>):</span>
    <span class="hljs-comment"># Change the target class based on whether this is a targeted attack or not</span>
    targeted_attack = target <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>
    target_class = target <span class="hljs-keyword">if</span> targeted_attack <span class="hljs-keyword">else</span> y_test[img_id, <span class="hljs-number">0</span>]<font></font>
    <font></font>
    <span class="hljs-comment"># Define bounds for a flat vector of x,y,r,g,b values</span>
    <span class="hljs-comment"># For more pixels, repeat this layout</span>
    bounds = [(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>), (<span class="hljs-number">0</span>,<span class="hljs-number">32</span>), (<span class="hljs-number">0</span>,<span class="hljs-number">256</span>), (<span class="hljs-number">0</span>,<span class="hljs-number">256</span>), (<span class="hljs-number">0</span>,<span class="hljs-number">256</span>)] * pixel_count<font></font>
    <font></font>
    <span class="hljs-comment"># Population multiplier, in terms of the size of the perturbation vector x</span>
    popmul = max(<span class="hljs-number">1</span>, popsize // len(bounds))<font></font>
    <font></font>
    <span class="hljs-comment"># Format the predict/callback functions for the differential evolution algorithm</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict_fn</span>(<span class="hljs-params">xs</span>):</span>
        <span class="hljs-keyword">return</span> predict_classes(xs, x_test[img_id], target_class, <font></font>
                               model, target <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>)<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callback_fn</span>(<span class="hljs-params">x, convergence</span>):</span>
        <span class="hljs-keyword">return</span> attack_success(x, x_test[img_id], target_class, <font></font>
                              model, targeted_attack, verbose)<font></font>
    <font></font>
    <span class="hljs-comment"># Call Scipy's Implementation of Differential Evolution</span><font></font>
    attack_result = differential_evolution(<font></font>
        predict_fn, bounds, maxiter=maxiter, popsize=popmul,<font></font>
        recombination=<span class="hljs-number">1</span>, atol=<span class="hljs-number">-1</span>, callback=callback_fn, polish=<span class="hljs-literal">False</span>)<font></font>
<font></font>
    <span class="hljs-comment"># Calculate some useful statistics to return from this function</span>
    attack_image = perturb_image(attack_result.x, x_test[img_id])[<span class="hljs-number">0</span>]<font></font>
    prior_probs = model.predict_one(x_test[img_id])<font></font>
    predicted_probs = model.predict_one(attack_image)<font></font>
    predicted_class = np.argmax(predicted_probs)<font></font>
    actual_class = y_test[img_id, <span class="hljs-number">0</span>]<font></font>
    success = predicted_class != actual_class<font></font>
    cdiff = prior_probs[actual_class] - predicted_probs[actual_class]<font></font>
<font></font>
    <span class="hljs-comment"># Show the best attempt at a solution (successful or not)</span><font></font>
    helper.plot_image(attack_image, actual_class, class_names, predicted_class)<font></font>
<font></font>
    <span class="hljs-keyword">return</span> [model.name, pixel_count, img_id, actual_class, predicted_class, success, cdiff, prior_probs, predicted_probs, attack_result.x]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est temps de partager les résultats de l'étude (l'attaque) et de voir comment le changement d'un seul pixel transformera une grenouille en chien, un chat en grenouille et une voiture en avion. </font><font style="vertical-align: inherit;">Mais plus les points d'image sont autorisés à changer, plus la probabilité d'une attaque réussie sur une image est élevée. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ga/mc/r2/gamcr2jr7fgitczf7wevptkafwa.png"><img src="https://habrastorage.org/webt/hc/df/xg/hcdfxgdnndfgcug3bb4hn9ij6xk.png"><img src="https://habrastorage.org/webt/qn/l_/zj/qnl_zjqfyz67jemvl5fewdbvvii.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Démontrez une attaque réussie sur une image de grenouille en utilisant le modèle Resnet. </font><font style="vertical-align: inherit;">Nous devrions voir la confiance dans le vrai déclin de la classe après plusieurs itérations.</font></font><br>
<br>
<pre><code class="python hljs">image_id = <span class="hljs-number">102</span>
pixels = <span class="hljs-number">1</span> <span class="hljs-comment"># Number of pixels to attack</span><font></font>
model = resnet<font></font>
<font></font>
_ = attack(image_id, model, pixel_count=pixels, verbose=<span class="hljs-literal">True</span>)<font></font>
<font></font>
Confidence: <span class="hljs-number">0.9938618</span>
Confidence: <span class="hljs-number">0.77454716</span>
Confidence: <span class="hljs-number">0.77454716</span>
Confidence: <span class="hljs-number">0.77454716</span>
Confidence: <span class="hljs-number">0.77454716</span>
Confidence: <span class="hljs-number">0.77454716</span>
Confidence: <span class="hljs-number">0.53226393</span>
Confidence: <span class="hljs-number">0.53226393</span>
Confidence: <span class="hljs-number">0.53226393</span>
Confidence: <span class="hljs-number">0.53226393</span>
Confidence: <span class="hljs-number">0.4211318</span>
</code></pre><br>
<img src="https://habrastorage.org/webt/a2/bw/rh/a2bwrhij-hnpjshjqcpmigtisyi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce sont des exemples d'une attaque non ciblée, et maintenant nous allons mener une attaque ciblée et choisir dans quelle classe nous aimerions que le modèle classe l'image. </font><font style="vertical-align: inherit;">La tâche est beaucoup plus compliquée que la précédente, car nous allons faire classer le réseau de neurones l'image d'un navire comme voiture et d'un cheval comme chat. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yr/n5/sw/yrn5swb3-4bqoyfujgxz6dfdome.png"><img src="https://habrastorage.org/webt/li/cp/iy/licpiypraj8dcsuxolvh2etbdde.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ci-dessous, nous essaierons d'obtenir lenet pour classer l'image du navire en tant que voiture.</font></font><br>
<br>
<pre><code class="python hljs">image_id = <span class="hljs-number">108</span>
target_class = <span class="hljs-number">1</span> <span class="hljs-comment"># Integer in range 0-9</span>
pixels = <span class="hljs-number">3</span><font></font>
model = lenet<font></font>
<font></font>
print(<span class="hljs-string">'Attacking with target'</span>, class_names[target_class])<font></font>
_ = attack(image_id, model, target_class, pixel_count=pixels, verbose=<span class="hljs-literal">True</span>)<font></font>
Attacking <span class="hljs-keyword">with</span> target automobile<font></font>
Confidence: <span class="hljs-number">0.044409167</span>
Confidence: <span class="hljs-number">0.044409167</span>
Confidence: <span class="hljs-number">0.044409167</span>
Confidence: <span class="hljs-number">0.054611664</span>
Confidence: <span class="hljs-number">0.054611664</span>
Confidence: <span class="hljs-number">0.054611664</span>
Confidence: <span class="hljs-number">0.054611664</span>
Confidence: <span class="hljs-number">0.054611664</span>
Confidence: <span class="hljs-number">0.054611664</span>
Confidence: <span class="hljs-number">0.054611664</span>
Confidence: <span class="hljs-number">0.054611664</span>
Confidence: <span class="hljs-number">0.054611664</span>
Confidence: <span class="hljs-number">0.054611664</span>
Confidence: <span class="hljs-number">0.054611664</span>
Confidence: <span class="hljs-number">0.054611664</span>
Confidence: <span class="hljs-number">0.081972085</span>
Confidence: <span class="hljs-number">0.081972085</span>
Confidence: <span class="hljs-number">0.081972085</span>
Confidence: <span class="hljs-number">0.081972085</span>
Confidence: <span class="hljs-number">0.1537778</span>
Confidence: <span class="hljs-number">0.1537778</span>
Confidence: <span class="hljs-number">0.1537778</span>
Confidence: <span class="hljs-number">0.22246778</span>
Confidence: <span class="hljs-number">0.23916133</span>
Confidence: <span class="hljs-number">0.25238588</span>
Confidence: <span class="hljs-number">0.25238588</span>
Confidence: <span class="hljs-number">0.25238588</span>
Confidence: <span class="hljs-number">0.44560355</span>
Confidence: <span class="hljs-number">0.44560355</span>
Confidence: <span class="hljs-number">0.44560355</span>
Confidence: <span class="hljs-number">0.5711696</span>
</code></pre><br>
<img src="https://habrastorage.org/webt/xi/ym/pn/xiympn3dd-xburofpy5tl34yybu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir traité des cas uniques d'attaques, nous collecterons des statistiques en utilisant l'architecture des réseaux de neurones convolutionnels ResNet, en passant par chaque modèle, en changeant 1, 3 ou 5 pixels de chaque image. </font><font style="vertical-align: inherit;">Dans cet article, nous montrons les conclusions finales sans déranger le lecteur à se familiariser avec chaque itération, car cela prend beaucoup de temps et de ressources de calcul.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">attack_all</span>(<span class="hljs-params">models, samples=<span class="hljs-number">500</span>, pixels=(<span class="hljs-params"><span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span></span>), targeted=False, 
               maxiter=<span class="hljs-number">75</span>, popsize=<span class="hljs-number">400</span>, verbose=False</span>):</span><font></font>
    results = []<font></font>
    <span class="hljs-keyword">for</span> model <span class="hljs-keyword">in</span> models:<font></font>
        model_results = []<font></font>
        valid_imgs = correct_imgs[correct_imgs.name == model.name].img<font></font>
        img_samples = np.random.choice(valid_imgs, samples, replace=<span class="hljs-literal">False</span>)<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> pixel_count <span class="hljs-keyword">in</span> pixels:
            <span class="hljs-keyword">for</span> i, img_id <span class="hljs-keyword">in</span> enumerate(img_samples):<font></font>
                print(<span class="hljs-string">'\n'</span>, model.name, <span class="hljs-string">'- image'</span>, img_id, <span class="hljs-string">'-'</span>, i+<span class="hljs-number">1</span>, <span class="hljs-string">'/'</span>, len(img_samples))<font></font>
                targets = [<span class="hljs-literal">None</span>] <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> targeted <span class="hljs-keyword">else</span> range(<span class="hljs-number">10</span>)<font></font>
                <font></font>
                <span class="hljs-keyword">for</span> target <span class="hljs-keyword">in</span> targets:
                    <span class="hljs-keyword">if</span> targeted:<font></font>
                        print(<span class="hljs-string">'Attacking with target'</span>, class_names[target])
                        <span class="hljs-keyword">if</span> target == y_test[img, <span class="hljs-number">0</span>]:
                            <span class="hljs-keyword">continue</span><font></font>
                    result = attack(img_id, model, target, pixel_count, <font></font>
                                    maxiter=maxiter, popsize=popsize, <font></font>
                                    verbose=verbose)<font></font>
                    model_results.append(result)<font></font>
                    <font></font>
        results += model_results<font></font>
        helper.checkpoint(results, targeted)<font></font>
    <span class="hljs-keyword">return</span> results<font></font>
<font></font>
untargeted = attack_all(models, samples=<span class="hljs-number">100</span>, targeted=<span class="hljs-literal">False</span>)<font></font>
<font></font>
targeted = attack_all(models, samples=<span class="hljs-number">10</span>, targeted=<span class="hljs-literal">False</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour tester la possibilité de discrédit du réseau, un algorithme a été développé et son effet sur la qualité des prévisions de la solution de reconnaissance de formes a été mesuré. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons les résultats finaux.</font></font><br>
<br>
<pre><code class="python hljs">untargeted, targeted = helper.load_results()<font></font>
<font></font>
columns = [<span class="hljs-string">'model'</span>, <span class="hljs-string">'pixels'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-string">'true'</span>, <span class="hljs-string">'predicted'</span>, <span class="hljs-string">'success'</span>, <span class="hljs-string">'cdiff'</span>, <span class="hljs-string">'prior_probs'</span>, <span class="hljs-string">'predicted_probs'</span>, <span class="hljs-string">'perturbation'</span>]<font></font>
<font></font>
untargeted_results = pd.DataFrame(untargeted, columns=columns)<font></font>
targeted_results = pd.DataFrame(targeted, columns=columns)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tableau ci-dessous montre qu'en utilisant le réseau neuronal ResNet avec une précision de 0,9231, en changeant plusieurs pixels de l'image, nous avons obtenu un très bon pourcentage d'images attaquées avec succès (attack_success_rate).</font></font><br>
<br>
<pre><code class="python hljs">helper.attack_stats(targeted_results, models, network_stats)<font></font>
Out[<span class="hljs-number">26</span>]:<font></font>
	model	accuracy   pixels	attack_success_rate<font></font>
<span class="hljs-number">0</span>	resnet	<span class="hljs-number">0.9231</span>	    <span class="hljs-number">1</span>	        <span class="hljs-number">0.144444</span>
<span class="hljs-number">1</span>	resnet	<span class="hljs-number">0.9231</span>	    <span class="hljs-number">3</span>	        <span class="hljs-number">0.211111</span>
<span class="hljs-number">2</span>	resnet	<span class="hljs-number">0.9231</span>	    <span class="hljs-number">5</span>	        <span class="hljs-number">0.222222</span><font></font>
<font></font>
helper.attack_stats(untargeted_results, models, network_stats)<font></font>
Out[<span class="hljs-number">27</span>]:<font></font>
	model	accuracy   pixels	attack_success_rate<font></font>
<span class="hljs-number">0</span>	resnet	<span class="hljs-number">0.9231</span>	   <span class="hljs-number">1</span>	        <span class="hljs-number">0.34</span>
<span class="hljs-number">1</span>	resnet	<span class="hljs-number">0.9231</span>	   <span class="hljs-number">3</span>	        <span class="hljs-number">0.79</span>
<span class="hljs-number">2</span>	resnet	<span class="hljs-number">0.9231</span>	   <span class="hljs-number">5</span>	        <span class="hljs-number">0.79</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans vos expériences, vous êtes libre d'utiliser d'autres architectures de réseaux de neurones artificiels, car il y en a actuellement un grand nombre. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ta/lw/tv/talwtvpnwkzp2od0p-8q9o28eli.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les réseaux de neurones ont enveloppé le monde moderne de fils invisibles. Depuis longtemps, des services ont été inventés où, grâce à l'IA (intelligence artificielle), les utilisateurs reçoivent des photos traitées stylistiquement similaires au travail de grands artistes, et aujourd'hui les algorithmes eux-mêmes peuvent dessiner des images, créer des chefs-d'œuvre musicaux, écrire des livres et même des scripts pour des films. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des domaines tels que la vision par ordinateur, la reconnaissance faciale, les véhicules sans pilote, le diagnostic des maladies - prennent des décisions importantes et n'ont pas le droit de faire des erreurs, et l'interférence avec le fonctionnement des algorithmes entraînera des conséquences désastreuses.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une attaque à un pixel est un moyen d'usurper les attaques. </font><font style="vertical-align: inherit;">Pour tester la possibilité de discrédit du réseau, un algorithme a été développé et son effet sur la qualité des prévisions de la solution de reconnaissance de formes a été mesuré. </font><font style="vertical-align: inherit;">Le résultat a montré que les architectures de réseaux de neurones convolutifs utilisées sont vulnérables à l'algorithme d'attaque à un pixel spécialement formé, qui remplace un pixel, afin de discréditer l'algorithme de reconnaissance. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'article a été préparé par </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Andronic</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adrey Cherny-Tkach</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans le cadre d'un stage chez </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr498094/index.html">Comment nous avons transféré toutes les communications internes de l'entreprise vers en ligne</a></li>
<li><a href="../fr498096/index.html">Comment une démo Memories tient dans 256 octets</a></li>
<li><a href="../fr498100/index.html">Conception de clusters Kubernetes: combien devraient-ils y en avoir?</a></li>
<li><a href="../fr498104/index.html">Comment les sites sont développés à partir de 100 000 $</a></li>
<li><a href="../fr498110/index.html">«Que faire lorsque des changements spectaculaires dans les processus démotivent une équipe.» L'expérience de l'ingénieur backend devenu chef d'équipe</a></li>
<li><a href="../fr498118/index.html">Conférences sur la télécommande: transformation en ligne du groupe JUG Ru</a></li>
<li><a href="../fr498120/index.html">Optimisation du temps de construction - Partie 1</a></li>
<li><a href="../fr498122/index.html">Comment tester sur un site distant pour ne pas ruiner le produit et votre vie</a></li>
<li><a href="../fr498124/index.html">Télégramme pour le support technique: outils et pièges</a></li>
<li><a href="../fr498126/index.html">Comment Amazon essaie d'amener les gens à acheter ... moins</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>