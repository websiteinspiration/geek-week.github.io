<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÜôÔ∏è üìõ ü§ûüèº Un peu sur les d√©localisations dans le noyau Linux üë©‚Äçüë©‚Äçüëß‚Äçüëß üõ¥ üêÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous allons r√©soudre un probl√®me simple - s√©lectionner un bloc de m√©moire dans l'espace du noyau Linux, y mettre du code binaire et l'ex√©cuter. Pour c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Un peu sur les d√©localisations dans le noyau Linux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504442/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons r√©soudre un probl√®me simple - s√©lectionner un bloc de m√©moire dans l'espace du noyau Linux, y mettre du code binaire et l'ex√©cuter. </font><font style="vertical-align: inherit;">Pour ce faire, nous √©crivons un module du noyau, nous y d√©finissons la fonction foo, qui jouera le r√¥le du code binaire dont nous avons besoin, puis, en utilisant la fonction module_alloc, s√©lectionnez le bloc de m√©moire, copiez-lui toute cette fonction via memcpy et lui donnez le contr√¥le. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici √† quoi √ßa ressemble:</font></font><br>
<a name="habracut"></a><br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	return (ret + 2);<font></font>
}<font></font>
<font></font>
static int exe_init(void)<font></font>
{<font></font>
	int ret = 0;<font></font>
	int (*new_foo)(int);<font></font>
<font></font>
	ret = foo(0);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	new_foo = module_alloc(PAGE_SIZE);<font></font>
	set_memory_x((unsigned long)new_foo, 1);<font></font>
<font></font>
	printk(KERN_INFO "foo=%lx new_foo=%lx\n",<font></font>
		(unsigned long)foo, (unsigned long)new_foo);<font></font>
<font></font>
	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
<font></font>
	ret = new_foo(1);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	vfree(new_foo);<font></font>
	return 0;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction exe_init est appel√©e lorsque le module est charg√©. </font><font style="vertical-align: inherit;">Nous regardons le r√©sultat du travail dans le journal du noyau:</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 6972.522422] ret=2<font></font>
[ 6972.522443] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 6972.522457] ret=3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout fonctionne correctement. </font><font style="vertical-align: inherit;">Et maintenant, nous ajoutons la fonction printk √† foo pour afficher l'argument:</font></font><br>
<br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
	return (ret + 2);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et vider 25 octets du contenu de la fonction new_foo () avant de lui passer le contr√¥le:</font></font><br>
<br>
<pre><code class="plaintext hljs">	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
	dump((unsigned long)new_foo);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
le vidage est d√©fini comme</font></font><br>
<br>
<pre><code class="plaintext hljs">static inline void dump(unsigned long x)<font></font>
{<font></font>
	int i;<font></font>
	for (i = 0; i &lt; 25; i++) \<font></font>
		pr_cont("%.2x ", *((unsigned char *)(x) + i) &amp; 0xFF); \<font></font>
	pr_cont("\n");<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous chargeons le module et obtenons un plantage avec le message suivant dans le journal:</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 8482.806092] ret=0<font></font>
[ 8482.806092] ret=2<font></font>
[ 8482.806111] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 8482.806113] 53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f <font></font>
[ 8482.806135] invalid opcode: 0000 [#1] SMP NOPTI<font></font>
[ 8482.806639] CPU: 0 PID: 5081 Comm: insmod Tainted: G           O      5.4.27 #12<font></font>
[ 8482.807669] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006<font></font>
[ 8482.808560] RIP: 0010:irq_create_direct_mapping+0x79/0x90<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'une mani√®re ou d'une autre, nous nous sommes retrouv√©s dans la fonction irq_create_direct_mapping, bien que nous ayons d√ª appeler printk. </font><font style="vertical-align: inherit;">Voyons ce qui s'est pass√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, jetez un ≈ìil √† la liste d√©mont√©e de la fonction foo. </font><font style="vertical-align: inherit;">Obtenez-le avec la commande objdump -d:</font></font><br>
<br>
<pre><code class="plaintext hljs">Disassembly of section .text:<font></font>
<font></font>
0000000000000000 &lt;foo&gt;:<font></font>
   0:	53                   	push   %rbx<font></font>
   1:	89 fe                	mov    %edi,%esi<font></font>
   3:	89 fb                	mov    %edi,%ebx<font></font>
   5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi<font></font>
   c:	e8 00 00 00 00       	callq  11 &lt;foo+0x11&gt;<font></font>
  11:	8d 43 02             	lea    0x2(%rbx),%eax<font></font>
  14:	5b                   	pop    %rbx<font></font>
  15:	c3                   	retq   <font></font>
  16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)<font></font>
  1d:	00 00 00 <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction foo est situ√©e au d√©but de la section de texte. √Ä l'offset 0xC, l'opcode de la commande d'appel proche e8 est situ√© - pr√®s, car il est ex√©cut√© dans le segment de code actuel, la valeur du s√©lecteur ne change pas. Les 4 octets suivants sont le d√©calage par rapport √† la valeur dans le registre RIP vers lequel le contr√¥le sera transf√©r√©, c'est-√†-dire RIP = RIP + offset, selon la documentation d'Intel (Intel 64 et IA-32 Architectures Software Developer's Manual, Instruction Set Reference AZ):</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un d√©calage relatif (rel16 ou rel32) est g√©n√©ralement sp√©cifi√© sous forme d'√©tiquette dans le code d'assemblage. </font><font style="vertical-align: inherit;">Mais au niveau du code machine, il est cod√© en tant que valeur imm√©diate sign√©e, 16 ou 32 bits. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette valeur est ajout√©e √† la valeur du registre EIP (RIP). </font><font style="vertical-align: inherit;">En mode 64 bits, le d√©calage relatif est toujours une valeur imm√©diate de 32 bits qui est √©tendue √† 64 bits avant d'√™tre ajout√©e √† la valeur du registre RIP pour le calcul cible.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous connaissons l'adresse de la fonction foo, c'est 0xffffffffc0000000, donc dans RIP = 0xffffffffc0000000 + 0xc + 0x5 = 0xffffffffc00000011 (0xc est l'offset √† l'instruction e8, 1 octet de l'instruction et 4 octets de l'offset). </font><font style="vertical-align: inherit;">Nous connaissons le d√©calage, car </font><font style="vertical-align: inherit;">fonctions corporelles sous-√©valu√©es. </font><font style="vertical-align: inherit;">Calculons o√π l'appel √† nous envoyer vers la fonction foo enverra:</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc00000011 + 0xffffffffc10b3de8 = 0xffffffff810b3df9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici l'adresse de la fonction printk:</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810b3df9  <font></font>
ffffffff810b3df9 T printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant, il en va de m√™me pour new_foo, dont l'adresse est 0xffffffffc0007000</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc0007011 + 0xffffffffc10b3de8 = 0xffffffff810badf9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'y a pas une telle adresse dans les kallsymes, mais il y a 0xffffffff810badf9 - 0x79 = 0xffffffff810bad80</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810bad80<font></font>
ffffffff810bad80 T irq_create_direct_mapping<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est la fonction m√™me sur laquelle le crash s'est produit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour √©viter un plantage, recalculez simplement l'offset en connaissant l'adresse de la fonction new_foo:</font></font><br>
<br>
<pre><code class="plaintext hljs">memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
unsigned int delta = (unsigned long)printk - (unsigned long)new_foo - 0x11;<font></font>
*(unsigned int *)((void *)new_foo + 0xD) = delta;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s cette correction, il n'y aura pas de plantage, la fonction new_foo s'ex√©cutera avec succ√®s et renverra le contr√¥le. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le probl√®me est r√©solu. </font><font style="vertical-align: inherit;">Il ne reste plus qu'√† comprendre pourquoi dans le d√©sassembleur listant le d√©calage apr√®s l'opcode e8 est z√©ro, mais il n'y a pas de fonction dans le vidage. </font><font style="vertical-align: inherit;">Pour ce faire, consid√©rez ce que sont les d√©localisations et comment le noyau fonctionne avec elles. </font><font style="vertical-align: inherit;">Mais d'abord, un peu sur le format ELF.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ELF signifie Executable and Linkable Format - le format des fichiers ex√©cutables et composables. Un fichier ELF est une collection de sections. La section stocke un ensemble d'objets n√©cessaires pour que l'√©diteur de liens forme une image ex√©cutable - instructions, donn√©es, tables de symboles, enregistrements de relocalisations, etc. Chaque section est d√©crite par un en-t√™te. Tous les en-t√™tes sont collect√©s dans un tableau d'en-t√™tes et sont essentiellement un tableau o√π chaque √©l√©ment a un index. L'en-t√™te de section contient un d√©calage par rapport au d√©but de la section et d'autres informations de surcharge, telles que des liens vers d'autres sections en sp√©cifiant un index dans la table d'en-t√™te.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la construction de notre cas de test, le compilateur ne conna√Æt pas l'adresse de la fonction printk, il remplit donc l'emplacement d'appel avec une valeur nulle et, √† l'aide d'un enregistrement de relocalisation, indique au noyau que cette position doit √™tre remplie avec une valeur valide. Un enregistrement de relocalisation contient un d√©calage par rapport √† la position o√π vous souhaitez apporter des modifications (position de relocalisation), le type de relocalisation et l'index du symbole dans la table des symboles, dont l'adresse doit √™tre remplac√©e √† l'offset sp√©cifi√©. √Ä quoi sert la r√©installation? R√©fl√©chissez ci-dessous. L'en-t√™te de la section des enregistrements de relocalisation fait r√©f√©rence par des index aux en-t√™tes de la section avec une table de caract√®res et de sections, par rapport au d√©but desquels un d√©calage par rapport √† la position de la relocalisation est sp√©cifi√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez consulter le contenu des enregistrements de relocalisation √† l'aide de l'utilitaire objdump avec le commutateur -r.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De la liste d√©mont√©e, nous savons qu'√† l'offset 0xD, il est n√©cessaire d'√©crire l'adresse de la fonction printk, nous recherchons donc la sortie objdump avec la position suivante:</font></font><br>
<br>
<pre><code class="plaintext hljs">000000000000000d R_X86_64_PC32     printk-0x0000000000000004
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, nous avons l'enregistrement de relocalisation n√©cessaire indiquant la position √† l'offset 0xD et le nom du symbole dont l'adresse doit √™tre √©crite √† cette position. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Valeur (-4). </font><font style="vertical-align: inherit;">qui est ajout√©e √† l'adresse de la fonction printk est appel√©e addendum, et elle est prise en compte lors du calcul du r√©sultat final de la relocalisation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardez maintenant le symbole printk:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep printk<font></font>
0000000000000000         *UND*	0000000000000000 printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un symbole, il n'est pas d√©fini √† l'int√©rieur du module (non d√©fini), nous allons donc le rechercher dans le noyau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il sera plus instructif d'examiner les enregistrements de relocalisation et les symboles sous forme binaire. </font><font style="vertical-align: inherit;">Cela peut √™tre fait √† l'aide de Wireshark, il peut analyser le format ELF. </font><font style="vertical-align: inherit;">Voici notre entr√©e de relocalisation (copier-coller de writeshark, LSB √† gauche):</font></font><br>
<br>
<pre><code class="plaintext hljs">  0d 00 00 00 00 00 00 00  02 00 00 00 22 00 00 00  fc ff ff ff ff ff ff ff<font></font>
  |                     |  |          ||         |  |                     |<font></font>
  +----  -------+  +--  ---++---+  +---- addendum  ------+<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comparez cette entr√©e avec la d√©finition de la structure correspondante de &lt;linux / elf.h&gt;:</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_rela {<font></font>
  Elf64_Addr r_offset;	/* Location at which to apply the action */<font></font>
  Elf64_Xword r_info;	/* index and type of relocation */<font></font>
  Elf64_Sxword r_addend;	/* Constant addend used to compute value */<font></font>
} Elf64_Rela;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous avons 8 octets de d√©calage 0x00000000d, 4 octets de type 0x00000002, 4 octets d'index dans la table de caract√®res 0x00000022 (ou 34 en d√©cimal) et 8 octets d'addendum -4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et voici l'entr√©e de la table des symboles au num√©ro 34:</font></font><br>
<br>
<pre><code class="plaintext hljs">  01 01 00 00 10 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et structure connexe</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_sym {<font></font>
  Elf64_Word st_name;		/* Symbol name, index in string tbl */<font></font>
  unsigned char	st_info;	/* Type and binding attributes */<font></font>
  unsigned char	st_other;	/* No defined meaning, 0 */<font></font>
  Elf64_Half st_shndx;		/* Associated section index */<font></font>
  Elf64_Addr st_value;		/* Value of the symbol */<font></font>
  Elf64_Xword st_size;		/* Associated symbol size */<font></font>
} Elf64_Sym;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les 4 premiers octets 0x00000101 sont l'index dans le tableau des cha√Ænes .strtab du nom de ce caract√®re, c'est-√†-dire printk. Le champ st_info d√©finit le type de symbole, il peut s'agir d'une fonction, d'un objet de donn√©es, etc., voir la sp√©cification ELF pour plus de d√©tails. Nous allons sauter le champ st_other, maintenant cela ne nous int√©resse plus, et regarder les trois derniers champs st_shndx, st_value et st_size. st_shndx - l'index d'en-t√™te de la section dans laquelle le caract√®re est d√©fini. Nous voyons ici une valeur nulle, car le symbole n'est pas d√©fini √† l'int√©rieur du module, il n'est pas dans les sections disponibles. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par cons√©quent, sa valeur st_value et sa taille st_size sont √©galement nulles. Ces champs seront remplis par le noyau lors du chargement du module. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä titre de comparaison, regardez le symbole foo, qui est clairement pr√©sent:</font></font><br>
<br>
<pre><code class="plaintext hljs">  08 00 00 00 02 00 02 00  00 00 00 00 00 00 00 00  16 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le symbole d√©finit une fonction qui se trouve dans la section .text √† l'adresse par rapport au d√©but de la section 0x00000000, c'est-√†-dire </font><font style="vertical-align: inherit;">au tout d√©but de la section, comme nous l'avons vu dans la liste d√©mont√©e, la taille de la fonction est de 22 octets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objdump nous montrera les m√™mes informations √† ce sujet:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep foo<font></font>
0000000000000000 l     F .text	0000000000000016 foo<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque le noyau charge le module, il trouve tous les caract√®res non d√©finis et remplit les champs st_value et st_size avec des valeurs valides. </font><font style="vertical-align: inherit;">Cela se fait dans la fonction simplify_symbols, fichier kernel / module.c:</font></font><br>
<br>
<pre><code class="plaintext hljs">/* Change all symbols so that st_value encodes the pointer directly. */<font></font>
static int simplify_symbols(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les param√®tres de la fonction, la structure load_info du formulaire suivant est pass√©e</font></font><br>
<br>
<pre><code class="plaintext hljs">struct load_info {<font></font>
	const char *name;<font></font>
	/* pointer to module in temporary copy, freed at end of load_module() */<font></font>
	struct module *mod;<font></font>
	Elf_Ehdr *hdr;<font></font>
	unsigned long len;<font></font>
	Elf_Shdr *sechdrs;<font></font>
	char *secstrings, *strtab;<font></font>
	unsigned long symoffs, stroffs, init_typeoffs, core_typeoffs;<font></font>
	struct _ddebug *debug;<font></font>
	unsigned int num_debug;<font></font>
	bool sig_ok;<font></font>
#ifdef CONFIG_KALLSYMS<font></font>
	unsigned long mod_kallsyms_init_off;<font></font>
#endif<font></font>
	struct {<font></font>
		unsigned int sym, str, mod, vers, info, pcpu;<font></font>
	} index;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les champs suivants nous int√©ressent: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - hdr - en-t√™te de fichier ELF </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - sechdrs - pointeur vers la table des en-t√™tes de section </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - strtab - table des noms de symboles - un ensemble de cha√Ænes s√©par√©es par des z√©ros </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - index.sym - index de l'en-t√™te de section contenant la table des symboles </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, la fonction aura acc√®s √† la section avec la table des symboles. </font><font style="vertical-align: inherit;">La table des symboles est un tableau d'√©l√©ments de type Elf64_Sym:</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Shdr *symsec = &amp;info-&gt;sechdrs[info-&gt;index.sym];<font></font>
Elf64_Sym *sym = (void *)symsec-&gt;sh_addr;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, dans la boucle, nous parcourons tous les caract√®res du tableau, d√©terminant pour chacun son nom:</font></font><br>
<pre><code class="plaintext hljs">for (i = 1; i &lt; symsec-&gt;sh_size / sizeof(Elf_Sym); i++) {<font></font>
	const char *name = info-&gt;strtab + sym[i].st_name;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le champ st_shndx contient l'index d'en-t√™te de la section dans laquelle ce caract√®re est d√©fini. </font><font style="vertical-align: inherit;">S'il y a une valeur nulle (notre cas), alors ce symbole n'est pas √† l'int√©rieur du module, vous devez le chercher dans le noyau:</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (sym[i].st_shndx) {<font></font>
	.....<font></font>
	 case SHN_UNDEF: //  0<font></font>
	ksym = resolve_symbol_wait(mod, info, name);<font></font>
 	/* Ok if resolved.  */<font></font>
	if (ksym &amp;&amp; !IS_ERR(ksym)) {<font></font>
		sym[i].st_value = kernel_symbol_value(ksym);<font></font>
		break;<font></font>
	}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vient ensuite la file d'attente de relocalisation dans la fonction apply_relocations:</font></font><br>
<br>
<pre><code class="plaintext hljs">static int apply_relocations(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
	unsigned int i;<font></font>
	int err = 0;<font></font>
<font></font>
	/* Now do relocations. */<font></font>
	for (i = 1; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la boucle, nous recherchons des sections de relocalisation et traitons les enregistrements de chaque section trouv√©e dans la fonction apply_relocate_add:</font></font><br>
<br>
<pre><code class="plaintext hljs">if (info-&gt;sechdrs[i].sh_type == SHT_RELA) //   <font></font>
	err = apply_relocate_add(info-&gt;sechdrs, info-&gt;strtab,<font></font>
				info-&gt;index.sym, i, mod);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un pointeur vers une table d'en-t√™te de section, un pointeur vers une table de noms de symboles, un index d'en-t√™te de section avec une table de symboles et un index d'en-t√™te de section de relocalisation sont pass√©s √† apply_relocate_add:</font></font><br>
<br>
<pre><code class="plaintext hljs">int apply_relocate_add(Elf64_Shdr *sechdrs,<font></font>
	   const char *strtab,<font></font>
	   unsigned int symindex,<font></font>
	   unsigned int relsec,<font></font>
	   struct module *me)<font></font>
{<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous abordons d'abord la section des d√©localisations:</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Rela *rel = (void *)sechdrs[relsec].sh_addr;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, en boucle, nous trions un tableau de ses entr√©es:</font></font><br>
<br>
<pre><code class="plaintext hljs">for (i = 0; i &lt; sechdrs[relsec].sh_size / sizeof(*rel); i++) {
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous trouvons la section pour la r√©installation et la position en elle, c'est-√†-dire </font><font style="vertical-align: inherit;">o√π nous devons apporter des modifications. </font><font style="vertical-align: inherit;">Le champ sh_info de l'en-t√™te de section de relocalisation est l'index de l'en-t√™te de section pour la relocalisation, le champ r_offset de l'enregistrement de relocalisation est le d√©calage par rapport √† la position √† l'int√©rieur de la section pour la relocalisation:</font></font><br>
<br>
<pre><code class="plaintext hljs">/* This is where to make the change */<font></font>
loc = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'adresse du personnage √† remplacer dans cette position, compte tenu de l'addendum. </font><font style="vertical-align: inherit;">Le champ r_info de l'entr√©e de relocalisation contient l'index de ce symbole dans la table des symboles:</font></font><br>
<br>
<pre><code class="plaintext hljs">	/* This is the symbol it is referring to.  Note that all<font></font>
	   undefined symbols have been resolved.  */<font></font>
	sym = (Elf64_Sym *)sechdrs[symindex].sh_addr<font></font>
		+ ELF64_R_SYM(rel[i].r_info);<font></font>
<font></font>
	val = sym-&gt;st_value + rel[i].r_addend;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le type de d√©localisation d√©termine le r√©sultat final des calculs, dans notre exemple c'est R_X86_64_PLT32:</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (ELF64_R_TYPE(rel[i].r_info)) {<font></font>
	......<font></font>
	case R_X86_64_PLT32:	<font></font>
		if (*(u32 *)loc != 0)<font></font>
			goto invalid_relocation;<font></font>
		val -= (u64)loc;	//   <font></font>
		*(u32 *)loc = val;  //    <font></font>
		break;<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous pouvons calculer nous-m√™mes la valeur finale, sachant que sym-&gt; st_value est l'adresse de la fonction printk 0xffffffff810b3df9, r_addend est (-4), le d√©calage par rapport √† la position de relocalisation est 0xd √† partir du d√©but de la section de texte du module, ou √† partir du d√©but de la fonction foo, c'est-√†-dire </font><font style="vertical-align: inherit;">sera ffffffffc000000d. </font><font style="vertical-align: inherit;">Remplacez toutes ces valeurs et obtenez:</font></font><br>
<br>
<pre><code class="plaintext hljs">val = (u32)(0xffffffff810b3df9 - 0x4 - 0xffffffffc000000d) = 0xc10b3de8
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons le vidage de la fonction foo, que nous avons obtenu au tout d√©but:</font></font><br>
<br>
<pre><code class="plaintext hljs">53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au d√©calage 0xD, la valeur 0xc10b3de8 est trouv√©e, qui est identique √† celle que nous avons calcul√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est ainsi que le noyau traite les d√©localisations et obtient le d√©calage n√©cessaire pour la commande close call. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la pr√©paration de l'article, la version 5.4.27 du noyau Linux a √©t√© utilis√©e.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr504414/index.html">Comment Microsoft a tu√© AppGet</a></li>
<li><a href="../fr504420/index.html">√âcrire une ar√®ne PvP au tour par tour avec des mouvements simultan√©s</a></li>
<li><a href="../fr504430/index.html">Centre des op√©rations de s√©curit√© Tinkoff de la vie quotidienne: analyse du chargeur de d√©marrage unique</a></li>
<li><a href="../fr504434/index.html">Programme √©ducatif pour les parents: comment prot√©ger les enfants du danger sur Internet</a></li>
<li><a href="../fr504438/index.html">30 mitaps par semaine. Nous ouvrons la saison d'√©t√© 2020</a></li>
<li><a href="../fr504444/index.html">Utilisation de Docker en plusieurs √©tapes pour cr√©er des images Windows</a></li>
<li><a href="../fr504448/index.html">Gamers Generation II</a></li>
<li><a href="../fr504450/index.html">JavaScript moderne: une vue lat√©rale</a></li>
<li><a href="../fr504452/index.html">Ontology lance la couche 2, contribuant √† une plateforme de cha√Æne publique plus int√©gr√©e</a></li>
<li><a href="../fr504454/index.html">Meilleurs r√©f√©rentiels GitHub pour les d√©veloppeurs Web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>