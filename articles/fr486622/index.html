<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏿 🕔 ➰ Modèle informatique parallèle 👨🏼‍🎤 🐴 👌🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introduction. Corutinisme compétitif
 Les articles précédents sur le thème de la programmation automatique n'étaient que des «fleurs». La "baie" de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Modèle informatique parallèle</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486622/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Introduction. </font><font style="vertical-align: inherit;">Corutinisme compétitif</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les articles précédents sur le thème de la programmation automatique n'étaient que des «fleurs». La "baie" de la programmation automatique, c'est-à-dire pour ce que vous devez faire, est un modèle de calcul parallèle basé sur le modèle de machine d'état. Alors, allons-y ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le standard C ++ incluait le support tant attendu du multithreading [1]. Mais nous ne l'admirerons ni ne critiquerons ce fait, car le travail avec les threads est alourdi par tant de conditions, de mises en garde et de fonctionnalités que sans exemples réels qui révèlent des problèmes de multithreading, une discussion sur la programmation multithread sera non seulement hâtive, mais aussi assez biaisée. Par conséquent, ci-après, pas principalement sur les flux, mais sur les automates, en tenant compte, bien sûr, des premiers.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le langage C ++ est loin d'être le premier, complété par des constructions de parallélisme. Dans les années 60 du siècle dernier, N. Wirth a proposé une extension parallèle du langage ALGOL [2]. Cependant, les 60 prochaines années n'ont pas clarifié ce qui devrait être considéré comme un algorithme parallèle et quel devrait être le modèle du calcul parallèle. Apparemment, une telle extension tardive du langage C ++ est également liée à cela. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les constructions de longue date du langage ALGOL et leurs analogues plus modernes du langage C ++ ne sont que des méthodes de parallélisation structurelle qui n'introduisent pas de modèle algorithmique parallèle. Pour justifier cela, on peut dire que les tentatives faites au cours du temps passé pour créer un tel modèle formel de calculs ont échoué. Il suffit de dire que les mêmes filets de Petri ne justifiaient pas les grands espoirs placés sur eux.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conséquence, la «spirale» du développement du parallélisme semble être revenue à sa source, n'ayant subi qu'un «développement terminologique». </font><font style="vertical-align: inherit;">Les anciennes coroutines triviales sont devenues soudainement des «coroutines» avancées (papier calque de la coroutine anglaise), et la confusion avec les concepts de parallèle et de simultanéité dans le segment anglophone de la programmation parallèle conduit parfois à des choses paradoxales. </font><font style="vertical-align: inherit;">Par exemple, la première édition du livre [1] diffère de la deuxième édition en remplaçant les termes «parallèle» par «concurrentiel» et «multithread» par «parallèle». </font><font style="vertical-align: inherit;">Donc, comprenez cela dans la situation «qui est qui».</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Modèle de calcul d'automate parallèle</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Personne ne contestera probablement que la prochaine étape qualitative dans le développement de la programmation est liée à la transition vers un modèle informatique parallèle. Mais si cela se produira à la suite du développement évolutif du modèle informatique existant ou s'il s'agira d'un modèle fondamentalement différent, la question est toujours en discussion. Et si les théoriciens se disputent toujours, alors la partie pratiquement motivée des programmeurs utilise déjà des méthodes structurelles pour paralléliser les programmes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La séparation des tâches et l'augmentation de la productivité sont considérées comme les seules raisons d'utiliser la concurrence. Au moins, pour eux ou pour leurs combinaisons, ils réduisent ou essaient de réduire tous les autres [1]. Mais il y a une raison qui est rarement évoquée, mais pour laquelle il vaut généralement la peine de s'engager dans une programmation parallèle. En effet, la vitesse peut être augmentée par des méthodes purement matérielles, et la séparation des tâches avec le parallélisme est liée de la même manière que le travail quotidien des employés de banque avec une liste de leurs fonctions officielles. Et seuls les algorithmes parallèles sont une stratégie qui nous permet de vaincre la complexité des tâches et d'augmenter la fiabilité des programmes. Et tout cela est contraire à l'opinion dominante concernant la programmation multi-thread, qui transforme tout programme parallèle en un produit logiciel complexe et peu fiable.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un système parallèle, composé de nombreux composants, objets, agents, etc. fonctionnant en parallèle et interagissant activement, met en œuvre un algorithme qui est déterminé de nombreuses manières non pas par les algorithmes des composants individuels (bien qu'ils le soient, bien sûr), mais par le nombre de composants, le nombre et genre de connexions entre eux. Pour contrôler cette complexité et comprendre l'algorithme de fonctionnement du système parallèle, vous avez besoin non seulement d'un modèle de calcul parallèle, mais d'un modèle qui a, entre autres, et même surtout, une théorie correspondante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La thèse selon laquelle «souvent un programme parallèle est plus difficile à comprendre ... et, par conséquent, le nombre d'erreurs augmente», pour le moins, est discutable. </font><font style="vertical-align: inherit;">Oui, l'algorithme de programme parallèle peut être assez difficile à comprendre, mais s'il existe une théorie, il peut être "calculé" formellement en utilisant des algorithmes de composants. </font><font style="vertical-align: inherit;">Et du point de vue de la conception, de la mise en œuvre et de la maintenance, les algorithmes des composants sont beaucoup plus simples que l'algorithme du système dans son ensemble. </font><font style="vertical-align: inherit;">Lors de la conception de composants plus simples, nous ferons évidemment moins d'erreurs que la conception d'un système en une seule pièce. </font><font style="vertical-align: inherit;">De plus, les composants débogués peuvent faire partie d'autres systèmes, réduisant la complexité, augmentant la fiabilité et minimisant leurs coûts de conception.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Accès simultané en série</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'article [3] décrit le parallélisme d'un modèle distinct d'une machine à états finis. Ses canaux au niveau de l'exécution des transitions spécifient l'exécution parallèle des fonctions / méthodes qui lui sont associées - prédicats et actions. Dans le même temps, il n'y a aucune restriction sur le parallélisme des prédicats. Quand ils travaillent, ils n'entrent pas en conflit les uns avec les autres, car n'affectent pas le contenu de la mémoire. Les actions, fonctionnant en parallèle, peuvent avoir des données d'entrée et de sortie communes, ainsi que les modifier indépendamment les unes des autres. Et tout cela peut être une source d'incertitude dans la valeur des données de sortie.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le bon fonctionnement des actions dans les situations décrites ci-dessus fournit une mémoire fantôme. </font><font style="vertical-align: inherit;">En y stockant de nouvelles valeurs, on peut utiliser les mêmes données dans une même action, à la fois en entrée et en sortie. </font><font style="vertical-align: inherit;">Un exemple est le modèle d'un générateur d'impulsions rectangulaire, décrit comme y =! Y, où y est la sortie du générateur. </font><font style="vertical-align: inherit;">Son code C ++ dans l'environnement VKPa est montré dans le Listing 1, et les résultats du programme sont montrés dans la Fig. </font><font style="vertical-align: inherit;">1.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 1. Générateur d'impulsions rectangulaire</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSWGenerator</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FSWGenerator(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FSWGenerator(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FSWGenerator(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSWGenerator.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_SWGenerator[] = {<font></font>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FSWGenerator::FSWGenerator(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_SWGenerator, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{<font></font>
    pTAppCore = pInfo;<font></font>
}<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSWGenerator::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-comment">// setting output signals</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSWGenerator::y1</span><span class="hljs-params">()</span> </span>{<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, !<span class="hljs-keyword">bool</span>(pVarY-&gt;GetDataSrc()));<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
 <img src="https://habrastorage.org/webt/3f/ue/ni/3fueni68ys5fwldckqdbodllckm.jpeg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 1. Simulation du fonctionnement du générateur d'impulsions rectangulaire dans le VKPA La</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
machine automatique a dans ce cas une condition avec une transition inconditionnelle (une transition avec un tiret à la place de la condition d'entrée) sous la forme d'une boucle marquée par l'action y1, qui met en œuvre l'inversion de la variable de sortie, qui forme une impulsion rectangulaire en dynamique. Dans le cadre du modèle d'automate, la fréquence du signal impulsionnel peut être contrôlée en réglant la valeur de tact du temps discret de l'espace d'automate dans lequel l'automate est chargé.</font></font><br>
<br>
<i> 1.          ,   .              .        .         .<br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La capacité de contrôler le temps discret de l'automate et la présence de nombreux espaces d'automate ne sont pas les seules, mais importantes, propriétés distinctives de l'environnement VKPa. </font><font style="vertical-align: inherit;">En les utilisant, vous pouvez optimiser les performances d'un programme parallèle. </font><font style="vertical-align: inherit;">Par exemple, les machines qui implémentent la visualisation des données et les dialogues utilisateur doivent être placées dans des espaces d'automate lents, et les processus d'application doivent être répartis entre les espaces d'automate en fonction des priorités et de la vitesse souhaitée, etc. </font><font style="vertical-align: inherit;">etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cadre d'un modèle d'automate, la valeur de la sortie du générateur est facilement liée à l'état actuel du modèle. </font><font style="vertical-align: inherit;">Le code du modèle de générateur, qui a déjà deux états, chacun reflétant l'état de la sortie du générateur, est indiqué dans le listing 2.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 2. Générateur d'ondes carrées sur les états</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_SWGenState[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSWGenState</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    FSWGenState(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_SWGenState, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) {};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSWGenState.h"</span></span>
<span class="hljs-comment">// state machine transition table</span><font></font>
LArc TBL_SWGenState[] = {<font></font>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le nouveau modèle, les états remplacent la variable de sortie, ce qui, comme on peut le voir, simplifie considérablement le modèle du générateur. </font><font style="vertical-align: inherit;">En conséquence, nous avons obtenu une machine «nue», représentée uniquement par une table de conversion. </font><font style="vertical-align: inherit;">Pour surveiller son état actuel «s1» dans VKPa, une variable de type fsa (état) avec le nom SWGenState. (S1) a été créée pour la machine avec le nom SWGenState. </font><font style="vertical-align: inherit;">Il prend une valeur vraie dans l'état s1 et fausse lorsque la machine est dans un état différent. </font><font style="vertical-align: inherit;">En outre, cette variable est déjà utilisée au moyen de l'affichage des données de l'environnement VKPA (voir la tendance du signal sur la figure 2). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xv/it/jp/xvitjpkfffsmaodeyax2cmeotkq.jpeg" alt="image"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. </font><font style="vertical-align: inherit;">2. Modélisation du générateur d'état</font></font><br>
</i><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Modèle de contrôle informatique parallèle</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, en allant vers la création d'un modèle de processus parallèles, il est logique d'utiliser de nombreuses machines à états finis fonctionnant et interagissant simultanément, c'est-à-dire réseau d'automates. Dans ce cas, le problème du choix d'un modèle de temps réseau apparaît, qui peut être le même pour toutes les machines ou, à la limite, individuel pour chacune. En VKPa, le choix a été fait en faveur d'un temps unique (pour plus de détails sur les réseaux synchrones d'automates, voir [5]).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le choix d'un temps unique vous permet de créer une algèbre d'automates ayant des opérations de composition et de décomposition d'automates. En utilisant le premier, vous pouvez trouver l'automate résultant, qui donne une idée précise du fonctionnement d'un système parallèle. Et ici, il convient de rappeler la thèse ci-dessus sur la «complexité de la compréhension» des programmes parallèles. La présence de l'opération de composition nous permet de résoudre le "problème de compréhension" du programme parallèle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien entendu, l'automate résultant pour un réseau d'un grand nombre de composants peut être très volumineux. Mais, heureusement, une compréhension du fonctionnement des sous-systèmes ou réseaux d'un petit nombre de composants est plus souvent requise, pour laquelle la recherche de l'automate résultant ne pose pas de gros problèmes. L'exemple de modèle RS-flip-flop suivant le démontre.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le modèle de déclenchement RS est un exemple d'un système parallèle simple. C'est particulièrement intéressant en présence de rétroactions croisées. Feedbacks, ou, d'une autre manière, chaînes cycliques, boucles, boucles algébriques, etc. sont actuellement un problème sérieux pour les modèles structurels de systèmes parallèles. Dans le cas général, elle est permise en introduisant dans les boucles d'espace des éléments de mémoire. C'est la solution standard proposée par la théorie des automates [4]. La même sortie est recommandée en la personne de MATLAB. L'environnement VKPa est différent en ce qu'il ne nécessite pas l'introduction de tels éléments supplémentaires pour la mise en œuvre des boucles. Notez, et c'est très important, que les circuits réels n'en ont pas besoin non plus (voir le circuit RS-flip-flop).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En figue. </font><font style="vertical-align: inherit;">La figure 3 présente le modèle le plus simple de l'élément AND-NOT, qui consiste en le circuit de déclenchement RS. </font><font style="vertical-align: inherit;">Il ne prend pas en compte les retards des éléments, ainsi que leur type (transport ou retards inertiels). </font><font style="vertical-align: inherit;">Cependant, il contient toujours au moins un temps de retard. </font><font style="vertical-align: inherit;">C'est le moment de la transition d'un état à un autre. </font><font style="vertical-align: inherit;">Le listing 3 montre le code du modèle </font></font><br>
<br>
<img src="https://habrastorage.org/webt/os/8b/am/os8bam0skdc-jwtctewqmbwupci.jpeg" alt="image"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">3. Le modèle de l'élément ET NON</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3. Modèle d'élément ET NON</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FIne</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FIne(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FIne(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FIne(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarX1;				<span class="hljs-comment">//  </span>
    CVar *pVarX2;				<span class="hljs-comment">//  </span>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameY;         <span class="hljs-comment">//   </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">bool</span> bX1, bX2, bY;<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FIne.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_Ine[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12^x1"</span>,	<span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12^x2"</span>,	<span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12x1x2"</span>,	<span class="hljs-string">"y2"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x1x2"</span>,   <span class="hljs-string">"y2"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"^x1"</span>,    <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"^x2"</span>,    <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FIne::FIne(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_Ine, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{ }<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FIne::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"x1"</span>, CLocVar::vtBool, <span class="hljs-string">" 1- "</span>);<font></font>
    pVarX2 = CreateLocVar(<span class="hljs-string">"x2"</span>, CLocVar::vtBool, <span class="hljs-string">" 2- "</span>);<font></font>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameY = CreateLocVar(<span class="hljs-string">"strNameY"</span>, CLocVar::vtString, <span class="hljs-string">"name of external output variable(y)"</span>);		<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX1) {<font></font>
        str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameX2) {<font></font>
        str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>); }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameY) {<font></font>
        str = pVarStrNameY-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>){pVarY = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);}<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">bool</span>(pVarX1-&gt;GetDataSrc()); }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">bool</span>(pVarX2-&gt;GetDataSrc()); }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarY; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y1</span><span class="hljs-params">()</span> </span>{ pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">1</span>); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y2</span><span class="hljs-params">()</span> </span>{ pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0.0</span>); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y12</span><span class="hljs-params">()</span> </span>{ FInit(); }
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En figue. La figure 4 montre un schéma d'une bascule RS et son modèle sous la forme d'une machine à états finis. Les flèches sur le modèle indiquent les connexions entre les machines du réseau. Ici, d'une part, les états des modèles reflètent les états des sorties de l'élément et, d'autre part, ils sont également utilisés comme signaux pour organiser des liens d'information entre des processus parallèles. C'est cette forme du modèle (avec synchronisation par états) qui permet de trouver assez facilement l'automate résultant du réseau. Il est illustré sur la fig. 5 (pour la procédure de recherche de l'automate résultant, voir [6] pour plus de détails).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comparez l'algorithme [résultant] du programme parallèle de bascule RS et l'algorithme de fonctionnement d'un élément AND-NOT séparé. La différence est frappante. Dans ce cas, les algorithmes des composants sont créés par des «poignées» et l'algorithme du système parallèle est créé implicitement - par «l'intelligence artificielle» du réseau. C'est la différence qualitative entre les programmes parallèles et séquentiels: en ne changeant que les communications (au moins une), nous obtiendrons un algorithme de travail complètement différent. Et ce ne sera certainement plus un déclencheur RS. Et, soit dit en passant, un autre automate résultant. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/kb/zi/fc/kbzifcjk_ycehmabwwtsuh_gyfc.jpeg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 4. Schéma du modèle RS-FF et du réseau </font></font><br>
</i><br>
<img src="https://habrastorage.org/webt/_v/ht/2n/_vht2nka0gtsreim8qhjplh_njq.jpeg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 5. Le modèle de réseau de machines résultant RS-trigger</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'analyse de l'automate résultant sur la Fig. 5 donne la "compréhension" suivante du programme parallèle (et du déclencheur réel, bien sûr). Premièrement, lors du passage d'un état à un autre, le déclencheur passera nécessairement par l'état «interdit» des sorties (et qu'en disent les manuels?). Deuxièmement, si le déclencheur est entraîné dans un seul état de sorties (dans l'état "s1w1"), puis que deux unités sont alimentées aux entrées, il passera en mode de génération, c'est-à-dire commutation cyclique entre les états «s1w1» et «s0w0» et (et avez-vous entendu parler de la génération de déclencheurs?).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une transition à travers un état interdit se produit également dans un déclencheur réel, mais le mode de génération est impossible en raison de la différence de retards d'éléments réels. Figure. La figure 6 montre le mode de génération du modèle de déclenchement déclencheur, qui existe tant que les unités aux entrées sont stockées. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque 2. Une description typique du fonctionnement du déclencheur RS est donnée dans la très grande majorité des cas sous la forme d'une table de vérité. Mais pour ce faire, comprendre qu'un déclencheur est un schéma séquentiel, c'est en fait délibérément induire en erreur ceux qui étudient ce sujet. Eh bien, aucun déclencheur ne peut avoir des «états interdits»! Mais pour une raison quelconque, seuls quelques-uns décident de découvrir cette vérité et, en particulier, discutent du problème de sa génération (voir, par exemple, [7]).</font></font><br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure. 7 montre la commutation d'un modèle de déclenchement entre ses états stables. Ici, un seul état des entrées de déclenchement conserve l'état actuel des sorties de déclenchement et lorsque telle ou telle entrée est mise à zéro, elle passe à l'état opposé. En même temps, lorsque le déclencheur est commuté, ses sorties momentanément égales à une mesure discrète prennent en même temps un seul état (interdit par qui?). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/fl/a0/csfla0xnbcpz0ngewn6izuj_cps.jpeg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 6. Mode de génération RS-trigger </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/nc/w5/74/ncw574s_lxpj2qq4oh1krswiclk.jpeg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 7. Commutation RS-trigger entre les états</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérons un autre modèle RS-trigger, composé d'un état et d'une action, c'est-à-dire </font><font style="vertical-align: inherit;">similaire au modèle du Listing 1. Son code est montré dans le Listing 4. Ce modèle, comme le modèle générateur, n'a pas de prédicats et les valeurs du signal sans aucune transformation intermédiaire sont entrées dans l'action y1. </font><font style="vertical-align: inherit;">Est-ce bon ou mauvais? </font><font style="vertical-align: inherit;">D'une part, il semble que ce soit bon, car </font><font style="vertical-align: inherit;">le code est devenu plus simple, mais d'un autre côté ... pas vraiment. </font><font style="vertical-align: inherit;">Et nous en comprendrons maintenant les raisons.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 4. Modèle d'élément NAND à partir d'une seule action</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FTwoOperators</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FTwoOperators(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FTwoOperators(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FTwoOperators(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarX1;				<span class="hljs-comment">//  </span>
    CVar *pVarX2;				<span class="hljs-comment">//  </span>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameY;         <span class="hljs-comment">//   </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">bool</span> bX1, bX2, bY;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FTwoOperators.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_TwoOperators[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12"</span>, <span class="hljs-string">"--"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,  <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FTwoOperators::FTwoOperators(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_TwoOperators, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{ }<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FTwoOperators::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"x1"</span>, CLocVar::vtBool, <span class="hljs-string">" 1- "</span>);<font></font>
    pVarX2 = CreateLocVar(<span class="hljs-string">"x2"</span>, CLocVar::vtBool, <span class="hljs-string">" 2- "</span>);<font></font>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameY = CreateLocVar(<span class="hljs-string">"strNameY"</span>, CLocVar::vtString, <span class="hljs-string">"name of external output variable(y)"</span>);		<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX1) {<font></font>
        str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameX2) {<font></font>
        str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>); }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameY) {<font></font>
        str = pVarStrNameY-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarY = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FTwoOperators::x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarY; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTwoOperators::y1</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// reading input signals</span>
    bX1 = <span class="hljs-keyword">bool</span>(pVarX1-&gt;GetDataSrc());<font></font>
    bX2 = <span class="hljs-keyword">bool</span>(pVarX2-&gt;GetDataSrc());
<span class="hljs-comment">// setting output signals</span><font></font>
    bY = !(bX1&amp;&amp;bX2);<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, bY);<font></font>
}<font></font>
<span class="hljs-comment">// initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTwoOperators::y12</span><span class="hljs-params">()</span> </span>{ FInit(); }
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous testons le nouveau modèle en mode «mémoire fantôme», nous ne verrons aucune différence dans son fonctionnement par rapport au précédent, c'est-à-dire, et, en passant, il passera par les états interdits et passera régulièrement en mode génération. Si nous configurons le travail avec des données dans le mode habituel, nous obtiendrons les résultats indiqués sur la Fig. 8 et fig. 9. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/mc/ib/tomcibxvaq2mae2kxxqc5clwits.jpeg" alt="image"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 8. Échec du mode de génération du modèle RS-trigger </font></font></i><br>
 <br>
<img src="https://habrastorage.org/webt/pu/qt/5y/puqt5yws1udobr_volkpcm7r4dm.jpeg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. 9. Ignorer les états interdits par le</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
modèle </font><i><font style="vertical-align: inherit;">RS-trigger</font></i><font style="vertical-align: inherit;"> Pourquoi le premier modèle, quel que soit le mode de travail avec la mémoire, affiche-t-il des résultats stables et le second - change-t-il de comportement? La raison en est les prédicats. Le deuxième modèle n'a pas de prédicats, ce qui est essentiel pour son comportement. Mais comment et pourquoi la présence / l'absence de prédicats affecte-t-elle l'algorithme de fonctionnement du programme parallèle?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le modèle de programme d'un élément AND-NOT, comme un programme automate, a deux canaux d'entrée et un canal de sortie. Ils doivent correspondre à deux prédicats et une action. Le premier programme est parfaitement conforme à cela. Le noyau VKPa, qui interprète la description de l'automate, exécute d'abord tous les prédicats non seulement d'un automate particulier, mais également de tout l'espace de l'automate, puis démarre toutes les actions. Dans ce cas, quelle que soit la séquence dans laquelle les actions ont été exécutées, simulant le parallélisme, et quel que soit le mode de fonctionnement avec la mémoire, les résultats des prédicats sur le cycle d'horloge actuel de l'automate ne dépendent pas d'eux (actions). Par conséquent, le premier programme produit le même résultat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxième programme, bien qu'il fonctionne directement avec les canaux d'entrée de la machine, lit les signaux d'entrée dans le cadre de l'action. </font><font style="vertical-align: inherit;">Les actions, en travaillant avec des données d'entrée en mode de mémoire fantôme, écrivent de nouvelles valeurs dans la mémoire fantôme et travaillent ainsi avec des données valides au début d'un cycle d'horloge discret. </font><font style="vertical-align: inherit;">Dans le mode habituel, ils «saisissent» les valeurs instantanées établies au moment de leur changement, et donc l'algorithme devient dépendant des moments de changement de mémoire. </font><font style="vertical-align: inherit;">Une dépendance similaire est démontrée par le deuxième programme. </font><font style="vertical-align: inherit;">Et même si des méthodes de prédicat étaient introduites dans le deuxième modèle, cela n'aurait aucun effet sur les résultats de ses travaux. </font><font style="vertical-align: inherit;">Ce qui importe ici n'est pas le fait de l'existence de méthodes de prédicat, mais les particularités de leur travail dans le cadre du modèle de programmation automate.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Conclusions</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En utilisant le programme parallèle RS-trigger comme exemple, nous avons examiné certaines des propriétés inhérentes à tout programme parallèle. </font><font style="vertical-align: inherit;">Nous continuerons à considérer certains aspects généraux du fonctionnement des programmes parallèles comme exemple de circuits logiques (numériques). </font><font style="vertical-align: inherit;">Le choix du thème de la modélisation des circuits numériques n'est pas accidentel. </font><font style="vertical-align: inherit;">En fait, sous «forme raffinée», ils représentent le travail de processus parallèles. </font><font style="vertical-align: inherit;">Cela rend l'analyse des nuances de la concurrence, de la race, de la synchronisation, des impasses, etc. </font><font style="vertical-align: inherit;">etc. transparent, clair et simple.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En même temps, peu importe comment vous appelez la programmation - «compétitive» ou parallèle, que vous utilisiez des «coroutines», des coroutines, des threads ou des machines pour la programmation, le résultat du programme [parallèle] doit être le même dans toutes les implémentations. </font><font style="vertical-align: inherit;">Le modèle automatique des programmes parallèles dans le cadre du PCUS poursuit cet objectif et uniquement cet objectif.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelles que soient les hypothèses qui seraient faites concernant la mise en œuvre du cœur de l’interprétation des automates de l’environnement du VKPa, toutes ces hypothèses seraient des «spéculations», car le résultat du travail des programmes automatiques ne doit pas être associé à la mise en œuvre d'un modèle de calcul. Il peut s'agir de logiciels (comme c'est le cas actuellement) ou de matériel (comme je l'espère dans le futur), implémentés sur un cœur ou sur leur ensemble, en version mono-thread ou multi-thread, etc. etc. tout cela ne devrait en aucun cas affecter les résultats des programmes automatiques parallèles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et, semble-t-il, l'objectif a été atteint. </font><font style="vertical-align: inherit;">Le modèle RS-trigger, comme l'un des tests possibles des systèmes de parallélisme [8], nous en convainc ... Comme la vie l'a montré, tous les autres programmes parallèles, à condition que l'environnement ait réussi la mise en œuvre du parallélisme du test RS-trigger, fonctionnent tout aussi correctement, de manière fiable et stable. . </font><font style="vertical-align: inherit;">Soit dit en passant, le même «test de déclenchement RS» MATLAB n'a pas réussi, et cela en dit déjà beaucoup ...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Littérature</font></font></b><div class="spoiler_text">1.  .    ++  .    . .  .  .. – .:  , 2012. – 672 . <br>
2.  .    : .  . – .: , 1981. – 360 .<br>
3.    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/ru/post/484588</a> . . . (  07.01.2020).<br>
4.  ..   . .: , 1962.<br>
5.  .., - ..    . – 2- ., .  . – .:  , 1988. – 480 .<br>
6.  ..    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cloud.mail.ru/public/HwsK/T95PMM8Ed</a> . . . (  01.02.2020).<br>
7.  .    . 2-  . – .: , 2004. – 432.<br>
8.  ..   ? “ ”, №10/97, .116-119. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.osp.ru/pcworld/1997/10/158015</a> . . . (  01.02.2020).<br>
</div></div></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr486598/index.html">Expériences de microcontrôleur dans Jupyter Notebook</a></li>
<li><a href="../fr486602/index.html">Svelte Community Materials Digest (16 janvier - 1er février)</a></li>
<li><a href="../fr486604/index.html">Non, les systèmes de type dynamique ne sont pratiquement plus ouverts</a></li>
<li><a href="../fr486608/index.html">Assistants essentiels à l'intelligence du service de renseignement le plus efficace au monde (partie 2)</a></li>
<li><a href="../fr486614/index.html">Pourquoi eSIM est nécessaire. Comment ça marche et pourquoi ils en parlent tant</a></li>
<li><a href="../fr486626/index.html">Svelte: découvrir les actions</a></li>
<li><a href="../fr486628/index.html">Distance fixe entre les tiques sur un axe dans gnuplot</a></li>
<li><a href="../fr486630/index.html">«Ne scintille pas dans les yeux»: comment est organisée la technologie d'éclairage de l'écran des lecteurs électroniques</a></li>
<li><a href="../fr486632/index.html">Modèles de programmation réactive mentale pour les superviseurs</a></li>
<li><a href="../fr486634/index.html">Mises à jour du backend MSVC dans Visual Studio 2019 version 16.3 et 16.4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>