<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💉 👴🏽 👔 Modèles de programmation réactive mentale pour les superviseurs 👦🏻 👩🏼‍🔬 🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article est destiné à un large éventail de lecteurs qui souhaitent savoir ce qu'est la programmation réactive. Le but de cet article est de former...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Modèles de programmation réactive mentale pour les superviseurs</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486632/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> <img src="https://habrastorage.org/webt/ez/hr/x0/ezhrx0ymj-ak_tdpfqhioagb3su.jpeg"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article est destiné à un large éventail de lecteurs qui souhaitent savoir ce qu'est la programmation réactive. </font><font style="vertical-align: inherit;">Le but de cet article est de former vos modèles mentaux de base de programmation réactive (MM RP) sans entrer dans les détails techniques.</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avertissement</font></font></b><div class="spoiler_text"> ( ) —    ,   .     ,                     .<br>
   ,      :            ,          . ,      ,     .<br>
          .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais d'abord, expliquons ce que les modèles mentaux et supérieurs mentionnés dans le titre de l'article ont à voir avec cela ...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À propos des modèles mentaux</font></font></b><div class="spoiler_text">  ,  ,         ,       .     ,       .<br>
            ,         ,    (. [1], [2])<br>
    ?  ,    ,                   .      (),   ,      ,   .      ,    ,    «», «»     « »    .<br>
    ,   ,       (),     ,      -  ().</div></div> <br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et voici les patrons ...</font></font></b><div class="spoiler_text">        .            «»  «»     ,            :   . (  ,  «»    ,      ).<br>
  ,   «»  ,     ,      ,  ,    , . ,          .   «»        «».      ,  ,    ,         .<br>
    ,    ,           ,   ..,       () — ,   ,            .<br>
 ,              .</div></div> <br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi la programmation réactive a-t-elle besoin de votre projet?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beaucoup de gens qui ne connaissent pas RP sont initialement sceptiques à son égard, soupçonnant que ce n'est qu'une autre mode vide, couverte de quelques beaux mots. </font><font style="vertical-align: inherit;">Surtout quand ils apprennent que vous ne pouvez évaluer la RP qu'en l'essayant. </font><font style="vertical-align: inherit;">Et l'essayer coûte cher, en raison du seuil d'entrée élevé. </font><font style="vertical-align: inherit;">Nous avons vécu et vécu avec OOP, qu'est-ce qui lui manque? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Permettez-moi de présenter mon point de vue à ce sujet.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À l'aube de la programmation, lorsque la plupart des programmes étaient écrits directement en langage assembleur, le concept de travail principal (un élément du modèle mental) des programmeurs était une instruction ou une commande de langage. Certaines données (primitives) sont transmises à l'entrée d'une commande ou d'une instruction. L'instruction traite et émet certaines données de sortie. L'apparition des premiers langages de programmation procédurale tels que Fortran n'a pas changé l'essence de la question. Seules les données et les opérations effectuées (comme une séquence de commandes élémentaires) sont devenues plus compliquées. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au fil du temps, il est devenu clair que ce concept n'était pas très cohérent avec les réalités du monde. Il peut y avoir beaucoup de données, elles peuvent être difficiles à structurer. Les données et les fonctionnalités qui les entourent seraient intéressantes à diviser en parties, à développer et à maintenir séparément, et à utiliser ensemble.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La POO a résolu ces problèmes de plusieurs façons. L'unité du modèle mental d'un programmeur OOP typique est un objet avec des données cachées (encapsulées) et une interface d'accès à ces données comme un ensemble de fonctions. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La POO a joué un rôle énorme dans l'automatisation et l'informatisation de nombreux processus de fabrication et autres. Et avec cela, ses faiblesses ont été exposées. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, dans la POO, il n'y a pas de concept de processus en tant que tel. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ils ont essayé d'améliorer la situation de différentes manières, en se concentrant sur divers aspects. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la programmation événementielle [3], la programmation de flux de données [4], le traitement de flux [5] et plusieurs autres paradigmes sont nés. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je me risquerais à susciter un flot de critiques envers les adeptes et les experts de ces paradigmes, en essayant de transmettre en termes simples leur essence générale.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'une manière ou d'une autre, ces paradigmes fonctionnent avec des flux d'informations. Dans le même temps, la programmation événementielle, comme son nom l'indique, se concentre sur le processus d'émergence d'éléments de flux d'informations, la programmation de flux de données - sur le contrôle de flux (fractionnement, fusion, transformation de flux) et le traitement de flux sur l'utilisation optimale des ressources dans le traitement des flux.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La programmation réactive est à peu près la même chose, mais avec un accent sur les opérations élémentaires spécifiques de création, de gestion et d'utilisation des threads. Ceux. RP décrit comment votre système réagit (l'anglais réagit) aux éléments du flux d'informations. Dans ce sens, il serait plus correct en russe d'utiliser le terme «programmation de réactifs» (du mot «réagir») ou «programmation de réaction» (du mot «réaction à quelque chose») s'il ne s'agissait pas de couper l'oreille, et le second n'a pas causé d'associations incorrectes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'oserais exprimer une autre pensée séditieuse. Ce que nous appelons aujourd'hui la programmation réactive en anglais (programmation réactive). appelé ainsi pour des raisons historiques et incliné en faveur de ce terme l'opinion majoritaire.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce paradigme aurait pu être appelé différemment. </font><font style="vertical-align: inherit;">Par conséquent, ne vous concentrez pas sur son nom actuel, mais essayez de comprendre son essence. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et bien que je parlerai de RP à un niveau assez abstrait, je citerai les API de la bibliothèque RxJS comme exemples concrets. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'acronyme RxJS signifie Reactive Extension for JavaScript, une extension JavaScript pour les fonctionnalités de programmation réactive. </font><font style="vertical-align: inherit;">Des extensions similaires existent pour de nombreux autres langages de programmation, comme on peut le voir dans l'image ci-dessous, tirée de [6].</font></font><br>
<img src="https://habrastorage.org/webt/ii/gb/ji/iigbjinggcawbioey0iz7ztarzs.png" alt="Extensions de programmation réactives"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi les modèles mentaux de RP ont-ils besoin de votre projet</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les grands projets ne se font pas seuls. Vous pouvez souvent lire ou entendre que les participants au projet doivent parler la même langue. Mon expérience montre que ce n'est guère nécessaire et possible. Mais ce qu'il faut, c'est que les concepts les plus élémentaires du projet soient énoncés et compris par les participants au projet aussi équitablement que possible. En termes de modèles mentaux (MM), nous pouvons dire que les MM de niveau supérieur devraient être aussi similaires que possible. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais comment peuvent-ils être similaires si les analystes pensent en termes de workflow et de cas d'utilisation, les architectes dans les modèles, les développeurs dans les fonctions et les structures de données et les testeurs dans les scénarios de test?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'invite pas tous ces spécialistes à commencer à penser en même temps aux catégories de programmation réactive, mais je peux leur promettre que la connaissance de ces catégories simplifiera et augmentera l'efficacité de leur communication professionnelle avec leurs collègues. </font><font style="vertical-align: inherit;">Cela devrait se produire car, d'une part, les MM RP ont la puissance nécessaire pour décrire des workflows complexes, et d'autre part, les MM RP peuvent être directement convertis en code dans de nombreux langages de programmation.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surprises, dangers, ou qu'en RP ce n'est pas la façon dont nous sommes tous habitués </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais avant d'entrer dans la description de la composition des modèles mentaux de programmation réactive, sur la base de notre propre expérience, je voudrais avertir le lecteur de ce qui n'y est pas. </font><font style="vertical-align: inherit;">De plus, non seulement non, mais l'attente même d'un comportement de POO simple et compréhensible dans le monde entraîne de tristes conséquences. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je fais cela non pas pour intimider, mais plutôt pour intriguer le lecteur.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Différence 1: au lieu d'un modèle de curseur, un graphique de calcul</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vais oser suggérer que de nombreux lecteurs, lorsqu'ils réfléchissent à la prochaine tâche à réaliser, ont un modèle mental dans leur tête, que j'appelle le modèle du curseur. </font><font style="vertical-align: inherit;">Il suppose qu'un algorithme étape par étape sous la forme d'une liste linéaire d'instructions sera inventé pour résoudre le problème. </font><font style="vertical-align: inherit;">L'exécution de l'algorithme se réduit à l'exécution pas à pas des instructions les unes après les autres. </font><font style="vertical-align: inherit;">Vous pouvez imaginer quelque chose comme un pointeur sur l'instruction en cours d'exécution. </font><font style="vertical-align: inherit;">Une fois l'instruction exécutée, le pointeur (curseur) passe à l'instruction suivante de la liste et commence à s'exécuter. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce modèle, une séquence de commandes écrites dans un langage de programmation orienté objet conditionnel</font></font><br>
<pre><code class="xml hljs">1. 1 = 2<font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2<font></font>
4.  1, 2, 3<font></font>
5. 1 = 4<font></font>
6.  1, 2, 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
donnera le résultat</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre modèle mental de curseur prédit et explique parfaitement un tel résultat. </font><font style="vertical-align: inherit;">Après avoir traité la troisième ligne, la valeur X3 est définie et la nouvelle valeur pour X1 spécifiée à la ligne 5 ne peut pas la modifier. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le monde de RP, selon l'interprétation de l'opération «+», le résultat sera très probablement</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 7</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce monde, la plupart des opérations connectent les paramètres d'entrée les uns aux autres, créant ainsi des graphiques de calcul à travers lesquels les calculs sont «poussés» lorsqu'un ou plusieurs paramètres sont modifiés.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Différence 2: opérations asynchrones</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cadre du modèle mental de calcul du curseur, l'opération suivante ne peut pas commencer plus tôt que la précédente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons l'exemple suivant. </font><font style="vertical-align: inherit;">Supposons que la fonction f1 calcule le salaire de base par la valeur de l'identifiant utilisateur userId et que la fonction f2 calcule le bonus en fonction de userId et la valeur du salaire. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, le calcul du salaire complet peut ressembler à ceci</font></font><br>
<pre><code class="xml hljs">1. X = f1(userId)<font></font>
2. Y = f2(userId, X)<font></font>
 X, Y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons qu'un membre du personnel ait un salaire de base de 10 000. </font><font style="vertical-align: inherit;">et un bonus de 1000 unités. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre modèle mental de curseur vous indique quoi imprimer.</font></font><br>
<pre><code class="xml hljs">10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hélas, dans le monde des RP asynchrones, le résultat peut, selon la durée des opérations, être</font></font><br>
<pre><code class="xml hljs">0 0 <font></font>
10000 0 <font></font>
0 1000 <font></font>
10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Je ne considère pas encore les exceptions). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fait est que dans le monde asynchrone-réactif, l'opération suivante n'attend pas la fin de la précédente, si c'est la précédente) asynchrone. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour illustrer cela, regardons quelques détails importants en utilisant l'exemple réaliste montré dans la figure ci-dessous. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'image montre le temps d'exécution de quatre instructions L1, L2, L3 et L4 qui sont indépendantes les unes des autres (leur nombre est important pour nous, pas l'orthographe) en modes synchrone (partie supérieure de l'image) et asynchrone (partie inférieure de l'image).</font></font><br>
<img src="https://habrastorage.org/webt/vb/s5/rb/vbs5rbmbwmrmmhqtw7gtx9tivzc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme on le voit, dans le premier cas, chaque instruction suivante "attend" la fin de la précédente. </font><font style="vertical-align: inherit;">Dans le cas asynchrone, toutes les instructions commencent à être exécutées simultanément. </font><font style="vertical-align: inherit;">En raison de l'exécution parallèle et de l'utilisation des ressources, la plupart des instructions s'exécutent en mode asynchrone plus longtemps qu'en mode synchrone. </font><font style="vertical-align: inherit;">Cependant, ensemble, ils légueront leur travail plus tôt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ordre d'achèvement des instructions dans les deux modes est également très différent. </font><font style="vertical-align: inherit;">En synchronisme, il:</font></font><pre><code class="javascript hljs">L1, L2, L3, l4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mais en asynchrone: </font></font><pre><code class="javascript hljs">L3, L2, L1, L4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Différence 3: les chaînes incomplètes (sans consommateur) ne fonctionnent pas du tout</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans de nombreux langages de programmation traditionnels, il est courant d'associer des appels de fonction ou des propriétés d'objet à des points. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, la chaîne d'appel de fonction JavaScript suivante transforme le mot «bon» en «chien»:</font></font><br>
<pre><code class="javascript hljs">„good“.split(„“).reverse().join(„“).replace(„oo“, „o“);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les séquences (chaînes) peuvent être longues. </font><font style="vertical-align: inherit;">Pour des raisons de réutilisation ou de commodité, ils peuvent être découpés en morceaux et partiellement réalisés. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La division d'une chaîne en RP en deux parties et l'appel d'une seule d'entre elles conduisent généralement à un manque de résultat, car seule la chaîne complète (avec le consommateur à la fin) est effectuée.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi tout ça?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablement, de nombreux lecteurs se posent déjà la question: «Ne sont-ils pas devenus fous collectivement, ces programmeurs réactifs? Pourquoi est-il nécessaire, une telle programmation? " </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne prétends pas prédire ce que les créateurs et les experts de la République de Pologne répondraient à cette question, mais ma réponse est la suivante: une telle programmation est nécessaire, car de nombreux objets du monde réel se comportent exactement comme ça. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphiques informatiques</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - c'est ce sur quoi Excel est construit, à partir duquel les comptables, mais aussi les chefs de projet sont ravis. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opérations asynchrones</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lorsque vous faites du café ou du thé dans votre cuisine, vous tenez-vous tout le temps dans la cuisine et regardez votre cafetière ou votre théière? Non. L'appareil fait bouillir de l'eau et fait son travail pendant que vous faites autre chose pour l'instant. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaîne d'opérations complète.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essayez de débrancher votre lampe de bureau de la prise murale et d'appuyer sur l'interrupteur. </font><font style="vertical-align: inherit;">La lampe ne s'allume pas de cela. </font><font style="vertical-align: inherit;">Cet objet ne fonctionne que s'il existe une chaîne complète - de la source au consommateur d'électricité. </font><font style="vertical-align: inherit;">Et il y a beaucoup, sinon la plupart, de tels objets dans le monde réel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je veux vous rassurer, votre connaissance de la programmation traditionnelle et du curseur MM ne doit pas être jetée à la poubelle à cause de l'apparition de RP. </font><font style="vertical-align: inherit;">La programmation réactive les a laissés seuls et les a étendus avec de nouvelles opérations sur de nouveaux types d'objets. </font><font style="vertical-align: inherit;">Comment - nous en parlerons plus tard.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'espace de la programmation des modèles mentaux et la place de MM RP</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parlant de la place du RP dans le paysage général de la programmation, les auteurs mentionnent souvent deux dimensions - la complexité des objets traités et le synchronisme / asynchronie des opérations. </font><font style="vertical-align: inherit;">Un exemple d'une telle classification peut être trouvé dans le livre «RxJS en action» [7], dans le chapitre «Quand et où utiliser RxJS». </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cette classification, la dimension des objets est divisée en objets uniques et multi-objets: tableaux, listes, etc. </font><font style="vertical-align: inherit;">Les opérations sont divisées en synchrones et asynchrones. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, cette classification divise le monde de la programmation en quatre domaines. </font><font style="vertical-align: inherit;">RP est l'un de ces domaines responsable du traitement multi-objets avec des opérations asynchrones. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je trouve cette classification très intéressante, mais je voudrais la regarder du point de vue des modèles mentaux. </font><font style="vertical-align: inherit;">Le tableau ci-dessous les présente.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valeurs et objets uniques</font></font></th>
<th>, ,    </th>
</tr>
<tr>
<td> </td>
<td>  </td>
<td>,  (Stream)</td>
</tr>
<tr>
<td> </td>
<td>,  (Promise)</td>
<td> (Workflow)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous supposons que les modèles mentaux d'instructions et le curseur ne nécessitent pas d'explication supplémentaire. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le cycle</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une extension des instructions MM et le curseur en raison des instructions supplémentaires du cycle ou revenir à un certain point. Cela permet à un ensemble d'instructions de traitement pour un seul objet de «boucler» dans une boucle, et ainsi de traiter de nombreux objets de ce type. Dans ce cas, le curseur se déplace à l'intérieur du cycle comme dans le modèle précédent, et ayant atteint le point de transition, il saute au début ou le traitement du cycle s'arrête si tous les objets sont traités. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jet.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La différence entre ce modèle mental et le précédent est que le curseur </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pointant vers l'objet en cours de traitement reste en place et que les objets eux-mêmes le «survolent».</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons cela avec deux exemples. Si vous peignez une clôture en bois, vous, par analogie avec le modèle de curseur, passez de planche en planche. Mais l'ouvrier sur le convoyeur reste en place et, par analogie avec le modèle de jet, les pièces à traiter elles-mêmes s'en approchent. De tels objets sont souvent désignés par le terme English Stream, par exemple, dans le langage Java. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sémaphore.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ce MM est plus facile à associer à un feu de circulation à une intersection. Les objets asynchrones interrogent périodiquement l'état d'une variable publique et effectuent certaines actions après avoir changé son état. (comme des conducteurs devant un feu de circulation) </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En attente.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une métaphore appropriée pour ce modèle d'attentes mentales est la lettre sur papier ou Emall que vous attendiez la dernière fois que vous avez obtenu votre emploi. Il peut y avoir une réponse positive ou négative. Votre comportement après avoir reçu la lettre dépend beaucoup de son contenu. Le terme anglais Promise est souvent utilisé pour décrire ces types d'objets. Que, du point de vue de l'utilisateur, c'est une attente, pour l'entrepreneur qui fournit les services, c'est plutôt une promesse. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous le voyons dans la description, le mouvement le long de chaque dimension (de haut en bas ou de droite à gauche dans le tableau) signifie un changement qualitatif dans le modèle mental.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme le montre le tableau, les jets et les attentes sont voisins à gauche et en haut de la cellule sud-est qui nous intéresse. </font><font style="vertical-align: inherit;">Qu'y a-t-il de nouveau dans les modèles mentaux de flux qui habitent la cellule qui nous intéresse par rapport à eux?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle est l'extension?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'expansion de Streams par rapport aux attentes est que les informations attendues peuvent arriver non pas une fois, mais en plusieurs parties. Dans ce cas, le processus peut se terminer sans se terminer. Ceux. après une série de portions réussies, nous recevrons une notification d'erreur. De plus, une autre version des informations est ajoutée - une notification de la fin du processus. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie, par exemple, qu'il est possible de recevoir plusieurs (mais pas toutes) parties des informations attendues et (sans message d'erreur) un message concernant la fin du traitement. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rappelons à nouveau, avec Waiting, nous n'avons que deux options alternatives pour les informations résultantes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le modèle Mental Jet est bien adapté pour comprendre, discuter et mettre en œuvre le processus de transformation d'une séquence d'objets du même type. MM Stream le développe avec les aspects suivants:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il peut y avoir de nombreux jets et nous pouvons les fusionner ensemble</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les jets peuvent être hétérogènes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons diviser les jets en nouveaux selon différents critères</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons les «fermer» et / ou les transformer en nouveaux dans le cadre d'un même flux. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc déterminé la place de MM RP (Streams) dans l'espace ou le paysage des objets de Programmation. </font><font style="vertical-align: inherit;">Abaissons maintenant la vue à vol d'oiseau et examinons de plus près les flux et leurs modèles mentaux.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flux et phases de leur cycle de vie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En première approximation, les flux de RP peuvent être imaginés comme des flux d'eau dans des conduites d'eau ou des flux d'électricité. </font><font style="vertical-align: inherit;">Il convient de rappeler que, comme toute autre analogie, cette analogie a ses limites et n'est pas toujours applicable. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En parlant de flux, on peut distinguer les aspects importants suivants:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque fil se pose en quelque sorte</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il se dirige en quelque sorte vers le consommateur.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il se passe quelque chose avec lui (il se transforme)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il peut être divisé en plusieurs flux ou fusionné avec d'autres flux</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le consommateur utilise en quelque sorte le flux, cessant d'exister.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les aspects énumérés sont simultanément des phases du cycle de vie des éléments individuels du flux. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinons-les plus en détail en utilisant l'exemple des fonctions RxJS.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Création de threads</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les flux peuvent être créés à partir d'éléments passifs tels qu'un tableau ou une liste d'objets dans votre programme, octets, lignes de fichiers, etc. Ce type de sources de flux est appelé froid (bien qu'il existe techniquement une définition plus précise des sources de flux froid). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les soi-disant sources chaudes "vivent leur propre vie" et si vous ne vous connectez pas à temps, les informations seront perdues. Cette catégorie comprend des informations sur les actions de l'utilisateur sur un ordinateur, une tablette, un smartphone, par exemple, des informations sur les frappes, les mouvements de la souris ou le toucher de l'écran. Cette catégorie comprend également les données demandées par divers protocoles tels que HTTP, les données de divers capteurs.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient de noter qu'il existe des sources dites «chaudes». </font><font style="vertical-align: inherit;">De plus, certaines sources «chaudes» peuvent être «refroidies» et «froides» peuvent être «réchauffées». </font><font style="vertical-align: inherit;">Mais vous devriez lire à ce sujet dans la littérature spéciale, par exemple, dans le livre [7]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est important pour nous de savoir que toutes les opérations de création de flux créent des objets du même type, qui peuvent être traités ultérieurement par les mêmes opérations, quel que soit leur contenu. </font><font style="vertical-align: inherit;">Dans cet article, nous appelons ces flux d'objets. </font><font style="vertical-align: inherit;">Le nom anglais correspondant est Observable.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mouvement des consommateurs et transformation des flux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les opérations de transformation des flux peuvent être effectuées aussi bien sur le chemin du consommateur que par lui-même. </font><font style="vertical-align: inherit;">Dans les deux cas, les traitements des éléments de flux sont strictement séquentiels, c'est-à-dire </font><font style="vertical-align: inherit;">l'opération suivante n'est lancée que lorsque la précédente est terminée et lui a transmis son résultat. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contrairement à Stream, qui dans certains langages de programmation sont des constructions de langage avec leur propre syntaxe et sémantique, les extensions réactives comme RxJS en JavaScript sont obligées d'utiliser la syntaxe et la sémantique de base du langage extensible. </font><font style="vertical-align: inherit;">Par conséquent, RxJs implémente la fonction pipe (), à l'intérieur de laquelle vous pouvez placer des appels aux fonctions - gestionnaires du flux lui-même et de ses éléments individuels. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est important de noter que seules les fonctions spéciales pouvant être canalisées peuvent être des gestionnaires de flux.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Débit triphasé"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous continuons l'analogie avec l'électricité, alors les flux que nous considérons peuvent être appelés triphasés. Outre le «fil normal» transmettant les informations de base, il existe également un «fil d'erreur» et un «fil de terminaison de flux». Les opérations de transformation permettent non seulement de changer l'objet, mais aussi de le rediriger vers un autre «fil». Cette technique est utilisée, par exemple, lors du traitement d'erreurs présumées lors de l'utilisation de serveurs utilisant le protocole HTTP. Par exemple, si un serveur ne répond pas, vous pouvez essayer d'en demander un autre sans informer l'utilisateur de l'échec de la demande du premier serveur.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est un autre élément très important de votre modèle de flux mental. </font><font style="vertical-align: inherit;">Si, dans les paradigmes de programmation traditionnels, l'erreur est renvoyée par la fonction de traitement sous forme de code d'erreur ou doit être interceptée en tant qu'interruption (exception), alors dans les flux l'erreur "circule" indépendamment du canal principal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Là, il peut être traité. </font><font style="vertical-align: inherit;">Par exemple, si un utilisateur a entré un mot de passe incorrect, il peut avoir la possibilité supplémentaire de tenter de le saisir une ou plusieurs fois.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fractionnement et fusion de flux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La répartition des flux s'effectue en deux étapes. À la première étape, les threads vides sont démarrés. Ensuite, dans la deuxième étape (étape de traitement de flux), dans l'une des fonctions de traitement, les éléments seront analysés et redirigés vers le flux souhaité. Techniquement, il existe de nombreuses options pour ce faire. Par exemple, le supprimer du thread actuel ou le cloner avant de le démarrer dans un nouveau thread. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez fusionner plusieurs flux en un en un nombre étonnamment élevé de façons. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les moyens les plus simples qui vous viennent à l'esprit sont de les fusionner dans l'ordre de réception, ou tout d'abord à partir du premier flux, puis à partir du second.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode illustrée ci-dessous dans l'image permet à l'un des deux flux de former un contenant des paires ordonnées d'objets des premier et deuxième flux. </font><font style="vertical-align: inherit;">Dans ce cas, une nouvelle paire est formée si un nouvel élément apparaît dans l'un des flux. </font><font style="vertical-align: inherit;">A contient une paire de strictement les derniers éléments de chaque flux. </font><font style="vertical-align: inherit;">Cela conduit au fait qu'un même élément peut être inclus dans plusieurs paires. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La notation graphique utilisée dans cet exemple est appelée diagrammes de marbre et est très efficace pour expliquer la sémantique du fractionnement et de la fusion des flux. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si ce sujet vous intéresse, je vous conseille d'étudier les opérations et leurs diagrammes de Marbre sur la ressource [8].</font></font><br>
<img src="https://habrastorage.org/webt/cw/q7/a1/cwq7a1t6omorptqk33hgm93yetw.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de flux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour utiliser les éléments du flux, l'utilisateur ou le client doit d'abord s'y abonner. En règle générale, il doit se désinscrire de celui-ci à la fin du traitement, car les garbage collector ne désactivent pas toujours automatiquement un abonnement lorsqu'ils essaient d'utiliser un abonné. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De nombreux clients peuvent s'abonner à un thread. Dans RxJs, la fonction d'abonnement est appelée subscribe (). Dans ce document, dans la plupart des cas, il est conseillé de placer des appels de traitement des éléments "normaux" du flux, d'un gestionnaire d'erreurs et (relativement rarement) d'un gestionnaire de terminaison de flux.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chacun des abonnés au flux reçoit sa copie de l'élément ou un clone de l'élément d'origine. </font><font style="vertical-align: inherit;">Afin de ne pas causer de problèmes, le flux est implémenté de telle sorte que les éléments reçus pour le traitement deviennent immuables. </font><font style="vertical-align: inherit;">Dans certaines situations, cette limitation peut encore être contournée, mais il vaut mieux ne pas le faire.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Charme dangereux des ruisseaux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les flux sont des objets très compliqués, quelque peu apparentés aux intégrales en mathématiques. C'est une chose de savoir qu'ils existent et même d'imaginer à peu près ce que c'est, et une autre chose de pouvoir les utiliser. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comprendre la logique interne de leur fonctionnement, nécessaire pour bien les appliquer dans la pratique, nécessite un effort intellectuel considérable. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les flux sont intrinsèquement étroitement liés à la programmation fonctionnelle. Pour une utilisation compétente des flux, il est utile de comprendre comment il est possible de construire et d'appliquer des fonctions de second ordre - des fonctions pour lesquelles d'autres fonctions servent d'arguments. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, la beauté et l'élégance des flux vous seront pleinement révélées. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les flux sont contagieux. Après avoir compris leur beauté, je veux les utiliser dans toutes les tâches, ce qui bien sûr n'est pas nécessaire.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans quelles tâches il est conseillé d'utiliser les flux et où les méthodes traditionnelles doivent être utilisées, chacun décide pour lui-même.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résumer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, j'ai essayé de vous parler des modèles mentaux de programmation réactive (MM RP) et même de les mettre partiellement dans votre conscience. </font><font style="vertical-align: inherit;">Répétons encore les points principaux.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MM RP sont spéciaux, pas similaires aux modèles mentaux de la programmation traditionnelle. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous nous lançons dans la programmation réactive, nous devons nous rappeler que certains éléments bien établis dans d'autres domaines du MM tels que le curseur, les chaînes d'appel ou les boucles ne fonctionnent pas, ou ne fonctionnent pas comme ça.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le modèle mental principal de RP est un «flux à trois canaux» avec un canal pour les éléments «normaux», les erreurs et les informations sur la fin du flux.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les flux peuvent être finis et infinis.</font></font></li>
<li>    «», «»  «» .   «»  «». </li>
<li>      .        (,       ).             .</li>
<li>     ,    .</li>
<li>       ,   .</li>
<li>       .        . </li>
<li>      ,  «».</li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si ce sujet vous intéresse, vous pouvez "jouer" avec les streams en utilisant les simulateurs disponibles sur le site [8]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous voulez mieux comprendre les concepts de RP, je vous recommande de parcourir le livre [7], et bien sûr, de vous familiariser avec The Reactive Manifesto [11]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous atteindrez le niveau suivant dans la formation de votre propre MM RP en travaillant à travers les livres [9] et [10] sur la conception et la modélisation des systèmes réactifs.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Littérature et références</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La programmation est la matérialisation des idées. </font><font style="vertical-align: inherit;">(Article sur Habr. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr.com/ru/post/425321</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sirotin V. RPSE: la réification comme paradigme du génie logiciel. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arxiv.org/abs/1810.01904</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmation événementielle. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.m.wikipedia.org/wiki/Event-driven_programming</font></font></a></li>
<li>Dataflow-programming. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Dataflow_programming</a></li>
<li>Stream-processing. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Stream_processing</a></li>
<li>Rx-Extensions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">reactivex.io/languages.html</a></li>
<li>RxJS in Action. – 4. August 2017. Paul P. Daniels (Autor), Luis Atencio. Manning Publications. ISBN-13: 978-1617293412</li>
<li>RxJS online Documentstion. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">xgrommx.github.io/rx-book/index.html</a></li>
<li>Reactive Design Patterns. 2017. Roland Kuhn Dr., Brian Hanafee, Jamie Allen. Manning Publications. ISBN-13: 978-1617291807</li>
<li>Functional and Reactive Domain Modeling. 2016. Debasish Ghosh.Manning Publications. ISBN-13: 978-1617292248</li>
<li>The Reactive Manifesto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">www.reactivemanifesto.org</a></li>
</ol><br>
<br>
<em> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">geralt</a></em></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr486632/">https://habr.com/ru/post/fr486632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr486614/index.html">Pourquoi eSIM est nécessaire. Comment ça marche et pourquoi ils en parlent tant</a></li>
<li><a href="../fr486622/index.html">Modèle informatique parallèle</a></li>
<li><a href="../fr486626/index.html">Svelte: découvrir les actions</a></li>
<li><a href="../fr486628/index.html">Distance fixe entre les tiques sur un axe dans gnuplot</a></li>
<li><a href="../fr486630/index.html">«Ne scintille pas dans les yeux»: comment est organisée la technologie d'éclairage de l'écran des lecteurs électroniques</a></li>
<li><a href="../fr486634/index.html">Mises à jour du backend MSVC dans Visual Studio 2019 version 16.3 et 16.4</a></li>
<li><a href="../fr486638/index.html">Blazor WebAssembly 3.2.0 Preview 1 est maintenant disponible</a></li>
<li><a href="../fr486640/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 331 (27 janvier - 2 février)</a></li>
<li><a href="../fr486644/index.html">Antenne DIY en 5 minutes</a></li>
<li><a href="../fr486646/index.html">Éloignez-vous de jQuery à Svelte, pas de douleur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>