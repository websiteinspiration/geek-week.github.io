<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍💻 🥇 ⚽️ SHISHUA: le générateur de nombres pseudo-aléatoires le plus rapide au monde 😨 🐫 👋🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a six mois, je voulais créer le meilleur générateur de nombres pseudo-aléatoires (PRNG) avec une architecture inhabituelle. Je pensais que le déb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SHISHUA: le générateur de nombres pseudo-aléatoires le plus rapide au monde</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/498352/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/ex/bl/5pexblhd_seedlgm8iidkfktef4.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a six mois, je voulais créer le meilleur générateur de nombres pseudo-aléatoires (PRNG) avec une architecture inhabituelle. Je pensais que le début serait facile et que vous travaillez, la tâche deviendra lentement plus complexe. Et j'ai pensé que si je pouvais tout apprendre assez rapidement pour faire face aux plus difficiles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À ma grande surprise, la complexité n'a pas augmenté de façon linéaire. Les tests d'octets chi carré se sont révélés très difficiles! Plus tard, il a été tout aussi difficile de passer des tests inflexibles. J'ai </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">publié les résultats actuels</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour comprendre quelles autres difficultés m'attendent. Cependant </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le test PractRand a échoué à ce moment-là</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, il a été très difficile de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">réussir le test BigCrush</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, il était très difficile de transférer 32 téraoctets de données lors du passage de PractRand. </font><font style="vertical-align: inherit;">La vitesse est devenue un problème. </font><font style="vertical-align: inherit;">Il ne suffit pas de créer un design qui génère dix mégaoctets par seconde, car passer PractRand prendrait un mois. </font><font style="vertical-align: inherit;">Mais je dois admettre qu'il </font><font style="vertical-align: inherit;">était très difficile de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passer ce test à une vitesse de gigaoctets par seconde</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous montez à une telle hauteur ... vous voulez savoir si vous pouvez vous rendre à la frontière de Pareto. </font><font style="vertical-align: inherit;">Vous voulez créer le PRNG le plus rapide au monde, qui passera les tests statistiques les plus complexes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai réussi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article précédent,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> j'ai parlé de ce que j'ai appris pour atteindre mon objectif. </font><font style="vertical-align: inherit;">Et ici, je vais vous dire comment fonctionne l'architecture finale.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objectif</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par l'évidence: la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vitesse dépend de la plateforme</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Je me suis concentré sur l'optimisation de l'architecture x86-64 moderne (processeurs Intel et AMD). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour comparer les performances, la métrique </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> classique est utilisée </font><font style="vertical-align: inherit;">: il s'agit du nombre de cycles de processeur dépensés pour générer un octet. </font><font style="vertical-align: inherit;">Cette métrique est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calculée et comparée</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans toutes les œuvres cryptographiques. </font><font style="vertical-align: inherit;">Un cpb légèrement inférieur dans le monde du logiciel ou du matériel peut assurer la victoire dans la compétition ou l'utilisation sur des sites Web à travers le monde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour améliorer cpb, vous pouvez:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Générez plus d'octets avec la même quantité de travail,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou faites moins de travail pour générer le même nombre d'octets,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou parallélisez le travail.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous ferons tout ce qui précède. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selon le premier point, nous devons produire plus de bits à chaque itération. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'avais peur qu'on me dise: "S'il ne donne pas de numéros 32 bits, alors ce n'est pas le DSRP", ou la même chose avec des numéros 64 bits. Ou: "Le PRNG ne devrait être que pour l'architecture x86-64", comme si les instructions comme POPCNT ou les registres comme% xmm7 étaient interdits.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, le PRNG est une ingénierie: les générateurs tentent depuis plusieurs décennies de tirer tout ce qui est possible des processeurs! Lorsque ROL est apparu, ils ont commencé à compter sur lui. Avec l'avènement des processeurs 64 bits, ils ont commencé à s'appuyer sur% rax. Bien sûr, sur ARM, ces algorithmes peuvent fonctionner plus lentement (bien que cela reste à voir), cependant, les PRN 64 bits étaient activement utilisés avant même que Android ne commence à nécessiter la prise en charge du 64 bits en 2019! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, ce domaine se développe avec le matériel. Et aujourd'hui, les processeurs Intel et AMD dus à </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> prennent déjà en charge les opérations 256 bits. RC4 a produit 1 octet, drand48 pourrait produire 4 octets à la fois, pcg64 - 8 octets, et maintenant nous pouvons immédiatement générer 32 octets.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8 octets peuvent être un nombre 64 bits, et la plupart des langages de programmation ont des types intégrés pour cela. </font><font style="vertical-align: inherit;">Mais peu de langues fournissent des types pour 16 octets (une exception notable est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__uint128_t</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en C). </font><font style="vertical-align: inherit;">Encore moins de langues ont du type pour 32 octets (sauf internes). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On peut donc dire adieu au prototype habituel de la fonction PRNG (exemple du benchmark Vigny </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HWD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">static uint64_t next(void);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu de cela, vous pouvez créer un générateur qui remplit le tampon (exemple de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mon benchmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quels sont les inconvénients de cette solution? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si votre générateur produit 32 octets à la fois, vous devez fournir au consommateur un tableau qui est un multiple de 32 (idéalement aligné sur 32 octets). </font><font style="vertical-align: inherit;">Bien que vous puissiez vous en passer, nous allons simplement remplir le tampon. </font><font style="vertical-align: inherit;">Nous allons supprimer les données inutilisées et les remplir à nouveau si nécessaire. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le délai</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devient imprévisible: certains appels ne feront que lire le tampon. </font><font style="vertical-align: inherit;">Mais en moyenne, tout sera pareil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous générons maintenant plus d'octets, effectuant la même quantité de travail. </font><font style="vertical-align: inherit;">Comment la parallélisons-nous?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallélisme</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les processeurs offrent un ensemble incroyable d'outils de parallélisation à tous les niveaux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, ce sont des instructions SIMD (Single-Instruction, Multiple Data). Par exemple, AVX2 effectue simultanément quatre ajouts 64 bits, ou huit ajouts 32 bits, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est utilisé en cryptographie depuis une quinzaine d'années. La concurrence a fourni les performances incroyables du </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha20</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il est utilisé par les primitives les plus importantes qui n'utilisent pas AESNI. Par exemple, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NORX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gimli sont</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conçus avec le parallélisme à l'esprit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Récemment, l'intérêt pour ce sujet a également augmenté dans la communauté PRNG non cryptographique. En particulier, les primitives existantes qui n'ont pas été conçues pour SIMD peuvent être à la base de la création de PRN très rapides.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque Sebastiano Vigna a fait la promotion de son architecture </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans la bibliothèque standard Julia, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il a découvert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que les résultats de huit instances PRNG compétitives et initialisées différemment peuvent être concaténées très rapidement si chaque opération est effectuée simultanément dans tous les PRNR. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD n'est qu'un des niveaux de parallélisation du processeur. Je recommande de lire l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article précédent sur ce sujet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afin d'avoir une meilleure idée, mais je vais donner quelques explications. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les pipelines de processeurs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permettent de traiter plusieurs instructions à différentes étapes. Si vous organisez bien l'ordre de leur exécution afin de réduire les dépendances entre les étapes, vous pouvez accélérer le traitement des instructions.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'exécution superscalaire</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous permet de traiter simultanément les parties informatiques des instructions. </font><font style="vertical-align: inherit;">Mais pour cela, ils ne devraient pas avoir de dépendances en lecture-écriture. </font><font style="vertical-align: inherit;">Vous pouvez adapter l'architecture pour réduire le risque de temps d'arrêt en enregistrant bien avant la lecture. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une exécution extraordinaire</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permet au processeur d'exécuter des instructions non pas dans l'ordre de séquence, mais lorsqu'elles sont prêtes, même si les instructions précédentes ne sont pas encore prêtes. </font><font style="vertical-align: inherit;">Mais pour cela, il ne devrait pas y avoir de dépendance en lecture-écriture. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant, nous passons à la mise en œuvre!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Architecture</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérons un schéma appelé semi-SHISHUA. </font><font style="vertical-align: inherit;">La provenance d'un tel nom deviendra progressivement apparente à mesure que vous lirez. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le schéma ressemble à ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd8/df1/b8f/bd8df1b8fcfae4897eb4b74f2c6e856f.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérez sa ligne par ligne.</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct prng_state {<font></font>
  __m256i state[2];<font></font>
  __m256i output;<font></font>
  __m256i counter;<font></font>
} prng_state;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'état est divisé en deux parties, qui sont placées dans le registre AVX2 (256 bits). Pour augmenter la vitesse, nous gardons le résultat proche de l'état lui-même, mais il ne fait pas partie de l'état. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons également un compteur 64 bits. Pour simplifier le calcul, c'est aussi un registre AVX2. Le fait est que AVX2 a une petite fonctionnalité: les registres ordinaires (% rax et similaires) ne peuvent pas être transférés directement vers SIMD via MOV, ils doivent passer par la RAM (le plus souvent via la pile), ce qui augmente le délai et coûte deux instructions de processeur (MOV sur la pile, VMOV de la pile). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant la génération. Commençons par charger, puis parcourons le tampon et remplissons-le avec 32 octets à chaque itération.</font></font><br>
<br>
<pre><code class="plaintext hljs">inline void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size) {<font></font>
  __m256i s0 = s-&gt;state[0], counter = s-&gt;counter,<font></font>
          s1 = s-&gt;state[1],       o = s-&gt;output;<font></font>
  for (__uint64_t i = 0; i &lt; size; i += 4) {<font></font>
    _mm256_storeu_si256((__m256i*)&amp;buf[i], o);<font></font>
    // …<font></font>
  }<font></font>
  s-&gt;state[0] = s0; s-&gt;counter = counter;<font></font>
  s-&gt;state[1] = s1; s-&gt;output  = o;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque la fonction est en ligne, le remplissage immédiat du tampon au démarrage permet au processeur d'exécuter immédiatement les instructions en fonction de cela grâce à un mécanisme d'exécution extraordinaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À l'intérieur de la boucle, nous effectuons rapidement trois opérations d'état:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ft</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ffle</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dd</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'où le nom SHISHUA!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Premier quart de travail</font></font></h3><br>
<pre><code class="plaintext hljs">u0 = _mm256_srli_epi64(s0, 1);              u1 = _mm256_srli_epi64(s1, 3);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, l'AVX2 ne prend pas en charge les révolutions. </font><font style="vertical-align: inherit;">Mais je veux mélanger les bits d'une position dans un nombre 64 bits avec les bits d'une autre position! </font><font style="vertical-align: inherit;">Et le changement est le meilleur moyen de réaliser cela. </font><font style="vertical-align: inherit;">Nous allons décaler d'un nombre impair, de sorte que chaque bit visite toutes les positions 64 bits, et non la moitié d'entre elles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant le quart de travail, des bits sont perdus, ce qui entraîne la suppression d'informations de notre état. </font><font style="vertical-align: inherit;">C'est mauvais, vous devez minimiser les pertes. </font><font style="vertical-align: inherit;">Les plus petits nombres impairs sont 1 et 3, nous utiliserons différentes valeurs de décalage pour augmenter l'écart entre les deux parties. </font><font style="vertical-align: inherit;">Cela aidera à réduire la similitude de leur auto-corrélation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons déplacer vers la droite, car les bits les plus à droite ont la diffusion la plus faible lors de l'addition: par exemple, le bit le moins significatif dans A + B est juste le XOR des bits les moins significatifs A et B.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En remuant</font></font></h3><br>
<pre><code class="plaintext hljs">t0 = _mm256_permutevar8x32_epi32(s0, shu0); t1 = _mm256_permutevar8x32_epi32(s1, shu1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous utiliserons le mixage 32 bits, car cela donne une granularité différente par rapport aux opérations 64 bits que nous utilisons partout (l'alignement 64 bits est violé). Il peut également s'agir d'une opération transversale: d'autres shuffles peuvent déplacer des bits dans les 128 bits à gauche s'ils commencent à gauche, ou dans les 128 bits à droite s'ils commencent à droite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mélange de constantes:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i shu0 = _mm256_set_epi32(4, 3, 2, 1, 0, 7, 6, 5),<font></font>
        shu1 = _mm256_set_epi32(2, 1, 0, 7, 6, 5, 4, 3);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour que le mélange améliore vraiment le résultat, nous déplacerons les parties 32 bits faibles (faible dispersion) des ajouts 64 bits vers des positions fortes, de sorte que les ajouts suivants les enrichissent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La partie 32 bits bas de gamme du bloc 64 bits ne se déplace jamais vers le même bloc 64 bits que la partie d'ordre supérieur. </font><font style="vertical-align: inherit;">Ainsi, les deux parties ne restent pas dans le même morceau, ce qui améliore le mélange. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au final, chaque partie 32 bits passe par toutes les positions d'un cercle: de A à B, de B à C, ... de H à A. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous avez peut-être remarqué que le mixage le plus simple qui prend en compte toutes ces exigences est deux 256 bits chiffre d'affaires (tours de 96 bits et 160 bits à droite, respectivement).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une addition</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ajoutons des morceaux 64 bits à partir de deux variables temporaires - décalage et mixage.</font></font><br>
<br>
<pre><code class="plaintext hljs">s0 = _mm256_add_epi64(t0, u0);              s1 = _mm256_add_epi64(t1, u1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'addition est la principale source de dispersion: dans cette opération, les bits sont combinés en combinaisons irréductibles d'expressions XOR et AND réparties sur des positions 64 bits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le stockage du résultat de l'addition dans un état préserve durablement cette dispersion.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonction de sortie</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'où tirons-nous la sortie? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est simple: la structure que nous avons créée nous permet de générer deux parties indépendantes de l'état s0 et s1, qui ne s'affectent en aucune façon. </font><font style="vertical-align: inherit;">Appliquez XOR sur eux et obtenez un résultat complètement aléatoire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour renforcer l'indépendance entre les données auxquelles nous appliquons XOR, nous prenons un résultat partiel: la partie décalée d'un état et la partie mixte d'un autre.</font></font><br>
<br>
<pre><code class="plaintext hljs">o = _mm256_xor_si256(u0, t1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela revient à réduire les dépendances en lecture-écriture entre les instructions d'un processeur superscalaire, comme si u0 et t1 étaient prêts à lire en s0 et s1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, discutez du compteur. Nous le traitons au début du cycle. Tout d'abord, modifiez l'état, puis augmentez la valeur du compteur:</font></font><br>
<br>
<pre><code class="plaintext hljs">s1 = _mm256_add_epi64(s1, counter);<font></font>
counter = _mm256_add_epi64(counter, increment);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi changeons-nous d'abord l'état, puis mettons à jour le compteur? s1 devient disponible plus tôt, ce qui réduit la probabilité que les instructions suivantes qui le lisent s'arrêtent dans le pipeline du processeur. De plus, cette séquence permet d'éviter la dépendance directe du compteur de lecture-écriture. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous appliquons le compteur à s1, et non à s0, car ils affectent tous les deux la sortie de toute façon, cependant, s1 perd plus de bits en raison du décalage, de sorte qu'il l'aide à «se remettre sur pied» après le décalage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le compteur peut ne pas enregistrer le test PractRand. Son seul objectif est de fixer une limite inférieure de 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">octets = 512 exbibytes pour la période PRNG: on ne recommence le cycle qu'après un millénaire de travail à une vitesse de 10 gibytes par seconde. Il est peu probable qu'il soit trop lent pour une utilisation pratique dans les siècles à venir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incrément:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i increment = _mm256_set_epi64x(1, 3, 5, 7);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les nombres impairs sont sélectionnés comme incréments, car seuls les nombres premiers de base couvrent tout le cycle du champ fini GF (2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), et tous les nombres impairs sont premiers de 2. En d'autres termes, si vous incrémentez d'un entier pair dans la plage de 0 à 4, revenant à 0 après 4, il s'avère que la séquence 0-2-0-2- ..., qui ne conduira jamais à 1 ou 3. Et l'incrément impair passe par tous les entiers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour tous les nombres 64 bits en état, nous utiliserons des nombres impairs différents, ce qui les séparera davantage et augmentera légèrement le mélange. </font><font style="vertical-align: inherit;">J'ai choisi les plus petits nombres impairs pour qu'ils n'aient pas l'air magique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est ainsi que la transition d'état et la fonction de sortie fonctionnent. </font><font style="vertical-align: inherit;">Comment les initialiser?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous initialisons l'état en utilisant les chiffres hexadécimaux Φ, le nombre irrationnel le moins approximé par la fraction.</font></font><br>
<br>
<pre><code class="plaintext hljs">static __uint64_t phi[8] = {<font></font>
  0x9E3779B97F4A7C15, 0xF39CC0605CEDC834, 0x1082276BF3A27251, 0xF86C6A11D0C18E95,<font></font>
  0x2767F0B153D27B7F, 0x0347045B5BF1827F, 0x01886F0928403002, 0xC1D64BA40F335E36,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenez une graine 256 bits. </font><font style="vertical-align: inherit;">Cela se fait souvent en cryptographie et ne nuit pas au travail des PRNG non cryptographiques:</font></font><br>
<br>
<pre><code class="plaintext hljs">prng_state prng_init(SEEDTYPE seed[4]) {<font></font>
  prng_state s;<font></font>
  // …<font></font>
  return s;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous ne voulons pas redéfinir toute la partie de l'état (s0 ou s1) avec ce nombre initial, il suffit d'en affecter la moitié. </font><font style="vertical-align: inherit;">De cette façon, nous éviterons l'utilisation de nombres initiaux atténuants, qui provoquent accidentellement ou intentionnellement un état initial faible connu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous ne modifions pas la moitié de chaque état, nous gardons le contrôle sur 128 bits d'état. </font><font style="vertical-align: inherit;">Une telle entropie est suffisante pour démarrer et maintenir une position forte.</font></font><br>
<br>
<pre><code class="plaintext hljs">s.state[0] = _mm256_set_epi64x(phi[3], phi[2] ^ seed[1], phi[1], phi[0] ^ seed[0]);<font></font>
s.state[1] = _mm256_set_epi64x(phi[7], phi[6] ^ seed[3], phi[5], phi[4] ^ seed[2]);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous répétons ( </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">plusieurs fois la </font><font style="vertical-align: inherit;">séquence suivante:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exécutez les étapes ( </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) des itérations SHISHUA.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous attribuons une partie de l'état à un autre état et l'autre partie à la sortie.</font></font></li>
</ol><br>
<pre><code class="plaintext hljs">for (char i = 0; i &lt; ROUNDS; i++) {<font></font>
  prng_gen(&amp;s, buf, 4 * STEPS);<font></font>
  s.state[0] = s.state[1];<font></font>
  s.state[1] = s.output;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'attribution d'un résultat de sortie augmente la dispersion des états. </font><font style="vertical-align: inherit;">Lors de l'initialisation, le travail supplémentaire et la corrélation des états n'ont pas d'importance, car cette série d'opérations est effectuée une seule fois. </font><font style="vertical-align: inherit;">Nous ne nous intéressons qu'à la dispersion lors de l'initialisation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir évalué l'effet sur la corrélation des valeurs initiales, j'ai choisi </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font><font style="vertical-align: inherit;">pour la </font><font style="vertical-align: inherit;">valeur et </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font><font style="vertical-align: inherit;">pour </font><font style="vertical-align: inherit;">10. J'ai calculé la corrélation en calculant les anomalies «inhabituelles» et «suspectes» résultant des outils de contrôle qualité PRNG dans PractRand.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est difficile de mesurer la vitesse pour plusieurs raisons:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mesure de l'horloge</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'est peut-être pas suffisamment précise.</font></font></li>
<li>    <strong></strong>,      , -  ,  -,       .</li>
<li>,        .        <strong></strong>   .</li>
<li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>  </strong></a>:        ,       .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'utilise l'instruction du processeur RDTSC, qui calcule le nombre de cycles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour que tout le monde puisse reproduire mes résultats, j'utilise une machine virtuelle basée sur le cloud. Cela ne change pas le niveau des résultats de référence par rapport aux tests locaux. De plus, vous n'avez pas à acheter le même ordinateur que le mien. Enfin, il existe de nombreuses situations où le PRNG est lancé dans les nuages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai choisi Google Cloud Platform N2 (processeur Intel) et N2D (processeur AMD). L'avantage de GCP est qu'il propose des serveurs avec des processeurs des deux fabricants. Dans cet article, nous nous concentrerons sur Intel, mais pour AMD, les résultats seront dans le même ordre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour approfondir le sujet, débarrassons-nous d'abord de l'ancien générateur cryptographique RC4. Impossible de paralléliser le travail, j'ai</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7,5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (cycles par octet généré). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exécutons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un MCG très populaire et rapide: le </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Lehmer128 PRNG</font></a><font style="vertical-align: inherit;"> le </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">plus simple</font></a><font style="vertical-align: inherit;"> , qui réussit le test BigCrush, a montré </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wow, super! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous exécuterons le dernier développement, qui est utilisé pour les tables de hachage rapides - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wyrand</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,41 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un peu mieux! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains DSRP ne réussissent pas le test PractRand de 32 téraoctets, mais ils fonctionnent très rapidement. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'a atteint que 512 mégaoctets, mais a montré une vitesse très élevée: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,34 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre développement récent de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Elle prétend être le PRNG le plus rapide au monde - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,31 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'accord, ça suffit. </font><font style="vertical-align: inherit;">Qu'est-ce que le semi-SHISHUA a montré? </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,14 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Deux fois plus vite que RomuTrio.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/f7a/c9f/c84f7ac9fcbc4d4a7b2400ae552522a4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cool. </font><font style="vertical-align: inherit;">Testez maintenant le générateur cryptographique ChaCha8. </font><font style="vertical-align: inherit;">Il a atteint ... </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,12 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD est une vraie magie! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour la communauté cryptographique, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce n'était pas une surprise particulière</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">ChaCha8 est extrêmement facile à paralléliser. </font><font style="vertical-align: inherit;">Ceci est juste un compteur bien haché dans un état diffus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et vous vous souvenez comment l'équipe linguistique de Julia a essayé de combiner plusieurs instances de l'architecture de Vigny pour créer un PRNG rapide basé sur SIMD? </font><font style="vertical-align: inherit;">Regardons leur résultat en utilisant cette technique ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 pièces de Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,09 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Techniquement, mon ordinateur portable pourrait affecter les résultats. Je ne sais pas pourquoi le développement de l'équipe Julia est plus rapide que ChaCha8 dans GCP, mais plus lent lorsqu'il est testé localement. Sur ma machine, semi-SHISHUA tourne plus vite que le développement de l'équipe Julia, mais plus lentement que ChaCha8. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est nécessaire de vaincre tous les concurrents. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous vous demandez probablement déjà pourquoi nous avons appelé la version précédente du générateur semi-SHISHUA? Parce qu'il s'est avéré facile de doubler la vitesse si vous exécutez deux copies de semi-SHISHUA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semblable à l'idée de la commande Julia, nous initialisons séparément deux PRNG (quatre blocs d'un état 256 bits), fournissant alternativement la sortie de leur travail. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais si nous créons plus d'états, nous pouvons produire encore plus de données, en combinant quatre états par paires:</font></font><br>
<br>
<pre><code class="plaintext hljs">o0 = _mm256_xor_si256(u0, t1);<font></font>
o1 = _mm256_xor_si256(u2, t3);<font></font>
o2 = _mm256_xor_si256(s0, s3);<font></font>
o3 = _mm256_xor_si256(s2, s1);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc obtenu SHISHUA, qui a montré une vitesse de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,06 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est deux fois plus rapide que le précédent concurrent le plus rapide au monde qui a réussi le test PractRand de 32 téraoctets. </font><font style="vertical-align: inherit;">Le résultat est sur le graphique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je pense que le développement s'est révélé compétitif. </font><font style="vertical-align: inherit;">Cela fonctionne encore plus rapidement sur mon ordinateur portable - 0,03 cpb, mais je respecterai mes principes concernant le benchmark. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'espère que pendant quelques semaines encore mon générateur restera sur le podium des plus rapides du monde (veuillez le faire).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualité</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le générateur passe honnêtement BigCrush et le test PractRand de 32 téraoctets. Et tout cela grâce à quatre flux de sortie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les inconvénients de l'architecture incluent son </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">irréversibilité</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela peut être vu en réduisant à un état 4 bits avec </font></font><code>s0 = [a, b]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>s1 = [c, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Avec un décalage, nous obtenons </font></font><code>[0, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>[0, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et en remuant, </font></font><code>[b, c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>[d, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De nouveaux </font></font><code>s0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">égaux </font></font><code>[b, c] + [0, a] = [b⊕(a∧c), a⊕c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais </font></font><code>s1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">égaux </font></font><code>[d, a] + [0, c] = [d⊕(a∧c), a⊕c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si </font></font><code>a = ¬c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, alors, </font></font><code>a⊕c = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>a∧c = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donc, </font></font><code>s0 = [b, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>s1 = [d, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Autrement dit, nous obtenons deux combinaisons de </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui nous donnent le même état final. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre cas, ce n'est pas un problème, car le compteur 64 bits fait également partie de l'état. Il s'avère que le cycle minimum de 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">71</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">octets (128 octets par transition d'état), ce qui est à une vitesse de 10 gibytes / sec. </font><font style="vertical-align: inherit;">durera sept mille ans. </font><font style="vertical-align: inherit;">Cela équilibre les états perdus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, même malgré l'irréversibilité, la période de transition moyenne entre les États est de 2 ^ ((256 + 1) ÷ 2). </font><font style="vertical-align: inherit;">Cela donne un cycle moyen de </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 135</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> octets (à une vitesse de 10 gibytes / sec. Il durera plus d'un billion de fois plus longtemps que l'univers n'existe). </font><font style="vertical-align: inherit;">Même si je crois que les cycles intermédiaires sont surestimés, car ils ne nous disent rien sur la qualité du générateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici les résultats de référence:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Générateur</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualité</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corrélation des semences</font></font></strong></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHISHUA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,06</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 256 Gio</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 + x8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,09</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 Kio</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 Kio</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,31</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 Kio</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 +</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,34</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">512 Mio</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 Kio</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wyrand</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,41</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 Kio</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lehmer128</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,44</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 Kio</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RC4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.48</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 Kio</font></font></td>
</tr>
</tbody></table></div><br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performances</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : nombre de cycles de processeur passés sur un octet généré. </font><font style="vertical-align: inherit;">Reçu sur les machines cloud N2 GCP et N2D (AMD), la commande est la même.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualité</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : niveau auquel le générateur ne réussit pas le test PractRand. </font><font style="vertical-align: inherit;">S'il n'échoue pas, il y a un signe&gt;. </font><font style="vertical-align: inherit;">Si le résultat n'est pas prouvé, il y a un point d'interrogation.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corrélation des nombres de graines</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Traversée PractRand avec octets alternés de huit flux avec les nombres de graines 0, 1, 2, 4, 8, 16, 32, 64. Nous utilisons PractRand avec une double convolution et des tests avancés.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3f6/f1d/ea73f6f1db25664622785ba127764dbc.png"></div><br>
</li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus loin</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien que dans notre cas il n'y ait aucun problème d'irréversibilité, nous pouvons toujours améliorer SHISHUA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À mon avis, le PRNG idéal a les propriétés suivantes:</font></font><br>
<br>
<ol>
<li><strong>      </strong>,     2<sup>1024</sup>.      10 /.    10<sup>282</sup>  ,   .    «» (  ).              ,       .  ,      128-  NEON   ARM?  ,      ,     .</li>
<li><strong>    </strong>.      ,   SHISHUA  XOR    .     ,     .</li>
<li><strong>  ,</strong>      2<sup>128</sup>    (     ).        SHISHUA,  ,  .  ,      ( )    (, , .  2).</li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'initialisation d'état a une dispersion parfaite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : tous les bits du nombre initial affectent tous les bits de l'état avec la même probabilité. </font><font style="vertical-align: inherit;">Je veux en savoir plus sur SHISHUA.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'un des problèmes qui freinent le développement des PRNG et de la cryptographie dans son ensemble est le manque de meilleurs outils à usage général. </font><font style="vertical-align: inherit;">J'ai besoin d'un outil qui puisse me donner immédiatement le résultat de mesure exact afin que je puisse comparer différentes architectures à la volée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PractRand est génial par rapport à ce qu'il était auparavant, cependant:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il ne permet pas d'évaluer des générateurs de haute qualité, ce qui rend impossible leur comparaison les uns avec les autres. </font><font style="vertical-align: inherit;">Nous devons dire: "eh bien, après 32 téraoctets, il n'y a pas d'anomalies ..."</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela prend des semaines pour l'exécuter ...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'espère que la situation s'améliorera considérablement bientôt.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr498332/index.html">Implémentation d'une architecture de sécurité sans confiance: deuxième édition</a></li>
<li><a href="../fr498334/index.html">Comment organiser le processus de planification dans SAP Analytics Cloud</a></li>
<li><a href="../fr498340/index.html">À propos de la nouvelle IDA Home (avis)</a></li>
<li><a href="../fr498346/index.html">GoLand 2020.1 - Prise en charge améliorée des modules Go, beaucoup de complétion automatique et bien plus encore</a></li>
<li><a href="../fr498350/index.html">Le meilleur matériel pour les entretiens d'embauche et les recherches d'emploi</a></li>
<li><a href="../fr498354/index.html">Comment traduire «liste de souhaits» en «matériel» ou semi-semi-mobile semi-idéal</a></li>
<li><a href="../fr498358/index.html">Apprenez le français ou comment obtenir un adaptateur universel à partir d'un scanner de diagnostic PSA</a></li>
<li><a href="../fr498360/index.html">Évaluation des métriques de charge du serveur intégré</a></li>
<li><a href="../fr498362/index.html">Kingston conserve son leadership dans les livraisons de SSD: comment faire?</a></li>
<li><a href="../fr498366/index.html">Quels algorithmes les développeurs Yandex implémentent-ils chaque jour</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>