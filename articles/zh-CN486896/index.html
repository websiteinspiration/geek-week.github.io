<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍👨 🚩 🚨 MAG250的UID和Stalker授权 🖖🏽 🧖🏽 🧑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="长期以来，我一直对Stalker门户中的媒体控制台授权这一主题感兴趣，但是之前没有。有一天，我不小心获得了Infomir MAG250前缀，因此决定解决此问题。
 
 训练
 首先，我拆解前缀，将电缆焊接到连接器，然后将其连接到计算机。启动终端程序后，我对熟悉的U-Boot感到满意。也可以通过按任意...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>MAG250的UID和Stalker授权</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486896/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">长期以来，我一直对Stalker门户中的媒体控制台授权这一主题感兴趣，但是之前没有。</font><font style="vertical-align: inherit;">有一天，我不小心获得了Infomir MAG250前缀，因此决定解决此问题。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">训练</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我拆解前缀，将电缆焊接到连接器，然后将其连接到计算机。</font><font style="vertical-align: inherit;">启动终端程序后，我对熟悉的U-Boot感到满意。</font><font style="vertical-align: inherit;">也可以通过按任意键来中断引导过程（通常制造商会禁用此类芯片，并且您必须花费大量时间才能将U-Boot置于所需状态）。</font><font style="vertical-align: inherit;">还可以通过ssh使用root特权进行访问。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/o-/4t/p6/o-4tp67pijj-mwgwzsxy7tcq0fu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该控制台配备256MB DRAM和两个闪存驱动器，即NOR 1 MB和NAND 256 MB。</font><font style="vertical-align: inherit;">使用NOR，将在进程中加载​​U-Boot，该进程从NAND加载内核和文件系统。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getuid（）函数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前缀会在Stalker门户中授权自己，发送一堆任何信息，例如类型，固件版本，硬件版本，序列号等。但是我对gSTB.GetUID（）函数发出的device_id参数特别感兴趣。乍一看，它是像SHA256或MD5这样的哈希。参考官方文档</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soft.infomir.com/stbapi/JS/v343/gSTB.html#.GetUID</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该函数最多可以包含两个参数，但是我感兴趣的第一件事是没有参数的选项。通过在IDA中加载stbapp，我们可以轻松找到此功能。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ev/5q/ln/ev5qlnsrhnbb2d61izfqbwqktp4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再往前走，我们看到了一个有趣的时刻</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k7/gr/ow/k7growkphe0iah5oqaidlljtgpe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此处，程序分配0x41字节的内存，将其无效，然后调用驱动程序函数/ dev / stapi / stevt_ioctl，并将该内存和参数0xC004C919传递给它。</font><font style="vertical-align: inherit;">因此，某个stevt_ioctl驱动程序负责生成UID。</font><font style="vertical-align: inherit;">为了检查这一点，我快速绘制了以下代码：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mo/fa/no/mofanof9n_oicnlia9xzepfbbpo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在控制台上运行它，我看到了一个熟悉的UID。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stevt_ioctl</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一步是拆卸stapi_ioctl_stripped.ko驱动程序，该驱动程序位于/ root / modules中。</font><font style="vertical-align: inherit;">我们将驱动程序加载到IDA中，并找到处理程序0xC004C919 ioctl（我将此函数称为calcHash）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yh/0x/ph/yh0xphq5q-bouv83w_vdpsl10js.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有三个有趣的观点。</font><font style="vertical-align: inherit;">首先，将0x41字节的内存从用户空间复制到内核空间（这正是用户传输的内容，在我们的示例中由零组成），</font><b><font style="vertical-align: inherit;">调用get_mem_type</font></b><font style="vertical-align: inherit;">函数</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（沿着内核本身的方式）和结果（再次为0x41字节），然后复制到用户的地址区域。</font><font style="vertical-align: inherit;">为了找到get_mem_type函数的地址，我看到了两种可能性：看一下/ proc / kallsysms文件，希望访问不受限制，否则，否则在驱动程序本身的汇编程序中编写一个汇编程序，它将在正确的位置返回寄存器r0的值。</font><font style="vertical-align: inherit;">在/ proc / kallsysms中查看后，我惊喜地发现了</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_mem_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x8080E380 </font><font style="vertical-align: inherit;">函数的地址</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">核心</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了进行进一步的分析，您将需要分析内核。内核本身可以在制造商的固件中找到，或者您可以使用U-Boot删除转储</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jy/pw/rk/jypwrkvsciffckeuityrrpxw0gk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
或安装所需的分区。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据U-Boot信息，内核加载为0x80800000，入口点为0x80801000。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内核</font><b><font style="vertical-align: inherit;">加载到</font></b><font style="vertical-align: inherit;"> IDA中并找到</font><b><font style="vertical-align: inherit;">get_mem_type</font></b><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在分析了代码之后，我发现了本节，据说该节返回了UID。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d3/fq/tf/d3fqtfjotcjbowla35u8ww7rzzg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，UID存储在0x80D635EC。接下来，我们在IDA中寻找该值的形成位置。这是在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">init_board_extra</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数中</font><font style="vertical-align: inherit;">（我不会翻译完整列表）</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cl/ws/l2/clwsl2szmjouku6qbpyucp2g2hc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，这是在r4寄存器的地址处相同的未知值，从该值可以计算出感兴趣的哈希值（顺便说一下，fill_hash由SHA256解析）。</font><font style="vertical-align: inherit;">我真的很想知道它是什么，所以我很快在汇编器中写了一个插入，该插入器通过printk函数在寄存器r2的地址处返回了内存的内容。</font><font style="vertical-align: inherit;">以这种方式修改内核后，我制作了一个新的uImage并将其上传到USB驱动器。</font><font style="vertical-align: inherit;">并在终端U-Boot中设置：</font></font><br>
<br>
<pre><code class="plaintext hljs">usb start<font></font>
fatload usb 0:1 80000000 uImage<font></font>
bootm</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是在最后一支队伍之后，如此悲伤的等待着我，</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/pw/js/xypwjsvafjdefnqk9q4u18npeji.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
U-Boot礼貌地拒绝运送我的新内核。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编辑U-Boot</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了说服U-Boot引导我的内核，我决定使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mw</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令本身将其修补到内存中</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">首先，我对NOR闪存进行了完整转储，它位于0xA0000000。</font><font style="vertical-align: inherit;">将转储驱动到IDA之后，我发现了U-Boot复制自身的内存地址。</font><font style="vertical-align: inherit;">这是0x8FD00000。</font><font style="vertical-align: inherit;">同样，转储了这部分内存并运行了IDA之后，我很容易找到了一个检查签名的函数。</font><font style="vertical-align: inherit;">如果一切正确，她返回0。此外，在两个不同的地方叫她。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/on/tq/eb/ontqebdlazmflevjnrx2kx9nnkw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个功能到底做了什么对我来说并不有趣。</font><font style="vertical-align: inherit;">她只需要这样返回0：</font></font><br>
<br>
<pre><code class="plaintext hljs">mov #0x0, r0<font></font>
rts<font></font>
nop</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
U-Boot的相应代码现在如下所示：</font></font><br>
<br>
<pre><code class="plaintext hljs">usb start<font></font>
mw.l 8fd0ec08 000b200a;<font></font>
mw.l 8fd0ec0c 00900009<font></font>
fatload usb 0:1 80000000 uImage<font></font>
bootm</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，U-Boot愉快地加载了我的内核，该内核发出</font></font><br>
<br>
<pre><code class="plaintext hljs">EF0F3A38FF7FD567012016J04501200:1a:79:23:7e:2MAG250pq8UK0DAOQD1JzpmBx1Vwdb58f9jP7SN</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全面分析</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那么，UID由什么组成？它是一个未知的8字节数，控制台的序列号，MAC地址，控制台的类型和一块垃圾。剩下的就是找出那是什么未知数字以及垃圾来自何处。我又回到了</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">init_board_extra</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此代码段中提取了一个未知的数字：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8g/hu/u2/8ghuu2d4buowz6plm_feo1hi9pk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，使用__ioremap函数，内核访问了物理内存0x00000000（这是闪存的NOR地址），将0x0F写入0x00000000，然后将0x98写入0x000000AA，并从0x000000C2开始读取8个字节。还有，这是什么？这些是内核与NOR通信的CFI协议命令。 0x0F使NOR进入原始状态，并使用0x98切换命令mods CFI。在此模块中，地址0x000000C2是安全代码区或64位唯一设备号。那些。未知号码是唯一的NOR闪存号码。以下是CFI标识的转储。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5y/y_/ez/5yy_eziyuvoq3pirbxmfecrjfqu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以通过设置直接在U-Boot中创建转储</font></font><br>
<pre><code class="plaintext hljs">mw.w a0000000 f0<font></font>
mw.w a00000aa 98<font></font>
md.b a1000000 100<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一块垃圾只是一个普通的32字节字符集，它被缝入内核本身，</font></font><br>
<br>
<img src="https://habrastorage.org/webt/n3/dz/tb/n3dztbcvv-kjjud2dhvkg25lrni.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并且在使用加密函数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swap_pairs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之前已对该垃圾进行了处理，该函数</font><font style="vertical-align: inherit;">只是更改了字节的位置</font></font><br>
<br>
<pre><code class="plaintext hljs">[0x00000003]&lt;-&gt;[0x0000000F]<font></font>
[0x00000005]&lt;-&gt;[0x0000001F]<font></font>
[0x00000009]&lt;-&gt;[0x00000002]<font></font>
[0x0000000A]&lt;-&gt;[0x0000001D]<font></font>
[0x00000010]&lt;-&gt;[0x00000015]<font></font>
[0x00000004]&lt;-&gt;[0x00000013]<font></font>
[0x0000000D]&lt;-&gt;[0x00000018]</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据收到的信息，我敢于假设制造商的数据库包含有关每个ID NOR闪存的信息以及相应的序列号和MAC地址。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，不可能选择所有这些，但是您可以编写自己的软件，该软件可以完全模拟控制台。</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN486880/index.html">错误的翻译人员导致了灾难性的后果</a></li>
<li><a href="../zh-CN486884/index.html">日本制药公司开始测试使用神经网络合成的药物</a></li>
<li><a href="../zh-CN486888/index.html">《面向对象的方法》一书。5th int。ed。”</a></li>
<li><a href="../zh-CN486890/index.html">自我发展：我如何不坐在两把椅子上而发现第三把椅子</a></li>
<li><a href="../zh-CN486892/index.html">联系人选择器API，或如何与浏览器共享联系人</a></li>
<li><a href="../zh-CN486902/index.html">Swift 5.1中面向协议的编程</a></li>
<li><a href="../zh-CN486904/index.html">向开发人员显示SonarQube中源代码质量控制的状态</a></li>
<li><a href="../zh-CN486908/index.html">Wulfric勒索软件是不存在的加密器</a></li>
<li><a href="../zh-CN486912/index.html">Lowkiq。我们为什么要这样做？</a></li>
<li><a href="../zh-CN486914/index.html">8. Fortinet入门v6.0。与用户合作</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>