<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐲 🌠 🏽 Limites de CPU e aceleração agressiva no Kubernetes 🧀 🐮 ➿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota perev. : Este conto preventivo do Omio, o agregador de viagens europeu, leva os leitores da teoria básica aos cativantes meandros práticos da con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Limites de CPU e aceleração agressiva no Kubernetes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/489668/"><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota perev.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Este conto preventivo do Omio, o agregador de viagens europeu, leva os leitores da teoria básica aos cativantes meandros práticos da configuração do Kubernetes. A familiaridade com esses casos ajuda não apenas a ampliar os horizontes, mas também a evitar problemas não triviais.</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/bw/jr/on/bwjronw-hyhosv46aa1d6pqldie.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Você já encontrou o fato de que o aplicativo "travou" no local, parou de responder às solicitações de verificação de integridade e não conseguiu entender o motivo desse comportamento? Uma explicação possível é o limite de cota para recursos da CPU. Ele será discutido neste artigo.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TL; DR: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
é altamente recomendável que você desative os limites de CPU no Kubernetes (ou desative as cotas CFS no Kubelet) se estiver usando uma versão do kernel Linux com um erro de cota CFS. No núcleo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">há</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um </font><font style="vertical-align: inherit;">bug </font><font style="vertical-align: inherit;">sério e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conhecido</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que leva a aceleração e atrasos excessivos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No Omio, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toda a infraestrutura é gerenciada pelo Kubernetes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Todas as nossas cargas com e sem estado funcionam exclusivamente no Kubernetes (usamos o Google Kubernetes Engine). </font><font style="vertical-align: inherit;">Nos últimos seis meses, começamos a observar desacelerações aleatórias. </font><font style="vertical-align: inherit;">Os aplicativos congelam ou param de responder às verificações de integridade, perdem a conexão com a rede etc. </font><font style="vertical-align: inherit;">Esse comportamento há muito nos deixou perplexos e, finalmente, decidimos abordar o problema de perto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resumo do artigo:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algumas palavras sobre contêineres e Kubernetes;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como os pedidos e limites de CPU são implementados;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como o limite de CPU funciona em ambientes com vários núcleos;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como rastrear a otimização da CPU;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resolvendo o problema e as nuances.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algumas palavras sobre contêineres e Kubernetes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes, de fato, é o padrão moderno no mundo da infraestrutura. </font><font style="vertical-align: inherit;">Sua principal tarefa é a orquestração de contêineres.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recipientes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No passado, tínhamos que criar artefatos como Java JARs / WARs, Python Eggs ou executáveis ​​para lançamento subsequente em servidores. </font><font style="vertical-align: inherit;">No entanto, para fazê-los funcionar, eles tiveram que fazer um trabalho adicional: instalar o tempo de execução (Java / Python), colocar os arquivos necessários nos lugares certos, garantir a compatibilidade com uma versão específica do sistema operacional, etc. </font><font style="vertical-align: inherit;">Em outras palavras, você precisava prestar muita atenção ao gerenciamento de configuração (que geralmente causava contendas entre desenvolvedores e administradores de sistema). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recipientes mudaram tudo.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, a imagem do contêiner atua como um artefato. </font><font style="vertical-align: inherit;">Ele pode ser representado como um tipo de arquivo executável estendido que contém não apenas um programa, mas também um tempo de execução completo (Java / Python / ...), bem como os arquivos / pacotes necessários pré-instalados e prontos para execução. </font><font style="vertical-align: inherit;">Os contêineres podem ser implantados e executados em vários servidores sem nenhuma etapa adicional. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, os contêineres funcionam em seu próprio ambiente de sandbox. </font><font style="vertical-align: inherit;">Eles têm seu próprio adaptador de rede virtual, seu próprio sistema de arquivos com acesso limitado, sua própria hierarquia de processos, suas próprias restrições na CPU e na memória, etc. Tudo isso é conseguido graças a um subsistema especial do kernel do Linux - namespaces (namespace).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como afirmado anteriormente, o Kubernetes é uma orquestra de contêineres. </font><font style="vertical-align: inherit;">Funciona da seguinte maneira: você fornece um pool de máquinas e diz: "Ei, Kubernetes, inicie dez instâncias do meu contêiner com 2 processadores e 3 GB de memória cada e mantenha-os operacionais!" </font><font style="vertical-align: inherit;">Kubernetes cuida do resto. </font><font style="vertical-align: inherit;">Ele encontrará capacidades livres, lançará contêineres e os reiniciará se necessário, lançará uma atualização ao alterar versões etc. </font><font style="vertical-align: inherit;">De fato, o Kubernetes permite abstrair do componente de hardware e torna toda a variedade de sistemas adequada para implantação e operação de aplicativos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hs/ux/tu/hsuxtucqvih716edmdtgac_btxa.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes do ponto de vista de um simples leigo</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que são solicitação e limite no Kubernetes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certo, descobrimos os contêineres e o Kubernetes. Também sabemos que vários contêineres podem estar na mesma máquina. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode desenhar uma analogia com um apartamento comum. Uma sala espaçosa é levada (carros / nós) e arrendada a vários inquilinos (contêineres). Kubernetes atua como um corretor de imóveis. Surge a pergunta: como manter os inquilinos em conflito entre si? E se um deles, por exemplo, decide ocupar o banheiro por meio dia? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É aqui que a solicitação e o limite entram em jogo. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solicitação de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPU </font><b><font style="vertical-align: inherit;">é apenas</font></b><font style="vertical-align: inherit;"> para fins de planejamento. É algo como a "lista de desejos" de um contêiner e é usada para selecionar o nó mais adequado. Ao mesmo tempo, o CPU </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode ser comparado a uma concessão - assim que escolhemos um nó para o contêiner,</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não poderá</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ir além dos limites estabelecidos. </font><font style="vertical-align: inherit;">E aqui surge um problema ...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como solicitações e limites são implementados no Kubernetes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Kubernetes usa o mecanismo de limitação do kernel (pulando o relógio) para implementar os limites da CPU. </font><font style="vertical-align: inherit;">Se o aplicativo exceder o limite, a aceleração é ativada (ou seja, recebe menos ciclos da CPU). </font><font style="vertical-align: inherit;">Solicitações e limites de memória são organizados de maneira diferente, para que sejam mais fáceis de detectar. </font><font style="vertical-align: inherit;">Para fazer isso, basta verificar o status do último reinício do pod: se é "OOMKilled". </font><font style="vertical-align: inherit;">Com a otimização da CPU, tudo não é tão simples, pois os K8s apenas disponibilizam métricas para uso, e não para cgroups.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solicitação de CPU</font></font></h4><br>
<img src="https://habrastorage.org/webt/hh/fk/qn/hhfkqnuy5oe4tq_ubi57aeblvqe.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a solicitação de CPU é implementada</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Para simplificar, vejamos um processo usando um exemplo de máquina com CPU de 4 núcleos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O K8s usa o mecanismo cgroups para controlar a alocação de recursos (memória e processador). Um modelo hierárquico está disponível para ele: um descendente herda os limites do grupo pai. Os detalhes da distribuição são armazenados no sistema de arquivos virtual ( </font></font><code>/sys/fs/cgroup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). No caso do processador, isso </font></font><code>/sys/fs/cgroup/cpu,cpuacct/*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O K8s usa o arquivo </font></font><code>cpu.share</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para alocar recursos do processador. No nosso caso, o grupo de controle raiz recebe 4096 compartilhamentos de recursos da CPU - 100% da energia disponível do processador (1 núcleo = 1024; esse é um valor fixo). O grupo raiz distribui os recursos proporcionalmente, dependendo das quotas de descendentes prescritas em</font></font><code>cpu.share</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e aqueles, por sua vez, fazem o mesmo com seus descendentes etc. Tipicamente Kubernetes raiz do grupo de controlo tem três nó filho: </font></font><code>system.slice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>user.slice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>kubepods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Os dois primeiros subgrupos são usados ​​para distribuir recursos entre cargas críticas do sistema e programas de usuários fora dos K8s. O último - - </font></font><code>kubepods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é criado pelo Kubernetes para distribuir recursos entre os pods. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O diagrama acima mostra que o primeiro e o segundo subgrupos receberam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1024</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compartilhamentos, com </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4096</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compartilhamentos </font><font style="vertical-align: inherit;">alocados ao subgrupo kuberpod </font><font style="vertical-align: inherit;">. Como isso é possível: afinal, o grupo raiz tem apenas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4096</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compartilhamentos disponíveis e a soma das compartilhamentos de seus descendentes excede significativamente esse número ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6144</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)? O fato é que o valor faz sentido lógico; portanto, o Linux Scheduler (CFS) o utiliza para alocar proporcionalmente os recursos da CPU. No nosso caso, os dois primeiros grupos recebem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">680</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ações reais (16,6% de 4096) e o kubepod recebe as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2736</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ações </font><font style="vertical-align: inherit;">restantes </font><font style="vertical-align: inherit;">. Em caso de inatividade, os dois primeiros grupos não usarão os recursos alocados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Felizmente, o planejador possui um mecanismo para evitar a perda de recursos da CPU não utilizados. Ele transfere capacidades "inativas" para o pool global, das quais são distribuídas entre grupos que precisam de capacidades adicionais do processador (a transferência ocorre em lotes para evitar perdas por arredondamento). Um método semelhante se aplica a todos os descendentes de descendentes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse mecanismo garante uma distribuição justa da energia do processador e garante que nenhum processo "roube" recursos de outros.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limite de CPU</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apesar de as configurações dos limites e solicitações nos K8s parecerem semelhantes, sua implementação é fundamentalmente diferente: esta é a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parte mais enganosa</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e menos documentada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O K8s usa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o mecanismo de cotas do CFS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para implementar limites. Suas configurações são especificadas nos arquivos </font></font><code>cfs_period_us</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>cfs_quota_us</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no diretório cgroup (o arquivo também está localizado lá </font></font><code>cpu.share</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por outro lado </font></font><code>cpu.share</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a cota é baseada em um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">período de tempo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e não na energia disponível do processador. </font></font><code>cfs_period_us</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define a duração do período (época) - é sempre 100.000 μs (100 ms). K8s tem a capacidade de alterar esse valor, mas atualmente está disponível apenas na versão alfa. O planejador usa a era para reiniciar as cotas usadas. Segundo arquivo</font></font><code>cfs_quota_us</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, define o tempo disponível (cota) em cada época. Observe que também é indicado em microssegundos. A cota pode exceder a duração da época; em outras palavras, pode ser superior a 100 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos dois cenários em máquinas de 16 núcleos (o tipo mais comum de computadores que temos no Omio): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pt/wr/dm/ptwrdmpxueuy4p1mn7mb8vfdhyg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cenário 1: 2 threads e um limite de 200 ms. Sem limitação O </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/7f/no/i9/7fnoi9e7kz6ib6jksx2mkqmc-zo.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cenário 2: 10 flui e um limite de 200 ms. A aceleração inicia após 20 ms, o acesso aos recursos do processador é reiniciado após outros 80 ms.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Suponha que você defina o limite da CPU para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> núcleos; O Kubernetes converterá esse valor para 200 ms. Isso significa que o contêiner pode usar no máximo 200 ms de tempo da CPU sem limitar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E aqui começa a diversão. </font><font style="vertical-align: inherit;">Como mencionado acima, a cota disponível é de 200 ms. </font><font style="vertical-align: inherit;">Se você tiver </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dez</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> threads </font><font style="vertical-align: inherit;">em execução paralela </font><font style="vertical-align: inherit;">em uma máquina de 12 núcleos (veja a ilustração do cenário 2), enquanto todos os outros pods estiverem inativos, a cota será esgotada em apenas 20 ms (desde 10 * 20 ms = 200 ms) e todos os threads deste pod é </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acelerador</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pelos próximos 80 ms. </font><font style="vertical-align: inherit;">O </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bug do agendador</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> já mencionado agrava a situação </font><font style="vertical-align: inherit;">, devido à qual a otimização excessiva ocorre e o contêiner não consegue nem calcular a cota existente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como avaliar a otimização em pods?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basta ir ao pod e correr </font></font><code>cat /sys/fs/cgroup/cpu/cpu.stat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<ul>
<li> <code>nr_periods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - o número total de períodos do planejador;</font></font></li>
<li> <code>nr_throttled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- o número de períodos de estrangulamento na composição </font></font><code>nr_periods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;</font></font></li>
<li> <code>throttled_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - tempo de aceleração acumulado em nanossegundos.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/fb/kp/tp/fbkptpvc9e6c1yua63aawbropk8.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que realmente está acontecendo?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, obtemos alta aceleração em todas as aplicações. </font><font style="vertical-align: inherit;">Às vezes, é </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma vez e meia</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mais forte que o calculado! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso leva a vários erros - falhas de prontidão nas verificações, travamentos de contêiner, interrupções na conexão de rede, tempos limite nas chamadas de serviço. </font><font style="vertical-align: inherit;">Por fim, isso se traduz em aumento da latência e aumento de erros.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decisão e consequências</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo é simples aqui. </font><font style="vertical-align: inherit;">Abandonamos os limites da CPU e começamos a atualizar o kernel do SO em clusters para a versão mais recente na qual o bug foi corrigido. </font><font style="vertical-align: inherit;">O número de erros (HTTP 5xx) em nossos serviços caiu imediatamente de forma significativa:</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erros HTTP 5xx</font></font></h3><br>
<img src="https://habrastorage.org/webt/rg/t4/wt/rgt4wttq-x7-0dz8-5pfybrk_d8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erros HTTP 5xx de um serviço crítico</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempo de resposta P95</font></font></h3><br>
<img src="https://habrastorage.org/webt/xc/ds/er/xcdservm7jabpev6yly59uq_u3i.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atraso de solicitação de serviço crítico, percentil 95</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Custos operacionais</font></font></h3><br>
<img src="https://habrastorage.org/webt/zb/ym/nc/zbymnckdg75bfpktepdi8ex4byg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Número de horas gastas</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qual é o problema?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conforme declarado no início do artigo:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode fazer uma analogia com um apartamento comum ... Kubernetes atua como corretor de imóveis. </font><font style="vertical-align: inherit;">Mas como manter os inquilinos em conflito entre si? </font><font style="vertical-align: inherit;">E se um deles, por exemplo, decide ocupar o banheiro por meio dia?</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa é a pegadinha. </font><font style="vertical-align: inherit;">Um contêiner negligente pode absorver todos os recursos disponíveis do processador na máquina. </font><font style="vertical-align: inherit;">Se você tiver uma pilha de aplicativos inteligente (por exemplo, JVM, Go, Node VM estiver configurada corretamente), isso não será um problema: você poderá trabalhar nessas condições por um longo período de tempo. </font><font style="vertical-align: inherit;">Porém, se os aplicativos forem pouco otimizados ou nem otimizados ( </font></font><code>FROM java:latest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), a situação pode ficar fora de controle. </font><font style="vertical-align: inherit;">No Omio, automatizamos Dockerfiles básicos com configurações padrão adequadas para a pilha de idiomas principais, portanto não havia esse problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recomendamos que você monitore as métricas de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (uso, saturação e erros), atrasos da API e taxas de erro. </font><font style="vertical-align: inherit;">Verifique se os resultados estão conforme o esperado.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referências</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa é a nossa história. </font><font style="vertical-align: inherit;">Os seguintes materiais ajudaram muito a entender o que está acontecendo:</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kernel.org → Agendador CFS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kernel.org → Controle de largura de banda do CFS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Noções básicas sobre agendamento de contêineres do Linux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tudo o que você precisa saber sobre contêineres Linux, Parte I: Grupos de controle do Linux e isolamento de processos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Histórias de falha do Kubernetes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">pesquise</font></a><font style="vertical-align: inherit;"> por "limitação da CPU".</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Relatório de erros do Kubernetes:</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 51135: Evite definir limites de CPU para pods garantidos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 67577: as cotas do CFS podem levar a restrições desnecessárias</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CFS excessivamente agressivo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você encontrou problemas semelhantes em sua prática ou tem experiência com otimização em ambientes de produção em contêiner? </font><font style="vertical-align: inherit;">Compartilhe sua história nos comentários!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS do tradutor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leia também no nosso blog:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escalonamento automático e gerenciamento de recursos no Kubernetes (revisão e relatório de vídeo)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o Gerenciador de CPU no Kubernetes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ";</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que acontece no Kubernetes quando o kubectl run é iniciado? </font><font style="vertical-align: inherit;">Parte 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ".</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt489644/index.html">Partículas macias no WebGL e OpenGL ES</a></li>
<li><a href="../pt489650/index.html">Automação de um jornalista. Parte 1: Tarefas e calendários</a></li>
<li><a href="../pt489662/index.html">PHP Digest No. 174 (10 a 24 de fevereiro de 2020)</a></li>
<li><a href="../pt489664/index.html">NPS, transportador, computação automática e de novo ... corotinas</a></li>
<li><a href="../pt489666/index.html">Sobrecarga em C ++. parte II Sobrecarga do operador</a></li>
<li><a href="../pt489672/index.html">Revivemos o hexapod. Parte dois</a></li>
<li><a href="../pt489674/index.html">Angular: uma introdução clara ao NGRX</a></li>
<li><a href="../pt489676/index.html">Fazemos um clone do serviço de entrega de comida usando Nuxt.js, GraphQL, Strapi e Stripe. Parte 1/7</a></li>
<li><a href="../pt489678/index.html">Memória indestrutível, processos indestrutíveis</a></li>
<li><a href="../pt489682/index.html">Bloqueio de leitura de origem cruzada (CORB) nas extensões do Chrome</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>