<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🍳 🙎 👩🏾‍🤝‍👩🏼 Les performances de Java moderne lorsque vous travaillez avec de grandes quantités de données, partie 2 🧑🏻 🛩️ 🕎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FYI: La première partie .
 
 Convoyeur de lots de référence
 Le pipeline par lots traite la quantité finale de données stockées. Il n'y a pas de flux ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Les performances de Java moderne lorsque vous travaillez avec de grandes quantités de données, partie 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/507210/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/d1/gm/bn/d1gmbnhwk4pkhy1bck7ykdmu-uq.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FYI: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La première partie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convoyeur de lots de référence</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le pipeline par lots traite la quantité finale de données stockées. Il n'y a pas de flux de résultats de traitement, la sortie de la fonction d'agrégation doit être appliquée à l'ensemble des données. Cela modifie les exigences de performances: la latence - un facteur clé du traitement en streaming - est absente ici car nous traitons les données en temps réel. La seule mesure importante est la durée totale de fonctionnement du convoyeur.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, nous avons choisi Parallel. </font><font style="vertical-align: inherit;">Lors de la première étape des tests, en travaillant sur un nœud, ce collecteur a vraiment montré le meilleur débit (mais seulement après le réglage). </font><font style="vertical-align: inherit;">Cependant, cela a été obtenu au prix de longues pauses. </font><font style="vertical-align: inherit;">Si l'un des nœuds de cluster s'arrête lors de la récupération de place, cela arrête l'intégralité du pipeline. </font><font style="vertical-align: inherit;">Et comme les nœuds collectent les ordures à différents moments, le temps de génération total augmente avec l'ajout de chaque nœud au cluster. </font><font style="vertical-align: inherit;">Nous avons analysé cet effet en comparant les résultats des tests sur un nœud et sur un cluster de trois nœuds. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, à ce stade, nous n'avons pas envisagé de collecteurs expérimentaux à faible latence. </font><font style="vertical-align: inherit;">Leurs pauses très courtes n'affectent pas les résultats des tests, de plus, cela est dû à la bande passante.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test sur un seul nœud: convoyeur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour une analyse comparative par lots sur un seul nœud, nous avons utilisé un pipeline simple. Code complet </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="java hljs">p.readFrom(longSource)<font></font>
 .rebalance() <span class="hljs-comment">// Introduced in Jet 4.2</span><font></font>
 .groupingKey(n -&gt; n % NUM_KEYS)<font></font>
 .aggregate(summingLong(n -&gt; n))<font></font>
 .filter(e -&gt; (e.getKey() &amp; <span class="hljs-number">0xFF_FFFFL</span>) == <span class="hljs-number">0</span>)<font></font>
 .writeTo(Sinks.logger())<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La source est un stub qui génère une séquence de numéros de type </font></font><code>long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La fonction clé est définie de manière à </font></font><code>groupingKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parcourir l'espace clé: 0, 1, 2, ... </font></font><code>NUM_KEYS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,, 0, 1, 2, ... Cela signifie que pendant le premier cycle, le pipeline voit toutes les clés et crée une structure de données fixe pour stocker les résultats agrégation. Et au cours des prochains cycles, le système ne met à jour que les données disponibles. Ceci est parfaitement cohérent avec l'hypothèse d'une collecte des ordures prenant en compte différentes générations: les objets passent par tous les calculs, ou n'existent pas longtemps et deviennent des ordures peu de temps après leur création. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre source a généré 400 millions d'éléments et nous avons créé 100 millions de clés individuelles, c'est-à-dire quatre fois passées à travers toutes les clés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opérateur</font></font><code>.rebalance()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remplace l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agrégation en deux étapes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> par défaut de Jet par l' </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">agrégation</font></a><font style="vertical-align: inherit;"> en une </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">étape</font></a><font style="vertical-align: inherit;"> . Cela a rendu le comportement du moteur dans nos benchmarks plus prévisible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons également testé une variante dans laquelle l'opération d'agrégation utilise une instance d'un objet de type comme état </font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et génère des ordures à chaque mise à jour du compte courant. Dans ce cas, de nombreux objets meurent après un temps décent dans l'ancienne génération. Dans cette situation, nous avons dû réduire le nombre de clés à 70 millions, car à 100 millions la charge sur le collecteur était trop élevée.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous ne nous sommes pas concentrés sur les collecteurs à faible latence car ils n'ont rien à offrir dans le cas d'un pipeline batch. </font><font style="vertical-align: inherit;">Comme nous avons déjà vu que JDK 14 fonctionne presque comme JDK 11, nous avons effectué un test pour le confirmer. </font><font style="vertical-align: inherit;">Et puis nous nous sommes concentrés sur JDK 8 et JDK 11. Et nous avons également comparé le collecteur parallèle par défaut utilisé dans JDK 8 à G1.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test sur un seul nœud: résultats</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons utilisé la référence sur un ordinateur portable avec 16 Go de RAM et un processeur Intel Core i7 à 6 cœurs. La taille du tas était de 10 Go. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au début, en raison de Parallel, les performances étaient très médiocres et nous avons dû régler la collecte des ordures. Par conséquent, nous vous recommandons fortement d'utiliser VisualVM et le plug-in Visual GC. Si vous définissez la fréquence d'images maximale (10 ips), vous pouvez profiter d'une visualisation très détaillée de la relation entre l'allocation de la mémoire de votre application et le travail du garbage collector. Après avoir regardé l'animation, nous avons réalisé que le problème principal était des morceaux de mémoire trop grands alloués à la nouvelle génération. Par défaut, le rapport de l'ancienne génération à la nouvelle n'est que de 2: 1, et pendant l'exécution, il ne change pas dynamiquement. Par conséquent, nous avons décidé d'appliquer le paramètre</font></font><code>-XX:NewRatio=8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et cela a changé la situation dans son ensemble. Maintenant, Parallel fonctionnait mieux. Nous avons également appliqué des </font></font><code>-XX:MaxTenuringThreshold=2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espaces survivants pour réduire la copie de données entre les espaces, car les objets temporaires meurent rapidement dans le pipeline. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant sur les résultats. La seule mesure appropriée pour un pipeline de lots est la durée de la tâche. Pour visualiser les résultats, nous avons pris leurs valeurs réciproques, par conséquent, le graphique montre le débit en éléments par seconde. Pour un nœud:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/87a/5c6/a4f87a5c66be2c77e0337151adb9d2ca.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/377/c40/5ab/377c405ab09606862cb1464b07624d56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'agrégation sans récupération de place fonctionne environ 30 à 35% plus rapidement, malgré un jeu de clés plus important. Le bundle G1 et JDK 8 a le plus mal fonctionné, et le Parallel et le JDK 11 ont été les mieux adaptés. Le bundle G1 et JDK 11 n'a pas beaucoup perdu. Notez que nous n'avons pas touché à la configuration G1, c'est un point important. La configuration de la récupération de place dépend fortement de la situation. Les résultats peuvent changer radicalement, par exemple, avec une augmentation de la quantité de données. Et vous devez configurer pour l'ensemble du cluster, pour un type de charge spécifique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici les performances du collecteur parallèle par défaut par rapport à la version personnalisée que nous avons utilisée lors des tests:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81b/797/c4a/81b797c4acae8f632c51147b699c3cad.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec un tas de 10 Go, les résultats sont très médiocres. </font><font style="vertical-align: inherit;">Le système est resté bloqué pendant des pauses complètes pour l'assemblage, chacune ayant pris environ 7 s. </font><font style="vertical-align: inherit;">À mesure que le tas augmentait, la situation s'améliorait, mais des cycles d'assemblage complets se produisaient très souvent. </font><font style="vertical-align: inherit;">Veuillez noter que ces résultats ont été obtenus pour le cas le plus courant - agrégation sans assemblage.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test sur trois nœuds: convoyeur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour tester correctement le cluster, nous avons dû utiliser un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pipeline</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plus complexe </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs">p.readFrom(longSource())<font></font>
 .rebalance()<font></font>
 .flatMap(n -&gt; {<font></font>
     Long[] items = <span class="hljs-keyword">new</span> Long[SOURCE_STEP];<font></font>
     Arrays.setAll(items, i -&gt; n + i);<font></font>
     <span class="hljs-keyword">return</span> traverseArray(items);<font></font>
 })<font></font>
 .rebalance()<font></font>
 .groupingKey(n -&gt; n % NUM_KEYS)<font></font>
 .aggregate(AggregateOperations.summingLong(n -&gt; n))<font></font>
 .filter(e -&gt; e.getKey() % <span class="hljs-number">1_000_000</span> == <span class="hljs-number">0</span>)<font></font>
 .writeTo(Sinks.logger())<font></font>
;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme la source ne fonctionne pas en parallèle, nous avons fait quelques optimisations afin qu'elle ne se transforme pas en goulot d'étranglement dans le système. </font><font style="vertical-align: inherit;">La source génère les nombres 0, 10, 20, ..., et nous avons parallélisé le stade </font></font><code>flatMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auquel les nombres manquants sont interpolés. </font><font style="vertical-align: inherit;">Également entre la source et </font></font><code>flatMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous avons utilisé </font></font><code>rebalance()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, distribuant des données à travers le cluster. </font><font style="vertical-align: inherit;">Et avant le début de la scène principale (agrégation de clés), nous avons de nouveau rééquilibré. </font><font style="vertical-align: inherit;">Après agrégation, nous laissons d'abord uniquement chaque millionième paire clé-valeur, puis les transmettons à l'enregistreur. </font><font style="vertical-align: inherit;">Un milliard d'éléments de données et un ensemble de 500 millions de clés ont été utilisés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme dans le cas d'un nœud, nous avons testé le convoyeur avec agrégation sans déchets et avec lui.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test sur trois nœuds: résultat</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons exécuté cette référence sur un cluster AWS à partir de trois instances c5d.4xlarge. Ils avaient 16 cœurs de processeur virtualisés et 32 ​​Go de mémoire. Bande passante du canal 10 Gb / s. Résultat:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/579/cc6/a6d/579cc6a6d172a6098f96b3c2b9cfbda8.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b28/32f/ca6/b2832fca67b0123a6ca976e518ecd87c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En passant, nous notons une augmentation globale d'environ trois fois du débit par rapport à un seul nœud. Ceci est une conséquence du traitement distribué. En ce qui concerne les assembleurs, la combinaison de G1 et JDK 11 est devenue la gagnante des deux tests.Un autre résultat frappant est la combinaison presque inopérante de G1 et JDK 8. Cependant, cela a des raisons plus profondes qui affectent d'autres dimensions. Par exemple, l'avantage évident de Parallel sur JDK 8 et JDK 11. Cela est dû à l'effet que nous avons noté au tout début: dès qu'un nœud s'arrête pour le garbage collection, le traitement sur l'ensemble du cluster s'arrête. Et G1 sur JDK 8 monte pendant de très longues pauses, plus d'une minute. Cela suffit pour que le détecteur de défaillance du cluster fonctionne et décide que le nœud est mort. La tâche échoue, le cluster se réorganise et la tâche redémarre sur deux nœuds.Cela entraîne une nouvelle défaillance encore plus rapide, car chaque nœud traite désormais plus de données. Dans le même temps, le nœud éjecté se joint à nouveau et la tâche recommence sur deux nœuds, mais sur d'autres. Il y a une boucle sans fin de redémarrage des tâches.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les pauses parallèles ne sont pas aussi longues que de casser le cluster, mais cela a fonctionné bien pire sur les tests sur le même nœud. Sur trois nœuds, il a perdu 30% face au peloton de G1 et JDK 11. Et sur des clusters plus importants, la situation sera encore pire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous regardez tous les tests, il est surprenant que Parallel s'exécute plus rapidement sur JDK 8 que sur JDK 11. Cependant, cela est dû à une très bonne coïncidence: dans ces tests, des pauses complètes ont commencé de manière synchrone sur tous les nœuds, ce qui a parallélisé le travail du collecteur. De toute évidence, cet effet ne peut être invoqué.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Même si dans notre configuration de test utilisant Parallel, nous n'avons pas observé l'effet catastrophique de longues pauses sur la stabilité du cluster, c'est un scénario très probable. </font><font style="vertical-align: inherit;">Dans d'autres tests, lorsque nous avons augmenté le tas et la quantité de données, ou laissé le même tas, mais réduit la marge d'exploitation, Parallel a agi de manière tout aussi destructrice. </font><font style="vertical-align: inherit;">Mais même lorsqu'il n'a pas conduit à des pannes, sur les graphes son avantage a disparu en travaillant sur le même nœud. </font><font style="vertical-align: inherit;">On peut s'attendre à ce que la situation s'aggrave avec l'ajout de nouveaux nœuds au cluster. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En revanche, un groupe de G1 et JDK 11 a fonctionné avec des pauses assez courtes, donc le convoyeur ne s'est pas arrêté. </font><font style="vertical-align: inherit;">Il dispose d'un mécanisme qui atténue les temps d'arrêt courts et, bien que les pauses ne dépassent pas 150 ms, la récupération de place n'a qu'un impact local.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr507198/index.html">Podcasts en tant que médias d'entreprise: comment gagner de l'argent avec eux et quelles mesures utiliser</a></li>
<li><a href="../fr507200/index.html">7 façons dont les scientifiques des données vous trompent</a></li>
<li><a href="../fr507202/index.html">Meetup Avito Analytics</a></li>
<li><a href="../fr507204/index.html">Cuisine d'intérieur design industriel: du croquis au produit en boîte</a></li>
<li><a href="../fr507206/index.html">Architecture Y messenger</a></li>
<li><a href="../fr507212/index.html">Former des rivaux de jeux intelligents dans Unity en utilisant la méthode "jouer avec soi-même" en utilisant ML-Agents</a></li>
<li><a href="../fr507214/index.html">Comment créer et modifier des formulaires PDF interactifs, ou la nouvelle compétence ABBYY FineReader PDF</a></li>
<li><a href="../fr507218/index.html">Lisez-moi, ou pourquoi le texte n'est pas lu jusqu'à la fin</a></li>
<li><a href="../fr507222/index.html">Pourquoi tout le monde devrait porter des masques</a></li>
<li><a href="../fr507224/index.html">Comment éliminer les angles morts avec des tests visuels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>