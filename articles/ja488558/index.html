<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏱️ 👍🏻 📬 Kafka Streamsでアプリケーションの高可用性を確保する 🍧 🐛 🧡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kafka Streamsは、Apache Kafkaに格納されたデータを分析および処理するためのJavaライブラリです。他のストリーミング処理プラットフォームと同様に、状態を保持する、または保持しないデータ処理をリアルタイムで実行できます。この投稿では、Kafka Streamsで高可用性（99....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kafka Streamsでアプリケーションの高可用性を確保する</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488558/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka Streamsは、Apache Kafkaに格納されたデータを分析および処理するためのJavaライブラリです。</font><font style="vertical-align: inherit;">他のストリーミング処理プラットフォームと同様に、状態を保持する、または保持しないデータ処理をリアルタイムで実行できます。</font><font style="vertical-align: inherit;">この投稿では、Kafka Streamsで高可用性（99.99％）を達成することが問題である理由と、それを達成するために何ができるかを説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知っておくべきこと</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題と考えられる解決策を説明する前に、Kafka Streamsの基本的な概念を見てみましょう。</font><font style="vertical-align: inherit;">コンシューマー/プロデューサー向けのKafka APIを使用したことがある場合、これらのパラダイムのほとんどはよく知っています。</font><font style="vertical-align: inherit;">次のセクションでは、パーティション内のデータのストレージ、コンシューマグループのリバランス、およびKafkaクライアントの基本概念がKafka Streamsライブラリにどのように適合するかを簡単に説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka：データのパーティション分割</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaの世界では、プロデューサーアプリケーションはデータをキーと値のペアとして特定のトピックに送信します。</font><font style="vertical-align: inherit;">トピック自体は、Kafkaブローカーでは1つ以上のパーティションに分割されます。</font><font style="vertical-align: inherit;">Kafkaはメッセージキーを使用して、データを書き込むパーティションを示します。</font><font style="vertical-align: inherit;">その結果、同じキーを持つメッセージは常に同じパーティションに置かれます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンシューマアプリケーションはコンシューマグループに編成され、各グループにはコンシューマの1つ以上のインスタンスを含めることができます。 </font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンシューマグループのコンシューマの各インスタンスは、入力トピックのパーティションの一意のセットからのデータを処理する責任があります。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンシューマインスタンスは、基本的に、コンシューマのグループで処理をスケールアップする手段です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カフカ：消費者グループの再調整</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前に述べたように、コンシューマグループの各インスタンスは、データを消費する一意のパーティションのセットを受け取ります。</font><font style="vertical-align: inherit;">新しいコンシューマがグループに参加するときはいつでも、彼がパーティションを取得できるようにリバランスを行う必要があります。</font><font style="vertical-align: inherit;">同じことがコンシューマーが死亡したときにも起こり、残りのコンシューマーはパーティションを取得して、すべてのパーティションが確実に処理されるようにする必要があります。</font></font><br>
<cut></cut><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カフカストリーム：ストリーム</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この投稿の冒頭で、Kafka StreamsライブラリはプロデューサーとコンシューマーのAPIに基づいて構築されており、データ処理はKafkaの標準ソリューションと同じ方法で編成されていることを知りました。 Kafka Streams構成では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">application.id</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールドは</font><i><font style="vertical-align: inherit;">group.id</font></i><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">同等</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンシューマAPI。 Kafka Streamsは特定の数のスレッドを事前に作成し、それぞれが入力トピックの1つ以上のパーティションからデータ処理を実行します。コンシューマーAPIの用語で言えば、ストリームは基本的に同じグループのコンシューマーのインスタンスと一致します。スレッドは、Kafka Streamsでデータ処理をスケーリングするための主な方法です。これは、1つのマシン上の各Kafka Streamsアプリケーションのスレッド数を増やすことによって垂直に行うか、同じapplication.idでマシンを追加して水平に行うことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bb7/bd3/8ed/bb7bd38edd33f26a146c12a1dea385b5.jpg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソース：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kafka.apache.org/21/documentation/streams/architecture</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaストリームには、タスク、処理トポロジ、スレッドモデルなど、さらに多くの要素があります。これらについては、この投稿では説明しません。</font><font style="vertical-align: inherit;">詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください。</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafkaストリーム：状態ストレージ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリーム処理では、状態の保持ありとなしの操作があります。</font><font style="vertical-align: inherit;">状態は、現在処理中のレコードの範囲を超える必要な情報をアプリケーションが記憶できるようにするものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カウント、あらゆるタイプの集約、結合などの状態操作は、はるかに複雑です。これは、レコードが1つしかないため、特定のキーの最後の状態（たとえば、カウント）を判別できないため、ストリームの状態をアプリケーションに格納する必要があるためです。前に説明したように、各スレッドは一意のパーティションのセットを処理するため、スレッドはデータセット全体のサブセットのみを処理します。つまり、同じapplication.idを持つ各Kafka Streamsアプリケーションスレッドは、独自の分離状態を維持します。 Kafka Streamsでの状態の形成方法については詳しく説明しませんが、変更ログトピックを使用して状態が復元され、ローカルディスクだけでなくKafkaブローカーにも保存されることを理解することが重要です。Kafka Brokerに状態変更ログを別のトピックとして保存することは、フォールトトレランスのためだけでなく、同じapplication.idでKafka Streamsの新しいインスタンスを簡単にデプロイできるようにするためにも行われます。状態はブローカー側の変更ログトピックとして保存されるため、新しいインスタンスはこのトピックから独自の状態をロードできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状態の保存の詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka Streamsで高可用性に問題があるのはなぜですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafka Streamsを使用したデータ処理の基本的な概念と原則を確認しました。</font><font style="vertical-align: inherit;">ここで、すべてのパーツを組み合わせて、高可用性の実現が問題となる理由を分析してみましょう。</font><font style="vertical-align: inherit;">前のセクションから、覚えておく必要があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kafkaトピックのデータはパーティションに分割され、パーティションはKafka Streamsストリーム間で分散されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 同じapplication.idを持つKafka Streamsアプリケーションは、実際には1つのグループのコンシューマーであり、そのスレッドのそれぞれは、コンシューマーの個別の独立したインスタンスです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 状態操作の場合、スレッドは独自の状態を保持します。これは、変更ログの形式でKafkaトピックによって「予約」されます。</font></font></li>
<li>       , Kafka      ,    .</li>
</ol><br>
<h2>TransferWise SPaaS (Stream Processing as a Service)</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この投稿の要点を強調する前に、TransferWiseで作成したものと、なぜ高可用性が私たちにとって非常に重要であるのかを説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TransferWiseには、ストリーミング処理用のノードがいくつかあり、各ノードには各製品チームのKafka Streamsのインスタンスがいくつか含まれています。特定の開発チーム用に設計されたKafka Streamsインスタンスには特別なapplication.idがあり、通常は5つ以上のスレッドがあります。一般に、チームは通常、クラスター全体で10〜20のスレッド（コンシューマーのインスタンスの数に相当）を持っています。ノードにデプロイされたアプリケーションは、入力トピックをリッスンし、入力データの状態の有無にかかわらずいくつかのタイプの操作を実行し、後続のダウンストリームマイクロサービスにリアルタイムのデータ更新を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
製品チームは、集計データをリアルタイムで更新する必要があります。</font><font style="vertical-align: inherit;">これは、お客様に即座に送金する機能を提供するために必要です。</font><font style="vertical-align: inherit;">通常のSLA：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定の日に、集約されたデータの99.99％が10秒未満で利用可能になるはずです。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアを与えるために、Kafka Streamsはストレステスト中に、毎秒20,085の入力メッセージを処理して集約することができました。</font><font style="vertical-align: inherit;">したがって、通常の負荷での10秒のSLAは、かなり達成可能に聞こえました。</font><font style="vertical-align: inherit;">残念ながら、アプリケーションが展開されているノードのローリングアップデート中にSLAに達しませんでした。以下に、これが発生した理由を説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライディングノードの更新</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TransferWiseでは、ソフトウェアの継続的な提供を強く信じており、通常は1日に数回、サービスの新しいバージョンをリリースしています。</font><font style="vertical-align: inherit;">単純な継続的なサービス更新の例を見て、リリースプロセス中に何が起こるかを見てみましょう。</font><font style="vertical-align: inherit;">繰り返しますが、次のことを覚えておく必要があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafkaトピックのデータはパーティションに分割され、パーティションはKafka Streamsストリーム間で分散されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じapplication.idを持つKafka Streamsアプリケーションは、実際には1つのグループのコンシューマーであり、そのスレッドのそれぞれは、コンシューマーの個別の独立したインスタンスです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態操作の場合、スレッドは独自の状態を保持します。これは、変更ログの形式でKafkaトピックによって「予約」されます。</font></font></li>
<li>       , Kafka      ,    .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単一ノードでのリリースプロセスには、通常8〜9秒かかります。</font><font style="vertical-align: inherit;">リリース中、ノード上のKafka Streamsのインスタンスは「穏やかに再起動」します。</font><font style="vertical-align: inherit;">したがって、単一ノードの場合、サービスを正しく再起動するために必要な時間は約8〜9秒です。</font><font style="vertical-align: inherit;">明らかに、ノード上のKafka Streamsインスタンスをシャットダウンすると、コンシューマーグループのリバランスが発生します。</font><font style="vertical-align: inherit;">データはパーティション分割されているため、起動可能なインスタンスに属するすべてのパーティションは、同じapplication.idを持つアクティブなKafka Streamsアプリケーション間で分散する必要があります。</font><font style="vertical-align: inherit;">これは、ディスクに保存された集約データにも適用されます。</font><font style="vertical-align: inherit;">このプロセスが完了するまで、データは処理されません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタンバイレプリカ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafka Streamsアプリケーションのリバランス時間を短縮するために、バックアップレプリカの概念があります。これは、構成でnum.standby.replicasとして定義されています。バックアップレプリカは、ローカルステートストアのコピーです。このメカニズムにより、Kafka Streamsの1つのインスタンスから別のインスタンスに状態ストアを複製できます。 Kafka Streamsスレッドが何らかの理由で停止した場合、状態回復プロセスの期間を最小限に抑えることができます。残念ながら、以下で説明する理由により、バックアップレプリカでもローリングサービスの更新には役立ちません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの異なるマシン（node-aとnode-b）にKafka Streamsの2つのインスタンスがあるとします。</font><font style="vertical-align: inherit;">Kafka Streamsインスタンスごとに、これらの2つのノードでnum.standby.replicas = 1が示されます。この構成では、各Kafka Streamsインスタンスが別のノードにリポジトリの独自のコピーを保持します。</font><font style="vertical-align: inherit;">ローリング更新中、次の状況が発生します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいバージョンのサービスがnode-aにデプロイされました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node-aのKafka Streamsインスタンスは無効になっています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リバランスが始まりました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">設定num.standby.replicas = 1を指定したため、node-aのリポジトリはすでにnode-bに複製されています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node-bにはすでにnode-aのシャドウコピーがあるため、リバランスプロセスはほぼ瞬時に行われます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node-aが再起動します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> node-aは、コンシューマのグループに参加します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KafkaブローカーはKafka Streamsの新しいインスタンスを確認し、リバランスを開始します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、num.standby.replicasはノードの完全なシャットダウンのシナリオでのみ役立ちます。</font><font style="vertical-align: inherit;">つまり、node-aがクラッシュした場合、node-bはほぼ瞬時に正しく動作し続けることができます。</font><font style="vertical-align: inherit;">ただし、ローリング更新の状況では、切断後、node-aはグループに再び参加し、この最後の手順でリバランスが発生します。</font><font style="vertical-align: inherit;">再起動後にノードAがコンシューマグループに参加すると、ノードAはコンシューマの新しいインスタンスと見なされます。</font><font style="vertical-align: inherit;">ここでも、新しいインスタンスが変更ログのトピックから状態を復元するまで、リアルタイムのデータ処理が停止することを覚えておく必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Apache Kafkaコンシューマーグループのプロトコルが正確に機能する方法であるため、新しいインスタンスがグループに参加するときにパーティションを再調整することは、Kafka Streams APIには適用されないことに注意してください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実績：Kafkaストリームによる高可用性</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaクライアントライブラリは上記の問題に組み込みの機能を提供しないという事実にもかかわらず、ローリング更新中に高いクラスター可用性を実現するために使用できるいくつかのトリックがあります。</font><font style="vertical-align: inherit;">バックアップレプリカの背後にある考え方は引き続き有効であり、適切なタイミングでバックアップマシンを用意することは、インスタンス障害が発生した場合の高可用性を確保するために使用する優れたソリューションです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期設定の問題は、すべてのノードのすべてのチームに1つのグループのコンシューマーが存在することでした。</font><font style="vertical-align: inherit;">これで、1つのグループの消費者ではなく、2つのグループがあり、2つ目は「ホット」クラスターとして機能します。</font><font style="vertical-align: inherit;">製品では、ノードには特別な変数CLUSTER_IDがあり、これはKafka Streamsインスタンスのapplication.idに追加されます。</font><font style="vertical-align: inherit;">Spring Boot application.yml構成のサンプルを次に示します。</font></font><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">application.yml</font></font></b><div class="spoiler_text"><code>spring.profiles: production<br>
streaming-pipelines:<br>
 team-a-stream-app-id: "${CLUSTER_ID}-team-a-stream-app"<br>
 team-b-stream-app-id: "${CLUSTER_ID}-team-b-stream-app"</code><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ある時点では、クラスターの1つだけがそれぞれアクティブモードであり、バックアップクラスターはリアルタイムでダウンストリームマイクロサービスにメッセージを送信しません。リリースのリリース中に、バックアップクラスターがアクティブになり、最初のクラスターでのローリング更新が可能になります。これはまったく異なるグループのコンシューマーであるため、お客様は処理の違反に気付くこともなく、後続のサービスは最近アクティブなクラスターからメッセージを受信し続けます。コンシューマーのバックアップグループを使用することの明らかな欠点の1つは、オーバーヘッドとリソースの消費が増えることですが、それでもこのアーキテクチャは、ストリーミング処理システムの追加の保証、制御、およびフォールトトレランスを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追加のクラスターを追加することに加えて、頻繁なリバランスで問題を軽減できるトリックもあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">group.initial.rebalance.delay.msを増やす</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafka 0.11.0.0以降、設定group.initial.rebalance.delay.msが追加されました。</font><font style="vertical-align: inherit;">ドキュメントによると、この設定は次のことを担当します。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GroupCoordinatorがグループのコンシューマの初期リバランスを遅らせるミリ秒単位の時間。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、この設定で60,000ミリ秒を設定した場合、ローリング更新を使用すると、リリースのリリースに1分のウィンドウがある場合があります。</font><font style="vertical-align: inherit;">Kafka Streamsインスタンスがこの時間枠で正常に再起動した場合、リバランスは呼び出されません。</font><font style="vertical-align: inherit;">再起動されたKafka Streamsインスタンスが原因であったデータは、ノードがオンラインモードに戻るまで引き続き利用できないことに注意してください。</font><font style="vertical-align: inherit;">たとえば、インスタンスの再起動に約8秒かかる場合、このインスタンスが担当するデータのダウンタイムは8秒になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この概念の主な欠点は、ノードに障害が発生した場合、現在の構成を考慮して、復元中にさらに1分の遅延が発生することです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更ログトピックのセグメントサイズの縮小</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafka Streamのリバランスの大きな遅れは、変更ログのトピックからの状態ストアの復元によるものです。変更ログトピックは圧縮されたトピックであり、トピック内の特定のキーの最新のレコードを保存できます。この概念について以下で簡単に説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafka Brokerのトピックは、セグメントに編成されています。セグメントが構成済みのしきい値サイズに達すると、新しいセグメントが作成され、前のセグメントが圧縮されます。デフォルトでは、このしきい値は1 GBに設定されています。ご存知かもしれませんが、Kafkaトピックとそのパーティションの基礎となる主なデータ構造は、フォワードライトのログ構造です。つまり、メッセージがトピックに送信されると、メッセージは常に最後の「アクティブ」セグメントに追加され、圧縮は行われません。続く。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、変更ログに保存されているほとんどのストレージ状態は常に「アクティブセグメント」ファイルにあり、圧縮されないため、何百万もの圧縮されていない変更ログメッセージが生成されます。</font><font style="vertical-align: inherit;">Kafka Streamsの場合、これは、リバランス中に、Kafka Streamsインスタンスが変更ログトピックからその状態を復元するときに、変更ログトピックから多くの冗長なエントリを読み取る必要があることを意味します。</font><font style="vertical-align: inherit;">状態ストアは履歴ではなく、最後の状態のみを処理するため、この処理時間は無駄になります。</font><font style="vertical-align: inherit;">セグメントのサイズを小さくすると、より強力なデータ圧縮が行われるため、Kafka Streamsアプリケーションの新しいインスタンスはより速く回復できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafka Streamsはローリングサービスの更新中に高可用性を提供する組み込み機能を提供していませんが、これはインフラストラクチャレベルで実行できます。</font><font style="vertical-align: inherit;">Kafka Streamsは、Apache FlinkやApache Sparkとは異なり、「クラスターフレームワーク」ではないことを覚えておく必要があります。</font><font style="vertical-align: inherit;">これは、開発者がデータをストリーミングするためのスケーラブルなアプリケーションを作成できるようにする軽量のJavaライブラリです。</font><font style="vertical-align: inherit;">それにもかかわらず、「99.99％」の可用性などの野心的なストリーミング目標を達成するために必要なビルディングブロックを提供します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja488544/index.html">すでに実行中のNode.JSアプリケーションからコードカバレッジを削除する</a></li>
<li><a href="../ja488546/index.html">ボックスをハックします。JSONウォークスルー。SeImpersonatePrivilegeを介したJson.NetおよびLPEの脆弱性</a></li>
<li><a href="../ja488548/index.html">実験：英語で人気のあるテキストを作成する方法を学ぶ方法（および英語を話すHabristsがほとんど読まない理由）</a></li>
<li><a href="../ja488550/index.html">ITの巨人から協同組合を作りたい人</a></li>
<li><a href="../ja488552/index.html">Apple FASおよびペアレンタルコントロールの開発者</a></li>
<li><a href="../ja488560/index.html">Google Cloud Platformでホスティングする無料のテレグラムボット</a></li>
<li><a href="../ja488564/index.html">グラフィックスプロセッシングユニット（GPU）での最初のニューラルネットワーク。初心者向けガイド</a></li>
<li><a href="../ja488566/index.html">QAエンジニアがVisual StudioのAutoTestsとTest ITをリンクして1日を節約した方法</a></li>
<li><a href="../ja488568/index.html">ニューラルネットワークは電子マネーを夢見ていますか？</a></li>
<li><a href="../ja488570/index.html">米国シークレットサービスがサイバーパンクRPGをハッカーの教科書と混同した方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>