<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗨️ 💌 🚷 ブレンディングとユニティテレイン：交差点を取り除き、目を傷つけないようにする方法 ⛏️ 👨🏻‍🚀 🈶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ゲーム内で現実的な世界を得るには、さまざまな地形の相互の相互作用や他のモデルとの相互作用を考慮する必要があります。また、3Dモデル間の目に見える交差線が画像の整合性を損なう場合は、それらを排除する方法を検討する価値があります。そのような線の最も一般的なケースは、多くの人にはよく知られているかもしれま...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ブレンディングとユニティテレイン：交差点を取り除き、目を傷つけないようにする方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/490226/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム内で現実的な世界を得るには、さまざまな地形の相互の相互作用や他のモデルとの相互作用を考慮する必要があります。</font><font style="vertical-align: inherit;">また、3Dモデル間の目に見える交差線が画像の整合性を損なう場合は、それらを排除する方法を検討する価値があります。</font><font style="vertical-align: inherit;">そのような線の最も一般的なケースは、多くの人にはよく知られているかもしれませんが、不透明なジオメトリを持つパーティクルのビルボードの交差部分です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ja/va/g2/javag2i9gc9lhkwohebgbyklsjc.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの例は、「屋外」シーンでの岩と植生の交差点と景観の表面の不自然な自然構成です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v0/k6/s9/v0k6s98hdon17qotuaryat0vogs.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまなスムージング方法（SSAA、MSAA、CSAA、FXAA、NFAA、CMAA、DLAA、TAAなど）に加えて、このような交差線の見かけ上の問題を軽減しますが、状況を完全には修正しませんが、より効果的な手法があります。</font><font style="vertical-align: inherit;">それらを検討します。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">深度ブレンディング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityには、透明な粒子と、ソフトパーティクルと呼ばれる不透明なジオメトリとの目に見える交差を排除するための組み込みのソリューションがあります。</font><font style="vertical-align: inherit;">この効果をサポートするシェーダーは、パーティクルフラグメントの深度と不透明なジオメトリの深度の違いがどれだけ小さいかに応じて、パーティクルの透明度をさらに高めます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mz/wx/9k/mzwx9kecz9hkjps0laijveek-54.png" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソフトパーティクルの動作原理</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
明らかに、</font><i><font style="vertical-align: inherit;">ソフトパーティクルを</font></i><font style="vertical-align: inherit;">正しく動作させるには、深度バッファが必要です。</font><font style="vertical-align: inherit;">遅延シェーディングの場合、深度バッファーはフルスクリーンバッファーをレンダリングする段階で形成され、MRT（磁気共鳴断層撮影ではなく複数のレンダリングターゲット）を考慮すると、その存在は追加の計算コストで表されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォワードシェーディングでUnity Legacy Pipelineを使用する場合、不透明なジオメトリを深度バッファーにレンダリングするために追加のパスが必要でした</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このパスは、Camera.depthTextureModeプロパティに適切な値を割り当てることによってアクティブ化されます。</font><font style="vertical-align: inherit;">このプロパティはインスペクターウィンドウでは使用できませんが、API </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2]で</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、MRTの助けを借りて深度バッファーとカラーバッファーの両方を同時にレンダリングできる、フォワードシェーディングを備えた独自のバージョンのScriptable Render Pipelineを実装できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7z/-b/1l/7z-b1lg9zs8xbsywe6evbmanfiw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソフトパーティクルをサポートするシェーダーの交差線の除去</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
一般に、深度ブレンディング法を使用して、3Dモデルとランドスケープの目に見える交差を除去することには、技術的な障害はありません。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを表示</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">depth</span> <span class="hljs-selector-tag">buffer</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;
<span class="hljs-selector-tag">UNITY_DECLARE_DEPTH_TEXTURE</span>(_<span class="hljs-selector-tag">CameraDepthTexture</span>);<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
    // ...<font></font>
<font></font>
    half4 <span class="hljs-attribute">projPos </span>: TEXCOORD0;<font></font>
};<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    o.projPos = ComputeScreenPos(o.pos);<font></font>
    COMPUTE_EYEDEPTH(o.projPos.z);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{     <font></font>
    fixed4 result = 0;<font></font>
      <font></font>
    // ... <font></font>
<font></font>
    float depth = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.projPos));<font></font>
    float sceneZ = LinearEyeDepth(depth);<font></font>
    float partZ = i.projPos.z;<font></font>
    float fade = saturate( sceneZ - partZ );<font></font>
    result.a = smoothstep( BlendStart, BlendEnd, fade );<font></font>
<font></font>
    // ... <font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、このアプローチにはいくつかの欠点があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の欠点はパフォーマンスに関連しています。深度ブレンディングは、ハードウェアパイプブレンディングの段階、つまり、ラスタライズとフラグメントシェーダーの計算の直後に機能します。この段階で、フラグメントシェーダーの実行結果は、</font><font style="vertical-align: inherit;">APIへの呼び出しによって事前定義された式</font><sup><font style="vertical-align: inherit;">[6] [7] [8] [9]</font></sup><font style="vertical-align: inherit;">に従って</font><font style="vertical-align: inherit;">、出力バッファー</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] [4] [5]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">記録された結果と混合され</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
これは、20年前に前任者が働いていたのとまったく同じように機能するという意味で、ハードウェアパイプラインの中で最も進歩的でない部分です。 GPUはメモリから値を読み取り、フラグメントシェーダーの値と混合して、メモリに書き戻します。</font></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、完全に透明な3Dモデルと部分的に透明な3Dモデルのどちらに深度ブレンディングを使用するかにも違いがあります。透明-パーティクルビルボードなど-完全にブレンドしなくても、レンダリング全体が透明です。不透明な3Dモデルの場合、深さでブレンドするときの実際の有形の目に見える透明度には、非常に少数のフラグメントのみが与えられますが、それらの大部分は不透明のままです。ただし、後者は、レンダリングにブレンドが使用されないことをまったく意味しません。単にアイドル状態で動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の欠点は、混合する色の選択方法に関連しています。つまり、特定のスクリーンピクセルで混合されるすべてのフラグメントは、カメラのワールド位置から発せられ、このスクリーンピクセルのワールド位置を通過する1本の光線上にあります。つまり、カメラの位置や向きを変更すると、視差が観察されます。カメラに近い位置にある3Dモデルの断片は、カメラから遠い位置にある風景の断片よりも速く移動します</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[10] [11]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、カメラの横方向の変位が一定の近距離から見ると特に顕著です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hz/sc/78/hzsc78n3vvddbvvlgrb3hqkfwxc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カメラを動かしたときの横方向の視差：3Dモデルの断片は、風景の断片と比較してより大きな距離にシフトします</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/5v/zf/wj/5vzfwjmabznaiprchenxb9eqy3q.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カメラを移動するときの横方向の視差：カメラを風景の断片に固定すると、モデルの断片がどれだけ速く移動するかが顕著になります。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
カメラを回転させると、視差が画面座標の2つの軸に沿ってすぐに観察されます。ただし、ダイナミクスでは、これは横方向の視差ほど明白ではありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qs/ew/jn/qsewjnfucpdriai47zh9032fwcm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カメラがシフトすると方位角視差：フラグメントが2つの</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
軸</font><i><font style="vertical-align: inherit;">に沿ってシフトされると、脳が視差パターンを認識しにくく</font></i><font style="vertical-align: inherit;">なりますが、最も顕著なのは、観察者が風景の表面を見る角度に応じて、深さのブレンドの外観が変化することです。ブレンドゾーンは、ビューの方向がランドスケープサーフェスの法線に垂直である場合、ほとんど見えなくなりますが、カメラを下に傾けると、このゾーンのサイズが急速に大きくなります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hd/r8/gs/hdr8gs_ha63gspkr_eaxowjosna.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カメラ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を奥行き方向に</font><i><font style="vertical-align: inherit;">傾けながらブレンディングゾーンの幅を変更するブレンディング</font></i><font style="vertical-align: inherit;">は、3Dモデルとランドスケープの交差線をなくすための良いオプションかもしれません。</font><font style="vertical-align: inherit;">この方法は、静的ではなく、原則として非常に詳細なテクスチャを含まないパーティクルエフェクトに適しています。そのため、それらの場合、視差効果は観察されません。</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高さマップのブレンド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランドスケープブレンドを実装する別のオプションは、UnityがTerrainData API </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[12]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を介してアクセスできる高さマップを使用すること</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テレインオブジェクトの位置とTerrainDataに示されているテレインの寸法を把握し、「高さマップ」を用意しておくと、ワールド座標で指定された任意のポイントでテレインの高さを計算できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ga/69/za/ga69zap3c3xnluhjfm68g4_roto.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高さマップのサンプリングに必要な地形パラメータ</font></font></i><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Setting</span> <span class="hljs-selector-tag">up</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">heightmap</span> <span class="hljs-selector-tag">and</span> <span class="hljs-selector-tag">uniforms</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">use</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">shaders</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalTexture</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainHeightmap</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.heightmapTexture</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.HeightmapScale</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.heightmapScale</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainSize</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.size</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainPos</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.transform</span><span class="hljs-selector-class">.position</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、今、風景の高さを計算した後、シェーダーでUV座標を計算して、世界座標での風景の高さのマップをサンプリングすることもできます。</font></font><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Computes</span> <span class="hljs-selector-tag">UV</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">sampling</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">TerrainUV</span>(<span class="hljs-selector-tag">float3</span> <span class="hljs-selector-tag">worldPos</span>)<font></font>
{<font></font>
    return (worldPos.xz - TerrainPos.xz) / TerrainSize.xz;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグメントシェーダーと頂点シェーダーで同じコードを使用できるようにするために、tex2Dlod関数がサンプリングに使用されます。</font><font style="vertical-align: inherit;">また、高さマップにはミップレベルがないため、ミップレベルを自動的に計算するtex2D関数でサンプリングしても、基本的には意味がありません。</font></font><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Returns</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">height</span> <span class="hljs-selector-tag">of</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">given</span> <span class="hljs-selector-tag">position</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">world</span> <span class="hljs-selector-tag">space</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">TerrainHeight</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">terrainUV</span>)<font></font>
{<font></font>
    float heightmapSample = tex2Dlod(TerrainHeightmap, float4(terrainUV,0,0));<font></font>
    return TerrainPos.y + UnpackHeightmap(heightmapSample) * HeightmapScale.y * 2;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
深度バッファーを使用せずに、透明度を介して交差の解消を再現することができます。</font><font style="vertical-align: inherit;">これはこの方法に関連する他の問題を解決しませんが、高さマップを使用してブレンドの操作性を確認することを可能にします。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを表示</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmap</span>; 
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;        <font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
<font></font>
   // ...<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{<font></font>
    fixed4 result = 0;<font></font>
<font></font>
    // ... <font></font>
<font></font>
    half height = TerrainHeight(i.heightMapUV);<font></font>
    half deltaHeight = i.worldPos.y - height;<font></font>
    result.a = smoothstep( BlendStart, BlendEnd, deltaHeight );<font></font>
<font></font>
    // ... <font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br>
<br>
<img src="https://habrastorage.org/webt/zl/fl/nz/zlflnzwmh3tl6z_dhlvxowot4he.png"><br>
<img src="https://habrastorage.org/webt/-k/qc/f8/-kqcf8fgcmkjj7kt3gxmfpz31zu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">深度ブレンディングと標高ブレンディング。</font><font style="vertical-align: inherit;">ブレンディングゾーンの幅は、同じシェーダーパラメーターでは異なります。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
図では、両方の方法で同じブレンディングパラメーターを使用しています。</font><font style="vertical-align: inherit;">高さマップとのブレンドは、観察者の視線と風景の法線の間の角度に依存しないため、ブレンドゾーンの幅は視覚的に異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高さマップとのブレンドは、少なくとも1つの点で、深さでのブレンドよりも優れています。これは、カメラが風景を見ている角度で肉眼で見えるブレンドの依存性を修正します。</font><font style="vertical-align: inherit;">残念ながら、視差効果はまだ観察されます。</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">造園再建ブレンディング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
視差をなくすには、3Dモデルのフラグメントを、その下に垂直にある風景のフラグメントと混合する必要があります（この場合の混合の色の選択は、カメラの位置と向きに依存しません）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/en/8t/h8en8tgwnrmjvhnunm0wkgcr3cu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">視差を修正する方法：ブレンドするランドスケープフラグメントの選択</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
もちろん、ここでは仮想ランドスケープフラグメントについて詳しく説明します。カメラの位置によっては、3Dモデルのフラグメントを混合する必要がある風景のフラグメントがカメラの視野に入らない場合もあります。同様の問題が、スクリーンスペース（SSLR）でのローカル反射のレンダリングにも存在します。これは、画面上にないフラグメントの反射をレンダリングすることが不可能であるという事実にあります</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランドスケープの場合、仮想フラグメントの色は、Unity APIによって提供される補助テクスチャを使用して高精度で再構築できます：法線マップ</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[14]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ライトマップ</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[15]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ブレンドレイヤーの加重テクスチャ</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[16]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、およびに含まれるテクスチャ層の構成</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[17]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ff/hu/zr/ffhuzriatn-pfjxf-nendtckscm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランドスケープのフラグメントの再構築ランドスケープ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を構成するすべてのテクスチャは、高さマップと同じUVに従ってサンプリングされます。</font><font style="vertical-align: inherit;">レイヤーの場合、サンプリングの座標は、特定のレイヤーに指定されたタイリングパラメーターによって調整されます</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[18] [19]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを表示</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">reconstructed</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">fragments</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmapTexture</span>;
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainNormalTexture</span>;
<span class="hljs-selector-tag">sampler2D</span> <span class="hljs-selector-tag">TerrainAlphaMap</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;
<span class="hljs-selector-tag">Float4</span> <span class="hljs-selector-tag">TerrainLightmap_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap0</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap0</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap0_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap1</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap1</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap1_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap2</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap2</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap2_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap3</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap3</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap3_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
#if defined(LIGHTMAP_ON)<font></font>
   float2 <span class="hljs-attribute">modelLightMapUV </span>: TEXCOORD2;<font></font>
   float2 <span class="hljs-attribute">terrainLightMapUV </span>: TEXCOORD3;<font></font>
#endif<font></font>
<font></font>
   // ...<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
<font></font>
#if defined(LIGHTMAP_ON)<font></font>
    o.modelLightMapUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;<font></font>
    o.terrainLightMapUV = o.heightMapUV * TerrainLightmap_ST.xy + TerrainLightmap_ST.zw;<font></font>
#endif<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainNormal</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">terrainUV</span>)<font></font>
{<font></font>
    return tex2Dlod( TerrainNormalTexture, float4(terrainUV,0,0) ).xyz * 2.0 - 1.0;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv0</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv1</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv2</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv3</span>, <span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">control</span>)<font></font>
{<font></font>
    half4 splat0 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap0, TerrainSplatMap0, uv0);<font></font>
    half4 splat1 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap1, TerrainSplatMap1, uv1);<font></font>
    half4 splat2 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap2, TerrainSplatMap2, uv2);<font></font>
    half4 splat3 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap3, TerrainSplatMap3, uv3);         <font></font>
    half4 result = splat0 * control.r + <font></font>
                   splat1 * control.g + <font></font>
                   splat2 * control.b + <font></font>
                   splat3 * control.a;<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainNormalMap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv0</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv1</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv2</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv3</span>, <span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">control</span>)<font></font>
{<font></font>
    half4 n0 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap0, TerrainSplatMap0, uv0);<font></font>
    half4 n1 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap1, TerrainSplatMap1, uv1);<font></font>
    half4 n2 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap2, TerrainSplatMap2, uv2);<font></font>
    half4 n3 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap3, TerrainSplatMap3, uv3);<font></font>
    half3 result = UnpackNormalWithScale(n0, 1.0) * control.r +<font></font>
                   UnpackNormalWithScale(n1, 1.0) * control.g +<font></font>
                   UnpackNormalWithScale(n2, 1.0) * control.b +<font></font>
                   UnpackNormalWithScale(n3, 1.0) * control.a;<font></font>
    result.z += 1e-5;<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainLightmap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv</span>, <span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">normal</span>)<font></font>
{<font></font>
#if defined(LIGHTMAP_ON)<font></font>
#if defined(DIRLIGHTMAP_COMBINED)<font></font>
    half4 lm = UNITY_SAMPLE_TEX2D(unity_Lightmap, uv);<font></font>
    half4 lmd = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, uv);<font></font>
    half3 result = DecodeLightmapRGBM(lm, unity_Lightmap_HDR);<font></font>
    result = DecodeDirectionalLightmap(result, lmd, normal);<font></font>
#else<font></font>
    half4 lm = UNITY_SAMPLE_TEX2D(unity_Lightmap, uv);<font></font>
    half3 result = DecodeLightmapRGBM(lm, unity_Lightmap_HDR);<font></font>
#endif                <font></font>
#else<font></font>
    half3 result = UNITY_LIGHTMODEL_AMBIENT.rgb;<font></font>
#endif<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{<font></font>
    fixed4 result = 0;<font></font>
<font></font>
    // ...<font></font>
<font></font>
    // compute model color and put it to the result<font></font>
<font></font>
    // ... <font></font>
<font></font>
    // reconstruction of terrain fragment<font></font>
<font></font>
    float2 splatUV0 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap0);<font></font>
    float2 splatUV1 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap1);<font></font>
    float2 splatUV2 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap2);<font></font>
    float2 splatUV3 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap3);<font></font>
<font></font>
    half4 control = tex2D(_TerrainAlphaMap, i.heightMapUV);<font></font>
    half4 terrainColor = TerrainSplatMap(splatUV0, splatUV1, splatUV2, splatUV3, control);<font></font>
<font></font>
    half3 terrainSurfaceNormal = TerrainNormal(i.heightMapUV);<font></font>
    half3 terrainSurfaceTangent = cross(terrainSurfaceNormal, float3(0,0,1));<font></font>
    half3 terrainSurfaceBitangent = cross(terrainSurfaceTangent, terrainSurfaceNormal);<font></font>
<font></font>
    half3 terrainNormal = TerrainNormalMap(splatUV0, splatUV1, splatUV2, splatUV3, control);<font></font>
    terrainNormal = terrainNormal.x * terrainSurfaceTangent + <font></font>
                    terrainNormal.y * terrainSurfaceBitangent + <font></font>
                    terrainNormal.z * terrainSurfaceNormal;<font></font>
    <font></font>
    half3 terrainLightmapColor = TerrainLightmap(i.heightMapUV, terrainNormal);<font></font>
    terrainColor *= terrainLightmapColor;<font></font>
<font></font>
    // blend model color &amp; terrain color<font></font>
<font></font>
    half height = TerrainHeight(i.heightMapUV);<font></font>
    half deltaHeight = i.worldPos.y - height;<font></font>
    half blendingWeight = smoothstep(BlendStart, BlendEnd, deltaHeight);<font></font>
<font></font>
    result.rgb = lerp(result.rgb, terrainColor, blendingFactor);<font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ランドスケープフラグメントの再構築とブレンドすると、深度ブレンドと高さマップとの典型的な問題がすべて修正されます（視差を含む）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mf/pb/0s/mfpb0sfkav-hj-i5xhpll305drc.png"><br>
<img src="https://habrastorage.org/webt/ba/-z/x6/ba-zx6icghn-mnbreobdnekbjay.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">造園再建ブレンディング</font></font></i><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テレインフラグメント再構築パフォーマンス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点で、質問する時が来ました。この種の妥協の価値は何ですか？一見すると、ランドスケープフラグメントの再構築のリソース強度は、アルファブレンディングのリソース強度をはるかに超えています。再構築するには、メモリからの追加の読み取り操作を12回実行する必要があります。アルファブレンディングでは、メモリからの1回の読み取り操作とメモリへの1回の書き込み操作のみが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、すべてがハードウェアプラットフォームの機能に依存します。フラグメントの再構築は、テクスチャ圧縮、ミップマッピング、GPUコアの処理能力、および特定のハードウェアパイプラインの最適化（早期深度拒否）によってサポートされます。そして、アルファブレンディングに対しては、すでに上で述べた事実は、それがどのGPUでも最も進歩的でない部分であるということです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、最適化の余地は常にあります。</font><font style="vertical-align: inherit;">たとえば、風景の色を再構築する場合、この再構築が必要になるのは、風景の表面から一定の高さ以下にある、3Dモデルの細長い断片のみです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェーダーでの動的分岐は、予測できないパフォーマンス結果をもたらす可能性がありますが、考慮すべき2つの点があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件による分岐で不要な計算をスキップすることは、この条件が大部分のケースで満たされない場合に実行する必要があります。</font></font></li>
<li>       .   ,             ( ,  ),      GPU.    ―   (branch granularity),  , , ,          ,      .         ,    ,       .  ,   GPU  ,     ,       . ,      GPU,   ,  1 (PowerVR SGX).</li>
</ol><br>
<img src="https://habrastorage.org/webt/i7/8y/x9/i78yx9mn7egjmojcmxl67crz1kc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なる度合いの一貫性の視覚化</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
フラグメントの再構成の場合、これらの両方の点が考慮されます。ほとんどの場合、分岐条件は、ランドスケープの色を再構成するためのリソース集約型の操作の実装を遮断することを可能にします。 「レッド」ゾーンと「グリーン」ゾーンの間の境界線）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k3/do/ic/k3doicnobaqmuv82xbdfvq_kgas.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランドスケープフラグメントの再構築の一貫性</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このブレンディング方法に関するいくつかのコメントを追加します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unityは、ランドスケープが</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インスタンスの描画</font><sup><font style="vertical-align: inherit;">]を</font></sup><font style="vertical-align: inherit;">有効にしている場合にのみ必要なすべてのテクスチャを提供します</font><sup><font style="vertical-align: inherit;">[20]</font></sup><font style="vertical-align: inherit;">。</font></font></li>
<li> Unity API    ,      (base map)         . -          .</li>
<li>         ,   API          (, Metal   16  ). </li>
<li>    3D-  ,     Terrain,     SRP.</li>
<li> 3D-      ,       3D-    . </li>
<li>,   «» ,     «»  .    ,  «»      ,             .  «»          .</li>
</ol><br>
<img src="https://habrastorage.org/webt/9z/yi/y-/9zyiy-6z47y7pxyonhwrl31zyoc.png"><br>
<i>    </i><br>
<br>
<br>
<h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dモデルを設計するとき、これらのモデルが使用されることになっているさまざまな地形の起伏を考慮することは不可能です。多くの場合、3Dモデルは、突出している部分を非表示にするためにランドスケープで深く「沈める」か、回転させる必要があります。逆に、表示する必要がある非表示の部分を表示します。 「ウォーミング」モデルは適用範囲を制限し、3Dモデルがランドスケープよりも早くレンダリングされると、オーバードローエフェクトも発生します。また、ターンは、すべての3Dモデル（たとえば、家や木ではない）には適していない。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ue/tg/8y/uetg8yx5ctdsn80stvnnezplgh4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dモデルの突き出た要素を非表示にするには、横向きに「ドロー」する必要があります</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スナップとは、グラフィックエディターのユーザーにとって馴染みのある用語です。これは、コントロールポイントを空間グリッドのノードに「固定」し、3Dエディターで他のオブジェクトの面とサーフェスに固定できる機能です。頂点シェーダーでランドスケープの高さのマップにスナップすると、シーンのデザインを大幅に簡略化できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4w/1t/xw/4w1txwi3vaczzpne7ewajozlymo.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スナップなしの3Dモデル。頂点スナップのある3Dモデル。頂点のスナップとブレンドを備えた3Dモデル。頂点スナップ、ブレンド、静的ライティングを備えた3Dモデル</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スナップを実装する際の主な困難は、3Dモデルのどの頂点を高さマップにスナップする必要があるか、どの頂点に価値がないかを理解する必要があることです。</font><font style="vertical-align: inherit;">頂点には、サーフェスのローカルな性質に関する情報（十分ではありません）のみが含まれ、トポロジに関する情報（必要）は含まれていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のアプリケーションの場合と同様に、この問題は、頂点に必要なパラメーターを直接実装することで、モデリング段階で最も簡単に解決できます。</font><font style="vertical-align: inherit;">そのようなパラメーターとして、直感的な属性を選択する必要があります。たとえば、スナップの重み付け係数（柔軟性のために必要なオープンサーフェスの境界までの距離ではありません）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7b/gq/2b/7bgq2bdhdlr13qgeqpgcocvo0q8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スナップの重み付けコーディング</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを表示</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Per-vertex</span> <span class="hljs-selector-tag">snapping</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmapTexture</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
<font></font>
   // ...<font></font>
<font></font>
};<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
    float snappingWeight = v.color.r;                <font></font>
    half height = TerrainHeight( o.heightMapUV );                <font></font>
    o.worldPos.y = lerp( o.worldPos.y, height, snappingWeight );<font></font>
    o.pos = UnityWorldToClipPos( half4( o.worldPos, 1 ) );<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頂点スナップの適用性は、地形と3Dモデルの表面との間の一般的な対応によって制限されます。</font><font style="vertical-align: inherit;">それらの重要な違いを補うには、他のよりリソース集約的な方法を使用する必要があります。たとえば、スキニング付きの3Dモデルを使用します。</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事から取り上げるべき主なアイデア：十分に複雑で潜在的にスケーラブルなシェーダーには基本的なデータが必要です。</font><font style="vertical-align: inherit;">また、開発者のタスクは、グラフィックシステムの操作方法を理解することです。グラフィックシステムが提供するデータ、相互に組み合わせる方法、シェーダーでの使用方法などです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的なケースでは、グラフィック効果の可能性が制限されているフレームワークを克服する唯一のオプションは、さまざまなシェーダーの結果を結合することであると結論付けることができます。</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンクを表示</font></font></b><div class="spoiler_text"><sup>[1]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.unity3d.com/Manual/SL-CameraDepthTexture.html</a><br>
<sup>[2]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.unity3d.com/ScriptReference/Camera-depthTextureMode.html</a><br>
<sup>[3]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.unity3d.com/ScriptReference/RenderTexture.html</a><br>
<sup>[4]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">www.khronos.org/opengl/wiki/Framebuffer_Object</a><br>
<sup>[5]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-id3d11device-createrendertargetview</a><br>
<sup>[6]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.unity3d.com/ScriptReference/Rendering.BlendMode.html</a><br>
<sup>[7]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.unity3d.com/ScriptReference/Rendering.BlendOp.html</a><br>
<sup>[8]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">www.khronos.org/opengl/wiki/Blending</a><br>
<sup>[9]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-blend-state</a><br>
<sup>[10]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">en.wikipedia.org/wiki/Parallax</a><br>
<sup>[11]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">en.wikipedia.org/wiki/Parallax_scrolling</a><br>
<sup>[12]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-heightmapTexture.html</a><br>
<sup>[13]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">pdfs.semanticscholar.org/ce6c/fcafe3581a7e4d7184a9727cc504bdc6b295.pdf</a><br>
<sup>[14]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-normalmapTexture.html</a><br>
<sup>[15]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-lightmapIndex.html</a><br>
<sup>[16]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-alphamapTextures.html</a><br>
<sup>[17]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-terrainLayers.html</a><br>
<sup>[18]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainLayer-tileSize.html</a><br>
<sup>[19]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainLayer-tileOffset.html</a><br>
<sup>[20]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-drawInstanced.html</a><br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja490204/index.html">2020年3月の人事およびIT採用担当者向けイベントのダイジェスト</a></li>
<li><a href="../ja490208/index.html">DUMP2020のバックエンドセクション：banter、fan、fail</a></li>
<li><a href="../ja490210/index.html">フロントエンドの高速化。サーバーリクエストが多い場合</a></li>
<li><a href="../ja490222/index.html">死の日標準ライブラリ</a></li>
<li><a href="../ja490224/index.html">おしゃれなステルス</a></li>
<li><a href="../ja490232/index.html">AWS ELBを使用した負荷分散</a></li>
<li><a href="../ja490234/index.html">Auroraのモバイルバンクをどのように実行したか：国内のモバイルOSの開発機能</a></li>
<li><a href="../ja490238/index.html">出会い系アプリが私たちを孤独にする方法</a></li>
<li><a href="../ja490242/index.html">SIM800xモジュールのGSMロケーションサービスとYandex.Locator APIとの連携</a></li>
<li><a href="../ja490244/index.html">ctypesによるPythonコードの最適化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>