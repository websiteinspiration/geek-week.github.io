<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öïÔ∏è üçµ üèüÔ∏è Programaci√≥n de un juego para un dispositivo integrado en ESP32: unidad, bater√≠a, sonido üï¥üèº üóíÔ∏è üöú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inicio: sistema de montaje, entrada, pantalla .
 
 Parte 4: conducir
 Odroid Go tiene una ranura para tarjeta microSD, que ser√° √∫til para descargar re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programaci√≥n de un juego para un dispositivo integrado en ESP32: unidad, bater√≠a, sonido</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503876/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/800/42e/44b80042e94aa2f2da9da2d2296461ad.jpg" alt="imagen"></div><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicio: sistema de montaje, entrada, pantalla</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 4: conducir</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go tiene una ranura para tarjeta microSD, que ser√° √∫til para descargar recursos (sprites, archivos de sonido, fuentes) y posiblemente incluso para guardar el estado del juego. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El lector de tarjetas est√° conectado a trav√©s de SPI, pero IDF facilita la interacci√≥n con la tarjeta SD al abstraer las llamadas SPI y usar funciones </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POSIX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est√°ndar </font><font style="vertical-align: inherit;">como </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fopen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fread</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fwrite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Todo esto se basa en la biblioteca </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FatFs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por lo que la tarjeta SD debe formatearse en el formato FAT est√°ndar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Est√° conectado al mismo bus SPI que el LCD, pero utiliza una l√≠nea de selecci√≥n de chip diferente. </font><font style="vertical-align: inherit;">Cuando necesitamos leer o escribir en la tarjeta SD (y esto no sucede muy a menudo), el controlador SPI cambiar√° la se√±al CS de la pantalla al lector de tarjetas SD y luego realizar√° la operaci√≥n. </font><font style="vertical-align: inherit;">Esto significa que al enviar datos a la pantalla, no podemos realizar ninguna operaci√≥n con la tarjeta SD, y viceversa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este momento, estamos haciendo todo en un solo hilo y estamos utilizando la transmisi√≥n de bloqueo a trav√©s de SPI a la pantalla, por lo que no puede haber transacciones simult√°neas con la tarjeta SD y con la pantalla LCD. </font><font style="vertical-align: inherit;">En cualquier caso, existe una alta probabilidad de que carguemos todos los recursos en el momento del lanzamiento.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modificaci√≥n de la ESP-IDF</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si intentamos inicializar la interfaz de la tarjeta SD despu√©s de la inicializaci√≥n de la pantalla, encontraremos un problema que hace imposible cargar Odroid Go. </font><font style="vertical-align: inherit;">ESP-IDF v4.0 no admite acceso compartido al bus SPI cuando se usa con una tarjeta SD. </font><font style="vertical-align: inherit;">Recientemente, los desarrolladores han agregado esta funcionalidad, pero a√∫n no est√° en una versi√≥n estable, por lo que nosotros mismos haremos una peque√±a modificaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comente la l√≠nea 303 </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp-idf / components / driver / sdspi_host.c</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Initialize SPI bus</span>
<span class="hljs-keyword">esp_err_t</span> ret = spi_bus_initialize((<span class="hljs-keyword">spi_host_device_t</span>)slot, &amp;buscfg,<font></font>
    slot_config-&gt;dma_channel);<font></font>
<span class="hljs-keyword">if</span> (ret != ESP_OK) {<font></font>
    ESP_LOGD(TAG, <span class="hljs-string">"spi_bus_initialize failed with rc=0x%x"</span>, ret);
    <span class="hljs-comment">//return ret;</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de hacer este cambio, a√∫n veremos un error durante la inicializaci√≥n, pero ya no har√° que el ESP32 se reinicie, porque el c√≥digo de error no se propaga arriba.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializaci√≥n</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57f/4f8/b0f/57f4f8b0fcca66e243637eeb68b39ff7.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/554/eae/9ec/554eae9ec4a3e850eb44e817e8b7b181.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Necesitamos decirle a IDF qu√© pines ESP32 est√°n conectados al lector MicroSD para que configure correctamente el controlador SPI subyacente, que realmente se comunica con el lector. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las notas generales </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VSPI.XXXX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se usan nuevamente en el </font><strong><font style="vertical-align: inherit;">diagrama</font></strong><font style="vertical-align: inherit;"> , pero podemos revisarlas hasta los n√∫meros de contacto reales en ESP32. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La inicializaci√≥n es similar a la inicializaci√≥n de la pantalla LCD, pero en lugar de la estructura general de configuraci√≥n SPI, utilizamos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdspi_slot_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dise√±ado para una tarjeta SD conectada a trav√©s del bus SPI. Configuramos los n√∫meros de contacto correspondientes y las propiedades de montaje de la tarjeta en el sistema FatFS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La documentaci√≥n de IDF no recomienda usar la funci√≥n </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_vfs_fat_sdmmc_mount</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el c√≥digo del programa terminado. Esta es una funci√≥n de envoltura que realiza muchas operaciones para nosotros, pero hasta ahora funciona con bastante normalidad, y probablemente nada cambiar√° en el futuro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El par√°metro </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"/ sdcard"</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><font style="vertical-align: inherit;">esta funci√≥n establece el punto de montaje virtual de la tarjeta SD, que luego utilizaremos como prefijo cuando trabajemos con archivos. Si tuvi√©ramos un archivo llamado "test.txt" en nuestra tarjeta SD, la ruta que usar√≠amos para vincularlo ser√≠a "/sdcard/test.txt". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de la inicializaci√≥n de la interfaz de la tarjeta SD, la interacci√≥n con los archivos es trivial: simplemente podemos usar llamadas est√°ndar a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">las</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funciones </font><strong><font style="vertical-align: inherit;">POSIX</font></strong><font style="vertical-align: inherit;"> , lo cual es muy conveniente.</font></font><br>
<br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">   8.3</a>,              .    ,   <b>fopen</b>   .        <b>make menuconfig</b>,       ,     <b>8.3</b>.</blockquote><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/62f/94a/d9462f94aeec7fbdce989e34967e637d.png"></div><br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cre√©</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un sprite de 64x64 </font><font style="vertical-align: inherit;">
en </font><strong><font style="vertical-align: inherit;">Aseprite</font></strong><font style="vertical-align: inherit;"> (terrible) que usa solo dos colores: completamente negro (p√≠xel deshabilitado) y completamente blanco (p√≠xel habilitado). Aseprite no tiene la opci√≥n de guardar el color RGB565 o exportarlo como un mapa de bits sin procesar (es decir, sin compresi√≥n y encabezados de imagen), por lo que export√© el sprite a un formato PNG temporal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, usando </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImageMagick,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> convert√≠ los datos a un archivo PPM, que convirti√≥ la imagen en datos sin comprimir sin formato con un encabezado simple. Luego, abr√≠ la imagen en un editor hexadecimal, elimin√© el encabezado y convert√≠ el color de 24 bits a 16 bits, eliminando todas las ocurrencias </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x000000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y todas las ocurrencias </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El orden de bytes aqu√≠ no es un problema, porque </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no cambian al cambiar el orden de bytes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El archivo sin formato se puede descargar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">FILE* spriteFile = fopen(<span class="hljs-string">"/sdcard/key"</span>, <span class="hljs-string">"r"</span>);<font></font>
assert(spriteFile);<font></font>
<font></font>
<span class="hljs-keyword">uint16_t</span>* sprite = (<span class="hljs-keyword">uint16_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">64</span> * <span class="hljs-number">64</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>));<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i)<font></font>
{<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; ++j)<font></font>
	{<font></font>
		fread(sprite, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>), <span class="hljs-number">64</span> * <span class="hljs-number">64</span>, spriteFile);<font></font>
	}<font></font>
}<font></font>
<font></font>
fclose(spriteFile);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, abrimos el archivo de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clave</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que </font><font style="vertical-align: inherit;">contiene bytes sin procesar y lo leemos en el b√∫fer. </font><font style="vertical-align: inherit;">En el futuro, cargaremos los recursos de sprites de manera diferente, pero para una demostraci√≥n esto es suficiente.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> spriteRow = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = y; row &lt; y + <span class="hljs-number">64</span>; ++row)<font></font>
{<font></font>
	spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = x; col &lt; x + <span class="hljs-number">64</span>; ++col)<font></font>
	{<font></font>
		<span class="hljs-keyword">uint16_t</span> pixelColor = sprite[<span class="hljs-number">64</span> * spriteRow + spriteCol];<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pixelColor != <span class="hljs-number">0</span>)<font></font>
		{<font></font>
			gFramebuffer[row * LCD_WIDTH + col] = color;<font></font>
		}<font></font>
<font></font>
		++spriteCol;<font></font>
	}<font></font>
<font></font>
	++spriteRow;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para dibujar un sprite, recorremos iterativamente su contenido. </font><font style="vertical-align: inherit;">Si el p√≠xel es blanco, lo dibujamos en el color seleccionado por los botones. </font><font style="vertical-align: inherit;">Si es negro, lo consideramos un fondo y no dibujamos.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Su navegador no admite video HTML5.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_4/media/sprite_drawing.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La c√°mara de mi tel√©fono tiene distorsiones de color. </font><font style="vertical-align: inherit;">Y perd√≥n por sacudirla. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para probar la grabaci√≥n de la imagen, moveremos la tecla a alg√∫n lugar de la pantalla, cambiaremos su color y luego escribiremos el buffer de cuadros en la tarjeta SD para que pueda verse en la computadora.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (input.menu)<font></font>
{<font></font>
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* snapFilename = <span class="hljs-string">"/sdcard/framebuf"</span>;<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Writing snapshot to %s"</span>, snapFilename);<font></font>
<font></font>
	FILE* snapFile = fopen(snapFilename, <span class="hljs-string">"wb"</span>);<font></font>
	assert(snapFile);<font></font>
<font></font>
		fwrite(gFramebuffer, <span class="hljs-keyword">sizeof</span>(gFramebuffer[<span class="hljs-number">0</span>]), LCD_WIDTH * LCD_HEIGHT, snapFile);<font></font>
	}<font></font>
<font></font>
	fclose(snapFile);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al presionar la tecla Men√∫, se guarda el contenido del b√∫fer de cuadros en un archivo llamado </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">framebuf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este ser√° un b√∫fer de cuadros sin formato, por lo que los p√≠xeles permanecer√°n en formato RGB565 con el orden de bytes invertido. </font><font style="vertical-align: inherit;">Podemos usar nuevamente ImageMagick para convertir este formato a PNG para verlo en una computadora.</font></font><br>
<br>
<pre><code class="cpp hljs">convert -depth <span class="hljs-number">16</span> -size <span class="hljs-number">320</span>x240+<span class="hljs-number">0</span> -endian msb rgb565:FRAMEBUF snap.png</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, podemos implementar la lectura / escritura en formato BMP / PNG y deshacernos de todo este alboroto con ImageMagick, pero esto es solo un c√≥digo de demostraci√≥n. </font><font style="vertical-align: inherit;">Hasta ahora no he decidido qu√© formato de archivo quiero usar para almacenar sprites.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bd/09c/e66/0bd09ce669a61276676a87b01c15e6f2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Aqu√≠ est√° √©l! </font><font style="vertical-align: inherit;">El b√∫fer de cuadro Odroid Go se muestra en la computadora de escritorio.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referencias</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esquema de odroid go</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentaci√≥n ESP-IDF: SDMMC</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 5: bater√≠a</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go tiene una bater√≠a de iones de litio, por lo que podemos crear un juego que puedas jugar sobre la marcha. </font><font style="vertical-align: inherit;">Esta es una idea tentadora para alguien que jug√≥ el primer Gameboy cuando era ni√±o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, necesitamos una forma de solicitar el nivel de bater√≠a del Odroid Go. </font><font style="vertical-align: inherit;">La bater√≠a est√° conectada al contacto en el ESP32, por lo que podemos leer el voltaje para tener una idea aproximada del tiempo de funcionamiento restante.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esquema</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f2/ceb/13b/1f2ceb13bf408d8773f22047464e4e66.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El diagrama muestra </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conectado al </font><font style="vertical-align: inherit;">voltaje </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> despu√©s de ser llevado a tierra a trav√©s de una resistencia. Dos resistencias ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R21</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R23</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) forman un divisor de voltaje similar al que se usa en la cruz del gamepad; Las resistencias vuelven a tener la misma resistencia, de modo que el voltaje es la mitad del original. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debido al divisor de voltaje, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> leer√° un voltaje igual a la mitad de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto probablemente se haga porque los contactos ADC en el ESP32 no pueden leer el alto voltaje de la bater√≠a de iones de litio (4.2 V con carga m√°xima). Sea como fuere, esto significa que para obtener el voltaje verdadero, debe duplicar la lectura de voltaje del ADC (ADC).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al leer el valor de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> obtenemos un valor digital, pero perdemos el valor anal√≥gico que representa. Necesitamos una manera de interpretar un valor digital con un ADC en forma de un voltaje anal√≥gico f√≠sico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDF le permite calibrar el ADC, que intenta dar un nivel de voltaje basado en el voltaje de referencia. Este voltaje de referencia ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vref</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) es de 1100 mV por defecto, pero debido a las caracter√≠sticas f√≠sicas, cada dispositivo es ligeramente diferente. ESP32 en Odroid Go tiene un Vref definido manualmente, "flasheado" en eFuse, que podemos usar como un Vref m√°s preciso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El procedimiento ser√° el siguiente: primero, configuraremos la calibraci√≥n ADC, y cuando queramos leer el voltaje, tomaremos un cierto n√∫mero de muestras (por ejemplo, 20) para calcular las lecturas promedio; entonces usamos el IDF para convertir estas lecturas a voltaje. El c√°lculo del promedio elimina el ruido y brinda lecturas m√°s precisas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desafortunadamente, no hay una conexi√≥n lineal entre el voltaje y la carga de la bater√≠a. Cuando la carga disminuye, el voltaje cae, cuando aumenta, aumenta, pero de manera impredecible. Todo lo que se puede decir: si el voltaje es inferior a aproximadamente 3,6 V, entonces la bater√≠a se descarga, pero es sorprendentemente dif√≠cil convertir con precisi√≥n el nivel de voltaje en un porcentaje de la carga de la bater√≠a.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para nuestro proyecto, esto no es particularmente importante. </font><font style="vertical-align: inherit;">Podemos implementar una aproximaci√≥n aproximada para que el jugador sepa sobre la necesidad de cargar r√°pidamente el dispositivo, pero no sufriremos, tratando de obtener el porcentaje exacto.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED de estado</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/0ad/2d6/b520ad2d63e2a4c59924debb6c3613bc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el panel frontal debajo de la pantalla Odroid Go hay un LED azul (LED), que podemos usar para cualquier prop√≥sito. Puede mostrarles que el dispositivo est√° encendido y funcionando, pero en este caso, cuando juega en la oscuridad, un LED azul brillante brillar√° en su cara. Por lo tanto, lo usaremos para indicar una carga baja de la bater√≠a (aunque preferir√≠a un color rojo o √°mbar para esto). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para usar el LED, debe configurar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como salida y luego aplicarle una se√±al alta o baja para encender y apagar el LED. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que una </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resistencia de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2 kŒ© ( </font><strong><font style="vertical-align: inherit;">resistencia limitadora de corriente</font></strong><font style="vertical-align: inherit;"> ) ser√° suficiente para que no quememos el LED y suministremos demasiada corriente desde el pin GPIO.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El LED tiene una resistencia bastante baja, por lo que si se le aplican 3,3 V, lo quemaremos cambiando la corriente. </font><font style="vertical-align: inherit;">Para protegerse contra esto, generalmente se conecta una resistencia en serie con el LED. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, las resistencias limitadoras de corriente para los LED suelen ser mucho menos de 2 kŒ©, por lo que no entiendo por qu√© la resistencia </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es tal resistencia.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializaci√≥n</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> BATTERY_READ_PIN = ADC1_GPIO36_CHANNEL;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BATTERY_LED_PIN = GPIO_NUM_2;<font></font>
<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">esp_adc_cal_characteristics_t</span> gCharacteristics;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeBatteryReader</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-comment">// Configure LED</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; BATTERY_LED_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure ADC</span><font></font>
	{<font></font>
		adc1_config_width(ADC_WIDTH_BIT_12);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
<font></font>
    	<span class="hljs-keyword">esp_adc_cal_value_t</span> type = esp_adc_cal_characterize(<font></font>
    		ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_12, <span class="hljs-number">1100</span>, &amp;gCharacteristics);<font></font>
<font></font>
    	assert(type == ESP_ADC_CAL_VAL_EFUSE_VREF);<font></font>
    }<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Battery reader initialized"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero configuramos el LED GPIO como salida para que podamos cambiarlo si es necesario. </font><font style="vertical-align: inherit;">Luego configuramos el pin ADC, como lo hicimos en el caso de una cruz, con un ancho de bits de 12 y atenuaci√≥n m√≠nima. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_characterize</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> realiza c√°lculos para que podamos caracterizar el ADC de modo que luego podamos convertir las lecturas digitales en estr√©s f√≠sico.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lectura de la bater√≠a</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">Odroid_ReadBatteryLevel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SAMPLE_COUNT = <span class="hljs-number">20</span>;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> raw = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sampleIndex = <span class="hljs-number">0</span>; sampleIndex &lt; SAMPLE_COUNT; ++sampleIndex)<font></font>
	{<font></font>
		raw += adc1_get_raw(BATTERY_READ_PIN);<font></font>
	}<font></font>
<font></font>
	raw /= SAMPLE_COUNT;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> voltage = <span class="hljs-number">2</span> * esp_adc_cal_raw_to_voltage(raw, &amp;gCharacteristics);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> voltage;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tomamos veinte muestras sin procesar del ADC del contacto del ADC, y luego las dividimos para obtener el valor promedio. Como se mencion√≥ anteriormente, esto ayuda a reducir el ruido de las lecturas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego usamos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_raw_to_voltage</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para convertir el valor bruto al voltaje real. Debido al divisor de voltaje mencionado anteriormente, duplicamos el valor de retorno: el valor de lectura ser√° la mitad del voltaje real de la bater√≠a. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En lugar de encontrar formas dif√≠ciles de convertir este voltaje a un porcentaje de la carga de la bater√≠a, devolveremos un voltaje simple. Deje que la funci√≥n de llamada decida por s√≠ misma qu√© hacer con el voltaje, ya sea convertirlo en un porcentaje de la carga o simplemente interpretarlo como un valor alto o bajo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El valor se devuelve en milivoltios, por lo que la funci√≥n de llamada debe realizar la conversi√≥n adecuada. </font><font style="vertical-align: inherit;">Esto evita el desbordamiento del flotador.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajuste de LED</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_EnableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_DisableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas dos funciones simples son suficientes para usar el LED. </font><font style="vertical-align: inherit;">Podemos encender o apagar la luz. </font><font style="vertical-align: inherit;">Deje que la funci√≥n de llamada decida cu√°ndo hacerlo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podr√≠amos crear una tarea que monitoree peri√≥dicamente el voltaje de la bater√≠a y, en consecuencia, cambie el estado del LED, pero ser√≠a mejor interrogar el voltaje de la bater√≠a en nuestro ciclo principal, y luego decidir c√≥mo configurar el voltaje de la bater√≠a desde all√≠.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manifestaci√≥n</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint32_t</span> batteryLevel = Odroid_ReadBatteryLevel();<font></font>
<font></font>
<span class="hljs-keyword">if</span> (batteryLevel &lt; <span class="hljs-number">3600</span>)<font></font>
{<font></font>
	Odroid_EnableBatteryLight();<font></font>
}<font></font>
<span class="hljs-keyword">else</span><font></font>
{<font></font>
	Odroid_DisableBatteryLight();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Simplemente podemos solicitar el nivel de bater√≠a en el ciclo principal, y si el voltaje est√° por debajo del valor umbral, encienda el LED, lo que indica la necesidad de cargarlo. </font><font style="vertical-align: inherit;">Con base en los materiales estudiados, puedo decir que 3600 mV (3.6 V) es una buena se√±al de una baja carga de bater√≠as de iones de litio, pero las bater√≠as en s√≠ son complejas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referencias</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esquema de odroid go</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentaci√≥n ESP-IDF: ADC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caracter√≠sticas de la bater√≠a</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 6: sonido</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El paso final para obtener una interfaz completa para todo el hardware Odroid Go es escribir una capa de sonido. Una vez terminado esto, podemos comenzar a avanzar hacia una programaci√≥n m√°s general del juego, menos relacionada con la programaci√≥n para Odroid. Toda interacci√≥n con perif√©ricos se realizar√° a trav√©s de las funciones </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debido a mi falta de experiencia con la programaci√≥n de sonido y la falta de buena documentaci√≥n por parte de IDF, cuando trabaj√© en un proyecto, la implementaci√≥n del sonido tom√≥ m√°s tiempo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, no se requer√≠a tanto c√≥digo para reproducir el sonido. La mayor parte del tiempo se dedic√≥ a c√≥mo convertir los datos de audio al ESP32 deseado y c√≥mo configurar el controlador de audio ESP32 para que coincida con la configuraci√≥n del hardware.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conceptos b√°sicos de sonido digital</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El sonido digital consta de dos partes: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grabaci√≥n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reproducci√≥n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grabar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para grabar sonido en una computadora, primero debemos convertirlo desde el espacio de una se√±al continua (anal√≥gica) al espacio de una se√±al discreta (digital). </font><font style="vertical-align: inherit;">Esta tarea se logra utilizando un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convertidor anal√≥gico a digital (ADC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (del que hablamos cuando trabajamos con la cruz en la Parte 2). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El ADC recibe una </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muestra de la</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> onda entrante y digitaliza el valor, que luego se puede guardar en un archivo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jugar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se puede devolver un archivo de sonido digital del espacio digital al anal√≥gico utilizando un convertidor </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digital a anal√≥gico (DAC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">DAC puede reproducir valores solo en un cierto rango. </font><font style="vertical-align: inherit;">Por ejemplo, un DAC de 8 bits con una fuente de 3.3 V puede generar voltajes anal√≥gicos en el rango de 0 a 3.3 mV en pasos de 12.9 mV (3.3 V dividido por 256). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El DAC toma valores digitales y los convierte de nuevo en voltaje, que puede transmitirse a un amplificador, altavoz o cualquier otro dispositivo capaz de recibir una se√±al de audio anal√≥gica.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tasa de muestreo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al grabar sonido anal√≥gico a trav√©s del ADC, las muestras se toman a una frecuencia determinada, y cada muestra es una "instant√°nea" de la se√±al de sonido en un momento determinado. Este par√°metro se llama </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frecuencia de muestreo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y se mide en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hercios</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuanto mayor es la frecuencia de muestreo, m√°s exactamente recreamos las frecuencias de la se√±al original. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El teorema de Nyquist-Shannon (Kotelnikov)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> establece (en t√©rminos simples) que la frecuencia de muestreo debe ser el doble de la frecuencia de se√±al m√°s alta que queremos registrar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El o√≠do humano puede escuchar aproximadamente en el rango </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de 20 Hz a 20 kHz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por lo que la frecuencia de </font><strong><font style="vertical-align: inherit;">muestreo</font></strong><font style="vertical-align: inherit;"> de </font><strong><font style="vertical-align: inherit;">44,1 kHz se</font></strong><font style="vertical-align: inherit;"> usa con mayor frecuencia para recrear m√∫sica de alta calidad.</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que es un poco m√°s del doble de la frecuencia m√°xima que el o√≠do humano puede reconocer. Esto asegura que se recrear√° un conjunto completo de frecuencias de instrumentos y voz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, cada muestra ocupa espacio en el archivo, por lo que no podemos seleccionar la frecuencia de muestreo m√°xima. Sin embargo, si no toma muestras lo suficientemente r√°pido, puede perder informaci√≥n importante. La frecuencia de muestreo seleccionada debe depender de las frecuencias presentes en el sonido recreado. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La reproducci√≥n debe realizarse a la misma frecuencia de muestreo que la fuente; de ‚Äã‚Äãlo contrario, el sonido y su duraci√≥n ser√°n diferentes.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que se grabaron diez segundos de sonido a una frecuencia de muestreo de 16 kHz. </font><font style="vertical-align: inherit;">Si lo juegas con una frecuencia de 8 kHz, entonces su tono ser√° m√°s bajo y la duraci√≥n ser√° de veinte segundos. </font><font style="vertical-align: inherit;">Si lo toca con una frecuencia de muestreo de 32 kHz, el tono audible ser√° m√°s alto y el sonido en s√≠ mismo durar√° cinco segundos. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este video muestra la diferencia en las frecuencias de muestreo con ejemplos.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profundidad de bits</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La frecuencia de muestreo es solo la mitad de la ecuaci√≥n. El sonido tambi√©n tiene una </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">profundidad de bits</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , es decir, el n√∫mero de bits por muestra. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando el ADC captura una muestra de una se√±al de audio, debe convertir este valor anal√≥gico a digital, y el rango de valores capturados depende del n√∫mero de bits utilizados. 8 bits (256 valores), 16 bits (65,526 valores), 32 bits (4,294,967,296 valores), etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El n√∫mero de bits por muestra est√° relacionado con el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rango din√°mico del</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sonido, es decir. con las partes m√°s ruidosas y silenciosas. La profundidad de bits m√°s com√∫n para la m√∫sica es de 16 bits. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante la reproducci√≥n, es necesario proporcionar la misma profundidad de bits que la fuente; de ‚Äã‚Äãlo contrario, el sonido y su duraci√≥n cambiar√°n.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, tiene un archivo de audio con cuatro muestras almacenadas como 8 bits: [0x25, 0xAB, 0x34, 0x80]. </font><font style="vertical-align: inherit;">Si intenta reproducirlos como si fueran de 16 bits, obtendr√° solo dos muestras: [0x25AB, 0x3480]. </font><font style="vertical-align: inherit;">Esto no solo conducir√° a valores incorrectos de muestras de sonido, sino que tambi√©n reducir√° a la mitad el n√∫mero de muestras y, por lo tanto, la duraci√≥n del sonido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n es importante conocer el formato de las muestras. </font><font style="vertical-align: inherit;">8 bits sin signo, 8 bits sin signo, 16 bits sin signo, 16 bits sin signo, etc. </font><font style="vertical-align: inherit;">Por lo general, 8 bits no est√°n firmados y 16 bits est√°n firmados. </font><font style="vertical-align: inherit;">Si est√°n confundidos, el sonido estar√° muy distorsionado. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este video muestra la diferencia de profundidad de bits con ejemplos.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Archivos wav</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muy a menudo, los datos de audio sin procesar en una computadora se almacenan en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el formato WAV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que tiene un encabezado simple que describe el formato de sonido (frecuencia de muestreo, profundidad de bits, tama√±o, etc.), seguido de los datos de audio en s√≠. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El sonido no est√° comprimido en absoluto (a diferencia de los formatos como MP3), por lo que podemos reproducirlo f√°cilmente sin la necesidad de una biblioteca de c√≥decs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El principal problema con los archivos WAV es que, debido a la falta de compresi√≥n, pueden ser bastante grandes. El tama√±o del archivo est√° directamente relacionado con la duraci√≥n, la frecuencia de muestreo y la profundidad de bits. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tama√±o = Duraci√≥n (en segundos) x Velocidad de muestreo (muestras / s) x Profundidad de bits (bit / muestra)</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La frecuencia de muestreo afecta m√°s al tama√±o del archivo, por lo que la forma m√°s f√°cil de ahorrar espacio es seleccionar un valor suficientemente bajo. </font><font style="vertical-align: inherit;">Crearemos un sonido de la vieja escuela, por lo que una baja frecuencia de muestreo nos conviene.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I2S</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32 tiene perif√©ricos, por lo que es relativamente simple proporcionar una interfaz con equipo de audio: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inter-IC Sound (I2S)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El protocolo I2S es bastante simple y consta de solo tres se√±ales: una se√±al de reloj, una selecci√≥n de canales (izquierda o derecha) y tambi√©n la l√≠nea de datos en s√≠. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La frecuencia del reloj depende de la frecuencia de muestreo, la profundidad de bits y el n√∫mero de canales. Los ritmos se reemplazan por cada bit de datos, por lo tanto, para una reproducci√≥n de sonido adecuada, debe configurar la frecuencia del reloj en consecuencia. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frecuencia de reloj = Frecuencia de muestreo (muestras / s) x Profundidad de bits (bits / muestra) x N√∫mero de canales</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El controlador I2S del microcontrolador ESP32 tiene dos modos posibles: puede enviar datos a los contactos conectados a un receptor I2S externo, que puede decodificar el protocolo y transferir datos al amplificador, o puede transferir datos al DAC ESP32 interno que emite una se√±al anal√≥gica que puede transmitirse a amplificador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go no tiene ning√∫n decodificador I2S en el tablero, por lo que tendremos que usar el DAC ESP32 interno de 8 bits, es decir, debemos usar sonido de 8 bits. </font><font style="vertical-align: inherit;">El dispositivo tiene dos DAC, uno conectado a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y el otro a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El procedimiento se ve as√≠:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transferimos datos de audio al controlador I2S</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El controlador I2S env√≠a datos de audio a DAC interno de 8 bits</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se√±al anal√≥gica de salidas DAC internas</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La se√±al anal√≥gica se transmite al amplificador de sonido.</font></font></li>
<li>      </li>
<li>  </li>
</ol><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/d93/a8e/2d9d93a8ed6eceb35846c0f31e336ec9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si observamos el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">circuito de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> audio en </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">el circuito Odroid Go</font></a><font style="vertical-align: inherit;"> , veremos dos pines GPIO ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) conectados a las entradas del amplificador de sonido ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAM8304A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
tambi√©n </font><strong><font style="vertical-align: inherit;">est√°</font></strong><font style="vertical-align: inherit;"> conectado a la se√±al </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD del</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> amplificador, es decir, el contacto que enciende o apaga el amplificador (se√±al baja significa apagado). Las salidas del amplificador est√°n conectadas a un altavoz ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recuerde que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son salidas de DAC ESP32 de 8 bits, es decir, un DAC est√° conectado a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y el otro a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entradas diferenciales del</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> amplificador de sonido. Las entradas diferenciales se utilizan para reducir el ruido causado por </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la interferencia electromagn√©tica</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cualquier ruido presente en una se√±al tambi√©n estar√° presente en otra. Una se√±al se resta de otra, lo que elimina el ruido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si observa las </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especificaciones del amplificador de sonido</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tiene un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">circuito de aplicaciones t√≠picas</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que es la forma recomendada por el fabricante para utilizar el amplificador.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/044/d2a/323/044d2a323366c5ddb3c3b87f918bf5f9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recomienda conectar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a tierra, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a la se√±al de entrada y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a la se√±al de encendido / apagado. Si hay un ruido de 0.005 V, entonces </font><font style="vertical-align: inherit;">se leer√° </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- </font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0V + 0.005V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y con </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN + 0.005V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Las se√±ales de entrada deben sustraerse entre s√≠ y obtener el valor de se√±al verdadero ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sin ruido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, los dise√±adores de Odroid Go no utilizaron la configuraci√≥n recomendada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez m√°s, mirando el circuito Odroid Go, vemos que los dise√±adores conectaron la salida DAC a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y que la misma salida DAC est√° conectada a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ DAKOTA DEL SUR</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Esta es una se√±al de apagado con un nivel bajo activo, por lo que para que el amplificador funcione, debe configurar una se√±al alta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto significa que para usar el amplificador, no debemos usar el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como un DAC, sino como una salida GPIO con una se√±al siempre alta. Sin embargo, en este caso, una se√±al alta se establece en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lo cual no es recomendado por la especificaci√≥n del amplificador (debe estar conectado a tierra). Luego debemos usar el DAC conectado a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ya que nuestra salida I2S debe alimentarse a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto significa que no lograremos la reducci√≥n de ruido necesaria, ya que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no </font><strong><font style="vertical-align: inherit;">est√°</font></strong><font style="vertical-align: inherit;"> conectado a tierra. El ruido suave emana constantemente de los altavoces.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Necesitamos asegurar la configuraci√≥n correcta del controlador I2S, porque queremos usar solo el DAC conectado a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliz√°ramos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un DAC conectado a </font><strong><font style="vertical-align: inherit;">IO25</font></strong><font style="vertical-align: inherit;"> , </font><strong><font style="vertical-align: inherit;">apagar√≠a</font></strong><font style="vertical-align: inherit;"> constantemente la se√±al del amplificador y el sonido ser√≠a terrible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s de esta rareza, cuando se usa un DAC interno de 8 bits, el controlador I2S en el ESP32 requiere que se le transmitan muestras de 16 bits, pero solo env√≠a el byte alto al DAC de 8 bits. </font><font style="vertical-align: inherit;">Por lo tanto, necesitamos tomar nuestro sonido de 8 bits y pegarlo en un b√∫fer el doble de grande, mientras que el b√∫fer estar√° medio vac√≠o. </font><font style="vertical-align: inherit;">Luego lo pasamos al controlador I2S y le pasa al DAC el byte alto de cada muestra. </font><font style="vertical-align: inherit;">Desafortunadamente, esto significa que tenemos que "pagar" por 16 bits, pero solo podemos usar 8 bits.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multitarea</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desafortunadamente, el juego no puede funcionar en un n√∫cleo, como originalmente quer√≠a, porque parece haber un error en el controlador I2S. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El controlador I2S debe usar DMA (como el controlador SPI), es decir, podr√≠amos iniciar la transferencia de I2S y luego continuar nuestro trabajo mientras el controlador I2S transmite datos de audio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero en cambio, la CPU est√° bloqueada durante la duraci√≥n del sonido, lo que no es apto para el juego. Imagine que presiona el bot√≥n de salto, y luego el sprite del jugador detiene su movimiento durante 100 ms mientras se reproduce el sonido de salto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver este problema, podemos aprovechar el hecho de que hay dos n√∫cleos a bordo del ESP32. </font><font style="vertical-align: inherit;">Podemos crear una tarea (es decir, un hilo) en el segundo n√∫cleo, que se ocupar√° de la reproducci√≥n de sonido. </font><font style="vertical-align: inherit;">Gracias a esto, podemos transferir el puntero al b√∫fer de sonido desde la tarea principal del juego a la tarea de sonido, y la tarea de sonido inicia la transferencia de I2S y se bloquea durante la reproducci√≥n del sonido. </font><font style="vertical-align: inherit;">Pero la tarea principal en el primer n√∫cleo (con procesamiento y renderizado de entrada) continuar√° ejecut√°ndose sin bloqueo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializaci√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sabiendo esto, podemos iniciar correctamente el controlador I2S. </font><font style="vertical-align: inherit;">Para hacer esto, solo necesita unas pocas l√≠neas de c√≥digo, pero la dificultad es descubrir qu√© par√°metros necesita establecer para una reproducci√≥n de sonido adecuada.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> AUDIO_AMP_SD_PIN = GPIO_NUM_25;<font></font>
<font></font>
<span class="hljs-keyword">static</span> QueueHandle_t gQueue;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlayTask</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span>
</span>{
	<span class="hljs-keyword">for</span>(;;)<font></font>
	{<font></font>
		QueueData data;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (xQueueReceive(gQueue, &amp;data, <span class="hljs-number">10</span>))<font></font>
		{<font></font>
			<span class="hljs-keyword">size_t</span> bytesWritten;<font></font>
			i2s_write(I2S_NUM_0, data.buffer, data.length, &amp;bytesWritten, portMAX_DELAY);<font></font>
			i2s_zero_dma_buffer(I2S_NUM_0);<font></font>
		}<font></font>
<font></font>
		vTaskDelay(<span class="hljs-number">1</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeAudio</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-comment">// Configure the amplifier shutdown signal</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; AUDIO_AMP_SD_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
<font></font>
		gpio_set_level(AUDIO_AMP_SD_PIN, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure the I2S driver</span><font></font>
	{<font></font>
		<span class="hljs-keyword">i2s_config_t</span> i2sConfig= {};<font></font>
<font></font>
		i2sConfig.mode = I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN;<font></font>
		i2sConfig.sample_rate = <span class="hljs-number">5012</span>;<font></font>
		i2sConfig.bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT;<font></font>
		i2sConfig.communication_format = I2S_COMM_FORMAT_I2S_MSB;<font></font>
		i2sConfig.channel_format = I2S_CHANNEL_FMT_ONLY_LEFT;<font></font>
		i2sConfig.dma_buf_count = <span class="hljs-number">8</span>;<font></font>
		i2sConfig.dma_buf_len = <span class="hljs-number">64</span>;<font></font>
<font></font>
		ESP_ERROR_CHECK(i2s_driver_install(I2S_NUM_0, &amp;i2sConfig, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>));<font></font>
		ESP_ERROR_CHECK(i2s_set_dac_mode(I2S_DAC_CHANNEL_LEFT_EN));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Create task for playing sounds so that our main task isn't blocked</span><font></font>
	{<font></font>
		gQueue = xQueueCreate(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(QueueData));<font></font>
		assert(gQueue);<font></font>
<font></font>
		BaseType_t result = xTaskCreatePinnedToCore(&amp;PlayTask, <span class="hljs-string">"I2S Task"</span>, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>);<font></font>
		assert(result == pdPASS);<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, configuramos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (que est√° conectado a la se√±al de apagado del amplificador) como una salida para que pueda controlar el amplificador de sonido y aplicarle una se√±al alta para encender el amplificador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, configuramos e instalamos el controlador I2S. </font><font style="vertical-align: inherit;">Analizar√© cada parte de la configuraci√≥n l√≠nea por l√≠nea, porque cada una de las l√≠neas requiere explicaci√≥n:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modo</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">configuramos el controlador como maestro (control del bus), un transmisor (porque transferimos datos a los destinatarios) y lo configuramos para usar el DAC incorporado de 8 bits (porque la placa Odroid Go no tiene un DAC externo).</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tasa_muestra</font></font><ul>
<li>    5012,      ,   ,      .   ,      ,          .    -,           2500 .</li>
</ul></li>
<li>bits_per_sample<ul>
<li>  ,    ESP32  8-,   I2S ,      16    ,   8     .</li>
</ul></li>
<li>communication_format<ul>
<li>      ,   ,   -   ,   8-      16- .</li>
</ul></li>
<li>channel_format<ul>
<li> GPIO,    <strong>IN+</strong>   ‚Äî  <strong>IO26</strong>,       ¬´¬ª   I2S.  ,  I2S      ,      <strong>IO25</strong>,      ,          .</li>
</ul></li>
<li>dma_buf_count  dma_buf_len<ul>
<li>  DMA-   ( )  ,        ,   ,        IDF.       ,     .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego creamos una cola: esta es la forma en que FreeRTOS env√≠a datos entre tareas. Ponemos los datos en la cola de una tarea y los extraemos de la cola de otra tarea. Cree una estructura llamada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que combine el puntero al b√∫fer de sonido y la longitud del b√∫fer en una sola estructura que se puede poner en cola. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, cree una tarea que se ejecute en el segundo n√∫cleo. Lo conectamos a la funci√≥n </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que realiza la reproducci√≥n de sonido. La tarea en s√≠ es un bucle sin fin que verifica constantemente para ver si hay datos en la cola. Si es as√≠, los env√≠a al controlador I2S para que puedan reproducirse. Bloquear√° la llamada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i2s_write</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y esto nos conviene, porque la tarea se realiza en un n√∫cleo separado del hilo principal del juego. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se requiere una llamada a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i2s_zero_dma_buffer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que despu√©s de que se complete la reproducci√≥n no queden sonidos de los altavoces. </font><font style="vertical-align: inherit;">No s√© si esto es un error del controlador I2S o el comportamiento esperado, pero sin √©l, una vez que el b√∫fer de sonido ha terminado de reproducirse, el altavoz emite una se√±al de basura.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reproducir sonido</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_PlayAudio</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span>* buffer, <span class="hljs-keyword">size_t</span> length)</span>
</span>{<font></font>
	QueueData data = {};<font></font>
<font></font>
	data.buffer = buffer;<font></font>
	data.length = length;<font></font>
<font></font>
	xQueueSendToBack(gQueue, &amp;data, portMAX_DELAY);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debido al hecho de que toda la configuraci√≥n ya se ha completado, la llamada a la funci√≥n de reproducci√≥n del b√∫fer de sonido en s√≠ es extremadamente simple, porque el trabajo principal se realiza en otra tarea. </font><font style="vertical-align: inherit;">Ponemos el puntero en el b√∫fer y la longitud del b√∫fer en la estructura </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y luego lo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">colocamos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la cola utilizada por la funci√≥n </font><strong><font style="vertical-align: inherit;">PlayTask</font></strong><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debido a este patr√≥n de operaci√≥n, un b√∫fer de sonido debe completar la reproducci√≥n antes de que pueda iniciar el segundo b√∫fer. </font><font style="vertical-align: inherit;">Por lo tanto, si se produce un salto y un disparo simult√°neamente, el primer sonido se reproducir√° antes que el segundo, y no simult√°neamente con √©l. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo m√°s probable es que en el futuro mezcle diferentes sonidos de cuadro en el b√∫fer de sonido que se transmite al controlador I2S. </font><font style="vertical-align: inherit;">Esto te permitir√° reproducir m√∫ltiples sonidos simult√°neamente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manifestaci√≥n</font></font></h2><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generaremos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
nuestros propios efectos de sonido usando </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">jsfxr</font></a><font style="vertical-align: inherit;"> , una herramienta dise√±ada espec√≠ficamente para generar el tipo de sonidos de juego que necesitamos. </font><font style="vertical-align: inherit;">Podemos establecer directamente la frecuencia de muestreo y la profundidad de bits, y luego generar el archivo WAV. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cre√© un simple efecto de sonido de salto que se asemeja al sonido del salto de Mario. </font><font style="vertical-align: inherit;">Tiene una frecuencia de muestreo de 5012 (como la configuramos durante la inicializaci√≥n) y una profundidad de 8 bits (porque el DAC es de 8 bits).</font></font><br>
<br>
<div class="oembed"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://austinmorlan.com/posts/embedded_game_programming_6/media/jump.wav</font></font></a></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En lugar de analizar el archivo WAV directamente en el c√≥digo, haremos algo similar a lo que hicimos para cargar el sprite en la demostraci√≥n de la Parte 4: eliminaremos el encabezado WAV del archivo usando el editor hexadecimal. Gracias a esto, el archivo le√≠do desde la tarjeta SD ser√° solo informaci√≥n en bruto. Adem√°s, no leeremos la duraci√≥n del sonido, lo escribiremos en el c√≥digo. En el futuro, cargaremos recursos de sonido de manera diferente, pero esto es suficiente para la demostraci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El archivo sin formato se puede descargar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Load sound effect</span>
<span class="hljs-keyword">uint16_t</span>* soundBuffer;
<span class="hljs-keyword">int</span> soundEffectLength = <span class="hljs-number">1441</span>;<font></font>
{<font></font>
	FILE* soundFile = fopen(<span class="hljs-string">"/sdcard/jump"</span>, <span class="hljs-string">"r"</span>);<font></font>
	assert(soundFile);<font></font>
<font></font>
	<span class="hljs-keyword">uint8_t</span>* soundEffect = <span class="hljs-built_in">malloc</span>(soundEffectLength);<font></font>
	assert(soundEffect);<font></font>
<font></font>
	soundBuffer = <span class="hljs-built_in">malloc</span>(soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	assert(soundBuffer);<font></font>
<font></font>
	fread(soundEffect, soundEffectLength, <span class="hljs-number">1</span>, soundFile);<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; soundEffectLength; ++i)<font></font>
    {<font></font>
        <span class="hljs-comment">// 16 bits required but only MSB is actually sent to the DAC</span>
        soundBuffer[i] = (soundEffect[i] &lt;&lt; <span class="hljs-number">8u</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cargamos los</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
datos de 8 bits en el b√∫fer </font><strong><font style="vertical-align: inherit;">soundEffect de</font></strong><font style="vertical-align: inherit;"> 8 bits </font><font style="vertical-align: inherit;">, y luego copiamos estos datos en el b√∫fer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soundBuffer de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16 bits </font><font style="vertical-align: inherit;">, donde los datos se almacenar√°n en los ocho bits m√°s altos. </font><font style="vertical-align: inherit;">Repito: esto es necesario debido a las caracter√≠sticas de la implementaci√≥n de IDF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de haber creado un b√∫fer de 16 bits, podemos reproducir el sonido de un clic de un bot√≥n. </font><font style="vertical-align: inherit;">Ser√≠a l√≥gico usar el bot√≥n de volumen para esto.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> lastState = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (;;)<font></font>
{<font></font>
	[...]<font></font>
<font></font>
	<span class="hljs-keyword">int</span> thisState = input.volume;<font></font>
<font></font>
	<span class="hljs-keyword">if</span> ((thisState == <span class="hljs-number">1</span>) &amp;&amp; (thisState != lastState))<font></font>
	{<font></font>
		Odroid_PlayAudio(soundBuffer, soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	}<font></font>
<font></font>
	lastState = thisState;<font></font>
<font></font>
	[...]<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Monitoreamos el estado del bot√≥n para que accidentalmente, con un clic del bot√≥n, no llame accidentalmente a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid_PlayAudio</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> varias veces.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Su navegador no admite video HTML5.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_6/media/demo.mp4" type="video/mp4"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo el c√≥digo fuente est√° </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referencias</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esquema de odroid go</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hoja de datos del amplificador de audio</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentaci√≥n ESP-IDF: DAC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentaci√≥n ESP-IDF: I2S</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formato de archivo WAVE</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video: Explicaci√≥n de la profundidad de bits</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video: Explicaci√≥n de la frecuencia de muestreo</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es503854/index.html">Usa SIL al m√°ximo</a></li>
<li><a href="../es503858/index.html">El libro "Terraform: infraestructura a nivel de c√≥digo"</a></li>
<li><a href="../es503860/index.html">Configuraci√≥n del entorno de red neuronal M√°scara R-CNN</a></li>
<li><a href="../es503864/index.html">Organizaci√≥n de sabores en Flutter</a></li>
<li><a href="../es503866/index.html">Desarrollo de la hoja de ruta publicada Zextras Suite para 2020</a></li>
<li><a href="../es503880/index.html">C√≥mo aprend√≠ a no preocuparme y amaba la visi√≥n artificial</a></li>
<li><a href="../es503884/index.html">C√≥mo aprender a trabajar de forma asincr√≥nica</a></li>
<li><a href="../es503888/index.html">Algoritmo AdaBoost</a></li>
<li><a href="../es503890/index.html">La historia de c√≥mo configur√© Azure AD B2C en React and React Native Part 1 (Tutorial)</a></li>
<li><a href="../es503892/index.html">Mitap: Cuarentena, vete</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>