<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📴 🐆 😍 Pixockets: Wie wir unsere eigene Netzwerkbibliothek für den Spieleserver geschrieben haben 🐤 🧑🏽‍🤝‍🧑🏽 👨‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Connected Stanislav Yablonsky, leitender Serverentwickler von Pixonic. 
 
 Als ich zu Pixonic kam, waren unsere Spieleserver Anwendungen, die a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pixockets: Wie wir unsere eigene Netzwerkbibliothek für den Spieleserver geschrieben haben</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/499642/"><img src="https://habrastorage.org/webt/1m/i0/kx/1mi0kx5zzmixsjdadghss9rpeic.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hallo! Connected Stanislav Yablonsky, leitender Serverentwickler von Pixonic. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als ich zu Pixonic kam, waren unsere Spieleserver Anwendungen, die auf dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Photon Realtime SDK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> basierten </font><font style="vertical-align: inherit;">: ein multifunktionales, aber sehr schweres Framework. Diese Lösung schien die Arbeit mit dem Server zu vereinfachen. So war es - bis zu einem gewissen Punkt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Photon Realtime hat uns an sich selbst gebunden, indem wir damit Daten zwischen Playern und dem Server austauschen mussten - und es auch an Windows gebunden, da es nur darauf funktionieren kann. Dies führte zu Einschränkungen sowohl zur Laufzeit (Laufzeit): Es war unmöglich, viele wichtige Einstellungen der virtuellen .NET-Maschine und des Betriebssystems zu ändern. Wir sind es gewohnt, mit Linux-Servern zu arbeiten, nicht mit Windows. Außerdem kosten sie uns weniger. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Außerdem hat die Verwendung von Photon die Leistung sowohl auf dem Server als auch auf dem Client beeinträchtigt, und bei der Profilerstellung hat sich eine anständige Belastung des Garbage Collectors und eine große Menge an Boxen / Unboxing gebildet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz gesagt, die Lösung mit Photon Realtime war für uns alles andere als optimal, und lange Zeit war es notwendig, etwas damit zu tun - aber es gab immer dringendere Aufgaben, und die Hände erreichten nicht die Lösung von Problemen mit dem Server. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da es für mich interessant war, nicht nur das Problem zu lösen, sondern auch das Netzwerk besser zu verstehen, habe ich beschlossen, die Initiative selbst zu ergreifen und zu versuchen, selbst eine Bibliothek zu schreiben. </font><font style="vertical-align: inherit;">Aber Sie verstehen, zu Hause - zu Hause, bei der Arbeit - bei der Arbeit, daher war die Zeit für die Entwicklung der Bibliothek nur im Transport. </font><font style="vertical-align: inherit;">Dies hinderte die Idee jedoch nicht daran, Wirklichkeit zu werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was dabei herauskam - lesen Sie weiter.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliotheksideologie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da wir Online-Spiele entwickeln, ist es für uns sehr wichtig, ohne Pausen zu arbeiten. Daher sind geringe Gemeinkosten zur Hauptanforderung für die Bibliothek geworden. Für uns ist dies vor allem eine geringe Belastung des Garbage Collectors. Um dies zu erreichen, habe ich versucht, Zuordnungen zu vermeiden, und in Fällen, in denen es schwierig war oder überhaupt nicht funktioniert hat, haben wir Pools erstellt (für Byte-Puffer, Verbindungsstatus, Header usw.).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Vereinfachung und Bequemlichkeit der Unterstützung und Montage haben wir begonnen, nur C # - und Systembuchsen zu verwenden. Außerdem war es wichtig, in das Zeitbudget pro Frame zu passen, da die Daten vom Server pünktlich ankommen sollten. Daher habe ich versucht, die Ausführungszeit zu verkürzen, auch auf Kosten einer Nichtoptimalität: Das heißt, an einigen Stellen hat es sich gelohnt, die schnellen und teilweise komplexeren Algorithmen und Datenstrukturen durch einfachere und vorhersehbarere zu ersetzen. Zum Beispiel haben wir keine sperrenfreien Warteschlangen verwendet, da sie den Garbage Collector belasten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typischerweise werden unsere Daten für Multiplayer-Shooter über UDP gesendet. Hinzu kam die Fragmentierung und Zusammenstellung von Paketen zum Senden von Daten, die größer als die Rahmengröße sind, sowie eine zuverlässige Zustellung aufgrund der Weiterleitung und des Verbindungsaufbaus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der UDP-Frame in unserer Bibliothek ist standardmäßig auf 1200 Byte eingestellt. </font><font style="vertical-align: inherit;">Pakete dieser Größe sollten in modernen Netzwerken mit einem relativ geringen Fragmentierungsrisiko übertragen werden, da die MTU in den meisten modernen Netzwerken höher als dieser Wert ist. </font><font style="vertical-align: inherit;">Gleichzeitig reicht dieser Betrag normalerweise aus, um den Änderungen zu entsprechen, die nach dem nächsten Tick (Statusaktualisierung) im Spiel an den Spieler gesendet werden müssen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Architektur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserer Bibliothek verwenden wir einen zweischichtigen Socket:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Schicht ist für die Arbeit mit Systemaufrufen verantwortlich und bietet eine bequemere API für die nächste Ebene.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite Schicht ist die direkte Arbeit mit der Sitzung, Fragmentierung / Zusammenstellung von Paketen, deren Weiterleitung usw.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/r_/na/zq/r_nazqva4twkyhnouvkr6dhowek.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Klasse für die Arbeit mit Verbindungen ist wiederum in zwei Ebenen unterteilt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die untere Ebene (SockBase) ist für das Senden und Empfangen von Daten über UDP verantwortlich. </font><font style="vertical-align: inherit;">Es ist ein dünner Wrapper über einem Socket-Systemobjekt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Top Level (SmartSock) bietet zusätzliche Funktionen über UDP. </font><font style="vertical-align: inherit;">Pakete schneiden und kleben, nicht erreichte Daten weiterleiten, Duplikate ablehnen - all dies liegt in seinem Verantwortungsbereich.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die untere Ebene ist in zwei Klassen unterteilt: BareSock und ThreadSock.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BareSock arbeitet in demselben Thread, aus dem der Anruf stammt, und sendet und empfängt Daten im nicht blockierenden Modus. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadSock stellt Pakete in Warteschlangen und erstellt somit separate Threads zum Senden und Empfangen von Daten. </font><font style="vertical-align: inherit;">Beim Zugriff gibt es nur einen Vorgang: Hinzufügen oder Entfernen von Daten zur Warteschlange.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BareSock wird häufig verwendet, um mit dem Client ThreadSock - mit dem Server - zu arbeiten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merkmale der Arbeit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe auch zwei Arten von Low-Level-Sockets geschrieben:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste ist synchroner Single-Threaded. </font><font style="vertical-align: inherit;">Darin erhalten wir den minimalen Overhead für Speicher und Prozessor, aber gleichzeitig treten Systemaufrufe direkt beim Zugriff auf den Socket auf. </font><font style="vertical-align: inherit;">Dies minimiert im Allgemeinen den Overhead (es müssen keine Warteschlangen und zusätzlichen Puffer verwendet werden), aber der Anruf selbst kann länger dauern als das Entfernen eines Elements aus der Warteschlange.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite ist asynchron mit separaten Threads zum Lesen und Schreiben. </font><font style="vertical-align: inherit;">In diesem Fall erhalten wir zusätzlichen Overhead für die Warteschlange, die Synchronisation und die Sende- / Empfangszeit (innerhalb weniger Millisekunden), da zum Zeitpunkt des Zugriffs auf den Socket der Lese- oder Schreibthread angehalten wird.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben auch versucht, SocketAsyncEventArgs zu verwenden - vielleicht die fortschrittlichste Netzwerk-API in .NET, die mir bekannt ist. Es stellte sich jedoch heraus, dass es für UDP wahrscheinlich nicht funktioniert: Der TCP-Stack funktioniert einwandfrei, aber UDP gibt Fehler beim Abrufen seltsam abgeschnittener Frames und sogar beim Absturz in .NET aus - als ob der Speicher im nativen Teil der virtuellen Maschine beschädigt wäre. Ich habe keine Beispiele für die Funktionsweise eines solchen Systems gefunden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres wichtiges Merkmal unserer Bibliothek ist der reduzierte Datenverlust. Wir hatten den Eindruck, dass viele Bibliotheken alte Datenpakete verwerfen, um Duplikate zu entfernen, wie wir später aus eigener Erfahrung gesehen haben. Natürlich ist eine solche Implementierung viel einfacher, da in diesem Fall ein Zähler mit der Nummer des zuletzt eingetroffenen Frames ausreicht, aber es hat uns nicht sehr gut gefallen. Daher verwendet Pixockets einen Umlaufpuffer aus den Nummern der letzten Frames, um Duplikate herauszufiltern: Neu eingetroffene Nummern werden anstelle der alten überschrieben, und Duplikate werden unter den zuletzt empfangenen Frames gesucht.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2y/cb/di/2ycbdijeldlgssku0tq5p3e5dmc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn also ein Paket vor dem aktuellen Frame gesendet wurde, aber danach kam, erreicht es immer noch das Ziel. </font><font style="vertical-align: inherit;">Dies kann beispielsweise bei der Positionsinterpolation sehr hilfreich sein. </font><font style="vertical-align: inherit;">In diesem Fall haben wir eine vollständigere Geschichte.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenpaketstruktur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Daten in der Bibliothek werden wie folgt übertragen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hw/gc/1j/hwgc1jlbxz5s4ng9h1vrenehqui.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Anfang des Pakets befindet sich der Header:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es beginnt mit der Größe des Pakets, das wiederum auf 64 Kilobyte begrenzt ist. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf die Größe folgt ein Byte mit Flags. </font><font style="vertical-align: inherit;">Die Interpretation des restlichen Titels hängt von ihrer Verfügbarkeit ab.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiter ist die Kennung für die Sitzung oder Verbindung. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit den entsprechenden Flags erhalten wir dann:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Flag mit der Paketnummer gesetzt ist, wird die Paketnummer nach der Sitzungskennung übertragen. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ihm folgen - auch im Fall des gesetzten Flags - die Anzahl der bestätigten Pakete und deren Nummern.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende des Headers finden Sie Informationen zum Fragment: </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kennung der Fragmentsequenz, die notwendig ist, um Fragmente verschiedener Nachrichten zu unterscheiden; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sequenznummer des Fragments;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamtzahl der Fragmente in der Nachricht. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für Informationen zum Fragment muss auch das entsprechende Flag gesetzt werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bibliothek ist geschrieben. </font><font style="vertical-align: inherit;">Was weiter?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um genauere Informationen zur synchronen Verbindung zu erhalten, haben wir später eine explizite Verbindung organisiert. Dies hat uns geholfen, Situationen klar zu verstehen, in denen eine Seite denkt, dass die Verbindung hergestellt und nicht unterbrochen wurde, und die andere Seite, dass sie unterbrochen wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der ersten Version von Pixockets war dies nicht der Fall: Der Client musste die Connect-Methode (Host, Port) nicht aufrufen. Er begann lediglich, Daten an eine bekannte Adresse und einen bekannten Port zu senden. Dann rief der Server die Listen-Methode (Port) auf und begann, Daten von einer bestimmten Adresse zu empfangen. Die Sitzungsdaten wurden beim Empfang / Senden des Pakets initialisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um nun eine Verbindung herzustellen, ist ein „Handshake“ erforderlich geworden - der Austausch speziell gebildeter Pakete - und der Client muss Connect aufrufen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus hat einer meiner Kollegen die Bibliothek gespalten, der Netzwerksicherheit mehr Aufmerksamkeit geschenkt und einige Funktionen hinzugefügt, z. B. die Möglichkeit, die Verbindung direkt innerhalb des Sockets wiederherzustellen: Wenn Sie beispielsweise zwischen Wi-Fi und 4G wechseln, wird die Verbindung jetzt automatisch wiederhergestellt. </font><font style="vertical-align: inherit;">Aber darüber werden wir später sprechen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich haben wir Unit-Tests für die Bibliothek geschrieben: Sie überprüfen alle wichtigen Möglichkeiten zum Herstellen einer Verbindung, zum Senden und Empfangen von Daten, zum Fragmentieren und Zusammenstellen von Paketen sowie zu verschiedenen Anomalien beim Senden und Empfangen von Daten - wie Duplizieren, Verlust, Nichtübereinstimmung in der Reihenfolge des Sendens und Empfangens. Für die anfängliche Leistungsprüfung habe ich spezielle Testanwendungen für Integrationstests geschrieben: einen Ping-Client, einen Ping-Server und eine Anwendung, die die Position, Farbe und Anzahl der farbigen Kreise auf dem Bildschirm über das Netzwerk synchronisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem die Testanwendungen die Effizienz unserer Bibliothek bewiesen hatten, haben wir begonnen, sie mit anderen Bibliotheken zu vergleichen: mit unserer alten Photon Realtime und mit der UDP-Bibliothek LiteNetLib 0.7.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eine vereinfachte Version eines Spielservers getestet, der einfach Eingaben von Spielern sammelt und das „geklebte“ Ergebnis zurücksendet. Wir haben 500 Spieler in Räumen mit 6 Personen aufgenommen, die Bildwiederholfrequenz beträgt 30 Mal pro Sekunde. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/e-/1e/fy/e-1efyiufgmkgsifktigenhbil0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Belastung des Garbage Collector- und Prozessorverbrauchs war bei Pixockets geringer, ebenso wie der Prozentsatz fehlender Pakete - anscheinend aufgrund der Tatsache, dass wir im Gegensatz zu anderen UDP-Versionen späte Pakete nicht ignorieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir die Bestätigung des Vorteils unserer Lösung in synthetischen Tests erhalten hatten, bestand der nächste Schritt darin, die Bibliothek in einem realen Projekt auszuführen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu diesem Zeitpunkt wurden in dem von uns ausgewählten Projekt Clients und Spieleserver über Photon Server synchronisiert. </font><font style="vertical-align: inherit;">Ich habe dem Client und dem Server die Unterstützung von Pixockets hinzugefügt, um die Auswahl des Protokolls vom Matchmaking-Server aus zu steuern, an den die Clients eine Anfrage zum Betreten des Spiels senden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Zeit lang spielten Clients gleichzeitig auf beiden Protokollen, und zu diesem Zeitpunkt sammelten wir Statistiken darüber, wie es ihnen ging. </font><font style="vertical-align: inherit;">Am Ende der Statistiksammlung stellte sich heraus, dass sich die Ergebnisse nicht von synthetischen Tests unterscheiden: Die Belastung des Garbage Collectors und des Prozessors hat abgenommen, auch der Paketverlust. </font><font style="vertical-align: inherit;">Gleichzeitig wurde der Ping etwas niedriger. </font><font style="vertical-align: inherit;">Daher wurde die nächste Version des Spiels bereits vollständig auf Pixockets veröffentlicht, ohne das Photon Realtime SDK zu verwenden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hr/gz/gs/hrgzgsslampwgbbr_u2puvpbhmq.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zukunftspläne</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt möchten wir die folgenden Funktionen in der Bibliothek implementieren:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vereinfachte Verbindung: Jetzt funktioniert sie nicht mehr optimal. Nach dem Aufruf von Connect auf dem Client müssen Sie Read aufrufen, bis sich der Verbindungsstatus ändert.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explizites Herunterfahren: Im Moment erfolgt das Herunterfahren auf der anderen Seite nur über den Timer.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingebaute Pings zur Aufrechterhaltung der Konnektivität;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatische Ermittlung der optimalen Bildgröße (jetzt wird nur noch eine Konstante verwendet).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können Pixockets </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">unter der Repository-Adresse</font></a><font style="vertical-align: inherit;"> anzeigen und an der Weiterentwicklung teilnehmen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499628/index.html">Entwicklungsinterviews: Freunde auswählen</a></li>
<li><a href="../de499630/index.html">Flattern. Frühjahrsupdate 2020</a></li>
<li><a href="../de499632/index.html">Verbessern der Audioqualität von Google Duo mit WaveNetEQ</a></li>
<li><a href="../de499634/index.html">Erweitertes TypeScript</a></li>
<li><a href="../de499636/index.html">Reagiere Native für die Kleinen. Mobile Entwicklungserfahrung</a></li>
<li><a href="../de499644/index.html">Robotererstellung (RPA) mit AutoTest-Tools</a></li>
<li><a href="../de499646/index.html">5 Regeln für die Integration von UX in Agile und Scrum</a></li>
<li><a href="../de499648/index.html">„Ein Spieledesigner ist immer ein Spieler“: Was macht ein Spezialist, welche Fähigkeiten sind wichtig?</a></li>
<li><a href="../de499652/index.html">Gibt es Leben in der Entwicklung nach dem Dekret</a></li>
<li><a href="../de499654/index.html">Wie implementiere ich CRM auf einem Remote-Standort und gewinne?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>