<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì¥ üêÜ üòç Pixockets: Wie wir unsere eigene Netzwerkbibliothek f√ºr den Spieleserver geschrieben haben üê§ üßëüèΩ‚Äçü§ù‚ÄçüßëüèΩ üë®‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Connected Stanislav Yablonsky, leitender Serverentwickler von Pixonic. 
 
 Als ich zu Pixonic kam, waren unsere Spieleserver Anwendungen, die a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pixockets: Wie wir unsere eigene Netzwerkbibliothek f√ºr den Spieleserver geschrieben haben</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/499642/"><img src="https://habrastorage.org/webt/1m/i0/kx/1mi0kx5zzmixsjdadghss9rpeic.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hallo! Connected Stanislav Yablonsky, leitender Serverentwickler von Pixonic. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als ich zu Pixonic kam, waren unsere Spieleserver Anwendungen, die auf dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Photon Realtime SDK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> basierten </font><font style="vertical-align: inherit;">: ein multifunktionales, aber sehr schweres Framework. Diese L√∂sung schien die Arbeit mit dem Server zu vereinfachen. So war es - bis zu einem gewissen Punkt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Photon Realtime hat uns an sich selbst gebunden, indem wir damit Daten zwischen Playern und dem Server austauschen mussten - und es auch an Windows gebunden, da es nur darauf funktionieren kann. Dies f√ºhrte zu Einschr√§nkungen sowohl zur Laufzeit (Laufzeit): Es war unm√∂glich, viele wichtige Einstellungen der virtuellen .NET-Maschine und des Betriebssystems zu √§ndern. Wir sind es gewohnt, mit Linux-Servern zu arbeiten, nicht mit Windows. Au√üerdem kosten sie uns weniger. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au√üerdem hat die Verwendung von Photon die Leistung sowohl auf dem Server als auch auf dem Client beeintr√§chtigt, und bei der Profilerstellung hat sich eine anst√§ndige Belastung des Garbage Collectors und eine gro√üe Menge an Boxen / Unboxing gebildet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz gesagt, die L√∂sung mit Photon Realtime war f√ºr uns alles andere als optimal, und lange Zeit war es notwendig, etwas damit zu tun - aber es gab immer dringendere Aufgaben, und die H√§nde erreichten nicht die L√∂sung von Problemen mit dem Server. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da es f√ºr mich interessant war, nicht nur das Problem zu l√∂sen, sondern auch das Netzwerk besser zu verstehen, habe ich beschlossen, die Initiative selbst zu ergreifen und zu versuchen, selbst eine Bibliothek zu schreiben. </font><font style="vertical-align: inherit;">Aber Sie verstehen, zu Hause - zu Hause, bei der Arbeit - bei der Arbeit, daher war die Zeit f√ºr die Entwicklung der Bibliothek nur im Transport. </font><font style="vertical-align: inherit;">Dies hinderte die Idee jedoch nicht daran, Wirklichkeit zu werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was dabei herauskam - lesen Sie weiter.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliotheksideologie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da wir Online-Spiele entwickeln, ist es f√ºr uns sehr wichtig, ohne Pausen zu arbeiten. Daher sind geringe Gemeinkosten zur Hauptanforderung f√ºr die Bibliothek geworden. F√ºr uns ist dies vor allem eine geringe Belastung des Garbage Collectors. Um dies zu erreichen, habe ich versucht, Zuordnungen zu vermeiden, und in F√§llen, in denen es schwierig war oder √ºberhaupt nicht funktioniert hat, haben wir Pools erstellt (f√ºr Byte-Puffer, Verbindungsstatus, Header usw.).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Vereinfachung und Bequemlichkeit der Unterst√ºtzung und Montage haben wir begonnen, nur C # - und Systembuchsen zu verwenden. Au√üerdem war es wichtig, in das Zeitbudget pro Frame zu passen, da die Daten vom Server p√ºnktlich ankommen sollten. Daher habe ich versucht, die Ausf√ºhrungszeit zu verk√ºrzen, auch auf Kosten einer Nichtoptimalit√§t: Das hei√üt, an einigen Stellen hat es sich gelohnt, die schnellen und teilweise komplexeren Algorithmen und Datenstrukturen durch einfachere und vorhersehbarere zu ersetzen. Zum Beispiel haben wir keine sperrenfreien Warteschlangen verwendet, da sie den Garbage Collector belasten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typischerweise werden unsere Daten f√ºr Multiplayer-Shooter √ºber UDP gesendet. Hinzu kam die Fragmentierung und Zusammenstellung von Paketen zum Senden von Daten, die gr√∂√üer als die Rahmengr√∂√üe sind, sowie eine zuverl√§ssige Zustellung aufgrund der Weiterleitung und des Verbindungsaufbaus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der UDP-Frame in unserer Bibliothek ist standardm√§√üig auf 1200 Byte eingestellt. </font><font style="vertical-align: inherit;">Pakete dieser Gr√∂√üe sollten in modernen Netzwerken mit einem relativ geringen Fragmentierungsrisiko √ºbertragen werden, da die MTU in den meisten modernen Netzwerken h√∂her als dieser Wert ist. </font><font style="vertical-align: inherit;">Gleichzeitig reicht dieser Betrag normalerweise aus, um den √Ñnderungen zu entsprechen, die nach dem n√§chsten Tick (Statusaktualisierung) im Spiel an den Spieler gesendet werden m√ºssen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Architektur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserer Bibliothek verwenden wir einen zweischichtigen Socket:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Schicht ist f√ºr die Arbeit mit Systemaufrufen verantwortlich und bietet eine bequemere API f√ºr die n√§chste Ebene.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite Schicht ist die direkte Arbeit mit der Sitzung, Fragmentierung / Zusammenstellung von Paketen, deren Weiterleitung usw.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/r_/na/zq/r_nazqva4twkyhnouvkr6dhowek.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Klasse f√ºr die Arbeit mit Verbindungen ist wiederum in zwei Ebenen unterteilt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die untere Ebene (SockBase) ist f√ºr das Senden und Empfangen von Daten √ºber UDP verantwortlich. </font><font style="vertical-align: inherit;">Es ist ein d√ºnner Wrapper √ºber einem Socket-Systemobjekt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Top Level (SmartSock) bietet zus√§tzliche Funktionen √ºber UDP. </font><font style="vertical-align: inherit;">Pakete schneiden und kleben, nicht erreichte Daten weiterleiten, Duplikate ablehnen - all dies liegt in seinem Verantwortungsbereich.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die untere Ebene ist in zwei Klassen unterteilt: BareSock und ThreadSock.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BareSock arbeitet in demselben Thread, aus dem der Anruf stammt, und sendet und empf√§ngt Daten im nicht blockierenden Modus. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadSock stellt Pakete in Warteschlangen und erstellt somit separate Threads zum Senden und Empfangen von Daten. </font><font style="vertical-align: inherit;">Beim Zugriff gibt es nur einen Vorgang: Hinzuf√ºgen oder Entfernen von Daten zur Warteschlange.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BareSock wird h√§ufig verwendet, um mit dem Client ThreadSock - mit dem Server - zu arbeiten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merkmale der Arbeit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe auch zwei Arten von Low-Level-Sockets geschrieben:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste ist synchroner Single-Threaded. </font><font style="vertical-align: inherit;">Darin erhalten wir den minimalen Overhead f√ºr Speicher und Prozessor, aber gleichzeitig treten Systemaufrufe direkt beim Zugriff auf den Socket auf. </font><font style="vertical-align: inherit;">Dies minimiert im Allgemeinen den Overhead (es m√ºssen keine Warteschlangen und zus√§tzlichen Puffer verwendet werden), aber der Anruf selbst kann l√§nger dauern als das Entfernen eines Elements aus der Warteschlange.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite ist asynchron mit separaten Threads zum Lesen und Schreiben. </font><font style="vertical-align: inherit;">In diesem Fall erhalten wir zus√§tzlichen Overhead f√ºr die Warteschlange, die Synchronisation und die Sende- / Empfangszeit (innerhalb weniger Millisekunden), da zum Zeitpunkt des Zugriffs auf den Socket der Lese- oder Schreibthread angehalten wird.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben auch versucht, SocketAsyncEventArgs zu verwenden - vielleicht die fortschrittlichste Netzwerk-API in .NET, die mir bekannt ist. Es stellte sich jedoch heraus, dass es f√ºr UDP wahrscheinlich nicht funktioniert: Der TCP-Stack funktioniert einwandfrei, aber UDP gibt Fehler beim Abrufen seltsam abgeschnittener Frames und sogar beim Absturz in .NET aus - als ob der Speicher im nativen Teil der virtuellen Maschine besch√§digt w√§re. Ich habe keine Beispiele f√ºr die Funktionsweise eines solchen Systems gefunden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres wichtiges Merkmal unserer Bibliothek ist der reduzierte Datenverlust. Wir hatten den Eindruck, dass viele Bibliotheken alte Datenpakete verwerfen, um Duplikate zu entfernen, wie wir sp√§ter aus eigener Erfahrung gesehen haben. Nat√ºrlich ist eine solche Implementierung viel einfacher, da in diesem Fall ein Z√§hler mit der Nummer des zuletzt eingetroffenen Frames ausreicht, aber es hat uns nicht sehr gut gefallen. Daher verwendet Pixockets einen Umlaufpuffer aus den Nummern der letzten Frames, um Duplikate herauszufiltern: Neu eingetroffene Nummern werden anstelle der alten √ºberschrieben, und Duplikate werden unter den zuletzt empfangenen Frames gesucht.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2y/cb/di/2ycbdijeldlgssku0tq5p3e5dmc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn also ein Paket vor dem aktuellen Frame gesendet wurde, aber danach kam, erreicht es immer noch das Ziel. </font><font style="vertical-align: inherit;">Dies kann beispielsweise bei der Positionsinterpolation sehr hilfreich sein. </font><font style="vertical-align: inherit;">In diesem Fall haben wir eine vollst√§ndigere Geschichte.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenpaketstruktur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Daten in der Bibliothek werden wie folgt √ºbertragen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hw/gc/1j/hwgc1jlbxz5s4ng9h1vrenehqui.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Anfang des Pakets befindet sich der Header:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es beginnt mit der Gr√∂√üe des Pakets, das wiederum auf 64 Kilobyte begrenzt ist. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf die Gr√∂√üe folgt ein Byte mit Flags. </font><font style="vertical-align: inherit;">Die Interpretation des restlichen Titels h√§ngt von ihrer Verf√ºgbarkeit ab.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiter ist die Kennung f√ºr die Sitzung oder Verbindung. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit den entsprechenden Flags erhalten wir dann:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Flag mit der Paketnummer gesetzt ist, wird die Paketnummer nach der Sitzungskennung √ºbertragen. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ihm folgen - auch im Fall des gesetzten Flags - die Anzahl der best√§tigten Pakete und deren Nummern.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende des Headers finden Sie Informationen zum Fragment: </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kennung der Fragmentsequenz, die notwendig ist, um Fragmente verschiedener Nachrichten zu unterscheiden; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sequenznummer des Fragments;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamtzahl der Fragmente in der Nachricht. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr Informationen zum Fragment muss auch das entsprechende Flag gesetzt werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bibliothek ist geschrieben. </font><font style="vertical-align: inherit;">Was weiter?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um genauere Informationen zur synchronen Verbindung zu erhalten, haben wir sp√§ter eine explizite Verbindung organisiert. Dies hat uns geholfen, Situationen klar zu verstehen, in denen eine Seite denkt, dass die Verbindung hergestellt und nicht unterbrochen wurde, und die andere Seite, dass sie unterbrochen wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der ersten Version von Pixockets war dies nicht der Fall: Der Client musste die Connect-Methode (Host, Port) nicht aufrufen. Er begann lediglich, Daten an eine bekannte Adresse und einen bekannten Port zu senden. Dann rief der Server die Listen-Methode (Port) auf und begann, Daten von einer bestimmten Adresse zu empfangen. Die Sitzungsdaten wurden beim Empfang / Senden des Pakets initialisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um nun eine Verbindung herzustellen, ist ein ‚ÄûHandshake‚Äú erforderlich geworden - der Austausch speziell gebildeter Pakete - und der Client muss Connect aufrufen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus hat einer meiner Kollegen die Bibliothek gespalten, der Netzwerksicherheit mehr Aufmerksamkeit geschenkt und einige Funktionen hinzugef√ºgt, z. B. die M√∂glichkeit, die Verbindung direkt innerhalb des Sockets wiederherzustellen: Wenn Sie beispielsweise zwischen Wi-Fi und 4G wechseln, wird die Verbindung jetzt automatisch wiederhergestellt. </font><font style="vertical-align: inherit;">Aber dar√ºber werden wir sp√§ter sprechen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich haben wir Unit-Tests f√ºr die Bibliothek geschrieben: Sie √ºberpr√ºfen alle wichtigen M√∂glichkeiten zum Herstellen einer Verbindung, zum Senden und Empfangen von Daten, zum Fragmentieren und Zusammenstellen von Paketen sowie zu verschiedenen Anomalien beim Senden und Empfangen von Daten - wie Duplizieren, Verlust, Nicht√ºbereinstimmung in der Reihenfolge des Sendens und Empfangens. F√ºr die anf√§ngliche Leistungspr√ºfung habe ich spezielle Testanwendungen f√ºr Integrationstests geschrieben: einen Ping-Client, einen Ping-Server und eine Anwendung, die die Position, Farbe und Anzahl der farbigen Kreise auf dem Bildschirm √ºber das Netzwerk synchronisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem die Testanwendungen die Effizienz unserer Bibliothek bewiesen hatten, haben wir begonnen, sie mit anderen Bibliotheken zu vergleichen: mit unserer alten Photon Realtime und mit der UDP-Bibliothek LiteNetLib 0.7.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eine vereinfachte Version eines Spielservers getestet, der einfach Eingaben von Spielern sammelt und das ‚Äûgeklebte‚Äú Ergebnis zur√ºcksendet. Wir haben 500 Spieler in R√§umen mit 6 Personen aufgenommen, die Bildwiederholfrequenz betr√§gt 30 Mal pro Sekunde. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/e-/1e/fy/e-1efyiufgmkgsifktigenhbil0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Belastung des Garbage Collector- und Prozessorverbrauchs war bei Pixockets geringer, ebenso wie der Prozentsatz fehlender Pakete - anscheinend aufgrund der Tatsache, dass wir im Gegensatz zu anderen UDP-Versionen sp√§te Pakete nicht ignorieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir die Best√§tigung des Vorteils unserer L√∂sung in synthetischen Tests erhalten hatten, bestand der n√§chste Schritt darin, die Bibliothek in einem realen Projekt auszuf√ºhren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu diesem Zeitpunkt wurden in dem von uns ausgew√§hlten Projekt Clients und Spieleserver √ºber Photon Server synchronisiert. </font><font style="vertical-align: inherit;">Ich habe dem Client und dem Server die Unterst√ºtzung von Pixockets hinzugef√ºgt, um die Auswahl des Protokolls vom Matchmaking-Server aus zu steuern, an den die Clients eine Anfrage zum Betreten des Spiels senden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Zeit lang spielten Clients gleichzeitig auf beiden Protokollen, und zu diesem Zeitpunkt sammelten wir Statistiken dar√ºber, wie es ihnen ging. </font><font style="vertical-align: inherit;">Am Ende der Statistiksammlung stellte sich heraus, dass sich die Ergebnisse nicht von synthetischen Tests unterscheiden: Die Belastung des Garbage Collectors und des Prozessors hat abgenommen, auch der Paketverlust. </font><font style="vertical-align: inherit;">Gleichzeitig wurde der Ping etwas niedriger. </font><font style="vertical-align: inherit;">Daher wurde die n√§chste Version des Spiels bereits vollst√§ndig auf Pixockets ver√∂ffentlicht, ohne das Photon Realtime SDK zu verwenden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hr/gz/gs/hrgzgsslampwgbbr_u2puvpbhmq.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zukunftspl√§ne</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt m√∂chten wir die folgenden Funktionen in der Bibliothek implementieren:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vereinfachte Verbindung: Jetzt funktioniert sie nicht mehr optimal. Nach dem Aufruf von Connect auf dem Client m√ºssen Sie Read aufrufen, bis sich der Verbindungsstatus √§ndert.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explizites Herunterfahren: Im Moment erfolgt das Herunterfahren auf der anderen Seite nur √ºber den Timer.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingebaute Pings zur Aufrechterhaltung der Konnektivit√§t;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatische Ermittlung der optimalen Bildgr√∂√üe (jetzt wird nur noch eine Konstante verwendet).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen Pixockets </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">unter der Repository-Adresse</font></a><font style="vertical-align: inherit;"> anzeigen und an der Weiterentwicklung teilnehmen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499628/index.html">Entwicklungsinterviews: Freunde ausw√§hlen</a></li>
<li><a href="../de499630/index.html">Flattern. Fr√ºhjahrsupdate 2020</a></li>
<li><a href="../de499632/index.html">Verbessern der Audioqualit√§t von Google Duo mit WaveNetEQ</a></li>
<li><a href="../de499634/index.html">Erweitertes TypeScript</a></li>
<li><a href="../de499636/index.html">Reagiere Native f√ºr die Kleinen. Mobile Entwicklungserfahrung</a></li>
<li><a href="../de499644/index.html">Robotererstellung (RPA) mit AutoTest-Tools</a></li>
<li><a href="../de499646/index.html">5 Regeln f√ºr die Integration von UX in Agile und Scrum</a></li>
<li><a href="../de499648/index.html">‚ÄûEin Spieledesigner ist immer ein Spieler‚Äú: Was macht ein Spezialist, welche F√§higkeiten sind wichtig?</a></li>
<li><a href="../de499652/index.html">Gibt es Leben in der Entwicklung nach dem Dekret</a></li>
<li><a href="../de499654/index.html">Wie implementiere ich CRM auf einem Remote-Standort und gewinne?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>