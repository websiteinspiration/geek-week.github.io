<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏑 👌🏿 🤳🏻 Modèles de stockage Kubernetes 🔀 ☝🏽 👩🏽‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 
 
 Nous vous rappelons que nous avons publié un autre livre extrêmement intéressant et utile sur les modèles Kubernetes. Tout a commen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Modèles de stockage Kubernetes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/490180/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ku/xh/fw/kuxhfwyrk51o4xpq6d1km-gpfbg.png"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bonjour, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous vous rappelons que nous avons publié un autre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">livre</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> extrêmement intéressant et utile </font><font style="vertical-align: inherit;">sur les modèles Kubernetes. </font><font style="vertical-align: inherit;">Tout a commencé avec </font><font style="vertical-align: inherit;">les </font><font style="vertical-align: inherit;">« </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patterns</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> » de </font><font style="vertical-align: inherit;">Brendan Burns et, soit dit en passant, le travail dans ce segment </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bat son plein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Aujourd'hui, nous vous invitons à lire un article du blog MinIO qui résume les tendances et les spécificités des modèles de stockage de données dans Kubernetes.</font></font><br>
<a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes a fondamentalement changé les modèles traditionnels de développement et de déploiement d'applications. </font><font style="vertical-align: inherit;">Maintenant, l'équipe peut prendre des jours pour développer, tester et déployer l'application - dans différents environnements, et tout cela au sein des clusters Kubernetes. </font><font style="vertical-align: inherit;">Un tel travail avec la technologie des générations précédentes prenait généralement des semaines, voire des mois.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette accélération a été rendue possible grâce à l'abstraction fournie par Kubernetes - c'est-à-dire du fait que Kubernetes lui-même interagit avec les détails de bas niveau des machines physiques ou virtuelles, permettant aux utilisateurs de déclarer, entre autres paramètres, le processeur souhaité, la mémoire requise, le nombre d'instances de conteneur. Étant donné que Kubernetes est pris en charge par une énorme communauté et que la portée de Kubernetes est en constante expansion, il domine largement sur toutes les plates-formes d'orchestration de conteneurs. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À mesure que l'utilisation de Kubernetes se développe, la confusion au sujet des modèles de stockage qui y sont utilisés augmente</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec la concurrence générale pour un morceau de tarte Kubernetes (c'est-à-dire pour le stockage de données), quand il s'agit de stockage de données, le signal se noie dans un bruit fort. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes incarne un modèle moderne de développement, de déploiement et de gestion d'applications. Un tel modèle moderne détache le stockage de données de l'informatique. Pour bien comprendre ce détachement dans le contexte de Kubernetes, vous devez également comprendre ce que sont les applications avec état et sans état, et comment le stockage de données est combiné avec cela. C'est là que l'approche de l'API REST utilisée par S3 présente des avantages évidents par rapport à l'approche POSIX / CSI qui est typique des autres solutions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous parlerons des modèles de stockage dans Kubernetes et nous discuterons séparément du débat sur les applications sans état et sans état, afin que nous puissions clairement comprendre la différence entre elles et pourquoi elle est importante. </font><font style="vertical-align: inherit;">Plus loin dans le texte, nous examinerons les applications et les modèles de stockage de données qui y sont utilisés à la lumière des meilleures pratiques pour travailler avec des conteneurs et Kubernetes.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conteneurs apatrides</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les conteneurs sont intrinsèquement légers et éphémères. </font><font style="vertical-align: inherit;">Ils peuvent être facilement arrêtés, supprimés ou déployés sur un autre nœud - tout cela prend quelques secondes. </font><font style="vertical-align: inherit;">Dans un grand système d'orchestration de conteneurs, ces opérations se produisent tout le temps et les utilisateurs ne remarquent même pas ces modifications. </font><font style="vertical-align: inherit;">Cependant, les mouvements ne sont possibles que si le conteneur n'a pas de dépendances sur le nœud sur lequel il se trouve. </font><font style="vertical-align: inherit;">Ces conteneurs fonctionneraient </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sans la préservation de l'État</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conteneurs avec état</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si le conteneur stocke des données sur des périphériques connectés localement (ou sur un périphérique bloc), l'entrepôt de données sur lequel il se trouve devra être déplacé vers un nouveau nœud avec le conteneur lui-même - en cas de défaillance. Ceci est important, car sinon l'application exécutée dans le conteneur ne pourra pas fonctionner correctement, car elle doit accéder aux données stockées sur les médias locaux. Ces conteneurs seraient en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">état</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'un point de vue purement technique, les conteneurs avec état peuvent également être déplacés vers d'autres nœuds. En règle générale, cela est réalisé à l'aide de systèmes de fichiers distribués ou de blocs de stockage réseau attachés à tous les nœuds sur lesquels les conteneurs fonctionnent. Ainsi, les conteneurs ont accès aux volumes pour le stockage de données persistantes et les informations sont stockées sur des disques situés sur le réseau. J'appellerai une telle méthode une « </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">approche de conteneur préservant l'état</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> », et dans le reste de l'article je l'appellerai par souci d'uniformité.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y1/cs/6z/y1cs6zoudpecfzs6ww-aw8ocxyg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans une approche de conteneur avec état typique, tous les modules d'application sont attachés à un système de fichiers distribué - une sorte de stockage partagé est obtenu, où toutes les données d'application sont acquises. </font><font style="vertical-align: inherit;">Bien que certaines variations soient possibles, il s'agit d'une approche de haut niveau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant pourquoi l'approche des conteneurs avec état dans le monde basé sur le cloud est anti-modèle.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conception d'applications basées sur le cloud</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Traditionnellement, les applications utilisaient des bases de données pour le stockage structuré des informations et des disques locaux ou des systèmes de fichiers distribués, où toutes les données non structurées ou même semi-structurées étaient vidées. Alors que le volume de données non structurées augmentait, les développeurs ont réalisé que POSIX était trop «bavard», associé à des coûts importants et, en fin de compte, interfère avec l'application lors du passage à une très grande échelle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela a principalement contribué à l'émergence d'une nouvelle norme pour le stockage de données, à savoir les stockages basés sur le cloud qui fonctionnent principalement sur la base de l'API REST et libèrent l'application de la maintenance fastidieuse de l'entrepôt de données local. Dans ce cas, l'application entre en fait dans le mode de fonctionnement sans enregistrer l'état (car l'état se trouve dans le stockage distant). Des applications modernes sont construites à partir de zéro en tenant déjà compte de ce facteur. En règle générale, toute application moderne qui traite des données d'une sorte ou d'une autre (journaux, métadonnées, blobs, etc.) est construite sur un paradigme orienté cloud, où l'état est transféré vers un système logiciel spécialement alloué pour son stockage.</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une approche de conteneur dynamique fait que tout ce paradigme revient exactement là où il a commencé!</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lorsque vous utilisez des interfaces POSIX pour stocker des données, les applications fonctionnent de la même manière que si elles maintenaient l'état, et pour cette raison, s'écartent des postulats les plus importants de la conception basée sur le cloud, c'est-à-dire de la possibilité de faire varier la taille des workflows d'application en fonction de l'entrée. charger, déplacer vers un nouveau nœud dès que le nœud actuel tombe en panne, etc.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un examen plus approfondi de cette situation révèle que lors du choix d'un entrepôt de données, nous sommes confrontés à maintes reprises au dilemme «POSIX versus API REST», MAIS avec une aggravation supplémentaire des problèmes POSIX causés par la nature distribuée des environnements Kubernetes. En particulier,</font></font><br>
<br>
<ul>
<li><b>POSIX </b>:  POSIX         ,     .     ,     . API   ,  , S3 API,    ,   ,   «»  .     ,       .        .</li>
<li><b> </b>:    ,     ,          . ,  ,            (    ),         ,     . -  POSIX       .   , S3 API       ,      ,  ,     .</li>
<li><b></b>:   POSIX     :          .      - .      ,   API,       ,   ,     ..</li>
<li><b></b>:       ,   .       ,    ,     ,      .  ,     ,      ,   .</li>
</ul><br>
<h4>   </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors que l'interface de stockage de données de conteneur (CSI) a beaucoup aidé à la distribution du niveau de volume de Kubernetes, le transmettant partiellement à des fournisseurs d'entrepôt de données tiers, mais a également contribué accidentellement à la conviction que l'approche de conteneur avec état était la méthode recommandée de stockage de données dans Kubernetes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSI a été développé comme standard pour fournir des systèmes de stockage de blocs et de fichiers arbitraires pour les applications héritées lorsque vous travaillez avec Kubernetes. Et, comme cela a été montré dans cet article, la seule situation où une approche de conteneur avec état (et CSI dans sa forme actuelle) est appropriée est lorsque l'application elle-même est un système hérité dans lequel il est impossible d'ajouter la prise en charge de l'API de stockage de données d'objet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est important de comprendre que l'utilisation de CSI dans sa forme actuelle, c'est-à-dire lors du montage de volumes lorsque vous travaillez avec des applications modernes, nous rencontrerons environ les mêmes problèmes que ceux rencontrés dans les systèmes où le stockage des données est organisé dans le style POSIX.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meilleure approche</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, il est important de comprendre que la plupart des applications ne sont pas intrinsèquement affûtées spécifiquement pour un travail avec ou sans conservation de l'état. </font><font style="vertical-align: inherit;">Ce comportement dépend de l'architecture globale du système et des options spécifiques sélectionnées lors de la conception. </font><font style="vertical-align: inherit;">Parlons un peu des applications avec état. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En principe, toutes les données d'application peuvent être divisées en plusieurs grands types:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consigner les données</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Données d'horodatage</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Données de transaction</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Métadonnées</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Images de conteneurs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Données blob (blobs)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous ces types de données sont très bien pris en charge sur les plates-formes de stockage de données modernes, et il existe plusieurs plates-formes basées sur le cloud adaptées pour fournir des données dans chacun de ces formats spécifiques. Par exemple, les données de transaction et les métadonnées peuvent résider dans une base de données cloud moderne telle que CockroachDB, YugaByte, etc. Les images de conteneur ou les données d'objets blob peuvent être stockées dans le registre Docker basé sur MinIO. Les données d'horodatage peuvent être stockées dans une base de données de séries temporelles, comme InfluxDB, etc. Nous n'entrerons pas dans les détails de chaque type de données et applications associées, mais l'idée générale est d'éviter le stockage persistant de données basé sur le montage de disque local.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/us/gk/li/usgklihtry8ddkgmpkumtziiv3y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En outre, il est souvent efficace de fournir une couche de mise en cache temporaire, qui sert de type de stockage de fichiers temporaires pour les applications, mais les applications ne doivent pas dépendre de ce niveau comme source de vérité.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stockage d'applications avec état</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors que dans la plupart des cas, il est utile de conserver les applications sans état, les applications conçues pour stocker des données - par exemple, les bases de données, les magasins d'objets, les magasins de clés et de valeurs - doivent conserver leur état. </font><font style="vertical-align: inherit;">Voyons pourquoi ces applications sont déployées sur Kubernetes. </font><font style="vertical-align: inherit;">Prenons l'exemple de MinIO, mais des principes similaires s'appliquent à tous les autres grands systèmes de stockage basés sur le cloud.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les applications centrées sur le cloud sont conçues pour maximiser l'utilisation de la flexibilité inhérente aux conteneurs. Cela signifie qu'ils ne font aucune hypothèse sur l'environnement dans lequel ils seront déployés. Par exemple, MinIO utilise un mécanisme de codage d'effacement interne, qui fournit au système une stabilité suffisante pour qu'il reste opérationnel même si la moitié des disques tombent en panne. MinIO gère également l'intégrité et la sécurité des données à l'aide de ses propres hachage et chiffrement côté serveur.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour de telles applications basées sur le cloud, les volumes persistants locaux (PV) sont les plus pratiques comme stockage de sauvegarde. </font><font style="vertical-align: inherit;">Le PV local offre la possibilité de stocker des données brutes, tandis que les applications exécutées au-dessus de ces PV collectent indépendamment des informations pour mettre à l'échelle les données et gérer les besoins croissants de données. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette approche est beaucoup plus simple et beaucoup plus évolutive par rapport aux systèmes PV basés sur CSI, qui apportent leurs propres niveaux de gestion des données et de redondance au système; </font><font style="vertical-align: inherit;">le fait est que ces niveaux entrent généralement en conflit avec des applications conçues selon le principe de la préservation de l'État.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mouvement confiant pour détacher les données de l'informatique</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous avons expliqué comment les applications sont réorientées pour fonctionner sans enregistrer l'état, ou, en d'autres termes, le stockage de données est séparé du calcul sur celles-ci. En conclusion, nous considérons quelques exemples concrets d'une telle tendance. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , la célèbre plate-forme d'analyse de données, est traditionnellement utilisée avec un déploiement avec état et un déploiement sur le système de fichiers HDFS. Cependant, à mesure que Spark passe à un monde basé sur le cloud, cette plate-forme est de plus en plus utilisée sans préservation de l'état à l'aide de `s3a`. Spark utilise s3a pour transférer l'état vers d'autres systèmes, tandis que les conteneurs Spark eux-mêmes fonctionnent entièrement sans préservation de l'état. Autres acteurs de grandes entreprises dans le domaine de l'analyse des mégadonnées, en particulier </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teradata</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Greenplum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> va également travailler avec la division du stockage de données et de l'informatique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des modèles similaires peuvent également être observés sur d'autres grandes plates-formes analytiques, notamment Presto, Tensorflow to R, Jupyter. </font><font style="vertical-align: inherit;">Le téléchargement de l'état vers des systèmes de stockage cloud distants facilite la gestion et la mise à l'échelle de votre application. </font><font style="vertical-align: inherit;">De plus, il facilite la portabilité de l'application vers une variété d'environnements.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr490162/index.html">Les caprices de l'évolution: la découverte d'un organisme vivant sans oxygène</a></li>
<li><a href="../fr490168/index.html">Analyse de la qualité du chatbot dans IBM Watson Assistant</a></li>
<li><a href="../fr490170/index.html">Chef de projet dans un vice. Pourquoi et quoi faire à ce sujet</a></li>
<li><a href="../fr490174/index.html">Recherche DNS dans Kubernetes</a></li>
<li><a href="../fr490178/index.html">Alors que tout le monde se dirige vers l'ouest, je me suis déplacé en Arménie</a></li>
<li><a href="../fr490184/index.html">Alphabet a un deuxième groupe secret de développeurs informatiques quantiques</a></li>
<li><a href="../fr490186/index.html">De quoi nous avons fait JET BI. Architecture Business Intelligence System sans digression lyrique</a></li>
<li><a href="../fr490190/index.html">Je vais chercher: géo-positionnement de l'hôte par adresse IP sur Internet global en utilisant le crypto échange Binance comme exemple</a></li>
<li><a href="../fr490194/index.html">Utilisation de RabbitMQ avec MonsterMQ Partie 4</a></li>
<li><a href="../fr490196/index.html">[Flipper Zero] refusez le Raspberry Pi, faites notre propre planche à partir de zéro. Trouver la bonne puce WiFi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>