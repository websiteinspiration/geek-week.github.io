<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙 🧟 ✌🏿 C＃機械学習：ML.NETの概要 ▫️ ⛔️ 👵🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ML.NETは、.NETプラットフォームで最も強力な機械学習ライブラリであると主張しています。本当か？質問はジェフプロサイズによって答えられます。
 
 Jeff Proseiz-有名なJeffrey Richterのワークショップの同僚であるWintellectの創設者の1人であり、9冊以上の本と...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C＃機械学習：ML.NETの概要</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/495208/"><img src="https://habrastorage.org/webt/s4/s1/qb/s4s1qbhqp1rnapciuy8hkap0z5e.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ML.NETは、.NETプラットフォームで最も強力な機械学習ライブラリであると主張しています。本当か？質問はジェフプロサイズによって答えられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeff Proseiz-有名なJeffrey Richterのワークショップの同僚であるWintellectの創設者の1人であり、9冊以上の本とアプリケーション開発に関する多くの記事の著者であり、Azureと連携してさまざまなAIソリューションを開発しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カットの下で、元のDotNext 2019モスクワ会議からのジェフのレポートの翻訳とビデオ。</font></font><br>
<a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/6LNcXqiT6T0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次は話者に代わるナラティブです。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
私たちの業界の歴史には10年ごとにパラダイムシフトがあると思います。 1980年代、パソコンに革命があり、高校を卒業して働き始めました。この革命は私たちの産業だけでなく、人々の日常生活も変えました。 1990年代、インターネットも同様の革命を起こしました。 2000年代には、同様に大規模な変化がスマートフォンの出現によって引き起こされました。現在、レストラン、地下鉄、路上では、人々は常にスマートフォンの画面を見ています。 20年前は、このテクノロジーがもたらす変化を想像するのは難しいでしょう。私たちは今、同様に根本的な革命の危機に瀕していると思います。今回は機械学習と人工知能に関連しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoft Research、Google、Facebookなどでは、この分野の論文を擁護した才能のある人々がたくさんいます。彼らは非常に高い給与を受け取り、複雑なニューラルネットワークを設計します。プログラマになる前は、ロケットサイエンスのエンジニアでした。エンジニアは高い問題に対処しません、これには物理学者が存在します。物理学者は法則を定式化して方程式を記述し、エンジニアはこれらの法則と方程式を使用して実際の問題を解決します。機械学習とAIの世界のプログラマーもまったく同じ役割を果たします。彼らは新しいネットワークのアーキテクチャを作成するのではなく、適切なツールとテクノロジーを知るために、既存のネットワークを使用できる必要があります。それが、私の観点から、ML.NETが非常に重要である理由です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数年前、機械学習の分野で働いていた誰もがPythonを学ばなければなりませんでした。 PythonはAIの分野で最も人気のある言語の1つであり、その理由の1つは、大学や大手企業でAIモデルを開発する人々がかつてPythonでのプログラミングを学んだことです。さらに、AIの高度なライブラリの重要な部分は、特にPython用に作成されています。これらは、Scikit、Keras、PyTorchなどです。 5年ほど前から積極的に機械学習に取り組み始め、それまでの人生で10行以下のPythonコードを記述しました。私はこの言語を学ばなければなりませんでしたが、同時に.NETに慣れていたので、常に不快でした。最近まで、C＃にはPythonで使用可能なライブラリの代替手段がありませんでしたが、現在ではそのような代替手段が登場しています。これはML.NETです。AIと連携するためのMicrosoftのオープンソースライブラリ。今日は、このライブラリを使用した多くのコード例を見ていきます。これらの例を含むGitHubリポジトリへのリンクを示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C＃の下にAIのライブラリがあるという事実は、多くの理由で重要です。これで、AIを操作するためにPythonを知る必要はありません。 C＃では、ScikitやKerasなどのPythonライブラリを使用して作成されたモデルを操作するのは困難です。これにはさまざまな方法がありますが、最も一般的な方法の1つは、Flask Webサーバーと一緒にPythonモデルをコンテナーに配置することです。しかし、このアプローチは非常に非効率的です。 C＃でアプリケーションを作成する開発者には、この言語でモデルを使用する機能が必要であり、ML.NETはそのような機会を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深いことに、ML.NETはそれほど新しいライブラリではありません。最近リリースされましたが、マイクロソフト内部では約10年使用されています。それは突然起こったのではなく、長年にわたって徐々に発達しました。コードのほとんどはMicrosoft Researchで作成されました。それはかなり粗雑なコードであり、Microsoftで働いていてこれらのライブラリにアクセスできる人たちにとっても使用するのは困難でした。共通のアーキテクチャがなく、さまざまなシェルなどを使用する必要がありました。 3年前、Microsoftの少数のグループが、このライブラリを外部使用およびオープンソースに対応できるようにすることを決定しました。 Microsoftの経営陣にこのプロジェクトに同意するよう説得するには、ほぼ1年かかりました。 ML.NETという名前で登場しました。 ML.NETの中心には、他の多くのMicrosoft製品で使用されているものと同じアルゴリズムがあります。彼らは掃除されましたそれらのドキュメントを作成し、共通のAPIを作成しました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データビュー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このライブラリがどのように機能するか、どのように構成されているか、プロジェクトでどのように使用するかに直接移動しましょう。</font><font style="vertical-align: inherit;">Visual Studioを開きます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DataView</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について理解する必要</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">があり</font></a><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">Python機械学習者はおそらく</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">パンダ</font></a><font style="vertical-align: inherit;">ライブラリを使用していました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。彼女はDataFrameと呼ばれる非常に便利なデータ構造を持っています。一般的なアプリケーションの作業は次のようになります。あるソースからデータを読み取り、それをDataFrameにロードして、必要な変換を行い、それらを使用してモデルをトレーニングします。 ML.NETの主要な構造の1つはDataViewと呼ばれ、IDataViewインターフェイスを実装するオブジェクトです。この構造はDataFrameに類似していますが、より柔軟で多用途です。 ML.NETチームは、Scikitのような通常のライブラリよりもはるかに高速にモデルをトレーニングし、処理を拡張できるライブラリを作成したいと考えていました。 ）モデルのトレーニング時間はほぼ直線的に変化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ML.NET開発者は、Pythonが単純に処理できないこのサイズのデータ​​セットを処理する機能を提供したいと考えていました。このため、DataViewが作成されました。最初はIEnumerableインターフェイスがこれらの目的で使用されていましたが、すぐにいくつかの制限が明らかになりました。特に、IEnumerableのコンテンツはメモリに収まる必要がありますが、データサイエンスは多くの場合、メモリに対して大きすぎるデータセットを処理する必要があります。 .NET型システムは、開発者がこれらのデータ構造内で実行することを望んでいたいくつかのアクションを許可できないことがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列に一連の整数値が含まれていることだけでなく、それぞれの範囲が制限されていることを示す必要があるとします（たとえば、0〜10）。これらの制限を克服するために、ML.NETチームはDataViewを作成しました。このデータ構造のアイデアは、SQLデータベースから採用されました。そのようなDataViewは、本質的に、データに含まれるデータのサイズに制限はありません。メモリにロードされるのは、現時点で必要な量だけだからです。さらに、DataViewは遅延評価を使用します。モデルがトレーニングされるまで、アクションは実行されません。これにより、デバッグが困難になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データをDataViewにロードし、いくつかの変換を実行したとします。その後、デバッガーで段階的にコードを実行すると、計算が遅れるため、データはありません。したがって、DataViewを使用する場合、最も重要な方法の1つはプレビューです。パフォーマンスが低下するため、デバッグのみに使用することは理にかなっています。特定のDataViewを含むプレビュー呼び出しをコードに挿入する場合、この呼び出しにブレークポイントを設定すると、デバッグ中にこの時点でDataViewのコンテンツが読み込まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DataViewの目的の1つは、それにデータをロードすることです。機械学習を使用する場合、データは非常に多くの場合、拡張子が.csvおよび.tsvのファイルに保存されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">// Load data from a CSV file that contains a header row  </span>
<span class="hljs-keyword">var</span> data = context.Data.LoadFromTextFile&lt;Input&gt;(<span class="hljs-string">"PATH_TO_DATA_FILE"</span>, hasHeader: <span class="hljs-literal">true</span>,                                                                 <font></font>
      separatorChar: <span class="hljs-string">','</span>); 
<span class="hljs-comment">// Load data from a TSV file without a header row. Allow quotes and trim whitespace. </span>
<span class="hljs-keyword">var</span> data = context.Data.LoadFromTextFile&lt;Input&gt;(<span class="hljs-string">"PATH_TO_DATA_FILE"</span>, allowQuoting: <span class="hljs-literal">true</span>,  <font></font>
      trimWhitespace: <span class="hljs-literal">true</span>);  
<span class="hljs-comment">// Load data from multiple CSV files (all files must have the same schema) </span>
<span class="hljs-keyword">var</span> loader = context.Data.CreateTextLoader&lt;Input&gt;(hasHeader: <span class="hljs-literal">true</span>, separatorChar: <span class="hljs-string">','</span>); 
<span class="hljs-keyword">var</span> data = loader.Load(<span class="hljs-string">"PATH1"</span>, <span class="hljs-string">"PATH2"</span>, <span class="hljs-string">"PATH3"</span>);
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのファイルからデータをロードするために、DataView開発者は、上記のメソッドをいくつか作成しました。</font><font style="vertical-align: inherit;">これらのメソッドには、引用符などを無視できるパラメータがあります。</font><font style="vertical-align: inherit;">CSVおよびTSVファイルからだけでなく、DataViewのデータをロードできます。</font><font style="vertical-align: inherit;">非常に多くの場合、データベースはデータを格納するために使用されます（Asure SQLやMySQLなど）。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Load data into an array or other IEnumerable from an external data source. // The following example simply creates an array in memory. </span><font></font>
<font></font>
<span class="hljs-keyword">var</span> input = <span class="hljs-keyword">new</span>[] <font></font>
{ <font></font>
      <span class="hljs-keyword">new</span> Input { Age = <span class="hljs-number">30</span>, YearsExperience = <span class="hljs-number">10</span>, ... }, 
      <span class="hljs-keyword">new</span> Input { Age = <span class="hljs-number">40</span>, YearsExperience = <span class="hljs-number">20</span>, ... }, 
      <span class="hljs-keyword">new</span> Input { Age = <span class="hljs-number">50</span>, YearsExperience = <span class="hljs-number">30</span>, ... } <font></font>
}; <font></font>
<font></font>
<span class="hljs-keyword">var</span> data = context.Data.LoadFromEnumerable&lt;Input&gt;(input);
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSVまたはTSVファイルからデータが読み込まれていない場合は常に、上記のLoadFromEnumerableメソッドを使用します。</font><font style="vertical-align: inherit;">IEnumerableがこのメソッドに渡されます。</font><font style="vertical-align: inherit;">非常に単純な場合もあれば、メモリ内に作成される場合もあれば、クエリによってデータベースに読み込まれた100万行を含む場合もあります。</font><font style="vertical-align: inherit;">これから説明する例では、ほとんどの場合TSVまたはCSVファイルからデータをダウンロードしますが、データはどこからでもダウンロードできることを理解することが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ML.NETは、DataViewにデータをロードするメソッドに加えて、DataViewにすでにロードされている作業データを準備できるメソッドも提供します。機械学習に従事している場合、実際の例から取得したデータは非常に生であり、重要な処理が必要であることを知っています。このような処理の典型的な例は、正規化と呼ばれるプロセスです。モデルのトレーニングに使用されるデータの変動が大きすぎる場合、最悪の場合、これによりモデルが特定の決定を下せなくなる可能性があります。最良のケースでは、モデルのトレーニングに必要な時間が大幅に長くなり、モデルの精度に影響する可能性があります。これを回避するために、データは正規化されます。正規化にはさまざまな方法がありますが、その1つが標準化です。これは、すべての値が-1から1の範囲に変換されることを意味しますこれらの値から平均が計算され、この平均が値から差し引かれます。この方法は、データサイエンスで非常によく使用されます。 ML.NETは、この変換を1行のコードで実行する機能を提供します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">// Remove rows with missing values in the "Age" and "YearsExperience" columns </span>
<span class="hljs-keyword">var</span> view = context.Data.FilterRowsByMissingValues(data, <span class="hljs-string">"Age"</span>, <span class="hljs-string">"YearsExperience"</span>);<font></font>
 <font></font>
<span class="hljs-comment">// Remove rows where "Age" is less than 20 or greater than 80 </span>
<span class="hljs-keyword">var</span> view = context.Data.FilterRowsByColumn(data, <span class="hljs-string">"Age"</span>, lowerBound: <span class="hljs-number">20</span>, upperBound: <span class="hljs-number">80</span>);<font></font>
<font></font>
<span class="hljs-comment">// Remove the "Age" column </span>
<span class="hljs-keyword">var</span> estimator = context.Transforms.DropColumns(<span class="hljs-string">"Age"</span>); 
<span class="hljs-keyword">var</span> view = estimator.Fit(data).Transform(data); <font></font>
<font></font>
<span class="hljs-comment">// Replace missing values in the "Age" column </span>
<span class="hljs-keyword">var</span> estimator = context.Transforms.ReplaceMissingValues(<span class="hljs-string">"Age"</span>, <font></font>
      replacementMode: MissingValueReplacingEstimator.ReplacementMode.Mean); <font></font>
<span class="hljs-keyword">var</span> view = estimator.Fit(data).Transform(data);
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記は、DataViewでデータを変更する方法の例です。データをロードするとき、一部の行に欠損値が含まれていることがよくあり、これがモデルのトレーニングに悪影響を及ぼします。この問題を解決する方法はいくつかあります。最も単純なのは、欠損値のある行を削除することです。これを可能にするメソッドがDataViewにあります。別の方法は、欠損値を列平均で置き換えることです。 DataViewには、これらすべてのメソッドのメソッドがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ML.NETで最も重要なメソッドの1つは、TrainTestSplitです。 Scikitを使用したことがある場合は、ML.NETの多くのメソッドの名前が、Scikitの類似のメソッドとまったく同じであることにお気づきでしょう。 ML.NETチームは主にScikitの例に従っており、PythonプログラマーがScikit APIを介してML.NETモデルをトレーニングできるようにするML.NET用のPythonラッパーを作成しました。したがって、ML.NETの利点はPythonで利用できます。スケーラビリティ、パフォーマンスなどです。TrainTestSplitメソッドは、機械学習モデルをチェックしないと予測がどれほど正確であるかを判断できないため重要です。理想的には、トレーニング用と検証用の2つの入力データセットが必要です。場合によっては、最初から2つのデータセットを利用できます。ほとんどの場合、データセットは1つだけです。この場合、トレーニングデータセットとテストデータセットに分割します。通常、この除算は80/20の比率で実行されますが、50/50になる場合もあります。 TrainTestSplitは、データセットのこの2つの分割を正確に実行します。以下のほとんどすべての例で使用されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての準備作業が完了すると、モデルのトレーニングが始まります。 ML.NETには、このための特別なメソッドがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dv/vn/o1/dvvno11iwdztjy0wwvbuubvtkp4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の画像の名前は実際にはクラスであり、メソッドではありません。対応するメソッドがクラスのインスタンスを作成するだけです。機械学習は主に回帰と分類の問題に使用されます。これら2つの問題は、教師あり学習問題と呼ばれるものの99.99％を占めます。 Scikitの人気の理由は、データサイエンスで使用されるアルゴリズム（サポートベクター法、ランダムフォレスト、決定木、通常の最小二乗回帰）を単純な関数呼び出しとして表すためです。 ML.NETは、トレーニングクラスで同じことを実現します。彼らは、過去数年間にMicrosoft Researchが実施した作業を使用しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回帰モデルを作成する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回帰モデルは、結果を数値で表すことができるモデルです。</font><font style="vertical-align: inherit;">たとえば、モデルを使用して、家の価格や、機械が検査を必要とするまでの時間を予測します。</font><font style="vertical-align: inherit;">数値の形で結果を与えるモデル、つまり回帰モデルが必要です。</font><font style="vertical-align: inherit;">ML.NETには、このようなモデルを作成するためのさまざまなアルゴリズムがあります。</font><font style="vertical-align: inherit;">おそらく、多くの人が最小二乗法に精通しています。</font><font style="vertical-align: inherit;">これは、機械学習コースが常に始まる最も単純な種類の回帰です。</font><font style="vertical-align: inherit;">はるかに複雑なアルゴリズムがあります。</font><font style="vertical-align: inherit;">ML.NETでは、これらのクラスのすべてのアルゴリズムに優れたドキュメントがあり、実装の詳細をすべて見つけることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ym/ke/wt/ymkewtg0sea_aas6sg3ajlvyul4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記は回帰モデルの例です。ここでは、データがDataViewで80/20の割合で分割されます。つまり、データの80％がトレーニングに使用され、20％が検証に使用されます。次のステップは、パイプラインを作成することです。ここでcontext.Transforms.Concatenateが呼び出されます。 ML.NETアプリケーションのコードの最初の行は、MLContextクラスのオブジェクトを作成します。このオブジェクトを使用すると、さまざまなML.NET APIへのアクセスが許可されるプロパティにアクセスできます。上記の例では、最初の行のコンテキスト変数はMLContextクラスのインスタンスです。この変数のDataプロパティを通じて、TrainTestSplitメソッドを呼び出します。このメソッドは、データを2つのセットに分割します。次に、Transformsプロパティを通じて、Concatenateメソッドが呼び出されます。この定数は、Scikitおよびその他の機械学習ライブラリには存在しません。機械学習モデルを学習するときは、列と行を含むテーブルから始めます。これらの列の1つには従属変数の値（ラベル列）が含まれ、残りの列には独立変数（機能列）の値が含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トレーニングでは、モデルは従属変数と独立変数の間の関係を構築しようとします。 ML.NETでこのような構造を作成するには、Concatenateメソッドを呼び出して、DataViewにFeatures列を作成する必要があります。同じ呼び出しで、独立変数の値を含むDataView列を指定できます。何も指定しないと、DataViewのすべての列がこのカテゴリに含まれます。上記の例の場合、列Col1、Col2、およびCol3を示しています。その後、学習アルゴリズムを実行する必要があります。再びコンテキストオブジェクトであるRegression.Trainersプロパティを参照し、FastForest（）メソッドを呼び出します。これにより、FastForestRegressionTrainerクラスのインスタンスが作成されます。高速フォレスト回帰は、ランダムフォレストおよびディシジョンツリー回帰のより洗練されたバージョンです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのアルゴリズムの利点は、データの正規化が不要であることです。したがって、この例では、正規化は実行されません。次のステップはモデルのトレーニングです。これは、トレーニング用のデータが引数として渡されるpipeline.Fit（）メソッドが呼び出されたときに発生します。以前のコードはすべて非常に高速であり、同じ方法には時間がかかる場合があります。データセットが数千の値の領域で小さい場合、実行に数秒かかります。これが5億行のテーブルの場合、さらに時間がかかります。このようなデータ配列の操作は通常、ラップトップではなく、GPUを使用するAzureまたはAWSのHPCクラスターで実行されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> options = <span class="hljs-keyword">new</span> FastForestRegressionTrainer.Options <font></font>
{ <font></font>
       <span class="hljs-comment">// Only use 80% of features to reduce over-fitting </span>
       FeatureFraction = <span class="hljs-number">0.8</span>, 
       <span class="hljs-comment">// Simplify the model by penalizing usage of new features </span>
       FeatureFirstUsePenalty = <span class="hljs-number">0.1</span>, 
       <span class="hljs-comment">// Limit the number of trees to 50 </span>
       NumberOfTrees = <span class="hljs-number">50</span> <font></font>
}; <font></font>
<span class="hljs-keyword">var</span> pipeline = context.Transforms.Concatenate(<span class="hljs-string">"Features"</span>, <span class="hljs-string">"Col1"</span>, <span class="hljs-string">"Col2"</span>, <span class="hljs-string">"Col3"</span>)      <font></font>
      .Append(context.Regression.Trainers.FastForest(options));</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
学習アルゴリズム（前の例の高速フォレストアルゴリズム）を定義するメソッドを呼び出すときは、デフォルト設定を使用できますが、オプション変数を使用して設定を指定できます。学習アルゴリズムを実装するScikit関数は、5、10、または20のパラメーターをとることができます。ここでも同じことがわかります。トレーニング用のクラスを作成するすべてのメソッドには、非常に満足のいくパフォーマンスを提供するデフォルト値があります。適切なパラメータを選択すると、モデルの精度が大幅に向上します。このパラメーター選択プロセスは、ハイパーパラメーター調整と呼ばれます。 ML.NETは、上記のパターンを常に使用します。つまり、オプションオブジェクトを作成し、それに必要なパラメーターを入力します。代わりに、Scikitはオプションの関数パラメーターを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルがタスクを実行しているかどうかを確認する唯一の方法は、チェックすることです。多くのライブラリでは、検証にはかなりの量のコードが必要です。対照的に、ML.NETでは、このプロセスは可能な限り単純化されています。結果を数値として返す回帰モデルを作成した場合、データサイエンスが回帰モデルの評価に使用するすべてのメトリックをプロパティに含むオブジェクトにアクセスできます。決定係数R2がよく使用されます。 0から1の範囲で変化し、0はモデルの精度が低いことを意味し、1はモデルの精度が高いことを意味します。インデックスR2が0.8または0.9を超えるように努力する必要があります。回帰モデルが評価される他の指標があります。たとえば、標準誤差と平均絶対誤差です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bp/rq/4f/bprq4fqapczlyojdqm-uv6ajoje.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのインジケーターはすべてML.NETで使用できます。インジケーターを表示するには、context.Regression.Evaluateメソッドを呼び出す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データサイエンスでは、交差検証は非常に重要です。データセットからランダムに行を選択してモデルを検証する場合、検証の結果は、選択された行によって異なる場合があります。したがって、通常、クロス検証を実行します。元のデータセットを80/20の比率で2つに分割することを5回実行し、各ペアに対してトレーニングと検証を実行します。これにより、アルゴリズムの実行時間が5倍になります。ここで、モデルを推定するために、5つの結果すべての標準誤差とR2の平均が使用され、そのような推定はより信頼性が高くなります。 ML.NETでは、この手順全体が可能な限り単純化されています。これは例で示されています：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/js/tc/vh/jstcvh6ks3d-jaggl9hx2c_okg0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Evaluateメソッドの代わりに、context.Regression.CrossValidateを呼び出して、クロスチェックする回数を指定します。 R2メトリックの平均は自動的に計算されませんが、テストごとに個別のメトリックが計算されます。自分で平均を計算するには、コードを1行だけ追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユニタリーエンコーディングという用語を知っていますか？ほとんどの場合、機械学習モデルは数値でのみ機能します。入力値が文字列である多くのタスクがあります。これらは、いわゆるカテゴリー値です。データセットには、BMW、アウディ、または類似の車のメーカーを示す列がある場合があります。テキストは私たち人間にとっては明らかですが、モデルにとっては明らかではありません。これらの値をモデルで理解できるようにするために、ユニタリーエンコーディングと呼ばれるプロセスが使用されます。品質値列の一意の値ごとに1つずつ、DataViewに列が追加されます。これらの列は、対応する値がソースデータセットに存在するかどうかに応じて、0または1を示します。この形式では、機械学習モデルがこのデータを読み取ることができます。 ScikitおよびML。NETこのアクションは1行のコードで実行されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ML.NETの回帰モデル</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デモ付きのビデオへの</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンクリポジトリへのリンク</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このモデルで使用する一連のデータは、不動産会社のZillowから借用したものです。</font><font style="vertical-align: inherit;">彼らはデータを公開しており、機械学習モデルの教育にそれらを使用すると非常に便利です。</font><font style="vertical-align: inherit;">私たちのデータセットはCSVファイルに含まれており、440行あります。</font><font style="vertical-align: inherit;">正確なモデルをこのような小さなセットで構築することはできませんが、デュアルコアラップトップでもトレーニングは高速です。</font><font style="vertical-align: inherit;">各行には、米国サンフランシスコ地域の不動産取引、平方フィートの住宅のサイズ、寝室、バスルームの数、および最後の購入/販売の価格に関するデータが含まれています。</font><font style="vertical-align: inherit;">モデルのタスクは、提供されたパラメーターに基づいて不動産価格を予測することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
program.csアプリケーションに移りましょう。</font><font style="vertical-align: inherit;">これは.NET Coreアプリケーションです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xn/hh/2k/xnhh2kkbxtoiw_hrhmjhlw70aye.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードの学習を最後から始めましょう。全体としてのML.NETとC＃の重要な利点の1つは、強力な型指定です。 Pythonでは、コードを実行したときにのみ入力エラーを認識し、このエラーが発生した場所を正確に知ることは困難です。 ML.NETでは、機械学習モデルの入力データと出力データの両方がどのように見えるかを定義します。上記の例では、Inputクラスを定義しました。名前は何でもかまいません。このクラスには、データセット内の列の名前と一致する名前が定義されたいくつかのプロパティがあります。 LoadColumn属性は、CSVファイルのどの列がこのデータをロードするかを示します。列の1つにLabel属性が割り当てられていることに注意してください。これは、予測される値を含む列の名前です。この場合、最後の購入/販売の価格を含む列です。モデルの出力は、不動産価格の予測です。出力については、Outputという個別のクラスを定義し、その中にPrice変数を作成します。変数名は任意ですが、その属性は重要です：ColumnName。文字列値を読み取るときにさまざまなトリックを実行するライブラリは好きではありませんが、この動作はここで許可されています。この場合、ColumnNameはスコアのみで、他の値に対しては例外がスローされます。この属性は、結果のDataViewのスコア列が、出力クラスの対応する変数に関連付けられる必要があることを示します。その他の値の場合、例外がスローされます。この属性は、結果のDataViewのスコア列が、出力クラスの対応する変数に関連付けられる必要があることを示します。その他の値の場合、例外がスローされます。この属性は、結果のDataViewのスコア列が、出力クラスの対応する変数に関連付けられる必要があることを示します。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Cc    </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  </a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルを作成し、トレーニングしてから実行するコードを考えてみましょう。新しいMLContextオブジェクトを作成します。これを思い出して、必要なすべてのAPIへのアクセスを提供します。このオブジェクトを作成するときに、乱数ジェネレーターの初期値を指定できます。多くの一般的なPythonライブラリでは、同じモデルを同じデータセットで何度もトレーニングできます。これらのライブラリは作業用に乱数を生成するため、結果は新しくなります。 Kerasでは、このモデルの動作を変更する方法はすぐには明確ではありません。これを行うには、問題の解決策が10行のコードの形式で提供されているStack Overflowに移動し、このコードを自分にコピーします。 ML.NETはこの手順を大幅に簡素化し、同じ入力で同じ結果を簡単に得ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PacificHeights.csvファイルが転送されるLoadFromTextFileメソッドを使用してDataViewを作成します。このファイルには、トレーニングと検証のための個別のデータセットがないため、作成する必要があります。これは、TrainTestSplitメソッドを使用して行われ、データの80％がトレーニングに、20％が検証に使用されます。ソースデータセットには、住居のタイプ（マンション、別荘、アパート）を示すUseCodeという列があります。これらの値はカテゴリ型であるため、ユニタリエンコーディングを実行する必要があります。これを行うには、OneHotEncodingメソッドを呼び出して、対応する定性値の列を示します（UseCode）。次に、Concatenateを呼び出して、独立変数の値を含む列を指定します。この行の最後の呼び出しは、モデルをトレーニングするためのFast Forestアルゴリズムを選択します。pipeline.fit（）メソッドを呼び出すと、モデルのトレーニングが開始されます。私たちが使用するデータセットでは、奇数行が400しかありません-トレーニングは非常に速く通過します。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デモ付きのビデオへのリンク</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
結果として、R2は0.74であり、それほど悪くはありません。</font><font style="vertical-align: inherit;">この場合、交差検定の結果による指標R2は低くなります。つまり、交差検定がない場合、この指標は過大評価されます。</font><font style="vertical-align: inherit;">モデルが予測した価格は、実際の価格にかなり近いことがわかりました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">評価と予測</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
評価には、MLContextクラスのオブジェクトのcontext.Regression.Evaluateメソッドを使用します。</font><font style="vertical-align: inherit;">主要な指標として、R2を選択しました。</font><font style="vertical-align: inherit;">範囲は0〜1で、1は最大精度に対応します。</font><font style="vertical-align: inherit;">context.Regression.CrossValidateメソッドを使用すると、モデルの精度をより現実的に把握できます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デモへの</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンクリポジトリへのリンク。</font><font style="vertical-align: inherit;">行48</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予測に移りましょう。</font><font style="vertical-align: inherit;">作成された（理想的に検証された）モデルを使用して予測を行うには、CreatePredictionEngineメソッドを呼び出す必要があります。</font><font style="vertical-align: inherit;">このメソッドのパラメーターとして、モデルの入力データと出力データのプロパティをそれぞれ定義する入力オブジェクトと出力オブジェクトが導入されています。</font><font style="vertical-align: inherit;">この入力オブジェクトを作成し、必要な値をそのプロパティに割り当て、最後に、CreatePredictionEngineによって返されたオブジェクトの.Predictメソッドを呼び出します。</font><font style="vertical-align: inherit;">このパターンはML.NETで広く使用されています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まとめる</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ML.NETの基本的な使い方を学びました。 ML.NETは強い型付けを使用します。これにより、モデルのトレーニングに使用されるデータの形式とモデルの出力形式の両方を指定できます。検討した例の場合、モデルの結果は、元のデータセットのLastSoldPrice列に基づいて予測される浮動小数点のPrice値です。この列はラベルとして指定されています。 MLContextクラスのオブジェクトを作成し、ソースデータを含むCSVファイルに基づいてDataViewを作成しました。次に、トレーニングとモデルの検証のために、このデータセットを80/20の比率で分割しました。データには住居のタイプを示すカテゴリ値を持つ列が含まれていたため、ユニタリエンコードを実行しました。 Concatenateメソッドを使用して、実行するモデルトレーニングに基づいて列を指定しました。その後、これらのモデルはFast Forestアルゴリズムを使用する必要があります。トレーニング自体は.Fit（）メソッドによって呼び出されました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分類モデル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機械学習には、分類モデルという別の種類のモデルがあります。</font><font style="vertical-align: inherit;">このようなモデルは、電子メールメッセージがスパムかどうかを判断するために使用されます。</font><font style="vertical-align: inherit;">2つの可能なクラスのみが分類されるこのようなモデルは、バイナリ分類モデルと呼ばれます。</font><font style="vertical-align: inherit;">別の例である光学式文字認識は、約20年前の機械学習の最も初期のアプリケーションの1つでした。</font><font style="vertical-align: inherit;">クラスの可能な数は認識されなければならない文字の数に等しいので、これはマルチクラス分類です。</font><font style="vertical-align: inherit;">このようなモデルでは、少し異なる学習アルゴリズムが使用されます。</font><font style="vertical-align: inherit;">ML.NETには、一般的に使用されるいくつかの異なるバイナリ分類アルゴリズムがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xn/id/j9/xnidj9qfxrvwgup0cohq5c21mhy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのアルゴリズムのクラスは上記にリストされています。</font><font style="vertical-align: inherit;">また、回帰モデルの場合と同様に、分類モデルはトレーニングの完了後にチェックする必要があります。</font><font style="vertical-align: inherit;">ここでモデルの精度を評価するための指標は、他のユーザーによって使用されます。</font><font style="vertical-align: inherit;">R2または二乗平均平方根誤差はありません。</font><font style="vertical-align: inherit;">代わりに、F1インジケーター、スコア曲線の下の面積インジケーター、混同行列などが適用されます。</font><font style="vertical-align: inherit;">これらはすべてML.NETで使用できます。計算には1行のコードしか必要ありません。</font><font style="vertical-align: inherit;">Evaluateメソッドを呼び出すと、プロパティに必要なすべてのメトリックが格納されているオブジェクトが返されます。</font><font style="vertical-align: inherit;">回帰モデルと同様に、分類モデルを使用して交差検証を実行できます。</font><font style="vertical-align: inherit;">その後、再び、モデルを説明するインジケーターをプロパティに含むオブジェクトを取得します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テキストのベクトル化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機械学習モデルは数値でのみ機能します。データセット内のテキストは、カテゴリの値の形式、たとえば犬の品種や車のブランドなどの形式である場合があります。多くの場合、データには文全体と段落全体が含まれることがあります。電子メールメッセージを分類するタスクの場合、メッセージテキストをベクトル、つまりゼロと1のセットに変換する必要があります。ここでは、単一のエンコーディングは役に立ちません。この場合、ほとんどの場合、ベクトル化が使用されます。この場合、テキストはいくつかの変換を受けます。完全に小文字に翻訳され、意味的負荷の小さい単語は削除されます（英語では、たとえば「the」または「that」です）。クリアされたテキストに基づいて、ゼロと1のテーブルが作成されます。このテーブルには、一意の単語または単語の組み合わせごとに個別の列があります。そのようなテーブルは巨大なサイズに達する可能性があります-テキストが5万の異なる単語を使用する場合、テーブルには5万の列があります。そのようなテキスト（メッセージなど）が100万ある場合、100万行になります。コンピュータの場合、これらはそれほど大きな数ではありません。 ML.NETには、これらすべてのアクションを自動的に実行するFeaturizeTextメソッドがあります。それが実行されると、テキストは9つの異なる変換を通過します。他のほとんどのライブラリでは、これは手動で行う必要があります。それが実行されると、テキストは9つの異なる変換を通過します。他のほとんどのライブラリでは、これは手動で行う必要があります。それが実行されると、テキストは9つの異なる変換を通過します。他のほとんどのライブラリでは、この変換は手動で行う必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FeaturizeTextメソッドの操作</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機械学習に興味がある場合は、テキストの調性の分析について聞いたことがあるでしょう。</font><font style="vertical-align: inherit;">モデルは映画レビューまたは製品レビューを分析し、このテキストを0〜1の範囲で評価できます。1は正の評価、0は負の評価です。</font><font style="vertical-align: inherit;">私の息子はデータサイエンスに従事しており、1年半前に高校を卒業し、卒業の6か月前に世界中でペット用品を販売する会社で働いていました。</font><font style="vertical-align: inherit;">彼の最初のタスクの1つは、テキストの調性を分析するためのモデルを作成することでした。これは、会社またはその製品の否定的なレビューがTwitterに表示された場合にマーケティング部門に警告することができます。</font><font style="vertical-align: inherit;">テキストの調性の分析は非常に簡単です。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">リポジトリへの</font></a></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デモリンクでビデオにリンク</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">行21</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような分析の例を考えてみましょう。私たちはYelpで1000のことわざのセットを持っています。これはかなり小さなデータセットです。コメントが肯定的であるか否定的であるかに応じて、各ステートメントにはすでに0または1の評価が割り当てられています。これに基づいて、0〜1の評価をテキストの任意の行に割り当てることができるバイナリ分類モデルを作成します。MLContextクラスのオブジェクトを作成し、TSVファイルからDataViewをロードして、データセットを2つの部分に分割します。チェック。その後、.FeaturizeTextメソッドを呼び出します。これは、分析されたテキスト内の一意の単語ごとに個別の列を持つ巨大なデータセットを作成します。アルゴリズムとして高速ツリーを使用します（このバージョンのアルゴリズムは、回帰ではなく分類を実行します）。この問題を解決するためにいくつかのアルゴリズムを試しましたが、これは比較的良い結果をもたらしました。 .Fit（）メソッドは、モデルのトレーニングを実行します。その後、モデルの評価と相互評価を行います。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<img src="https://habrastorage.org/webt/bu/mz/eo/bumzeop2hpx2uc5kan0ttyfqiw8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「料理は素晴らしい、サービスは素晴らしい」というフレーズを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">紹介するビデオへのリンク</font></a><font style="vertical-align: inherit;">は0.996と評価され、非常に高かった。</font><font style="vertical-align: inherit;">「ここに犬を連れて行きません」というフレーズの評価は0.01、つまり非常に低くなっています。</font><font style="vertical-align: inherit;">結果はかなり正確です。</font><font style="vertical-align: inherit;">ML.NETほど高速な正確な色調分析モデルを作成するライブラリはありません。</font><font style="vertical-align: inherit;">これはすべてC＃で行うことができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スパム検出 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用されるデータセットについてのいくつかの言葉。最近機械学習が急速に成長した理由は、5年または10年前よりも多くのデータを利用できるようになったためです。過去には、エンロンを取り巻くスキャンダルがあり、その結果、何人かの指導者が刑務所に入れられました。この会社からの何百万もの電子メールが米国州の所有物になり、公開されています。研究者たちはこの大量のメッセージを調べ、全員に1または0、つまりスパムか非スパムかの評価を割り当てました。この作業のおかげで、非常に正確なスパム検出モデルをトレーニングできるようになりました。これは、公開されている唯一のスパム検出データセットではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモデルでは、前の例とは異なるアルゴリズムを使用します。私はいくつかの異なるアルゴリズムを試しましたが、これが最良の結果をもたらしました。トレーニング済みのモデルである私は、いくつかのテストメッセージを送信しました。その1つは明らかなスパムでした。後者の推定値は約0.1でした。つまり、アルゴリズムは非常に正確な結果を提供します。 20年前、このタスクは機械学習の最初のアプリケーションの1つになりました。これ以前は、ルールベースのシステムを使用してスパムを検出していたため、簡単に回避できました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンピュータビジョンの最新の進歩により、機械学習とAIの範囲は大幅に拡大しました。機械部品を製造する会社で働いているとします。組立ラインから外れた部品が不良品かどうかを写真から判別できるプログラムを書く必要があります。 20年前はこの問題はほとんど解決できませんでした。10年前は非常に問題がありましたが、今日では画像分類の分野の進歩により解決されています。画像分類は、プログラムによって画像内のオブジェクトを認識するプロセスです。画像分類を実行するモデルのほとんどは、畳み込みニューラルネットワークです。画像を分類する際の主な難しさについてもっと読む。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結婚を詳細に検出する例では、プログラムの作成は非常に現実的ですが、それをトレーニングするには、GPUを備えた非常に大規模で高価なHPCクラスターが必要になります。 Microsoft ResearchまたはFacebookの研究者が非常に複雑な画像認識モデルを作成できるのは、NVIDIA GPUを備えた数千のノードを持つクラスターにアクセスできるためです。このような設備にアクセスできなければ、通常の方法でネットワークをトレーニングして欠陥部品を認識することは不可能です。学習を移転することでこの困難を回避することができます。 Microsoft、Google、FacebookはすでにTensorFlowを使用して非常に複雑な進化型ニューラルネットワークを作成し、GitHubに公開しています。これらのネットワークは非常に大きく、最大100メガバイトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トレーニングを転送すると、そのようなネットワークから分類レベルを削除して、ニーズに合わせることができます。このようなネットワークを50〜100枚の画像で再トレーニングすると、90％を超える精度を得ることができます。 Scikitはこれを行うことができません。 Kerasはそのような機会を提供しますが、そこは気味が悪いようです。 ML.NETでは、ニューラルネットワークを最初から作成することはまだできません。ただし、Microsoft、Google、または他の誰かが作成した既製のニューラルネットワークを再トレーニングできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
米国では、かなり人気のあるシリコンバレーシリーズがあります。このシリーズには、Not a Hot Dogアプリを特集したエピソードがありました。画像の食べ物がホットドッグかどうかを判断できます。ここでのタスクは実際には非常に複雑であり、10年前は解決できなかったでしょう。私の例では、Googleが作成した畳み込みニューラルネットワークを使用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あまり知られていないML.NET TensorFlowModelクラスを使用して、20の画像でこのモデルを再トレーニングしました。これで、画像にホットドッグが存在するかどうかを判別できます。その後、新しいバージョンのモデルをハードディスクにZIPファイルとして保存するメソッドを呼び出しました。次に、このモデルを使用する小さなWPFアプリケーションを作成しました。ハードドライブに保存されるため、学習するたびに時間を無駄にせず、すぐにファイルからプログラムにロードできます。アプリケーションに画像をダウンロードし、モデルを使用して画像にホットドッグが存在するかどうかを判断できます。普通のプログラマーのトレーニングを移さなければ、そのような問題を解決できるニューラルネットワークを作成することは不可能です。 ML.NETでは、他の人のニューラルネットワークを他の機械学習ライブラリよりも簡単に使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GitHubにはリポジトリがあり、Jeff Proiseがレポートで示したすべての例とその他の例を見つけることができます。</font><font style="vertical-align: inherit;">これらの例では、定期的にコードが更新されます。</font><font style="vertical-align: inherit;">リポジトリアドレス：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/jeffprosise/ML.NET</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext 2020 Piterは、6月15日から18日まで新しいオンライン形式で開催されます。</font><font style="vertical-align: inherit;">Jeff Prosezが</font><font style="vertical-align: inherit;">機械学習に関する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいレポートを発表</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">また、会議では、John Skeet（Stack Overflow全体の最初の人物、C＃in Depthの作成者）とScott Hanselman（最近のMicrosoft Buildで彼を覚えており、彼は開発者向けの新しいツールのデモを行いました）になります。</font><font style="vertical-align: inherit;">この夏の8つの会議すべて</font><font style="vertical-align: inherit;">の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チケット</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には、さらにクールな講演者が見られ</font><font style="vertical-align: inherit;">ます。</font></font></blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja495196/index.html">IBが「ダーウィン賞」、または愚かさ、ゴミ、騙しやすさ、およびそれらの結果についての7つのストーリーを持っている場合</a></li>
<li><a href="../ja495200/index.html">私たちは「ITスペシャリストは私たちの2020年を救うのでしょうか？」というクエストでOTUS誕生日を祝います。</a></li>
<li><a href="../ja495202/index.html">エンジニアリング特殊部隊：熱と寒さ</a></li>
<li><a href="../ja495204/index.html">1つの製品会社のIT管理モデル</a></li>
<li><a href="../ja495206/index.html">パニックおよびパンデミックに対するアジャイル。全員の行動計画：ビジネスを救うための7つのステップ</a></li>
<li><a href="../ja495210/index.html">ルネットの詐欺師がコロナウイルスにどのように反応したか</a></li>
<li><a href="../ja495212/index.html">Quarkusでのネイティブコンパイル-なぜ重要なのか</a></li>
<li><a href="../ja495214/index.html">誰もいないオフィス：リモートサイトでのゲーム開発</a></li>
<li><a href="../ja495216/index.html">リモートでの学習、交渉、コンサルティング-パート2：Vinteo Server-3か月の無料ビデオ会議</a></li>
<li><a href="../ja495220/index.html">太陽系は、形成直後に現在の構成を取得しました</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>