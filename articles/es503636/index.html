<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëßüèæ üèçÔ∏è ü§±üèæ ¬øQu√© tipo de carga en los servidores crea mecanismos de red? üè∞ üë®üèø‚Äçüé® üôçüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al analizar el funcionamiento del subsistema de red de servidores, generalmente se presta atenci√≥n a indicadores tales como la latencia, el rendimient...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>¬øQu√© tipo de carga en los servidores crea mecanismos de red?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/503636/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al analizar el funcionamiento del subsistema de red de servidores, generalmente se presta atenci√≥n a indicadores tales como la latencia, el rendimiento del sistema y la cantidad de paquetes que se pueden procesar por segundo (PPS, paquetes por segundo). Estos indicadores se utilizan para comprender bajo qu√© carga m√°xima puede funcionar la computadora en estudio. Y aunque estas m√©tricas son importantes y a menudo pueden decir mucho sobre el sistema, no proporcionan informaci√≥n sobre el impacto que tiene el procesamiento de paquetes de red en los programas que se ejecutan en el servidor. </font><font style="vertical-align: inherit;">
Este material tiene como objetivo estudiar la carga creada por los mecanismos de red en los servidores. En particular, hablaremos sobre cu√°nto tiempo de procesador puede "robar" la soluci√≥n a los problemas de red de varios procesos que se ejecutan en sistemas Linux.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/q_/0y/ya/q_0yyareydlakrio4dbunpbt8fu.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procesamiento de paquetes de red en Linux</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux procesa un n√∫mero significativo de paquetes en el contexto de cualquier proceso ejecutado por el procesador al momento de procesar la IRQ correspondiente. </font><font style="vertical-align: inherit;">El motor de contabilidad del sistema asignar√° los ciclos de procesador utilizados para esto a cualquier proceso que se est√© ejecutando actualmente. </font><font style="vertical-align: inherit;">Esto se har√° incluso si este proceso no tiene nada que ver con el procesamiento de paquetes de red. </font><font style="vertical-align: inherit;">Por ejemplo, un equipo </font></font><code>top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede indicar que un proceso parece estar utilizando m√°s del 99% de los recursos del procesador, pero de hecho el 60% del tiempo del procesador se gastar√° en procesar los paquetes. </font><font style="vertical-align: inherit;">Y esto significa que el proceso en s√≠, resolviendo sus propios problemas, usa solo el 40% de los recursos de la CPU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manejador entrante</font></font><code>net_rx_action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generalmente se realiza muy, muy r√°pido. Por ejemplo, en menos de 25 Œºs. (Estos datos se obtuvieron de mediciones usando eBPF. Si est√° interesado en los detalles, mire </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a> <code>net_rx_action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) El procesador puede procesar hasta 64 paquetes por instancia de NAPI (NIC o RPS) antes de posponer la tarea a otro ciclo de SoftIRQ. Uno tras otro, sin interrupci√≥n, pueden seguir hasta 10 ciclos de SoftIRQ, lo que demora aproximadamente 2 ms (puede obtener m√°s informaci√≥n al respecto leyendo </font></font><code>__do_softirq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Si el vector SoftIRQ, despu√©s de que ha pasado el n√∫mero m√°ximo de ciclos, o ha pasado el tiempo, todav√≠a tiene problemas sin resolver, entonces la soluci√≥n de estos problemas se retrasa para la ejecuci√≥n en el hilo</font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU espec√≠fica. </font><font style="vertical-align: inherit;">Cuando esto sucede, el sistema resulta ser un poco m√°s transparente en el sentido de obtener informaci√≥n sobre la carga del procesador creada por las operaciones de red (aunque dicho an√°lisis se realiza suponiendo que se examina SoftIRQ, que est√° relacionado con el procesamiento de paquetes y no con otra cosa) . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una forma de obtener los indicadores anteriores es usar </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">sudo perf record -a \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:irq_handler_entry,irq:irq_handler_exit<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:softirq_entry --filter="vec == 3" \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:softirq_exit --filter="vec == 3"&nbsp; \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e napi:napi_poll \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- sleep 1<font></font>
<font></font>
sudo perf script<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ est√° el resultado:</font></font><br>
<br>
<pre><code class="plaintext hljs">swapper &nbsp; &nbsp; 0 [005] 176146.491879: irq:irq_handler_entry: irq=152 name=mlx5_comp2@pci:0000:d8:00.0<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491880:&nbsp; irq:irq_handler_exit: irq=152 ret=handled<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491880: &nbsp; &nbsp; irq:softirq_entry: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491942:&nbsp; &nbsp; &nbsp; &nbsp; napi:napi_poll: napi poll on napi struct 0xffff9d3d53863e88 for device eth0 work 64 budget 64<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491943:&nbsp; &nbsp; &nbsp; irq:softirq_exit: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491943: &nbsp; &nbsp; irq:softirq_entry: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491971:&nbsp; &nbsp; &nbsp; &nbsp; napi:napi_poll: napi poll on napi struct 0xffff9d3d53863e88 for device eth0 work 27 budget 64<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491971:&nbsp; &nbsp; &nbsp; irq:softirq_exit: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.492200: irq:irq_handler_entry: irq=152 name=mlx5_comp2@pci:0000:d8:00.0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, el procesador est√° inactivo (de ah√≠ la aparici√≥n de entradas </font></font><code>swapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para el proceso), se llama a IRQ para la cola Rx en la CPU 5, se procesa SoftIRQ dos veces, se procesan 64 paquetes primero, luego 27. La siguiente IRQ se llama despu√©s de 229 Œºs y comienza el ciclo nuevamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estos datos se obtuvieron en un sistema inactivo. Pero en el procesador, se puede realizar cualquier tarea. En este caso, se produce la secuencia de eventos anterior, interrumpiendo esta tarea y realizando tareas IRQ / SoftIRQ. Al mismo tiempo, la contabilidad del sistema atribuye al proceso interrumpido la carga creada por el procesador. Como resultado, las tareas de procesamiento de paquetes de red generalmente est√°n ocultas de las herramientas convencionales de monitoreo de carga del procesador. Se ejecutan en el contexto de alg√∫n proceso seleccionado al azar, en el contexto del "proceso de v√≠ctima". Esto nos lleva a algunas preguntas. ¬øC√≥mo estimar el tiempo durante el cual se interrumpe el proceso para el procesamiento de paquetes? ¬øC√≥mo comparar 2 soluciones de red diferentes para comprender cu√°l de ellas tiene un efecto menor en varias tareas resueltas en una computadora?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando se utilizan mecanismos RSS, RPS, RFS, el procesamiento de paquetes generalmente se distribuye entre los n√∫cleos del procesador. </font><font style="vertical-align: inherit;">Por lo tanto, la secuencia de procesamiento de paquetes anterior est√° relacionada con cada CPU espec√≠fica. </font><font style="vertical-align: inherit;">A medida que aumenta la velocidad de llegada de paquetes (creo que podemos hablar de velocidades de 100,000 paquetes por segundo y m√°s), cada CPU tiene que procesar miles o decenas de miles de paquetes por segundo. </font><font style="vertical-align: inherit;">El procesamiento de tantos paquetes afectar√° inevitablemente a otras tareas realizadas en el servidor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere una forma de evaluar este efecto.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deshabilitar el procesamiento de paquetes distribuidos</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comenzar, detengamos el procesamiento distribuido de paquetes deshabilitando RPS y configurando reglas de control de flujo destinadas a organizar el procesamiento de todos los paquetes relacionados con una direcci√≥n MAC espec√≠fica en la √∫nica CPU que conocemos. </font><font style="vertical-align: inherit;">Mi sistema tiene 2 NIC agregadas en una configuraci√≥n 802.3ad. </font><font style="vertical-align: inherit;">Las tareas de red se asignan a una sola m√°quina virtual que se ejecuta en una computadora. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RPS en adaptadores de red est√° deshabilitado de la siguiente manera:</font></font><br>
<br>
<pre><code class="plaintext hljs">for d in eth0 eth1; do<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;find /sys/class/net/${d}/queues -name rps_cpus |<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;while read f; do<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 0 | sudo tee ${f}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;done<font></font>
done<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, configuramos las reglas de control de flujo para garantizar que los paquetes ingresen a la m√°quina virtual de prueba utilizando una sola CPU:</font></font><br>
<br>
<pre><code class="plaintext hljs">DMAC=12:34:de:ad:ca:fe<font></font>
sudo ethtool -N eth0 flow-type ether dst ${DMAC} action 2<font></font>
sudo ethtool -N eth1 flow-type ether dst ${DMAC} action 2<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deshabilitar RPS y usar reglas de control de flujo nos permite garantizar que todos los paquetes destinados a nuestra m√°quina virtual se procesen en la misma CPU. </font><font style="vertical-align: inherit;">Para asegurarse de que los paquetes se env√≠an a la cola a la que deben enviarse, puede usar un comando como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ethq</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Luego puede averiguar a qu√© CPU pertenece esta cola </font></font><code>/proc/interrupts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En mi caso, el turno 2 se procesa por medio de la CPU 5.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comando de velocidad Openssl</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podr√≠a usar utilidades </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font><font style="vertical-align: inherit;">analizar los tiempos de ejecuci√≥n de SoftIRQ responsables del procesamiento del tr√°fico entrante </font></font><code>bpf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero este enfoque es bastante complicado. Adem√°s, el proceso de observaci√≥n en s√≠ definitivamente afecta los resultados. Una soluci√≥n mucho m√°s simple y comprensible es identificar la carga creada por las operaciones de red en el sistema utilizando alguna tarea, una que cree una carga conocida en el sistema. Por ejemplo, este es un comando </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizado para probar el rendimiento de OpenSSL. Esto le permitir√° descubrir cu√°ntos recursos de procesador obtiene el programa en realidad y compararlo con la cantidad de recursos que se supone que recibir√° (esto ayudar√° a determinar cu√°ntos recursos se gastan en tareas de red).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El equipo es </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">casi 100% un equipo de espacio de usuario. Si lo vincula a una determinada CPU, entonces, durante la ejecuci√≥n de las pruebas, utiliza todos sus recursos disponibles. El equipo trabaja configurando el temporizador en el intervalo especificado (aqu√≠, por ejemplo, para facilitar los c√°lculos, lleva 10 segundos), ejecutando la prueba y luego, cuando se activa el temporizador, us√°ndolo </font></font><code>times</code><code>()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para averiguar cu√°nto tiempo de procesador realmente tuvo el programa. Desde el punto de vista </font></font><code>syscall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se ve as√≠:</font></font><br>
<br>
<pre><code class="plaintext hljs">alarm(10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0<font></font>
times({tms_utime=0, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726601344<font></font>
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---<font></font>
rt_sigaction(SIGALRM, ...) = 0<font></font>
rt_sigreturn({mask=[]}) = 2782545353<font></font>
times({tms_utime=1000, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726602344<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, resulta que </font></font><code>alarm()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se hicieron muy pocas llamadas al sistema </font><font style="vertical-align: inherit;">entre llamar </font><font style="vertical-align: inherit;">y verificar los resultados. Si el programa no se interrumpi√≥, o se interrumpi√≥ muy raramente, el tiempo </font></font><code>tms_utime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coincidir√° con el tiempo de la prueba (en este caso, 10 segundos). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que esta es una prueba realizada exclusivamente en el espacio del usuario, cualquier hora del sistema que aparezca </font></font><code>times()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significar√° una carga adicional en el sistema. Resulta que, aunque </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este es un proceso que se ejecuta en la CPU, la misma CPU puede estar ocupada con otra cosa. Por ejemplo, procesando paquetes de red:</font></font><br>
<br>
<pre><code class="plaintext hljs">alarm(10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0<font></font>
times({tms_utime=0, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726617896<font></font>
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---<font></font>
rt_sigaction(SIGALRM, ...) = 0<font></font>
rt_sigreturn({mask=[]}) = 4079301579<font></font>
times({tms_utime=178, tms_stime=571, tms_cutime=0, tms_cstime=0}) = 1726618896<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ puede ver que fue </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posible trabajar en el procesador durante 7,49 segundos (178 + 571 en unidades de medida correspondientes a 0,01 s). </font><font style="vertical-align: inherit;">Pero al mismo tiempo 5,71 s. </font><font style="vertical-align: inherit;">este intervalo est√° representado por la hora del sistema. </font><font style="vertical-align: inherit;">Como no est√° </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ocupado con ning√∫n negocio en el espacio del kernel, esto significa que 5,71 s. </font><font style="vertical-align: inherit;">- Este es el resultado de una carga adicional en el sistema. </font><font style="vertical-align: inherit;">Es decir, este es el momento en que el proceso fue "robado" para satisfacer las necesidades del sistema.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usar el comando de velocidad openssl para detectar la carga del sistema causada por mecanismos de red</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora que hemos descubierto c√≥mo funciona el equipo </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, veremos los resultados que produce en un servidor pr√°cticamente inactivo:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ taskset -c 5 openssl speed -seconds 10 aes-256-cbc &gt;/dev/null<font></font>
Doing aes-256 cbc for 10s on 16 size blocks: 66675623 aes-256 cbc's in 9.99s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 18096647 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 4607752 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 1162429 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 145251 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 72831 aes-256 cbc's in 10.00s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, se nos informa que el programa pasa de 9.99 a 10 segundos para procesar bloques de diferentes tama√±os. Esto confirma que los mecanismos del sistema no toman tiempo del procesador del programa. Ahora, usando </font></font><code>netperf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cargaremos el servidor procesando paquetes que provienen de dos fuentes. Ejecute la prueba nuevamente:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ taskset -c 5 openssl speed -seconds 10 aes-256-cbc &gt;/dev/null<font></font>
Doing aes-256 cbc for 10s on 16 size blocks: 12061658 aes-256 cbc's in 1.96s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 3457491 aes-256 cbc's in 2.10s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 893939 aes-256 cbc's in 2.01s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 201756 aes-256 cbc's in 1.86s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 25117 aes-256 cbc's in 1.78s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 13859 aes-256 cbc's in 1.89s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los resultados son muy diferentes de los obtenidos en un servidor inactivo. Se espera que cada una de las pruebas se ejecute en 10 segundos, pero </font></font><code>times()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informa que el tiempo de ejecuci√≥n real es de 1.78 a 2.1 segundos. Esto significa que el tiempo restante, que var√≠a de 7,9 a 8,22 segundos, se dedic√≥ al procesamiento de los paquetes, ya sea en el contexto del proceso </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o en </font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Echemos un vistazo a lo que dar√° el equipo </font></font><code>top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al analizar el lanzamiento que acaba de completar </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="plaintext hljs">PID USER&nbsp; &nbsp; &nbsp; PR&nbsp; NI&nbsp; &nbsp; VIRT&nbsp; &nbsp; RES&nbsp; &nbsp; SHR S&nbsp; %CPU %MEM &nbsp; &nbsp; TIME+ COMMAND&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P&nbsp;<font></font>
&nbsp;8180 libvirt+&nbsp; 20 &nbsp; 0 33.269g 1.649g 1.565g S 279.9&nbsp; 0.9&nbsp; 18:57.81 qemu-system-x86 &nbsp; &nbsp; 75<font></font>
&nbsp;8374 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 99.4&nbsp; 0.0 &nbsp; 2:57.97 vhost-8180&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 89<font></font>
&nbsp;1684 dahern&nbsp; &nbsp; 20 &nbsp; 0 &nbsp; 17112 &nbsp; 4400 &nbsp; 3892 R&nbsp; 73.6&nbsp; 0.0 &nbsp; 0:09.91 openssl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;38 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 26.2&nbsp; 0.0 &nbsp; 0:31.86 ksoftirqd/5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ podr√≠a pensar que </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliza aproximadamente el 73% de los recursos de la CPU 5, y </font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se obtienen los recursos restantes. </font><font style="vertical-align: inherit;">Pero en realidad, en el contexto </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el procesamiento de una cantidad tan grande de paquetes se realiza que el programa en s√≠ solo toma entre el 18 y el 21% del tiempo del procesador para resolver sus problemas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si reduce la carga de la red a 1 flujo, </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene la </font><font style="vertical-align: inherit;">sensaci√≥n de que </font><font style="vertical-align: inherit;">se est√° consumiendo el 99% de los recursos del sistema.</font></font><br>
<br>
<pre><code class="plaintext hljs">&nbsp;&nbsp;PID USER&nbsp; &nbsp; &nbsp; PR&nbsp; NI&nbsp; &nbsp; VIRT&nbsp; &nbsp; RES&nbsp; &nbsp; SHR S&nbsp; %CPU %MEM &nbsp; &nbsp; TIME+ COMMAND&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P<font></font>
&nbsp;8180 libvirt+&nbsp; 20 &nbsp; 0 33.269g 1.722g 1.637g S 325.1&nbsp; 0.9 166:38.12 qemu-system-x86 &nbsp; &nbsp; 29<font></font>
44218 dahern&nbsp; &nbsp; 20 &nbsp; 0 &nbsp; 17112 &nbsp; 4488 &nbsp; 3996 R&nbsp; 99.2&nbsp; 0.0 &nbsp; 0:28.55 openssl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
&nbsp;8374 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 64.7&nbsp; 0.0&nbsp; 60:40.50 vhost-8180&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 55<font></font>
&nbsp;&nbsp;&nbsp;38 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 S &nbsp; 1.0&nbsp; 0.0 &nbsp; 4:51.98 ksoftirqd/5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero en realidad resulta que el programa que se ejecuta en el espacio del usuario obtiene, de los 10 segundos esperados, solo unos 4 segundos:</font></font><br>
<br>
<pre><code class="plaintext hljs">Doing aes-256 cbc for 10s on 16 size blocks: 26596388 aes-256 cbc's in 4.01s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 7137481 aes-256 cbc's in 4.14s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 1844565 aes-256 cbc's in 4.31s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 472687 aes-256 cbc's in 4.28s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 59001 aes-256 cbc's in 4.46s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 28569 aes-256 cbc's in 4.16s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las herramientas convencionales de monitoreo de procesos indican que el programa usa casi todos los recursos del procesador, pero en realidad resulta que el 55-80% de los recursos de la CPU se gastan en el procesamiento de paquetes de red. </font><font style="vertical-align: inherit;">El rendimiento del sistema al mismo tiempo se ve excelente (m√°s de 22 Gb / s por l√≠nea de 25 Gb / s), pero esto tiene un tremendo impacto en los procesos que se ejecutan en este sistema.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumen</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ examinamos un ejemplo de c√≥mo los mecanismos de procesamiento de paquetes "roban" los relojes del procesador de un punto de referencia simple y no muy importante. </font><font style="vertical-align: inherit;">Pero en un servidor real, los procesos que se ven afectados de manera similar pueden ser cualquier cosa. </font><font style="vertical-align: inherit;">Estos pueden ser procesadores virtuales, subprocesos de emulador, subprocesos vhost de m√°quinas virtuales. </font><font style="vertical-align: inherit;">Estos pueden ser diferentes procesos del sistema, cuyo impacto puede tener un impacto diferente en el rendimiento de estos procesos y de todo el sistema. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øConsidera, analizando sus servidores, el impacto en el rendimiento real de la carga asociada con las operaciones de red?</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es503624/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 416 (18-24 de mayo de 2020)</a></li>
<li><a href="../es503626/index.html">Pruebas. Errores de certificaci√≥n ISTQB o resuelve un mill√≥n de ejemplos</a></li>
<li><a href="../es503630/index.html">Gafas de realidad aumentada: ¬ød√≥nde estamos ahora?</a></li>
<li><a href="../es503632/index.html">1000 y 1 publicaci√≥n: feliz cumplea√±os, Habr ‚ù§</a></li>
<li><a href="../es503634/index.html">5 interesantes hallazgos de JavaScript realizados en el c√≥digo fuente de Vue</a></li>
<li><a href="../es503638/index.html">6 h√°bitos √∫tiles que, sorprendentemente, solo unos pocos programadores tienen</a></li>
<li><a href="../es503642/index.html">C√≥mo ingresar a LinkedIn, Facebook, Google en Silicon Valley</a></li>
<li><a href="../es503648/index.html">¬øQu√© significa la salida de "ss -s"</a></li>
<li><a href="../es503650/index.html">VKCup 2020 Etapa I. Un largo camino</a></li>
<li><a href="../es503652/index.html">Eventos digitales en Mosc√∫ del 25 al 31 de mayo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>