<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌪️ 🏅 ⤵️ PostgreSQL：たった1つの変更で生産性が9倍に向上した方法 🚬 🐓 😗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="個人の財政を管理するように設計された実際のプロジェクトの中心には、独自のデータ同期システムがあります。最近、私はプロジェクトに完全なエンドツーエンドの暗号化を実装しました（ただし、まだ暗号化されていません）。この仕事は、システムの内部メカニズムのパフォーマンスを研究するために私に刺激を与えました。今...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL：たった1つの変更で生産性が9倍に向上した方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/504620/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">個人の財政を管理するように設計され</font><font style="vertical-align: inherit;">た</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトの中心に</font><font style="vertical-align: inherit;">は、独自のデータ同期システムがあります。</font><font style="vertical-align: inherit;">最近、私はプロジェクトに完全なエンドツーエンドの暗号化を実装しました（ただし、まだ暗号化されていません）。</font><font style="vertical-align: inherit;">この仕事は、システムの内部メカニズムのパフォーマンスを研究するために私に刺激を与えました。</font><font style="vertical-align: inherit;">今日は、プロジェクトのパフォーマンスを9〜10倍向上させることができるPostgreSQLの1つの機能についてお話します。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/en/vx/ag/envxagx-4vx97fcie_xoqxjgche.jpeg"></a><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題169000の投稿</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際は完全にローカルなアプリケーションであり、同期は競合のない複製データ型（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CRDT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を使用してバックグラウンドで実行され</font><font style="vertical-align: inherit;">ます。つまり、プロジェクトのサーバー側は非常に単純です。その主なタスクは、クライアントへの「メッセージ」を保存およびロードすることです。すべてのデータ同期コードに必要なJavaScriptは約200行だけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同期を高速化するには、大量のメッセージを処理する必要があります。実際、1つの奇妙なことが一度起こりました。新しいユーザーが1日に169,000件のメッセージを生成しました。これは、通常の値から大幅に逸脱する指標です。たとえば、1000のトランザクションをシステムにインポートすると、約6,000のメッセージが生成されます。そして、これは完全に正常な値であり、1人のユーザーが1日に生成するメッセージの平均数を超えています。これらの169000メッセージは、APIを使用して大量のデータをシステムにインポートしようとしたときに生成されたと思います。我々は持っている</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なるAPI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同様の目的のために。しかし、非常に多くのメッセージがたくさんあります。そこで、それらを実際のパフォーマンス調査のベンチマークに変えることにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムに169,000通のメッセージを渡して、サーバーを「ハング」させようとしました。</font><font style="vertical-align: inherit;">リクエストはタイムアウトにより拒否されましたが、サーバーはまだメッセージを把握しようとしており、他のすべてを遅くしていました。</font><font style="vertical-align: inherit;">これが問題であることがすぐにわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージはPostgreSQLデータベースに保存されます。</font><font style="vertical-align: inherit;">対応するテーブルは次のようになります。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> messages_binary<font></font>
&nbsp;&nbsp;(<span class="hljs-type">timestamp</span> <span class="hljs-type">TEXT</span>,<font></font>
&nbsp;&nbsp;&nbsp;group_id <span class="hljs-type">TEXT</span>,<font></font>
&nbsp;&nbsp;&nbsp;is_encrypted <span class="hljs-type">BOOLEAN</span>,<font></font>
&nbsp;&nbsp;&nbsp;content <span class="hljs-type">bytea</span>,
&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">PRIMARY KEY</span>(<span class="hljs-type">timestamp</span>, group_id));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テーブルには、小さなバイナリBLOB、タイムスタンプ、およびこれらのBLOBが属する「同期グループ」が含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースに膨大な数の行を追加しようとしたため、サーバーが過負荷になりました。</font><font style="vertical-align: inherit;">残念ながら、データベースにメッセージを追加するとき、多数の演算子を含む1つの要求を単純に実行することはできません</font></font><code>INSERT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">CRDTの機能は、データベースの操作にいくつかの制限を課します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージは複製できません（フィールドで識別されます</font></font><code>timestamp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font></li>
<li><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハッシュツリー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を更新する必要があり</font><font style="vertical-align: inherit;">ます。この手順は、メッセージがデータベースに追加されているかどうかによって異なります。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の制限は扱いやすかった。</font></font><code>timestamp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主キー</font><font style="vertical-align: inherit;">を作成したので</font><font style="vertical-align: inherit;">、ビュークエリを実行できます</font></font><code>INSERT INTO messages_binary (...) VALUES (...) ON CONFLICT DO NOTHING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この式</font></font><code>ON CONFLICT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、競合が発生したときに何もする必要がないことをシステムに伝えます。</font><font style="vertical-align: inherit;">主キーの競合は、既存のレコードの重複で発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の制限は、すでにはるかに深刻な問題でした。</font><font style="vertical-align: inherit;">行がテーブルに挿入されたかどうかを知るために、データ書き込み操作の結果を取得する必要があります。</font><font style="vertical-align: inherit;">行がテーブルに追加された場合、ハッシュツリーを更新する必要がありました。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">if</span>(inserted) {<font></font>
&nbsp;&nbsp;trie = merkle.<span class="hljs-keyword">insert</span>(trie, <span class="hljs-type">Timestamp</span>.parse(msg.timestamp));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システム内の各タイムスタンプが1回だけハッシュツリーに追加されることが非常に重要です。このツリーは、システムを均一な状態に維持する責任があり、データハッシュを処理するために使用されます。タイムスタンプがツリーに1回だけ追加されることを確認しないと、ハッシュ（および検証）が正しくないことが判明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベース更新コード全体は、次のようになります（ここでは、いくつかの抽象化が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node-postgresで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用されてい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<pre><code class="pgsql hljs">await runQuery(<span class="hljs-string">'BEGIN'</span>);<font></font>
let trie = await getMerkle(runQuery, groupId);<font></font>
<span class="hljs-keyword">for</span> (let message <span class="hljs-keyword">of</span> messages) {<font></font>
&nbsp;&nbsp;let <span class="hljs-type">timestamp</span> = message.getTimestamp();<font></font>
&nbsp;&nbsp;let isEncrypted = message.getIsencrypted();<font></font>
&nbsp;&nbsp;let content = message.getContent();<font></font>
&nbsp;&nbsp;let { changes } = await runQuery(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;`<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> messages_binary (<span class="hljs-type">timestamp</span>, group_id, is_encrypted, content)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">VALUES</span> (<span class="hljs-meta">$1</span>, <span class="hljs-meta">$2</span>, <span class="hljs-meta">$3</span>, <span class="hljs-meta">$4</span>) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">CONFLICT</span> <span class="hljs-keyword">DO</span> <span class="hljs-keyword">NOTHING</span>`,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-type">timestamp</span>, groupId, isEncrypted, content]<font></font>
&nbsp;&nbsp;);<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">if</span> (changes === <span class="hljs-number">1</span>) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;//   <font></font>
&nbsp;&nbsp;&nbsp;&nbsp;trie = merkle.<span class="hljs-keyword">insert</span>(trie, <span class="hljs-type">Timestamp</span>.parse(<span class="hljs-type">timestamp</span>));<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
await runQuery(<font></font>
&nbsp;&nbsp;`<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> messages_merkles (group_id, merkle)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">VALUES</span> (<span class="hljs-meta">$1</span>, <span class="hljs-meta">$2</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">ON</span> <span class="hljs-keyword">CONFLICT</span> (group_id) <span class="hljs-keyword">DO</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">SET</span> merkle = <span class="hljs-meta">$2</span>`,<font></font>
&nbsp;&nbsp;[groupId, <span class="hljs-type">JSON</span>.stringify(trie)]<font></font>
);<font></font>
await runQuery(<span class="hljs-string">'COMMIT'</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ほとんどの場合、実際のコードです。機能するコードとの主な違いは、失敗した場合にトランザクションをロールバックすることです。これらすべてがトランザクションで発生し、メッセージとハッシュツリーが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アトミックに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新されることは非常に重要です</font><font style="vertical-align: inherit;">。この場合も、ハッシュツリーはメッセージの内容の検証を提供します。ツリーとメッセージは常に同期する必要があります。そうでない場合、ユーザーに同期エラーが発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで問題の本質が完全に明らかになりました：私たちは要求を満たします</font></font><code>INSERT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">個々のメッセージごとに。</font><font style="vertical-align: inherit;">システムに非常に大きな負荷をかけるこの例では、169,000の要求に対応しようとしています。</font><font style="vertical-align: inherit;">PostgreSQLは別のサーバーで実行されます（ただし、アプリケーションサーバーの近くにあります）。</font><font style="vertical-align: inherit;">このような膨大な数のネットワーククエリが実行されると、それ自体がシステムパフォーマンスを低下させる可能性があり、そのようなタスクがPostgreSQLに過負荷をかける可能性があることは言うまでもありません。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際のシステムパフォーマンスはどのくらいですか？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データがデータベースにゆっくり追加されていることは知っていましたが、どれほど遅いか理解できませんでした。</font><font style="vertical-align: inherit;">そこで、より少ないメッセージを使用してシステムをテストすることにしました。</font><font style="vertical-align: inherit;">処理が正常に完了するように。</font><font style="vertical-align: inherit;">4000メッセージを処理するのに6.9秒かかることがわかりました。</font><font style="vertical-align: inherit;">これは、上記のコードをプロファイリングした結果にすぎません。ネットワークを介したデータ送信に費やされた時間は考慮されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはUXプロジェクトの大きな課題です。</font><font style="vertical-align: inherit;">データ処理のプロセスでは、ユーザーはコンピューター画面の前に座って、同期アイコンがどのように回転するかを観察する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムのアーキテクチャに戻ると、次のようになります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">できるだけ少ないリクエストを実行します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースに追加されたメッセージを確認します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージの録音とハッシュツリーの更新に関する操作を原子的に実行します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
既に存在するメッセージを見つけてフィルターで除外することもできますが、これには大量のクエリを実行する必要があります</font></font><code>SELECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（クエリに169,000を送信する見込みにだれもが満足することはないため、1つのクエリではうまくいかないでしょう。パラメーター）。</font><font style="vertical-align: inherit;">データベースに一意の番号のメッセージを追加するというアイデアもありました。</font><font style="vertical-align: inherit;">この番号を持つのは新しいメッセージだけなので、この番号でメッセージを受信する要求を満たすことができます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリの最適化</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（Key-Valueデータベースと比較した）リレーショナルデータベースの優れた点は、通常、その実装がこの種の問題に対して信頼性の高いソリューションを備えていることです。私たちのパターンはあまり独創的ではなかったので、私はこれを行う方法が単にあるはずだと思いました。最初に考えたのは、単一の演算子を使用してデータベースに数行を追加することでした</font></font><code>INSERT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-comment">--     INSERT ,   ,  PostgreSQL</span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> messages_binary (<span class="hljs-type">timestamp</span>, group_id, content) <span class="hljs-keyword">VALUES</span><font></font>
&nbsp;&nbsp;("1", "group1", "binary-blob1"),<font></font>
&nbsp;&nbsp;("3", "group1", "binary-blobb6"),<font></font>
&nbsp;&nbsp;("2", "group1", "binary-blobbbb");<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、複数のステートメント</font></font><code>INSERT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を1つのクエリに</font><font style="vertical-align: inherit;">結合するよりも優れてい</font><font style="vertical-align: inherit;">ます。そのような構成はより高速に動作する可能性が高いためです。さらに重要なことに、私たちは何が行われたかについての情報を受け取ることを望んでいました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドキュメントを詳しく調べたところ、式</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RETURNING</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステートメントが</font><font style="vertical-align: inherit;">見つかりました</font></font><code>INSERT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。デフォルトでは、データベースにデータを追加するPostgreSQLは、変更された行数に関する情報のみを返します。ただし、フォームのクエリ</font></font><code>INSERT INTO table (value) VALUES (1) RETURNING id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">実行される</font><font style="vertical-align: inherit;">と、システムは新しい行の識別子を返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な質問は、そのようなデザインが必要に応じて機能するかどうかでした。つまり、</font></font><code>INSERT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかの要素を処理するように設計され</font><font style="vertical-align: inherit;">た演算子が使用さ</font><font style="vertical-align: inherit;">れ、同時に式が</font></font><code>ON CONFLICT DO NOTHING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、実際にデータベースに追加された要素に対してのみ識別子配列が返されますか？そのようなデザインは、すべての要素の識別子を返すことができるのではないかと思いました。記録に矛盾があるもの、つまり結果として記録されなかったものも含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のアイデアを研究するためのスクリプトをすばやく書きました。そして、ここで私は幸運</font></font><code>RETURNING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でした。</font><font style="vertical-align: inherit;">式</font><font style="vertical-align: inherit;">は私が必要とするとおりに機能しました。関連するリクエストは次のとおりです。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> messages_binary (<span class="hljs-type">timestamp</span>, group_id, content) <span class="hljs-keyword">VALUES</span>
&nbsp;&nbsp;(<span class="hljs-string">'1'</span>, <span class="hljs-string">'group5'</span>, <span class="hljs-string">'...'</span>),<font></font>
&nbsp;&nbsp;(<span class="hljs-string">'2'</span>, <span class="hljs-string">'group6'</span>, <span class="hljs-string">'...'</span>),<font></font>
&nbsp;&nbsp;(<span class="hljs-string">'3'</span>, <span class="hljs-string">'group7'</span>, <span class="hljs-string">'...'</span>)
<span class="hljs-keyword">ON</span> <span class="hljs-keyword">CONFLICT</span> <span class="hljs-keyword">DO</span> <span class="hljs-keyword">NOTHING</span> <span class="hljs-keyword">RETURNING</span> <span class="hljs-type">timestamp</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このリクエストの実行時に、タイムスタンプが1のメッセージがすでに存在する場合、メッセージ2と3のみがデータベースに書き込まれ、返される配列はのようになり</font></font><code>[{ id: '2' }, { id: '3' }]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">起こりました！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この式</font></font><code>RETURNING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">により、すべての作業を1つの要求に減らすことができました。</font><font style="vertical-align: inherit;">結果を使用して、データベースに追加されたメッセージを正確に見つけることができ、この知識に基づいて、それに応じてハッシュツリーを更新できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいコードは次のようになります。</font><font style="vertical-align: inherit;">私はまだ</font><font style="vertical-align: inherit;">補助機構の安全性を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査してい</font></font></a><font style="vertical-align: inherit;"></font><code>pg-promise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます：</font></font><br>
<br>
<pre><code class="pgsql hljs">//      `pg-promise`<font></font>
//    <span class="hljs-keyword">INSERT</span>   .<font></font>
//    .<font></font>
// http://vitaly-t.github.io/pg-promise/helpers.html#.<span class="hljs-keyword">insert</span>
let stmt = pgp.helpers.<span class="hljs-keyword">insert</span>(<font></font>
&nbsp;&nbsp;messages.map(msg =&gt; ({<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">timestamp</span>: msg.getTimestamp(),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;group_id: groupId,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;is_encrypted: msg.getIsencrypted(),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;content: msg.getContent()<font></font>
&nbsp;&nbsp;})),<font></font>
&nbsp;&nbsp;[<span class="hljs-string">'timestamp'</span>, <span class="hljs-string">'group_id'</span>, <span class="hljs-string">'is_encrypted'</span>, <span class="hljs-string">'content'</span>],
&nbsp;&nbsp;<span class="hljs-string">'messages_binary'</span><font></font>
);<font></font>
let { changes, <span class="hljs-keyword">rows</span> } = await runQuery(<font></font>
&nbsp;&nbsp;stmt + <span class="hljs-string">' ON CONFLICT DO NOTHING RETURNING timestamp'</span><font></font>
);<font></font>
<span class="hljs-keyword">rows</span>.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">row</span> =&gt; {<font></font>
&nbsp;&nbsp;trie = merkle.<span class="hljs-keyword">insert</span>(trie, <span class="hljs-type">Timestamp</span>.parse(<span class="hljs-keyword">row</span>.timestamp));<font></font>
});<font></font>
//   …<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に結果を見てみましょう。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-number">4000</span> messages
<span class="hljs-keyword">Before</span>: <span class="hljs-number">6.9</span>s
<span class="hljs-keyword">After</span>: <span class="hljs-number">.75</span>s
<span class="hljs-number">40000</span> messages
<span class="hljs-keyword">Before</span>: <span class="hljs-number">59</span>s
<span class="hljs-keyword">After</span>: <span class="hljs-number">7.1</span>s
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがあなたを驚かせたら-あなたは知っています-すべてがそのように見えます。</font><font style="vertical-align: inherit;">以前は、40,000件のメッセージを処理するのに59秒かかりました。</font><font style="vertical-align: inherit;">そして今-わずか7.1秒。</font><font style="vertical-align: inherit;">これは、以前と同じ時間に10倍以上のメッセージを処理する機会があることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この資料のリリース後、SQLエラーのために上記のデータが歪んでいることが判明したことを付け加えます。</font><font style="vertical-align: inherit;">データの各部分は、必要以上に大きくなることが判明しました（バイナリBLOBのエンコードが正しくないため）。</font><font style="vertical-align: inherit;">このエラーを修正した後、生成されたINSERTクエリは約25％減少しました。</font><font style="vertical-align: inherit;">これにより、40,000件のメッセージが約5秒で処理されるようになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
169,000メッセージの処理についてはどうですか？</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのリクエストはどのくらいの大きさですか？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、169,000のメッセージをデータベースに書き込むという新しい条件でのベンチマークの動作に興味があるかもしれません。さて、PostgreSQLの制限により、まだ実行できないことがわかりました。この問題の解決は簡単ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
169,000件のレコードを処理しようとしたときに最初に発生した問題は、Node.jsのクラッシュでした。つまり、この失敗により、</font><font style="vertical-align: inherit;">非常に多くの要素が渡さ</font></font><code>pgp.helpers.insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れた</font></font><code>pg-promise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とき</font><font style="vertical-align: inherit;">からの</font><font style="vertical-align: inherit;">補助メソッドが発生</font><font style="vertical-align: inherit;">しました。なぜこれが起こったのか正確にはわかりませんが、他の問題も発生したため、この理由を特定する理由はわかりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、169,000要素を処理するということは、21 MBのデータをアンロードすることを意味します。この操作中にエラーが発生する可能性があるため、これは受け入れられません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベンチマークを100,000メッセージに減らすと、すでに何かを機能させることができます。</font></font><code>INSERT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数の値を使用</font><font style="vertical-align: inherit;">するクエリ</font><font style="vertical-align: inherit;">は、72 MBの文字列です。このような巨大な要求を単純に満たそうとすると、サーバー全体が一時停止されます。私は問題の原因が何であるかを正確に知りません。また、システムがそのようなクエリを処理できるようにPostgreSQLを設定できることもわかりません。ただし、このサイズのリクエストは処理できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より適切な解決策は、要求を複数の部分に分割し、単一の要求のメッセージ数の上限を示すことです。このような制限の役割としては、40,000メッセージが適しているようです。サイズについて言えば、データの量は5 MBであり、処理に7秒かかります（true、そして非常に多くのメッセージがある場合、クエリ文字列のサイズは40 MBですが、PostgreSQLはそのような要求を問題なく処理します）。 169,000件のメッセージを処理するには、5つのリクエストを送信する必要があります。そのうち4件には40,000件のメッセージが含まれ、さらに9,000件のメッセージが含まれています。このような要求の合計処理時間は約29.6秒（169000 / 40,000 * 7）になります。ユーザーに操作の進行状況に関する情報が表示される場合、これはそのような大量のデータに対してはそれほど多くありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これは最悪のシナリオです。</font><font style="vertical-align: inherit;">通常、リクエストを処理する必要はありません。リクエストの処理時間は秒単位で表されます。</font><font style="vertical-align: inherit;">ほとんどの場合、10〜200のメッセージを処理する要求が実行されます。</font><font style="vertical-align: inherit;">このアプローチでは、データの同期に約20ミリ秒かかります。</font><font style="vertical-align: inherit;">169,000メッセージ-これはおそらく最悪のシナリオの最悪の状況です。これは、誰かが1秒あたり数千のリクエストでAPIを満たし、変更を同期しようとした場合に発生する可能性のある状況です。</font><font style="vertical-align: inherit;">これはほとんど起こりません。</font><font style="vertical-align: inherit;">しかし、ユーザーが必要とする可能性がある状況に備える必要があります。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別の改善</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が話したいもう1つのシステム改善は、上記の問題とは関係ありません。ハッシュツリーはデータベースに格納されるため、サーバーはそれを読み取り、変更してから、書き戻す必要があります。つまり、ツリーを操作する場合、競合モードでは、サーバーとの別の接続を確立してツリーを変更することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、この問題を解決するために、かなり原始的なソリューションであるミューテックスが使用されます。ロックは、個々のユーザーレベルです。つまり、ユーザーは競争力のあるデータ同期を実行できますが、同じユーザーが複数のデバイスでデータを同期することを決定した場合、対応するタスクが順次実行されます。これは、ハッシュツリーを更新するときに競合状態を回避するために必要です（このツリーを最新の状態に保つことは非常に重要であることを忘れないでください）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トランザクションに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serializable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分離レベルを使用</font><font style="vertical-align: inherit;">すると、この問題を解決できると</font><font style="vertical-align: inherit;">感じてい</font><font style="vertical-align: inherit;">ます。取引開始</font></font><code>BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">PostgreSQLは、競合状態の可能性を検出すると、トランザクションをキャンセルします。</font><font style="vertical-align: inherit;">1つのトランザクションのフレームワークでデータベースから何かを読み取り、そこに何かを書き込むことを考えると、これが自分に適しているかどうかは完全にはわかりません。</font><font style="vertical-align: inherit;">しかし、これが私に適している場合、トランザクションが失敗した場合は、単にそれを再起動するだけで十分です。</font><font style="vertical-align: inherit;">その結果、同期処理が順次実行されます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次は何ですか？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
169,000メッセージの同期パフォーマンスを調査することはまだしていません。システムには多くの追加メカニズムが存在するため、クライアントは同期中にさらに多くの作業を行います。したがって、最適化の余地はまだ十分にあります。現在の状況では、システムが169,000のメッセージを一度に処理できるとは思えませんが、通常は40,000のメッセージを処理できると確信しています。また、大きなリクエストを40,000件のメッセージを処理するように設計されたリクエストに分割することをお勧めします。これにより、特にユーザーのフィードバックが簡素化され、実行中の作業の進捗状況をユーザーに通知できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、一般的に、非常に重い負荷に基づいてシステムを最適化することは非常に有用な演習であることに注意できます。</font><font style="vertical-align: inherit;">達成された9〜10倍のパフォーマンス向上は、システム全体の負荷の約95％を占める小さなリクエストに影響します。</font><font style="vertical-align: inherit;">以前は100ミリ秒かかっていたクエリは、今では約10ミリ秒しかかかりません。</font><font style="vertical-align: inherit;">これは素晴らしいです！</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースで作業を最適化する必要があった場合は、どのような結果が得られたかをお知らせください。</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/gu/ab/cg/guabcgmwuqoopx1ar80sjpz6keq.png"></a> <br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/de/0y/l-/de0yl-6ppopvisr_a80b4yuhjj8.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja504610/index.html">ECIES-X25519-AEAD-Ratchet-新しい高速I2Pエンドツーエンドネットワーク暗号化プロトコル</a></li>
<li><a href="../ja504612/index.html">JavaScriptを減らすためにSvelteは必要ないかもしれません</a></li>
<li><a href="../ja504614/index.html">ビルダーとアーキテクト：2種類のプログラマー</a></li>
<li><a href="../ja504616/index.html">Idle Detection APIを使用して非アクティブなユーザーを検出する</a></li>
<li><a href="../ja504618/index.html">進歩的な改善の美しさ</a></li>
<li><a href="../ja504622/index.html">Что делает Rust универсальным языком программирования</a></li>
<li><a href="../ja504624/index.html">ジュリアのダンシングリンクアルゴリズム：タイピングの実装とパフォーマンスへの影響</a></li>
<li><a href="../ja504626/index.html">ウェブサイトのベンチマーク：4つの無料ツール</a></li>
<li><a href="../ja504628/index.html">分散型ブロックチェーンシステムのノードへの更新の機能</a></li>
<li><a href="../ja504632/index.html">包括的な教育：なぜそのような良いアイデアがそれほどうまく機能しないのか</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>