<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😌 🚄 👇🏿 Arend-HoTTベースの依存型言語（パート2） 👨🏽‍🍳 🚓 📲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Arend言語に関する記事の最初の部分では、最も単純な帰納型、再帰関数、クラス、およびセットを調べました。
 
 2. Arendでのリストのソート
 2.1アーレンドの順序付きリスト
 順序付きリストのタイプは、リストとその順序付けの証明で構成されるペアとして定義します。すでに述べたように、Are...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Arend-HoTTベースの依存型言語（パート2）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/470632/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arend言語</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">に関する記事の最初の部分では</font></a><font style="vertical-align: inherit;">、最も単純な帰納型、再帰関数、クラス、およびセットを調べました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Arendでのリストのソート</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1アーレンドの順序付きリスト</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
順序付きリストのタイプは、リストとその順序付けの証明で構成されるペアとして定義します。すでに述べたように、Arendでは、従属ペアはキーワードを使用して定義され</font></font><code>\Sigma</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">順序付きリストについての</font></a></font><code>Sorted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前述の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">記事の</font></a><font style="vertical-align: inherit;">定義に触発されたサンプルとの比較を通じて</font><font style="vertical-align: inherit;">、タイプ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">判別し</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><br>
<br>
<pre><code class="plaintext hljs">\func SortedList (O : LinearOrder.Dec) =&gt; \Sigma (l : List O) (Sorted l)<font></font>
<font></font>
\data Sorted {A : LinearOrder.Dec} (xs : List A) \elim xs<font></font>
&nbsp;| nil =&gt; nilSorted<font></font>
&nbsp;| :-: x nil =&gt; singletonSorted<font></font>
&nbsp;| :-: x1 (:-: x2 xs) =&gt; consSorted ((x1 = x2) || (x1 &lt; x2)) (Sorted (x2 :-: xs))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：Arendは、タイプが</font></font><code>Sorted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニバースに含まれている</font><font style="vertical-align: inherit;">ことを自動的に推測でき</font><font style="vertical-align: inherit;">ました</font></font><code>\Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、定義内の3つのパターンすべて</font></font><code>Sorted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が相互に排他的であり、コンストラクター</font></font><code>consSorted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に2つのパラメーターがあり、両方がに属しているために発生しました</font></font><code>\Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
述語のいくつかの明らかなプロパティを証明してみましょう。</font></font><code>Sorted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">順序付きリストの末尾自体が順序付きリストであるとしましょう（このプロパティは将来私たちに役立つでしょう）。</font></font><br>
<a name="habracut"></a><br>
<pre><code class="plaintext hljs">\func tail-sorted {O : LinearOrder.Dec} (x : O) (xs : List O) (A : Sorted (x :-: xs)) : Sorted xs \elim xs, A<font></font>
 &nbsp;| nil, _ =&gt; nilSorted<font></font>
 &nbsp;| :-: _ _, consSorted _ xs-sorted =&gt; xs-sorted</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装で</font></font><code>tail-sorted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、リスト</font></font><code>xs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と述語と</font><font style="vertical-align: inherit;">同時にパターンマッチング</font></font><code>Sorted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用し</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さらに、</font><font style="vertical-align: inherit;">未使用の変数の代わりに使用できる</font><i><font style="vertical-align: inherit;">スキップ記号</font></i><font style="vertical-align: inherit;">「_」を使用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要性の注釈なしにAgdaで証明できない事実の例としてセクション1.3で言及されている、順序付けられたリストのプロパティを証明することがArendで可能かどうか尋ねるかもしれません。このプロパティは、依存ペアを通じて定義された順序付きリストの同等性を証明するには、ペアの最初のコンポーネントの同等性を検証することで十分であることを思い出してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アーレンドでは、このプロパティは、前述の構成</font></font><code>inProp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と依存ペアの拡張性プロパティの</font><font style="vertical-align: inherit;">結果として簡単に取得できると主張されてい</font></font><code>SigmaExt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func sorted-equality {A : LinearOrder.Dec} (l1 l2 : SortedList A) (P : l1.1 = l2.1) : l1 = l2 <font></font>
  =&gt; SigmaPropExt Sorted l1 l2 P</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロパティは</font></font><code>SigmaPropExt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">標準ライブラリの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paths</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュールで証明され</font><font style="vertical-align: inherit;">ます; </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">関数拡張性のプロパティを</font></a><font style="vertical-align: inherit;">含む、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HoTTブックの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第2章からの他の多くの事実もそこで証明されます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Arendは、</font><font style="vertical-align: inherit;">
演算子</font><font style="vertical-align: inherit;">を使用して番号nのシグマタイププロジェクターを参照します（この場合、シグマタイプは</font><font style="vertical-align: inherit;">であり、式</font><font style="vertical-align: inherit;">はこのタイプの最初のコンポーネント-タイプ</font><font style="vertical-align: inherit;">式を</font><font style="vertical-align: inherit;">意味します</font><font style="vertical-align: inherit;">）。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>.n</code><font style="vertical-align: inherit;"></font><code>SortedList A</code><font style="vertical-align: inherit;"></font><code>l1.1</code><font style="vertical-align: inherit;"></font><code>List A</code><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2「置換」プロパティの実装</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Arendにリストソート関数を実装してみましょう。当然、並べ替えアルゴリズムの単純な実装ではなく、いくつかのプロパティの証明を伴う実装が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアルゴリズムには少なくとも2つのプロパティが必要であることは明らかです</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&nbsp;。1.アルゴリズムの結果は順序付きリストである必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&nbsp;2.結果のリストは、元のリストの順列である必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、Arendでリストの「be permutation」プロパティを実装してみましょう。これを行うには</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ここから</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取得</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">し</font></a><font style="vertical-align: inherit;">た定義をArendに適合させます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">\truncated \data InsertSpec {A : \Set} (xs : List A) (a : A) (ys : List A) : \Prop \elim xs, ys<font></font>
 &nbsp;| xs, :-: y ys =&gt; insertedHere (a = y) (xs = ys)<font></font>
 &nbsp;| :-: x xs, :-: y ys =&gt; insertedThere (x = y) (InsertSpec xs a ys)<font></font>
<font></font>
\truncated \data Perm {A : \Set} (xs ys : List A) : \Prop<font></font>
 &nbsp;| permInsert (xs' ys' : List A) (a : A) (Perm xs' ys') (InsertSpec xs' a xs) (InsertSpec ys' a ys)<font></font>
 &nbsp;| permTrivial (xs = ys)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たち</font></font><code>InsertSpec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">導入した述語</font><font style="vertical-align: inherit;">は、次の直感的な意味を持っています。</font></font><code>InsertSpec xs a ys</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり、リスト</font></font><code>ys</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がリスト内の</font></font><code>xs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（任意の位置に）</font><font style="vertical-align: inherit;">要素aを挿入した結果で</font><font style="vertical-align: inherit;">ある</font><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">を正確</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">意味</font><font style="vertical-align: inherit;">します。したがって、</font></font><code>InsertSpec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは挿入関数の仕様と見なすことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ型</font></font><code>Perm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が「順列である」という関係を実際に定義し</font><font style="vertical-align: inherit;">ていることは明らかです</font><font style="vertical-align: inherit;">。コンストラクター</font><font style="vertical-align: inherit;">が同じ要素aをいくつかのリストに挿入し、</font><font style="vertical-align: inherit;">長さ</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">短く、すでに相互の順列である</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、それら</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">相互の順列で</font></font><code>permInsert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある</font></font><code>xs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">正確に主張し</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
「be permutation」プロパティの定義では、対称性プロパティを検証するのは簡単です。</font></font><code>ys</code><font style="vertical-align: inherit;"></font><code>xs</code><font style="vertical-align: inherit;"></font><code>ys</code><font style="vertical-align: inherit;"></font><code>xs’</code><font style="vertical-align: inherit;"></font><code>ys’</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="plaintext hljs">\func Perm-symmetric {A : \Set} {xs ys : List A} (P : Perm xs ys) : Perm ys xs \elim P<font></font>
 &nbsp;| permTrivial xs=ys =&gt; permTrivial (inv xs=ys)<font></font>
 &nbsp;| permInsert perm-xs'-ys' xs-spec ys-spec =&gt; permInsert (Perm-symmetric perm-xs'-ys') ys-spec xs-spec</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
推移性プロパティもで満たされますが</font></font><code>Perm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その検証ははるかに複雑です。</font><font style="vertical-align: inherit;">このプロパティは、ソートアルゴリズムの実装では何の役割も果たさないため、演習として読者に任せます。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func Perm-transitive {A : \Set} (xs ys zs : List A) (P1 : Perm xs ys) (P2 : Perm ys zs) : Perm xs zs =&gt; {?}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.3サンプルと比較した場合のホモトピーレベルの変化 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果のリストが順序付けされたままになるように、順序付けられたリストに要素を挿入する関数を実装してみましょう。</font><font style="vertical-align: inherit;">次の単純な実装から始めましょう。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : List O) (y : O) : List O \elim xs<font></font>
 &nbsp;| nil =&gt; y :-: nil<font></font>
 &nbsp;| :-: x xs' =&gt; \case LinearOrder.trichotomy x y \with {<font></font>
   &nbsp;&nbsp;| byLeft x=y =&gt; x :-: insert xs' y<font></font>
   &nbsp;&nbsp;| byRight (byLeft x&lt;y) =&gt; x :-: insert xs' y<font></font>
   &nbsp;&nbsp;| byRight (byRight y&lt;x) =&gt; y :-: x :-: xs'<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この設計</font></font><code>\case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">により、任意の式のサンプルとの比較</font></font><code>\elim</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が可能になります（関数定義の最高レベルでのみ、そのパラメーターに対してのみ使用できます）。</font><font style="vertical-align: inherit;">Arendにタイプの確認を依頼する</font></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、次のエラーメッセージが表示されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">[ERROR] Data type '||' is truncated to the universe \Prop<font></font>
    &nbsp;&nbsp;which does not fit in the universe of the eliminator type: List O.E<font></font>
  &nbsp;In: | byLeft x-leq-y =&gt; x :-: insert xs' y<font></font>
  &nbsp;While processing: insert</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、クラスでは</font><font style="vertical-align: inherit;">、演算子を使用し</font><font style="vertical-align: inherit;">て</font></font><code>LinearOrder.Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義が</font></font><code>trichotomy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与えられ</font></font><code>||</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次に</font><font style="vertical-align: inherit;">演算子が</font><font style="vertical-align: inherit;">命題切り捨てを使用して定義されることです。すでに述べたように、universe </font></font><code>\Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">属するタイプの</font><font style="vertical-align: inherit;">場合、Arendのパターンとのマッチングは、結果の式のタイプ自体がアサーションである場合にのみ許可されます（上記の関数にはtypeが</font></font><code>List O.E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ありますが、このタイプはセットです）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を回避する方法はありますか？これを解決する最も簡単な方法は、トリコトミーの特性の定義を変更することです。</font></font><code>Or</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">切り捨てられた</font><font style="vertical-align: inherit;">型の</font><font style="vertical-align: inherit;">代わりに切り捨てられ</font><font style="vertical-align: inherit;">ていない</font><font style="vertical-align: inherit;">型</font><font style="vertical-align: inherit;">を使用して、トリコトミーの次の定義を検討してください</font></font><code>||</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func set-trichotomy {A : StrictPoset} (x y : A) =&gt; ((x = y) `Or` (x &lt; y)) `Or` (y &lt; x)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この定義は、元の定義から何かが異なってい</font></font><code>trichotomy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て</font></font><code>||</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？命題が切り詰められ、パターンマッチングが使用できなくなった場合に、なぜ命題が切り捨てられた型を使用したのでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、最初の質問に答えてみましょう。厳密な注文</font><font style="vertical-align: inherit;">の</font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、</font></font><code>trichotomy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>set-trichotomy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際に</font><font style="vertical-align: inherit;">違いは</font><font style="vertical-align: inherit;">あり</font><font style="vertical-align: inherit;">ません。タイプ</font></font><code>set-trichotomy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はステートメントで</font><font style="vertical-align: inherit;">あることに注意し</font><font style="vertical-align: inherit;">てください。この事実は、トリコトミーの定義における3つのすべての選択肢が順序の公理のために相互に排他的であり、3つのタイプのそれぞれが</font></font><code>x = y, x &lt; y, y &lt; x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それ自体がアサーションであるという</font><font style="vertical-align: inherit;">事実に由来</font><font style="vertical-align: inherit;">します（</font></font><code>x = y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font></font><code>BaseSet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">定義するときに</font><font style="vertical-align: inherit;">、キャリアを</font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セット</font><font style="vertical-align: inherit;">にすること</font><font style="vertical-align: inherit;">を要求した</font><font style="vertical-align: inherit;">ため、</font><font style="vertical-align: inherit;">これ</font><font style="vertical-align: inherit;">はアサーション</font><font style="vertical-align: inherit;">です！）。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func set-trichotomy-isProp {A : StrictPoset} (x y : A) (l1 l2 : set-trichotomy x y): l1 = l2 \elim l1, l2<font></font>
 &nbsp;| inl (inl l1), inl (inl l2) =&gt; pmap (\lam z =&gt; inl (inl z)) (Path.inProp l1 l2)<font></font>
 &nbsp;| inl (inr l1), inl (inr l2) =&gt; pmap (\lam z =&gt; inl (inr z)) (Path.inProp l1 l2)<font></font>
 &nbsp;| inr l1,       inr l2       =&gt; pmap inr (Path.inProp l1 l2)<font></font>
 &nbsp;| inl (inl l1), inl (inr l2) =&gt; absurd (lt-eq-false l1 l2)<font></font>
 &nbsp;| inl (inr l1), inl (inl l2) =&gt; absurd (lt-eq-false l2 l1)<font></font>
 &nbsp;| inl (inl l1), inr l2       =&gt; absurd (lt-eq-false (inv l1) l2)<font></font>
 &nbsp;| inr l1,       inl (inl l2) =&gt; absurd (lt-eq-false (inv l2) l1)<font></font>
 &nbsp;| inl (inr l1), inr l2       =&gt; absurd (lt-lt-false l1 l2)<font></font>
 &nbsp;| inr l1,       inl (inr l2) =&gt; absurd (lt-lt-false l2 l1)<font></font>
&nbsp; \where {<font></font>
  &nbsp;&nbsp; \func lt-eq-false {A : StrictPoset} {x y : A} (l1 : x = y) (l2 : x &lt; y) : Empty =&gt;<font></font>
    &nbsp;&nbsp;&nbsp;&nbsp;A.&lt;-irreflexive x (transport (x &lt;) (inv l1) l2)<font></font>
<font></font>
   &nbsp;&nbsp;\func lt-lt-false {A : StrictPoset} {x y : A} (l1 : x &lt; y) (l2 : y &lt; x) : Empty =&gt;<font></font>
    &nbsp;&nbsp;&nbsp; A.&lt;-irreflexive x (A.&lt;-transitive _ _ _ l1 l2)<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のリスト</font></font><code>absurd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロジック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュールで定義されているex falso quodlibet原則の指定</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">型</font></font><code>Empty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の定義にはコンストラクターがない</font><font style="vertical-align: inherit;">ため</font><font style="vertical-align: inherit;">（セクション1.2を参照）、定義内のケースを並べ替える必要はありません</font></font><code>absurd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func absurd {A : \Type} (x : Empty) : A</code></pre><br><font style="vertical-align: inherit;"></font><code>set-trichotomy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステートメントが</font><font style="vertical-align: inherit;">
何で</font><font style="vertical-align: inherit;">ある</font><font style="vertical-align: inherit;">かがわかったので</font></font><code>set-trichotomy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>trichotomy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定可能な注文の</font><font style="vertical-align: inherit;">通常のプロパティから</font><font style="vertical-align: inherit;">プロパティ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">導出できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これを行うに</font></font><code>\return \level</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、この時点でパターンとの照合が許可された操作であることをアーレンドタイマーに通知</font><font style="vertical-align: inherit;">する構成</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用できます</font><font style="vertical-align: inherit;">（この場合、関数の結果が</font></font><code>set-trichotomy-property</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステートメント</font><font style="vertical-align: inherit;">であることの証拠を示す必要があります</font><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func set-trichotomy-property {A : LinearOrder.Dec} (x y : A) : set-trichotomy x y =&gt;<font></font>
 &nbsp;\case A.trichotomy x y \return \level (set-trichotomy x y) (set-trichotomy-isProp x y) \with {<font></font>
   &nbsp;&nbsp;| byLeft x=y =&gt; inl (inl x=y)<font></font>
   &nbsp;&nbsp;| byRight (byLeft x&lt;y) =&gt; inl (inr x&lt;y)<font></font>
   &nbsp;&nbsp;| byRight (byRight y&lt;x) =&gt; inr (y&lt;x)<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、2番目の質問、つまり、数学オブジェクトのプロパティを公式化するときに、通常ではなく命題が切り捨てられた構文を使用することが望ましい理由に答えてみましょう。</font><font style="vertical-align: inherit;">これについて、厳密でない線形次数の定義の一部を検討してください（完全な定義</font><font style="vertical-align: inherit;">は、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">LinearOrder</font></a><font style="vertical-align: inherit;">モジュールに</font></font><code>Lattice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も</font></font><code>TotalOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あります</font><font style="vertical-align: inherit;">）。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="plaintext hljs">\class TotalOrder \extends Lattice {<font></font>
 &nbsp;| totality (x y : E) : x &lt;= y || y &lt;= x<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで</font></font><code>TotalOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、チェックされていない構成を通じて全体フィールドの定義を記述した場合</font><font style="vertical-align: inherit;">に、クラスの意味がどのように変化するかを想像してみましょう</font></font><code>Or</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">\class BadTotalOrder \extends Lattice {<font></font>
 &nbsp;| badTotality (x y : E) : (x &lt;= y) `Or` (y &lt;= x)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、型は</font></font><code>(x &lt;= y) `Or` (y &lt;= x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステートメントで</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">なくなります。同じ値の場合には</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義の両方の選択肢を</font></font><code>badTotality</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装することができ、そして証明の左または右のブランチの選択があり</font></font><code>badTotality</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ユーザーの裁量で絶対に任意と遺跡-に1つのコンストラクタを好む理由はない</font></font><code>Or</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別の。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今では違いが何であるかは明らかです</font></font><code>TotalOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font></font><code>BadTotalOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 2つの順序付けられたセット</font></font><code>O1 O2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><code>TotalOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セット</font></font><code>O1.E, O2.E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">セットに</font><font style="vertical-align: inherit;">与えられた順序の</font><font style="vertical-align: inherit;">等価性を証明できる場合は常に等しい</font></font><code>O1.&lt;, O2.&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（これは望ましいプロパティです）。一方、のために</font></font><code>O1 O2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><code>BadTotalOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平等を証明する</font></font><code>O1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>O2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それはケースのみで可能であるとき、加えて、すべての要素について</font></font><code>x</code><font style="vertical-align: inherit;"></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平等を保持</font></font><code>O1.badTotality x x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して</font></font><code>O2.badTotality x x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、クラスは</font></font><code>BadTotalOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すでに「線形に順序付けられたセット」としてではなく、「</font><font style="vertical-align: inherit;">実装</font><font style="vertical-align: inherit;">で</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左または右のブランチの</font><font style="vertical-align: inherit;">各</font><font style="vertical-align: inherit;">フィールド</font><font style="vertical-align: inherit;">要素の選択を伴う線形に順序付けられたセット」と見なす必要があることがわかります</font><font style="vertical-align: inherit;">。</font></font><code>Or</code><font style="vertical-align: inherit;"></font><code>badTotality x x</code><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.4ソートアルゴリズム</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、並べ替えアルゴリズムの実装に進みます。</font></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">証明されたプロパティの助けを借りて、前のセクションから</font><font style="vertical-align: inherit;">の関数の素朴な実装を修正しようとし</font><font style="vertical-align: inherit;">ます</font></font><code>set-trichotomy-property</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（この場合、定義内の括弧の配置が成功したため、</font></font><code>set-trichotomy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考慮されるケースの数が減少しました）。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : List O) (y : O) : List O \elim xs<font></font>
 &nbsp;| nil =&gt; y :-: nil<font></font>
 &nbsp;| :-: x xs' =&gt; \case set-trichotomy-property x y \with {<font></font>
   &nbsp;&nbsp;| inr y&lt;x =&gt; y :-: x :-: xs'<font></font>
   &nbsp;&nbsp;| inl x&lt;=y =&gt; x :-: insert xs' y<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、この定義の類似物を順序付きリストに実装してみましょう。</font></font><code>\let … \in</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキストに新しいローカル変数を追加できるようにする</font><font style="vertical-align: inherit;">特別な構造</font><font style="vertical-align: inherit;">を使用します。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : SortedList O \elim xs<font></font>
 &nbsp;| (nil, _) =&gt; (y :-: nil, singletonSorted)<font></font>
 &nbsp;| (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property x y \with {<font></font>
   &nbsp;&nbsp;| inr y&lt;x =&gt; (y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted)<font></font>
   &nbsp;&nbsp;| inl x&lt;=y =&gt; \let (result, result-sorted) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y<font></font>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; \in (x :-: result, {?})</code></pre><br><font style="vertical-align: inherit;"></font><code>{?}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リストが</font></font><code>x :-: result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">順序付けされ</font><font style="vertical-align: inherit;">ていることを示す必要がある場所に</font><font style="vertical-align: inherit;">
、不完全なフラグメント（式で示される</font><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">証明に残しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">コンテキストにはリストの順序付けの証拠がありますが、リスト</font><font style="vertical-align: inherit;">の最初の要素の値を超えないこと</font></font><code>result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を確認する必要</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります</font></font><code>result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、コンテキストで使用可能な前提から簡単ではありません（現在のターゲットのすべての前提を確認するために、これは現在実装されているブランチと呼ばれます）計算-関数から型チェックをリクエストする必要があります</font></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">仕様の証明と並行して結果のリストの順序を証明すると、実装</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
が</font></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はるかに簡単になる</font><font style="vertical-align: inherit;">ことが</font><font style="vertical-align: inherit;">わかり</font></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">署名を変更する</font></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> そして、最も簡単なケースでこの仕様の証明を書いてください：</font></font><br>
<br>
<pre><code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : <font></font>
 &nbsp;\Sigma (ys : SortedList O) (InsertSpec xs.1 y ys.1) \elim xs<font></font>
 &nbsp;| (nil, _) =&gt; ((y :-: nil, singletonSorted), insertedHere idp idp)<font></font>
 &nbsp;| (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property x y \with {<font></font>
   &nbsp;&nbsp;| inr y&lt;x =&gt; ((y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted), insertedHere idp idp)<font></font>
   &nbsp;&nbsp;| inl x&lt;=y =&gt;<font></font>
    &nbsp;&nbsp;&nbsp; \let ((result, result-sorted), result-spec) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y<font></font>
    &nbsp;&nbsp;&nbsp; \in ((x :-: result, {?}), insertedThere idp result-spec)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
証明なしで残された単一のフラグメントの場合、Arendは次のコンテキスト値を出力します。</font></font><br>
<br>
<pre><code class="plaintext hljs">Expected type: Sorted (x :-: (insert (\this, tail-sorted x \this \this) \this).1.1)<font></font>
  &nbsp;Context:<font></font>
    &nbsp;&nbsp;result-sorted : Sorted (insert (\this, tail-sorted \this \this \this) \this).1.1<font></font>
    &nbsp;&nbsp;xs-sorted : Sorted (x :-: xs')<font></font>
    &nbsp;&nbsp;x : O<font></font>
    &nbsp;&nbsp;x&lt;=y : Or (x = y) (O.&lt; x y)<font></font>
    &nbsp;&nbsp;O : Dec<font></font>
    &nbsp;&nbsp;result : List O<font></font>
    &nbsp;&nbsp;y : O<font></font>
    &nbsp;&nbsp;xs' : List O<font></font>
    &nbsp;&nbsp;result-spec : InsertSpec xs' y (insert (xs', tail-sorted \this xs' \this) y).1.1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
証明を完了するに</font><font style="vertical-align: inherit;">は、演算子の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フルフォース</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能</font></font><code>\case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用する必要があります。5つの異なる変数へのパターンマッチングを使用します。また、他の変数の値に依存する可能性のある変数のタイプを使用し</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、依存パターンマッチング</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（依存パターンマッチング）を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造結腸は、明らかに、比較が行われるため、変数の一種で（変数の型では、このようにして他の変数の値に依存するかを示し</font></font><code>xs-sorted, result-spec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>result-sorted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の段落のそれぞれにおいて</font></font><code>\case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、変数</font></font><code>xs'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対応するサンプルに置き換えられます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
設計</font></font><code>\return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターンを一致させるために使用される変数を、予期される結果のタイプに関連付けます。つまり、現在の目標では、各アイテムで</font></font><code>\case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、変数の</font></font><code>result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わりに対応するサンプルが使用さ</font><font style="vertical-align: inherit;">れます</font><font style="vertical-align: inherit;">。この構成がなければ、そのような置換は実行されず、すべての点</font></font><code>\case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">での目標は、</font></font><code>\case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式</font><font style="vertical-align: inherit;">自体のサイトでの目標と一致します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) :<font></font>
&nbsp; \Sigma (ys : SortedList O) (InsertSpec xs.1 y ys.1) \elim xs<font></font>
 &nbsp;&nbsp;| (nil, _) =&gt; ((y :-: nil, singletonSorted), insertedHere idp idp)<font></font>
 &nbsp;&nbsp;| (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property x y \with {<font></font>
   &nbsp;&nbsp;&nbsp;| inr y&lt;x =&gt; ((y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted), insertedHere idp idp)<font></font>
   &nbsp;&nbsp;&nbsp;| inl x&lt;=y =&gt;<font></font>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\let ((result, result-sorted), result-spec) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y<font></font>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\in ((x :-: result,<font></font>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\case result \as result, xs' \as xs', xs-sorted : Sorted (x :-: xs'),<font></font>
                 result-spec : InsertSpec xs' y result, result-sorted : Sorted result<font></font>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\return Sorted (x :-: result) \with {<font></font>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| nil, _, _, _, _ =&gt; singletonSorted<font></font>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| :-: r rs, _, _, insertedHere y=r _, result-sorted =&gt;<font></font>
               consSorted (transport (\lam z =&gt; (x = z) || (x &lt; z)) y=r (Or-to-|| x&lt;=y)) result-sorted<font></font>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| :-: r rs, :-: x' _, consSorted x&lt;=x' _, insertedThere x2=r _, result-sorted =&gt;<font></font>
               consSorted (transport (\lam z =&gt; (x = z) || (x &lt; z)) x2=r x&lt;=x') result-sorted<font></font>
           }), insertedThere idp result-spec)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコードブロックで</font></font><code>consSorted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、パターン比較の最後の2つのポイントでの</font><font style="vertical-align: inherit;">コンストラクターの最初の複雑な引数</font><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">追加のコメントに値し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これらの式の両方の意味を理解するために、式を式に置き換え</font></font><code>{?}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Arend taypcherに両方の位置でターゲットを定義するように依頼します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あちこちで、現在のターゲットはtypeであることがわかり</font></font><code>(x = r) || O.&lt; x r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">さらに、最初の目標のコンテキストでは、前提があります</font></font><br>
<br>
<pre><code class="plaintext hljs">x&lt;=y : Or (x = y) (O.&lt; x y) <font></font>
y=r : y = r</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、第二の文脈-前提</font></font><br>
<br>
<pre><code class="plaintext hljs">x&lt;=x' : (x = x') || O.&lt; x x'<font></font>
x2=r : x' = r.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
直感的に明らか：最初の目標を証明するには、正しいステートメント</font></font><code>Or (x = y) (O.&lt; x y)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の変数yの代わりに変数を代入し</font><font style="vertical-align: inherit;">、セクション1.3で定義された関数を使用</font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して命題切り捨て型に切り替える</font><font style="vertical-align: inherit;">だけで十分</font><font style="vertical-align: inherit;">です。 2番目の目標を証明するには、</font><font style="vertical-align: inherit;">変数の代わりに変数</font><font style="vertical-align: inherit;">を代入するだけで十分</font><font style="vertical-align: inherit;">です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
説明されている式置換演算を形式化するために、標準のArendライブラリに特別な関数が存在します</font><font style="vertical-align: inherit;">。彼女の署名を考えてみましょう：</font></font><code>||</code><font style="vertical-align: inherit;"></font><code>Or-to-||</code><font style="vertical-align: inherit;"></font><code>(x = x') || O.&lt; x x'</code><font style="vertical-align: inherit;"></font><code>x'</code><font style="vertical-align: inherit;"></font><code>r</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>transport</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="plaintext hljs">\func transport {A : \Type} (B : A -&gt; \Type) {a a' : A} (p : a = a') (b : B a) : B a'</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、</font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型</font><font style="vertical-align: inherit;">は変数の</font><font style="vertical-align: inherit;">代わりに</font><font style="vertical-align: inherit;">使用する</font><font style="vertical-align: inherit;">必要があり</font></font><code>O.E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（残りの引数が指定されている場合は明示的に省略できます</font></font><code>transport</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、代わり</font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に式を使用し</font></font><code>\lam (z : O) =&gt; (x = z) || (x &lt; z)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仕様と一緒に挿入ソートアルゴリズムを実装しても、特別な問題は発生しなくなりました。リストをソートする</font></font><code>x :-: xs'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には、最初に</font></font><code>xs'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再帰呼び出しを使用し</font><font style="vertical-align: inherit;">てリストの末尾をソートし、</font></font><code>insertSort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すでに実装されている関数にアクセスして、順序を維持したまま</font><font style="vertical-align: inherit;">このリスト内に要素を挿入し</font><font style="vertical-align: inherit;">ます</font></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func insertSort {O : LinearOrder.Dec} (xs : List O) : <font></font>
 &nbsp;\Sigma (result : SortedList O) (Perm xs result.1) \elim xs<font></font>
 &nbsp;| nil =&gt; ((nil, nilSorted), permTrivial idp)<font></font>
 &nbsp;| :-: x xs' =&gt; \let | (ys, perm-xs'-ys) =&gt; insertSort xs'    <font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (zs, zs-spec) =&gt; insert ys x<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\in (zs, permInsert perm-xs'-ys (insertedHere idp idp) zs-spec)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは元の目標を達成し、Arendにソートリストを実装しました。このセクションに記載されているArendコード全体は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ここから</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1つのファイルにダウンロードでき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">厳密な順序の代わりに</font><font style="vertical-align: inherit;">非</font><font style="vertical-align: inherit;">厳密な順序</font><font style="vertical-align: inherit;">を使用した</font><font style="vertical-align: inherit;">場合</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、関数の実装をどのように変更する必要があるのか​​と質問されるかもしれません</font><font style="vertical-align: inherit;">。覚えているように、全体関数の定義では、切り捨て演算の使用</font><font style="vertical-align: inherit;">は非常に重要でした。つまり、この定義は、代わりに</font><font style="vertical-align: inherit;">使用される</font><font style="vertical-align: inherit;">定義と同等ではありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
この質問への答えは次のとおりです。アナログを構築する</font><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">はまだ可能ですが、これについては、関数のタイプが</font></font><code>insert</code><font style="vertical-align: inherit;"></font><code>LinearOrder.Dec</code><font style="vertical-align: inherit;"></font><code>TotalOrder</code><font style="vertical-align: inherit;"></font><code>||</code><font style="vertical-align: inherit;"></font><code>||</code><font style="vertical-align: inherit;"></font><code>Or</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>insert</code><font style="vertical-align: inherit;"></font><code>TotalOrder</code><font style="vertical-align: inherit;"></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステートメントです（これにより、定義内で</font></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ステートメントに従ってサンプルと比較でき</font></font><code>totality x y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言い換えれば、要素</font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が順序付きリスト</font><font style="vertical-align: inherit;">に挿入された結果である、等しいまでの順序付きリストが1つだけであることを証明する必要があり</font><font style="vertical-align: inherit;">ます</font></font><code>xs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これが本当の事実であることは簡単にわかりますが、その正式な証明はそれほど簡単ではありません。</font><font style="vertical-align: inherit;">この事実の検証は、関心のある読者のための演習として残します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このイントロダクションでは、Arend言語の主な構成要素について理解し、クラスメカニズムの使用方法も学びました。仕様の証明とともに、最も単純なアルゴリズムを実装することができました。したがって、Arendは、たとえばプログラム検証などの「日常的な」問題を解決するのに非常に適していることを示しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arendのすべての機能について言及したわけではありません。たとえば、</font><font style="vertical-align: inherit;">さまざまな型のコンストラクターをいくつかの特別なパラメーター値で「接着」できるようにする</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件付きの型</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">については、ほとんど何も述べていません</font><font style="vertical-align: inherit;">。たとえば、Arendの整数型の実装は、次のような条件を持つ型を使用して指定されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">\data Int<font></font>
 &nbsp;| pos Nat<font></font>
 &nbsp;| neg Nat \with { zero =&gt; pos zero }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この定義は、整数は「正」と「負」のゼロが識別される自然数のタイプの2つのコピーで構成されると述べています。このような定義は、Coq標準ライブラリの定義よりもはるかに便利です。Coq標準ライブラリの定義では、自然数の「負のコピー」を「1だけシフト」して、これらのコピーが交差しないようにする必要があります（表記</font></font><code>neg 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が-2ではなく-1を示す</font><font style="vertical-align: inherit;">場合ははるかに便利</font><font style="vertical-align: inherit;">です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスとそのインスタンスの述語レベルとホモトピーレベルを導出するアルゴリズムについては、何も述べていません。インターバルのタイプについてもほとんど触れませんでした。</font></font><code>I</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それはアーレンドの論理的基盤である区間理論において重要な役割を果たしますが。</font><font style="vertical-align: inherit;">このタイプの重要性を理解するには、アーレンドタイプの等式は間隔の概念によって定義されることを言及するだけで十分です。</font><font style="vertical-align: inherit;">間隔のタイプを持つ変数内のサンプルとの比較は、かなり具体的な規則に従って行われますが、この記事でも何も触れていません（いわゆるサンプルとのホモトピー比較）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
投稿者</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Sinchuk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">JetBrains Researchの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HoTTおよびDependent Typesの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上級研究</font><font style="vertical-align: inherit;">員。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja470616/index.html">フェルミパラドックスの新しい解決策（私たちが宇宙で一人でいる理由）</a></li>
<li><a href="../ja470618/index.html">因子分析を使用したニュースのテーマ別モデリング</a></li>
<li><a href="../ja470620/index.html">コードとしてのインフラストラクチャ：XPの問題を克服する方法</a></li>
<li><a href="../ja470622/index.html">特徴選択手法の概要</a></li>
<li><a href="../ja470628/index.html">宇宙船シミュレータ造船</a></li>
<li><a href="../ja470634/index.html">Instagramでコミュニティを特定してユーザーの興味を特定する</a></li>
<li><a href="../ja470638/index.html">準ニュートン法、またはAthosの二次導関数が多すぎる場合</a></li>
<li><a href="../ja470640/index.html">Elasticsearchのサイジング</a></li>
<li><a href="../ja470642/index.html">Yandex.Station Miniをご覧ください。小さなデバイスの大きな物語</a></li>
<li><a href="../ja470644/index.html">corblogが時々酸味を帯びる理由：いくつかの観察とヒント</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>