<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😦 🔟 🍀 2020年对Java有何期待？ 👉🏻 💆🏽 👩🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="2020年已经如火如荼，让我们讨论一下今年Java世界中正在发生的变化。本文将列出Java和JDK的主要趋势。我将对读者在评论中的补充内容感到满意。
 
 立即保留该文章更具有事实调查性的保留。可以在相应项目的网站或开源出版物中找到有关所讨论的每个主题的详细信息。
 
 
 
 所以，让我们开始吧。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>2020年对Java有何期待？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dins/blog/488302/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2020年已经如火如荼，让我们讨论一下今年Java世界中正在发生的变化。</font><font style="vertical-align: inherit;">本文将列出Java和JDK的主要趋势。</font><font style="vertical-align: inherit;">我将对读者在评论中的补充内容感到满意。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
立即保留该文章更具有事实调查性的保留。</font><font style="vertical-align: inherit;">可以在相应项目的网站或开源出版物中找到有关所讨论的每个主题的详细信息。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ss/xa/se/ssxaserudinczxpy3cusjxcilzu.jpeg" alt="图片"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所以，让我们开始吧。</font><font style="vertical-align: inherit;">不幸的是，您将立即使那些不太遵循Java发布周期但正在等待长期支持程序（LTS）的人感到失望。</font><font style="vertical-align: inherit;">今年，我们正在等待只有较短的支持生命周期（STS）的版本。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们将考虑即将于3月中旬发布的JDK 14版本。</font><font style="vertical-align: inherit;">在此发布周期中，多达16个JEP被声明。</font><font style="vertical-align: inherit;">以下是完整列表：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">305：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instanceof的模式匹配（预览）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">343：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包装工具（培养箱）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">345：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G1的NUMA感知内存分配</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">349：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JFR事件流</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">352：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非易失性映射字节缓冲区</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">358：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有用的NullPointerExceptions</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">359：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记录（预览）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">361：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开关表达式（标准）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">362：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弃用Solaris和SPARC端口</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">363：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除并发标记扫描（CMS）垃圾收集器</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">364：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mac OS上的ZGC</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">365：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows上的ZGC</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">366：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弃用ParallelScavenge + SerialOld GC组合</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">367：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除Pack200工具和API</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">368：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文本块（第二预览）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">370：</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外部存储器访问API（孵化器）</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这份清单中的许多JEP在2019年Joker大会上得到了广泛报道，我将重点介绍对我而言最有趣的那些。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instanceof的模式匹配（预览）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
漫长的JEP终于在Preview中问世。</font><font style="vertical-align: inherit;">我认为，如果您是一位从事Java代码多年的实践程序员，那么您将不只一次遇到这种痛苦：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String) {<font></font>
    String s = (String) obj;<font></font>
    System.out.println(s.toUpperCase());<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您也使用Kotlin编写或正在编写代码，那么看到Java代码的痛苦会更糟。</font><font style="vertical-align: inherit;">琥珀项目的参与者将向我们展示他们对Java模式匹配的看法，这将减轻这种痛苦。</font><font style="vertical-align: inherit;">随着Java 14的问世，我们可以将示例重写如下：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String s) {<font></font>
   System.out.println(s.toUpperCase());<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
似乎该插件没有那么有价值-我们节省了一行代码。</font><font style="vertical-align: inherit;">但是假设我们要执行以下操作：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String) {<font></font>
    String s = (String) obj;<font></font>
    <span class="hljs-keyword">if</span> (s.contains(“prefix_”)) {
       <span class="hljs-keyword">return</span> s.toUpperCase();<font></font>
    }<font></font>
}<font></font>
<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它看起来笨重，不是吗？</font><font style="vertical-align: inherit;">让我们尝试相同的事情，但是要使用模式匹配。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">return</span> (obj <span class="hljs-keyword">instanceof</span> String s) &amp;&amp; s.contains(“prefix_”) ? s.toUpperCase() : <span class="hljs-keyword">null</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所以显然会更好。</font><font style="vertical-align: inherit;">但是请记住，此功能的状态为“预览”。</font><font style="vertical-align: inherit;">让我们看看随着时间的变化。</font><font style="vertical-align: inherit;">对我来说，这绝对会让我的生活更美好。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有用的NullPointerExceptions</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2020年就在院子里，您仍然在写，以便NullPointerExceptions为您而飞？</font><font style="vertical-align: inherit;">别担心，您可能不是唯一的一个。</font><font style="vertical-align: inherit;">Goetz Lindenmaier和Ralf Schmelter并未提出摆脱NullPointerExceptions的新方法（可选仍然是我们），但他们建议改进应用程序的调试过程以准确了解null的位置。</font><font style="vertical-align: inherit;">因此，让我们想象一下，我们当然是在晚上五点钟编写代码的。</font><font style="vertical-align: inherit;">我们编写了以下函数：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStreetFromRequest</span><span class="hljs-params">(Request request)</span> </span>{
   <span class="hljs-keyword">return</span> request.getAddress().getStreet().toUpperCase();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不错，但是他们完全忘记了放置@Nullable和@Nonnull批注，并检查传输字段中的地址。</font><font style="vertical-align: inherit;">得到了NullPointerException。</font><font style="vertical-align: inherit;">异常告诉我们什么？</font></font><br>
<br>
<pre><code class="java hljs">Exception in thread <span class="hljs-string">"main"</span> java.lang.NullPointerException<font></font>
	at Program.getStreetFromRequest(Program.java:<span class="hljs-number">10</span>)<font></font>
	at Program.main(Program.java:<span class="hljs-number">6</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
las，我们只能看到一行，一个类和一个堆栈。</font><font style="vertical-align: inherit;">空值到底返回哪里？</font><font style="vertical-align: inherit;">也许这是一个请求？</font><font style="vertical-align: inherit;">也许getAddress（）返回null？</font><font style="vertical-align: inherit;">还是getStreet（）？</font><font style="vertical-align: inherit;">好吧，呼叫链有时会受伤。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JEP的作者提出了一个解决方案：抛出异常时，应该绕过堆栈来确定返回的确切位置为null，然后显示变量/方法的名称。</font><font style="vertical-align: inherit;">让我们尝试使用-XX：+ ShowCodeDetailsInExceptionMessages选项的Java 14。</font><font style="vertical-align: inherit;">我们开始时会有所不同：</font></font><br>
<br>
<pre><code class="java hljs">Exception in thread <span class="hljs-string">"main"</span> java.lang.NullPointerException: Cannot invoke <span class="hljs-string">"String.toUpperCase()"</span> because the <span class="hljs-keyword">return</span> value of <span class="hljs-string">"Address.getStreet()"</span> is <span class="hljs-keyword">null</span>
	at Program.getStreetFromRequest(Program.java:<span class="hljs-number">10</span>)<font></font>
	at Program.main(Program.java:<span class="hljs-number">6</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们知道夜间编程不会带来好处（但有时会导致按时完成任务），并且在我们的程序中我们忘记了地址不是必填字段。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记录（预览）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还在产生带有想法的getters / setters / equals / hashCode吗？</font><font style="vertical-align: inherit;">然后这个JEP来找你！</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据类距离应用程序软件开发人员生命中的最后位置很远。</font><font style="vertical-align: inherit;">每次我们必须使用我们最喜欢的IDE生成Data类的方法时，或者使用各种编译时插件来生成必要的方法，例如lombok。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，我们有很多与此类似的代码：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>{
    <span class="hljs-keyword">private</span> Address address;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Address <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> address;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(Address address)</span> </span>{
       <span class="hljs-keyword">this</span>.address = address;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
        Request request = (Request) o;<font></font>
        <span class="hljs-keyword">return</span> Objects.equals(address, request.address);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> Objects.hash(address);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Request{"</span> +
                <span class="hljs-string">"address="</span> + address +
                <span class="hljs-string">'}'</span>;<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
或诸如此类：</font></font><br>
<pre><code class="java hljs"><span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>{
    <span class="hljs-keyword">private</span> Address address;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Java 14中，Amber项目的成员提出了一种用于创建数据类的新语法。</font><font style="vertical-align: inherit;">为此，请使用新的关键字记录。</font><font style="vertical-align: inherit;">Record的语法与类描述或枚举稍有不同，并且与Kotlin略有相似。</font><font style="vertical-align: inherit;">上面的代码可以重写如下：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">Request</span><span class="hljs-params">(Address address)</span> </span>{<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
默认情况下，所有记录字段都具有私有修饰符和最终修饰符。</font><font style="vertical-align: inherit;">记录本身是最终类，不能从另一个类继承，但是它可以实现接口。</font><font style="vertical-align: inherit;">在框中的记录类中，我们得到：getters方法，一个公共构造函数，其参数均为描述顺序中的所有记录字段，等于/ hashCode和toString。</font><font style="vertical-align: inherit;">令人不愉快的是：除了在类名之后指定的字段外，我们无法将字段添加到记录中。</font><font style="vertical-align: inherit;">例如，此代码将导致错误：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">Request</span><span class="hljs-params">(Address address)</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String anotherParameter; <span class="hljs-comment">// compilation error</span><font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文本块（第二预览）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文本块在Java 13中作为预览发布。我们用户扭曲，旋转并提供了反馈（我真诚地相信您已经在使用Java 13和预览功能）。</font><font style="vertical-align: inherit;">结果，Java创建者对文本块进行了较小的更改。</font><font style="vertical-align: inherit;">首先，我们现在可以通过在行中添加转义序列\来明确指示行的结尾。</font><font style="vertical-align: inherit;">这是一个例子：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> test = <span class="hljs-string">""</span><span class="hljs-string">"
                This is the long text block with escape string \s
                that is really well done            \s
                "</span><span class="hljs-string">""</span>;<font></font>
        System.out.println(test);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们将所有空格显式设置为\字符，所有空格字符将保存为\ s字符。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其次，现在我们可以包装文本块的长行，而在最后一行不接收\ n个字符。</font><font style="vertical-align: inherit;">为此，我们只需要在换行符处添加\。</font><font style="vertical-align: inherit;">它是什么样子的：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> test = <span class="hljs-string">""</span><span class="hljs-string">"
                This is the long text block with escape string \
                that is really well-done functional            
                "</span><span class="hljs-string">""</span>;<font></font>
System.out.println(test);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
执行后，我们得到以下行：“这是带有转义字符串的长文本块，功能确实很好。” </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我看来，这是一个很好的补充。</font><font style="vertical-align: inherit;">我非常期待将此功能转换为标准功能。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们审查的所有功能都可能在即将召开的会议上进行广泛讨论。</font><font style="vertical-align: inherit;">其中一些已经在Joker 2019上进行了讨论。请务必查看Cay Horstmann在Joker 2019上发表的关于“ Java 13及更高版本中的功能进化”的演讲。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有一些更有趣的事情。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
孵化器中JEP列表上有两个有趣的项目。首先，我们将拥有一个通用工具，该工具将为不同的操作系统创建安装程序（最后，我想告诉那些在Windows上安装程序的人）。 Jpacker将能够为Windows创建maci / exe安装程序，为Linux创建macOS软件包和rpm / deb。让我们看看结果如何，但是在极少数情况下，当我为台式机做某事时，我个人遭受了这样一个事实，即我没有用于安装安装程序的常规工具。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更有前景的是用于访问“外部内存”的新API，即 </font><font style="vertical-align: inherit;">任何类型的本机或持久性内存。</font><font style="vertical-align: inherit;">例如，此API主要对Java数据库创建者或Netty等框架创建者有用。</font><font style="vertical-align: inherit;">他们使用Unsafe和ByteBuffer来尽可能利用堆外资源优化内存访问。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一个版本。</font><font style="vertical-align: inherit;">喜悦与沮丧</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9月，我们正在等待第15号的另一个短期支持版本。最终版本中将包括的JEP列表仍处于打开状态。</font><font style="vertical-align: inherit;">到目前为止，您可以在标准库和虚拟机中看到语言本身的许多不同更改。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是候选人列表（可以快速更改，请看这里：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bugs.openjdk.java.net/secure/Dashboard.jspa?selectPageId=19114</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111：</font></font></td>
<td>Additional Unicode Constructs for Regular Expressions</td>
</tr>
<tr>
<td>116:</td>
<td>Extended Validation SSL Certificates</td>
</tr>
<tr>
<td>134:</td>
<td>Intuitive Semantics for Nested Reference Objects</td>
</tr>
<tr>
<td>152:</td>
<td>Crypto Operations with Network HSMs</td>
</tr>
<tr>
<td>198:</td>
<td>Light-Weight JSON API</td>
</tr>
<tr>
<td>218:</td>
<td>Generics over Primitive Types</td>
</tr>
<tr>
<td>300:</td>
<td>Augment Use-Site Variance with Declaration-Site Defaults</td>
</tr>
<tr>
<td>301:</td>
<td>Enhanced Enums</td>
</tr>
<tr>
<td>302:</td>
<td>Lambda Leftovers</td>
</tr>
<tr>
<td>303:</td>
<td>Intrinsics for the LDC and INVOKEDYNAMIC Instructions</td>
</tr>
<tr>
<td>306:</td>
<td>Restore Always-Strict Floating-Point Semantics</td>
</tr>
<tr>
<td>338:</td>
<td>Vector API (Incubator)</td>
</tr>
<tr>
<td>339:</td>
<td>Compiler Intrinsics for Java SE APIs</td>
</tr>
<tr>
<td>348:</td>
<td>Compiler Intrinsics for Java SE APIs</td>
</tr>
<tr>
<td>356:</td>
<td>Enhanced Pseudo-Random Number Generators</td>
</tr>
<tr>
<td>360:</td>
<td>Sealed Types (Preview)</td>
</tr>
<tr>
<td>371:</td>
<td>Hidden Classes</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，该列表仍然没有太多期望的东西。首先，对我来说是Project Loom。近年来，结构并行的想法非常流行。协程可以大大简化竞争性并行计算和任务的异步执行的任务。可以在例如Kotlin（协程）和Go（goroutines）语言中看到实现此想法的绝佳示例。 Java也在探索结构并行性的思想，并且已经有了初步结果。目前，您只能通过从项目存储库编译JDK来查看它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个非常有前途的项目Valhalla还没有通过预览使我们满意。关于这个项目的有趣报告在Joker 2019上发表了（Sergey Kuksenko的“ Java是否需要内联“类型？Valhalla项目的性能工程师的狭窄视角”）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列表中显示了什么？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引起您注意的第一件事是JSON API。问题立即出现-为什么？显然没有明确的答案。关于动机的JEP部分说，JSON已经成为Web服务的标准，现在是时候使Java SE与JSON交互了（即使现在有很多库可以解析JSON）。最可能的解释是软件开发人员能够使用小型核心API来减少捆绑包的大小，而不必将沉重的Jackson拖到自己身上。我看不到任何其他解释，因为它甚至没有数据绑定。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们还看到了与加密API相关的许多改进。首先，JDK开发人员希望通过添加对EVSSL证书的支持来扩展验证SSL证书的过程。使用Java中的该API，您可以确定EV证书（扩展验证）是否信任SSL连接。将完全支持符合指南的EVSSL证书。还将添加新的EdDSA加密算法，并将改进HSM加密的验证。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从语言的角度来看，我将选择泛型在基元上的实现。每个曾经用C＃编程并切换到Java的人都可能会问一个问题，为什么不可能对基元执行泛型类型。答案很简单-泛型仅适用于对象，而基元不是对象，尤其是不继承Object类。这不是在这一问题上展开战争的第一年，而布莱恩·格茨（Brian Goetz）又回到了这一问题。到目前为止，没有什么特别的描述。任务很明确-支持诸如List之类的构造。但是即使在目前，在实现此功能之前，也需要解决13个未解决的问题。老实说，我想知道这个系列会如何结束。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我最后要谈的是密封类型。</font><font style="vertical-align: inherit;">这是进行模式匹配的下一步。</font><font style="vertical-align: inherit;">密封类型是实现密封（修饰符）并允许类或接口使用关键字的语言扩展。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用密封类，我们将后代的数量限制为仅在许可（显式限制）或同一编译单元（文件）中指定的那些类。</font><font style="vertical-align: inherit;">密封类的示例描述：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// </span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> sealed <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>{
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span></span>{}
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span></span>{}<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// </span>
<span class="hljs-keyword">public</span> sealed <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BaseInterface</span> <span class="hljs-title">permits</span> <span class="hljs-title">ChildC</span>, <span class="hljs-title">ChildD</span></span>{<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//  </span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BaseInterface</span> </span>{<font></font>
}<font></font>
<span class="hljs-comment">//  </span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildD</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BaseInterface</span> </span>{<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
密封修饰符可确保只有有限的后代集合才能扩展基类或实现接口。</font><font style="vertical-align: inherit;">处理这些类的对象时可以使用此属性。</font><font style="vertical-align: inherit;">而且，当然，这是在模式匹配的switch语句中使用的最佳选择。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们研究了今年的各种JDK创新。</font><font style="vertical-align: inherit;">其中有些会射击，有些不会。</font><font style="vertical-align: inherit;">但是，在所有新JDK中，最重要的是，我希望有新的小型（或并非如此）的优化能够使我们的程序在每个版本免费的情况下都更快。</font><font style="vertical-align: inherit;">如果您在2019年最后一个Joker上访问了Tagir Valeev Java 9-14：小型优化的报告，那么像我一样，您很可能会对贡献者优化JDK所做的工作印象深刻。</font><font style="vertical-align: inherit;">乍看之下看不到它的结果，也没有一个以上的JEP反映出来，但是我们每天都在使用它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好的Java发行给了我们所有人。</font><font style="vertical-align: inherit;">探索新的平台功能，参加会议并跟踪趋势。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN488278/index.html">全球首款太阳能系列灯</a></li>
<li><a href="../zh-CN488280/index.html">如何使用大型监视器和控制台WLSDM实用程序查看Oracle WebLogic Server</a></li>
<li><a href="../zh-CN488284/index.html">爱+帆布=心</a></li>
<li><a href="../zh-CN488288/index.html">与文化规范无关</a></li>
<li><a href="../zh-CN488298/index.html">来自世界开放地图498号的新闻（01/28 / 2020-03.02.2020）</a></li>
<li><a href="../zh-CN488304/index.html">Sivelkiriya操作系统：技术</a></li>
<li><a href="../zh-CN488308/index.html">普京看到的手镯：Healbe Gobe仍然是唯一可以计算卡路里摄入量的小工具</a></li>
<li><a href="../zh-CN488310/index.html">我的挑战如何变成团队挑战</a></li>
<li><a href="../zh-CN488316/index.html">Epson EH-TW7100-4K HDR投影机以及对支持HDR和4K的投影机的基本功能的思考</a></li>
<li><a href="../zh-CN488320/index.html">死锁帝国-开发者游戏</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>