<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎖️ 🍓 👸🏻 Blitz.Engine: Asset System 🌭 👽 ☁️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bevor wir verstehen, wie das Asset-System der Blitz.Engine- Engine funktioniert , müssen wir entscheiden, was Asset ist und was genau wir unter Asset-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Blitz.Engine: Asset System</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498300/"><img src="https://habrastorage.org/webt/yk/rv/sv/ykrvsv2-nadxe5rvvs7gj8iw-9w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir verstehen, wie das Asset-System der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blitz.Engine-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Engine </font><b><font style="vertical-align: inherit;">funktioniert</font></b><font style="vertical-align: inherit;"> , müssen wir entscheiden, was Asset ist und was genau wir unter Asset-System verstehen. Laut Wikipedia ist ein Spielobjekt ein digitales Objekt, das hauptsächlich aus denselben Daten besteht, eine unteilbare Einheit, die einen Teil des Spielinhalts darstellt und bestimmte Eigenschaften aufweist. Aus Sicht des Programmmodells kann ein Asset als Objekt angezeigt werden, das in einem Datensatz erstellt wurde. Assets können als separate Datei gespeichert werden. Ein Asset-System ist wiederum eine Menge Programmcode, der für das Laden und Betreiben von Assets verschiedener Typen verantwortlich ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich ist ein Asset-System ein großer Teil der Spiel-Engine, die ein loyaler Assistent für Spieleentwickler werden oder ihr Leben in die Hölle verwandeln kann. </font><font style="vertical-align: inherit;">Meiner Meinung nach war die logische Entscheidung, diese „Hölle“ an einem Ort zu konzentrieren und andere Teamentwickler sorgfältig davor zu schützen. </font><font style="vertical-align: inherit;">Wir werden Ihnen erzählen, was wir in dieser Artikelserie gemacht haben - los geht's!</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Geplante Artikel zum Thema:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anforderungserklärung und Architekturübersicht</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asset-Lebenszyklus</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detaillierte Übersicht über die AssetManager-Klasse</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integration in ECS</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GlobalAssetCache</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anforderungen und Gründe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anforderungen an das Asset-Loading-System wurden zwischen einem Felsen und einem harten Ort geboren. </font><font style="vertical-align: inherit;">Ein Amboss war der Wunsch, etwas in sich geschlossenes zu tun, damit es funktioniert, ohne externen Code zu schreiben. </font><font style="vertical-align: inherit;">Gut oder fast ohne externen Code zu schreiben. </font><font style="vertical-align: inherit;">Der Hammer wurde Realität. </font><font style="vertical-align: inherit;">Und hier ist, was wir am Ende hatten:</font></font><br>
<br>
<ol>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatische Speicherverwaltung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dh die Freigabefunktion für das Asset muss nicht aufgerufen werden. </font><font style="vertical-align: inherit;">Das heißt, sobald alle externen Objekte, die das Asset verwenden, zerstört werden, wird das Asset zerstört. </font><font style="vertical-align: inherit;">Die Motivation hier ist einfach - schreiben Sie weniger Code. </font><font style="vertical-align: inherit;">Weniger Code bedeutet weniger Fehler.</font></font></li>
<li><i> <b></b>  </i>,           (    AssetManager’a).   ,      .   —      .       ,     «»    .<br>
    ,      ,       ().       —    ,  . ,     ,              .         ,      ,    .        ,   ,    .</li>
<li><i>   </i>      .  :        .         ,         .</li>
<li><i> (shared)  </i>. ,         .  ,    .           «» ,               .</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Priorisieren Sie das Laden von Assets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es gibt nur 3 Prioritätsstufen: Hoch, Mittel, Niedrig. </font><font style="vertical-align: inherit;">Innerhalb derselben Priorität werden Assets in der Reihenfolge der Anforderung geladen. </font><font style="vertical-align: inherit;">Stellen Sie sich eine Situation vor: Ein Spieler klickt auf „Zum Kampf“ und das Laden des Levels beginnt. </font><font style="vertical-align: inherit;">Gleichzeitig fällt die Aufgabe, das Sprite des Ladebildschirms vorzubereiten, in die Download-Warteschlange. </font><font style="vertical-align: inherit;">Da jedoch einige der Level-Assets vor dem Sprite in die Warteschlange geraten sind, schaut der Spieler einige Zeit auf den schwarzen Bildschirm.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus haben wir eine einfache Regel für uns selbst formuliert: "Alles, was im AssetManager-Thread ausgeführt werden kann, muss im AssetManager-Thread ausgeführt werden." </font><font style="vertical-align: inherit;">Zum Beispiel das Vorbereiten einer Partition der Landschaft und der Textur von Normalen basierend auf einer Höhenkarte, das Verknüpfen eines GPU-Programms usw.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Implementierungsdetails</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir verstehen, wie das Asset-Ladesystem funktioniert, müssen wir uns mit zwei Klassen vertraut machen, die in der Blitz.Engine-Engine weit verbreitet sind:</font></font><br>
<br>
<ul>
<li><code>Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Laufzeitinformationen zu einem Typ. </font><font style="vertical-align: inherit;">Dieser Typ ähnelt dem Typ </font></font><code>Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus der C # -Sprache, mit der Ausnahme, dass er keinen Zugriff auf die Felder und Methoden des Typs bietet. </font><font style="vertical-align: inherit;">Enthält: Typname, eine Reihe von Zeichen wie </font></font><code>is_floating, is_pointer, is_const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usw. </font><font style="vertical-align: inherit;">Die Methode </font></font><code>Type::instance&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt innerhalb eines Anwendungsstarts eine Konstante zurück </font></font><code>const Type*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit der Sie das Formular überprüfen können</font></font><code>if (type == Type::instance&lt;T&gt;())</code></li>
<li><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Ermöglicht das Packen des Werts eines beliebigen beweglichen oder kopierbaren Typs. </font><font style="vertical-align: inherit;">Das Wissen darüber, welcher Typ verpackt ist, </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird als const gespeichert </font></font><code>Type*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weiß, wie man einen Hash anhand seines Inhalts berechnet und wie man Inhalte auf Gleichheit vergleicht. </font><font style="vertical-align: inherit;">Auf dem Weg können Sie Konvertierungen vom aktuellen Typ in einen anderen durchführen. </font><font style="vertical-align: inherit;">Dies ist eine Art Umdenken jeder Klasse aus der Standardbibliothek oder der Boost-Bibliothek.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ladesystem für alle Assets-Listen basiert auf drei Klassen : </font></font><code>AssetManager, AssetBase, IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bevor Sie jedoch mit der Beschreibung dieser Klassen fortfahren, müssen Sie sagen, dass der externe Code einen Alias ​​verwendet </font></font><code>Asset&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der wie folgt deklariert ist:</font></font><br>
<br>
<pre><code class="cpp hljs">Asset = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dabei ist T eine AssetBase oder ein bestimmter Asset-Typ. Mit shared_ptr erreichen wir überall die Erfüllung der Anforderung Nummer 1 (Automatische Speicherverwaltung). </font></font><br>
<br>
<code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist eine endliche Klasse, die keine Erben hat. Diese Klasse definiert den Lebenszyklus eines Assets und sendet Nachrichten über Änderungen im Status eines Assets. Außerdem wird </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Abhängigkeitsbaum zwischen Assets und einem Asset gespeichert, das an Dateien auf der Festplatte gebunden ist, </font></font><code>FileWatcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und es wird ein erneutes Laden von Assets abgehört und implementiert. Und am wichtigsten ist, dass </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein separater Thread gestartet, eine Task-Warteschlange zum Vorbereiten des Assets implementiert und die gesamte Synchronisation mit anderen Anwendungsthreads gekapselt wird (die Asset-Anforderung kann von jedem Anwendungsthread einschließlich des Download-Streams ausgeführt werden). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleichzeitig </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arbeitet mit einem abstrakten Vermögenswert</font></font><code>AssetBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delegieren der Aufgabe zum Erstellen und Laden eines Assets eines bestimmten Typs an den Erben von </font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich werde Ihnen in den folgenden Artikeln mehr darüber erzählen, wie dies geschieht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Rahmen der Anforderung Nr. 4 (Asset Sharing) lautete eine der heißesten Fragen: „Was ist als Asset-ID zu verwenden?“. </font><font style="vertical-align: inherit;">Die einfachste und offensichtlichste Lösung wäre, den Pfad zu der herunterzuladenden Datei zu verwenden. </font><font style="vertical-align: inherit;">Diese Entscheidung bringt jedoch eine Reihe schwerwiegender Einschränkungen mit sich:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ein Asset zu erstellen, muss letzteres als Datei auf der Festplatte dargestellt werden, wodurch die Möglichkeit entfällt, Laufzeit-Assets basierend auf anderen Assets zu erstellen.</font></font></li>
<li>    . ,    GPUProgram     (defines).      ,       .</li>
<li>         ,   .</li>
<li>        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben die Absätze 3 und 4 am Anfang nicht als Argument betrachtet, da nicht einmal der Gedanke bestand, dass dies nützlich sein könnte. Diese Funktionen erleichterten jedoch später die Entwicklung des Editors erheblich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher haben wir uns entschlossen, den Asset-Schlüssel als Kennung zu verwenden, die auf der Ebene </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch den Typ dargestellt wird </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Der </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erbe kann </font><font style="vertical-align: inherit;">interpretieren </font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Selbst </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kennt nur die Beziehung zwischen der Art des Schlüssels und dem Erben </font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Der Code, der ein Asset anfordert, weiß normalerweise, welchen Asset-Typ er benötigt, und arbeitet mit einem Schlüssel eines bestimmten Typs. Es geht alles ungefähr so:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Texture</span>:</span> <span class="hljs-keyword">public</span> AssetBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PathKey</span>
    {</span><font></font>
        FilePath path;<font></font>
        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">hash</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PathKey&amp; other);<font></font>
    };<font></font>
<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryKey</span>
    {</span>
        u32 width = <span class="hljs-number">1</span>;<font></font>
        u32 height = <span class="hljs-number">1</span>;<font></font>
        u32 level_count = <span class="hljs-number">1</span>;<font></font>
        TextureFormat format = RBGA8;<font></font>
        TextureType type = TEX_2D;<font></font>
        <span class="hljs-function">Vector&lt;Vector&lt;u8*&gt;&gt; data</span>; <span class="hljs-comment">// Face&lt;MipLevels&lt;Image&gt;&gt;</span><font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">hash</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> MemoryKey&amp; other);<font></font>
    };<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextureSerializer</span>:</span> <span class="hljs-keyword">public</span> IAssetSerializer<font></font>
{<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AssetManager</span> <span class="hljs-title">final</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    Asset&lt;T&gt; <span class="hljs-title">get_asset</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Any&amp; key, ...)</span></span>;
    <span class="hljs-function">Asset&lt;AssetBase&gt; <span class="hljs-title">get_asset</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Any&amp; key, ...)</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
   ...<font></font>
   <span class="hljs-function">Texture::PathKey <span class="hljs-title">key</span><span class="hljs-params">(<span class="hljs-string">"/path_to_asset"</span>)</span></span>;<font></font>
   Asset&lt;Texture&gt; asset = asset_manager-&gt;get_asset&lt;Texture&gt;(key);<font></font>
   ...<font></font>
<font></font>
   Texture::MemoryKey mem_key;<font></font>
   mem_key.width = <span class="hljs-number">128</span>;<font></font>
   mem_key.format = <span class="hljs-number">128</span>;<font></font>
   mem_key.level_count = <span class="hljs-number">1</span>;<font></font>
   mem_key.format = A8;<font></font>
   mem_key.type = TEX_2D;<font></font>
   Vector&lt;u8*&gt;&amp; mip_chain = mem_key.data.emplace_back();<font></font>
   mip_chain.push_back(generage_sdf_font());<font></font>
   <font></font>
   Asset&lt;Texture&gt; sdf_font_texture = asset_manager-&gt;get_asset&lt;Texture&gt;(mem_key);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Methode </font></font><code>hash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und der Vergleichsoperator im Inneren </font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden für das Funktionieren der entsprechenden Klassenoperationen benötigt </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber wir werden nicht im Detail darauf eingehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was also im obigen Code passiert: </font></font><code>get_asset(key)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum </font><font style="vertical-align: inherit;">Zeitpunkt des Aufrufs wird der </font><font style="vertical-align: inherit;">Schlüssel in ein temporäres Objekt des Typs kopiert </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das wiederum an die Methode übergeben wird </font></font><code>get_asset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nehmen Sie als </font><font style="vertical-align: inherit;">nächstes </font><font style="vertical-align: inherit;">den Schlüsseltyp aus dem Argument. In unserem Fall wird es sein:</font></font><br>
<br>
<pre><code class="cpp hljs">Type::instance&lt;MyAsset::PathKey&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei diesem Typ findet er das Serializer-Objekt und delegiert alle nachfolgenden Vorgänge (Erstellen und Laden) an den Serializer. </font></font><br>
<br>
<code>AssetBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist die Basisklasse für alle Arten von Assets in der Engine. </font><font style="vertical-align: inherit;">Diese Klasse speichert den Asset-Schlüssel, den aktuellen Status des Assets (geladen, in der Warteschlange usw.) sowie den Fehlertext, wenn das Laden des Assets fehlgeschlagen ist. </font><font style="vertical-align: inherit;">Tatsächlich ist die interne Struktur etwas komplizierter, aber wir werden dies zusammen mit dem Lebenszyklus der Vermögenswerte berücksichtigen. </font></font><br>
<br>
<code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie der Name schon sagt, ist dies die Basisklasse für die Entität, die das Asset vorbereitet. </font><font style="vertical-align: inherit;">Tatsächlich lädt der Erbe dieser Klasse nicht nur den Vermögenswert:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuordnung und Freigabe eines Asset-Objekts eines bestimmten Typs.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden eines Assets eines bestimmten Typs.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompilieren einer Liste von Dateipfaden, auf deren Grundlage das Asset erstellt wird. </font><font style="vertical-align: inherit;">Diese Liste wird für den Mechanismus zum erneuten Laden von Assets benötigt, wenn sich eine Datei ändert. </font><font style="vertical-align: inherit;">Es stellt sich die Frage: Warum die Liste der Pfade und nicht ein Pfad? </font><font style="vertical-align: inherit;">Einfache Assets wie Texturen können wirklich auf der Basis einer einzelnen Datei erstellt werden. </font><font style="vertical-align: inherit;">Wenn wir uns jedoch den Shader ansehen, werden wir sehen, dass der Neustart nicht nur erfolgen sollte, wenn der Shadertext geändert wird, sondern auch, wenn die mit dem Shader verbundene Datei über die include-Direktive geändert wird.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asset auf Festplatte speichern. </font><font style="vertical-align: inherit;">Es wird sowohl beim Bearbeiten von Assets als auch beim Vorbereiten von Assets für das Spiel aktiv verwendet.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt die unterstützten Schlüsseltypen an.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und die letzte Frage, die ich im Rahmen dieses Artikels hervorheben möchte: Warum benötigen Sie möglicherweise mehrere Schlüsseltypen auf einem Serializer / Asset? </font><font style="vertical-align: inherit;">Lassen Sie es uns der Reihe nach klären.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Serializer - mehrere Arten von Schlüsseln</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir ein Beispiel für ein Asset </font></font><code>GPUProgram</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dh einen Shader). </font><font style="vertical-align: inherit;">Um einen Shader in unseren Motor zu laden, sind folgende Informationen erforderlich:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Pfad zur Shader-Datei.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste der Präprozessordefinitionen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Phase, für die der Shader zusammengestellt und kompiliert wird (Vertex, Fragment, Compute).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Name des Einstiegspunkts.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir diese Informationen zusammenfassen, erhalten wir den Shader-Schlüssel, der im Spiel verwendet wird. Während der Entwicklung eines Spiels oder einer Engine ist es jedoch häufig erforderlich, einige Debugging-Informationen auf dem Bildschirm anzuzeigen, manchmal mit einem bestimmten Shader. In dieser Situation ist es praktisch, den Shader-Text direkt in den Code zu schreiben. Dazu können wir den zweiten Schlüsseltyp erhalten, der anstelle des Pfads zur Datei und der Liste der Präprozessordefinitionen den Text des Shaders enthält. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein anderes Beispiel: Textur. Der einfachste Weg, eine Textur zu erstellen, besteht darin, sie von der Festplatte zu laden. Dazu benötigen wir den Pfad zur Datei ( </font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Wir können den Inhalt der Textur aber auch algorithmisch generieren und eine Textur aus einem Array von Bytes ( </font></font><code>MemoryKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">erstellen </font><font style="vertical-align: inherit;">. Der dritte Schlüsseltyp kann ein Schlüssel zum Erstellen einer </font></font><code>RenderTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textur sein ( </font></font><code>RTKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abhängig von der Art des Schlüssels können verschiedene Glyphen-Rasterisierungs-Engines verwendet werden: stb (StbFontKey), FreeType (FTFontKet) oder ein selbstsignierter signierter Distanzfeld-Schriftgenerator (SDFFontKey). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keyframe-Animationen können geladen ( </font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) oder durch Code ( </font></font><code>MemoryKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">generiert werden </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Asset - mehrere Arten von Schlüsseln</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich vor, wir haben ein </font></font><code>ParticleEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asset, das die Regeln für die Partikelerzeugung beschreibt. Darüber hinaus haben wir einen praktischen Editor für dieses Asset. Gleichzeitig sind der Ebeneneditor und der Partikeleditor eine Anwendung mit mehreren Fenstern. Dies ist praktisch, da Sie eine Ebene öffnen, eine Partikelquelle darin platzieren und den Effekt in der Umgebung der Ebene betrachten können, während Sie den Effekt selbst bearbeiten. Wenn wir einen Schlüsseltyp haben, ist das Effektobjekt, das in der Welt der Effektbearbeitung und in der Ebenenwelt verwendet wird, ein und dasselbe. Alle im Effekteditor vorgenommenen Änderungen sind sofort in der Ebene sichtbar. Auf den ersten Blick mag dies eine coole Idee sein, aber schauen wir uns die folgenden Szenarien an:</font></font><br>
<br>
<ol>
<li>    ,   ,    ,    .   ,            . </li>
<li>-       ,    .        ,            .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus ist eine Situation möglich, in der wir zwei verschiedene Arten von Assets aus einer Datei auf einer Festplatte mit zwei verschiedenen Arten von Schlüsseln erstellen. </font><font style="vertical-align: inherit;">Mit dem Schlüsseltyp "Spiel" erstellen wir eine Datenstruktur, die für die schnelle Arbeit im Spiel optimiert ist. </font><font style="vertical-align: inherit;">Mit dem Schlüsseltyp "redaktionell" erstellen wir eine Datenstruktur, die für die Bearbeitung geeignet ist. </font><font style="vertical-align: inherit;">Auf diese Weise implementiert unser Editor die Bearbeitung </font></font><code>BlendTree</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für Skelettanimationen. </font><font style="vertical-align: inherit;">Basierend auf einer Art von Schlüssel erstellt das Asset-System ein Asset mit einem ehrlichen Baum im Inneren und einer Reihe von Signalen zum Ändern der Topologie, was beim Bearbeiten sehr praktisch ist, aber im Spiel eher langsam. </font><font style="vertical-align: inherit;">Mit einem anderen Schlüsseltyp erstellt der Serializer einen anderen Asset-Typ: Das Asset verfügt über keine Methoden zum Ändern des Baums, und der Baum selbst wird in ein Array von Knoten umgewandelt, wobei die Verknüpfung zum Knoten ein Index im Array ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Epilog</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammenfassend möchte ich Ihre Aufmerksamkeit auf die Lösungen konzentrieren, die die Weiterentwicklung des Motors am meisten beeinflusst haben:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden einer benutzerdefinierten Struktur als Asset-Schlüssel, nicht als Dateipfad.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden von Assets nur im asynchronen Modus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein flexibles Schema für die Verwaltung der Asset-Freigabe (ein Asset - mehrere Arten von Schlüsseln).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Möglichkeit, Assets desselben Typs unter Verwendung verschiedener Datenquellen zu empfangen (Unterstützung für mehrere Schlüsseltypen in einem Serializer).</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der nächsten Reihe erfahren Sie, wie genau diese Entscheidungen die Implementierung des internen und des externen Codes beeinflusst haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autor:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exmix</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de498290/index.html">Prozedurale Hydrologie: Dynamische Simulation von Flüssen und Seen</a></li>
<li><a href="../de498292/index.html">Sparen Sie viel Geld bei großen Mengen in PostgreSQL</a></li>
<li><a href="../de498294/index.html">Objekterkennung Erkennen und regieren. Teil 1</a></li>
<li><a href="../de498296/index.html">Design auf Systemebene. Teil 1. Von der Idee zum System</a></li>
<li><a href="../de498298/index.html">Firmen verwenden Bug Bounties, um Hacker-Stille zu kaufen</a></li>
<li><a href="../de498302/index.html">ILO Advanced License. Warum wird es gerade jetzt benötigt?</a></li>
<li><a href="../de498304/index.html">Automatisieren Sie die Verwaltungsaufgaben für VMware vSphere API mithilfe von Ansible</a></li>
<li><a href="../de498308/index.html">Python-genetischer Algorithmus zum Auffinden globaler Extrema</a></li>
<li><a href="../de498310/index.html">Drei Fallstricke des maschinellen Lernens und wie man sie vermeidet</a></li>
<li><a href="../de498312/index.html">Entwicklung eines elektrischen Flugzeugnetzes mit modellorientiertem Design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>