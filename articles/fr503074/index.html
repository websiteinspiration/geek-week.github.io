<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏼 👩🏿‍🚀 🎠 Détails sur le package de fournisseur pour Flutter 🥅 👩🏿‍🎨 🍔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 
 
 Nos plans à moyen terme incluent la sortie du livre Flutter. En ce qui concerne le langage de Dart en tant que sujet, nous adoptons...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Détails sur le package de fournisseur pour Flutter</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/503074/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos plans à moyen terme incluent la sortie du livre Flutter. </font><font style="vertical-align: inherit;">En ce qui concerne le langage de Dart en tant que sujet, nous adoptons toujours une position plus prudente, nous allons donc essayer d'évaluer sa pertinence en fonction des résultats de cet article. </font><font style="vertical-align: inherit;">Il se concentrera sur le package </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et, par conséquent, sur la gestion des états dans Flutter.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fournisseur est un progiciel de gestion de l'état écrit par </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remy Rusle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et adopté par Google et la communauté Flutter. </font><font style="vertical-align: inherit;">Mais qu'est-ce que la gestion de l'État? </font><font style="vertical-align: inherit;">Pour commencer, qu'est-ce qu'une condition? </font><font style="vertical-align: inherit;">Permettez-moi de vous rappeler que l'état n'est que des données pour représenter l'interface utilisateur dans votre application. </font><font style="vertical-align: inherit;">La gestion des états est une approche pour créer ces données, y accéder, les manipuler et les éliminer. </font><font style="vertical-align: inherit;">Pour mieux comprendre le package Provider, nous décrivons brièvement l'historique de la gestion des états dans Flutter.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. StatefulWidget</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StatelessWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un simple composant d'interface utilisateur qui s'affiche uniquement lorsqu'il contient des données. Il n'y a </font></font><code>StatelessWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas de «mémoire»; il est créé et détruit si nécessaire. Flutter a également un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StatefulWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dans lequel il y a une mémoire, grâce à lui un satellite à longue durée de vie - l'objet </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cette classe a une méthode </font></font><code>setState()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lorsqu'elle est appelée, un widget est lancé qui reconstruit l'état et l'affiche sous une nouvelle forme. Il s'agit de la forme la plus simple de gestion de l'état Flutter fournie dès le départ. Voici un exemple avec un bouton qui affiche toujours l'heure de la dernière pression:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyWidget</span>&gt; </span>{
  <span class="hljs-built_in">DateTime</span> _time = <span class="hljs-built_in">DateTime</span>.now();  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(_time.toString()),<font></font>
      onPressed: () {<font></font>
        setState(() =&gt; _time = <span class="hljs-built_in">DateTime</span>.now());<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quel est donc le problème avec cette approche? </font><font style="vertical-align: inherit;">Supposons que votre application ait un état global stocké dans la racine </font></font><code>StatefulWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il contient des données destinées à être utilisées dans diverses parties de l'interface utilisateur. </font><font style="vertical-align: inherit;">Ces données sont partagées et transmises à chaque widget enfant sous forme de paramètres. </font><font style="vertical-align: inherit;">Tout événement au cours duquel il est prévu de modifier ces données s'affiche alors sous la forme de rappels. </font><font style="vertical-align: inherit;">Ainsi, à travers tous les widgets intermédiaires, un grand nombre de paramètres et de rappels sont transmis, ce qui peut rapidement conduire à la confusion. </font><font style="vertical-align: inherit;">Pire encore, toute mise à jour de la racine susmentionnée entraînera une reconstruction de l'arborescence entière du widget, ce qui est inefficace.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. InheritedWidget</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InheritedWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un widget spécial dont les descendants peuvent y accéder sans lien direct. </font><font style="vertical-align: inherit;">Juste en se tournant vers </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, un widget consommateur peut s'inscrire pour une reconstruction automatique, qui se produira lors de la reconstruction d'un widget ancêtre. </font><font style="vertical-align: inherit;">Cette technique vous permet d'organiser plus efficacement la mise à jour de l'interface utilisateur. </font><font style="vertical-align: inherit;">Au lieu de reconstruire d'énormes morceaux de l'application en réponse à un petit changement d'état, vous ne pouvez sélectionner sélectivement que les widgets spécifiques qui doivent être reconstruits. </font><font style="vertical-align: inherit;">Vous avez déjà travaillé avec </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaque fois que vous avez utilisé </font></font><code>MediaQuery.of(context)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>Theme.of(context)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Certes, il est moins probable que vous ayez implémenté votre propre InheritedWidget avec conservation de l'état. </font><font style="vertical-align: inherit;">Le fait est que leur mise en œuvre correcte n'est pas facile.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. ScopedModel</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScopedModel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un package créé en 2017 par Brian Egan, qui le rend facile à utiliser </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour stocker l'état de l'application. </font><font style="vertical-align: inherit;">Vous devez d'abord créer un objet d'état qui hérite de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puis l'appeler </font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque ses propriétés changent. </font><font style="vertical-align: inherit;">La situation n'est pas sans rappeler l'implémentation de l'interface </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PropertyChangeListener</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en Java.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Model</span> </span>{<font></font>
  String _foo;  String get foo =&gt; _foo;<font></font>
  <font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> set <span class="hljs-title">foo</span><span class="hljs-params">(String value)</span> </span>{<font></font>
    _foo = value;<font></font>
    notifyListeners();  <font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour fournir notre objet d'état, nous enveloppons cet objet dans un widget </font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la racine de notre application:</font></font><br>
<br>
<pre><code class="java hljs">ScopedModel&lt;MyModel&gt;(<font></font>
  model: MyModel(),<font></font>
  child: MyApp(...)<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Désormais, tous les widgets descendants pourront accéder </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à l'aide du widget </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScopedModelDescendant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">L'instance de modèle est passée au paramètre </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> ScopedModelDescendant&lt;MyModel&gt;(<font></font>
      builder: (context, child, model) =&gt; Text(model.foo),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout widget descendant pourra également mettre à jour le modèle, ce qui provoquera automatiquement une reconstruction de tout </font></font><code>ScopedModelDescendants</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(à condition que notre modèle appelle correctement </font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = ScopedModel.of&lt;MyModel&gt;(context);<font></font>
        model.foo = <span class="hljs-string">'bar'</span>;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br>
<code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a gagné en popularité dans Flutter en tant qu'outil de gestion des états, mais son utilisation est limitée à la fourniture d'objets qui héritent de la classe </font></font><code>Model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et utilisent ce modèle de notification des modifications.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. BLoC</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la conférence </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google I / O '18</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le </font><font style="vertical-align: inherit;">modèle </font><font style="vertical-align: inherit;">BLoC ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Business Logic Component</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) a </font><font style="vertical-align: inherit;">été introduit </font><font style="vertical-align: inherit;">, qui constitue un autre outil pour extraire l'état des widgets. Les classes BLoC sont des composants non UI à longue durée de vie qui préservent l'état et l'exposent en tant que flux et récepteurs. En prenant la logique d'état et d'entreprise au-delà de l'interface utilisateur, vous pouvez implémenter le widget de manière simple </font></font><code>StatelessWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et utiliser </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamBuilder</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour la reconstruction automatique. En conséquence, le widget "devient stupide", et il devient plus facile à tester. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemple de classe BLoC:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBloc</span> </span>{
  <span class="hljs-keyword">final</span> _controller = StreamController&lt;MyType&gt;();  Stream&lt;MyType&gt; <span class="hljs-keyword">get</span> stream =&gt; _controller.stream;<font></font>
  StreamSink&lt;MyType&gt; <span class="hljs-keyword">get</span> sink =&gt; _controller.sink;<font></font>
  <font></font>
  myMethod() {<font></font>
    <span class="hljs-comment">//  </span><font></font>
    sink.add(foo);<font></font>
  }  dispose() {<font></font>
    _controller.close();<font></font>
  }<font></font>
}<font></font>
 ,   BLoC:<font></font>
<span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context) {<font></font>
 <span class="hljs-keyword">return</span> StreamBuilder&lt;MyType&gt;(<font></font>
  stream: myBloc.stream,<font></font>
  builder: (context, asyncSnapshot) {<font></font>
    <span class="hljs-comment">//  </span><font></font>
 });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le problème avec le modèle BLoC est qu'il n'est pas évident de créer et de détruire des objets BLoC. </font><font style="vertical-align: inherit;">Comment l'instance a-t-elle été créée </font></font><code>myBloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans l'exemple ci-dessus? </font><font style="vertical-align: inherit;">Comment appelons-nous </font></font><code>dispose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour nous débarrasser de lui? </font><font style="vertical-align: inherit;">Les flux nécessitent une utilisation </font></font><code>StreamController</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui devrait être </font></font><code>closed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dès qu'elle devient inutile - cela est fait pour éviter les fuites de mémoire. </font><font style="vertical-align: inherit;">(Il n'y a pas une </font><font style="vertical-align: inherit;">telle chose comme destructor de classe à Dart, seule une classe </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>StatefulWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a une méthode </font></font><code>dispose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">De plus, il n'est pas clair comment partager ce BLoC entre plusieurs widgets. </font><font style="vertical-align: inherit;">Il est souvent difficile pour les développeurs de maîtriser BLoC. </font><font style="vertical-align: inherit;">Il existe plusieurs packages qui tentent de simplifier cela.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Fournisseur</font></font></h4><br>
<code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est un package écrit en 2018 par Remy Rusle, similaire à </font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais dont les fonctions ne sont pas limitées à, fournissant une sous-classe de Model. C'est également un wrapper qui conclut </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais le fournisseur peut fournir tous les objets d'état, y compris BLoC, les flux, les futurs et autres. Étant donné que le fournisseur est si simple et flexible, Google a annoncé lors de la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conférence Google I / O '19</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qu'à l'avenir, il </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serait le package préféré pour la gestion de l'état. Bien sûr, d'autres packages sont également autorisés, mais si vous avez des doutes, Google recommande de s'arrêter à </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">construit "avec des widgets, pour des widgets."</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous permet de placer n'importe quel objet avec un état dans l'arborescence des widgets et d'ouvrir l'accès à celui-ci pour tout autre widget (enfant). </font><font style="vertical-align: inherit;">Il </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permet </font><font style="vertical-align: inherit;">également de </font><font style="vertical-align: inherit;">gérer la durée de vie des objets d'état en les initialisant avec des données et en effectuant un nettoyage après leur suppression de l'arborescence des widgets. </font><font style="vertical-align: inherit;">Par conséquent, il </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convient même pour la mise en œuvre de composants BLoC ou peut servir de base à d'autres solutions de gestion d'état! </font><font style="vertical-align: inherit;">Ou tout simplement utilisé pour </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implémenter des dépendances</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - un terme sophistiqué qui signifie transférer des données vers des widgets d'une manière qui vous permet de relâcher la connexion et d'améliorer la testabilité du code. </font><font style="vertical-align: inherit;">Finalement,</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est livré avec un ensemble de classes spécialisées, grâce auxquelles il est encore plus pratique à utiliser. </font><font style="vertical-align: inherit;">Ensuite, nous examinerons de plus près chacune de ces classes.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fournisseur de base</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChangeNotifierProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Futureprovider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenableProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MultiProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proxyprovider</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installation</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour l'utiliser </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ajoutez d'abord une dépendance à notre fichier </font></font><code>pubspec.yaml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<code>provider: ^3.0.0</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous importons le paquet </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">là où il est nécessaire: </font></font><br>
<br>
<code>import 'package:provider/provider.dart';</code><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fournisseur de base</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Créez la base </font></font><code>Provide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r à la racine de notre application; </font><font style="vertical-align: inherit;">cela contiendra une instance de notre modèle:</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: MyApp(...),<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le paramètre </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crée une instance </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si vous souhaitez lui passer une instance existante, utilisez le constructeur ici </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Provider.value</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, vous pouvez consommer cette instance du modèle n'importe où dans </font></font><code>MyApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en utilisant le widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> Consumer&lt;MyModel&gt;(<font></font>
      builder: (context, value, child) =&gt; Text(value.foo),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'exemple ci-dessus, la classe </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obtient une instance </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à l'aide du widget </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consommateur</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ce widget nous donne </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contenant notre objet dans le paramètre </font></font><code>value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, que devons-nous faire si nous voulons mettre à jour les données de notre modèle? Disons que nous avons un autre widget où, lorsqu'un bouton est cliqué, la propriété doit être mise à jour </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);<font></font>
        model.foo = <span class="hljs-string">'bar'</span>;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notez la syntaxe spécifique utilisée pour accéder à l'instance </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Fonctionnellement, cela équivaut à accéder au widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Le widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est utile dans les cas où le code ne peut pas facilement obtenir le lien </font></font><code>BuildContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que pensez-vous qu'il adviendra du widget original </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que nous avons créé plus tôt? Une nouvelle signification y sera-t-elle affichée </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement non</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il n'est pas possible d'écouter les changements dans les anciens objets Dart traditionnels (au moins sans réflexion, ce qui n'est pas fourni dans Flutter). Ainsi, </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il ne pourra pas «voir» que nous avons correctement mis à jour la propriété </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ordonné la </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mise à jour </font><font style="vertical-align: inherit;">du widget </font><font style="vertical-align: inherit;">en réponse. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChangeNotifierProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il y a de l'espoir! </font><font style="vertical-align: inherit;">Vous pouvez faire en sorte que notre classe </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implémente une impureté </font></font><code>ChangeNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il faudra un peu pour changer l'implémentation de notre modèle et appeler une méthode spéciale </font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaque fois que l'une de nos propriétés change. </font><font style="vertical-align: inherit;">Cela fonctionne à peu près de la même manière </font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais dans ce cas, il est bien que vous n'ayez pas besoin d'hériter d'une classe particulière du modèle. </font><font style="vertical-align: inherit;">Il suffit de réaliser le mélange </font></font><code>ChangeNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Voici à quoi ça ressemble:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>{
  <span class="hljs-built_in">String</span> _foo;  <span class="hljs-built_in">String</span> <span class="hljs-keyword">get</span> foo =&gt; _foo;<font></font>
  <font></font>
  <span class="hljs-keyword">void</span> <span class="hljs-keyword">set</span> foo(<span class="hljs-built_in">String</span> value) {<font></font>
    _foo = value;<font></font>
    notifyListeners();  <font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, nous avons remplacé notre propriété </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par </font></font><code>getter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>setter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, soutenu par la variable privée _foo. </font><font style="vertical-align: inherit;">De cette façon, nous pouvons «intercepter» toutes les modifications apportées à la propriété foo et faire savoir à nos auditeurs que notre objet a changé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, de l'extérieur </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous pouvons changer notre implémentation afin qu'elle utilise une classe différente appelée </font></font><code> ChangeNotifierProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs">ChangeNotifierProvider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: MyApp(...),<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme ça! </font><font style="vertical-align: inherit;">Maintenant, lorsque notre </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">met à jour la propriété </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans l'instance </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, elle </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera automatiquement mise à jour pour refléter ce changement. </font><font style="vertical-align: inherit;">Cool, non? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au fait. </font><font style="vertical-align: inherit;">Vous avez probablement remarqué un gestionnaire de boutons </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec lequel nous avons utilisé la syntaxe suivante:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par défaut, cette syntaxe entraînera automatiquement la reconstruction de l'instance </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dès que le modèle changera </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Peut-être que nous n'en avons pas besoin. </font><font style="vertical-align: inherit;">En fin de compte, il </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contient simplement un bouton qui ne change pas du tout lorsque la valeur change </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour éviter la reconstruction, vous pouvez utiliser la syntaxe suivante pour accéder à notre modèle sans vous inscrire à la reconstruction:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context, listen: <span class="hljs-keyword">false</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est un autre charme fourni dans le package </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juste comme ça. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
À première vue, il n'est pas clair pourquoi il est nécessaire </font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En fin de compte, vous pouvez simplement utiliser l'habituel </font></font><code>StreamBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si vous avez besoin de consommer un flux dans Flutter. </font><font style="vertical-align: inherit;">Par exemple, nous écoutons ici le flux </font></font><code>onAuthStateChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fourni par </font></font><code>FirebaseAuth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context {<font></font>
  <span class="hljs-keyword">return</span> StreamBuilder(<font></font>
   stream: FirebaseAuth.instance.onAuthStateChanged, <font></font>
   builder: (BuildContext context, AsyncSnapshot snapshot){ <font></font>
     ...<font></font>
   });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour faire de même avec de l'aide </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous pourrions fournir notre flux </font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la racine de notre application:</font></font><br>
<br>
<pre><code class="dart hljs">StreamProvider&lt;FirebaseUser&gt;.value(<font></font>
  stream: FirebaseAuth.instance.onAuthStateChanged,<font></font>
  child: MyApp(...),<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consommez ensuite le widget enfant, comme c'est généralement le cas avec </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context) {<font></font>
  <span class="hljs-keyword">return</span> Consumer&lt;FirebaseUser&gt;(<font></font>
    builder: (context, value, child) =&gt; Text(value.displayName),<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Non seulement notre code de widget est devenu beaucoup plus propre, mais il fait également abstraction du fait que les données proviennent du flux. Si nous décidons de changer l'implémentation de base, par exemple en </font></font><code>FutureProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, alors aucune modification du code du widget ne sera nécessaire. Comme vous le verrez, cela s'applique à tous les autres fournisseurs indiqués ci-dessous. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FutureProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Similaire à l'exemple ci-dessus, c'est </font></font><code>FutureProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une alternative à la norme </font></font><code> FutureBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque vous travaillez avec des widgets. Voici un exemple:</font></font><br>
<br>
<pre><code class="plaintext hljs">FutureProvider&lt;FirebaseUser&gt;.value(<font></font>
  value: FirebaseAuth.instance.currentUser(),<font></font>
  child: MyApp(...),<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour consommer cette valeur dans le widget enfant, nous utilisons la même implémentation </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que dans l'exemple </font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ci-dessus. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenableProvider </font></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une interface Dart implémentée par la classe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueNotifier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui prend une valeur et avertit les écouteurs lorsqu'elle passe à une autre valeur. </font><font style="vertical-align: inherit;">Il est possible, par exemple, d'encapsuler un compteur entier dans une classe de modèle simple:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> </span>{
  <span class="hljs-keyword">final</span> ValueNotifier&lt;<span class="hljs-built_in">int</span>&gt; counter = ValueNotifier(<span class="hljs-number">0</span>);  <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous travaillez avec des types complexes, il </font></font><code>ValueNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilise l'opérateur de l' </font></font><code>==</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objet qui y est stocké pour déterminer si la valeur a changé. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créons le plus simple </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui contiendra notre modèle principal, et il sera suivi d'une </font><font style="vertical-align: inherit;">propriété d'écoute </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imbriquée </font><font style="vertical-align: inherit;">:</font></font><code>ValueListenableProvider</code><font style="vertical-align: inherit;"></font><code>counter</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: Consumer&lt;MyModel&gt;(builder: (context, value, child) {<font></font>
    <span class="hljs-keyword">return</span> ValueListenableProvider&lt;<span class="hljs-built_in">int</span>&gt;.value(<font></font>
      value: value.counter,<font></font>
      child: MyApp(...)<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter que ce fournisseur imbriqué est de type </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il peut y en avoir d'autres. </font><font style="vertical-align: inherit;">Si vous avez plusieurs fournisseurs du même type enregistrés, le fournisseur retournera le «plus proche» (ancêtre le plus proche). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici comment écouter une propriété à </font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partir de n'importe quel widget enfant:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> Consumer&lt;<span class="hljs-built_in">int</span>&gt;(<font></font>
      builder: (context, value, child) {<font></font>
        <span class="hljs-keyword">return</span> Text(value.toString());<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais voici comment mettre à jour une propriété à </font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partir d'un autre widget. </font><font style="vertical-align: inherit;">Veuillez noter: nous devons avoir accès à la copie originale </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);<font></font>
        model.counter.value++;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MultiProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Si vous utilisez de nombreux widgets</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, à la racine de l'application, vous obtenez une structure laide à partir de nombreuses pièces jointes:</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;Foo&gt;.value( <font></font>
  value: foo, <font></font>
  child: Provider&lt;Bar&gt;.value( <font></font>
    value: bar, <font></font>
    child: Provider&lt;Baz&gt;.value( <font></font>
      value: baz , <font></font>
      child: MyApp(...)<font></font>
    ) <font></font>
  ) <font></font>
)</code></pre><br>
<code>MultiProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous permet de les déclarer tous au même niveau. </font><font style="vertical-align: inherit;">C'est juste du sucre syntaxique: au niveau intra-système, ils restent tous imbriqués de toute façon.</font></font><br>
<br>
<pre><code class="dart hljs">MultiProvider( <font></font>
  providers: [ <font></font>
    Provider&lt;Foo&gt;.value(value: foo), <font></font>
    Provider&lt;Bar&gt;.value(value: bar), <font></font>
    Provider&lt;Baz&gt;.value(value: baz), <font></font>
  ], <font></font>
  child: MyApp(...), <font></font>
)<font></font>
</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProxyProvider</font></font></i></a><br>
<br>
<code>ProxyProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une classe intéressante ajoutée dans la troisième version du package</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il vous permet de déclarer des fournisseurs qui eux-mêmes peuvent dépendre d'autres fournisseurs, jusqu'à six sur un. </font><font style="vertical-align: inherit;">Dans cet exemple, la classe Bar est spécifique à l'instance</font></font><code>Foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela est utile lors de la compilation d'un ensemble racine de services qui dépendent eux-mêmes les uns des autres.</font></font><br>
<br>
<pre><code class="dart hljs">MultiProvider ( <font></font>
  providers: [ <font></font>
    Provider&lt;Foo&gt; ( <font></font>
      builder: (context) =&gt; Foo(),<font></font>
    ), <font></font>
    ProxyProvider&lt;Foo, Bar&gt;(<font></font>
      builder: (context, value, previous) =&gt; Bar(value),<font></font>
    ), <font></font>
  ], <font></font>
  child: MyApp(...),<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier argument de type générique est le type dont dépend le vôtre </font></font><code>ProxyProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le second est le type qu'il renvoie.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment écouter de nombreux fournisseurs en même temps</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et si nous voulons qu'un seul widget écoute de nombreux fournisseurs et se reconstruise lorsque l'un d'eux change? </font><font style="vertical-align: inherit;">Vous pouvez écouter jusqu'à 6 fournisseurs en même temps à l'aide des options de widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous recevrons des instances en tant que paramètres de méthode supplémentaires </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="dart hljs">Consumer2&lt;MyModel, <span class="hljs-built_in">int</span>&gt;(<font></font>
  builder: (context, value, value2, child) {<font></font>
    <span class="hljs-comment">//value  MyModel</span>
    <span class="hljs-comment">//value2  int</span><font></font>
  },<font></font>
);</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'il est utilisé, </font></font><code>InheritedWidget</code> <code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il </font><font style="vertical-align: inherit;">vous </font><font style="vertical-align: inherit;">permet de gérer l'état comme il est de coutume dans Flutter. </font><font style="vertical-align: inherit;">Il permet aux widgets d'accéder aux objets d'état et de les écouter de manière à ce que le mécanisme de notification sous-jacent soit abstrait. </font><font style="vertical-align: inherit;">Il est plus facile de gérer la durée de vie des objets d'état en créant des points d'ancrage pour créer ces objets selon vos besoins et vous en débarrasser en cas de besoin. </font><font style="vertical-align: inherit;">Ce mécanisme peut être utilisé pour implémenter facilement des dépendances et même comme base pour des options de gestion d'état plus avancées. </font><font style="vertical-align: inherit;">Avec la bénédiction de Google et le soutien croissant de la communauté Flutter, c'est </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devenu un package à essayer sans tarder!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr503062/index.html">Le coût réel de la vie dans la Silicon Valley pour le développeur</a></li>
<li><a href="../fr503064/index.html">IoT où vous n'avez pas attendu (partie 3). Construire un modèle de simulation</a></li>
<li><a href="../fr503068/index.html">Au carrefour de la technologie et des affaires: les leaders informatiques ouvrent une nouvelle université en Suisse</a></li>
<li><a href="../fr503070/index.html">Mug électrique. Construire un scooter électrique / vélo électrique fou</a></li>
<li><a href="../fr503072/index.html">Juste un autre outil: apprendre à connaître la configuration du service avec la configuration de l'état souhaité </a></li>
<li><a href="../fr503082/index.html">Télégramme en tant que NAS / FTP</a></li>
<li><a href="../fr503084/index.html">Revue des cours de l'Académie Lightbend - Architecture réactive</a></li>
<li><a href="../fr503086/index.html">Les services de transcription en ligne sont-ils sécurisés et confidentiels?</a></li>
<li><a href="../fr503088/index.html">Comment nous avons sélectionné le fret pour les transporteurs</a></li>
<li><a href="../fr503096/index.html">Pourquoi les gestionnaires veulent-ils que les travailleurs recyclent?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>