<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õ™Ô∏è üí™üèæ ü§òüèæ Das Buch "Bash and Cybersecurity: Angriff, Verteidigung und Analyse √ºber die Linux-Befehlszeile" üëáüèΩ üëçüèª üï•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! Die Befehlszeile kann ein ideales Werkzeug f√ºr die Cybersicherheit sein. Unglaubliche Flexibilit√§t und absolute Verf√ºgbarkeit mach...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Das Buch "Bash and Cybersecurity: Angriff, Verteidigung und Analyse √ºber die Linux-Befehlszeile"</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/501528/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/xx/ml/ir/xxmlirxciwbxahmteiy-9cslfxg.jpeg" align="left" alt="Bild"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo habrozhiteli! </font><font style="vertical-align: inherit;">Die Befehlszeile kann ein ideales Werkzeug f√ºr die Cybersicherheit sein. </font><font style="vertical-align: inherit;">Unglaubliche Flexibilit√§t und absolute Verf√ºgbarkeit machen die Standard-Befehlszeilenschnittstelle (CLI) zu einer grundlegenden L√∂sung, wenn Sie √ºber die entsprechende Erfahrung verf√ºgen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Autoren Paul Tronkon und Karl Albing sprechen √ºber Befehlszeilentools und Tricks, mit denen Sie Daten mit proaktivem Schutz sammeln, Protokolle analysieren und den Netzwerkzustand √ºberwachen k√∂nnen. </font><font style="vertical-align: inherit;">Pentester lernen, wie man Angriffe mit kolossalen Funktionen ausf√ºhrt, die in fast jede Linux-Version integriert sind.</font></font><br>
<a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr wen ist dieses Buch?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Buch "Bash and Cybersecurity" richtet sich an diejenigen, die lernen m√∂chten, wie man im Kontext der Computersicherheit mit der Befehlszeile arbeitet. </font><font style="vertical-align: inherit;">Unser Ziel ist es nicht, vorhandene Tools durch Befehlszeilenskripte zu ersetzen, sondern Ihnen beizubringen, wie Sie die Befehlszeile effektiv nutzen k√∂nnen, um vorhandene Funktionen zu verbessern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im gesamten Buch finden Sie Beispiele f√ºr Sicherheitsmethoden wie Datenerfassung, Analyse und Penetrationstests. </font><font style="vertical-align: inherit;">Der Zweck dieser Beispiele besteht darin, die Befehlszeilenfunktionen zu demonstrieren und Ihnen einige der grundlegenden Methoden vorzustellen, die in √ºbergeordneten Tools verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Buch ist keine Einf√ºhrung in die Programmierung, obwohl einige allgemeine Konzepte in Teil I behandelt werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokoll√ºberwachung in Echtzeit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die F√§higkeit, ein Magazin nach dem Eintreten eines Ereignisses zu analysieren, ist eine wichtige F√§higkeit. </font><font style="vertical-align: inherit;">Genauso wichtig ist es jedoch, Informationen in Echtzeit aus der Protokolldatei extrahieren zu k√∂nnen, um b√∂swillige oder verd√§chtige Aktionen zum Zeitpunkt ihres Auftretens zu erkennen. </font><font style="vertical-align: inherit;">In diesem Kapitel werden Methoden zum Lesen von Journaleintr√§gen betrachtet, wenn diese erstellt und formatiert werden, um Analysen anzuzeigen und Warnungen basierend auf bekannten Bedrohungsindikatoren f√ºr den Betrieb eines Systems oder Netzwerks zu generieren (Indikatoren f√ºr Kompromisse).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textprotokoll√ºberwachung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste M√∂glichkeit, das Protokoll in Echtzeit zu √ºberwachen, besteht darin, den Befehl tail mit dem Parameter ‚Äìf zu verwenden. Er liest die Datei kontinuierlich und zeigt sie in stdout an, wenn neue Zeilen hinzugef√ºgt werden. Wie in den vorherigen Kapiteln wird beispielsweise das Zugriffsprotokoll des Apache-Webservers verwendet, die beschriebenen Methoden sind jedoch f√ºr jedes Textprotokoll relevant. Geben Sie Folgendes ein, um das Apache-Zugriffsprotokoll mit dem Befehl tail zu verfolgen: </font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ausgabe des Befehls tail kann an den Befehl grep √ºbergeben werden, sodass nur Datens√§tze angezeigt werden, die bestimmten Kriterien entsprechen. Im folgenden Beispiel wird das Apache-Zugriffsprotokoll verfolgt und Eintr√§ge angezeigt, die einer bestimmten IP-Adresse entsprechen:</font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | grep '10.0.0.152'<br>
</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen auch regul√§re Ausdr√ºcke verwenden. In diesem Beispiel werden nur Datens√§tze angezeigt, die den HTTP 404-Statuscode "Seite nicht gefunden" zur√ºckgeben. Die Option -i wird hinzugef√ºgt, um den Fall von Zeichen zu ignorieren: </font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | egrep -i 'HTTP/.*" 404'</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um fremde Informationen zu l√∂schen, sollte die Ausgabe an den Befehl cut √ºbergeben werden. In diesem Beispiel wird das Zugriffsprotokoll auf Abfragen √ºberwacht, die zum Statuscode 404 f√ºhren, und anschlie√üend mit der Schnittmethode nur das Datum / die Uhrzeit und die angeforderte Seite angezeigt: </font><font style="vertical-align: inherit;">
Um die eckigen Klammern und doppelten Anf√ºhrungszeichen zu entfernen, k√∂nnen Sie die Ausgabe an tr -d 'weiterleiten. [] "'.</font></font><br>
<br>
<code>$ tail -f access.log | egrep --line-buffered 'HTTP/.*" 404' | cut -d' ' -f4-7<br>
[29/Jul/2018:13:10:05 -0400] "GET /test<br>
[29/Jul/2018:13:16:17 -0400] "GET /test.txt<br>
[29/Jul/2018:13:17:37 -0400] "GET /favicon.ico</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis: Hier wird die Option --line-buffering des Befehls egrep verwendet. </font><font style="vertical-align: inherit;">Dies zwingt egrep, jedes Mal, wenn ein Zeilenumbruch auftritt, auf stdout zu drucken. </font><font style="vertical-align: inherit;">Ohne diesen Parameter erfolgt eine Pufferung und die Ausgabe wird erst an den Befehl cut gesendet, wenn der Puffer voll ist. </font><font style="vertical-align: inherit;">Wir wollen nicht so lange warten. </font><font style="vertical-align: inherit;">Mit dieser Option kann der Befehl egrep jede gefundene Zeile schreiben.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEFEHLSLINIENPUFFER </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert beim Puffern? </font><font style="vertical-align: inherit;">Stellen Sie sich vor, egrep findet viele Zeichenfolgen, die dem angegebenen Muster entsprechen. </font><font style="vertical-align: inherit;">In diesem Fall wird egrep viel ausgegeben. </font><font style="vertical-align: inherit;">Die Ausgabe (in der Tat jede Eingabe oder Ausgabe) ist jedoch viel teurer (nimmt mehr Zeit in Anspruch) als die Datenverarbeitung (Textsuche). </font><font style="vertical-align: inherit;">Je weniger E / A-Aufrufe vorhanden sind, desto effizienter ist das Programm.</font></font><br>
<br>
     grep       ,  ,          .         .  grep       .   ,  grep   50    .   ,     50  ,     ,     .   50  !<br>
<br>
       egrep, ,             .  egrep       ,     ,     .    ,    ,   ,      ,      .      ,     .<br>
<br>
    ,    ,  tail -f        (    ),       . ,       ¬´ ¬ª,      .     .          .<br>
<br>
   ,        egrep     ,     .        ,   .</blockquote><br>
<h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit den Befehlen tail und egrep k√∂nnen Sie das Protokoll √ºberwachen und alle Eintr√§ge anzeigen, die bekannten Mustern verd√§chtiger oder b√∂swilliger Aktivit√§ten entsprechen, die h√§ufig als IOCs bezeichnet werden. Sie k√∂nnen ein einfaches Intrusion Detection System (IDS) erstellen. Erstellen Sie zun√§chst eine Datei mit den Mustern f√ºr regul√§re Ausdr√ºcke f√ºr das IOC (siehe Beispiel 8.1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel 8.1. ioc.txt </font><b><font style="vertical-align: inherit;">(1)</font></b><font style="vertical-align: inherit;"> Diese Vorlage (../) ist ein Indikator f√ºr einen Verzeichnis-Bypass-Angriff: Ein Angreifer versucht, das aktuelle Arbeitsverzeichnis zu verlassen und auf Dateien zuzugreifen, auf die er nicht zugreifen kann. </font><b><font style="vertical-align: inherit;">(2)</font></b><font style="vertical-align: inherit;"> Linux-Dateien etc / passwd und etc / shadow werden zur Authentifizierung des Systems verwendet und sollten niemals √ºber einen Webserver aufgerufen werden. </font><b><font style="vertical-align: inherit;">(3)</font></b></font><br>
<br>
<code>\.\./ <b>(1)</b><br>
etc/passwd <b>(2)</b><br>
etc/shadow<br>
cmd\.exe <b>(3)</b><br>
/bin/sh<br>
/bin/bash<br>
</code><br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Bereitstellen der Dateien cmd.exe, / bin / sh oder / bin / bash ist ein Hinweis auf die vom Webserver zur√ºckgegebene umgekehrte Verbindung. Eine umgekehrte Verbindung zeigt h√§ufig einen erfolgreichen Betriebsversuch an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass IOCs im Regex-Format vorliegen m√ºssen, da sie sp√§ter vom Befehl egrep verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datei ioc.txt kann mit der Option egrep -f verwendet werden. Dieser Parameter weist egrep an, die Muster f√ºr regul√§re Ausdr√ºcke aus der angegebenen Datei zu durchsuchen. Auf diese Weise k√∂nnen Sie den Befehl tail verwenden, um die Protokolldatei zu √ºberwachen. Wenn jeder Datensatz hinzugef√ºgt wird, wird die Lesezeile mit allen Vorlagen in der IOC-Datei verglichen und der entsprechende Datensatz angezeigt. Hier ist ein Beispiel:</font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | egrep -i -f ioc.txt</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus kann der Befehl tee verwendet werden, um Warnungen gleichzeitig auf dem Bildschirm anzuzeigen und zur sp√§teren Verarbeitung in einer eigenen Datei zu speichern: </font><font style="vertical-align: inherit;">
Auch hier ist die Option --line-buffered erforderlich, um sicherzustellen, dass keine Probleme durch das Puffern der Ausgabe des Befehls auftreten.</font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | egrep --line-buffered -i -f ioc.txt |<br>
tee -a interesting.txt</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows-Protokoll√ºberwachung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erw√§hnt, m√ºssen Sie den Befehl wevtutil verwenden, um auf Windows-Ereignisse zuzugreifen. </font><font style="vertical-align: inherit;">Obwohl dieser Befehl universell ist, verf√ºgt er nicht √ºber Funktionen wie tail, mit denen neue eingehende Datens√§tze abgerufen werden k√∂nnen. </font><font style="vertical-align: inherit;">Es gibt jedoch einen Ausweg: Verwenden Sie ein einfaches Bash-Skript, das dieselbe Funktionalit√§t bietet (Beispiel 8.2). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel 8.2. </font><font style="vertical-align: inherit;">wintail.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# wintail.sh<font></font>
#<font></font>
# :<font></font>
#    tail   Windows<font></font>
#<font></font>
# : ./wintail.sh<font></font>
#<font></font>
<font></font>
WINLOG=<span class="hljs-string">"Application"</span> (<span class="hljs-number">1</span>)<font></font>
<font></font>
LASTLOG=$(wevtutil qe <span class="hljs-string">"$WINLOG"</span> <span class="hljs-comment">//c:1 //rd:true //f:text) (2)</span><font></font>
<font></font>
<span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span>
<span class="hljs-keyword">do</span>
      CURRENTLOG=$(wevtutil qe <span class="hljs-string">"$WINLOG"</span> <span class="hljs-comment">//c:1 //rd:true //f:text) (3)</span>
      <span class="hljs-keyword">if</span> [[ <span class="hljs-string">"$CURRENTLOG"</span> != <span class="hljs-string">"$LASTLOG"</span> ]]<font></font>
      then<font></font>
            echo <span class="hljs-string">"$CURRENTLOG"</span>
            echo <span class="hljs-string">"----------------------------------"</span>
            LASTLOG=<span class="hljs-string">"$CURRENTLOG"</span><font></font>
      fi<font></font>
done</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Variable definiert das Windows-Protokoll, das Sie verfolgen m√∂chten. F√ºr eine Liste der derzeit auf dem System verf√ºgbaren Protokolle k√∂nnen Sie den Befehl wevtutil el verwenden. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier wird wevtutil ausgef√ºhrt, um die angegebene Protokolldatei anzufordern. Der Parameter c: 1 gibt nur einen Protokolleintrag zur√ºck. Mit dem Parameter rd: true kann der Befehl den neuesten Protokolleintrag lesen. Schlie√ülich gibt f: text das Ergebnis im Klartext und nicht im XML-Format zur√ºck, wodurch das Lesen des Ergebnisses auf dem Bildschirm vereinfacht wird. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den n√§chsten Zeilen wird der Befehl wevtutil erneut ausgef√ºhrt, und der neu empfangene Protokolleintrag wird mit dem zuletzt auf dem Bildschirm gedruckten verglichen. </font><font style="vertical-align: inherit;">Wenn sie sich voneinander unterscheiden, bedeutet dies, dass √Ñnderungen im Protokoll vorgenommen wurden. </font><font style="vertical-align: inherit;">In diesem Fall wird ein neuer Eintrag angezeigt. </font><font style="vertical-align: inherit;">Wenn die verglichenen Datens√§tze identisch sind, geschieht nichts und der Befehl wevtutil geht zur√ºck und beginnt erneut zu suchen und zu vergleichen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellung eines Echtzeit-Histogramms</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Befehl tail -f stellt den aktuellen Datenstrom bereit. </font><font style="vertical-align: inherit;">Was aber, wenn Sie die Anzahl der Zeilen z√§hlen m√∂chten, die f√ºr einen bestimmten Zeitraum zur Datei hinzugef√ºgt wurden? </font><font style="vertical-align: inherit;">Sie k√∂nnen diesen Datenstrom beobachten, einen Timer starten und √ºber einen bestimmten Zeitraum z√§hlen. </font><font style="vertical-align: inherit;">dann sollte die Z√§hlung gestoppt und die Ergebnisse gemeldet werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Arbeit kann in zwei Skriptprozesse unterteilt werden: Ein Skript liest die Zeilen und das andere √ºberwacht die Uhrzeit. Der Timer benachrichtigt den Leitungsz√§hler unter Verwendung eines Standard-POSIX-Interprozess-Kommunikationsmechanismus, der als Signal bezeichnet wird. Ein Signal ist ein Software-Interrupt, und es gibt verschiedene Arten von Signalen. Einige von ihnen sind schwerwiegend - sie f√ºhren zum Ende des Prozesses (z. B. eine Ausnahme bei einer Gleitkommaoperation). Die meisten dieser Signale k√∂nnen entweder ignoriert oder abgefangen werden. Es wird eine Aktion ausgef√ºhrt, wenn ein Signal abgefangen wird. Viele dieser Signale haben im Betriebssystem einen vordefinierten Zweck. Wir werden eines von zwei Signalen verwenden, die den Benutzern zur Verf√ºgung stehen. Dies ist das Signal SIGUSR1 (das andere ist SIGUSR2).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Shell-Skripte k√∂nnen Interrupts mit dem integrierten Trap-Befehl abfangen. Mit ihm k√∂nnen Sie einen Befehl ausw√§hlen, der bestimmt, welche Aktion Sie ausf√ºhren m√∂chten, wenn ein Signal empfangen wird, sowie eine Liste von Signalen, die einen Aufruf dieses Befehls ausl√∂sen. Beispiel: </font></font><br>
<br>
<code>trap warnmsg SIGINT</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dadurch wird der Befehl warnmsg (unser eigenes Skript oder unsere eigene Funktion) immer dann aufgerufen, wenn das Shell-Skript ein SIGINT-Signal empf√§ngt, z. B. wenn Sie Strg + C dr√ºcken, um einen laufenden Prozess zu unterbrechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel 8.3 zeigt ein Skript, das eine Z√§hlung durchf√ºhrt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel 8.3 looper.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# looper.sh<font></font>
#<font></font>
# :<font></font>
#    <font></font>
#<font></font>
# : ./looper.sh [filename]<font></font>
# filename ‚Äî  ,   ,<font></font>
#  : log.file<font></font>
#<font></font>
<font></font>
<span class="hljs-function">function <span class="hljs-title">interval</span> <span class="hljs-params">()</span>                                           <span class="hljs-params">(<span class="hljs-number">1</span>)</span>
</span>{<font></font>
      echo $(date <span class="hljs-string">'+%y%m%d %H%M%S'</span>) $cnt                       (<span class="hljs-number">2</span>)<font></font>
      cnt=<span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
declare -i cnt=<span class="hljs-number">0</span>
<span class="hljs-function">trap interval <span class="hljs-title">SIGUSR1</span>                                          <span class="hljs-params">(<span class="hljs-number">3</span>)</span>

shopt -s <span class="hljs-title">lastpipe</span>                                              <span class="hljs-params">(<span class="hljs-number">4</span>)</span>

tail -f --pid</span>=$$ ${<span class="hljs-number">1</span>:-log.file} | <span class="hljs-function"><span class="hljs-keyword">while</span> read <span class="hljs-title">aline</span>             <span class="hljs-params">(<span class="hljs-number">5</span>)</span>
<span class="hljs-keyword">do</span>
     let cnt++
done</span></code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Intervallfunktion wird beim Empfang jedes Signals aufgerufen. Nat√ºrlich muss das Intervall definiert werden, bevor wir es benennen und Trap in unserem Ausdruck verwenden k√∂nnen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Befehl date wird aufgerufen, um einen Zeitstempel f√ºr den Wert der zu druckenden cnt-Variablen bereitzustellen. Nachdem der Z√§hler angezeigt wurde, setzen wir diesen Wert auf 0 zur√ºck, um den Countdown des n√§chsten Intervalls zu starten. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem das Intervall definiert ist, k√∂nnen wir anzeigen, dass die Funktion immer dann aufgerufen wird, wenn unser Prozess das Signal SIGUSR1 empf√§ngt. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein sehr wichtiger Schritt. Wenn eine Pipeline von Befehlen vorhanden ist (z. B. ls-l | grep rwx | wc), werden normalerweise Teile der Pipeline (jeder Befehl) in Subnetzen ausgef√ºhrt und jeder Prozess endet mit einer eigenen Prozesskennung. Dies k√∂nnte ein Problem f√ºr dieses Szenario sein, da sich die while-Schleife in einer Subshell mit einer anderen Prozesskennung befindet. Unabh√§ngig davon, welcher Prozess gestartet wird, kennt das Skript looper.sh die Kennung des while-Schleifenprozesses nicht, um ein Signal an ihn zu senden. Dar√ºber hinaus √§ndert das √Ñndern des Werts der Variablen cnt in der Unterschale nicht den Wert von cnt im Hauptprozess, sodass das Signal f√ºr den Hauptprozess jedes Mal den Wert auf 0 setzt. Sie k√∂nnen dieses Problem mit dem Befehl shopt l√∂sen, der den Parameter (-s) auf lastpipe setzt. Es weist die Shell an, keine Subshell f√ºr den letzten Befehl in der Pipeline zu erstellen.und f√ºhren Sie diesen Befehl im selben Prozess wie das Skript selbst aus. In unserem Fall bedeutet dies, dass der Befehl tail in einer Subshell (dh in einem anderen Prozess) ausgef√ºhrt wird und die while-Schleife Teil des Hauptskriptprozesses wird. Hinweis: Diese Shell-Option ist nur in Bash-Version 4.x und h√∂her und nur f√ºr nicht interaktive Shells (d. H. Skripte) verf√ºgbar.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(5)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist der Befehl tail -f mit einem anderen Parameter --pid. Wir geben die Kennung des Prozesses an, der nach Abschluss dieses Prozesses den Befehl tail ausf√ºhrt. Wir geben die Prozess-ID des aktuellen Shell-Skripts $$ an, das angezeigt werden soll. Mit dieser Aktion k√∂nnen Sie Prozesse bereinigen und den Befehl tail nicht im Hintergrund ausf√ºhren lassen (wenn dieses Skript beispielsweise im Hintergrund ausgef√ºhrt wird; Beispiel 8.4). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Skript tailcount.sh startet und stoppt das Skript mit einer Stoppuhr (Timer) und z√§hlt die Zeitintervalle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel 8.4. tailcount.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# tailcount.sh<font></font>
#<font></font>
# :<font></font>
#    n <font></font>
#<font></font>
# : ./tailcount.sh [filename]<font></font>
#     filename:  looper.sh<font></font>
#<font></font>
<font></font>
#  ‚Äî    <font></font>
<span class="hljs-function">function <span class="hljs-title">cleanup</span> <span class="hljs-params">()</span>
</span>{<font></font>
      [[ -n $LOPID ]] &amp;&amp; kill $LOPID          (<span class="hljs-number">1</span>)<font></font>
}<font></font>
<font></font>
<span class="hljs-function">trap cleanup <span class="hljs-title">EXIT</span>                             <span class="hljs-params">(<span class="hljs-number">2</span>)</span>
bash looper.sh $1 &amp;                           <span class="hljs-params">(<span class="hljs-number">3</span>)</span>
LOPID</span>=$!                                      (<span class="hljs-number">4</span>)<font></font>
#   <font></font>
sleep <span class="hljs-number">3</span><font></font>
<font></font>
<span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span>
<span class="hljs-keyword">do</span><font></font>
      kill -SIGUSR1 $LOPID<font></font>
      sleep <span class="hljs-number">5</span>
done &gt;&amp;<span class="hljs-number">2</span>                                      (<span class="hljs-number">5</span>)</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da dieses Skript andere Skripte ausf√ºhrt, sollte es nach der Arbeit bereinigt werden. Wenn die Prozesskennung in LOPID gespeichert wurde, speichert die Variable den Wert, daher sendet die Funktion mit dem Befehl kill ein Signal an diesen Prozess. Wenn Sie im Befehl kill kein bestimmtes Signal angeben, wird standardm√§√üig das SIGTERM-Signal gesendet. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Befehl EXIT ist kein Signal. Dies ist ein Sonderfall, wenn die Trap-Anweisung die Shell anweist, diese Funktion aufzurufen (in diesem Fall Bereinigung), wenn die Shell, die dieses Skript ausf√ºhrt, heruntergefahren werden soll. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt beginnt die eigentliche Arbeit. Das Skript looper.sh wird gestartet, das im Hintergrund ausgef√ºhrt wird: Damit dieses Skript w√§hrend des gesamten Zyklus funktioniert (ohne darauf zu warten, dass der Befehl die Arbeit abschlie√üt), wird es von der Tastatur getrennt. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier wird die Kennung des Skriptprozesses gespeichert, den wir gerade im Hintergrund gestartet haben. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(5)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Weiterleitung ist lediglich eine Vorsichtsma√ünahme. Alle Ausgaben, die von einer while-Schleife oder von kill / sleep-Anweisungen stammen (obwohl wir sie nicht erwarten), sollten nicht mit Ausgaben der Funktion looper.sh gemischt werden, die sie, obwohl sie im Hintergrund funktioniert, trotzdem an stdout sendet. Daher leiten wir Daten von stdout nach stderr um.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammenfassend sehen wir, dass die Funktion looper.sh zwar im Hintergrund platziert wurde, ihre Prozesskennung jedoch in einer Shell-Variablen gespeichert ist. Alle f√ºnf Sekunden sendet das Skript tailcount.sh ein Signal SIGUSR1 an diesen Prozess (der in der Funktion looper.sh ausgef√ºhrt wird), der seinerseits das Skript looper.sh aufruft, um die aktuelle Anzahl der darin festgelegten Zeilen zu drucken und die Z√§hlung neu zu starten. Nach dem Beenden wird das Skript tailcount.sh gel√∂scht, indem ein SIGTERM-Signal an die Funktion looper.sh gesendet wird, um es zu unterbrechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mithilfe von zwei Skripten - einem Skript, das die Zeilenz√§hlung durchf√ºhrt, und einem Skript mit einer Stoppuhr (Timer), die das erste Skript steuert - k√∂nnen Sie die Ausgabe (die Anzahl der Zeilen f√ºr einen bestimmten Zeitraum) abrufen, auf deren Grundlage das n√§chste Skript ein Histogramm erstellt. Es hei√üt so:</font></font><br>
<br>
<code>bash tailcount.sh | bash livebar.sh</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Skript livebar.sh liest Daten aus stdin und druckt die Ausgabe in stdout, eine Zeile f√ºr jede Eingabezeile (Beispiel 8.5). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel 8.5 </font><font style="vertical-align: inherit;">livebar.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# livebar.sh<font></font>
#<font></font>
# :<font></font>
#    ¬´¬ª <font></font>
#<font></font>
# :<font></font>
# &lt;output from other script or program&gt; | bash livebar.sh<font></font>
#<font></font>
<font></font>
<span class="hljs-function">function <span class="hljs-title">pr_bar</span> <span class="hljs-params">()</span>                                         <span class="hljs-params">(<span class="hljs-number">1</span>)</span>
</span>{<font></font>
      local raw maxraw scaled<font></font>
      raw=$<span class="hljs-number">1</span>
      maxraw=$<span class="hljs-number">2</span><font></font>
      ((scaled=(maxbar*raw)/maxraw))<font></font>
      ((scaled == <span class="hljs-number">0</span>)) &amp;&amp; scaled=<span class="hljs-number">1</span> #   
      <span class="hljs-keyword">for</span>((i=<span class="hljs-number">0</span>; i&lt;scaled; i++)) ; <span class="hljs-keyword">do</span> printf <span class="hljs-string">'#'</span> ; done<font></font>
      printf <span class="hljs-string">'\n'</span><font></font>
<font></font>
} # pr_bar<font></font>
<font></font>
maxbar=<span class="hljs-number">60</span>     #         (<span class="hljs-number">2</span>)<font></font>
MAX=<span class="hljs-number">60</span>
<span class="hljs-function"><span class="hljs-keyword">while</span> read dayst timst qty
<span class="hljs-keyword">do</span>
      <span class="hljs-title">if</span> <span class="hljs-params">(( qty &gt; MAX )</span>)                                   <span class="hljs-params">(<span class="hljs-number">3</span>)</span>
      then
           let MAX</span>=$qty+$qty/<span class="hljs-number">4</span>    #   <font></font>
           echo <span class="hljs-string">"                      **** rescaling: MAX=$MAX"</span><font></font>
      fi<font></font>
      printf <span class="hljs-string">'%6.6s %6.6s %4d:'</span> $dayst $timst $qty         (<span class="hljs-number">4</span>)<font></font>
      pr_bar $qty $MAX<font></font>
done<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Funktion pr_bar zeigt eine Zeichenfolge von Hashtags an, die basierend auf den angegebenen Parametern auf die maximale Gr√∂√üe skaliert werden. </font><font style="vertical-align: inherit;">Diese Funktion scheint vertraut zu sein, da wir sie zuvor im Skript histogram.sh verwendet haben. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist die l√§ngste Hashtag-Zeilengr√∂√üe, die wir zulassen k√∂nnen (ohne Zeilenumbruch). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie gro√ü werden die anzuzeigenden Werte sein? Ohne dies vorher zu wissen (obwohl diese Daten dem Skript als Argument zur Verf√ºgung gestellt werden k√∂nnen), verfolgt das Skript das Maximum. Wenn dieses Maximum √ºberschritten wird, beginnt der Wert zu ‚Äûskalieren‚Äú und die jetzt angezeigten Linien. Zuk√ºnftige Linien werden ebenfalls auf ein neues Maximum skaliert. Das Skript addiert 25% zum Maximalwert, sodass der Wert nicht skaliert werden muss, wenn der n√§chste neue Wert jedes Mal nur um 1-2% erh√∂ht wird. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf definiert die minimale und maximale Breite der ersten beiden zu druckenden Felder. </font><font style="vertical-align: inherit;">Dies sind Datums- und Zeitstempel, die abgeschnitten werden, wenn die Breitenwerte √ºberschritten werden. </font><font style="vertical-align: inherit;">Geben Sie die Breite von vier Zeichen an, um den gesamten Wert anzuzeigen. </font><font style="vertical-align: inherit;">In diesem Fall werden trotz der Einschr√§nkungen alle Werte gedruckt. </font><font style="vertical-align: inherit;">Wenn die Anzahl der Zeichen in den Werten weniger als vier betr√§gt, werden die fehlenden durch Leerzeichen erg√§nzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da dieses Skript von stdin gelesen wird, k√∂nnen Sie es selbst ausf√ºhren, um zu sehen, wie es sich verh√§lt. </font><font style="vertical-align: inherit;">Hier ist ein Beispiel:</font></font><br>
<br>
<pre><code class="java hljs">$ bash  livebar.sh
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">20</span>
<span class="hljs-number">201010</span>     <span class="hljs-number">1020</span> <span class="hljs-number">20</span>:####################
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">70</span>
                       **** rescaling: MAX=<span class="hljs-number">87</span>
<span class="hljs-number">201010</span>     <span class="hljs-number">1020</span> <span class="hljs-number">70</span>:################################################
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">75</span>
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">75</span>:###################################################<font></font>
^C</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel wird die Eingabe mit der Ausgabe gemischt. </font><font style="vertical-align: inherit;">Sie k√∂nnen auch Eingaben in eine Datei einf√ºgen und diese in ein Skript umleiten, um nur die Ausgabe anzuzeigen:</font></font><br>
<br>
<pre><code class="java hljs">$ bash livebar.sh &lt; testdata.txt<font></font>
bash livebar.sh &lt; x.data<font></font>
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">20</span>:####################<font></font>
                 **** rescaling: MAX=<span class="hljs-number">87</span>
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">70</span>:################################################
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">75</span>:###################################################<font></font>
$</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬ªWeitere Informationen zum Buch finden Sie auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Website des Herausgebers.</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
¬ª </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalt</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
¬ª </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auszug</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
f√ºr Khabrozhiteley 25% Rabatt auf den Gutschein - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bash</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nach Zahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de501510/index.html">Ein neuer Blick auf die Fullstack-Entwicklung mit dem Ruby on Rails-Framework</a></li>
<li><a href="../de501516/index.html">Lassen Sie uns das Vakuum ausschalten ?! Alexey Lesovsky</a></li>
<li><a href="../de501520/index.html">C # 8 und Nullg√ºltigkeit. Wie leben wir damit?</a></li>
<li><a href="../de501522/index.html">Kostenlose Skillbox-Webinare: Schreiben von Spielen in PHP, Unity und Unreal Engine</a></li>
<li><a href="../de501526/index.html">Warum wird kanadisches Englisch als "schmutzig" angesehen und was hat Keanu Reeves damit zu tun?</a></li>
<li><a href="../de501534/index.html">Jetzt mit COVID-19 gibt es auch einen Ausschlag</a></li>
<li><a href="../de501536/index.html">Ma√ügeschneidert: Eine Geschichte dar√ºber, wie aus einer Codezeile Kilotonnen Kohle wurden</a></li>
<li><a href="../de501538/index.html">Einr√ºckung in Python - L√∂sungsoption</a></li>
<li><a href="../de501544/index.html">Perfektes Smartphone</a></li>
<li><a href="../de501546/index.html">"Warum mache ich das durch?" - Psychologen erkl√§ren, wie man isoliert Sinn findet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>