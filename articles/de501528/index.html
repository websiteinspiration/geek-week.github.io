<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛪️ 💪🏾 🤘🏾 Das Buch "Bash and Cybersecurity: Angriff, Verteidigung und Analyse über die Linux-Befehlszeile" 👇🏽 👍🏻 🕥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! Die Befehlszeile kann ein ideales Werkzeug für die Cybersicherheit sein. Unglaubliche Flexibilität und absolute Verfügbarkeit mach...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Das Buch "Bash and Cybersecurity: Angriff, Verteidigung und Analyse über die Linux-Befehlszeile"</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/501528/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/xx/ml/ir/xxmlirxciwbxahmteiy-9cslfxg.jpeg" align="left" alt="Bild"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo habrozhiteli! </font><font style="vertical-align: inherit;">Die Befehlszeile kann ein ideales Werkzeug für die Cybersicherheit sein. </font><font style="vertical-align: inherit;">Unglaubliche Flexibilität und absolute Verfügbarkeit machen die Standard-Befehlszeilenschnittstelle (CLI) zu einer grundlegenden Lösung, wenn Sie über die entsprechende Erfahrung verfügen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Autoren Paul Tronkon und Karl Albing sprechen über Befehlszeilentools und Tricks, mit denen Sie Daten mit proaktivem Schutz sammeln, Protokolle analysieren und den Netzwerkzustand überwachen können. </font><font style="vertical-align: inherit;">Pentester lernen, wie man Angriffe mit kolossalen Funktionen ausführt, die in fast jede Linux-Version integriert sind.</font></font><br>
<a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für wen ist dieses Buch?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Buch "Bash and Cybersecurity" richtet sich an diejenigen, die lernen möchten, wie man im Kontext der Computersicherheit mit der Befehlszeile arbeitet. </font><font style="vertical-align: inherit;">Unser Ziel ist es nicht, vorhandene Tools durch Befehlszeilenskripte zu ersetzen, sondern Ihnen beizubringen, wie Sie die Befehlszeile effektiv nutzen können, um vorhandene Funktionen zu verbessern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im gesamten Buch finden Sie Beispiele für Sicherheitsmethoden wie Datenerfassung, Analyse und Penetrationstests. </font><font style="vertical-align: inherit;">Der Zweck dieser Beispiele besteht darin, die Befehlszeilenfunktionen zu demonstrieren und Ihnen einige der grundlegenden Methoden vorzustellen, die in übergeordneten Tools verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Buch ist keine Einführung in die Programmierung, obwohl einige allgemeine Konzepte in Teil I behandelt werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokollüberwachung in Echtzeit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Fähigkeit, ein Magazin nach dem Eintreten eines Ereignisses zu analysieren, ist eine wichtige Fähigkeit. </font><font style="vertical-align: inherit;">Genauso wichtig ist es jedoch, Informationen in Echtzeit aus der Protokolldatei extrahieren zu können, um böswillige oder verdächtige Aktionen zum Zeitpunkt ihres Auftretens zu erkennen. </font><font style="vertical-align: inherit;">In diesem Kapitel werden Methoden zum Lesen von Journaleinträgen betrachtet, wenn diese erstellt und formatiert werden, um Analysen anzuzeigen und Warnungen basierend auf bekannten Bedrohungsindikatoren für den Betrieb eines Systems oder Netzwerks zu generieren (Indikatoren für Kompromisse).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textprotokollüberwachung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste Möglichkeit, das Protokoll in Echtzeit zu überwachen, besteht darin, den Befehl tail mit dem Parameter –f zu verwenden. Er liest die Datei kontinuierlich und zeigt sie in stdout an, wenn neue Zeilen hinzugefügt werden. Wie in den vorherigen Kapiteln wird beispielsweise das Zugriffsprotokoll des Apache-Webservers verwendet, die beschriebenen Methoden sind jedoch für jedes Textprotokoll relevant. Geben Sie Folgendes ein, um das Apache-Zugriffsprotokoll mit dem Befehl tail zu verfolgen: </font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ausgabe des Befehls tail kann an den Befehl grep übergeben werden, sodass nur Datensätze angezeigt werden, die bestimmten Kriterien entsprechen. Im folgenden Beispiel wird das Apache-Zugriffsprotokoll verfolgt und Einträge angezeigt, die einer bestimmten IP-Adresse entsprechen:</font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | grep '10.0.0.152'<br>
</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können auch reguläre Ausdrücke verwenden. In diesem Beispiel werden nur Datensätze angezeigt, die den HTTP 404-Statuscode "Seite nicht gefunden" zurückgeben. Die Option -i wird hinzugefügt, um den Fall von Zeichen zu ignorieren: </font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | egrep -i 'HTTP/.*" 404'</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um fremde Informationen zu löschen, sollte die Ausgabe an den Befehl cut übergeben werden. In diesem Beispiel wird das Zugriffsprotokoll auf Abfragen überwacht, die zum Statuscode 404 führen, und anschließend mit der Schnittmethode nur das Datum / die Uhrzeit und die angeforderte Seite angezeigt: </font><font style="vertical-align: inherit;">
Um die eckigen Klammern und doppelten Anführungszeichen zu entfernen, können Sie die Ausgabe an tr -d 'weiterleiten. [] "'.</font></font><br>
<br>
<code>$ tail -f access.log | egrep --line-buffered 'HTTP/.*" 404' | cut -d' ' -f4-7<br>
[29/Jul/2018:13:10:05 -0400] "GET /test<br>
[29/Jul/2018:13:16:17 -0400] "GET /test.txt<br>
[29/Jul/2018:13:17:37 -0400] "GET /favicon.ico</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis: Hier wird die Option --line-buffering des Befehls egrep verwendet. </font><font style="vertical-align: inherit;">Dies zwingt egrep, jedes Mal, wenn ein Zeilenumbruch auftritt, auf stdout zu drucken. </font><font style="vertical-align: inherit;">Ohne diesen Parameter erfolgt eine Pufferung und die Ausgabe wird erst an den Befehl cut gesendet, wenn der Puffer voll ist. </font><font style="vertical-align: inherit;">Wir wollen nicht so lange warten. </font><font style="vertical-align: inherit;">Mit dieser Option kann der Befehl egrep jede gefundene Zeile schreiben.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEFEHLSLINIENPUFFER </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert beim Puffern? </font><font style="vertical-align: inherit;">Stellen Sie sich vor, egrep findet viele Zeichenfolgen, die dem angegebenen Muster entsprechen. </font><font style="vertical-align: inherit;">In diesem Fall wird egrep viel ausgegeben. </font><font style="vertical-align: inherit;">Die Ausgabe (in der Tat jede Eingabe oder Ausgabe) ist jedoch viel teurer (nimmt mehr Zeit in Anspruch) als die Datenverarbeitung (Textsuche). </font><font style="vertical-align: inherit;">Je weniger E / A-Aufrufe vorhanden sind, desto effizienter ist das Programm.</font></font><br>
<br>
     grep       ,  ,          .         .  grep       .   ,  grep   50    .   ,     50  ,     ,     .   50  !<br>
<br>
       egrep, ,             .  egrep       ,     ,     .    ,    ,   ,      ,      .      ,     .<br>
<br>
    ,    ,  tail -f        (    ),       . ,       « »,      .     .          .<br>
<br>
   ,        egrep     ,     .        ,   .</blockquote><br>
<h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit den Befehlen tail und egrep können Sie das Protokoll überwachen und alle Einträge anzeigen, die bekannten Mustern verdächtiger oder böswilliger Aktivitäten entsprechen, die häufig als IOCs bezeichnet werden. Sie können ein einfaches Intrusion Detection System (IDS) erstellen. Erstellen Sie zunächst eine Datei mit den Mustern für reguläre Ausdrücke für das IOC (siehe Beispiel 8.1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel 8.1. ioc.txt </font><b><font style="vertical-align: inherit;">(1)</font></b><font style="vertical-align: inherit;"> Diese Vorlage (../) ist ein Indikator für einen Verzeichnis-Bypass-Angriff: Ein Angreifer versucht, das aktuelle Arbeitsverzeichnis zu verlassen und auf Dateien zuzugreifen, auf die er nicht zugreifen kann. </font><b><font style="vertical-align: inherit;">(2)</font></b><font style="vertical-align: inherit;"> Linux-Dateien etc / passwd und etc / shadow werden zur Authentifizierung des Systems verwendet und sollten niemals über einen Webserver aufgerufen werden. </font><b><font style="vertical-align: inherit;">(3)</font></b></font><br>
<br>
<code>\.\./ <b>(1)</b><br>
etc/passwd <b>(2)</b><br>
etc/shadow<br>
cmd\.exe <b>(3)</b><br>
/bin/sh<br>
/bin/bash<br>
</code><br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Bereitstellen der Dateien cmd.exe, / bin / sh oder / bin / bash ist ein Hinweis auf die vom Webserver zurückgegebene umgekehrte Verbindung. Eine umgekehrte Verbindung zeigt häufig einen erfolgreichen Betriebsversuch an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass IOCs im Regex-Format vorliegen müssen, da sie später vom Befehl egrep verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datei ioc.txt kann mit der Option egrep -f verwendet werden. Dieser Parameter weist egrep an, die Muster für reguläre Ausdrücke aus der angegebenen Datei zu durchsuchen. Auf diese Weise können Sie den Befehl tail verwenden, um die Protokolldatei zu überwachen. Wenn jeder Datensatz hinzugefügt wird, wird die Lesezeile mit allen Vorlagen in der IOC-Datei verglichen und der entsprechende Datensatz angezeigt. Hier ist ein Beispiel:</font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | egrep -i -f ioc.txt</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus kann der Befehl tee verwendet werden, um Warnungen gleichzeitig auf dem Bildschirm anzuzeigen und zur späteren Verarbeitung in einer eigenen Datei zu speichern: </font><font style="vertical-align: inherit;">
Auch hier ist die Option --line-buffered erforderlich, um sicherzustellen, dass keine Probleme durch das Puffern der Ausgabe des Befehls auftreten.</font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | egrep --line-buffered -i -f ioc.txt |<br>
tee -a interesting.txt</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows-Protokollüberwachung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erwähnt, müssen Sie den Befehl wevtutil verwenden, um auf Windows-Ereignisse zuzugreifen. </font><font style="vertical-align: inherit;">Obwohl dieser Befehl universell ist, verfügt er nicht über Funktionen wie tail, mit denen neue eingehende Datensätze abgerufen werden können. </font><font style="vertical-align: inherit;">Es gibt jedoch einen Ausweg: Verwenden Sie ein einfaches Bash-Skript, das dieselbe Funktionalität bietet (Beispiel 8.2). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel 8.2. </font><font style="vertical-align: inherit;">wintail.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# wintail.sh<font></font>
#<font></font>
# :<font></font>
#    tail   Windows<font></font>
#<font></font>
# : ./wintail.sh<font></font>
#<font></font>
<font></font>
WINLOG=<span class="hljs-string">"Application"</span> (<span class="hljs-number">1</span>)<font></font>
<font></font>
LASTLOG=$(wevtutil qe <span class="hljs-string">"$WINLOG"</span> <span class="hljs-comment">//c:1 //rd:true //f:text) (2)</span><font></font>
<font></font>
<span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span>
<span class="hljs-keyword">do</span>
      CURRENTLOG=$(wevtutil qe <span class="hljs-string">"$WINLOG"</span> <span class="hljs-comment">//c:1 //rd:true //f:text) (3)</span>
      <span class="hljs-keyword">if</span> [[ <span class="hljs-string">"$CURRENTLOG"</span> != <span class="hljs-string">"$LASTLOG"</span> ]]<font></font>
      then<font></font>
            echo <span class="hljs-string">"$CURRENTLOG"</span>
            echo <span class="hljs-string">"----------------------------------"</span>
            LASTLOG=<span class="hljs-string">"$CURRENTLOG"</span><font></font>
      fi<font></font>
done</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Variable definiert das Windows-Protokoll, das Sie verfolgen möchten. Für eine Liste der derzeit auf dem System verfügbaren Protokolle können Sie den Befehl wevtutil el verwenden. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier wird wevtutil ausgeführt, um die angegebene Protokolldatei anzufordern. Der Parameter c: 1 gibt nur einen Protokolleintrag zurück. Mit dem Parameter rd: true kann der Befehl den neuesten Protokolleintrag lesen. Schließlich gibt f: text das Ergebnis im Klartext und nicht im XML-Format zurück, wodurch das Lesen des Ergebnisses auf dem Bildschirm vereinfacht wird. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den nächsten Zeilen wird der Befehl wevtutil erneut ausgeführt, und der neu empfangene Protokolleintrag wird mit dem zuletzt auf dem Bildschirm gedruckten verglichen. </font><font style="vertical-align: inherit;">Wenn sie sich voneinander unterscheiden, bedeutet dies, dass Änderungen im Protokoll vorgenommen wurden. </font><font style="vertical-align: inherit;">In diesem Fall wird ein neuer Eintrag angezeigt. </font><font style="vertical-align: inherit;">Wenn die verglichenen Datensätze identisch sind, geschieht nichts und der Befehl wevtutil geht zurück und beginnt erneut zu suchen und zu vergleichen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellung eines Echtzeit-Histogramms</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Befehl tail -f stellt den aktuellen Datenstrom bereit. </font><font style="vertical-align: inherit;">Was aber, wenn Sie die Anzahl der Zeilen zählen möchten, die für einen bestimmten Zeitraum zur Datei hinzugefügt wurden? </font><font style="vertical-align: inherit;">Sie können diesen Datenstrom beobachten, einen Timer starten und über einen bestimmten Zeitraum zählen. </font><font style="vertical-align: inherit;">dann sollte die Zählung gestoppt und die Ergebnisse gemeldet werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Arbeit kann in zwei Skriptprozesse unterteilt werden: Ein Skript liest die Zeilen und das andere überwacht die Uhrzeit. Der Timer benachrichtigt den Leitungszähler unter Verwendung eines Standard-POSIX-Interprozess-Kommunikationsmechanismus, der als Signal bezeichnet wird. Ein Signal ist ein Software-Interrupt, und es gibt verschiedene Arten von Signalen. Einige von ihnen sind schwerwiegend - sie führen zum Ende des Prozesses (z. B. eine Ausnahme bei einer Gleitkommaoperation). Die meisten dieser Signale können entweder ignoriert oder abgefangen werden. Es wird eine Aktion ausgeführt, wenn ein Signal abgefangen wird. Viele dieser Signale haben im Betriebssystem einen vordefinierten Zweck. Wir werden eines von zwei Signalen verwenden, die den Benutzern zur Verfügung stehen. Dies ist das Signal SIGUSR1 (das andere ist SIGUSR2).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Shell-Skripte können Interrupts mit dem integrierten Trap-Befehl abfangen. Mit ihm können Sie einen Befehl auswählen, der bestimmt, welche Aktion Sie ausführen möchten, wenn ein Signal empfangen wird, sowie eine Liste von Signalen, die einen Aufruf dieses Befehls auslösen. Beispiel: </font></font><br>
<br>
<code>trap warnmsg SIGINT</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dadurch wird der Befehl warnmsg (unser eigenes Skript oder unsere eigene Funktion) immer dann aufgerufen, wenn das Shell-Skript ein SIGINT-Signal empfängt, z. B. wenn Sie Strg + C drücken, um einen laufenden Prozess zu unterbrechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel 8.3 zeigt ein Skript, das eine Zählung durchführt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel 8.3 looper.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# looper.sh<font></font>
#<font></font>
# :<font></font>
#    <font></font>
#<font></font>
# : ./looper.sh [filename]<font></font>
# filename —  ,   ,<font></font>
#  : log.file<font></font>
#<font></font>
<font></font>
<span class="hljs-function">function <span class="hljs-title">interval</span> <span class="hljs-params">()</span>                                           <span class="hljs-params">(<span class="hljs-number">1</span>)</span>
</span>{<font></font>
      echo $(date <span class="hljs-string">'+%y%m%d %H%M%S'</span>) $cnt                       (<span class="hljs-number">2</span>)<font></font>
      cnt=<span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
declare -i cnt=<span class="hljs-number">0</span>
<span class="hljs-function">trap interval <span class="hljs-title">SIGUSR1</span>                                          <span class="hljs-params">(<span class="hljs-number">3</span>)</span>

shopt -s <span class="hljs-title">lastpipe</span>                                              <span class="hljs-params">(<span class="hljs-number">4</span>)</span>

tail -f --pid</span>=$$ ${<span class="hljs-number">1</span>:-log.file} | <span class="hljs-function"><span class="hljs-keyword">while</span> read <span class="hljs-title">aline</span>             <span class="hljs-params">(<span class="hljs-number">5</span>)</span>
<span class="hljs-keyword">do</span>
     let cnt++
done</span></code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Intervallfunktion wird beim Empfang jedes Signals aufgerufen. Natürlich muss das Intervall definiert werden, bevor wir es benennen und Trap in unserem Ausdruck verwenden können. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Befehl date wird aufgerufen, um einen Zeitstempel für den Wert der zu druckenden cnt-Variablen bereitzustellen. Nachdem der Zähler angezeigt wurde, setzen wir diesen Wert auf 0 zurück, um den Countdown des nächsten Intervalls zu starten. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem das Intervall definiert ist, können wir anzeigen, dass die Funktion immer dann aufgerufen wird, wenn unser Prozess das Signal SIGUSR1 empfängt. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein sehr wichtiger Schritt. Wenn eine Pipeline von Befehlen vorhanden ist (z. B. ls-l | grep rwx | wc), werden normalerweise Teile der Pipeline (jeder Befehl) in Subnetzen ausgeführt und jeder Prozess endet mit einer eigenen Prozesskennung. Dies könnte ein Problem für dieses Szenario sein, da sich die while-Schleife in einer Subshell mit einer anderen Prozesskennung befindet. Unabhängig davon, welcher Prozess gestartet wird, kennt das Skript looper.sh die Kennung des while-Schleifenprozesses nicht, um ein Signal an ihn zu senden. Darüber hinaus ändert das Ändern des Werts der Variablen cnt in der Unterschale nicht den Wert von cnt im Hauptprozess, sodass das Signal für den Hauptprozess jedes Mal den Wert auf 0 setzt. Sie können dieses Problem mit dem Befehl shopt lösen, der den Parameter (-s) auf lastpipe setzt. Es weist die Shell an, keine Subshell für den letzten Befehl in der Pipeline zu erstellen.und führen Sie diesen Befehl im selben Prozess wie das Skript selbst aus. In unserem Fall bedeutet dies, dass der Befehl tail in einer Subshell (dh in einem anderen Prozess) ausgeführt wird und die while-Schleife Teil des Hauptskriptprozesses wird. Hinweis: Diese Shell-Option ist nur in Bash-Version 4.x und höher und nur für nicht interaktive Shells (d. H. Skripte) verfügbar.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(5)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist der Befehl tail -f mit einem anderen Parameter --pid. Wir geben die Kennung des Prozesses an, der nach Abschluss dieses Prozesses den Befehl tail ausführt. Wir geben die Prozess-ID des aktuellen Shell-Skripts $$ an, das angezeigt werden soll. Mit dieser Aktion können Sie Prozesse bereinigen und den Befehl tail nicht im Hintergrund ausführen lassen (wenn dieses Skript beispielsweise im Hintergrund ausgeführt wird; Beispiel 8.4). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Skript tailcount.sh startet und stoppt das Skript mit einer Stoppuhr (Timer) und zählt die Zeitintervalle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel 8.4. tailcount.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# tailcount.sh<font></font>
#<font></font>
# :<font></font>
#    n <font></font>
#<font></font>
# : ./tailcount.sh [filename]<font></font>
#     filename:  looper.sh<font></font>
#<font></font>
<font></font>
#  —    <font></font>
<span class="hljs-function">function <span class="hljs-title">cleanup</span> <span class="hljs-params">()</span>
</span>{<font></font>
      [[ -n $LOPID ]] &amp;&amp; kill $LOPID          (<span class="hljs-number">1</span>)<font></font>
}<font></font>
<font></font>
<span class="hljs-function">trap cleanup <span class="hljs-title">EXIT</span>                             <span class="hljs-params">(<span class="hljs-number">2</span>)</span>
bash looper.sh $1 &amp;                           <span class="hljs-params">(<span class="hljs-number">3</span>)</span>
LOPID</span>=$!                                      (<span class="hljs-number">4</span>)<font></font>
#   <font></font>
sleep <span class="hljs-number">3</span><font></font>
<font></font>
<span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span>
<span class="hljs-keyword">do</span><font></font>
      kill -SIGUSR1 $LOPID<font></font>
      sleep <span class="hljs-number">5</span>
done &gt;&amp;<span class="hljs-number">2</span>                                      (<span class="hljs-number">5</span>)</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da dieses Skript andere Skripte ausführt, sollte es nach der Arbeit bereinigt werden. Wenn die Prozesskennung in LOPID gespeichert wurde, speichert die Variable den Wert, daher sendet die Funktion mit dem Befehl kill ein Signal an diesen Prozess. Wenn Sie im Befehl kill kein bestimmtes Signal angeben, wird standardmäßig das SIGTERM-Signal gesendet. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Befehl EXIT ist kein Signal. Dies ist ein Sonderfall, wenn die Trap-Anweisung die Shell anweist, diese Funktion aufzurufen (in diesem Fall Bereinigung), wenn die Shell, die dieses Skript ausführt, heruntergefahren werden soll. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt beginnt die eigentliche Arbeit. Das Skript looper.sh wird gestartet, das im Hintergrund ausgeführt wird: Damit dieses Skript während des gesamten Zyklus funktioniert (ohne darauf zu warten, dass der Befehl die Arbeit abschließt), wird es von der Tastatur getrennt. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier wird die Kennung des Skriptprozesses gespeichert, den wir gerade im Hintergrund gestartet haben. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(5)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Weiterleitung ist lediglich eine Vorsichtsmaßnahme. Alle Ausgaben, die von einer while-Schleife oder von kill / sleep-Anweisungen stammen (obwohl wir sie nicht erwarten), sollten nicht mit Ausgaben der Funktion looper.sh gemischt werden, die sie, obwohl sie im Hintergrund funktioniert, trotzdem an stdout sendet. Daher leiten wir Daten von stdout nach stderr um.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammenfassend sehen wir, dass die Funktion looper.sh zwar im Hintergrund platziert wurde, ihre Prozesskennung jedoch in einer Shell-Variablen gespeichert ist. Alle fünf Sekunden sendet das Skript tailcount.sh ein Signal SIGUSR1 an diesen Prozess (der in der Funktion looper.sh ausgeführt wird), der seinerseits das Skript looper.sh aufruft, um die aktuelle Anzahl der darin festgelegten Zeilen zu drucken und die Zählung neu zu starten. Nach dem Beenden wird das Skript tailcount.sh gelöscht, indem ein SIGTERM-Signal an die Funktion looper.sh gesendet wird, um es zu unterbrechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mithilfe von zwei Skripten - einem Skript, das die Zeilenzählung durchführt, und einem Skript mit einer Stoppuhr (Timer), die das erste Skript steuert - können Sie die Ausgabe (die Anzahl der Zeilen für einen bestimmten Zeitraum) abrufen, auf deren Grundlage das nächste Skript ein Histogramm erstellt. Es heißt so:</font></font><br>
<br>
<code>bash tailcount.sh | bash livebar.sh</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Skript livebar.sh liest Daten aus stdin und druckt die Ausgabe in stdout, eine Zeile für jede Eingabezeile (Beispiel 8.5). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel 8.5 </font><font style="vertical-align: inherit;">livebar.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# livebar.sh<font></font>
#<font></font>
# :<font></font>
#    «» <font></font>
#<font></font>
# :<font></font>
# &lt;output from other script or program&gt; | bash livebar.sh<font></font>
#<font></font>
<font></font>
<span class="hljs-function">function <span class="hljs-title">pr_bar</span> <span class="hljs-params">()</span>                                         <span class="hljs-params">(<span class="hljs-number">1</span>)</span>
</span>{<font></font>
      local raw maxraw scaled<font></font>
      raw=$<span class="hljs-number">1</span>
      maxraw=$<span class="hljs-number">2</span><font></font>
      ((scaled=(maxbar*raw)/maxraw))<font></font>
      ((scaled == <span class="hljs-number">0</span>)) &amp;&amp; scaled=<span class="hljs-number">1</span> #   
      <span class="hljs-keyword">for</span>((i=<span class="hljs-number">0</span>; i&lt;scaled; i++)) ; <span class="hljs-keyword">do</span> printf <span class="hljs-string">'#'</span> ; done<font></font>
      printf <span class="hljs-string">'\n'</span><font></font>
<font></font>
} # pr_bar<font></font>
<font></font>
maxbar=<span class="hljs-number">60</span>     #         (<span class="hljs-number">2</span>)<font></font>
MAX=<span class="hljs-number">60</span>
<span class="hljs-function"><span class="hljs-keyword">while</span> read dayst timst qty
<span class="hljs-keyword">do</span>
      <span class="hljs-title">if</span> <span class="hljs-params">(( qty &gt; MAX )</span>)                                   <span class="hljs-params">(<span class="hljs-number">3</span>)</span>
      then
           let MAX</span>=$qty+$qty/<span class="hljs-number">4</span>    #   <font></font>
           echo <span class="hljs-string">"                      **** rescaling: MAX=$MAX"</span><font></font>
      fi<font></font>
      printf <span class="hljs-string">'%6.6s %6.6s %4d:'</span> $dayst $timst $qty         (<span class="hljs-number">4</span>)<font></font>
      pr_bar $qty $MAX<font></font>
done<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Funktion pr_bar zeigt eine Zeichenfolge von Hashtags an, die basierend auf den angegebenen Parametern auf die maximale Größe skaliert werden. </font><font style="vertical-align: inherit;">Diese Funktion scheint vertraut zu sein, da wir sie zuvor im Skript histogram.sh verwendet haben. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist die längste Hashtag-Zeilengröße, die wir zulassen können (ohne Zeilenumbruch). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie groß werden die anzuzeigenden Werte sein? Ohne dies vorher zu wissen (obwohl diese Daten dem Skript als Argument zur Verfügung gestellt werden können), verfolgt das Skript das Maximum. Wenn dieses Maximum überschritten wird, beginnt der Wert zu „skalieren“ und die jetzt angezeigten Linien. Zukünftige Linien werden ebenfalls auf ein neues Maximum skaliert. Das Skript addiert 25% zum Maximalwert, sodass der Wert nicht skaliert werden muss, wenn der nächste neue Wert jedes Mal nur um 1-2% erhöht wird. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf definiert die minimale und maximale Breite der ersten beiden zu druckenden Felder. </font><font style="vertical-align: inherit;">Dies sind Datums- und Zeitstempel, die abgeschnitten werden, wenn die Breitenwerte überschritten werden. </font><font style="vertical-align: inherit;">Geben Sie die Breite von vier Zeichen an, um den gesamten Wert anzuzeigen. </font><font style="vertical-align: inherit;">In diesem Fall werden trotz der Einschränkungen alle Werte gedruckt. </font><font style="vertical-align: inherit;">Wenn die Anzahl der Zeichen in den Werten weniger als vier beträgt, werden die fehlenden durch Leerzeichen ergänzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da dieses Skript von stdin gelesen wird, können Sie es selbst ausführen, um zu sehen, wie es sich verhält. </font><font style="vertical-align: inherit;">Hier ist ein Beispiel:</font></font><br>
<br>
<pre><code class="java hljs">$ bash  livebar.sh
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">20</span>
<span class="hljs-number">201010</span>     <span class="hljs-number">1020</span> <span class="hljs-number">20</span>:####################
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">70</span>
                       **** rescaling: MAX=<span class="hljs-number">87</span>
<span class="hljs-number">201010</span>     <span class="hljs-number">1020</span> <span class="hljs-number">70</span>:################################################
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">75</span>
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">75</span>:###################################################<font></font>
^C</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel wird die Eingabe mit der Ausgabe gemischt. </font><font style="vertical-align: inherit;">Sie können auch Eingaben in eine Datei einfügen und diese in ein Skript umleiten, um nur die Ausgabe anzuzeigen:</font></font><br>
<br>
<pre><code class="java hljs">$ bash livebar.sh &lt; testdata.txt<font></font>
bash livebar.sh &lt; x.data<font></font>
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">20</span>:####################<font></font>
                 **** rescaling: MAX=<span class="hljs-number">87</span>
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">70</span>:################################################
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">75</span>:###################################################<font></font>
$</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»Weitere Informationen zum Buch finden Sie auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Website des Herausgebers.</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalt</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auszug</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
für Khabrozhiteley 25% Rabatt auf den Gutschein - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bash</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nach Zahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de501510/index.html">Ein neuer Blick auf die Fullstack-Entwicklung mit dem Ruby on Rails-Framework</a></li>
<li><a href="../de501516/index.html">Lassen Sie uns das Vakuum ausschalten ?! Alexey Lesovsky</a></li>
<li><a href="../de501520/index.html">C # 8 und Nullgültigkeit. Wie leben wir damit?</a></li>
<li><a href="../de501522/index.html">Kostenlose Skillbox-Webinare: Schreiben von Spielen in PHP, Unity und Unreal Engine</a></li>
<li><a href="../de501526/index.html">Warum wird kanadisches Englisch als "schmutzig" angesehen und was hat Keanu Reeves damit zu tun?</a></li>
<li><a href="../de501534/index.html">Jetzt mit COVID-19 gibt es auch einen Ausschlag</a></li>
<li><a href="../de501536/index.html">Maßgeschneidert: Eine Geschichte darüber, wie aus einer Codezeile Kilotonnen Kohle wurden</a></li>
<li><a href="../de501538/index.html">Einrückung in Python - Lösungsoption</a></li>
<li><a href="../de501544/index.html">Perfektes Smartphone</a></li>
<li><a href="../de501546/index.html">"Warum mache ich das durch?" - Psychologen erklären, wie man isoliert Sinn findet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>