<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💒 🍲 🥊 リアルタイムサービスの例に関するQおよびKDB +の機能 👨🏼‍🌾 👩🏿‍✈️ 🍚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="KDB +ベース、Qプログラミング言語、それらの長所と短所については、以前の記事で読むことができます。はじめに簡単に。この記事では、Qにサービスを実装して、着信データストリームを処理し、「リアルタイム」モードで1分あたりのさまざまな集計関数を計算します（つまり、次のデータまですべてを計算する時間があ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>リアルタイムサービスの例に関するQおよびKDB +の機能</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dbtc/blog/470596/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KDB +ベース、Qプログラミング言語、それらの長所と短所については、以前の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">記事で</font></a><font style="vertical-align: inherit;">読むことができます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はじめに簡単に。</font><font style="vertical-align: inherit;">この記事では、Qにサービスを実装して、着信データストリームを処理し、「リアルタイム」モードで1分あたりのさまざまな集計関数を計算します（つまり、次のデータまですべてを計算する時間があります）。</font><font style="vertical-align: inherit;">Qの主な機能は、単一のオブジェクトではなく、その配列、配列の配列、およびその他の複雑なオブジェクトを操作できるベクトル言語であることです。</font><font style="vertical-align: inherit;">Qやそれに関連するK、J、APLなどの言語は、その簡潔さで有名です。</font><font style="vertical-align: inherit;">多くの場合、Javaなどの使い慣れた言語でコードの複数の画面にまたがるプログラムは、複数の行で記述することができます。</font><font style="vertical-align: inherit;">これはまさにこの記事で説明したいことです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wb/ej/zy/wbejzyzkg_-aypnh92it6kecrtq.jpeg"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KDB +は、特定の方法（主に時間順）でソートされた、非常に大量のデータに焦点を当てた列データベースです。まず、金融機関-銀行、投資ファンド、保険会社などで使用されています。 Q言語はKDB +の内部言語であり、このデータを効果的に使用することができます。 Qのイデオロギーは簡潔さと効率性ですが、明快さは犠牲になります。これは、いずれにしてもベクトル言語が認識しにくくなるという事実によって正当化され、録音の簡潔さと豊富さにより、プログラムのはるかに大きな部分を1つの画面で見ることができ、最終的には理解が容易になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、本格的なQプログラムを実装しています。ぜひお試しください。</font><font style="vertical-align: inherit;">これを行うには、Q自体が必要です。無料の32ビットバージョンは、kx社のWebサイト（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.kx.com）から</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダウンロードできます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">同じ場所で、興味があれば、Qのリファレンス情報、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q For Mortals</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という本</font><font style="vertical-align: inherit;">、このトピックに関するさまざまな記事</font><font style="vertical-align: inherit;">を見つけることができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の定式化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
25ミリ秒ごとにデータテーブルを送信するソースがあります。 KDB +は主に金融で使用されるため、次の列がある取引テーブルであると想定します。時間（ミリ秒単位の時間）、sym（取引所の会社名</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-IBM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AAPL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など）、価格（価格株の購入元）、サイズ（取引サイズ）。 25ミリ秒の間隔は任意に選択され、小さすぎず、大きすぎません。その存在は、サービスに到着するデータがすでにバッファリングされていることを意味します。現在の負荷に応じて、動的バッファリングを含め、サービス側でバッファリングを実装するのは簡単ですが、簡単にするために、一定の間隔で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービスは、sym列からの各着信文字の1分ごとに、集計関数のセット（最大価格、平均価格、合計サイズなど）をカウントする必要があります。</font><font style="vertical-align: inherit;">有用な情報。</font><font style="vertical-align: inherit;">簡単にするために、すべての関数は増分的に計算できると仮定します。</font><font style="vertical-align: inherit;">新しい値を取得するには、古い値と入力値の2つの数値を知っていれば十分です。</font><font style="vertical-align: inherit;">たとえば、max、average、sum関数にはこのプロパティがありますが、median関数にはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、着信データストリームは時間順に並べられているものとします。</font><font style="vertical-align: inherit;">これにより、土壇場でのみ作業する機会が得られます。</font><font style="vertical-align: inherit;">実際には、更新が遅れた場合に備えて、現在および過去の分で作業できれば十分です。</font><font style="vertical-align: inherit;">簡単にするため、このケースは考慮しません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集計関数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に、必要な集計関数を示します。</font><font style="vertical-align: inherit;">サービスの負荷を増やすために、可能な限りそれらを使用しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高-最大価格-1分あたりの最大価格。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低-最小価格-1分あたりの最小価格。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">firstPrice-最初の価格-1分あたりの最初の価格。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lastPrice-最終価格-1分あたりの最終価格。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">firstSize-最初のサイズ-分の最初の取引サイズ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lastSize-最後のサイズ-分の最後の取引サイズ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numTrades-count i-1分あたりのトランザクション数。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボリューム-合計サイズ-1分あたりのトランザクションサイズの合計。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pvolume-合計価格-1分あたりの価格の合計。avgPriceに必要です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">売上高-合計価格*サイズ-1分あたりのトランザクションの合計量。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avgPrice-pvolume％numTrades-1分あたりの平均価格。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avgSize-volume％numTrades-1分あたりの平均取引サイズ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vwap-回転率％-トランザクションのサイズで重み付けされた1分あたりの平均価格。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cumVolume-合計ボリューム-全体の累積トランザクションサイズ。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの列を初めて初期化する方法と次の1分ごとに初期化する方法について、すぐにわかりにくい点を1つすぐに説明します。</font><font style="vertical-align: inherit;">firstPrice型の一部の列は、毎回nullで初期化する必要があります。それらの値は未定義です。</font><font style="vertical-align: inherit;">他のタイプのボリュームは常に0に設定する必要があります。たとえば、cumVolumeは直前の分からコピーする必要があり、最初のセットは0に設定する必要があるなど、列がまだ残っています。データタイプディクショナリを使用してこれらすべてのパラメーターを設定します（レコードのアナログ）。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// list ! list –  , 0n – float null, 0N – long null, `sym –  , `sym1`sym2 –  </span>
initWith:`sym`time`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover`avgPrice`avgSize`vwap`cumVolume!(`;<span class="hljs-number">00</span>:<span class="hljs-number">00</span>;<span class="hljs-number">0</span>n;<span class="hljs-number">0</span>n;<span class="hljs-number">0</span>n;<span class="hljs-number">0</span>n;<span class="hljs-number">0</span>N;<span class="hljs-number">0</span>N;<span class="hljs-number">0</span>;<span class="hljs-number">0</span>;<span class="hljs-number">0.0</span>;<span class="hljs-number">0.0</span>;<span class="hljs-number">0</span>n;<span class="hljs-number">0</span>n;<span class="hljs-number">0</span>n;<span class="hljs-number">0</span>);<font></font>
aggCols:reverse key[initWith] except `sym`time; <span class="hljs-comment">//    , reverse  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
便宜上、symとtimeをディクショナリに追加しました。これで、initWithは、最終的な集計テーブルの完成した行であり、正しいsymと時刻を設定するために残っています。</font><font style="vertical-align: inherit;">これを使用して、テーブルに新しい行を追加できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
集計関数を作成するときに必要なaggCols。</font><font style="vertical-align: inherit;">Qで式が計算される順序の特殊性（右から左）のため、リストを逆にする必要があります。</font><font style="vertical-align: inherit;">一部の列は前の列に依存しているため、目標は高からcumVolumeの方向に計算を提供することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のものから新しい分にコピーされる列、便宜上sym列が追加されました：</font></font><br>
<br>
<pre><code class="cpp hljs">rollColumns:`sym`cumVolume;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、更新方法に応じて列をグループに分けます。</font><font style="vertical-align: inherit;">次の3つのタイプを区別できます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッテリー（ボリューム、ターンオーバー、..）-前のバッテリーに入力値を追加する必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特別なポイント（高、低、..）がある場合-1分の最初の値が入力データから取得され、残りは関数を使用してカウントされます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残り。</font><font style="vertical-align: inherit;">常に関数を使用してカウントされます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのクラスの変数を定義します。</font></font><br>
<br>
<pre><code class="cpp hljs">accumulatorCols:`numTrades`volume`pvolume`turnover;<font></font>
specialCols:`high`low`firstPrice`firstSize;<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算順序</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
集計テーブルは2段階で更新されます。</font><font style="vertical-align: inherit;">効率を上げるために、最初に入力テーブルを縮小して、文字と分ごとに1行が残るようにします。</font><font style="vertical-align: inherit;">私たちのすべての機能は増分的であり、関連性があるという事実は、この追加のステップからの結果が変化しないことを保証します。</font><font style="vertical-align: inherit;">あなたはselectの助けを借りてテーブルを絞ることができます：</font></font><br>
<br>
<pre><code class="cpp hljs">select high:max price, low:min price … by sym,time.minute from table
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドにはマイナスがあります-計算された列のセットは事前定義されています。</font><font style="vertical-align: inherit;">幸い、Qでは、選択は動的に作成された引数で置き換えることができる関数としても実装されています。</font></font><br>
<br>
<pre><code class="cpp hljs">?[table;whereClause;byClause;selectClause]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引数の形式については詳しく説明しませんが、今回の場合、select式のみが重要であり、それらは列columnの辞書でなければなりません！式。</font><font style="vertical-align: inherit;">したがって、収縮関数は次のように定義できます。</font></font><br>
<br>
<pre><code class="cpp hljs">selExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover!<span class="hljs-function">parse <span class="hljs-title">each</span> <span class="hljs-params">(<span class="hljs-string">"max price"</span>;<span class="hljs-string">"min price"</span>;<span class="hljs-string">"first price"</span>;<span class="hljs-string">"last price"</span>;<span class="hljs-string">"first size"</span>;<span class="hljs-string">"last size"</span>;<span class="hljs-string">"count i"</span>;<span class="hljs-string">"sum size"</span>;<span class="hljs-string">"sum price"</span>;<span class="hljs-string">"sum price*size"</span>)</span></span>; <span class="hljs-comment">// each   map  Q   </span><font></font>
preprocess:?[;();`sym`time!`sym`time.minute;selExpression];<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
わかりやすくするために、私は解析関数を使用しました。これは、Q式を含む文字列をeval関数に渡すことができる値に変換し、関数selectで必要です。</font><font style="vertical-align: inherit;">また、プリプロセスは、select関数の射影（つまり、部分的に引数が定義された関数）として定義されており、1つの引数（テーブル）が欠落していることにも注意してください。</font><font style="vertical-align: inherit;">テーブルに前処理を適用すると、縮小されたテーブルが作成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の段階は、集計テーブルの更新です。</font><font style="vertical-align: inherit;">最初に、アルゴリズムを疑似コードで記述します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> each sym in inputTable<font></font>
  idx: row index in agg table <span class="hljs-keyword">for</span> sym+currentTime;<font></font>
  aggTable[idx;`high]: aggTable[idx;`high] | inputTable[sym;`high];<font></font>
  aggTable[idx;`volume]: aggTable[idx;`volume] + inputTable[sym;`volume];<font></font>
  …<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qでは、ループの代わりに、map / reduce関数を使用するのが慣例です。</font><font style="vertical-align: inherit;">しかし、Qはベクトル言語であり、すべての操作を一度にすべてのシンボルに安全に適用できるので、最初の近似として、すべてのシンボルを一度に操作せずに、サイクルなしで実行できます。</font></font><br>
<br>
<pre><code class="cpp hljs">idx:calcIdx inputTable;<font></font>
row:aggTable idx;<font></font>
aggTable[idx;`high]: row[`high] | inputTable`high;<font></font>
aggTable[idx;`volume]: row[`volume] + inputTable`volume;<font></font>
…<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに先に進むことができます。Qには、独特で非常に強力な演算子、一般化された代入演算子があります。</font><font style="vertical-align: inherit;">インデックス、関数、引数のリストを使用して、複雑なデータ構造の値のセットを変更できます。</font><font style="vertical-align: inherit;">私たちの場合は、次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs">idx:calcIdx inputTable;<font></font>
rows:aggTable idx;<font></font>
<span class="hljs-comment">// .[target;(idx0;idx1;..);function;argument] ~ target[idx 0;idx 1;…]: function[target[idx 0;idx 1;…];argument],     –  </span><font></font>
.[aggTable;(idx;aggCols);:;flip (row[`high] | inputTable`high;row[`volume] + inputTable`volume;…)];<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、テーブルに割り当てるには列ではなく行のリストが必要であり、フリップ関数を使用して行列（列のリストを行のリストに）を転置する必要があります。</font><font style="vertical-align: inherit;">大きなテーブルの場合、これは不要です。代わりに、map関数（アポストロフィのように見えます）を使用して、各列に汎用の割り当てを個別に適用します。</font></font><br>
<br>
<pre><code class="sql hljs">.[aggTable;;:;]'[(idx;)each aggCols; (row[`high] | inputTable`high;row[`volume] + inputTable`volume;…)];
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再び投影関数を使用します。</font><font style="vertical-align: inherit;">また、Qでは、リストの作成も関数であり、each（マップ）関数を使用してそれを呼び出し、リストのリストを取得できることにも注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計算された列のセットが固定されないように、上記の式を動的に作成します。</font><font style="vertical-align: inherit;">最初に、rowおよびinp変数を使用して各列を計算する関数を定義し、集計データおよび入力データを参照します。</font></font><br>
<br>
<pre><code class="cpp hljs">aggExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`avgPrice`avgSize`vwap`cumVolume!<font></font>
 (<span class="hljs-string">"row[`high]|inp`high"</span>;<span class="hljs-string">"row[`low]&amp;inp`low"</span>;<span class="hljs-string">"row`firstPrice"</span>;<span class="hljs-string">"inp`lastPrice"</span>;<span class="hljs-string">"row`firstSize"</span>;<span class="hljs-string">"inp`lastSize"</span>;<span class="hljs-string">"pvolume%numTrades"</span>;<span class="hljs-string">"volume%numTrades"</span>;<span class="hljs-string">"turnover%volume"</span>;<span class="hljs-string">"row[`cumVolume]+inp`volume"</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部の列は特別です。最初の値を関数で計算しないでください。</font><font style="vertical-align: inherit;">それが列行[`numTrades]の最初であると判断できます。0の場合、値が最初です。</font><font style="vertical-align: inherit;">Qには選択関数があります-？[ブールリスト;リスト1;リスト2]-最初の引数の条件に応じてリスト1または2から値を選択します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// high -&gt; ?[isFirst;inp`high;row[`high]|inp`high]</span>
<span class="hljs-comment">// @ -        </span>
@[`aggExpression;specialCols;{[x;y]<span class="hljs-string">"?[isFirst;inp`"</span>,y,<span class="hljs-string">";"</span>,x,<span class="hljs-string">"]"</span>};<span class="hljs-built_in">string</span> specialCols];
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、関数（中括弧で囲まれた式）を使用して総称割り当てを呼び出しました。</font><font style="vertical-align: inherit;">現在の値（最初の引数）と、4番目のパラメーターで渡す追加の引数が渡されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これとは別に、バッテリースピーカーを追加します。それらの機能は同じであるためです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// volume -&gt; row[`volume]+inp`volume</span>
aggExpression[accumulatorCols]:{<span class="hljs-string">"row[`"</span>,x,<span class="hljs-string">"]+inp`"</span>,x } each <span class="hljs-built_in">string</span> accumulatorCols;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Qの標準による通常の割り当てです。値のリストを一度に割り当てるだけです。</font><font style="vertical-align: inherit;">最後に、メイン関数を作成します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ":",/:aggExprs ~ map[{":",x};aggExpr] =&gt; ":row[`high]|inp`high"    ,         </span>
<span class="hljs-comment">// string[cols],'exprs ~ map[,;string[cols];exprs] =&gt; "high:row[`high]|inp`high"   . ,’   map[concat]</span>
<span class="hljs-comment">// ";" sv exprs – String from Vector (sv),     “;” </span>
updateAgg:value <span class="hljs-string">"{[aggTable;idx;inp] row:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols;("</span>,(<span class="hljs-string">";"</span>sv <span class="hljs-built_in">string</span>[aggCols],<span class="hljs-string">'":",/:aggExpression aggCols),")]}";
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この式を使用して、上で引用した式を含む文字列から動的に関数を作成します。</font><font style="vertical-align: inherit;">結果は次のようになります。</font></font><br>
<br>
<pre><code class="sql hljs">{[aggTable;idx;inp] rows:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols ;(cumVolume:row[`cumVolume]+inp`cumVolume;… ; high:?[isFirst;inp`high;row[`high]|inp`high])]}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qでは計算の順序が右から左になるため、列の計算の順序は逆になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、計算に必要な2つの主要な関数ができました。これで、インフラストラクチャが少し追加され、サービスの準備が整いました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後のステップ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての作業を行う前処理およびupdateAgg関数があります。</font><font style="vertical-align: inherit;">ただし、正しい移行を数分で保証し、集計のインデックスを計算する必要があります。</font><font style="vertical-align: inherit;">まず、init関数を定義します。</font></font><br>
<br>
<pre><code class="cpp hljs">init:{<font></font>
  tradeAgg:: <span class="hljs-number">0</span><span class="hljs-meta">#enlist[initWith]; <span class="hljs-comment">//    , enlist    ,  0#   0   </span></span>
  currTime::<span class="hljs-number">00</span>:<span class="hljs-number">00</span>; <span class="hljs-comment">//   0, :: ,     </span>
  currSyms::`u#`symbol$(); <span class="hljs-comment">// `u# -    ,    </span>
  offset::<span class="hljs-number">0</span>; <span class="hljs-comment">//   tradeAgg,     </span>
  rollCache:: `sym xkey update `u<span class="hljs-meta">#sym from rollColumns#tradeAgg; <span class="hljs-comment">//     roll ,    sym</span></span><font></font>
 }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、現在の分を変更するロール関数を定義します。</font></font><br>
<br>
<pre><code class="cpp hljs">roll:{[tm]
  <span class="hljs-keyword">if</span>[currTime&gt;tm; :init[]]; <span class="hljs-comment">//    ,    init</span>
  rollCache,::offset _ rollColumns#tradeAgg; <span class="hljs-comment">//   –  roll   aggTable, ,   rollCache</span><font></font>
  offset::count tradeAgg;<font></font>
  currSyms::`u#`$();<font></font>
 }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい文字を追加する関数が必要です：</font></font><br>
<br>
<pre><code class="java hljs">addSyms:{[syms]<font></font>
  currSyms,::syms; <span class="hljs-comment">//    </span>
  <span class="hljs-comment">//    sym, time  rollColumns   .</span>
  <span class="hljs-comment">//  ^      roll ,     . value flip table     .</span><font></font>
  `tradeAgg upsert @[count[syms]#enlist initWith;`sym`time,cols rc;:;(syms;currTime), (initWith cols rc)^value flip rc:rollCache ([] sym: syms)];<font></font>
 }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、データを追加するためにクライアントによって呼び出されるupd関数（Qサービスのこの関数の従来の名前）：</font></font><br>
<br>
<pre><code class="cpp hljs">upd:{[tblName;data] <span class="hljs-comment">// tblName   ,       </span>
  tm:exec distinct time from data:() xkey preprocess data; <span class="hljs-comment">// preprocess &amp; calc time</span>
  updMinute[data] each tm; <span class="hljs-comment">//     </span><font></font>
};<font></font>
updMinute:{[data;tm]<font></font>
  <span class="hljs-keyword">if</span>[tm&lt;&gt;currTime; roll tm; currTime::tm]; <span class="hljs-comment">//  ,  </span>
  data:select from data where time=tm; <span class="hljs-comment">// </span>
  <span class="hljs-keyword">if</span>[count msyms:<span class="hljs-function">syms where <span class="hljs-title">not</span> <span class="hljs-params">(syms:data`sym)</span>in currSyms</span>; addSyms msyms]; <span class="hljs-comment">//  </span>
  updateAgg[`tradeAgg;offset+currSyms?syms;data]; <span class="hljs-comment">//   .  ?        .</span><font></font>
 };<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで全部です。</font><font style="vertical-align: inherit;">約束どおり、数行だけのサービスの完全なコードを次に示します。</font></font><br>
<br>
<pre><code class="cpp hljs">initWith:`sym`time`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover`avgPrice`avgSize`vwap`cumVolume!(`;<span class="hljs-number">00</span>:<span class="hljs-number">00</span>;<span class="hljs-number">0</span>n;<span class="hljs-number">0</span>n;<span class="hljs-number">0</span>n;<span class="hljs-number">0</span>n;<span class="hljs-number">0</span>N;<span class="hljs-number">0</span>N;<span class="hljs-number">0</span>;<span class="hljs-number">0</span>;<span class="hljs-number">0.0</span>;<span class="hljs-number">0.0</span>;<span class="hljs-number">0</span>n;<span class="hljs-number">0</span>n;<span class="hljs-number">0</span>n;<span class="hljs-number">0</span>);<font></font>
aggCols:reverse key[initWith] except `sym`time;<font></font>
rollColumns:`sym`cumVolume;<font></font>
<font></font>
accumulatorCols:`numTrades`volume`pvolume`turnover;<font></font>
specialCols:`high`low`firstPrice`firstSize;<font></font>
<font></font>
selExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover!<span class="hljs-function">parse <span class="hljs-title">each</span> <span class="hljs-params">(<span class="hljs-string">"max price"</span>;<span class="hljs-string">"min price"</span>;<span class="hljs-string">"first price"</span>;<span class="hljs-string">"last price"</span>;<span class="hljs-string">"first size"</span>;<span class="hljs-string">"last size"</span>;<span class="hljs-string">"count i"</span>;<span class="hljs-string">"sum size"</span>;<span class="hljs-string">"sum price"</span>;<span class="hljs-string">"sum price*size"</span>)</span></span>;<font></font>
preprocess:?[;();`sym`time!`sym`time.minute;selExpression];<font></font>
<font></font>
aggExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`avgPrice`avgSize`vwap`cumVolume!(<span class="hljs-string">"row[`high]|inp`high"</span>;<span class="hljs-string">"row[`low]&amp;inp`low"</span>;<span class="hljs-string">"row`firstPrice"</span>;<span class="hljs-string">"inp`lastPrice"</span>;<span class="hljs-string">"row`firstSize"</span>;<span class="hljs-string">"inp`lastSize"</span>;<span class="hljs-string">"pvolume%numTrades"</span>;<span class="hljs-string">"volume%numTrades"</span>;<span class="hljs-string">"turnover%volume"</span>;<span class="hljs-string">"row[`cumVolume]+inp`volume"</span>);<font></font>
@[`aggExpression;specialCols;{<span class="hljs-string">"?[isFirst;inp`"</span>,y,<span class="hljs-string">";"</span>,x,<span class="hljs-string">"]"</span>};<span class="hljs-built_in">string</span> specialCols];<font></font>
aggExpression[accumulatorCols]:{<span class="hljs-string">"row[`"</span>,x,<span class="hljs-string">"]+inp`"</span>,x } each <span class="hljs-built_in">string</span> accumulatorCols;<font></font>
updateAgg:value <span class="hljs-string">"{[aggTable;idx;inp] row:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols;("</span>,(<span class="hljs-string">";"</span>sv <span class="hljs-built_in">string</span>[aggCols],<span class="hljs-string">'":",/:aggExpression aggCols),")]}"; / '</span><font></font>
<font></font>
init:{<font></font>
  tradeAgg::<span class="hljs-number">0</span>#enlist[initWith];<font></font>
  currTime::<span class="hljs-number">00</span>:<span class="hljs-number">00</span>;<font></font>
  currSyms::`u#`symbol$();<font></font>
  offset::<span class="hljs-number">0</span>;<font></font>
  rollCache:: `sym xkey update `u#sym from rollColumns#tradeAgg;<font></font>
 };<font></font>
roll:{[tm]<font></font>
  <span class="hljs-keyword">if</span>[currTime&gt;tm; :init[]];<font></font>
  rollCache,::offset _ rollColumns#tradeAgg;<font></font>
  offset::count tradeAgg;<font></font>
  currSyms::`u#`$();<font></font>
 };<font></font>
addSyms:{[syms]<font></font>
  currSyms,::syms;<font></font>
  `tradeAgg upsert @[count[syms]#enlist initWith;`sym`time,cols rc;:;(syms;currTime),(initWith cols rc)^value flip rc:rollCache ([] sym: syms)];<font></font>
 };<font></font>
<font></font>
upd:{[tblName;data] updMinute[data] each exec distinct time from data:() xkey preprocess data};<font></font>
updMinute:{[data;tm]<font></font>
  <span class="hljs-keyword">if</span>[tm&lt;&gt;currTime; roll tm; currTime::tm];<font></font>
  data:select from data where time=tm;<font></font>
  <span class="hljs-keyword">if</span>[count msyms:syms where <span class="hljs-keyword">not</span> (syms:data`sym)in currSyms; addSyms msyms];<font></font>
  updateAgg[`tradeAgg;offset+currSyms?syms;data];<font></font>
 };<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト中</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービスのパフォーマンスを確認します。</font><font style="vertical-align: inherit;">これを行うには、別のプロセスで実行し（service.qファイルにコードを記述）、init関数を呼び出します。</font></font><br>
<br>
<pre><code class="plaintext hljs">q service.q –p 5566<font></font>
<font></font>
q)init[]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のコンソールで、2番目のQプロセスを開始し、最初のQプロセスに接続します。</font></font><br>
<br>
<pre><code class="cpp hljs">h:hopen `:host:<span class="hljs-number">5566</span>
h:hopen <span class="hljs-number">5566</span> <span class="hljs-comment">//     </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、キャラクターのリストを作成します-10,000個とランダムなテーブルを作成する関数を追加します。</font><font style="vertical-align: inherit;">2番目のコンソールで：</font></font><br>
<br>
<pre><code class="cpp hljs">syms:`IBM`AAPL`GOOG,<span class="hljs-number">-9997</span>?`<span class="hljs-number">8</span>
rnd:{[n;t] ([] sym:n?syms; time:t+asc n#til <span class="hljs-number">25</span>; price:n?<span class="hljs-number">10f</span>; size:n?<span class="hljs-number">10</span>)}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文字のリストに3つの実際の文字を追加して、テーブルでそれらを探すのをより便利にしました。</font><font style="vertical-align: inherit;">rnd関数は、n行のランダムなテーブルを作成します。時間はtからt + 25ミリ秒まで変化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、サービスにデータを送信することができます（最初の10時間を追加します）。</font></font><br>
<br>
<pre><code class="cpp hljs">{h (`upd;`trade;rnd[<span class="hljs-number">10000</span>;x])} each `time$<span class="hljs-number">00</span>:<span class="hljs-number">00</span> + til <span class="hljs-number">60</span>*<span class="hljs-number">10</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テーブルが更新されたことをサービスにチェックインできます。</font></font><br>
<br>
<pre><code class="cpp hljs">\c <span class="hljs-number">25</span> <span class="hljs-number">200</span><font></font>
select from tradeAgg where sym=`AAPL<font></font>
<span class="hljs-number">-20</span>#select from tradeAgg where sym=`AAPL
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果：</font></font><br>
<br>
<pre><code class="1c hljs">sym<span class="hljs-string">|time|high|low|firstPrice|lastPrice|firstSize|lastSize|numTrades|volume|pvolume|turnover|avgPrice|avgSize|vwap|cumVolume</span>
--<span class="hljs-string">|--|--|--|--|--------------------------------</span>
AAPL<span class="hljs-string">|09:27|9.258904|9.258904|9.258904|9.258904|8|8|1|8|9.258904|74.07123|9.258904|8|9.258904|2888</span>
AAPL<span class="hljs-string">|09:28|9.068162|9.068162|9.068162|9.068162|7|7|1|7|9.068162|63.47713|9.068162|7|9.068162|2895</span>
AAPL<span class="hljs-string">|09:31|4.680449|0.2011121|1.620827|0.2011121|1|5|4|14|9.569556|36.84342|2.392389|3.5|2.631673|2909</span>
AAPL<span class="hljs-string">|09:33|2.812535|2.812535|2.812535|2.812535|6|6|1|6|2.812535|16.87521|2.812535|6|2.812535|2915</span>
AAPL<span class="hljs-string">|09:34|5.099025|5.099025|5.099025|5.099025|4|4|1|4|5.099025|20.3961|5.099025|4|5.099025|2919</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、負荷テストを実行して、サービスが1分あたりに処理できるデータ量を調べます。</font><font style="vertical-align: inherit;">更新の間隔を25ミリ秒に設定したことを思い出してください。</font><font style="vertical-align: inherit;">したがって、ユーザーがデータを要求する時間を与えるには、サービスは（平均して）更新ごとに少なくとも20ミリ秒に収まる必要があります。</font><font style="vertical-align: inherit;">2番目のプロセスで次のように入力します。</font></font><br>
<br>
<pre><code class="cpp hljs">tm:<span class="hljs-number">10</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00.000</span>
stressTest:{[n] <span class="hljs-number">1</span> <span class="hljs-built_in">string</span>[tm],<span class="hljs-string">" "</span>; times,::h ({st:.z.T; upd[`trade;x]; .z.T-st};rnd[n;tm]); tm+:<span class="hljs-number">25</span>}<font></font>
start:{[n] times::(); <span class="hljs-keyword">do</span>[<span class="hljs-number">4800</span>;stressTest[n]]; <span class="hljs-number">-1</span> <span class="hljs-string">" "</span>; `min`avg`med`max!(min times;avg times;med times;max times)}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4800は2分です。</font><font style="vertical-align: inherit;">最初に、25ミリ秒ごとに1000行を開始してみることができます。</font></font><br>
<br>
<pre><code class="cpp hljs">start <span class="hljs-number">1000</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の場合、結果は更新ごとに約数ミリ秒です。</font><font style="vertical-align: inherit;">そのため、すぐに行数を10.000に増やします。</font></font><br>
<br>
<pre><code class="cpp hljs">start <span class="hljs-number">10000</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果：</font></font><br>
<br>
<pre><code class="cpp hljs">min| <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00.004</span>
avg| <span class="hljs-number">9.191458</span>
med| <span class="hljs-number">9f</span>
max| <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00.030</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しますが、特別なことは何もありませんが、これは1分あたり2400万行、1秒あたり40万行です。</font><font style="vertical-align: inherit;">25ミリ秒を超えると、更新が遅くなったのは5倍だけで、明らかに分を変更したときのようです。</font><font style="vertical-align: inherit;">100,000に増加：</font></font><br>
<br>
<pre><code class="cpp hljs">start <span class="hljs-number">100000</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果：</font></font><br>
<br>
<pre><code class="cpp hljs">min| <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00.013</span>
avg| <span class="hljs-number">25.11083</span>
med| <span class="hljs-number">24f</span>
max| <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00.108</span><font></font>
q)sum times<font></font>
<span class="hljs-number">00</span>:<span class="hljs-number">02</span>:<span class="hljs-number">00.532</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、サービスはほとんど対応していませんが、それでも何とかフロートのままです。このデータ量（1分間に2億4,000万行）は非常に大きく、そのような場合は、サービスの複数のクローン（または数十のクローン）を実行するのが通例であり、それぞれが文字の一部のみを処理します。それにもかかわらず、結果は、主にデータストレージに焦点を当てたインタプリタ言語にとって印象的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題が発生する可能性があります。なぜ、各更新のサイズに伴って時間が非線形に増加するのでしょうか。その理由は、絞り込み関数は実際にはupdateAggよりもはるかに効率的に機能するC関数だからです。一部の更新サイズ（約10.000）から開始すると、updateAggは上限に達し、実行時間は更新のサイズに依存しません。サービスがそのような量のデータを消化できるのは、予備ステップQによるものです。これは、ビッグデータを操作して正しいアルゴリズムを選択することがいかに重要であるかを強調しています。もう1つのポイントは、データをメモリに正しく格納することです。データが列に格納されていなかったり、時間順に並べられていなかったりすると、TLBキャッシュミス（プロセッサアドレスキャッシュにメモリページアドレスが存在しないなど）に慣れることになります。障害が発生した場合、アドレスの検索には約30倍の時間がかかります。データが散在している場合は、サービスの速度が数倍遅くなる可能性があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、KDB +とQのデータベースが、ビッグデータの保存や選択によるそれらへの簡単なアクセスだけでなく、1つのQプロセスで数億行/ギガバイトのデータを消化できるデータ処理サービスの作成にも適していることを示しました。</font><font style="vertical-align: inherit;">Q言語自体は、そのベクトルの性質、SQL方言の組み込みインタープリター、および非常に成功したライブラリー関数のセットにより、データ処理に関連するアルゴリズムを非常に短時間で効率的に実装できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記はQの機能の一部にすぎず、他のユニークな機能があることに注意します。</font><font style="vertical-align: inherit;">たとえば、非常にシンプルなIPCプロトコルは、個別のQプロセス間の境界を消去し、これらの数百のプロセスを1つのネットワークに結合し、世界のさまざまな場所にある数十のサーバーに配置できます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja470576/index.html">今後数年間でアメリカの銀行は200,000の仕事を取り除くでしょう</a></li>
<li><a href="../ja470578/index.html">モバイルバンクで簿記を「人間化」する方法</a></li>
<li><a href="../ja470584/index.html">Telerik UI for UWPをチェックして、PVS-Studioに慣れる</a></li>
<li><a href="../ja470592/index.html">Pleskレビュー-ホスティングおよびサイトコントロールパネル</a></li>
<li><a href="../ja470594/index.html">モスクワでの光のショー「光のサークル」2019からのレポート</a></li>
<li><a href="../ja470598/index.html">本「現代のJava。ラムダ式、ストリーム、関数型プログラミング」</a></li>
<li><a href="../ja470600/index.html">安全なnoVNCコンソール、Kubernetesでの自動スケーリング、OstrovkaでのHaproxy、およびプログラマーとの管理者の作業について</a></li>
<li><a href="../ja470602/index.html">三次元の世界でのモスクワのメトロの様子</a></li>
<li><a href="../ja470604/index.html">eコマースでのサイトの読み込み速度：ロシアの上位48のオンラインストアの分析</a></li>
<li><a href="../ja470608/index.html">Unity UIの最適化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>