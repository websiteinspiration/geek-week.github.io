<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏻 🙍 🤵 Struktur data abadi yang mutakhir 👩‍🎤 🐀 👩🏼‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama bertahun-tahun, para ahli di C ++ telah mendiskusikan semantik nilai-nilai, ketetapan, dan berbagi sumber daya melalui komunikasi. Tentang duni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Struktur data abadi yang mutakhir</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/487100/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selama bertahun-tahun, para ahli di C ++ telah mendiskusikan semantik nilai-nilai, ketetapan, dan berbagi sumber daya melalui komunikasi. </font><font style="vertical-align: inherit;">Tentang dunia baru tanpa mutex dan ras, tanpa pola Command dan Observer. </font><font style="vertical-align: inherit;">Padahal, semuanya tidak sesederhana itu. </font><font style="vertical-align: inherit;">Masalah utama masih dalam struktur data kami.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/pu/18/6opu18ei6gi5dbo8dvcsgopyebq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Struktur data yang tidak dapat berubah tidak mengubah nilainya. Untuk melakukan sesuatu dengannya, Anda perlu membuat nilai baru. Nilai-nilai lama tetap di tempat yang sama, sehingga mereka dapat dibaca dari aliran yang berbeda tanpa masalah dan kunci. Akibatnya, sumber daya dapat dibagikan secara lebih rasional dan teratur, karena nilai lama dan baru dapat menggunakan data umum. Berkat ini, mereka jauh lebih cepat untuk membandingkan satu sama lain dan dengan kompak menyimpan sejarah operasi dengan kemungkinan pembatalan. Semua ini sangat cocok pada sistem multi-threaded dan interaktif: struktur data seperti itu menyederhanakan arsitektur aplikasi desktop dan memungkinkan layanan untuk skala yang lebih baik. Struktur yang tidak dapat diubah adalah rahasia kesuksesan Clojure dan Scala, dan bahkan komunitas JavaScript sekarang mengambil keuntungan darinya, karena mereka memiliki perpustakaan Immutable.js,ditulis di perut perusahaan Facebook.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bawah potongan video dan terjemahan laporan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari konferensi C ++ Russia 2019 Moscow. </font><font style="vertical-align: inherit;">Juan berbicara tentang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , perpustakaan struktur yang tidak dapat diubah untuk C ++. </font><font style="vertical-align: inherit;">Di pos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keunggulan arsitektur kekebalan;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pembuatan tipe vektor persisten yang efektif berdasarkan pohon RRB;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analisis arsitektur pada contoh editor teks sederhana.</font></font></li>
</ul><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/dbFfpTp3EhA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tragedi arsitektur berbasis nilai</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memahami pentingnya struktur data yang tidak dapat diubah, kami membahas semantik nilai. Ini adalah fitur yang sangat penting dari C ++, saya menganggapnya sebagai salah satu keunggulan utama bahasa ini. Untuk semua ini, sangat sulit untuk menggunakan semantik nilai seperti yang kita inginkan. Saya percaya bahwa ini adalah tragedi arsitektur berbasis nilai, dan jalan menuju tragedi ini ditaburi dengan niat baik. Misalkan kita perlu menulis perangkat lunak interaktif berdasarkan model data dengan representasi dokumen yang dapat diedit pengguna. Ketika arsitektur yang berbasis pada nilai-nilai di jantung model ini menggunakan jenis sederhana dan nyaman dari nilai-nilai yang sudah ada di bahasa: </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>tuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Logika aplikasi dibuat dari fungsi yang mengambil dokumen berdasarkan nilai dan mengembalikan versi baru dokumen berdasarkan nilai. Dokumen ini dapat berubah di dalam fungsi (seperti yang terjadi di bawah), tetapi semantik nilai dalam C ++, diterapkan pada argumen dengan nilai dan tipe pengembalian dengan nilai, memastikan bahwa tidak ada efek samping. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/7e/0y/fh7e0ybdwuqnh3iona30quev4ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fitur ini sangat mudah untuk dianalisis dan diuji. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/5c/4x/cb5c4xq-hps1x76mn-fmweshklu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena kami bekerja dengan nilai-nilai, kami akan mencoba menerapkan pembatalan tindakan. Ini bisa sulit, tetapi dengan pendekatan kami itu adalah tugas yang sepele: kami memiliki </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berbagai negara dengan berbagai salinan dokumen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d-/vh/nd/d-vhndh9j8leugdcjoyf3b4yhqq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan kita juga memiliki UI, dan untuk memastikan responsifnya, pemetaan UI perlu dilakukan di utas terpisah. Dokumen dikirim ke aliran lain melalui pesan, dan interaksi juga terjadi berdasarkan pesan, dan bukan melalui pembagian penggunaan negara </font></font><code>mutexes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ketika salinan diterima oleh aliran kedua, di sana Anda dapat melakukan semua operasi yang diperlukan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/xx/kc/toxxkcwck44iayev1hywf-wqllk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menyimpan dokumen ke disk seringkali sangat lambat, terutama jika dokumen itu besar. Oleh karena itu, menggunakan </font></font><code>std::async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operasi ini dilakukan secara tidak sinkron. Kami menggunakan lambda, menaruh tanda sama di dalamnya untuk memiliki salinan, dan sekarang Anda dapat menyimpan tanpa jenis sinkronisasi primitif lainnya.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ey/jj/veeyjjijubbrc49-ghusxnuft4e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, anggaplah kita juga memiliki aliran kontrol suara. Seperti yang saya katakan, saya banyak bekerja dengan perangkat lunak musik, dan suara adalah representasi lain dari dokumen kami, harus dalam aliran yang terpisah. Oleh karena itu, salinan dokumen juga diperlukan untuk aliran ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasilnya, kami mendapat skema yang sangat indah, tetapi tidak terlalu realistis. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dj/w2/hu/djw2hu7q55lbi2nmgmwok1i_cb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selalu harus menyalin dokumen, riwayat tindakan untuk pembatalan membutuhkan gigabytes, dan untuk setiap rendering UI Anda perlu membuat salinan dokumen yang dalam. Secara umum, semua interaksi terlalu mahal.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uq/sv/8-/uqsv8-sx3hphtcm9wvozi1z83fs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang dilakukan pengembang C ++ dalam situasi ini? Alih-alih menerima dokumen berdasarkan nilai, logika aplikasi sekarang menerima tautan ke dokumen dan memutakhirkannya jika perlu. Dalam hal ini, Anda tidak perlu mengembalikan apa pun. Tetapi sekarang kita tidak berurusan dengan nilai, tetapi dengan objek dan lokasi. Ini menciptakan masalah baru: jika ada tautan ke negara bagian dengan akses bersama, Anda memerlukannya </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini sangat mahal, sehingga akan ada beberapa representasi UI kami dalam bentuk pohon yang sangat kompleks dari berbagai Widget.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua elemen ini harus menerima pembaruan ketika dokumen berubah, sehingga beberapa mekanisme antrian diperlukan untuk mengubah sinyal. Lebih jauh, sejarah dokumen tidak lagi merupakan set negara, melainkan akan menjadi implementasi dari pola Tim. Operasi harus dilaksanakan dua kali, dalam satu arah dan dalam yang lain, dan memastikan bahwa semuanya simetris. Menyimpan di utas terpisah sudah terlalu sulit, jadi ini harus ditinggalkan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dl/lr/sj/dllrsjhkvqxxckjx1r69lflqck4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengguna sudah terbiasa dengan gambar jam pasir, jadi tidak apa-apa jika mereka menunggu sebentar. Hal lain yang menakutkan - monster pasta sekarang mengatur kode kita.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada titik apa semuanya menjadi menurun? </font><font style="vertical-align: inherit;">Kami merancang kode kami dengan sangat baik, dan kemudian kami harus berkompromi karena menyalin. </font><font style="vertical-align: inherit;">Namun dalam C ++, penyalinan diperlukan untuk memberikan nilai hanya untuk data yang dapat diubah. </font><font style="vertical-align: inherit;">Jika objek tidak berubah, maka operator penugasan dapat diimplementasikan sehingga hanya menyalin pointer ke representasi internal dan tidak lebih.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan struktur data yang dapat membantu kami. </font><font style="vertical-align: inherit;">Dalam vektor di bawah ini, semua metode ditandai sebagai </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sehingga tidak dapat diubah. </font><font style="vertical-align: inherit;">Pada eksekusi </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vektor tidak memperbarui, sebaliknya, vektor baru dikembalikan, ke mana data yang ditransfer ditambahkan. </font><font style="vertical-align: inherit;">Sayangnya, kami tidak dapat menggunakan tanda kurung siku dengan pendekatan ini karena cara mereka didefinisikan. </font><font style="vertical-align: inherit;">Sebagai gantinya, Anda dapat menggunakan fungsi ini</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mengembalikan versi baru dengan item yang diperbarui. Struktur data kami sekarang memiliki properti yang disebut kegigihan dalam pemrograman fungsional. Itu berarti bukan bahwa kita menyimpan struktur data ini ke hard drive, tetapi fakta bahwa ketika diperbarui, konten lama tidak dihapus - sebagai gantinya, garpu baru dunia kita dibuat, yaitu struktur. Berkat ini, kita dapat membandingkan nilai masa lalu dengan sekarang - ini dilakukan dengan bantuan dua </font></font><code>assert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-keyword">const</span> auto v1 = v0.push_back(<span class="hljs-number">15</span>);
<span class="hljs-keyword">const</span> auto v2 = v1.push_back(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> auto v3 = v2.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">42</span>);<font></font>
<font></font>
assert(v2.size() == v0.size() + <span class="hljs-number">2</span>);<font></font>
assert(v3[<span class="hljs-number">0</span>] - v1[<span class="hljs-number">0</span>] == <span class="hljs-number">27</span>);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perubahan sekarang dapat langsung diperiksa, mereka tidak lagi sifat tersembunyi dari struktur data. Fitur ini sangat berharga dalam sistem interaktif di mana kami harus selalu mengubah data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Properti penting lainnya adalah pembagian struktural. Sekarang kami tidak menyalin semua data untuk setiap versi baru dari struktur data. Bahkan dengan </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak semua data disalin, tetapi hanya sebagian kecil saja. Semua garpu kami memiliki akses umum ke tampilan ringkas, yang proporsional dengan jumlah perubahan, bukan jumlah salinan. Ini juga mengikuti perbandingan yang sangat cepat: jika semuanya disimpan dalam satu blok memori, dalam satu pointer, maka Anda dapat dengan mudah membandingkan pointer dan tidak memeriksa elemen yang ada di dalamnya, jika mereka sama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejak vektor seperti itu, menurut saya, sangat berguna, Aku diimplementasikan di perpustakaan terpisah: ini adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - perpustakaan struktur berubah, sebuah proyek open source.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat menulisnya, saya ingin penggunaannya agar tidak asing bagi pengembang C ++. </font><font style="vertical-align: inherit;">Ada banyak perpustakaan yang menerapkan konsep pemrograman fungsional dalam C ++, tetapi memberi kesan bahwa pengembang menulis untuk Haskell, bukan untuk C ++. </font><font style="vertical-align: inherit;">Ini menciptakan ketidaknyamanan. </font><font style="vertical-align: inherit;">Selain itu, saya mencapai kinerja yang baik. </font><font style="vertical-align: inherit;">Orang-orang menggunakan C ++ ketika sumber daya yang tersedia terbatas. </font><font style="vertical-align: inherit;">Akhirnya, saya ingin perpustakaan disesuaikan. </font><font style="vertical-align: inherit;">Persyaratan ini terkait dengan persyaratan kinerja.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mencari vektor sihir</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada bagian kedua dari laporan ini, kami akan mempertimbangkan bagaimana vektor tidak berubah ini terstruktur. Cara termudah untuk memahami prinsip-prinsip struktur data seperti itu adalah dengan memulai dengan daftar reguler. Jika Anda sedikit terbiasa dengan pemrograman fungsional (menggunakan Lisp atau Haskell sebagai contoh), Anda tahu bahwa daftar adalah struktur data abadi yang paling umum. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ou/d6/rnoud6a8vaqpet2jg-n18be85fk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memulai, mari kita asumsikan bahwa kita memiliki daftar dengan satu simpul </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Saat menambahkan elemen baru ke bagian atas daftar, node baru dibuat, masing-masing memiliki pointer ke node yang sudah ada. Oleh karena itu, dalam contoh pada slide, kami tidak memiliki tiga salinan dari satu daftar, tetapi tiga elemen dalam memori, yaitu, </font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mereka </font></font><code>v0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunjukkan elemen yang berbeda. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/nf/bh/bmnfbhtdmbu_kdm_xlpuxleld2w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita juga dapat membuat garpu realitas, yaitu, membuat daftar baru yang memiliki akhir yang sama, tetapi awal yang berbeda.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Struktur data seperti itu telah dipelajari untuk waktu yang lama: Chris Okasaki menulis karya mendasar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur Data Murni Fungsional</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Selain itu, struktur data </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finger Tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang diajukan oleh Ralf Hinze dan Ross Paterson sangat menarik </font><font style="vertical-align: inherit;">. Tetapi untuk C ++, struktur data seperti itu tidak berfungsi dengan baik. Mereka menggunakan node kecil, dan kita tahu bahwa di C ++ node kecil berarti kurangnya efisiensi caching. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, mereka sering mengandalkan properti yang tidak dimiliki C ++, seperti kemalasan. Oleh karena itu, karya Phil Bagwell tentang struktur data yang tidak berubah jauh lebih bermanfaat bagi kita - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditulis pada awal 2000-an, serta karya Rich Hickey - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, penulis Clojure. Rich Hickey membuat daftar, yang sebenarnya bukan daftar, tetapi berdasarkan pada struktur data modern: vektor dan peta hash. Struktur data ini memiliki efisiensi caching dan berinteraksi dengan baik dengan prosesor modern, yang tidak diinginkan untuk bekerja dengan node kecil. Struktur seperti itu dapat digunakan dalam C ++. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana cara membangun vektor kekebalan? Di jantung struktur apa pun, bahkan yang menyerupai vektor, harus ada array. Tetapi array tidak memiliki pembagian struktural. Untuk mengubah elemen array apa pun, tanpa kehilangan properti persistensi, Anda harus menyalin seluruh array. Agar tidak melakukan ini, array dapat dibagi menjadi beberapa bagian terpisah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, ketika memperbarui elemen vektor, kita hanya perlu menyalin satu bagian, dan bukan seluruh vektor. Tetapi potongan-potongan itu sendiri bukanlah struktur data, mereka harus digabungkan dengan satu atau lain cara. Tempatkan mereka di array lain. Sekali lagi, muncul masalah bahwa array bisa sangat besar, dan kemudian menyalinnya lagi akan memakan waktu terlalu banyak.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami membagi array ini menjadi beberapa bagian, menempatkannya kembali dalam array yang terpisah, dan ulangi prosedur ini hingga hanya ada satu array root. Struktur yang dihasilkan disebut pohon sisa. Pohon ini dijelaskan oleh konstanta M = 2B, yaitu faktor percabangan. Indikator cabang ini harusnya kekuatan dua, dan kami akan segera mencari tahu mengapa. Dalam contoh pada slide, blok empat karakter digunakan, tetapi dalam praktiknya, blok 32 karakter digunakan. Ada eksperimen yang dengannya Anda dapat menemukan ukuran blok optimal untuk arsitektur tertentu. Ini memungkinkan Anda untuk mencapai rasio terbaik dari akses struktural bersama terhadap waktu akses: semakin rendah pohon, semakin sedikit waktu akses.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Membaca ini, pengembang menulis dalam C ++ mungkin berpikir: tetapi struktur berbasis pohon sangat lambat! Pohon tumbuh dengan peningkatan jumlah elemen di dalamnya, dan karena ini, waktu akses terdegradasi. Itu sebabnya programmer lebih suka </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, daripada </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Saya segera meyakinkan Anda: pohon kami tumbuh sangat lambat. Vektor yang berisi semua nilai yang mungkin dari int 32-bit hanya memiliki 7 level. Dapat ditunjukkan secara eksperimental bahwa dengan ukuran data ini, rasio cache ke volume beban secara signifikan mempengaruhi kinerja daripada kedalaman pohon. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat bagaimana akses ke elemen pohon dilakukan. Misalkan Anda perlu beralih ke elemen 17. Kami mengambil representasi biner dari indeks dan membaginya menjadi kelompok-kelompok ukuran faktor percabangan.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c1/gz/o1/c1gzo1qqm9pycpehqerzzkvwvwm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di setiap grup, kami menggunakan nilai biner yang sesuai dan dengan demikian turun pohon. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, misalkan kita perlu membuat perubahan dalam struktur data ini, yaitu, jalankan metode </font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/l8/xi/3y/l8xi3yorosfghnwt9gmcijtk83a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk melakukan ini, pertama-tama Anda perlu menyalin blok di mana elemen itu berada, dan kemudian salin setiap node internal dalam perjalanan ke elemen. Di satu sisi, cukup banyak data yang harus disalin, tetapi pada saat yang sama sebagian besar dari data ini adalah umum, ini mengkompensasi volume mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Omong-omong, ada struktur data yang jauh lebih tua yang sangat mirip dengan yang saya jelaskan. Ini adalah halaman memori dengan bagan tabel halaman. Manajemennya juga dilakukan menggunakan panggilan </font></font><code>fork</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita coba memperbaiki struktur data kita. Misalkan kita perlu menghubungkan dua vektor. Struktur data yang dijelaskan sejauh ini memiliki keterbatasan yang sama </font></font><code>std::vector:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">karena memiliki sel kosong di bagian paling kanannya. Karena strukturnya seimbang sempurna, sel-sel kosong ini tidak mungkin berada di tengah pohon. Oleh karena itu, jika ada vektor kedua yang ingin kita gabungkan dengan yang pertama, kita perlu menyalin elemen ke dalam sel kosong, yang akan membuat sel kosong di vektor kedua, dan pada akhirnya kita harus menyalin seluruh vektor kedua. Operasi semacam itu memiliki kompleksitas komputasi O (n), di mana n adalah ukuran vektor kedua.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan berusaha mencapai hasil yang lebih baik. Ada versi modifikasi dari struktur data kami yang disebut pohon santai radix seimbang. Dalam struktur ini, node yang tidak di jalur paling kiri mungkin memiliki sel kosong. Oleh karena itu, dalam simpul yang tidak lengkap (atau santai), perlu untuk menghitung ukuran subtree. Sekarang Anda dapat melakukan operasi gabungan yang kompleks tetapi logaritmik. Operasi dengan kompleksitas waktu konstan ini adalah O (log (32)). Karena pohonnya dangkal, waktu aksesnya konstan, walaupun relatif lama. Karena kami memiliki operasi penyatuan, versi yang santai dari struktur data ini disebut confluent: selain persisten, dan Anda dapat menggunakannya, dua struktur tersebut dapat digabungkan menjadi satu.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qr/rj/hz/qrrjhzfbr-22n0cdr-vvhke1pvq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh yang telah kami kerjakan sejauh ini, struktur data sangat rapi, tetapi dalam praktiknya, implementasi di Clojure dan bahasa fungsional lainnya terlihat berbeda. Mereka membuat wadah untuk setiap nilai, yaitu, setiap elemen dalam vektor berada di sel yang terpisah, dan simpul daun berisi pointer ke elemen-elemen ini. Tetapi pendekatan ini sangat tidak efisien, dalam C ++ biasanya tidak memasukkan setiap nilai dalam sebuah wadah. Oleh karena itu, akan lebih baik jika elemen-elemen ini berada di node secara langsung. Kemudian masalah lain muncul: elemen yang berbeda memiliki ukuran yang berbeda. Jika elemen berukuran sama dengan pointer, struktur kami akan terlihat seperti yang ditunjukkan di bawah ini:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/78/s4/_k/78s4_kqqdc_fi8_ydkopktou0m4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi jika elemen-elemennya besar, maka struktur data kehilangan properti yang kami ukur (waktu akses O (log (32) ()), karena menyalin satu lembar sekarang membutuhkan waktu lebih lama. Oleh karena itu, saya mengubah struktur data ini sehingga dengan bertambahnya ukuran jumlah elemen yang terkandung di dalamnya mengurangi jumlah elemen-elemen ini dalam simpul daun. Sebaliknya, jika elemen-elemen kecil, mereka sekarang dapat lebih cocok. Versi baru dari pohon ini disebut menanamkan pohon radix seimbang. Ini digambarkan bukan oleh satu konstanta, tetapi oleh dua: salah satunya menggambarkan node internal, dan daun kedua .. Implementasi pohon di C ++ dapat menghitung ukuran optimal elemen daun tergantung pada ukuran pointer dan elemen itu sendiri.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pohon kami sudah bekerja dengan cukup baik, tetapi masih bisa diperbaiki. Lihatlah fungsi yang mirip dengan fungsi </font></font><code>iota</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = v.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dibutuhkan input </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dijalankan </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada akhir vektor untuk setiap integer antara </font></font><code>first</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>last</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan mengembalikan apa yang terjadi. Semuanya sesuai dengan kebenaran fungsi ini, tetapi berfungsi secara tidak efisien. Setiap panggilan </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyalin blok paling kiri yang tidak perlu: panggilan berikutnya mendorong elemen lain dan salinan diulang lagi, dan data yang disalin oleh metode sebelumnya dihapus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat mencoba implementasi lain dari fungsi ini, di mana kami meninggalkan kegigihan dalam fungsi tersebut. Dapat digunakan </font></font><code>transient vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan API yang bisa berubah yang kompatibel dengan API reguler </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dalam fungsi seperti itu, setiap panggilan </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengubah struktur data.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    auto t = v.transient();<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        t.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> t.persistent();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementasi ini lebih efisien, dan memungkinkan Anda untuk menggunakan kembali elemen baru di jalur yang benar. Di akhir fungsi, panggilan </font></font><code>.persistent()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dibuat yang mengembalikan kekal </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kemungkinan efek samping tetap tidak terlihat dari luar fungsi. Yang asli </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah dan tetap tidak berubah, hanya data yang dibuat di dalam fungsi yang diubah. Seperti yang saya katakan, keuntungan penting dari pendekatan ini adalah Anda dapat menggunakan </font></font><code>std::back_inserter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma standar yang membutuhkan API yang bisa diubah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan contoh lain.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        <font></font>
            .push_back(<span class="hljs-string">'i'</span>)        <font></font>
            .push_back(<span class="hljs-string">'!'</span>);       <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi tidak menerima dan kembali </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi rantai panggilan dijalankan di dalam </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Di sini, seperti dalam contoh sebelumnya, penyalinan yang tidak perlu di dalam panggilan dapat terjadi </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Perhatikan bahwa nilai pertama yang dieksekusi </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah nilai yang dinamai, dan sisanya adalah nilai-r, yaitu tautan anonim. Jika Anda menggunakan penghitungan referensi, metode ini </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat merujuk ke penghitung referensi untuk node yang memori dialokasikan di pohon. Dan dalam hal nilai-r, jika jumlah tautannya satu, menjadi jelas bahwa tidak ada bagian lain dari program yang mengakses node-node ini. Di sini kinerjanya persis sama seperti pada kasus dengan </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        ⟵ named <span class="hljs-keyword">value</span>: v<font></font>
            .push_back(<span class="hljs-string">'i'</span>)        ⟵ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span>
            .push_back(<span class="hljs-string">'!'</span>);       ⟵ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, untuk membantu kompiler, kita dapat mengeksekusinya </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak digunakan di tempat lain dalam fungsi. Kami memiliki keuntungan penting, yang tidak ada dalam </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">varian: jika kami meneruskan nilai yang dikembalikan dari say_hi lain ke fungsi say_hi, maka tidak akan ada salinan tambahan. Dalam kasus c, </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada batas di mana penyalinan berlebih dapat terjadi. Dengan kata lain, kami memiliki struktur data yang persisten dan tidak dapat diubah, yang kinerjanya tergantung pada jumlah aktual dari akses bersama dalam runtime. Jika tidak ada pembagian, maka kinerjanya akan sama dengan struktur data yang bisa berubah. Ini adalah properti yang sangat penting. Contoh yang sudah saya tunjukkan di atas dapat ditulis ulang dengan metode </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = std::move(v).push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejauh ini kita telah berbicara tentang vektor, dan selain itu ada juga peta hash. Mereka didedikasikan untuk laporan yang sangat berguna oleh Phil Nash: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cawan Suci. Sebuah array hash dipetakan untuk C ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini menggambarkan tabel hash diimplementasikan berdasarkan prinsip yang sama yang baru saja saya bicarakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya yakin banyak dari Anda memiliki keraguan tentang kinerja struktur seperti itu. Apakah mereka bekerja cepat dalam latihan? Saya telah melakukan banyak tes, dan singkatnya jawaban saya adalah ya. Jika Anda ingin mempelajari lebih lanjut tentang hasil tes, mereka diterbitkan dalam artikel saya untuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konferensi Internasional Pemrograman Fungsional 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sekarang, saya pikir, lebih baik untuk membahas bukan nilai absolut, tetapi efek struktur data ini terhadap sistem secara keseluruhan. </font><font style="vertical-align: inherit;">Tentu saja, memperbarui vektor kami lebih lambat karena Anda perlu menyalin beberapa blok data dan mengalokasikan memori untuk data lain. </font><font style="vertical-align: inherit;">Tetapi melewati vektor kita dilakukan pada kecepatan yang hampir sama dengan yang normal. </font><font style="vertical-align: inherit;">Sangat penting bagi saya untuk mencapai ini, karena membaca data dilakukan jauh lebih sering daripada mengubahnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, karena pembaruan yang lebih lambat, tidak perlu menyalin apa pun, hanya struktur data yang disalin. </font><font style="vertical-align: inherit;">Oleh karena itu, waktu yang dihabiskan untuk memperbarui vektor, seolah-olah, diamortisasi untuk semua salinan yang dilakukan dalam sistem. </font><font style="vertical-align: inherit;">Oleh karena itu, jika Anda menerapkan struktur data ini dalam arsitektur yang mirip dengan yang saya jelaskan di awal laporan, kinerja akan meningkat secara signifikan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ewig</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak akan berdasar dan menunjukkan struktur data saya menggunakan contoh. </font><font style="vertical-align: inherit;">Saya menulis editor teks kecil. </font><font style="vertical-align: inherit;">Ini adalah alat interaktif yang disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana dokumen diwakili oleh vektor yang tidak berubah. </font><font style="vertical-align: inherit;">Saya memiliki salinan seluruh Esperanto Wikipedia pada disk saya, beratnya 1 gigabyte (awalnya saya ingin mengunduh versi bahasa Inggris, tetapi terlalu besar). </font><font style="vertical-align: inherit;">Apapun editor teks yang Anda gunakan, saya yakin dia tidak akan menyukai file ini. </font><font style="vertical-align: inherit;">Dan ketika Anda mengunduh file ini di </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Anda dapat segera mengeditnya, karena </font><i><font style="vertical-align: inherit;">unduhannya</font></i><font style="vertical-align: inherit;"> tidak sinkron. </font><font style="vertical-align: inherit;">Navigasi file berfungsi, tidak ada yang hang, tidak </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tidak ada sinkronisasi. </font><font style="vertical-align: inherit;">Seperti yang Anda lihat, file yang diunduh membutuhkan 20 juta baris kode.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum mempertimbangkan properti paling penting dari alat ini, mari kita perhatikan detail lucu. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eb/kt/eq/ebkteqmtvnbkncoxlb91z0g6qpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di awal baris, disorot dalam warna putih di bagian bawah gambar, Anda melihat dua tanda hubung. UI ini kemungkinan besar akrab bagi pengguna emacs; tanda hubung di sana berarti bahwa dokumen tersebut belum dimodifikasi dengan cara apa pun. Jika Anda melakukan perubahan, maka tanda bintang ditampilkan sebagai ganti tanda hubung. Tapi, tidak seperti editor lain, jika Anda </font><font style="vertical-align: inherit;">menghapus perubahan ini </font><font style="vertical-align: inherit;">di </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (jangan urungkan, hapus saja), maka tanda hubung akan ditampilkan sebagai ganti tanda bintang karena </font><font style="vertical-align: inherit;">semua versi teks sebelumnya disimpan </font><font style="vertical-align: inherit;">dalam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Berkat ini, bendera khusus tidak diperlukan untuk menunjukkan apakah dokumen telah diubah: keberadaan perubahan ditentukan oleh perbandingan dengan dokumen asli.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan properti lain yang menarik dari alat ini: salin seluruh teks dan tempelkan beberapa kali di tengah teks yang ada. </font><font style="vertical-align: inherit;">Seperti yang Anda lihat, ini terjadi secara instan. </font><font style="vertical-align: inherit;">Bergabung dengan vektor di sini adalah operasi logaritmik, dan logaritma jutaan orang bukanlah operasi yang panjang. </font><font style="vertical-align: inherit;">Jika Anda mencoba menyimpan dokumen besar ini ke hard drive Anda, itu akan memakan waktu lebih lama, karena teks tidak lagi disajikan sebagai vektor yang diperoleh dari versi sebelumnya dari vektor ini. </font><font style="vertical-align: inherit;">Saat menyimpan ke disk, serialisasi terjadi, sehingga kegigihan hilang.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kembali ke arsitektur berbasis nilai</font></font></h2><br>
<img src="https://habrastorage.org/webt/wf/o7/b7/wfo7b78ha0wnqjzcjjeky_esh0g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mulai dengan bagaimana Anda tidak dapat kembali ke arsitektur ini: menggunakan Pengontrol, Model, dan Tampilan gaya Java yang biasa, yang paling sering digunakan untuk aplikasi interaktif di C ++. Tidak ada yang salah dengan mereka, tetapi mereka tidak cocok untuk masalah kita. Di satu sisi, pola Model-View-Controller memungkinkan untuk pemisahan tugas, tetapi di sisi lain, masing-masing elemen ini adalah objek, baik dari sudut pandang berorientasi objek dan dari sudut pandang C ++, yaitu, ini adalah area memori dengan bisa berubah kondisi. Lihat yang tahu tentang Model; yang jauh lebih buruk - Model secara tidak langsung tahu tentang View, karena hampir pasti ada panggilan balik yang melaluinya View diberitahu ketika Model berubah. Bahkan dengan penerapan prinsip-prinsip berorientasi objek terbaik, kami mendapatkan banyak ketergantungan timbal balik.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/07/so/xq/07soxqkandixucwhzk6mvfr1e84.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seiring bertambahnya aplikasi dan Model, Pengendali, dan Tampilan baru ditambahkan, muncul situasi ketika, untuk mengubah segmen program, Anda perlu mengetahui tentang semua bagian yang terkait dengannya, tentang semua Tampilan yang menerima peringatan melalui </font></font><code>callback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dll. Akibatnya, semua orang monster pasta yang akrab mulai mengintip melalui dependensi ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apakah arsitektur lain mungkin? Ada pendekatan alternatif untuk pola Model-View-Controller yang disebut "Arsitektur Aliran Data Unidirectional". Konsep ini tidak ditemukan oleh saya, cukup sering digunakan dalam pengembangan web. Di Facebook, ini disebut arsitektur Flux, tetapi di C ++, ini belum diterapkan.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/z6/p2/tyz6p2hutpnjwusi0edhbcwvo0s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elemen arsitektur seperti itu sudah akrab bagi kita: Aksi, Model dan Tampilan, tetapi arti dari blok dan panah berbeda. Blok adalah nilai, bukan objek dan bukan wilayah dengan status yang bisa berubah. Ini berlaku bahkan untuk Tampilan. Lebih jauh, panah bukanlah tautan, karena tanpa objek tidak ada tautan. Di sini panah adalah fungsi. Antara Aksi dan Model, ada fungsi pembaruan yang menerima Model saat ini, yaitu, kondisi dunia saat ini, dan Aksi, yang merupakan representasi dari suatu peristiwa, misalnya, klik mouse, atau peristiwa tingkat abstraksi lain, misalnya, penyisipan elemen atau simbol ke dalam dokumen. Fungsi pembaruan memperbarui dokumen dan mengembalikan negara baru di dunia. Model terhubung ke render fungsi tampilan, yang mengambil Model dan mengembalikan tampilan. Ini membutuhkan kerangka kerja di mana Tampilan dapat direpresentasikan sebagai nilai.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam pengembangan web, React melakukan ini, tetapi dalam C ++ belum ada yang seperti itu, walaupun siapa tahu, jika ada orang yang ingin membayar saya untuk menulis sesuatu seperti ini, mungkin akan segera muncul. Sementara itu, Anda dapat menggunakan API mode Langsung, di mana fungsi draw memungkinkan Anda untuk membuat nilai sebagai efek samping. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akhirnya, Tampilan harus memiliki mekanisme yang memungkinkan pengguna atau sumber acara lainnya untuk mengirim Tindakan. Ada cara mudah untuk menerapkan ini, disajikan di bawah ini:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">application <span class="hljs-title">update</span>(<span class="hljs-params">application state, action ev</span>)</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fname</span>)</span><font></font>
{<font></font>
    auto term  = terminal{};<font></font>
    auto state = application{load_buffer(fname), key_map_emacs};<font></font>
    <span class="hljs-keyword">while</span> (!state.done) {<font></font>
        draw(state);<font></font>
        auto act = term.next();<font></font>
        state = update(state, act);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan pengecualian menyimpan dan memuat secara tidak sinkron, ini adalah kode yang digunakan dalam editor yang baru saja disajikan. Ada objek di sini </font></font><code>terminal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang memungkinkan Anda membaca dan menulis dari baris perintah. Selanjutnya, </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini adalah nilai Model, ini menyimpan seluruh keadaan aplikasi. Seperti yang dapat Anda lihat di bagian atas layar, ada fungsi yang mengembalikan versi baru </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Siklus di dalam fungsi dijalankan hingga aplikasi harus ditutup, yaitu sampai </font></font><code>!state.done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dalam loop, negara baru ditarik, maka acara berikutnya diminta. Akhirnya, status disimpan dalam variabel lokal </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan loop dimulai lagi. Kode ini memiliki keunggulan yang sangat penting: hanya ada satu variabel yang dapat berubah yang ada di seluruh eksekusi program, ini adalah objek </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengembang Clojure menyebut arsitektur atom-tunggal ini: ada satu titik tunggal di seluruh aplikasi yang melaluinya semua perubahan dilakukan. </font><font style="vertical-align: inherit;">Logika aplikasi tidak berpartisipasi dalam memperbarui titik ini dengan cara apa pun, ini membuat siklus yang dirancang khusus untuk ini. </font><font style="vertical-align: inherit;">Berkat ini, logika aplikasi seluruhnya terdiri dari fungsi murni, seperti fungsi </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan pendekatan ini untuk menulis aplikasi, cara berpikir tentang perangkat lunak berubah. </font><font style="vertical-align: inherit;">Pekerjaan sekarang dimulai bukan dengan diagram antarmuka dan operasi UML, tetapi dengan data itu sendiri. </font><font style="vertical-align: inherit;">Ada beberapa kesamaan dengan desain berorientasi data. </font><font style="vertical-align: inherit;">Benar, desain berorientasi data biasanya digunakan untuk mendapatkan kinerja maksimal, di sini, selain kecepatan, kami berusaha untuk kesederhanaan dan kebenaran. </font><font style="vertical-align: inherit;">Penekanannya sedikit berbeda, tetapi ada kesamaan penting dalam metodologi.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> index = <span class="hljs-keyword">int</span>;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> coord<font></font>
{<font></font>
    index row = {};<font></font>
    index col = {};<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">using</span> line = immer::flex_vector&lt;<span class="hljs-keyword">char</span>&gt;;
<span class="hljs-keyword">using</span> text = immer::flex_vector&lt;line&gt;;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> file<font></font>
{<font></font>
    immer::box&lt;std::<span class="hljs-keyword">string</span>&gt; name;<font></font>
    text content;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> snapshot<font></font>
{<font></font>
    text content;<font></font>
    coord cursor;<font></font>
};<font></font>
 <font></font>
<span class="hljs-keyword">struct</span> buffer<font></font>
{<font></font>
    file <span class="hljs-keyword">from</span>;<font></font>
    text content;<font></font>
    coord cursor;<font></font>
    coord scroll;<font></font>
    std::optional&lt;coord&gt; selection_start;<font></font>
    immer::vector&lt;snapshot&gt; history;<font></font>
    std::optional&lt;std::size_t&gt; history_pos;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> application<font></font>
{<font></font>
    buffer current;<font></font>
    key_map keys;<font></font>
    key_seq input;<font></font>
    immer::vector&lt;text&gt; clipboard;<font></font>
    immer::vector&lt;message&gt; messages;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> action { key_code key; coord size; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di atas adalah tipe data utama dari aplikasi kita. Tubuh utama dari aplikasi terdiri dari </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yaitu flex_vector, dan flex_vector adalah </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salah satu yang Anda dapat melakukan operasi gabungan. Berikutnya </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah vektor di mana ia disimpan </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Seperti yang Anda lihat, ini adalah representasi teks yang sangat sederhana. </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disimpan dengan bantuan </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang memiliki nama, yaitu alamat dalam sistem file, dan sebenarnya </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Seperti </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang digunakan jenis lain, sederhana tapi sangat berguna: </font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini adalah wadah elemen tunggal. Ini memungkinkan Anda untuk memasukkan tumpukan dan memindahkan objek, menyalin yang mungkin terlalu banyak sumber daya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jenis penting lain: </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Berdasarkan jenis ini, fungsi batal aktif. Ini berisi dokumen (dalam bentuk</font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dan posisi kursor (coord). Ini memungkinkan Anda untuk mengembalikan kursor ke posisi di mana ia selama mengedit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jenis selanjutnya adalah </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini adalah istilah dari vim dan emacs, karena dokumen terbuka disebut di sana. Di </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sana ada file dari mana teks diunduh, serta konten teks - ini memungkinkan Anda untuk memeriksa perubahan dalam dokumen. Untuk menyorot bagian dari teks, ada variabel opsional yang </font></font><code>selection_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunjukkan awal pemilihan. Vektor dari </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah kisah teks. Perhatikan bahwa kami tidak menggunakan pola Tim, sejarah hanya terdiri dari negara. Akhirnya, jika pembatalan baru saja selesai, kita perlu indeks posisi dalam sejarah negara </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jenis berikutnya: </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini berisi dokumen terbuka (buffer), </font></font><code>key_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan</font></font><code>key_seq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk pintasan keyboard, serta vektor dari </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk clipboard dan vektor lain untuk pesan yang ditampilkan di bagian bawah layar. </font><font style="vertical-align: inherit;">Sejauh ini, dalam versi debut aplikasi hanya akan ada satu utas dan satu jenis tindakan yang membutuhkan input </font></font><code>key_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>coord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemungkinan besar, banyak dari Anda sudah memikirkan cara mengimplementasikan operasi ini. </font><font style="vertical-align: inherit;">Jika diambil berdasarkan nilai dan dikembalikan dengan nilai, maka dalam kebanyakan kasus operasi cukup sederhana. </font><font style="vertical-align: inherit;">Kode editor teks saya diposting di </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sehingga Anda dapat melihat tampilannya sebenarnya. </font><font style="vertical-align: inherit;">Sekarang saya akan membahas secara terperinci hanya pada kode yang mengimplementasikan fungsi pembatalan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membatalkan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menulis pembatalan dengan benar tanpa infrastruktur yang sesuai tidaklah mudah. Dalam editor saya, saya menerapkannya di sepanjang garis emacs, jadi pertama-tama beberapa kata tentang prinsip-prinsip dasarnya. Perintah pengembalian tidak ada di sini, dan berkat ini, Anda tidak dapat kehilangan pekerjaan Anda. Jika diperlukan pengembalian, perubahan apa pun dilakukan pada teks, dan kemudian semua tindakan pembatalan menjadi bagian lagi dari riwayat pembatalan.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/4z/j_/s04zj_sia6mzw8reywkbznlhlem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prinsip ini digambarkan di atas. Belah ketupat merah di sini menunjukkan posisi dalam sejarah: jika pembatalan belum selesai, belah ketupat merah selalu di akhir. Jika Anda membatalkan, berlian akan memindahkan satu negara kembali, tetapi pada saat yang sama, negara lain akan ditambahkan ke akhir antrian - sama seperti yang dilihat pengguna saat ini (S3). Jika Anda membatalkan lagi dan kembali ke S2, negara S2 ditambahkan ke akhir antrian. Jika sekarang pengguna membuat semacam perubahan, itu akan ditambahkan ke akhir antrian sebagai negara baru S5, dan belah ketupat akan dipindahkan ke sana. Sekarang, ketika membatalkan tindakan sebelumnya, tindakan membatalkan sebelumnya akan digulirkan terlebih dahulu. Untuk menerapkan sistem pembatalan seperti itu, kode berikut cukup:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">buffer <span class="hljs-title">record</span>(<span class="hljs-params">buffer before, buffer after</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (before.content != after.content) {<font></font>
        after.history = after.history.push_back({before.content, before.cursor});<font></font>
        <span class="hljs-keyword">if</span> (before.history_pos == after.history_pos)<font></font>
            after.history_pos = std::nullopt;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> after;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">buffer <span class="hljs-title">undo</span>(<span class="hljs-params">buffer buf</span>)</span><font></font>
{<font></font>
    auto idx = buf.history_pos.value_or(buf.history.size());<font></font>
    <span class="hljs-keyword">if</span> (idx &gt; <span class="hljs-number">0</span>) {<font></font>
        auto restore = buf.history[--idx];<font></font>
        buf.content = restore.content;<font></font>
        buf.cursor = restore.cursor;<font></font>
        buf.history_pos = idx;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> buf;<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada dua tindakan, </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dilakukan selama operasi apa pun. Ini sangat nyaman karena kita tidak perlu tahu apakah ada pengeditan dokumen yang terjadi. Fungsi transparan untuk logika aplikasi. Setelah tindakan apa pun, fungsi memeriksa apakah dokumen telah berubah. Jika terjadi perubahan, </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konten dan posisi kursor untuk </font><font style="vertical-align: inherit;">dieksekusi </font></font><code>history</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika tindakan tidak mengarah ke perubahan </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(yaitu, input yang diterima </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bukan disebabkan oleh tindakan pembatalan), maka </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai diberikan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika perlu </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kami periksa </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika tidak ada artinya, kami menganggapnya </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di akhir cerita. Jika riwayat pembatalan tidak kosong (mis.</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak di awal cerita), pembatalan dilakukan. </font><font style="vertical-align: inherit;">Konten dan kursor saat ini diganti dan diubah </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Irrevocability dari operasi undo dicapai oleh fungsi </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang juga disebut selama operasi undo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kami memiliki operasi </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang memakan 10 baris kode, dan yang tanpa perubahan (atau dengan perubahan minimal) dapat digunakan di hampir semua aplikasi lain.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perjalanan waktu</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentang perjalanan waktu. Seperti yang akan kita lihat sekarang, ini adalah topik yang terkait dengan pembatalan. Saya akan menunjukkan karya kerangka kerja yang akan menambah fungsionalitas yang berguna untuk aplikasi apa pun dengan arsitektur yang sama. Kerangka kerja di sini disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig-debug</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Versi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig ini</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mencakup beberapa fitur debugging. Sekarang dari browser Anda dapat membuka debugger, di mana Anda dapat memeriksa status aplikasi.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dy/ba/7x/dyba7xjocwgjjmqvayinlfwx0y4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami melihat bahwa tindakan terakhir diubah ukurannya, karena saya membuka jendela baru, dan manajer jendela saya secara otomatis mengubah ukuran jendela yang sudah terbuka. Tentu saja, untuk serialisasi otomatis di JSON, saya harus menambahkan anotasi untuk struct dari perpustakaan refleksi khusus. Tetapi sisa dari sistem ini cukup universal, dapat dihubungkan ke aplikasi serupa. Sekarang di browser Anda dapat melihat semua tindakan selesai. Tentu saja, ada kondisi awal yang tidak memiliki tindakan. Ini adalah keadaan sebelum pengunduhan. Selain itu, dengan mengklik dua kali saya dapat mengembalikan aplikasi ke keadaan sebelumnya. Ini adalah alat debugging yang sangat berguna yang memungkinkan Anda untuk melacak terjadinya kegagalan fungsi dalam aplikasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda tertarik, Anda dapat mendengarkan laporan saya tentang CPPCON 19, Nilai-nilai paling berharga, di sana saya akan memeriksa debugger ini secara detail. </font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/_oBx_NbLghY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, arsitektur berbasis nilai dibahas lebih rinci di sana. </font><font style="vertical-align: inherit;">Di dalamnya, saya juga memberi tahu Anda cara menerapkan tindakan dan mengaturnya secara hierarkis. </font><font style="vertical-align: inherit;">Ini memastikan modularitas sistem dan memungkinkan Anda untuk tidak menyimpan semuanya dalam satu fungsi pembaruan besar. </font><font style="vertical-align: inherit;">Selain itu, laporan itu berbicara tentang unduhan file asinkron dan multi-utas. </font><font style="vertical-align: inherit;">Ada versi lain dari laporan ini di mana setengah jam dari materi tambahan adalah struktur data yang tidak dapat diubah Postmodern.</font></font><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/y_m0ce1rzRI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk meringkas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya pikir sudah waktunya untuk mengambil stok. Saya akan mengutip Andy Wingo - dia adalah pengembang yang sangat baik, dia mencurahkan banyak waktu untuk V8 dan kompiler pada umumnya, akhirnya, dia terlibat dalam mendukung Guile, mengimplementasikan Skema untuk GNU. Baru-baru ini, ia menulis di Twitter-nya: “Untuk mencapai sedikit percepatan program, kami mengukur setiap perubahan kecil dan hanya menyisakan yang memberikan hasil positif. Tetapi kami benar-benar mencapai percepatan yang signifikan, secara membabi buta, menginvestasikan banyak usaha, tidak memiliki kepercayaan diri 100% dan hanya dibimbing oleh intuisi. Sungguh dikotomi yang aneh. ”</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sepertinya saya bahwa pengembang C ++ berhasil dalam genre pertama. </font><font style="vertical-align: inherit;">Beri kami sistem tertutup, dan kami, dengan dipersenjatai dengan alat kami, akan memeras segala yang mungkin darinya. </font><font style="vertical-align: inherit;">Namun dalam genre kedua kita tidak terbiasa bekerja. </font><font style="vertical-align: inherit;">Tentu saja, pendekatan kedua lebih berisiko, dan seringkali itu mengarah pada usaha yang sia-sia. </font><font style="vertical-align: inherit;">Di sisi lain, dengan sepenuhnya menulis ulang suatu program, seringkali dapat dibuat lebih mudah dan lebih cepat. </font><font style="vertical-align: inherit;">Saya harap saya berhasil meyakinkan Anda untuk setidaknya mencoba pendekatan kedua ini.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente berbicara di konferensi C ++ Russia 2019 Moscow dan berbicara tentang struktur data yang memungkinkan Anda melakukan hal-hal menarik. </font><font style="vertical-align: inherit;">Bagian dari keajaiban struktur ini terletak pada salinan salinan - inilah yang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan dibicarakan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oleh </font><font style="vertical-align: inherit;">Anton Polukhin dan Roman Rusyaev </font><font style="vertical-align: inherit;">pada konferensi mendatang </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ikuti pembaruan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">program</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di situs.</font></font></blockquote></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id487100/">https://habr.com/ru/post/id487100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id487090/index.html">Tingkat baru optimasi Windows</a></li>
<li><a href="../id487092/index.html">Memodelkan proses bisnis sebagai bagian dari proyek implementasi sistem ERP</a></li>
<li><a href="../id487094/index.html">Acara pemrosesan ulang yang diterima dari Kafka</a></li>
<li><a href="../id487096/index.html">Cuplikan. Cara membuat proses bekerja dengan dokumentasi lebih mudah</a></li>
<li><a href="../id487098/index.html">Draw with ants: gambar prosedural menggunakan algoritma optimisasi koloni semut</a></li>
<li><a href="../id487106/index.html">Penganalisa PVS-Studio RunUO memeriksa</a></li>
<li><a href="../id487108/index.html">Profil Gamer Seluler: Penelitian MyTracker</a></li>
<li><a href="../id487110/index.html">BURUK SRE. Eksperimen lengkap dengan pakar dari Booking.com dan Google.com</a></li>
<li><a href="../id487112/index.html">Edge of Madness: Lingkaran Dasar</a></li>
<li><a href="../id487116/index.html">Mengapa Perselisihan Bermigrasi dari Pergi ke Karat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>