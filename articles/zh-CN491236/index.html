<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛁 👨🏾‍✈️ ✌🏽 .NET中的异步编程：最佳实践 💓 🖲️ 👉🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C＃中异步/等待的出现导致对如何编写简单且正确的并行代码的重新定义。通常，使用异步编程，程序员不仅无法解决线程所带来的问题，而且还会引入新的问题。死锁和飞行无处不在-它们变得更难诊断。
 
 
 
 Dmitry Ivanov-华为软件分析团队的负责人，曾是JetBrains Rider技术的负责人...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.NET中的异步编程：最佳实践</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491236/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C＃中异步/等待的出现导致对如何编写简单且正确的并行代码的重新定义。通常，使用异步编程，程序员不仅无法解决线程所带来的问题，而且还会引入新的问题。死锁和飞行无处不在-它们变得更难诊断。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/uz/8g/buuz8gok2hqubwnj1773hwimncq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dmitry Ivanov-华为软件分析团队的负责人，曾是JetBrains Rider技术的负责人和ReSharper核心的开发人员：数据结构，缓存，多线程以及在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会议上的定期演讲者</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在过场动画下-来自DotNext 2019 Piter会议的Dmitry报告的视频记录和文字记录。</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wM-h6P1BJRk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代表讲者的进一步叙述。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在多线程或异步代码中，某些东西经常会中断。原因可能是僵局，也可能是种族。通常，一场竞赛每千次崩溃一次，通常不是在本地，而是在构建服务器上崩溃，并且要花几天的时间才能赶上。我相信对于很多人来说这是一个熟悉的情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，即使是经验丰富的开发人员，也要查看异步代码，我发现自己认为某些东西可以写得短三倍，而且更正确。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这表明问题不在于人，而在于工具。</font><font style="vertical-align: inherit;">人们只是使用该工具并希望其解决问题。</font><font style="vertical-align: inherit;">该工具本身具有大量功能（有时甚至是多余的），设置和隐式上下文，这导致以下事实：很容易错误使用。</font><font style="vertical-align: inherit;">让我们尝试弄清楚如何使用async / await并使用</font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET中</font><font style="vertical-align: inherit;">的类</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用异步/等待解决的方法存在问题。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有争议的设计示例。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现实生活中的一项任务，我们将异步解决。</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步/等待和有待解决的问题</font></font></h2><br>
<img src="https://habrastorage.org/webt/v1/ym/30/v1ym304jgxmwh_4kymlyqr4wddi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么我们需要异步/等待？假设我们有可用于共享共享内存的代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在工作开始时，我们使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dequeue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阻塞请求从阻塞队列（例如，从Internet或磁盘）读取请求，在这种情况下，该文件</font><font style="vertical-align: inherit;">（阻塞请求将在示例中用红色标记）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方法需要大量线程，并且每个线程都需要资源，在</font><i><font style="vertical-align: inherit;">调度程序</font></i><font style="vertical-align: inherit;">上造成了负载</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但这不是主要问题。假设人们可以重写操作系统，以便这些系统支持十万个线程和一百万个线程。但是主要的问题是某些线程根本无法使用。例如，您有一个用户界面线程。没有正常的适当UI框架，在该框架中，不仅要从一个线程访问数据。 UI线程无法被阻止。为了不阻止它，我们需要异步代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在让我们讨论第二个任务。读取文件后，需要以某种方式对其进行处理。我们将并行进行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
你们中许多人都听说过并行性与异步性不同。在这种情况下，就会出现一个问题：异步是否可以帮助编写更紧凑，美观和更快的并行代码？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后的任务是使用共享内存。</font><font style="vertical-align: inherit;">我们是否需要使用锁定来拖动这种机制，将其同步到异步代码，还是可以通过某种方式避免这种情况？</font><font style="vertical-align: inherit;">可以</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步/的await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这方面的帮助？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步/等待路径</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看世界上和.NET中异步编程的发展。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打回来</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Void <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {…}<font></font>
 <font></font>
<font></font>
<span class="hljs-function">Void <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    …<span class="hljs-comment">//synchronous code</span><font></font>
 <font></font>
    Foo(<span class="hljs-keyword">params</span>,() =&gt;{<font></font>
       …<span class="hljs-comment">//asynchronous code;continuation</span><font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
异步编程始于回调。</font><font style="vertical-align: inherit;">也就是说，首先您需要同步调用代码的某些部分，然后第二部分-异步调用。</font><font style="vertical-align: inherit;">例如，您从文件中读取数据，数据准备就绪后，它将以某种方式传递给您。</font><font style="vertical-align: inherit;">此异步部分作为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回调传递</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更多回调</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {...} 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">Action callback</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">Action callback</span>)</span> {...}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
    <font></font>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; { <font></font>
      ... <span class="hljs-comment">//continuation 1 </span><font></font>
      Bar(() =&gt; {<font></font>
        <span class="hljs-comment">//continuation 2</span><font></font>
        Baz(() =&gt; {<font></font>
          <span class="hljs-comment">//continuation 3</span><font></font>
        }); <font></font>
      });<font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，从一个回调中，您可以注册另一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回调</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，从中您可以注册第三个回调，最后，所有这些都将变成一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Callback Hell</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/vq/8g/bfvq8gknishmtrdwaiixz6mzuvs.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回调：例外</font></font></h3><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action onSuccess, Action onFailure</span>)</span> {...}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code </span>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; {<font></font>
      ... <span class="hljs-comment">//asynchronous code on success </span><font></font>
    },<font></font>
    () =&gt; {<font></font>
        ... <span class="hljs-comment">//asynchronous code on failure</span><font></font>
    }); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何处理例外情况？例如，ReSharper在分别响应异常和良好执行时，并未展示出最漂亮的代码片段-针对特殊情况和成功的延续，存在单独的回调。结果就是这样的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回调地狱</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但不是线性的，而是像树一样的，这可能完全令人困惑。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/hs/y3/lghsy31j9pke1do-8rpmcyuovfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在.NET中，第一种回调方法称为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步编程模型</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（APM）。该方法将称为</font></font><code>AsyncCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，与基本上相同</font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是该方法具有一些功能。首先，方法应以单词“ Begin”开头（从文件中读取的内容为BeginRead），它返回some </font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。自己</font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是一个知道该操作已完成并且具有某种机制的处理程序</font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。您</font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以挂起，等待操作异步完成。另一方面，您可以调用</font></font><code>EndOperation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即</font></font><code>EndRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同步</font><font style="vertical-align: inherit;">进行make </font><font style="vertical-align: inherit;">和hang（这非常类似于property </font></font><code>Task.Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方法有许多问题。首先，它不能保护我们免受</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回调地狱的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">伤害</font><font style="vertical-align: inherit;">。第二，仍然不清楚如何处理异常。第三，尚不清楚将在哪个线程上调用此回调-我们无法控制该调用。第四，问题来了，如何将代码段与回调结合起来？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mr/5z/xr/mr5zxr01ztmadod_fuetd3loqew.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个模型称为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于事件的异步模式</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这是一种响应式回调方法。方法的思想是我们将</font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有事件完成的对象</font><font style="vertical-align: inherit;">传递给该方法</font><font style="vertical-align: inherit;">并订阅该事件。如您所见，</font></font><code>BeginOperationName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改为</font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。当您进入Socket类时，可能会造成混乱，其中混合了两种模式：</font></font><code>ConnectAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>BeginConnect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，您必须致电取消</font></font><code>OperationNameAsyncCancel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。由于在.NET中找不到其他位置，因此通常每个人都发送</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，如果您意外地在库中遇到一个以结尾的方法，则</font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要了解它不一定会返回</font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而是可以返回类似的构造。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/w4/4u/6sw44uh3ljw5kwdkowtxylfz5xc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑在Java中称为</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以JavaScript（如</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promises</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和.NET（如</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task Asynchronous Patterns）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（即“任务”）形式表示的</font><i><font style="vertical-align: inherit;">Future</font></i><font style="vertical-align: inherit;">。此方法假定您有一些计算对象，并且可以看到该对象的状态（运行或已完成）。在.NET中，有</font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两种状态</font><font style="vertical-align: inherit;">的所谓</font><font style="vertical-align: inherit;">方便分隔：任务开始和任务完成。当一个方法被调用任务时一个常见的错误</font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是没有回报成功延续，但是</font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>Faulted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，在UI应用程序中单击“取消”的结果应与返回异常（执行）不同。在.NET中，有一个区别：如果执行是您要保护的错误，则</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取消</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-强制操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在.NET中，还引入了一个概念</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-它是一种在线程之上的抽象，用于指示在何处运行任务。在这种情况下，取消支持是在设计级别设计的。 .NET库中几乎所有操作</font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都可以传递。这不适用于所有语言：例如，在Kotlin中，您可以撤消任务，但在.NET中，则不能。解决方案可能是取消任务的人员与任务本身之间的责任划分。收到任务后，您只能明确地取消任务-您必须将其继续传递</font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个特殊的对象</font></font><code>TaskCompletionSoure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使您可以轻松地适应与</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于事件的异步模式</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font><i><font style="vertical-align: inherit;">异步编程模型</font></i><font style="vertical-align: inherit;">相关联的旧API</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果在任务中编程，则必须阅读一个文档。</font><font style="vertical-align: inherit;">它描述了有关tasa的所有协议。</font><font style="vertical-align: inherit;">例如，任何返回任务的方法都应在运行状态下返回它，这意味着它不能为</font></font><code>Created</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而所有此类操作都必须以结尾</font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合并延续</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Task <span class="hljs-title">ourMethod</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">return</span> Task.RunSynchronously(() =&gt;{<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Foo(); <span class="hljs-comment">//continuation 1</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Bar(); <span class="hljs-comment">//continuation 2</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Baz(); <span class="hljs-comment">//continuation 3</span><font></font>
  })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至于组合，考虑到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回调地狱</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，尽管有重复的代码片段，但改动很小，它可以以更线性的形式出现。</font><font style="vertical-align: inherit;">似乎代码正在以这种方式进行改进，但是这里也有一些陷阱。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始和继续任务</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
  TaskCreationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)<font></font>
Task.ContinueWith(Action&lt;Task&gt;, <font></font>
  TaskContinuationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们在标准任务启动过程中转到三个参数：第一个是启动任务的选项，第二个是启动任务的选项，</font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三个是- </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/w_/a4/fw/w_a4fwuiwflisfw-ifxqwtgnpxu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TaskScheduler告知任务从何处开始，并且是您可以独立覆盖的对象。例如，您可以覆盖method </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font><font style="vertical-align: inherit;">做</font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则该方法</font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从中获取线程</font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将任务发送到那里。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您接管</font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主线程，它将把所有内容放在一个队列中，并且任务将在主线程上顺序执行。但是，问题在于，在.NET中，您无需传递即可执行任务</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。出现了一个问题：.NET如何计算传递给它的任务？当任务从</font></font><code>StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部</font><font style="vertical-align: inherit;">开始时</font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">展示在</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们给她的那张。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于隐式上下文，这种设计似乎颇具争议。在某些情况下，它</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含异步代码，该代码在某处深深地继承</font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并与另一个调度程序重叠，从而导致死锁。在这种情况下，您可以使用option </font></font><code>TaskCreationOption.HideScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这是一个警钟，它表明我们有一些选项可以覆盖</font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
延续都是一样的。问题出现了：它从何而来</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？首先，它是从您开始使用的方法中获取的</font></font><code>Continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它也</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取自ThreadStatic。重要的是，对于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步/等待，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">延续的工作方式必须完全不同。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bt/-f/ne/bt-fnekfbdnfmn4n-u3zrvp7bdc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们转到参数</font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>TaskContinuationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。他们的主要问题是他们很多。这些参数中的一些互相抵消，有些则互斥。所有这些参数均可在所有可能的组合中使用，因此很难记住渴望会发生的所有事情。其中一些选项完全无法理解。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/us/wh/aguswhpfaos0qjqvfopo_rr8aeo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，参数</font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代表两个可能的应用程序选项，但是继续是以同步方式还是异步方式启动取决于许多您不知道的事情。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/-c/zv/jm-czv9x4lhhmibfgxqxwjcvxqe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个例子：我们启动了任务，启动了延续，并同时给出了两个参数</font></font><code>TaskContinuations.ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，之后他们异步开始继续。</font><font style="vertical-align: inherit;">它将在上一个任务结束的同一堆栈中执行，还是将其转移到</font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font><font style="vertical-align: inherit;">在这种情况下，将有第三个选择：取决于。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/j6/8z/vvj68zu1keb_n50viyk4iqbydae.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑一下</font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。创建任务时，可以设置其结果</font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以使以前的异步模式适应任务世界。您</font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以请求</font></font><code>tcs.Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且</font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在您致电时</font><font style="vertical-align: inherit;">此任务将进入状态</font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是，如果在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线程池上</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行它</font><font style="vertical-align: inherit;">，则会出现</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">死锁</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。问题是，为什么我们甚至不同步编写任何内容？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v5/g1/2b/v5g12bn0tycbshdrascqvi-hkug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们创建</font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，启动一个新任务，然后有第二个线程启动该任务中的某些内容。它超过了预期的一百毫秒。然后我们的主线程-绿色- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，就是这样。他释放堆栈，堆栈挂起，等待继续调用</font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当</font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暴露。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在蓝色线程中，我们转到</font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后是最有趣的。</font><font style="vertical-align: inherit;">基于.NET的内部考虑，他</font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">认为此操作的延续</font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以同步执行，即直接在同一堆栈</font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上执行</font><font style="vertical-align: inherit;">，然后</font><font style="vertical-align: inherit;">在同一堆栈上同步执行。</font><font style="vertical-align: inherit;">尽管我们什至没有写任何东西，这还是很奇怪</font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这可能是混合同步和异步代码的问题。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uv/7z/go/uv7zgosoif24okbeyq7fffwdz8o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与此相关的另一个问题</font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是，当我们</font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锁</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下</font><font style="vertical-align: inherit;">调用时</font><font style="vertical-align: inherit;">，您不能调用任意代码，因为在锁下您只能执行一些细粒度的活动。</font><font style="vertical-align: inherit;">在一些</font><i><font style="vertical-align: inherit;">动作</font></i><font style="vertical-align: inherit;">下运行</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，不可能来自他们来自哪里。</font><font style="vertical-align: inherit;">如何解决这个问题呢？</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span>  tcs  =  <span class="hljs-keyword">new</span>   TaskCompletionSource&lt;<span class="hljs-keyword">int</span>&gt;(<font></font>
       TaskContinuationsOptions.RunContinuationsAsynchronously  <font></font>
) ;<font></font>
<span class="hljs-keyword">lock</span>(mylock)<font></font>
{  <font></font>
    tcs.SetResult(O); <font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是</font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值得</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">只为不适应</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任务</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库中的代码。</font><font style="vertical-align: inherit;">通过等待几乎可以解决所有其他问题。</font><font style="vertical-align: inherit;">在这种情况下，始终强烈建议指定参数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ TaskCompletionSource.RunContinuationsAsynchronously”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您几乎总是需要异步运行延续。</font><font style="vertical-align: inherit;">在这种情况下，您</font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将无法启动任何东西。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ap/_-/ab/ap_-abu8wjhwxr0edsvayrcc-6w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么要同步执行延续？</font><font style="vertical-align: inherit;">因为它</font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指的是以下内容</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而不是我们的内容。</font><font style="vertical-align: inherit;">为了使他与我们的人联系起来，您需要编写以下内容：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/zj/6q/qbzj6q1fjhhqozii8yec5ok3pcy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此示例说明了参数如何不直观，它们如何相交，如何引入认知复杂性-很难编写。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亲子层次</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   })<font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// don’t wait for child</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有其他使用参数的选项。例如，</font><font style="vertical-align: inherit;">当您启动一个任务并在其下运行另一个任务时，</font><font style="vertical-align: inherit;">就会出现</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">父子</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">层次结构。在这种情况下，如果您编写</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">则不会等待内部启动的任务。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gw/se/28/gwse28nxykd4vfwt_chfw0qjt_w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您编写</font></font><code>TaskCreationOptions.AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待。您可以在产品中使用此属性。我认为每个人都可以举一个例子，其中有一个任务层次结构，任务等待子任务，子任务用于子任务。无需在任何地方写</font></font><code>WaitForChildren</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这种等待是异步发生的。也就是说，父任务的主体结束，并且在此之后父任务不被认为是完整的，直到子任务正常工作才开始其继续。</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// still wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... parent task to attach is in ThreadStatic</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可能存在将任务转移到中的某处的问题</font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后您开始时所做的所有操作</font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都会添加到此父任务中，这是一个警钟。</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo();<font></font>
}, TaskCreationOptions.DenyChildAttach)<font></font>
.ContinueWith(...) <span class="hljs-comment">// don’t wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一方面，有一个选项可以取消上一个选项</font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这种应用经常发生。</font></font><br>
<br>
<pre><code class="cs hljs">Task.Run(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">//don’t wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
    }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
值得记住的是，</font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是标准的启动方式，默认情况下暗含</font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
输入的隐式上下文</font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会增加复杂性。您不了解任务的工作原理，因为您需要了解上下文。可能出现的另一个问题与异步/等待的空闲状态有关。那是因为在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步/等待中，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您没有任务，但是有动作。延续不是诚实的任务，而是行动。编写异步/等待代码时，不需要使用</font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它，因为您明确地将任务捆绑在一起以等待等待，这是正确的方法。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k7/q5/vg/k7q5vgi8h9qwvvo3akgzow8vu_q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于如何开始延续，您有六个选择。您启动了任务，启动了</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">问题：这种延续将具有什么状态？</font><font style="vertical-align: inherit;">有五个可能的答案：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常规继续将成功完成；将发生RunToCompletion；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任务将是错误的；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取消将发生；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这项任务根本不会完成，而是处于某种困境。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项-“取决于”。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/5u/x5/1k/5ux51kwpr4aixg_2io3xroerxam.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，任务将处于“已取消”状态，尽管在任何地方都没有“已取消”一词。</font><font style="vertical-align: inherit;">在这里，我们扔接待，什么也不做。</font><font style="vertical-align: inherit;">问题是，即使您在十分钟前就知道了这些选项，当您阅读带有很多选项的他人的代码时，仍然会忘记这里发生的事情。</font><font style="vertical-align: inherit;">所以不要写。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消除</font></font></h3><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(); <font></font>
});<font></font>
<font></font>
                                                      Failed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任务开始时的第三个参数是kancellation。</font><font style="vertical-align: inherit;">您编写</font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即，将任务置于“已取消”状态的特殊操作。</font><font style="vertical-align: inherit;">在这种情况下，任务将处于“失败”状态，因为并非所有任务</font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都相等。</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(cancellationToken); <font></font>
}, cancellationToken);<font></font>
<font></font>
                                                      Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了使任务能够执行</font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您需要将</font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其及其CancellationToken一起</font><font style="vertical-align: inherit;">抛出</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">实际上，您永远不会显式地执行此操作，而是以这种方式进行操作：</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    cancellationToken.ThrowIfCancellationRequested(); <font></font>
}, cancellationToken);<font></font>
                                                       Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是否需要区分cancelToken？</font><font style="vertical-align: inherit;">在任务中的某处，您检查是否有人删除了您：取消抛出，然后任务进入状态</font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">或者有人在运行时单击“取消”并取消了任务。</font><font style="vertical-align: inherit;">我们在JetBrains的实践表明，您无需区分这些标记。</font><font style="vertical-align: inherit;">如果您收到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种在发生某些取消时发生的特殊类型，则可以对其进行区分。</font><font style="vertical-align: inherit;">在这种情况下，您只需要正常完成任务，不登录即可，并且在收到执行信息时-登录。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">深栈</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    Foo();<font></font>
}, cancellationToken);<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
     Bar() {<font></font>
       ...<font></font>
          Baz() {<font></font>
             <span class="hljs-comment">//how to get cancellation token?</span><font></font>
          } <font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设您有很多筹码。这</font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是我们讨论的唯一显式参数。必须通过绝对所有层次结构将其传输到任何地方。如果在存在较深层次的情况下，您需要在最低级别的某个地方取消任务以放弃接收，该怎么办？我们使用了一个特殊的技巧。他被称为</font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">static</span> AsyncLocal&lt;Cancelation&gt; asyncLocalCancellation;<font></font>
<font></font>
Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
     asyncLocalCancellation.Set(cancellationToken) <font></font>
    Foo();<font></font>
}, cancellationToken); <span class="hljs-comment">// use AsyncLocal to put cancellation int</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { 
     <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span> {<font></font>
      ...<font></font>
         Baz() {<font></font>
             asyncLocalCancellation.Value.CheckForInterrupt(); <font></font>
         }<font></font>
   } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这与</font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅在</font></font><code>ThreadLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步/等待代码旅行中幸存</font><font style="vertical-align: inherit;">的特殊</font><font style="vertical-align: inherit;">代码相同。</font><font style="vertical-align: inherit;">由于您的代码是异步的，并且具有此取消功能，因此将其放入中</font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在更深的位置可以说“ </font></font><code>CheckForInterrupt Throw If Cancellation Requested</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">”。</font><font style="vertical-align: inherit;">同样，这是唯一</font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要完全涂抹整个代码的参数，但是，我认为，对于大多数任务，您只需要知道发生了什么</font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并由此得出一个结论：取消或失败。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">认知复杂性</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
    TaskCreationOptions, <font></font>
    TaskScheduler, <font></font>
    CancellationToken<font></font>
)<font></font>
                                                   JetBrains.Lifetimes<font></font>
<font></font>
lifetime.Start(TaskScheduler, Action) <span class="hljs-comment">//puts lifetime in AsyncLocal</span><font></font>
<font></font>
lifetime.StartMainRead(Action) <font></font>
lifetime.StartMainWrite(TaskScheduler, Action) <font></font>
lifetime.StartBackgroundRead(TaskScheduler, Action)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
启动任务时阅读代码越困难，出错的风险就越高。一年后查看代码，您会忘记它的作用，因为其中包含大量参数。但是，我们有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JetBrains.Lifetimes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库</font><font style="vertical-align: inherit;">，它提供了现代化的寿命，以及优化的CancellationToken，与Start方法被重写，并与重复的代码段得到解决，因为这个问题</font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少数调度程序允许您使用读取锁定在主线程上调度任务。也就是说，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">读锁定</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是您显式选择的，它是一种特殊的调度程序，它使用</font><i><font style="vertical-align: inherit;">读锁定</font></i><font style="vertical-align: inherit;">在主线程上调度代码</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以及具有写锁的主线程，后台线程-现在，启动随机播放的方法变得非常简单。同时，生存期会自动通过取消</font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，从而大大简化了代码。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_h/1n/gu/_h1ngucdl-vvbpyyalkk_gwvapu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步/等待</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何</font><font style="vertical-align: inherit;">解决这些问题，以及它们带来了哪些问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此示例中，部分代码被同步执行，然后</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步代码。首先，重复的代码（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">样板</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">要少得多是一件好事</font><font style="vertical-align: inherit;">。其次，异步代码与同步代码非常相似，这正是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await的目的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。您可以以与同步编写相同的方式异步编写，而不会占用线程。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，编译器将部署什么？同步代码将同步执行，然后任务</font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font><font style="vertical-align: inherit;">同步执行</font><font style="vertical-align: inherit;">，特殊的GetAwaiter对象从何而来。在这种情况下，我们很感兴趣</font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。您可以为任何对象编写等待者。结果，我们等待任务完成</font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并同步执行它</font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果任务未完成，则</font><font style="vertical-align: inherit;">在</font><i><font style="vertical-align: inherit;">Context Scheduler</font></i><font style="vertical-align: inherit;">上</font><i><font style="vertical-align: inherit;">调度</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuationCode</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。即使您写了</font><i><font style="vertical-align: inherit;">await</font></i><font style="vertical-align: inherit;">，也可能绝对会同步调用所有内容。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
   <span class="hljs-keyword">await</span> InnerAsync();
   <span class="hljs-keyword">await</span> Task.Yield(); <span class="hljs-comment">//guaranteed !IsCompleted </span><font></font>
   continuationCode();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一个窍门</font></font><code>Task.Yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是一项特殊的任务，可确保其侍者不会总是回到您身边</font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，</font></font><code>continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此位置将不会同步调用它。对于UI线程，这可能很重要，因为您不会花费大量时间。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jg/jy/7d/jgjy7dh0cnbslfcyk4jpyapc9du.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何选择继续的线程？</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步/等待</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哲学是</font><font style="vertical-align: inherit;">这样的：您编写与同步相同的异步代码。如果您有一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线程池</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">那么这</font><font style="vertical-align: inherit;">对您没有任何影响-continuationCode将在另一个线程上执行。无论</font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您说的是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待状态</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是否</font><font style="vertical-align: inherit;">完成</font><font style="vertical-align: inherit;">，都需要在UI线程上执行所有操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
等待任务的机制如下：</font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它被调用，被调用</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从中创建</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是Post方法的事情，与方法非常相似</font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">实际上</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是更早的事情，它只需要</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Post并通过Post来执行其任务。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
    continuationCode(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一种方法可以使用参数更改此行为</font></font><code>ContinueOnCapturedContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">.NET中最令人讨厌的API称为</font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这种情况下，API将创建一个特殊的等待者，</font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该</font><font style="vertical-align: inherit;">等待者不同于</font><font style="vertical-align: inherit;">改变继续的</font><font style="vertical-align: inherit;">等待者，</font><font style="vertical-align: inherit;">它在相同的线程，方法终止</font></font><code>InnerAsync </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和任务终止</font><font style="vertical-align: inherit;">的相同上下文中运行</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//code must be absolutely context-agnostic</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
互联网上有很多疯狂的建议：如果您遇到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">死锁</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，请涂抹所有ConfigureAwait代码，一切都会好起来的。</font><font style="vertical-align: inherit;">这是错误的方式。</font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以在某些库方法中要稍微提高性能的情况下使用，也可以在方法结束时使用。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">死锁</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode();<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个典型的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">僵局</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在UI线程上，他们等待了十秒钟，然后完成了</font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于您所做的事情</font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将</font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">永远不会启动，</font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此</font><font style="vertical-align: inherit;">，它将</font><font style="vertical-align: inherit;">永远不会返回。</font><font style="vertical-align: inherit;">所有这些都是在一开始就发生的。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">OnBluttionClick</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span>
  <span class="hljs-keyword">int</span> v = Button.Text.ParseInt();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
  Button.Text.Set((v+<span class="hljs-number">1</span>).ToString());<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
想象这是一些真实的活动。我们单击按钮，将其打开，</font><i><font style="vertical-align: inherit;">等待</font></i><font style="vertical-align: inherit;">它</font></font><code>Button.ParseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后</font><font style="vertical-align: inherit;">写道：</font><font style="vertical-align: inherit;">我们说：“请不要关闭我们的UI流，继续执行。”问题是我们希望第二部分</font><font style="vertical-align: inherit;">也要在UI线程上执行，因为这是</font><i><font style="vertical-align: inherit;">await</font></i><font style="vertical-align: inherit;">的理念</font><font style="vertical-align: inherit;">。也就是说，您的异步代码看起来与同步代码相同，并且在相同的上下文中运行。在这种情况下，当然会出现错误。此外</font><font style="vertical-align: inherit;">，可以有许多假设其上下文的方法调用。在这种情况下该怎么办？你可以这样做：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><code>Button.Text.Set</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//The same UI context</span><font></font>
}<font></font>
PumpUntil(() =&gt; task.IsCompleted);<font></font>
<span class="hljs-comment">//VS synchronization contexts always pump on any Wait</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用UI线程，必须禁止在</font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有公共消息队列的线程上</font><font style="vertical-align: inherit;">执行此</font><font style="vertical-align: inherit;">操作。</font><font style="vertical-align: inherit;">您可以执行此消息队列，</font><font style="vertical-align: inherit;">而无需执行操作</font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或编写操作</font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，与此同时，连续过程也将被执行。如果不能混合使用同步和异步代码，则不要混合使用。但是有时候这是无法避免的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，您有旧代码，并且必须将它们混合，然后再泵送UI流。 Visual Studio可以按期望的速度注入UI线程，甚至</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有所改变。如果您在任何上进入WaitHandle </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则在挂起时，您的UI流将被抽出。因此，他们在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">僵局</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和种族</font><font style="vertical-align: inherit;">之间进行选择，而选择</font><font style="vertical-align: inherit;">种族s。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽水机</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是非理想的API，也就是说，当您在任意位置执行随机连续性时，可能会有细微差别。</font><font style="vertical-align: inherit;">不幸的是，没有其他方法。</font><font style="vertical-align: inherit;">混合同步和异步代码。</font><font style="vertical-align: inherit;">如果有的话，整个骑士都安排在旧地方，所以有时也会有些细微差别。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改变背景</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> myTaskScheduler;<font></font>
    continuationCode(); <span class="hljs-comment">//on scheduler context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有另一种使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有趣方式</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">你可以写</font></font><code>Awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和跳线程。</font><font style="vertical-align: inherit;">我在Visual Studio中阅读过帖子，他们写了很长时间的书，说在方法中间来回跳动并不好，但是现在他们自己做。</font><font style="vertical-align: inherit;">Visual Studio具有一个通过调度程序跳入线程的API。</font><font style="vertical-align: inherit;">对于正常使用，这样做是不好的。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构化并发</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Factory.StartNew(() =&gt; {...}, myTaskScheduler);<font></font>
    continuationCode(); <span class="hljs-comment">//on initial context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了方便地浸入新环境并返回旧环境，应建立一些结构性竞争或结构并行性。</font><font style="vertical-align: inherit;">例如，在60年代，GoTo运算符被认为是有害的，因为它违反了结构性。</font><font style="vertical-align: inherit;">就在这里。</font><font style="vertical-align: inherit;">跳线程违反了结构。</font><font style="vertical-align: inherit;">令人惊讶的是，使用异步状态机似乎是一个不错的出路。</font><font style="vertical-align: inherit;">也就是说，在违反常规结构的地方，您跳到GoTo，就可以违反线程结构：do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">将</font><font style="vertical-align: inherit;">其与标签</font><font style="vertical-align: inherit;">混合</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当您需要这样做时，这是一种极为奇怪和罕见的情况。</font><font style="vertical-align: inherit;">尽管如此，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回相同的上下文</font><font style="vertical-align: inherit;">还是更好</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，线程池将没有与原来相同的线程，而是具有相同的上下文。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺序行为</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与并行执行不同？</font><font style="vertical-align: inherit;">等待执行是顺序执行。</font><font style="vertical-align: inherit;">在这种情况下，我们开始第一个任务，等待它，然后开始第二个任务-我们等待。</font><font style="vertical-align: inherit;">我们没有并行性。</font><font style="vertical-align: inherit;">对于大多数用途，不需要并行性。</font><font style="vertical-align: inherit;">并行性本身比顺序更复杂。</font><font style="vertical-align: inherit;">串行代码比并行代码简单，这是一个公理。</font><font style="vertical-align: inherit;">但是有时您需要在并行代码中运行某些内容，并且您需要这样做：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">await</span> task1;<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并发行为</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();<font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，任务并行开始。</font><font style="vertical-align: inherit;">显然，方法可以在运行状态下立即返回任务，因此不会有并行性。</font><font style="vertical-align: inherit;">假设两个任务都抛出一个执行。</font><font style="vertical-align: inherit;">然后您等待第一个任务，然后在第一次等待中起飞。</font><font style="vertical-align: inherit;">就是说，您一写完</font></font><code>await task1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，就起飞了，却没有处理</font></font><code>exception task2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">有趣的是，这是绝对有效的代码。</font><font style="vertical-align: inherit;">正是这种代码使.NET导致这样一个事实，即在4.5版中，执行的行为已发生改变。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异常处理</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async(); <font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2;<font></font>
<font></font>
  <span class="hljs-comment">// if task1 throws exception and task2 throws exception we only throw and</span>
  <span class="hljs-comment">// handle task1’s exception</span><font></font>
<font></font>
  <span class="hljs-comment">//4.0 -&gt; 4.5 framework: unhandled exceptions now don’t crush process</span>
  <span class="hljs-comment">//still visible in UnobservedExceptionHandler</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前，未处理的执行只是简单地抛出了流程，如果您没有抓住其中的执行</font></font><code>UnobservedExceptionHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您也可以将其附加到调度程序中），那么该流程就不会执行。现在，这是绝对有效的代码。尽管.NET更改了其行为，但它保留了设置以沿相反的方向返回行为。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span>  Task  <span class="hljs-title">MyAsync</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)</span>  {  <font></font>
<font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">SomeTask1  <span class="hljs-title">Async</span>(<span class="hljs-params">cancellationToken</span>)</span>; <font></font>
 <font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">Some <span class="hljs-title">Task2Async</span>(<span class="hljs-params"> cancellation  Token</span>)</span>; 
  <span class="hljs-comment">//you should always pass use async API with cancelationToken  if possible </span><font></font>
} <font></font>
  <font></font>
<span class="hljs-keyword">try</span> { 
    <span class="hljs-keyword">await</span>  MyAsync( cancellation  Token); <font></font>
} <span class="hljs-keyword">catch</span> (OperationException e) { <span class="hljs-comment">// do nothing: OCE happened</span>
} <span class="hljs-keyword">catch</span> (Exception e) { <font></font>
    log.Error(e);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
查看执行过程如何进行。</font><font style="vertical-align: inherit;">必须传输CancellationToken -s，有必要“涂抹” CancellationToken -s所有代码。</font><font style="vertical-align: inherit;">异步的正常行为是您不检查任何地方</font></font><code>Task.Status ancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，使用异步代码的方式与使用同步的方式相同。</font><font style="vertical-align: inherit;">也就是说，在取消的情况下，您得到执行，而在这种情况下，收到时您什么也不做</font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状态为已取消和故障的区别是您没有收到</font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而是正常执行。</font><font style="vertical-align: inherit;">在这种情况下，我们可以保证，您只需要执行此操作并据此得出结论即可。</font><font style="vertical-align: inherit;">如果您通过Task显式启动了任务，那么您将得到飞行</font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">并且在异步情况下，在这种情况下，他们</font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总是抛出其中的第一个执行（在这种情况下- </font></font><code>OperationCanceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在实践中</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同步方式</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SynchronousWorker</span>(<span class="hljs-params">...</span>)</span> {<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，一个恶魔在ReSharper中工作-这是为您着色文件的编辑器。</font><font style="vertical-align: inherit;">如果在编辑器中打开了文件，则有一些活动会将其放入阻塞队列。</font><font style="vertical-align: inherit;">我们的流程</font></font><code>worker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从那里读取数据，然后使用此文件执行一系列不同的任务，对其进行着色，解析，构建，然后将这些文件添加到中</font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">有了</font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锁，其他机制已经在使用它。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步方式</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在将代码重写为异步代码时，我们首先将其替换</font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><code>async Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">确保最后写上“ Async”一词。</font><font style="vertical-align: inherit;">所有异步方法都必须以Async结尾-这是一个约定。</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
<font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在那之后，您需要对我们的做些事情</font></font><code>blockingQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。显然，如果有一些同步原语，那么就必须有一些异步原语。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-6/zk/8i/-6zk8ilnmdsonzd6zkafkcloqyi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个原语称为channel：位于package中的通道</font></font><code>System.Threading.Channels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。您可以创建有限和无限制的通道和队列，可以异步等待。此外，您可以创建一个值为“零”的通道，也就是说，它根本没有缓冲区。这种渠道称为集合渠道，在Go和Kotlin中得到积极推广。原则上，如果可以在异步代码中使用通道，则这是一个非常好的模式。也就是说，我们将队列更改为存在方法</font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">的通道</font></font><code>WriteAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessInParallel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一堆并行代码，用于处理文件并将其转换为</font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">异步可以帮助我们编写更紧凑的并行代码而不是异步代码吗？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简化并行代码</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以通过以下方式重写代码：</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e0/zt/8u/e0zt8ud_8b4_wsiqsrd9_baalwy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他们长什么样</font></font><code>ProcessInParallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？例如，我们有一个文件。首先，我们将其分解为词素，并且我们可以并行执行两个任务：构建搜索缓存和构建语法树。之后是“搜索语义错误”的任务。在此重要的是，所有这些任务都必须形成有向无环图。也就是说，您可以在并行线程中运行某些部分，而不能在并行线程中运行，并且显然有依赖关系哪个任务应该等待其他任务。您将获得此类任务的图表，并希望以某种方式将其分散在线程中。是否可以将其编写得精美无误？在我们的代码中，多次以不同的方式解决了这个问题。编写此代码没有错误时，这种情况很少发生。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xh/-h/3j/xh-h3jav69twzsqei3rrjbe2ymy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们按如下方式定义此任务图：假设每个任务还​​有其他任务，它依赖于该任务，然后使用ExecuteBefore字典编写方法的框架。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">骨架解决方案</font></font></h3> <br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore; <span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">// lots of work with toposort, locks, etc.</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> res; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您直接解决此问题，则需要对该图进行拓扑排序。</font><font style="vertical-align: inherit;">然后，执行没有相关任务的任务，执行该任务，分析锁下的结构，查看哪些任务没有相关任务。</font><font style="vertical-align: inherit;">运行，以某种方式分散它们</font></font><code>Task Runner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将其编写得更加紧凑：图形的拓扑排序+在不同线程上执行此类任务。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步懒</font></font></h3><br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore;
<span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();
  <span class="hljs-keyword">var</span> lazy = <span class="hljs-keyword">new</span> Dictionary&lt;Action&lt;ProcessedFile&gt;, Lazy&lt;Task&gt;&gt;(); 
  <span class="hljs-keyword">foreach</span> ((action, beforeList) <span class="hljs-keyword">in</span> ExecuteBefore)<font></font>
    lazy[action] = <span class="hljs-keyword">new</span> Lazy&lt;Task&gt;(<span class="hljs-keyword">async</span> () =&gt; <font></font>
    {<font></font>
      <span class="hljs-keyword">await</span> Task.WhenAll(beforeList.Select(b =&gt; lazy[b].Value)) 
      <span class="hljs-keyword">await</span> Task.Yield();<font></font>
      action(res);<font></font>
}<font></font>
  <span class="hljs-keyword">await</span> Task.WhenAll(lazy.Values.Select(l =&gt; l.Value)) 
  <span class="hljs-keyword">return</span> res;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一种称为的模式</font></font><code>Async Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们创建我们</font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该执行不同动作的动作。让我们创建一个字典：将每个阶段（Action ProcessedFile）的格式设置为某个Task，或者从Task设置为Lazy，然后沿原始图形运行。变量</font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将具有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动作</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本身</font><font style="vertical-align: inherit;">，并且在beforeList中-必须在我们之前执行的那些动作。然后</font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从</font><font style="vertical-align: inherit;">创建</font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们用Task编写</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，我们正在等待必须完成的所有任务。在beforeList中，选择</font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该词典中的一个。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，此处不会同步执行任何内容，因此该代码不会落在上</font></font><code>ItemNotFoundException in Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们执行了我们之前的所有任务，通过行动进行搜索</font></font><code>Lazy Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后我们执行动作。</font><font style="vertical-align: inherit;">最后，您只需要让每个任务开始即可，否则您将永远不知道某些事情是否没有开始。</font><font style="vertical-align: inherit;">在这种情况下，什么也没有开始。</font><font style="vertical-align: inherit;">这是解决方案。</font><font style="vertical-align: inherit;">这种方法是在10分钟内编写的，这是绝对显而易见的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，异步代码是我们的决定，起初它占据了几个屏幕，这些屏幕具有复杂的竞争代码。</font><font style="vertical-align: inherit;">在这里，他是绝对一致的。</font><font style="vertical-align: inherit;">我什至不使用它</font></font><code>ConcurrentDictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而是使用通常的它</font></font><code>Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为我们没有竞争性地给它写任何东西。</font><font style="vertical-align: inherit;">有一个一致的代码。</font><font style="vertical-align: inherit;">我们</font><font style="vertical-align: inherit;">很好地</font><font style="vertical-align: inherit;">解决了使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async -s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编写并行代码的问题</font><font style="vertical-align: inherit;">，这意味着-没有错误。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摆脱锁</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
    <span class="hljs-keyword">lock</span> (_lock) {<font></font>
      sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
   }<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是否值得引入异步和这些锁？现在有各种各样的异步锁，异步信号量，即试图使用同步和异步代码中的原语。这个概念似乎是错误的，因为使用锁可以保护某些东西免于并行执行。我们的任务是将并行执行转换为顺序执行，因为它更容易。而且如果容易的话，错误也就更少了。</font></font><br>
<br>
<pre><code class="cs hljs">Channel&lt;Pair&lt;File, ProcessedFile&gt;&gt; output;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
  <font></font>
  <span class="hljs-keyword">await</span> output.WriteAsync(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以创建一些通道，并在其中放置几个​​File和ProcessedFile，</font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他一些过程将</font><font style="vertical-align: inherit;">处理此通道</font><font style="vertical-align: inherit;">，并将按顺序进行。锁本身除了保护结构外，还实质上使访问线性化，在此位置，连续线程中的所有线程都变为并行。并且我们正在用渠道显式替换它。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/q_/qe/mf/q_qemfc4mssz9shitqlekzee6nc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
架构如下：工作人员从文件接收文件</font></font><code>input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将它们发送到处理器的某个位置，处理器也按顺序处理所有内容，没有并行性。该代码看起来简单得多。我了解并非所有事情都可以通过这种方式完成。当您可以构建数据管道时，这种体系结构并不总是有效。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7k/9j/sv/7k9jsvdwqbqrzgbejoozsk5lj_s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可能是您有第二个通道进入处理器，而不是从通道中形成非循环有向图，而是有周期的图。</font><font style="vertical-align: inherit;">这是Roman Elizarov在2018年告诉KotlinConf的一个例子。</font><font style="vertical-align: inherit;">他使用这些渠道在Kotlin上编写了一个示例，并且那里存在循环，并且该示例已关闭。</font><font style="vertical-align: inherit;">问题是，如果在图形中有这样的循环，那么异步世界中的一切都会变得更加复杂。</font><font style="vertical-align: inherit;">异步死锁的坏处在于，当您拥有一堆线程时，它们比同步死锁更难解决，而且很明显，挂死了什么。</font><font style="vertical-align: inherit;">因此，它是必须正确使用的工具。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">避免异步代码中的同步。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">串行代码比并行代码简单。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步代码可以很简单，并使用最少的参数和更改其行为的隐式上下文。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您已经习惯于编写同步代码，并且即使异步代码与同步代码非常相似，也不要在其中拖拽原语，而primitives是您在同步代码中所习惯的</font></font><code>async mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果可能，使用提要，以及其他</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传递消息的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原语</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
串行代码比并行代码简单。如果您可以编写体系结构使其顺序显示，而无需运行并行代码和锁定，则可以按顺序编写体系结构。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是我们从大量带有任务的示例中看到的最后一件事。</font><font style="vertical-align: inherit;">在设计系统时，请尽量减少对隐式上下文的依赖。</font><font style="vertical-align: inherit;">隐式上下文导致对代码中发生的事情的误解，并且您可能会忘记一年中的隐式问题。</font><font style="vertical-align: inherit;">而且如果另一个人处理此代码并重做其中的某些内容，则可能会导致您曾经知道的困难，而新程序员由于隐式上下文而不知道。</font><font style="vertical-align: inherit;">结果，不良的设计的特征在于大量的参数，它们的组合和隐式上下文。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">读什么</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TAP文件</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步指导</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一生</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">medium.com/@elizarov/deadlocks-in-non-hierarchical-csp-e5910d137cc</font></font></a></li>
</ul><br>
<blockquote>     -10     .     DotNext   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN491218/index.html">在PlatformIO中集成PVS-Studio</a></li>
<li><a href="../zh-CN491224/index.html">调度服务的自动化，或服务公司如何减少30％的运输成本</a></li>
<li><a href="../zh-CN491230/index.html">我如何去学校21和泄露秘密</a></li>
<li><a href="../zh-CN491232/index.html">RPA +机器学习=智能自动化</a></li>
<li><a href="../zh-CN491234/index.html">使用SOLIDWORKS进行3D打印零件建模的三个技巧</a></li>
<li><a href="../zh-CN491238/index.html">遗传密码分析II</a></li>
<li><a href="../zh-CN491240/index.html">通往云端的道路：昨天和今天</a></li>
<li><a href="../zh-CN491244/index.html">不需要Ableton：将Ableton Push 2连接到VCV机架</a></li>
<li><a href="../zh-CN491246/index.html">DEFCON会议27.您的车是我的车。第2部分</a></li>
<li><a href="../zh-CN491250/index.html">LED灯高斯基本</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>