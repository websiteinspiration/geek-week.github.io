<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚯 💬 📉 コピーペーストからコンポーネントへ：さまざまなアプリケーションでのコードの再利用 🥠 🍩 🐃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Badooはいくつかのアプリケーションを開発しており、それぞれが独自の特性、管理、製品、エンジニアリングのチームを持つ個別の製品です。しかし、私たちはすべて同じオフィスで協力して、同様の問題を解決しています。
 
 各プロジェクトの開発は独自の方法で行われました。コードベースは、さまざまな時間枠や製...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>コピーペーストからコンポーネントへ：さまざまなアプリケーションでのコードの再利用</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/466049/"><img src="https://habrastorage.org/webt/4j/xp/to/4jxptoi9jrqf5aynpoeurc816ee.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Badooはいくつかのアプリケーションを開発しており、それぞれが独自の特性、管理、製品、エンジニアリングのチームを持つ個別の製品です。</font><font style="vertical-align: inherit;">しかし、私たちはすべて同じオフィスで協力して、同様の問題を解決しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各プロジェクトの開発は独自の方法で行われました。</font><font style="vertical-align: inherit;">コードベースは、さまざまな時間枠や製品ソリューションだけでなく、開発者のビジョンにも影響を受けました。</font><font style="vertical-align: inherit;">最終的に、プロジェクトの機能は同じで、実装が根本的に異なることに気付きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、アプリケーション間で機能を再利用する機会が得られる構造にすることにしました。</font><font style="vertical-align: inherit;">今では、個々のプロジェクトで機能を開発する代わりに、すべての製品に統合する共通コンポーネントを作成しています。</font><font style="vertical-align: inherit;">私たちがこれをどのようにして実現したかに興味がある場合は、猫へようこそ。</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、最初に、問題を詳しく見てみましょう。問題の解決により、共通のコンポーネントが作成されました。</font><font style="vertical-align: inherit;">それらのいくつかがありました：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーション間でコピーして貼り付けます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スティックをホイールに挿入するプロセス。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトの異なるアーキテクチャ。</font></font><br>
</li>
</ul><br>
<img src="https://habrastorage.org/webt/wq/ls/ov/wqlsovroayg0xhqrwibqc37pv6y.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事では、と私のレポートのテキストバージョンである</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppsConf 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">閲覧することができ、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題：コピーと貼り付け</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少し前、木々がふわふわになり、草が青くなり、私が1歳若かったとき、私たちはしばしば次のような状況にありました。</font></font><br>
&nbsp;<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者がいます、彼をレシャと呼びましょう。彼は自分のタスクのクールなモジュールを作成し、それを同僚に伝え、それを自分のアプリケーションのリポジトリーに入れ、そこで使用します。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、すべてのアプリケーションが異なるリポジトリにあることです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-a/1f/zq/-a1fzqhp9m--jhxy1tcrmx7plwi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、開発者のAndreyは、別のリポジトリの別のアプリケーションに取り組んでいます。彼はこのモジュールを自分のタスクで使用したいと考えています。これは、Leshaが従事していたものと疑わしく似ています。しかし、問題が発生します。コードを再利用するプロセスは完全にデバッグされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況では、Andreiは彼の決定（ケースの80％で発生）を書くか、Lyoshaのソリューションをコピーアンドペーストして、アプリケーション、タスク、または気分に合うようにすべてを変更します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2e/nd/95/2end959nckg-szaxu_nwwwcqxtm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、Leshaは、自分のタスクのコードに変更を追加して、モジュールを更新できます。彼は別のバージョンを知らず、リポジトリを更新するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況にはいくつかの問題があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、いくつかのアプリケーションがあり、それぞれに独自の開発履歴があります。各アプリケーションで作業するとき、製品チームはしばしば単一の構造にするのが難しいソリューションを作成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二に、別々のチームがプロジェクトに関与しているため、相互に通信が不十分であり、したがって、1つまたは別のモジュールの更新/再利用について互いに連絡することはほとんどありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第3に、アプリケーションアーキテクチャは大きく異なります。MVPからMVIに、神のアクティビティから単一のアクティビティに。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、「プログラムのハイライト」：アプリケーションは異なるリポジトリにあり、それぞれが独自のプロセスを持っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの問題との戦いの初めに、私たちは究極の目標を設定しました：すべてのアプリケーション間でベストプラクティス（ロジックとUIの両方）を再利用することです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定：プロセスを確立します</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の問題のうち、2つはプロセスに関連しています。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">突き通せない壁でプロジェクトを共有する2つのリポジトリ。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コミュニケーションが確立されておらず、製品アプリケーションチームの要件が異なるチームを分離します。</font></font><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のものから始めましょう。同じモジュールバージョンの2つのリポジトリを扱っています。</font><font style="vertical-align: inherit;">理論的には、git-subtreeまたは類似のソリューションを使用して、共通のプロジェクトモジュールを個別のリポジトリに配置できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ro/q0/nr/roq0nrr9xuy2my8ajbsldfcismw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変更中に問題が発生。</font><font style="vertical-align: inherit;">安定したAPIを持ち、外部ソースを通じて配布されるオープンソースプロジェクトとは異なり、すべてを破壊する内部コンポーネントで変更が発生することがよくあります。</font><font style="vertical-align: inherit;">サブツリーを使用すると、そのような移行のたびに面倒になります。</font><font style="vertical-align: inherit;">昨年</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">のメビウス会議</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
でアントンシューキンが話していたように、iOSチームの私の同僚も同様の経験を持ってい</font><font style="vertical-align: inherit;">ます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らの経験を調査して理解した後、単一のリポジトリに切り替えました。</font><font style="vertical-align: inherit;">すべてのAndroidアプリケーションが1か所に配置されるようになったため、次のようなメリットがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gradleモジュールを使用してコードを安全に再利用できます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビルドとテストに1つのインフラストラクチャを使用して、CIでツールチェーンを接続することに成功しました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの変更により、チーム間の肉体的および精神的な障壁が取り除かれました。これにより、お互いの開発とソリューションを自由に使用できるようになりました。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、このソリューションには欠点もあります。</font><font style="vertical-align: inherit;">IDEやGradleの対象にならないこともある巨大なプロジェクトがあります。</font><font style="vertical-align: inherit;">Android StudioのLoad / Unloadモジュールは問題を部分的に解決する可能性がありますが、すべてのアプリケーションで同時に作業し、頻繁に切り替える必要がある場合、それらを使用することは困難です。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の問題-チーム間の相互作用-はいくつかの部分で構成されていました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コミュニケーションが確立されていない別々のチーム。&nbsp;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的なモジュールに対する責任の不明確な分布;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">製品チームのさまざまな要件。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それを解決するために、チャットや登録など、各アプリケーションに特定の機能を実装するチームを編成しました。</font><font style="vertical-align: inherit;">開発に加えて、これらのコンポーネントをアプリケーションに統合する責任もあります。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
製品チームはすでに既存のコンポーネントを手にしており、特定のプロジェクトのニーズに合わせてそれらを改善およびカスタマイズします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、現在、再利用可能なコンポーネントの作成は、アイデアの段階から生産の開始まで、会社全体のプロセスの一部です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューション：アーキテクチャの合理化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再利用に向けた次のステップは、アーキテクチャを合理化することでした。</font><font style="vertical-align: inherit;">なぜこれをしたのですか？&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのコードベースは、数年にわたる開発の歴史的な遺産を持っています。</font><font style="vertical-align: inherit;">時間と人とともに、アプローチは変化しました。</font><font style="vertical-align: inherit;">それで、私たちは全体のアーキテクチャの動物園がある状況に自分自身を見つけました、それは次の問題をもたらしました：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共通モジュールの統合は、新しいモジュールを作成するよりもほとんど時間がかかりました。</font><font style="vertical-align: inherit;">機能の特徴に加えて、コンポーネントとアプリケーションの両方の構造に我慢する必要がありました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションを切り替える必要があった開発者は、新しいアプローチを習得するために多くの時間を費やしました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの場合、ラッパーはあるアプローチから別のアプローチに作成され、モジュール統合のコードの半分になりました。</font></font><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、MVICoreライブラリ（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）で</font><font style="vertical-align: inherit;">構造化したMVIアプローチを採用しました</font><font style="vertical-align: inherit;">。私たちは特に、その機能の1つ、つまり常に有効性を保証するアトミック状態の更新に興味を持っていました。さらに少し進んで、論理レイヤーとプレゼンテーションレイヤーの状態を組み合わせ、断片化を減らしました。したがって、私たちは、唯一のエンティティがロジックを担当する構造になり、ビューは状態から作成されたモデルのみを表示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ze/4z/kr/ze4zkr0ecnm_x9il17ibon6uzkk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
責任の分離は、レベル間のモデルの変換を通じて発生します。これのおかげで、再利用性という形でボーナスを得ることができます。外部から要素を接続します。つまり、それぞれが他の要素が存在することを疑うことはありません。それらは単にいくつかのモデルを与えて、それらに来ることに反応します。これにより、コンポーネントを引き出して、モデル用のアダプターを作成することにより、他の場所でそれらを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際の画面例を見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wm/0k/cs/wm0kcsuh1io0cr4cnil0ui11gme.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的なRxJavaインターフェースを使用して、要素が機能するタイプを示します。入力は、インターフェイスConsumer &lt;T&gt;、出力-ObservableSource &lt;T&gt;で示されます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// input = Consumer&lt;ViewModel&gt;</span>
<span class="hljs-comment">// output = ObservableSource&lt;Event&gt;</span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">View</span></span>(
    <span class="hljs-keyword">val</span> events: PublishRelay&lt;Event&gt;<font></font>
): ObservableSource&lt;Event&gt; <span class="hljs-keyword">by</span> events, Consumer&lt;ViewModel&gt; {<font></font>
<font></font>
    <span class="hljs-keyword">val</span> button: Button
    <span class="hljs-keyword">val</span> textView: TextView<font></font>
<font></font>
    <span class="hljs-keyword">init</span> {<font></font>
        button.setOnClickListener {<font></font>
            events.accept(Event.ButtonClick)<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">accept</span><span class="hljs-params">(model: <span class="hljs-type">ViewModel</span>)</span></span> {<font></font>
        textView.text = model.text<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのインターフェースを使用して、ViewをConsumer &lt;ViewModel&gt;およびObservableSource &lt;Event&gt;として表現できます。</font><font style="vertical-align: inherit;">ViewModelには画面の状態のみが含まれ、MVVMとはほとんど関係がないことに注意してください。</font><font style="vertical-align: inherit;">モデルを受け取ったら、そこからデータを表示できます。ボタンをクリックすると、外部に送信されるイベントを送信します。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// input = Consumer&lt;Wish&gt;</span>
<span class="hljs-comment">// output = ObservableSource&lt;State&gt;</span><font></font>
<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Feature</span>: <span class="hljs-type">ReducerFeature</span>&lt;<span class="hljs-type">Wish, State</span>&gt;</span>(<font></font>
    initialState = State(counter = <span class="hljs-number">0</span>),<font></font>
    reducer = ReducerImpl()<font></font>
) {<font></font>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReducerImpl</span>: <span class="hljs-type">Reducer</span>&lt;<span class="hljs-type">Wish, State</span>&gt; </span>{
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(state: <span class="hljs-type">State</span>, wish: <span class="hljs-type">Wish</span>)</span></span> = <span class="hljs-keyword">when</span> (wish) {
            <span class="hljs-keyword">is</span> Increment -&gt; state.copy(counter = state.counter + <span class="hljs-number">1</span>)<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能はすでにObservableSourceとConsumerを実装しています。</font><font style="vertical-align: inherit;">そこで初期状態（0に等しいカウンター）を転送し、この状態を変更する方法を示す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wishの転送後、Reduceが呼び出され、最後の状態に基づいて新しいものが作成されます。</font><font style="vertical-align: inherit;">Reducerに加えて、ロジックは他のコンポーネントで記述できます。</font><font style="vertical-align: inherit;">あなたは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらについてもっと学ぶことができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの要素を作成した後は、それらを接続する必要があります。</font></font><br>
<br>
<img width="250" src="https://habrastorage.org/webt/pq/kh/jp/pqkhjphpe4pvypmm5y8icqralhy.png" align="left"><br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> eventToWish: (Event) -&gt; Wish = {    
    <span class="hljs-keyword">when</span> (it) {
        <span class="hljs-keyword">is</span> ButtonClick -&gt; Increment<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">val</span> stateToModel: (State) -&gt; ViewModel = {<font></font>
   ViewModel(text = state.counter.toString())<font></font>
}<font></font>
<font></font>
<font></font>
Binder().apply {<font></font>
    bind(view to feature using eventToWish)<font></font>
    bind(feature to view using stateToModel)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、あるタイプの要素を別のタイプに変換する方法を示します。</font><font style="vertical-align: inherit;">したがって、ButtonClickはIncrementになり、Stateのカウンターフィールドがテキストになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、目的の変換を使用して各チェーンを作成できます。</font><font style="vertical-align: inherit;">これにはバインダーを使用します。</font><font style="vertical-align: inherit;">ObservableSourceとConsumerの関係を作成して、ライフサイクルを観察できます。</font><font style="vertical-align: inherit;">そして、これらすべてが素敵な構文で。</font><font style="vertical-align: inherit;">このタイプの接続により、要素を個別に引き出して使用できる柔軟なシステムが実現します。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MVICore要素は、ObservableSourceおよびConsumerからラッパーを作成した後、アーキテクチャの「動物園」と非常にうまく連携します。</font><font style="vertical-align: inherit;">たとえば、クリーンアーキテクチャのユースケースメソッドをウィッシュ/ステートでラップし、フィーチャーの代わりにチェーンを使用できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/l3/x7/ee/l3x7eef1pxxq4qbl6epceicz_1a.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成分</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、コンポーネントに移ります。</font><font style="vertical-align: inherit;">彼らはどんな人ですか？&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションの画面を検討し、論理的な部分に分割します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s6/xb/mg/s6xbmgomehcdqao1psynv5mnnlc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは区別することができます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上部にロゴとボタンがあるツールバー。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロファイルとロゴのカード。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instagramセクション。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの各パーツは、完全に異なるコンテキストで再利用できるまさにそのコンポーネントです。したがって、Instagramセクションは、別のアプリケーションでのプロファイル編集の一部になる可能性があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/o_/yh/c7/o_yhc7jqyzwma6l4nljmf2jasuk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的なケースでは、コンポーネントはいくつかのビュー、ロジック要素、内部のネストされたコンポーネントであり、共通の機能によって結合されます。そしてすぐに問題が発生します：それらをサポートされている構造に組み立てる方法？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが遭遇した最初の問題は、MVICoreが要素の作成とバインドに役立つが、共通の構造を提供していないことです。共通モジュールの要素を再利用する場合、これらの部品をどこにまとめるかは明確ではありません。共通部分の内部か、アプリケーション側か</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的なケースでは、アプリケーションに断片を分散させたくはありません。</font><font style="vertical-align: inherit;">理想的には、依存関係を取得し、コンポーネント全体を望ましいライフサイクルで組み立てることができるような構造を模索しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、コンポーネントを画面に分割しました。</font><font style="vertical-align: inherit;">要素の接続は、アクティビティまたはフラグメント用のDIコンテナの作成の次に行われました。</font><font style="vertical-align: inherit;">これらのコンテナはすべての依存関係をすでに認識しており、ビューとライフサイクルにアクセスできます。&nbsp;</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">object</span> SomeScopedComponent : ScopedComponent&lt;SomeComponent&gt;() {<font></font>
<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: SomeComponent {
        <span class="hljs-keyword">return</span> DaggerSomeComponent.builder()<font></font>
            .build()<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> SomeComponent.<span class="hljs-title">subscribe</span><span class="hljs-params">()</span></span>: Array&lt;Disposable&gt; = <font></font>
        arrayOf(<font></font>
            Binder().apply {<font></font>
                bind(feature().news to otherFeature())<font></font>
                bind(feature() to view())<font></font>
            }<font></font>
        )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は一度に2つの場所で始まりました。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DIはロジックの使用を開始し、1つのクラスでコンポーネント全体の説明につながりました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナはアクティビティまたはフラグメントにアタッチされ、少なくとも画面全体を記述するため、そのような画面/コンテナには多くの要素があり、この画面のすべての依存関係を接続するための膨大な量のコードに変換されます。</font></font><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題を順番に解決するために、ロジックを別のコンポーネントに配置することから始めました。したがって、このコンポーネント内のすべてのフィーチャーを収集し、入力および出力を通じてビューと通信できます。インターフェースの観点からは、これは通常のMVICore要素のように見えますが、同時にいくつかの他の要素から作成されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bx/xf/ih/bxxfihgylnpbclxg3o9pcem9xr8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決して、要素を接続する責任を共有しました。しかし、画面上でコンポーネントを共有しましたが、手元にないことは明らかであり、その結果、1か所に多数の依存関係が生じました。&nbsp;</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Scope</span>
<span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentImpl</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span></span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> params: ScreenParams,<font></font>
    news: NewsRelay,<font></font>
    <span class="hljs-meta">@OnDisposeAction</span> onDisposeAction: () -&gt; <span class="hljs-built_in">Unit</span>,<font></font>
    globalFeature: GlobalFeature,<font></font>
    conversationControlFeature: ConversationControlFeature,<font></font>
    messageSyncFeature: MessageSyncFeature,<font></font>
    conversationInfoFeature: ConversationInfoFeature,<font></font>
    conversationPromoFeature: ConversationPromoFeature,<font></font>
    messagesFeature: MessagesFeature,<font></font>
    messageActionFeature: MessageActionFeature,<font></font>
    initialScreenFeature: InitialScreenFeature,<font></font>
    initialScreenExplanationFeature: InitialScreenExplanationFeature?,<font></font>
    errorFeature: ErrorFeature,<font></font>
    conversationInputFeature: ConversationInputFeature,<font></font>
    sendRegularFeature: SendRegularFeature,<font></font>
    sendContactForCreditsFeature: SendContactForCreditsFeature,<font></font>
    screenEventTrackingFeature: ScreenEventTrackingFeature,<font></font>
    messageReadFeature: MessageReadFeature?,<font></font>
    messageTimeFeature: MessageTimeFeature?,<font></font>
    photoGalleryFeature: PhotoGalleryFeature?,<font></font>
    onlineStatusFeature: OnlineStatusFeature?,<font></font>
    favouritesFeature: FavouritesFeature?,<font></font>
    isTypingFeature: IsTypingFeature?,<font></font>
    giftStoreFeature: GiftStoreFeature?,<font></font>
    messageSelectionFeature: MessageSelectionFeature?,<font></font>
    reportingFeature: ReportingFeature?,<font></font>
    takePhotoFeature: TakePhotoFeature?,<font></font>
    giphyFeature: GiphyFeature,<font></font>
    goodOpenersFeature: GoodOpenersFeature?,<font></font>
    matchExpirationFeature: MatchExpirationFeature,<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> pushIntegration: PushIntegration<font></font>
) : AbstractMviComponent&lt;UiEvent, States&gt;(</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況での正しい解決策は、コンポーネントを壊すことです。上記で見たように、各画面は、独立した部分に分割できる多くの論理要素で構成されています。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少し考えて、ツリー構造に到達し、単純に既存のコンポーネントからそれを構築して、このスキームを得ました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/el/yl/v1/elylv1elwdrgyoqdamiepx0lleo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、（ビューとロジックから）2つのツリーの同期を維持することはほとんど不可能です。ただし、コンポーネントがビューの表示を担当している場合は、このスキームを簡略化できます。すでに作成されたソリューションを検討した後、私たちはUberのRIBに依存してアプローチを再考しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sy/xt/kd/syxtkdw8uiusbnrneqna1-bqfbe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの背後にある考え方は、MVICoreの基本と非常によく似ています。</font><font style="vertical-align: inherit;">RIBは一種の「ブラックボックス」であり、依存関係（つまり、入力と出力）から厳密に定義されたインターフェイスを通じて通信が行われます。</font><font style="vertical-align: inherit;">このようなインターフェースを高速反復製品でサポートするのは明らかに複雑ですが、コードを再利用する絶好の機会があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、以前の反復と比較すると、次のようになります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネント内のロジックのカプセル化。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面をパーツに分割することを可能にするネストのサポート。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MVICoreをサポートする入出力からの厳密なインターフェースを介した他のコンポーネントとの相互作用。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントの依存関係のコンパイル時の安全な接続（DIとしてDaggerに依存）。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これはすべてからはほど遠いです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のリポジトリに</font><font style="vertical-align: inherit;">は、より詳細で最新の説明が含ま</font><font style="vertical-align: inherit;">れ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">てい</font></a><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ここには完璧な世界があります。</font><font style="vertical-align: inherit;">これには、完全に再利用可能なツリーを構築できるコンポーネントがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私たちは不完全な世界に住んでいます。&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現実へようこそ！</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不完全な世界では、我慢しなければならないことがたくさんあります。</font><font style="vertical-align: inherit;">私たちは次のことを心配しています：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまな機能：すべての統一にもかかわらず、要件の異なる個々の製品を扱っています。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サポート：A / Bテストで新しい機能がないとどうなりますか？</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レガシー（私たちの新しいアーキテクチャの前に書かれたすべてのもの）。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各アプリケーションが共通のコンポーネントに独自のものを追加するため、ソリューションの複雑さは指数関数的に増加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションに統合される一般的なコンポーネントの例として、登録プロセスを検討してください。</font><font style="vertical-align: inherit;">一般に、登録は一連の画面であり、フロー全体に影響を与えるアクションが含まれています。</font><font style="vertical-align: inherit;">各アプリケーションには、異なる画面と独自のUIがあります。</font><font style="vertical-align: inherit;">最終的な目標は、柔軟な再利用可能なコンポーネントを作成することです。これにより、上記のリストの問題を解決することもできます。&nbsp;</font></font><br>
<br>
<img src="https://habrastorage.org/webt/22/v6/cd/22v6cdpd9uf8ebuxcdo0j4mgc5a.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その他の要件</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各アプリケーションには、ロジックとUIの両方から独自の登録バリエーションがあります。したがって、データをダウンロードしてフロー全体をルーティングすることにより、コンポーネントの機能を最小限に一般化し始めます。&nbsp; </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nv/lr/1b/nvlr1bpwh_s1bw0lrlfk0py2zww.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなコンテナーは、サーバーからアプリケーションにデータを転送します。アプリケーションは、ロジックを備えた完成した画面に変換されます。唯一の要件は、そのようなコンテナーに渡される画面がフロー全体のロジックと対話するために依存関係を満たさなければならないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのアプリケーションでこのトリックを行った結果、画面のロジックはほとんど同じであることがわかりました。理想的な世界では、ビューをカスタマイズして一般的なロジックを作成します。問題は、それらをカスタマイズする方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MVICoreの説明から思い出せるように、ViewとFeatureはどちらもObservableSourceとConsumerからのインターフェースに基づいています。</font><font style="vertical-align: inherit;">それらを抽象化して使用すると、主要な部分を変更せずに実装を置き換えることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/ox/lo/ayoxlo24e49tsprdsdxplsdv4yo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、UIを分割してロジックを再利用します。</font><font style="vertical-align: inherit;">その結果、サポートがはるかに便利になります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サポート</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
視覚要素のバリエーションについて、A / Bテストを検討してください。</font><font style="vertical-align: inherit;">この場合、ロジックは変更されないため、ObservableSourceおよびConsumerからの既存のインターフェースを別のView実装に置き換えることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/qg/vm/agqgvmwnzn_cztnwovas8jk9ydw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、新しい要件が、すでに書かれたロジックと矛盾することがあります。</font><font style="vertical-align: inherit;">この場合、アプリケーションが画面全体を提供する元のスキームにいつでも戻すことができます。</font><font style="vertical-align: inherit;">私たちにとって、これは一種の「ブラックボックス」であり、インターフェイスが尊重されている間、コンテナに何が渡されるかは関係ありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統合</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際に示されているように、ほとんどのアプリケーションはアクティビティを基本単位として使用し、その間の通信手段は古くから知られています。</font><font style="vertical-align: inherit;">私たちがしなければならなかったのは、コンポーネントをActivityでラップし、データを入力と出力に渡す方法を学ぶことだけでした。</font><font style="vertical-align: inherit;">結局のところ、このアプローチはフラグメントでもうまく機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルアクティビティアプリケーションの場合、大きな変化はありません。</font><font style="vertical-align: inherit;">ほとんどすべてのフレームワークは、RIBコンポーネントが自身をラップできるようにする基本要素を提供します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最終的に</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの段階を経て、会社のプロジェクト間のコード再利用の割合が大幅に増加しました。</font><font style="vertical-align: inherit;">現在、コンポーネントの数は100に近づいており、それらのほとんどは一度に複数のアプリケーションの機能を実装しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの経験は次のことを示しています：</font></font><br>
<br>
<ul>
<li>      ,    ,        ;<br>
</li>
<li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   </a>,       ,    ;<br>
</li>
<li>               .<br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の同僚のZsolt Kocsiは以前、MVICoreとその背後にあるアイデアについて書いていました。</font><font style="vertical-align: inherit;">私は非常に私たちは私たちのブログ（に翻訳した彼の記事、読書をお勧めします</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RIBについては、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の元の記事をご覧ください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">また、実践的な知識を得るために</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、私たちから</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかのレッスン</font><font style="vertical-align: inherit;">（英語）</font><font style="vertical-align: inherit;">を取ることをお勧めし</font><font style="vertical-align: inherit;">ます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja466033/index.html">チームをアイデアの検索に関与させ、アイデア以上のものを得る方法</a></li>
<li><a href="../ja466039/index.html">eコマース用のPHPライブラリー：ATOLおよびPaytureの操作、GS1コードの解析およびその他のタスク</a></li>
<li><a href="../ja466041/index.html">Facebook開発者サークルの最初のオフラインイベント：モスクワコミュニティ-イベントの開始</a></li>
<li><a href="../ja466045/index.html">ブランドを活性化させる方法：成功したストーリーテリング</a></li>
<li><a href="../ja466047/index.html">オンラインストアの設計。パート3.ホームページとカタログ</a></li>
<li><a href="../ja466051/index.html">プロファイリングJavaミートアップの自動化10/09</a></li>
<li><a href="../ja466053/index.html">シンガポールのロシアのIT企業の代表：なぜそうではないのですか？</a></li>
<li><a href="../ja466059/index.html">本「デザイン思考。洞察から新製品や市場まで」</a></li>
<li><a href="../ja466065/index.html">PostgreSQLニュースダイジェスト。第17号</a></li>
<li><a href="../ja466067/index.html">Kodiの魅力的なスクリーンセーバー</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>