<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ß üë©üèø‚Äçüíº üö¥üèª Multi-colored windows: virtual constructor, CRTP and intricate templates üå§Ô∏è ü§ì ü§≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For quite some time, a non-trivial design pattern has been known when a derived class is passed in the base parameter:
 

template<class T> class Base...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Multi-colored windows: virtual constructor, CRTP and intricate templates</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/507146/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For quite some time, a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">non-trivial design pattern has been</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> known </font><font style="vertical-align: inherit;">when a derived class is passed in the base parameter:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">Base</span>
{</span><font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base&lt;Derived&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This template has its own name - CRTP: Curiously Recurring Template Pattern, which translates as "strangely repeating pattern." I added even more oddities to this already strange construction: I generalized it to a whole chain of inheritances. Yes, it really can be done, but for this you have to </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">give the soul</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to pay a big price. To find out how I did it and what price I have to pay, I invite you to read further this article for details.</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we will deal </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with terrible perversions by</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> various strange methods and other bad things. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I want to warn you right away: do not take the material described here as something serious. I am sure that in 95-99% of cases all this will never be useful to you in practice. This is a kind of entertaining math, a workout for the mind. In practice, it is unlikely to be useful, but it is interesting to devote time to this. Only in this case does the C ++ language and its capabilities act as mathematics. I warn you in advance, because If you are looking for something serious and practically oriented here, you may be disappointed.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Immediately tune in to the exotic, as if you suddenly found yourself in a country where two moons, three suns, leaves of plants are blue or lilac, and indeed many usual things are kind of ... strange and unusual ... If you are mired in gray everyday life and not long ago read something like that, then you came to the address ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multi-colored windows</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It was a long time ago. </font><font style="vertical-align: inherit;">Almost three years ago. </font><font style="vertical-align: inherit;">I then </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sat on heavy grass</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> only comprehended the </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zen</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> basis of C ++ 11/14 from the book Meyers S. - "Effective and modern C ++." </font><font style="vertical-align: inherit;">It also mentions this pattern. </font><font style="vertical-align: inherit;">After that, as I felt that I had </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">achieved enlightenment, I</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mastered the basics of the new standard and was ready to look at old things in a new way, I began to refresh a book on Windows API in my memory: Shchupak Yu. - ‚ÄúWin32 API. </font><font style="vertical-align: inherit;">Effective application development. ‚Äù </font><font style="vertical-align: inherit;">At the very beginning, it describes a minimal C language program for creating and displaying a window:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><font></font>
<font></font>
HWND hMainWnd;<font></font>
TCHAR szClassName[] = TEXT(<span class="hljs-string">"MyClass"</span>);<font></font>
MSG msg;<font></font>
WNDCLASSEX *wc;<font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{<font></font>
	HDC hDC;<font></font>
	PAINTSTRUCT ps;<font></font>
	RECT rect;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span>(uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		SetClassLongPtr(hWnd, <span class="hljs-number">-10</span>, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"Hello, world!"</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		DestroyWindow(hWnd);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="hljs-keyword">int</span> nCmdShow)</span>
</span>{	
	<span class="hljs-keyword">if</span>(!(wc = <span class="hljs-keyword">new</span> WNDCLASSEX))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"  !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	wc-&gt;cbSize = <span class="hljs-keyword">sizeof</span>(WNDCLASSEX);<font></font>
	wc-&gt;style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wc-&gt;lpfnWndProc = WndProc;<font></font>
	wc-&gt;cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;hInstance = hInstance;<font></font>
	wc-&gt;hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wc-&gt;hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wc-&gt;hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wc-&gt;lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wc-&gt;lpszClassName = szClassName;<font></font>
	wc-&gt;hIconSm = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">if</span>(!RegisterClassEx(wc))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"     !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">delete</span> wc;<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	hMainWnd = CreateWindow(szClassName, TEXT(<span class="hljs-string">"A Hello1 Application"</span>), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, <span class="hljs-number">0</span>, CW_USEDEFAULT, <span class="hljs-number">0</span>, (HWND)<span class="hljs-literal">NULL</span>, (HMENU)<span class="hljs-literal">NULL</span>, (HINSTANCE)hInstance, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(!hMainWnd)<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"   !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
	ShowWindow(hMainWnd, nCmdShow);<font></font>
	<span class="hljs-comment">//UpdateWindow(hMainWnd);</span><font></font>
<font></font>
	<span class="hljs-comment">//      </span>
	<span class="hljs-keyword">while</span>(GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<font></font>
	{<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//MessageBox(NULL, TEXT("Application is going to quit."), TEXT("Exit"), MB_OK);</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I have already done this many times, displaying different windows on the model of this book. </font><font style="vertical-align: inherit;">And suddenly I thought: I just read about C ++ just yesterday! </font><font style="vertical-align: inherit;">I can write my own class to display this window! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No sooner said than done:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;					<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The structure of the class is trivial: several constructors are declared (with the transfer of both the main parameters and links to the more detailed WNDCLASSEX structure), the CreateWnd function of registering the window class itself and creating the window, called from the constructors, as well as a set of virtual member functions that perform actions processing each of the Windows messages inside the window callback procedure. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Members of the class data are also minimal: window handle hWnd; WNDCLASSEX structure used to create the class; and the title bar of the window.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The window callback procedure is declared as static in order to avoid implicitly passing the this pointer to the class object and thus violate the agreement on the type (signature) of the function of the window procedure accepted in Windows (remember that we will not call this function ourselves, but Windows, because the parameters and return type of this function are strictly specified).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Window procedure and this pointer</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is known from C ++: if a member-function is defined as static, a pointer to a class object must be passed to it explicitly. However, we cannot pass a pointer to a class object in a static window procedure, because the format of this function does not allow this transfer. In this connection, a fundamental problem arises: if there are several objects of the WindowClass class, then how does the only static window procedure know which particular class object the message received? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is only one way out: you need to establish this connection in one way or another.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows identifies a window by its HWND hWnd handle. The class object corresponding to this window can be identified by a pointer to this object. Therefore, it is necessary to establish the connection hWnd &lt;-&gt; pointer to the WindowClass object. For example, a window procedure, being at the same time a member of a class, could have a link or a pointer to some also static data structure that establishes a connection between hWnd and an object pointer for each window and is updated every time an object of the class is created. The data structure must be static so that, firstly, it can be accessed from within a static window procedure without a pointer to any class object, and secondly, that it should be unique to all objects of the class (which logically follows from its purpose ), and thirdly,so that it is still bound to a class with the appropriate access level, and not be some external global variable.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, after figuring out how to describe this structure and why it is needed, it remains to find out what this structure should be. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Two dynamic arrays can be declared: one for HWND window handles, and the second for pointers to WindowClass objects. However, this is not the best solution: it is not clear how to choose the size of the array, what the scenarios for using windows will be, whether the arrays will turn out to be almost empty if their size is incorrectly selected, which will cause memory overrun. Or, on the contrary, when when creating windows their volume is exhausted, it will be necessary to increase their size, etc. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A better (and even I would say - ideal) solution in this situation is a list ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">list!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) A list is a dynamic data structure consisting of a set of nodes connected in pairs. Each node (in the case of a doubly linked list) has pointers to the previous and next nodes of the list, as well as additional stored data. In our situation, each window node corresponds to each of the windows, and the useful data is a window handle and a pointer to an object of the WindowClass class. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, each time a new window is created, a new list node is created and added to its end (becomes the last). When closing, the node is deleted, and the pointers of the previous and next nodes are adjusted to each other to replace the remote node. In this case, there is no memory overrun - exactly as many nodes are created as there are windows created, and they are also deleted at the same time as the window is closed.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, a new static member should also be added to the WindowClass class:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> List wndList;	<span class="hljs-comment">// ,    </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and declare it privileged to enable it to access WindowClass members:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">friend</span> List;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(I will not here now give a definition of the list class and node class, their functions, since this does not apply directly to the WindowClass class, and the implementation logic of this class is known and quite trivial.) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, the window procedure when a new message arrives in case it belongs to the number it processes, according to the window descriptor hWnd passed to it from Windows, it accesses the list, searches for a node in it according to the specified hWnd, and, finding it, gets the required pointer to an object of the WindowClass class. Then, by pointer, it calls a virtual function corresponding to the message being processed: for an overridden class, a virtual function with the same name can perform other actions.</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowClass::WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{
	<span class="hljs-comment">// 	</span>
	ListElement * pListElem = <span class="hljs-literal">nullptr</span>;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span> (uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		{<font></font>
			<span class="hljs-comment">//lParam      CREATESTRUCT,         WindowClass,  </span>
			<span class="hljs-comment">// (.  WindowClass::CreateWnd)</span>
			CREATESTRUCT *cs = <span class="hljs-keyword">reinterpret_cast</span>&lt;CREATESTRUCT *&gt;(lParam);<font></font>
			WindowClass *p_wndClass = <span class="hljs-keyword">reinterpret_cast</span>&lt;WindowClass *&gt;(cs-&gt;lpCreateParams);<font></font>
			p_wndClass-&gt;hWnd = hWnd;		<span class="hljs-comment">// hWnd   ,    </span>
			<span class="hljs-comment">//    </span><font></font>
			pListElem = wndList.add(p_wndClass);<font></font>
			<span class="hljs-keyword">if</span> (pListElem)<font></font>
				pListElem-&gt;p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//  ,   </span><font></font>
		}<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)	<font></font>
			pListElem-&gt;p_wndClass-&gt;OnPaint(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnClose(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnDestroy(hWnd);  <span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is one subtle point here. It concerns the initialization of the class and the processing of the WM_CREATE message. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When creating a window with the CreateWindow function, at the time of its invocation, the hWnd window handle is not yet known: the window has not yet been created! Therefore, in order to be able to call virtual OnCreate, you need to know the pointer to the class object. This is done by rather risky passing the this pointer from the WindowClass :: CreateWnd function to the CreateWindow function via the lParam pointer. When processing WM_CREATE, the window procedure receives this pointer from the parameter, with its help initializes the hWnd member inside the object, and then creates a new list node for this window using the pointer to the class object. Then it calls virtual OnCreate by pointer.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the remaining messages, the logic described above is performed: search for the list node by the current window handle hWnd transferred from Windows, and then call the desired virtual function by the pointer to the class object from the list node. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having compiled the program and making sure that everything is working correctly, I, rubbing my hands </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the feeling of my own greatness</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from the work done, began to read further. </font><font style="vertical-align: inherit;">And there on the next page the function of changing the window properties is indicated:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">DWORD <span class="hljs-title">SetClassLong</span><span class="hljs-params">(HWND hWnd, <span class="hljs-keyword">int</span> nIndex, LONG dwNewLong)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I immediately decided on the spot to create a new window based on the old one:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass		<span class="hljs-comment">//         </span><font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The derived class differs from the base class by adding a static window counter, as well as changing OnCreate, OnPaint and OnDestroy: the OnCreate function changes the background color of the window, OnPaint displays a different message, and OnDestroy decreases the static window counter. </font><font style="vertical-align: inherit;">Everything is very simple and clear. </font><font style="vertical-align: inherit;">Assembled and launched. </font><font style="vertical-align: inherit;">The message text has become different ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... but the color of the window has not changed.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virtual constructor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I then realized that I had already set foot on thin ice. </font><font style="vertical-align: inherit;">Not all the nuances are described in the basic material of the main books. </font><font style="vertical-align: inherit;">One of them is a virtual constructor. </font><font style="vertical-align: inherit;">I thought that calling the virtual function of the derived class from the constructor is exactly the same as everywhere else in the program. </font><font style="vertical-align: inherit;">It turned out that this could not be done.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problem is that the virtual function that is called from the constructor is called as not virtual: only the base class object is created, and then not until the end, and the derivative object has not yet been created, and the table of virtual functions has not been generated. In our case, we get the chain: derivative constructor -&gt; base constructor -&gt; CreateWnd -&gt; CreateWindow -&gt; window procedure -&gt; OnCreate, that is, OnCreate is actually called from the constructor. The derived object has not yet been created, therefore, OnCreate is called for the base class! Its redefinition in the derivative, it turns out, does not make sense! What to do?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is known from C ++ that any overridden function can be called by its full name: class_name :: function_name. A class name is not just a name: it identifies itself, in fact, the type of object. It is also known from C ++ that a class (and function) can be made template (template) by passing it (her) type as a parameter. Therefore, if you make the window procedure function template and pass the type of the derived class to it in some way, you can call the desired overridden function directly in the constructor of the </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stop stop stop !!! You can‚Äôt do the same !!! A derived class has not yet been created, its data has not been initialized: what functions are you going to call here? </font></font><br>
<s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you can‚Äôt, but really want to, then you can.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, I did not aim at a full appeal to the derived class. </font><font style="vertical-align: inherit;">I meant to call a completely </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">third-party</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WinAPI function, which has nothing to do with the class. </font><font style="vertical-align: inherit;">‚ÄúBut this can be done in completely different ways, and much easier!‚Äù </font><font style="vertical-align: inherit;">- you say. </font><font style="vertical-align: inherit;">Yes. </font><font style="vertical-align: inherit;">Can. </font><font style="vertical-align: inherit;">And I will write about it at the end of the article. </font><font style="vertical-align: inherit;">But at that moment I threw all this aside and concentrated on the purely technical side of the question: but still, is it possible, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in principle,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to call something from the derivative in the constructor of the base class? </font><font style="vertical-align: inherit;">It was a purely sporting interest, if you like. </font><font style="vertical-align: inherit;">I didn‚Äôt think about any practical side at that moment. </font><font style="vertical-align: inherit;">It was a non-trivial task, and I wondered if I could solve it.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Window Template Class - Method 1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the difficulty is: how to pass the type of the derived class to the window procedure? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I didn‚Äôt want to make the entire base class of WindowClass a template class at once: for each derived class its own base class will be generated. In addition, since WindowClass will become template, both the list nodes and the list itself will also have to be made template: they have pointers to class objects, and to use these pointers, they must know their type, that is, WindowClass and how it will be parameterized . At the moment of defining the list class and the node class, this is unknown; therefore, this type must also be passed as a parameter (from WindowClass). It follows that for each derived class will create its own list corresponding to </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this derived class</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(and only him)! And now you can‚Äôt put pointers to the base classes corresponding to different derivatives into one array: they have different types.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So I started looking for a way to pass the type of the derived class, without parameterizing the entire class. A type can be passed to the base class only through the constructor: this is the only function that is accessed when creating the object. Therefore, it should be boilerplate. However, it turned out that she obviously could not specify the template parameters: it would look like passing parameters to the template class itself, and not its constructor. Therefore, the type can only be inferred from the parameters passed to the constructor. But I didn‚Äôt want to add a special constructor parameter, which serves only for type inference: cluttering the list of arguments with a purely utility parameter. And if the user forgets to transfer it, for example,through at least the trivial (DerivedClass *) nullptr? This is not scary yet - the compiler will display an error message that the class cannot be instantiated. Worse, if the user creates a class hierarchy and passes a pointer to the wrong derived class: everything will be correct from the point of view of compilation, but we will get an incorrectly working program with an incomprehensible error.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In short, this design miscalculation is such a solution. </font><font style="vertical-align: inherit;">Thus, the responsibility for the correct instantiation is not even transferred to the creator of the derived class, but to the one who will use it! </font><font style="vertical-align: inherit;">And he can be neither a dream, nor a spirit regarding such nuances and sincerely do not understand where the error is. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ultimately, giving up, I decided nevertheless, without changing the constructor parameters, to parameterize WindowClass itself and at the same time the associated list and list node classes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WindowClass template class:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">struct</span> <span class="hljs-title">ListElement</span>				// 
{</span>
	<span class="hljs-comment">// </span>
	HWND hWnd;					<span class="hljs-comment">//  Windows</span>
	WindowClass&lt;WndCls&gt; *p_wndClass;	<span class="hljs-comment">//    WindowClass</span><font></font>
<font></font>
	ListElement *pNext;			<span class="hljs-comment">//    </span>
	ListElement *pPrev;			<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-keyword">using</span> WndProcCallback = LRESULT (*)(HWND, UINT, WPARAM, LPARAM);		<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List&lt;WndCls&gt; wndList;					<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//	</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T, <span class="hljs-keyword">typename</span> </span>= T::OnCreate&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//! .  FirstWin32CPP_DerivedTemplate2</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span><font></font>
		T::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//  OnCreate         </span>
	</span>{<font></font>
		p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List&lt;WndCls&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
	<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Derived class:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WindowClassDerived&amp;);		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A window procedure, being a template member of a template class and having access to the passed type of the derived class, calls OnCreate of the derived class. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So we come naturally to the CRTP template. Here it turned out by itself. Only much later did I find out that this design is a well-known template with the corresponding name. But then I did not know this, and it seemed to me that I received it for the first time.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I realized right away that this is only half the solution. </font><font style="vertical-align: inherit;">I can easily want to create another class based on this derivative. </font><font style="vertical-align: inherit;">And that‚Äôs it: it is not a template one and no longer accepts any parameters. </font><font style="vertical-align: inherit;">So I came up with the idea of ‚Äã‚Äãpassing the second derived class through the first derivative to the base one. </font><font style="vertical-align: inherit;">(The thin ice under my feet began to crack ... I was already going where there was no return.) But if I do it once, I can do it as many as I like: even if I have ten derived classes, I can take the tenth in a row ( the very last one) to pass along the chain to the base one, and it will call there the function of this last derivative that I need (and, generally speaking, any intermediate one, if desired). </font><font style="vertical-align: inherit;">The task was clear. </font><font style="vertical-align: inherit;">All that remained was to do it.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameterized Window Class - Method 2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the second run, I set myself three tasks:</font></font><br>
<ul>
<li>-     ;</li>
<li>   ;</li>
<li>   ,   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, in order to comply with these requirements, you will still have to make a template for the designer and still add a special parameter to it. However, this means a violation of another requirement. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is the solution here? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can divide the original WindowClass base class into two components: WindowClass itself (let's call it WindowClassBase now), which is a single unshakable foundation, and supplementing its derived class (which can be called the same original WindowClass name). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The complementary class is responsible for the implementation of OnCreate, and, in addition, it can be parameterized as a whole. And he in his constructor will pass the type passed to him through a special parameter to the constructor of the WindowClassBase class.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In any case, in WindowClassBase relative to the source now you have to make some changes. First, in addition to actually removing OnCreate from it, you will have to add a pointer member to the class that supplements it (and, in the future, derivatives of it), as well as a call function that calls OnCreate by this pointer: we cannot call the pointer to the base one, because OnCreate is no longer in it, and OnCreate of the classes that are complementary and derived from it is better to call it by the correct pointer to the desired class, rather than trying to something with the this pointer of the base. Ultimately, the special parameter of the WindowClassBase constructor will be needed not only for type inference, but also for saving and then calling the necessary class through OnCreate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, the type of this pointer had to be made void:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the class is not template, and you cannot tell the compiler to create a pointer with an unknown type;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">many derivatives are inherited from the base class, they all have different types - what type of pointer should I use?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the end, I just declared it in C style: in any strange situation, use a pointer to void. </font><font style="vertical-align: inherit;">The pointer is physically stored as typeless, but at the time of the call, OnCreate is cast to the type of the called class. </font><font style="vertical-align: inherit;">This is done in a special template call function that belongs to WindowClassBase and whose parameter type is known at the time of the call:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
</span>{
	<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span>
	<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
		(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Initially, std :: true_type or std :: false_type was used as the second parameter to select the desired option to override the function. Using the SFINAE method, it was ascertained at the compilation stage whether the WndCls class has an OnCreate member function. If it does, then the above version of the function is called. If it does not, then the call to OnCreate was made in the form:</font></font><br>
<pre><code class="cpp hljs">(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;OnCreate(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Subsequently, it became clear that SFINAE was not necessary: ‚Äã‚Äãa class that complements WindowClassBase, in any case, has an OnCreate member function, therefore, even if the passed WndCls parameter class does not have OnCreate defined in it, it is in one of the base classes with respect to it , and checking will give true in all cases. If, by some miracle, the complementing class is changed so that OnCreate is removed from it, and in all classes derived from it, it will not be either, then there is no point in calling it according to the second option: such code simply will not be compiled. Therefore, in the end, the above option is given here.)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The logic of accepting and using the base class type in WindowClassBase is quite simple: the type is derived from the pointer to the object of the derived class passed to the WindowClassBase constructor, this pointer is stored in this constructor, and the pointer to the template window procedure is instantiated by the passed type, and the above LaunchOnCreate is accessed . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, the WindowClassBase class will now look like this:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassBase</span>				//  <span class="hljs-title">Windows</span>
{</span>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span>
	<span class="hljs-keyword">void</span> *p_drvWndCls;								<span class="hljs-comment">//   ,    (..  -  </span>
													<span class="hljs-comment">//,   ( )   , ..   void</span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls</span>
		<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
			(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">friend</span> List;
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">friend</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//     </span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassBase(WindowClassBase&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassBase();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, here is the code for the shortest constructor:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase::WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle)</span>
</span>{
	<span class="hljs-comment">// ,   ,   wc</span>
	<span class="hljs-comment">// : p_wndClass -    ,        , wc -    </span>
	<span class="hljs-comment">//    Windows, szWndTitle -   </span><font></font>
<font></font>
	WindowClassBase::wc = wc;<font></font>
	WindowClassBase::wc.lpfnWndProc = WndProc&lt;WndCls&gt;;<font></font>
	WindowClassBase::szWndTitle = szWndTitle;<font></font>
<font></font>
	p_drvWndCls = p_wndClass;		<span class="hljs-comment">//    ,   OnCreate()      WM_CREATE</span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	CreateWnd(WindowClassBase::wc, <span class="hljs-literal">false</span>, szWndTitle);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inside the window procedure, the call to LaunchOnCreate is as follows:</font></font><br>
<pre><code class="cpp hljs">p_wndClass-&gt;LaunchOnCreate&lt;WndCls&gt;(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
He decided to remove the window procedure itself from the class outside, declaring it privileged in the WindowClassBase class. Perhaps this didn‚Äôt make much sense: what difference does it make, where to produce its instantiations - outside or inside the class? The code segment is one! Although, I admit, from the point of view of the same encapsulation, perhaps you should still leave it static inside the class. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It remains to define the complementary class:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase			<span class="hljs-comment">//,  WindowClassBase    </span><font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The class has a constructor that looks the same as the original WindowClass before splitting, that is, without a special parameter, and this special parameter is generated internally when the WindowClassBase constructor is accessed by passing the this pointer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This WindowClass in this form is almost the equivalent of the original WindowClass. </font><font style="vertical-align: inherit;">As such, it does not support inheritance with OnCreate overrides. </font><font style="vertical-align: inherit;">However, this is the starting point for supporting inheritance (as will be shown below). </font><font style="vertical-align: inherit;">In this form:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the base class WindowClassBase is not generic in itself, which means that it will be the only one for all derived classes, whatever they may be; </font><font style="vertical-align: inherit;">the List to ensure that all other Windows messages are correctly processed will also be the only one;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the WindowClass constructor does not have an extra special parameter.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, two of the three requirements are satisfied. </font><font style="vertical-align: inherit;">It remains to deal with the latter: with inheritance.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derived class type chaining in WindowClassBase, control type</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To begin with, we will consider one-time inheritance, when the initialization logic of WindowClass does not suit us, and we want to change it through the creation of a derived class (for now at least one). </font><font style="vertical-align: inherit;">What needs to be changed in WindowClass to ensure this? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A new variant of the complementary class becomes boilerplate. </font><font style="vertical-align: inherit;">This is not scary, since it actually does not contain any data, but only the OnCreate function and constructors:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This class takes a parameter of type DerWndCls and, converting the this pointer to it, passes it to WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pay attention to static_cast. This is important because my conversion was originally written in C style like this:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After I translated it everywhere to static_cast, half of the code (see below) did not compile. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is also a delicate point: the conversion is performed at the compilation stage, but this class itself has the OnCreate function, and after the conversion, DerWndCls can be used to call OnCreate of the DerWndCls class. </font><font style="vertical-align: inherit;">This is the difference from the conversion case described above inside WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, you can create a certain class WindowClassDerived, override OnCreate in it and instantiate it with the WindowClassTemplate described above, again implementing the same original strange repeating template indicated at the beginning of the article:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And OnCreate of this WindowClassDerived will be called inside the WindowClassBase, as required!</font></font><br>
<pre><code class="cpp hljs">WindowClassDerived::WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle) : WindowClassTemplate(hInstance, szClassName, szWndTitle)<font></font>
{<font></font>
	usiWndNum++;		<span class="hljs-comment">//    </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But this is a one-time inheritance. </font><font style="vertical-align: inherit;">In the case of multiple inheritance, instead of WindowClassDerived, in turn, you should declare a new template, potentially taking the class a level higher in the hierarchy and passing it to WindowClassTemplate. </font><font style="vertical-align: inherit;">I specifically highlight two key points:</font></font><br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Potentially</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> host class up in the hierarchy. </font><font style="vertical-align: inherit;">This means that it may not accept any class, that is, be itself the very top class of the hierarchy so that an object can be created from it.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transmitting</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parameter WindowClassTemplate. </font><font style="vertical-align: inherit;">This means that the accepted template argument must be passed further from class to class through the entire inheritance chain to the very bottom, in WindowClassTemplate and from there to WindowClassBase.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, on the one hand, the class must be template and take a certain class as a parameter. On the other hand, it must monitor the situation that it is itself a finite (at the time of instantiation) class, and instantiate the base class by itself, and not by the transferred type. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With all this, I would like it to be done automatically by the compiler: defining a new class based on an already created one will not require any modification of the latter ‚Äî then the whole essence of inheritance-polymorphism is lost. That is: I create a class that is currently at the top of the hierarchy, but then </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maybe</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a new class will be created based on this, which will replace the current one without changing its definition. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How to implement this functionality?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To solve the problem of automation and intelligent decision-making, the default argument for the template suggests itself: if the current class being created is the top one and the template parameter is not passed to it, then we must assign this parameter to it. This is accomplished using the default argument. Then the following questions arise: how to choose it and how to relate it to the situation of the parameter passed explicitly, as well as transferring itself if the parameter is not passed? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, you cannot write your own defined class as a default parameter. The compiler simply will not miss the code of the form:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">WindowClassDerived</span>&lt;&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
He reports that a recursive type dependency is too complex. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let‚Äôs go on the other side. </font><font style="vertical-align: inherit;">Let us introduce a fictitious class that does nothing functionally and does not store anything, playing the role of only dummy plugs and signaling to the compiler that in case of its appearance nothing will be transferred ‚Äúfrom above‚Äù:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};	<span class="hljs-comment">//-,     </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And in the default argument, substitute this gag for ourselves:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With this option, in the situation with the default argument, thisclass is passed to the WindowClassTemplate. </font><font style="vertical-align: inherit;">The thisclass class does not have an OnCreate member function, so this option simply does not compile. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let‚Äôs try then to introduce a second, auxiliary control parameter, on the basis of which we will decide which type to pass on. </font><font style="vertical-align: inherit;">To do this, of course, you need to change the WindowClassTemplate, for example, like this:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassControlBaseTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//  ControlType == thisclass,      DerWndCls,    ,   WindowClassBase</span>
	<span class="hljs-comment">//  ControlType != thisclass,    ControlType,        ( </span>
	<span class="hljs-comment">//    ControlType     )</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;ControlType, thisclass&gt;::value, DerWndCls, ControlType&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassControlBaseTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassControlBaseTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Not one type is transmitted to it, but two. Based on the combination of these two types, the final type is determined using the &lt;type_traits&gt; tools: std :: conditional_t ‚Äã‚Äãand std :: is_same. It is this type that is passed on to WindowClassBase. The selection logic is described in the comments: if thisclass is passed to ControlType, then we select DerWndCls, otherwise ControlType itself is selected. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's build a template that uses it when inheriting:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsDerivedTemplateClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassControlBaseTemplate&lt;WndClsDerivedTemplateClass&lt;DerWndCls&gt;, ControlType&gt;		<span class="hljs-comment">//      </span><font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WndClsDerivedTemplateClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WndClsDerivedTemplateClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WndClsDerivedTemplateClass(WndClsDerivedTemplateClass&amp;);	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WndClsDerivedTemplateClass() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first parameter is initialized by default through thisclass, and ControlType is calculated based on DerWndCls itself: if DerWndCls = thisclass, then ControlType: = thisclass, otherwise ControlType: = DerWndCls (specifically specified Pascal-style assignment to distinguish from comparison). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, the WndClsDerivedTemplateClass class itself, parameterized by DerWndCls, will be passed along with the control type computed (at the compilation stage).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we create an object of this class, that is, WndClsDerivedTemplateClass itself is the top of the hierarchy, then DerWndCls = ControlType = thisclass, and then &lt;WndClsDerivedTemplateClass, thisclass&gt; passes. The fact that WndClsDerivedTemplateClass is parameterized by a dummy does not matter - this type, and indeed any DerWndCls passed in place, is not used inside the class in any way: no object is created from it and no function is called through it. Therefore, formally WndClsDerivedTemplateClass can be instantiated literally with anything - the parameter type serves only for passing further along the line of inheritance. But here, instead of DerWndCls, WndClsDerivedTemplateClass &lt;thisclass or any other type&gt; was passed on, it matters: WndClsDerivedTemplateClass has an OnCreate function,which will be called inside WindowClassBase.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With this option, thisclass comes to the WindowClassControlBaseTemplate in place of the ControlType, and the final type is displayed as DerWndCls = WndClsDerivedTemplateClass, which has the OnCreate function needed. Which is what we need. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now consider the option when a new class is built based on WindowClassControlBaseTemplate (further inheritance):</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, in WndClsDerivedTemplateClass, something other than thisclass takes the place of DerWndCls, and ControlType, seeing this difference, takes on the value passed to DerWndCls. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then in the WindowClassControlBaseTemplate the following parameterization option goes: &lt;WndClsDerivedTemplateClass &lt;WindowClassDerivedTemplateNext&gt;, WindowClassDerivedTemplateNext&gt;. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In WindowClassControlBaseTemplate, in turn, since ControlType! = Thisclass, it uses the ControlType itself, which is equal to WindowClassDerivedTemplateNext, which is the right class for selecting OnCreate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At first glance, with such a scheme, everything seems to be good. But this is not so. We build another class based on the latter:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedTemplateNext&lt;WindowClassDerivedTemplateNext2&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In WindowClassDerivedTemplateNext, WindowClassDerivedTemplateNext2 will replace DerWndCls. ControlType is also displayed as WindowClassDerivedTemplateNext2. Then, WindowClassDerivedTemplateNext </font><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt; </font><font style="vertical-align: inherit;">will be passed to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WndClsDerivedTemplateClass</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and ControlType will display the same WindowClassDerivedTemplateNext &lt;WindowClassDerivedTemplateNext2&gt; in it. Next, the same values ‚Äã‚Äãwill be transferred to WindowClassControlBaseTemplate, and there, instead of the correct WindowClassDerivedTemplateNext2 &lt;WindowClassDerivedTemplateNext&gt;, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;WindowClassDerivedTemplateNextTerplateDiveTerplateDiveTlassDimeTextDementer </font><font style="vertical-align: inherit;">is used to </font><b><font style="vertical-align: inherit;">call the</font></b><font style="vertical-align: inherit;"> WindowClass function.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I remind you that with this scheme of inheriting and passing parameters, the type of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><b><font style="vertical-align: inherit;">itself</font></b><font style="vertical-align: inherit;"> , which came to WindowClassControlBaseTemplate as a result, is important, and not what it is parameterized with. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, so that the type for which OnCreate will be called is displayed correctly, you need to change the definition of the WindowClassDerivedTemplateNext class:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, then in WndClsDerivedTemplateClass, the correct value equal to WindowClassDerivedTemplateNext2 will be passed to the ControlType instead of being displayed there in the wrong value. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, the last class we are building should not pass ControlType, allowing the nearest base one to output it independently, and this base one and all the underlying ones must pass ControlType explicitly, prohibiting its automatic output to the wrong value. This approach implies a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">change in the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definition of the nearest base class, which is possible only if we have the source code available or we built it ourselves before.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we forgot to do this and violated this rule, then when using static_cast we get a compilation error, and if we convert C-style pointers inside WindowClassControlBaseTemplate, we get a </font><font style="vertical-align: inherit;">program that </font><font style="vertical-align: inherit;">does </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> work </font><b><font style="vertical-align: inherit;">correctly</font></b><font style="vertical-align: inherit;"> . For example, if we try to create an object for a class</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
then the compiler will give an error: it will not be able to convert the pointer types inside the WindowClassControlBaseTemplate due to the fact that the type was incorrect and cannot be converted for (since we are going to create an object of the WindowClassDerivedTemplateNext class, we assume for it that the WindowClassDerivedTemplateNext class itself is at the top hierarchy, and in this case, as shown above, ControlType should not be passed). Without static_cast, the code will compile and just call OnCreate of the wrong class. However, removing the ControlType transmission makes the program compiled again.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ultimately, all this is too complicated, unreliable, and requires the availability of source codes of all classes. </font><font style="vertical-align: inherit;">In addition, we can only create objects of the last derived class, and one of its base classes cannot be created due to the ControlType transmission (or we can if the pointer is passed in the C style, but these objects will be incorrectly initialized). </font><font style="vertical-align: inherit;">We need a different solution, more simple and reliable.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable template</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, the above variant of template inheritance and passing the type of the created object to the WindowClassBase class, where the window is created and the OnCreate call, has serious drawbacks. We need some other, more reliable and efficient option. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 11 introduces a new type of template: a template with a variable number of arguments, or a variable template. Its parameters are a sequence of types of previously unknown length. Instead of risky manipulations with the control type in the previous example, I decided to go the other way: to avoid situations where the intermediate class in the hierarchy replaces the parent class in the hierarchy through incorrect parameterization (in the example above it was </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt;), you can generally get rid of this type of parameterization by simply putting these classes in sequence next to each other. For example, with three successive inheritances in the template parameters, the following list will eventually be formed: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;WndCls3 &lt;&gt;, WndCls2 &lt;&gt;, WndCls1 &lt;&gt;&gt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Processing this list, more precisely, one of its final elements (depending on how you composed it), You can extract the desired class in the hierarchy and work with it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, instead of the WindowClassTemplate and WindowClassControlBaseTemplate templates described earlier, which are closest to the root WindowClassBase and form the basis for all other inheritances, you should write a new variable template class. In its simplest version, it will be like this:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,      </span>
<span class="hljs-keyword">template</span>&lt;class... Classes&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>;</span>		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-comment">//,          </span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span>... <span class="hljs-title">OtherWindowClasses</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>&lt;DerWndCls, OtherWindowClasses...&gt; :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//      :    - DerWndCls</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = DerWndCls;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadicTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadicTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, a general description of the class template without the body is declared. Then, his specialization is determined, in which the first type is separated from the rest. It is he who is of interest to us. This is true for the case when each subsequent class places itself </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the end of</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the parameter list </font><font style="vertical-align: inherit;">when moving down the hierarchy chain to WindowClassBase </font><font style="vertical-align: inherit;">. Then the class we need will be at the beginning, and it is very simple to separate it from the rest. You can do differently: each new class will put itself </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the beginning</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">list of template options. Then the class at the top of the hierarchy will be the last in the list, and extracting it from there is much more difficult. In this particular case, these two approaches are completely identical, but the first is much easier to implement (including during compilation - you won‚Äôt have to process the entire list by extracting the last element from it), and it is he who is given above. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first element, which is the highest class in the hierarchy, is retrieved from the list and passed to WindowClassBase. If OnCreate is defined for it, it will be called. Otherwise, the OnCreate of the nearest base class will be called in relation to it. If the variable parameter list is empty (we are trying to create an object from WindowClassVariadicTemplate), then compilation will fail, requiring at least one type in the parameter list.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first class based on WindowClassVariadicTemplate will be like this:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic1</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadicTemplate&lt;PrevWndClasses..., WindowClassVariadic1&lt;&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadic1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(hInstance, szClassName, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadic1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(wc, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	WindowClassVariadic1(WindowClassVariadic1&amp; wcObj) : WindowClassVariadicTemplate(wcObj)			<span class="hljs-comment">// </span><font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassVariadic1() <span class="hljs-keyword">override</span>		<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);		<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_DESTROY   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This class, having accepted an undefined list of PrevWndClasses parameters, passes it further to the base class, inserting itself in front of it as the first element with an empty list of parameters. </font><font style="vertical-align: inherit;">Since this class WindowClassVariadic1 itself is variable, WindowClassVariadic1 &lt;&gt; will also be variable, although without parameters, and this entire sequence of classes is actually a variable template, each element of which is also a variable template. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following derived class is:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic2</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic1&lt;PrevWndClasses..., WindowClassVariadic2&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With the exception of changing the name of the derivative and the base, the class has exactly the same form as the previous one. </font><font style="vertical-align: inherit;">The next class is similar:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic3</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic2&lt;PrevWndClasses..., WindowClassVariadic3&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is the meaning of polymorphic multiple inheritance: declaring a class this way, we guarantee not only the creation of objects of this type, but also all objects of all other classes derived from it, no matter how much and whatever they are in the future. In this case, the correct OnCreate will always be called in WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, this variable template is the first working way to solve the problem of calling OnCreate when creating a window that fully meets all the previously set requirements.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Looking ahead, where the best method in the given situation was ultimately found, the implementation of inheritance through a variable template allows you to implement more complex compilation logic in WindowClassBase: having access to all types by which inheritance occurred, you can flexibly choose among them the necessary or criteria and call the member function defined in it. </font><font style="vertical-align: inherit;">But this is still a slightly different case.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialization class</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unaware of the reaction of static_cast to derived types, I continued to look for other ways to implement the transfer of the hierarchy's vertex class to WindowClassBase. </font><font style="vertical-align: inherit;">At some point, I thought about bringing the OnCreate implementation to a separate class, specially created for it:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassInit1</span>
{</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This class parameterizes another class that implements all other overrides for virtual functions. </font><font style="vertical-align: inherit;">It is derived from the already described WindowClassTemplate:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsInit</span> = <span class="hljs-title">WindowClassInit1</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedI1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WndClsInit&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this way:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class inheritance occurs as usual for virtual functions;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only the initialization class specially defined for the implementation of OnCreate is transferred from class to class according to the inheritance chain.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If this class is located at the top of the hierarchy, then the WndClsInit parameter will become equal to WindowClassInit1 - the initialization class defined for this class, and it will be transferred further along the hierarchy chain. If this class is intermediate in the chain, then it will simply accept the class passed to it and pass it on. Then, that this option compares favorably with the previous ones in that the templates do not transfer themselves, but transfer some third-party class, which is implemented (and looks) much easier. A template in this form is also suitable without changes for the implementation of the entire inheritance chain: only the change of class names will occur.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, static_cast, unlike C-style conversion, inside WindowClassTemplate will not miss this form of inheritance: it simply cannot convert when passing this from (WindowClassTemplate *) to (WindowClassInit1 *). </font><font style="vertical-align: inherit;">And this is logical: WindowClassInit1 is actually an extraneous class, just passed as a type to this point, it is not connected in any way with WindowClassTemplate and the entire chain of derivatives from it, therefore pointer conversion to it is unacceptable.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derived class type chaining in WindowClassBase, conditional transfer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And finally, the best way was found for this situation to transfer the type of the derived class to the root base WindowClassBase through the entire inheritance chain, devoid of the drawbacks of the previous ones and at the same time simpler than the variable template. </font><font style="vertical-align: inherit;">Define the following template class based on WindowClassTemplate:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassDerivedAlternative1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerivedAlternative1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerivedAlternative1() <span class="hljs-keyword">override</span>	<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);	<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>			<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>	<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{
		<span class="hljs-comment">//  WM_PAINT   </span><font></font>
		HDC hDC;<font></font>
		PAINTSTRUCT ps;<font></font>
		RECT rect;<font></font>
<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"       ( )."</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This class accepts DerWndCls as a parameter, which by default is equal to thisclass. </font><font style="vertical-align: inherit;">During the transfer, DerWndCls is compared with thisclass: in case of equality (the default value, that is, the given class is at the top of the hierarchy), it passes itself with an empty list of parameters. </font><font style="vertical-align: inherit;">Otherwise, the received DerWndCls is passed on. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I consider this solution to be the best in this situation in all respects:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a single form of class definition for the entire inheritance chain;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simple and transparent logic of class transfer along the entire inheritance chain;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no overhead due to the variable template (in those cases, as in this, when this is not required).</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrible retribution</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What does all this mean? </font><font style="vertical-align: inherit;">This means that if you want to use such an unconventional form of inheritance, you must design all your classes in a strictly defined way so that they allow the transfer through yourself of a possible new derivative. </font><font style="vertical-align: inherit;">This is a very easy requirement, and if you wish, it is easy to follow. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But there is another, much more non-trivial question: the relationship between types and pointers. </font><font style="vertical-align: inherit;">Smart people wrote: do not play with such things in the constructor and go against the principles of the language and the logic of the compiler. </font><font style="vertical-align: inherit;">But I did not obey and did it anyway. </font><font style="vertical-align: inherit;">Now comes natural retribution. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we have 4 classes:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative2&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative3</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative2&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative3&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative4</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative3&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative4&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As I wrote above, their specific content and logic of work are completely unimportant. </font><font style="vertical-align: inherit;">The only important thing is that in the title of the class definition. </font><font style="vertical-align: inherit;">Based on these classes, we create 4 objects:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">WindowClassDerivedAlternative1&lt;&gt; <span class="hljs-title">w1</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative2&lt;&gt; <span class="hljs-title">w2</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative3&lt;&gt; <span class="hljs-title">w3</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative4&lt;&gt; <span class="hljs-title">w4</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>))</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We expand the definitions of their types hidden behind empty brackets using the default arguments. Type w1 is WindowClassDerivedAlternative1. Type w2 is WindowClassDerivedAlternative2, and its base class is WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative2&gt;. The type w3 is WindowClassDerivedAlternative3, its base class is WindowClassDerivedAlternative2 &lt;WindowClassDerivedAlternative3&gt;, and its base class is WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative3&gt;. Similarly, for the fourth object. Take a look at the following diagram:</font></font><br>
<img src="https://habrastorage.org/webt/bu/b5/nn/bub5nnsttowpw1lhstypwm-3vfc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By creating each new derived class on the basis of a certain base class that is defined in this way, you define not just a new class, but at the same time the whole chain of its base ones all over again. It will be parallel to the chain of its own base class. Your class will have its own base classes, and none of them will be able to lead to any of the original base classes, despite the fact that the generation code for all these classes is the same! It seems real fantasy, but it really is! This means that all the usual ways to manipulate inherited classes and pointers will not work! In this particular architecture, only the base WindowClassBase saves the situation, otherwise it would also be impossible to create an array from the base classes (for example, based on the WindowClassTemplate),because all such classes have different types.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, the well-known and understandable definition of the form:</font></font><br>
<pre><code class="cpp hljs">WindowClassDerivedAlternative1&lt;&gt; *p2 = &amp;w2;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... will stop compiling because you are trying to create a type pointer that is incompatible with the type of the w2 object despite the fact that half an hour ago you yourself wrote a class derived from the WindowClassDerivedAlternative1 &lt;&gt; class and based on which the w2 object was created.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When habitual laws stop working, it can cause shock. </font><font style="vertical-align: inherit;">And with all this, there are actually no dirty compiler hacks, forced type conversions, and other really bad things. </font><font style="vertical-align: inherit;">Everything is extremely clean and legal: templates, default parameters, and type library tools. </font><font style="vertical-align: inherit;">Only familiar code writing methods stop working. </font><font style="vertical-align: inherit;">Using this in a real project means declaring there a danger zone, which can only be entered by qualified specialized personnel with appropriate protective measures.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code Experiments</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To make it easier for everyone interested in experimenting and save time on typing, I posted on GitHub all the projects that served as the basis for this article: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ECRTP</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Just choose one project in turn as your starting one, otherwise you will drown in a sea of ‚Äã‚Äãcolorful windows.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚ÄúIf all this is such a joke, then, given the efforts expended, it looks too serious and natural. </font><font style="vertical-align: inherit;">And if not a joke, then no normal developer in their right mind will really use anything like that. </font><font style="vertical-align: inherit;">And anyway, dude, wouldn‚Äôt you end up suffering nonsense and not go do something </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that brings money, it‚Äôs</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> useful. ‚Äù </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You are right if you think so. </font><font style="vertical-align: inherit;">In this article, I just showed that C ++ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The question of the practical application of these structures remains open. And in general, this is more likely to apply to generalized and metaprogramming. You may not need to create any objects of these classes at all, but the classes themselves may be needed for some reason. Yes, and you never know what useful solutions you can come up with on this basis ... The original CRTP is used! And it‚Äôs not even used anywhere, but right in the standard library! Who does not believe or do not remember, google std :: en_shared_from_this. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Returning to the original task with windows ... Especially now, soberly </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and without grass</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> looking back at all this three years later ... Even if we discard the fact that I touched on a banal topic that has already been traveled a million times, and this has long been of no interest to anyone, because for </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">real boys</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normal people have </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MFC</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qt, I would just ensure that some functional object is passed to the window class. </font><font style="vertical-align: inherit;">It‚Äôs not difficult to ensure its transfer through the chain of inheritance, but it will do everything simply, clearly and without distortion, and you will get a completely normal predictable class without any side effects, which you can accompany and develop to absolutely anyone. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What happened in this article is just an interesting non-trivial task, which I still managed to solve. </font><font style="vertical-align: inherit;">I hope this was interesting to you too.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en507114/index.html">Ode Excel: 34 Years of Magic</a></li>
<li><a href="../en507116/index.html">"Udalenka". Notes from yesterday‚Äôs office developer. Part 2</a></li>
<li><a href="../en507124/index.html">PDB is not only valuable fur</a></li>
<li><a href="../en507132/index.html">Vladimir Kitov: ‚ÄúIt is impossible to understand how pioneering scientists foresaw universal computerization back in the 1950s!‚Äù</a></li>
<li><a href="../en507138/index.html">21st Century Geology as the Earth Data Science</a></li>
<li><a href="../en507148/index.html">Send magic links using Node.js</a></li>
<li><a href="../en507150/index.html">We draw an interference picture in JavaScript</a></li>
<li><a href="../es486176/index.html">Memo de correspondencia de correo electr√≥nico corporativo</a></li>
<li><a href="../es486178/index.html">FOSS News No. 1 - revisi√≥n de noticias gratuitas y de c√≥digo abierto del 27 de enero al 2 de febrero de 2020</a></li>
<li><a href="../es486180/index.html">Consejos y fuentes para crear aplicaciones sin servidor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>