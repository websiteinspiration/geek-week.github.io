<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏾 🔁 🥝 Metode Monte Carlo untuk Rantai Markov (MCMC). pengantar 🧔🏽 🧛🏿 💱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 
 
 Kami mengingatkan Anda bahwa sebelumnya kami mengumumkan buku " Pembelajaran Mesin Tanpa Kata-Kata Tambahan " - dan sekarang sudah dij...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Metode Monte Carlo untuk Rantai Markov (MCMC). pengantar</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/491268/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mengingatkan Anda bahwa sebelumnya kami mengumumkan buku " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembelajaran Mesin Tanpa Kata-Kata Tambahan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " - dan sekarang sudah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dijual</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Terlepas dari kenyataan bahwa bagi pemula di MO, buku itu memang bisa menjadi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desktop</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , beberapa topik di dalamnya masih belum tersentuh. Oleh karena itu, kami menawarkan kepada semua orang yang tertarik untuk menerjemahkan sebuah artikel oleh Simon Kerstens tentang esensi algoritma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MCMC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan implementasi algoritma semacam itu di Python.</font></font><br>
<a name="habracut"></a> <br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode Monte Carlo untuk rantai Markov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (MCMC) adalah kelas metode yang kuat untuk pengambilan sampel dari distribusi probabilitas yang hanya diketahui hingga konstanta normalisasi tertentu (tidak diketahui). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, sebelum mempelajari MCMC, mari kita bahas mengapa Anda mungkin perlu membuat pilihan seperti itu. Jawabannya adalah: Anda mungkin tertarik pada sampel itu sendiri dari sampel (misalnya, untuk menentukan parameter yang tidak diketahui menggunakan metode derivasi Bayesian), atau untuk memperkirakan nilai yang diharapkan dari fungsi relatif terhadap distribusi probabilitas (misalnya, untuk menghitung jumlah termodinamika dari distribusi keadaan dalam fisika statistik). Terkadang kami hanya tertarik pada mode distribusi probabilitas. Dalam hal ini, kami mendapatkannya dengan metode optimasi numerik, sehingga tidak perlu membuat pilihan lengkap.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ternyata pengambilan sampel dari distribusi probabilitas apa pun kecuali yang paling primitif adalah tugas yang sulit. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode transformasi terbalik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah teknik dasar untuk pengambilan sampel dari distribusi probabilitas, yang, bagaimanapun, membutuhkan penggunaan fungsi distribusi kumulatif, dan untuk menggunakannya, pada gilirannya, Anda perlu mengetahui konstanta normalisasi, yang biasanya tidak diketahui. Pada prinsipnya, konstanta normalisasi dapat diperoleh dengan integrasi numerik, tetapi metode ini dengan cepat menjadi tidak praktis dengan peningkatan jumlah dimensi. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengambilan Sampel Deviasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu tidak memerlukan distribusi yang dinormalisasi, tetapi untuk mengimplementasikannya secara efektif, perlu banyak tahu tentang distribusi yang menarik bagi kita. Selain itu, metode ini sangat menderita dari kutukan dimensi - ini berarti efektivitasnya menurun dengan cepat dengan peningkatan jumlah variabel. Itulah mengapa Anda perlu mengatur penerimaan sampel representatif secara cerdas dari distribusi Anda - tidak perlu mengetahui konstanta normalisasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma MCMC adalah kelas metode yang dirancang khusus untuk ini. Mereka kembali ke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel tengara Metropolis dan lainnya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; Metropolis mengembangkan algoritma MCMC pertama yang dinamai </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menurut namanya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan dirancang untuk menghitung keadaan keseimbangan sistem dua dimensi bidang keras. Bahkan, para peneliti sedang mencari metode universal yang akan memungkinkan kita untuk menghitung nilai-nilai yang diharapkan ditemukan dalam fisika statistik. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini akan membahas dasar-dasar pengambilan sampel MCMC. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RANTAI MARKOV</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita mengerti mengapa kita perlu mengambil sampel, mari kita beralih ke jantung MCMC: rantai Markov. Apa itu rantai Markov? Tanpa membahas perincian teknis, kita dapat mengatakan bahwa rantai Markov adalah urutan acak negara dalam ruang keadaan tertentu, di mana probabilitas memilih negara tertentu hanya bergantung pada keadaan rantai saat ini, tetapi tidak pada sejarah sebelumnya: rantai ini tidak memiliki memori. Dalam kondisi tertentu, rantai Markov memiliki distribusi stasioner unik negara, yang konvergen, mengatasi sejumlah negara. Setelah sejumlah negara bagian dalam rantai Markov, distribusi invarian diperoleh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengambil sampel dari distribusi, </font></font><img src="https://habrastorage.org/webt/wb/sl/yf/wbslyf0r1hu5bjl1gbu7pyr3u48.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma MCMC membuat dan mensimulasikan rantai Markov yang distribusi stasionernya</font></font><img src="https://habrastorage.org/webt/wb/sl/yf/wbslyf0r1hu5bjl1gbu7pyr3u48.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; ini berarti bahwa setelah periode "benih" awal, keadaan rantai Markov tersebut didistribusikan sesuai dengan prinsip </font></font><img src="https://habrastorage.org/webt/wb/sl/yf/wbslyf0r1hu5bjl1gbu7pyr3u48.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Karena itu, kita hanya perlu menyelamatkan negara untuk mendapatkan sampel </font></font><img src="https://habrastorage.org/webt/wb/sl/yf/wbslyf0r1hu5bjl1gbu7pyr3u48.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk tujuan pendidikan, marilah kita mempertimbangkan ruang keadaan diskrit dan "waktu" diskrit. Kuantitas kunci yang mencirikan rantai Markov adalah operator transisi yang </font></font><img src="https://habrastorage.org/webt/5q/fu/fx/5qfufxlugigeusphytdet38q580.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunjukkan kemungkinan berada dalam keadaan </font></font><img src="https://habrastorage.org/webt/gs/gz/hz/gsgzhzrwlbmvbexpmq21j8u1dbu.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada suatu waktu </font></font><img src="https://habrastorage.org/webt/cj/ut/o7/cjuto7hmum9a2ki6gyy23a86jb0.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, asalkan rantai tersebut berada dalam keadaan </font></font><img src="https://habrastorage.org/webt/cj/ut/o7/cjuto7hmum9a2ki6gyy23a86jb0.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada suatu waktu </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang hanya untuk bersenang-senang (dan sebagai demonstrasi), mari kita cepat-cepat menenun rantai Markov dengan distribusi stasioner yang unik. Mari kita mulai dengan beberapa impor dan pengaturan untuk grafik:</font></font><br>
<br>
<pre><code class="python hljs">%matplotlib notebook<font></font>
%matplotlib inline<font></font>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<font></font>
plt.rcParams[<span class="hljs-string">'figure.figsize'</span>] = [<span class="hljs-number">10</span>, <span class="hljs-number">6</span>]<font></font>
np.random.seed(<span class="hljs-number">42</span>)</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rantai Markov akan mengelilingi ruang keadaan diskrit yang dibentuk oleh tiga kondisi cuaca: </font></font><br>
<br>
<pre><code class="python hljs">state_space = (<span class="hljs-string">"sunny"</span>, <span class="hljs-string">"cloudy"</span>, <span class="hljs-string">"rainy"</span>)</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam ruang keadaan diskrit, operator transisi hanyalah sebuah matriks. </font><font style="vertical-align: inherit;">Dalam kasus kami, kolom dan baris sesuai dengan cuaca cerah, berawan, dan hujan. </font><font style="vertical-align: inherit;">Mari kita pilih nilai yang relatif masuk akal untuk probabilitas semua transisi:</font></font><br>
<br>
<pre><code class="python hljs">transition_matrix = np.array(((<span class="hljs-number">0.6</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.1</span>),<font></font>
                              (<span class="hljs-number">0.3</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.3</span>),<font></font>
                              (<span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.5</span>)))</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baris menunjukkan status di mana sirkuit saat ini dapat ditemukan, dan kolom menunjukkan status di mana sirkuit dapat pergi. </font><font style="vertical-align: inherit;">Jika kita mengambil langkah "waktu" dari rantai Markov dalam satu jam, maka, asalkan cuaca cerah sekarang, ada kemungkinan 60% bahwa cuaca cerah akan berlanjut selama satu jam berikutnya. </font><font style="vertical-align: inherit;">Ada juga kemungkinan 30% bahwa akan ada cuaca berawan di jam berikutnya, dan 10% kemungkinan itu akan turun hujan segera setelah cuaca cerah. </font><font style="vertical-align: inherit;">Ini juga berarti bahwa nilai di setiap baris bertambah menjadi satu. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita sedikit menggerakkan rantai Markov kami:</font></font><br>
<br>
<pre><code class="python hljs">n_steps = <span class="hljs-number">20000</span>
states = [<span class="hljs-number">0</span>]
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n_steps):<font></font>
    states.append(np.random.choice((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>), p=transition_matrix[states[<span class="hljs-number">-1</span>]]))<font></font>
states = np.array(states)</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita dapat mengamati bagaimana rantai Markov menyatu dengan distribusi stasioner, menghitung probabilitas empiris dari masing-masing negara sebagai fungsi dari panjang rantai:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">despine</span>(<span class="hljs-params">ax, spines=(<span class="hljs-params"><span class="hljs-string">'top'</span>, <span class="hljs-string">'left'</span>, <span class="hljs-string">'right'</span></span>)</span>):</span>
    <span class="hljs-keyword">for</span> spine <span class="hljs-keyword">in</span> spines:<font></font>
        ax.spines[spine].set_visible(<span class="hljs-literal">False</span>)<font></font>
<font></font>
fig, ax = plt.subplots()<font></font>
width = <span class="hljs-number">1000</span>
offsets = range(<span class="hljs-number">1</span>, n_steps, <span class="hljs-number">5</span>)
<span class="hljs-keyword">for</span> i, label <span class="hljs-keyword">in</span> enumerate(state_space):<font></font>
    ax.plot(offsets, [np.sum(states[:offset] == i) / offset <font></font>
            <span class="hljs-keyword">for</span> offset <span class="hljs-keyword">in</span> offsets], label=label)<font></font>
ax.set_xlabel(<span class="hljs-string">"number of steps"</span>)<font></font>
ax.set_ylabel(<span class="hljs-string">"likelihood"</span>)<font></font>
ax.legend(frameon=<span class="hljs-literal">False</span>)<font></font>
despine(ax, (<span class="hljs-string">'top'</span>, <span class="hljs-string">'right'</span>))<font></font>
plt.show()</code></pre><br>
<br>
<img src="https://habrastorage.org/webt/vu/tg/xv/vutgxvc3lq1-sang725fmek1ibm.png"><br>
 <br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HONOR OF ALL MCMC: ALGORITMA METROPOLIS-HASTING</font></font></b> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Tentu saja, semua ini sangat menarik, tetapi kembali ke proses pengambilan sampel dari distribusi probabilitas yang berubah-ubah </font></font><img src="https://habrastorage.org/webt/r2/lm/5b/r2lm5bcuhr-rdtxeg90gjnogcza.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini bisa berupa diskrit, dalam hal ini kita akan terus berbicara tentang matriks transisi </font></font><img src="https://habrastorage.org/webt/sz/nh/au/sznhau4xxghwlc7ma-eixqb9jok.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, atau kontinu, dalam hal ini </font></font><img src="https://habrastorage.org/webt/sz/nh/au/sznhau4xxghwlc7ma-eixqb9jok.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menjadi inti transisi. Selanjutnya, kami akan berbicara tentang distribusi berkelanjutan, tetapi semua konsep yang kami pertimbangkan di sini juga berlaku untuk kasus-kasus terpisah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita dapat merancang inti transisi sedemikian rupa sehingga negara bagian berikutnya sudah dideduksi </font></font><img src="https://habrastorage.org/webt/r2/lm/5b/r2lm5bcuhr-rdtxeg90gjnogcza.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka ini dapat dibatasi, karena rantai Markov kita ... akan langsung diambil sampelnya </font></font><img src="https://habrastorage.org/webt/r2/lm/5b/r2lm5bcuhr-rdtxeg90gjnogcza.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sayangnya, untuk mencapai ini, kita perlu kemampuan untuk mengambil sampel</font></font><img src="https://habrastorage.org/webt/r2/lm/5b/r2lm5bcuhr-rdtxeg90gjnogcza.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apa yang tidak bisa kita lakukan - jika tidak, Anda tidak akan membacanya, kan? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusinya adalah memecah inti transisi </font></font><img src="https://habrastorage.org/webt/7_/os/ja/7_osja2wwom8x6f29sp5ecxnrwc.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menjadi dua bagian: langkah proposal dan langkah penerimaan / penolakan. Distribusi tambahan muncul pada langkah sampel</font></font><img src="https://habrastorage.org/webt/qf/bl/m0/qfblm0cpxxgzun1zq6i9qv_zmfq.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari mana keadaan rantai berikutnya yang mungkin dipilih. Kita tidak hanya dapat membuat pilihan dari distribusi ini, tetapi kita dapat secara sewenang-wenang memilih distribusi itu sendiri. Namun, ketika mendesain, seseorang harus berusaha untuk datang ke konfigurasi seperti itu di mana sampel yang diambil dari distribusi ini akan berkorelasi minimal dengan keadaan saat ini dan pada saat yang sama memiliki peluang bagus untuk melewati fase penerimaan. Langkah menerima / membuang di atas adalah bagian kedua dari inti transisi; pada tahap ini, kesalahan yang terkandung dalam status percobaan dipilih dari dikoreksi </font></font><img src="https://habrastorage.org/webt/dq/wo/ba/dqwoba_pfa-ktifmo9zviggtesm.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Di sini, probabilitas penerimaan yang berhasil dihitung </font></font><img src="https://habrastorage.org/webt/hz/f4/rv/hzf4rviqapfrbg3mphv1na6kao0.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan sampel diambil </font></font><img src="https://habrastorage.org/webt/gs/gz/hz/gsgzhzrwlbmvbexpmq21j8u1dbu.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan probabilitas seperti keadaan berikutnya dalam rantai. Mendapatkan status selanjutnya </font></font><img src="https://habrastorage.org/webt/gs/gz/hz/gsgzhzrwlbmvbexpmq21j8u1dbu.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari</font></font><img src="https://habrastorage.org/webt/5q/fu/fx/5qfufxlugigeusphytdet38q580.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kemudian dilakukan sebagai berikut: pertama, pengadilan </font></font><img src="https://habrastorage.org/webt/gs/gz/hz/gsgzhzrwlbmvbexpmq21j8u1dbu.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diambil dari </font></font><img src="https://habrastorage.org/webt/qf/bl/m0/qfblm0cpxxgzun1zq6i9qv_zmfq.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kemudian diambil sebagai keadaan berikutnya dengan probabilitas </font></font><img src="https://habrastorage.org/webt/hz/f4/rv/hzf4rviqapfrbg3mphv1na6kao0.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau dibuang dengan probabilitas </font></font><img src="https://habrastorage.org/webt/cr/_w/sd/cr_wsdxfgphyie2qbzl977pvfgq.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan dalam kasus terakhir, keadaan saat ini disalin dan digunakan sebagai yang berikutnya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, kita memiliki </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/vg/w-/tyvgw-g_ij7vgrpzoxtt7t3enmw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
kondisi yang cukup untuk rantai Markov memiliki </font></font><img src="https://habrastorage.org/webt/r2/lm/5b/r2lm5bcuhr-rdtxeg90gjnogcza.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai distribusi stasioner adalah sebagai berikut: Inti transisi harus menyerahkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keseimbangan rinci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau sebagai menulis dalam literatur fisik, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reversibilitas mikroskopis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hf/bg/oy/hfbgoyr944ikp5ce_menl-sg0da.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini berarti kemungkinan berada dalam keadaan </font></font><img src="https://habrastorage.org/webt/mt/2y/jr/mt2yjrl958wkwmuhsrpm3h-4uko.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan bergerak dari sana ke sana</font></font><img src="https://habrastorage.org/webt/4t/py/hc/4tpyhcj70euwoys5id2rrqxa_ac.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus sama dengan probabilitas proses kebalikannya, yaitu, mampu </font></font><img src="https://habrastorage.org/webt/4t/py/hc/4tpyhcj70euwoys5id2rrqxa_ac.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan masuk ke keadaan </font></font><img src="https://habrastorage.org/webt/mt/2y/jr/mt2yjrl958wkwmuhsrpm3h-4uko.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kernel transisi dari sebagian besar algoritma MCMC memenuhi kondisi ini. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar inti transisi dua bagian untuk mematuhi keseimbangan terperinci, perlu untuk memilih dengan benar </font></font><img src="https://habrastorage.org/webt/oc/hr/x1/ochrx15_pe9awrsow_fygffjego.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yaitu, untuk memastikan bahwa memungkinkan Anda untuk memperbaiki segala asimetri dalam aliran probabilitas dari / ke </font></font><img src="https://habrastorage.org/webt/4t/py/hc/4tpyhcj70euwoys5id2rrqxa_ac.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><img src="https://habrastorage.org/webt/mt/2y/jr/mt2yjrl958wkwmuhsrpm3h-4uko.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Metropolis-Hastings algoritma menggunakan kriteria diterimanya Metropolis: </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/mh/dm/z2/mhdmz27voos90zkz5_-zexopsdc.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan di sini keajaiban dimulai: </font></font><img src="https://habrastorage.org/webt/r2/lm/5b/r2lm5bcuhr-rdtxeg90gjnogcza.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita hanya tahu konstanta, tetapi itu tidak masalah, karena konstanta yang tidak diketahui ini membatalkan ekspresi untuk</font></font><img src="https://habrastorage.org/webt/oc/hr/x1/ochrx15_pe9awrsow_fygffjego.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! Properti paccpacc inilah yang memastikan pengoperasian algoritma berdasarkan pada algoritma Metropolis-Hastings pada distribusi yang tidak dinormalisasi. Distribusi pembantu simetris c sering digunakan </font></font><img src="https://habrastorage.org/webt/b2/ss/pz/b2sspzujgmdn_uwizxwjjokkg5w.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dalam hal ini algoritma Metropolis-Hastings direduksi menjadi algoritma Metropolis asli (kurang umum) yang dikembangkan pada tahun 1953. Dalam algoritma asli </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hd/3k/vq/hd3kvqg9l2jqltan97_gfmzutsi.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, inti transisi lengkap dari Metropolis-Hastings dapat ditulis sebagai </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tl/ic/rd/tlicrdfto9zvzlooid7cdt4ii-m.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KAMI MELAKSANAKAN ALGORITMA METROPOLIS-HASTING DI PYTHON</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nah, sekarang kita telah menemukan cara kerja algoritma Metropolis-Hastings, mari beralih ke implementasinya. Pertama, kita menetapkan probabilitas logaritmik dari distribusi dari mana kita akan membuat pilihan - tanpa konstanta normalisasi; diasumsikan bahwa kita tidak mengenal mereka. Selanjutnya, kami bekerja dengan distribusi normal standar:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log_prob</span>(<span class="hljs-params">x</span>):</span>
     <span class="hljs-keyword">return</span> <span class="hljs-number">-0.5</span> * np.sum(x ** <span class="hljs-number">2</span>)</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, kami memilih distribusi bantu simetris. </font><font style="vertical-align: inherit;">Secara umum, kinerja algoritma Metropolis-Hastings dapat ditingkatkan jika Anda menyertakan informasi yang sudah Anda ketahui tentang distribusi dari mana Anda ingin membuat pilihan dalam distribusi tambahan. </font><font style="vertical-align: inherit;">Pendekatan yang disederhanakan terlihat seperti ini: kami mengambil keadaan saat ini </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan memilih sampel dari </font></font><img src="https://habrastorage.org/webt/tl/ic/rd/tlicrdfto9zvzlooid7cdt4ii-m.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yaitu, menetapkan ukuran langkah tertentu </font></font><code>Δ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan ke kiri atau kanan dari keadaan kami saat ini tidak lebih dari </font></font><img src="https://habrastorage.org/webt/q1/n2/d_/q1n2d_lbzpbqtvbmbgiha503cmo.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proposal</span>(<span class="hljs-params">x, stepsize</span>):</span>
    <span class="hljs-keyword">return</span> np.random.uniform(low=x - <span class="hljs-number">0.5</span> * stepsize, <font></font>
                             high=x + <span class="hljs-number">0.5</span> * stepsize, <font></font>
                             size=x.shape)</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akhirnya, kami menghitung probabilitas bahwa proposal akan diterima:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">p_acc_MH</span>(<span class="hljs-params">x_new, x_old, log_prob</span>):</span>
    <span class="hljs-keyword">return</span> min(<span class="hljs-number">1</span>, np.exp(log_prob(x_new) - log_prob(x_old)))</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kami menyatukan semua ini ke dalam implementasi yang benar-benar singkat dari tahap pengambilan sampel untuk algoritma Metropolis-Hastings:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sample_MH</span>(<span class="hljs-params">x_old, log_prob, stepsize</span>):</span><font></font>
    x_new = proposal(x_old, stepsize)<font></font>
    <span class="hljs-comment">#   ,     :</span>
    <span class="hljs-comment">#       [0,1]  </span>
    <span class="hljs-comment">#     </span><font></font>
    accept = np.random.random() &lt; p_acc(x_new, x_old, log_prob)<font></font>
    <span class="hljs-keyword">if</span> accept:
        <span class="hljs-keyword">return</span> accept, x_new
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> accept, x_old</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain keadaan berikutnya dalam rantai Markov, </font></font><code>x_new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code>x_old</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kami juga mengembalikan informasi tentang apakah langkah MCMC diadopsi. </font><font style="vertical-align: inherit;">Ini akan memungkinkan kami untuk melacak dinamika pengumpulan sampel. </font><font style="vertical-align: inherit;">Sebagai kesimpulan dari implementasi ini, kami menulis sebuah fungsi yang akan dipanggil berulang </font></font><code>sample_MH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan dengan demikian membangun rantai Markov:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_MH_chain</span>(<span class="hljs-params">init, stepsize, n_total, log_prob</span>):</span><font></font>
<font></font>
    n_accepted = <span class="hljs-number">0</span><font></font>
    chain = [init]<font></font>
<font></font>
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n_total):<font></font>
        accept, state = sample_MH(chain[<span class="hljs-number">-1</span>], log_prob, stepsize)<font></font>
        chain.append(state)<font></font>
        n_accepted += accept<font></font>
    <font></font>
    acceptance_rate = n_accepted / float(n_total)<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> chain, acceptance_rate</code></pre><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MENGUJI ALGORITMA METROPOLIS-HAST KAMI DAN PENELITIAN PERILAKUNYA</font></font></b> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mungkin, sekarang Anda tidak sabar untuk melihat semua ini beraksi. </font><font style="vertical-align: inherit;">Kami akan melakukan ini, kami akan membuat keputusan berdasarkan argumen </font></font><code>stepsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>n_total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="python hljs">chain, acceptance_rate = build_MH_chain(np.array([<span class="hljs-number">2.0</span>]), <span class="hljs-number">3.0</span>, <span class="hljs-number">10000</span>, log_prob)<font></font>
chain = [state <span class="hljs-keyword">for</span> state, <span class="hljs-keyword">in</span> chain]<font></font>
print(<span class="hljs-string">"Acceptance rate: {:.3f}"</span>.format(acceptance_rate))<font></font>
last_states = <span class="hljs-string">", "</span>.join(<span class="hljs-string">"{:.5f}"</span>.format(state) 
                        <span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> chain[<span class="hljs-number">-10</span>:])<font></font>
print(<span class="hljs-string">"Last ten states of chain: "</span> + last_states)<font></font>
Acceptance rate: <span class="hljs-number">0.722</span>
Last ten states of chain: <span class="hljs-number">-0.84962</span>, <span class="hljs-number">-0.84962</span>, <span class="hljs-number">-0.84962</span>, <span class="hljs-number">-0.08692</span>, <span class="hljs-number">0.92728</span>, <span class="hljs-number">-0.46215</span>, <span class="hljs-number">0.08655</span>, <span class="hljs-number">-0.33841</span>, <span class="hljs-number">-0.33841</span>, <span class="hljs-number">-0.33841</span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya baik-baik saja. Jadi, apakah itu berhasil? Kami berhasil mengambil sampel di sekitar 71% kasus, dan kami memiliki rantai negara. Beberapa negara bagian pertama di mana rantai belum konvergen ke distribusi stasionernya harus dibuang. Mari kita periksa apakah kondisi yang kita pilih benar-benar memiliki distribusi normal:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_samples</span>(<span class="hljs-params">chain, log_prob, ax, orientation=<span class="hljs-string">'vertical'</span>, normalize=True,
                 xlims=(<span class="hljs-params"><span class="hljs-number">-5</span>, <span class="hljs-number">5</span></span>), legend=True</span>):</span>
    <span class="hljs-keyword">from</span> scipy.integrate <span class="hljs-keyword">import</span> quad<font></font>
    <font></font>
    ax.hist(chain, bins=<span class="hljs-number">50</span>, density=<span class="hljs-literal">True</span>, label=<span class="hljs-string">"MCMC samples"</span>,<font></font>
           orientation=orientation)<font></font>
    <span class="hljs-comment">#     PDF</span>
    <span class="hljs-keyword">if</span> normalize:<font></font>
        Z, _ = quad(<span class="hljs-keyword">lambda</span> x: np.exp(log_prob(x)), -np.inf, np.inf)
    <span class="hljs-keyword">else</span>:<font></font>
        Z = <span class="hljs-number">1.0</span>
    xses = np.linspace(xlims[<span class="hljs-number">0</span>], xlims[<span class="hljs-number">1</span>], <span class="hljs-number">1000</span>)<font></font>
    yses = [np.exp(log_prob(x)) / Z <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> xses]
    <span class="hljs-keyword">if</span> orientation == <span class="hljs-string">'horizontal'</span>:<font></font>
        (yses, xses) = (xses, yses)<font></font>
    ax.plot(xses, yses, label=<span class="hljs-string">"true distribution"</span>)
    <span class="hljs-keyword">if</span> legend:<font></font>
        ax.legend(frameon=<span class="hljs-literal">False</span>)<font></font>
    <font></font>
fig, ax = plt.subplots()<font></font>
plot_samples(chain[<span class="hljs-number">500</span>:], log_prob, ax)<font></font>
despine(ax)<font></font>
ax.set_yticks(())<font></font>
plt.show()</code></pre><br>
<br>
<img src="https://habrastorage.org/webt/yo/rx/59/yorx59lirnkyju_dymptouaaokw.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tampak hebat! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana dengan parameter </font></font><code>stepsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>n_total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Kami pertama-tama membahas ukuran langkah: menentukan seberapa jauh status percobaan dapat dihapus dari kondisi rangkaian saat ini. Oleh karena itu, ini adalah parameter distribusi tambahan </font></font><code>q</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mengontrol seberapa besar langkah acak yang diambil oleh rantai Markov. Jika ukuran langkah terlalu besar, status percobaan sering berakhir di bagian akhir distribusi, di mana nilai probabilitasnya rendah. Mekanisme pengambilan sampel Metropolis-Hastings membuang sebagian besar langkah-langkah ini, akibatnya tingkat penerimaan dikurangi dan konvergensi melambat secara signifikan. Lihat diri mu sendiri:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sample_and_display</span>(<span class="hljs-params">init_state, stepsize, n_total, n_burnin, log_prob</span>):</span><font></font>
    chain, acceptance_rate = build_MH_chain(init_state, stepsize, n_total, log_prob)<font></font>
    print(<span class="hljs-string">"Acceptance rate: {:.3f}"</span>.format(acceptance_rate))<font></font>
    fig, ax = plt.subplots()<font></font>
    plot_samples([state <span class="hljs-keyword">for</span> state, <span class="hljs-keyword">in</span> chain[n_burnin:]], log_prob, ax)<font></font>
    despine(ax)<font></font>
    ax.set_yticks(())<font></font>
    plt.show()<font></font>
    <font></font>
sample_and_display(np.array([<span class="hljs-number">2.0</span>]), <span class="hljs-number">30</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">500</span>, log_prob)<font></font>
Acceptance rate: <span class="hljs-number">0.116</span></code></pre><br>
<br>
<img src="https://habrastorage.org/webt/0g/4-/-r/0g4--rezypxzaqta-pkugq3gi3w.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak terlalu keren, bukan? Sekarang tampaknya yang terbaik adalah mengatur ukuran langkah kecil. Ternyata ini juga bukan keputusan yang cerdas, karena rantai Markov akan menyelidiki distribusi probabilitas dengan sangat lambat, dan karena itu juga tidak akan menyatu secepat dengan ukuran langkah yang dipilih dengan baik:</font></font><br>
<br>
<pre><code class="python hljs">sample_and_display(np.array([<span class="hljs-number">2.0</span>]), <span class="hljs-number">0.1</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">500</span>, log_prob)<font></font>
Acceptance rate: <span class="hljs-number">0.992</span></code></pre><br>
<br>
<img src="https://habrastorage.org/webt/bf/qh/xi/bfqhxistqravnn7xug43ubowgmu.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terlepas dari bagaimana Anda memilih parameter ukuran langkah, rantai Markov akhirnya menyatu ke distribusi stasioner. Tetapi ini mungkin membutuhkan banyak waktu. Waktu di mana kita akan mensimulasikan rantai Markov </font></font><code>n_total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditentukan </font><font style="vertical-align: inherit;">oleh parameter </font><font style="vertical-align: inherit;">- ini hanya menentukan berapa banyak status rantai Markov (dan, oleh karena itu, sampel yang dipilih) yang akhirnya akan kita miliki. Jika rantai konvergen lambat, maka perlu ditingkatkan </font></font><code>n_total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agar rantai Markov punya waktu untuk "melupakan" keadaan awal. Oleh karena itu, kami akan meninggalkan ukuran langkah kecil dan meningkatkan jumlah sampel dengan meningkatkan parameter </font></font><code>n_total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="python hljs">sample_and_display(np.array([<span class="hljs-number">2.0</span>]), <span class="hljs-number">0.1</span>, <span class="hljs-number">500000</span>, <span class="hljs-number">25000</span>, log_prob)<font></font>
Acceptance rate: <span class="hljs-number">0.990</span></code></pre><br>
<br>
<img src="https://habrastorage.org/webt/fs/ba/27/fsba27vppyvfqnwdnnr0ifdp3w4.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin kita sedang bergerak menuju tujuan ... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KESIMPULAN</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mempertimbangkan semua hal di atas, saya harap sekarang Anda secara intuitif memahami esensi dari algoritma Metropolis-Hastings, parameternya, dan memahami mengapa ini adalah alat yang sangat berguna untuk memilih dari distribusi probabilitas non-standar yang mungkin Anda temui dalam praktik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya sangat menyarankan Anda bereksperimen dengan kode yang diberikan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- sehingga Anda terbiasa dengan perilaku algoritma dalam berbagai keadaan dan memahaminya lebih dalam. </font><font style="vertical-align: inherit;">Coba distribusi tambahan asimetris! </font><font style="vertical-align: inherit;">Apa yang akan terjadi jika Anda tidak mengkonfigurasi kriteria penerimaan dengan benar? </font><font style="vertical-align: inherit;">Apa yang terjadi jika Anda mencoba mengambil sampel dari distribusi bimodal? </font><font style="vertical-align: inherit;">Bisakah Anda menemukan cara untuk secara otomatis menyesuaikan ukuran langkah? </font><font style="vertical-align: inherit;">Apa jebakan di sini? </font><font style="vertical-align: inherit;">Jawab sendiri pertanyaan-pertanyaan ini!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id491258/index.html">IT gadis, dari mana Anda berasal? Mari kita membangun peta</a></li>
<li><a href="../id491260/index.html">Normalisasi teks dalam tugas pengenalan ucapan</a></li>
<li><a href="../id491262/index.html">Mata untuk mata. Masalah Biometrik</a></li>
<li><a href="../id491264/index.html">Pengantar SSD. Bagian 4. Fisik</a></li>
<li><a href="../id491266/index.html">SurfingAttack: kompromi smartphone dengan asisten suara [+ video]</a></li>
<li><a href="../id491272/index.html">Pengembangan situs web dalam pascal (backend)</a></li>
<li><a href="../id491276/index.html">Bagaimana saya menghindari larangan pada API Pesan melalui dokumentasi Vkontakte</a></li>
<li><a href="../id491278/index.html">CLRium # 7: Laporan, Latihan, Mentor</a></li>
<li><a href="../id491280/index.html">Kisah bagaimana saya mengembangkan bahasa pemrograman</a></li>
<li><a href="../id491282/index.html">Cara meningkatkan produktivitas tim (dan mengurangi kesalahan) menggunakan aksi unjuk rasa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>