<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🔧 👋🏾 👨🏼 Intel VシリーズFPGAのPCI Express：インターフェイスの基本とハードウェアコア機能 🥝 🖐🏿 👨🏻‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前書き
 多くの人に馴染みのあるPCI ExpressまたはPCIeインターフェイスは、デジタルテクノロジーが普及し始めたばかりのときでも、FPGAシステム開発者が利用できました。現時点では、ソフトウェアコアが外部の物理レベルのマイクロ回路に接続されているソリューションがありました[ 5 ]。これに...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Intel VシリーズFPGAのPCI Express：インターフェイスの基本とハードウェアコア機能</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496702/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの人に馴染みのあるPCI ExpressまたはPCIeインターフェイスは、デジタルテクノロジーが普及し始めたばかりのときでも、FPGAシステム開発者が利用できました。現時点では、ソフトウェアコアが外部の物理レベルのマイクロ回路に接続されているソリューションがありました[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]。これにより、2.5ギガトランザクション/秒の速度で単一レーンPCIeラインを作成することが可能になりました。さらに、テクノロジーの開発により、インターフェイスの物理層はFPGA自体の内部のPCIeハードウェアブロックに移行しました。可能なチャネルの数は8に、そして新しいマイクロ回路の数は16に増えました。最新の標準に従って、可能なデータ転送速度が増加しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、ロシア語のソースで最新のFPGAのハードウェアコアを操作するための補助資料を見つけることは依然として難しく、PCIeインターフェイス自体に関する情報はあまりありません。ハードウェアPCI Expressコアのガイドは、開発者がすでに標準に精通し、デバイスとパーソナルコンピューター（PC）間のデータ転送の基本を理解していることを意味します。ただし、PCIe標準自体の豊富な情報は、デバイスからPCメモリへ、またはその逆にデータを正常に転送するために実行する必要がある手順をすぐには明らかにしません。より完全な状況を把握するには、情報のかなりの部分をさまざまなソースから少しずつ収集する必要があります。インテルFPGAシステムの開発者にとって、問題も入手可能な資料や記事のほとんどで、ザイリンクスFPGAハードウェアコアの操作について説明しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、FPGAシステム設計者がPCI Expressインターフェイスを使用するために知っておく必要があることについて、著者が説明します。</font><font style="vertical-align: inherit;">は、Avalon-STバージョンのIntelのVシリーズのハードウェアコアPCI Express FPGAを操作する機能を検討します。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCIeレベルとパケットタイプ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PCI Expressはしばしばバスと呼ばれるという事実にもかかわらず、実際には、このインターフェイスはシリアルデュプレックスチャネルのグループによって接続されたデバイスのネットワークです。 PCI Expressネットワーク自体は、ルート（ルート）、エンドポイント（エンドポイント）、ルーター（スイッチ）のいくつかのメインノードで構成されています（図1）。 2つのデバイス間でのみデータを転送するには、ルートとエンドポイントがあれば十分です。最近のPCの場合、ネットワークルートは中央プロセッサのコアとともに1つの基板上にあります。 PCIeルートの場所に関係なく、PCIeルートはシステムメモリに関連付けられています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_c/hp/8v/_chp8va2uvyrgrc_pt0irj-wnrk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図1-PCIeネットワーク</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PCIeデータ転送プロトコルは、トランザクション層、データリンク層、および物理層の3つの層に分かれています。</font><font style="vertical-align: inherit;">インターフェイスデータはパケットの形で送信されます。</font><font style="vertical-align: inherit;">パケットの一般化されたビューを図2に示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pe/eg/sa/peegsa43-ji_l00myvwxe8kt6tg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-PCIeパケットの一般化されたビュー</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
トランザクションレベルでは、パケット（TLP）は少なくともヘッダーで構成されます。</font><font style="vertical-align: inherit;">パッケージのタイプによっては、ヘッダーの後にデータ（パッケージの有用なコンテンツ）が続く場合があります。</font><font style="vertical-align: inherit;">追加のチェックサムをパッケージの最後に追加することもできます。</font><font style="vertical-align: inherit;">トランザクションレベルのパケットには、主に次の種類があります（表1）。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表1-トランザクションレベルのパケットの種類</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いいえ。</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージビュー</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様別パッケージタイプ名</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ読み取り要求 </font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ読み取り要求</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ書き込み要求</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ書き込み要求</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">３</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I / Oスペース読み取り要求</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I / O読み取り要求</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I / Oスペースの書き込み要求</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I / O書き込み要求</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成リクエストの読み取り</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成読み取り要求</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成リクエストの書き込み</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成書き込み要求</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読書反応</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完了</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージ</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージ</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リンク層では、パケットシーケンス番号とリンクチェックサムが各トランザクションレベルのパケットに追加されます。</font><font style="vertical-align: inherit;">データリンク層は、独自のタイプのパケット（DLLP）も形成します。これには（表2）が含まれ</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いいえ。</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージビュー</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様別パッケージタイプ名</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランザクションレベルのパッケージの確認</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLP確認</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランザクションレベルのパッケージ拒否</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLP Nack</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">３</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パワー管理</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パワー管理</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データフロー制御</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロー制御</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、物理層は、IEEE 802.3標準から借用したパケットの先頭と末尾のシンボルでパケットを補完します。</font><font style="vertical-align: inherit;">トランザクションレベルのパケットの場合、シンボルK27.7およびK29.7がそれぞれ使用されます。</font><font style="vertical-align: inherit;">データリンクパケットの場合、シンボルK28.2およびK29.7。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FPGAハードウェアコアを使用する場合、開発者はトランザクションレベルのパケットのみを形成する必要があります。</font><font style="vertical-align: inherit;">チャネルおよび物理層パケットは、カーネルブロックによって形成されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランザクションレベルのパケットルーティング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合計すると、異なるタイプのパケットが3つの方法で送信者から受信者に到着できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アドレスへのルーティング。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IDルーティング</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 間接ルーティング。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルーティング方式とトランザクションレベルパケットのタイプの関係を表3に示します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表3-ルーティング方式とパケットタイプの対応</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">№p</font></font></th>
<th> </th>
<th> </th>
</tr>
<tr>
<td>1</td>
<td>  </td>
<td>       . <br>
    I/O     I/O<br>
</td>
</tr>
<tr>
<td>2</td>
<td>  </td>
<td>     . <br>
    ID.<br>
  <br>
</td>
</tr>
<tr>
<td>3</td>
<td> </td>
<td>    ID</td>
</tr>
</tbody></table></div><br>
<h2>   .        </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各エンドポイントには独自の構成スペースがあり、さまざまな命令およびステータスレジスタが配置されています。その中には、ベースアドレスレジスタまたはBARがあります。エンドポイントを初期化するとき、BIOSまたはオペレーティングシステムはエンドポイントのBARをスキャンして、各エンドポイントに必要なメモリとスペースの量を決定します。次に、アクティブな各BARに、システムメモリの割り当てられた部分の開始アドレスが書き込まれます。その結果、エンドポイントは適切な要求を送信できるアドレスを取得します。通常、エンドポイントでは、割り当てられたメモリ領域に関連付けられたレジスタマップが形成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、各エンドポイント、つまり内部の論理デバイスは、バス番号、デバイス番号、論理デバイス（関数）番号の3つの部分で構成される一意の識別子を取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようにして、システムにはエンドポイントと通信するのに十分な情報があります。ただし、BARでクエリを使用してデータを送信すると、パフォーマンスが低下します。まず、32ビット幅のBARの場合、使用できる要求の長さは1つのダブルワード（DWORD）に制限されます。 64ビットBARの場合、2つのダブルワード。第2に、各要求は中央処理装置の関与で発生します。中央プロセッサの負荷を軽減し、各パッケージのサイズを大きくするには、エンドポイントが独立してシステムメモリとの間でデータを移動する必要があります。これを行うには、エンドポイントは、データを読み書きできるシステムメモリアドレスを知っている必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の場合、エンドポイントとシステムメモリ間の一般的なデータ転送方式は次のように表すことができます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンドポイントドライバは、システムメモリにデータを書き込むためのバッファを割り当てます。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ドライバは、システムメモリ内に一連のアドレスとバッファサイズ（データを書き込むためのバッファ記述子）を形成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> エンドポイントドライバーは、記述子のセットのアドレスをBAR領域に関連付けられたデバイスレジスタに書き込みます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンドポイントドライバは、BAR領域に関連付けられたデータ転送制御レジスタをプログラムします。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> エンドポイントは、システムメモリを読み取る要求を送信して、システムメモリに書き込むための記述子のセットを取得します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> エンドポイントはシステムメモリに書き込み要求を送信し、ストレージバッファを満たします。</font></font></li>
<li>      /   ,    ,        ,  ;</li>
<li>                   PCIe. </li>
</ol><br>
<h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドライバーがエンドポイントレジスタを構成する段階で、BARに関連付けられたアドレススペースのタイプに応じて、エンドポイントはメモリへの書き込み要求（図3）またはI / Oスペースへの書き込み要求を受け取ります。ドライバーがレジスター構成中にレジスターを読み取る場合、エンドポイントは対応する読み取り要求も受け取ります（図4）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/w0/_e/5o/w0_e5oqkd6yfw7uyv9vewkmokw4.png" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3-1 DWのメモリへの書き込み要求の例</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/ca/by/yk/cabyyk_ju4inqbsdevo3b-z3pma.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図4-1 DWのメモリからの読み取り要求の例</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
書き込みまたは読み取り要求とは異なり、I / O要求にはいくつかの制限があります。まず、書き込み要求と読み取り要求の両方で、受信者からの応答が必要です。これにより、I / Oスペースへのリクエストを使用したデータ転送の速度が、理論上のPCIe帯域幅が許容するよりもはるかに低くなるという事実につながります。第2に、I / Oスペース要求のアドレスは32ビットに制限されており、4 GBを超えるシステムメモリのフラグメントへのアクセスは許可されません。第3に、I / Oスペース要求は1ダブルワードを超えることはできず、転送に複数の仮想チャネルを使用できません。これらの理由により、I / Oスペースへの書き込みおよび読み取りの要求は、これ以上考慮されません。それにもかかわらず、メモリの書き込み/読み取りとI / Oスペースのヘッダーの内容は、いくつかのフィールドでのみ異なるため、図3および4に示すパケット構造は、I / Oスペースのリクエストにも適用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンドポイントまたはPCIeルートがメモリまたはI / Oスペースの読み取り要求を受信すると、デバイスは応答を送信する必要があります。リクエストの送信者が一定の時間内に応答を受信しない場合、これは応答の待機中にエラーを引き起こします。何らかの理由でデバイスが要求されたデータを送信できない場合は、エラー応答を生成する必要があります。考えられる理由は次のとおりです。受信者がこのリクエストをサポートしていない（サポートされていないリクエスト）。受信者は構成要求を受け入れる準備ができておらず、後でそれを繰り返すように要求します（構成要求の再試行ステータス）。内部エラーが発生したため、受信者は応答できず、要求を拒否します（完了を中止）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読み取り要求に対する正常な応答とサポートされていない要求によるエラー応答のフォーマットを図5、6に示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gp/pl/y4/gpply4dawc8olvy6iyeipyeraos.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図5-読み取りに対する成功した応答の</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/3s/uw/bv/3suwbvjqkiqpoaogl9ewbnbixjq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例図6-サポートされていない要求に関する応答の例</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
エンドポイントが4 GB以内のメモリ領域にアクセスしている間、パケットヘッダーの形式は図3、4に示されているヘッダーと変わりません。または4 GBを超えるメモリを読み取る場合、宛先アドレスの上位ビットを持つ追加のダブルワードがヘッダーで使用されます（図7）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rr/1o/w6/rr1ow6yxljdhqffy9gguw6v-3os.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図7-128バイトの書き込み要求ヘッダーの例</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
パケットヘッダーフィールドの略称の説明を表4に示します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表4-ヘッダーフィールドの略語のリスト</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いいえ。</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールド指定</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールド名</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任命</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トラフィックカテゴリ-トラフィッククラス</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想チャネルのメンバーシップを定義します</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atr</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の属性</font></font></td>
<td>   : , ,    ID,       ID.</td>
</tr>
<tr>
<td>3</td>
<td>TH</td>
<td>    ‒ TLP Processing Hint</td>
<td>,         [1..0]      .</td>
</tr>
<tr>
<td>4</td>
<td>TD</td>
<td>       ‒ TLP Digest</td>
<td>,          .</td>
</tr>
<tr>
<td>5</td>
<td>EP</td>
<td>    </td>
<td>,      .</td>
</tr>
<tr>
<td>6</td>
<td>AT</td>
<td>  ‒ Address Translation</td>
<td>,     :   ,  ,  </td>
</tr>
<tr>
<td>7</td>
<td>BE</td>
<td>        ‒ Byte Enable</td>
<td>         </td>
</tr>
<tr>
<td>8</td>
<td>PH</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージ処理のヒント-処理のヒント</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージの受信者に、パッケージの使用方法とデータ構造のヒントを提供します</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BCM</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイト数の変化の存在</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パケットのバイト数が変更されたかどうかを示します。</font><font style="vertical-align: inherit;">フラグを設定できるのは、PCI-Xデバイスに直面している送信者のみです</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンドポイントが割り込みを使用してイベントを報告する場合、エンドポイントは適切なパケットを形成する必要もあります。</font><font style="vertical-align: inherit;">全体で、PCIeは3種類の割り込みを使用できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レガシー割り込み（レガシー割り込みまたはINT）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージ形式の割り込み（Message Signaled InterruptsまたはMSI）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張メッセージ割り込み（メッセージ信号割り込み拡張またはMSI-X）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
継承されたINT割り込みは、メッセージ割り込みをサポートしないシステムとの互換性のために使用されます。実際、このタイプの割り込みは、物理的な割り込みラインの動作をシミュレートするメッセージ（メッセージタイプのパケット）です。指定されたイベントが発生すると、エンドポイントは、INT割り込みがアクティブになったというメッセージをPCIeルートに送信し、割り込みハンドラーからのアクションを待ちます。割り込みハンドラが指定されたアクションを実行するまで、INT割り込みはアクティブな状態です。継承された割り込みでは、イベントのソースを特定できません。これにより、割り込みハンドラーは、PCIeツリーのすべてのエンドポイントを順次スキャンして、この割り込みを処理します。割り込みが処理されると、エンドポイントはそのことを示すメッセージを送信しますINT割り込みがより非アクティブであること。 FPGAハードウェアコアは、ユーザーロジックからの信号に基づいて、INT割り込みに必要なメッセージを個別に生成するため、パケット構造は考慮されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージ割り込みとその拡張バージョンは、PCIeの主要な必須タイプの割り込みです。どちらのタイプの割り込みも、実際には、システムメモリに1ダブルワードの長さで書き込む要求です。通常のリクエストとの違いは、システム構成の段階でデバイスごとに記録アドレスとパッケージ内容が割り当てられることです。この場合、中央プロセッサ内のローカルの高度なプログラマブル割り込みコントローラー（LAPIC）が宛先になります。このタイプの割り込みを使用する場合、PCIeツリー内のすべてのデバイスを順番にポーリングする必要はありません。さらに、システムがデバイスに複数の割り込みベクトルの使用を許可している場合、各ベクトルを独自のイベントに関連付けることができます。これにより、割り込み処理のプロセッサ時間が短縮され、システム全体のパフォーマンスが向上します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSI割り込みにより、最大32の個別のベクトルを形成できます。正確な数は、エンドポイントの機能によって異なります。この場合、システムはベクトルの一部のみの使用を許可する場合があります。構成段階で、システムは割り込みアドレスと初期データを書き込み、エンドポイントの構成スペースの特殊レジスターに書き込みます。アクティブな割り込みはすべて同じアドレスを使用します。ただし、ベクトルごとに、エンドポイントは初期データのビットを変更します。たとえば、エンドポイントが最大4つの割り込みベクトルをサポートするとし、システムでは4つのベクトルすべてが許可され、書き込み用の初期データは0x4970です。次に、最初のベクトルを形成するために、エンドポイントは初期データを変更せずに渡します。 2番目のベクトルの場合、デバイスは最初のビットを変更し、数値0x4971を送信します。3番目と4番目のベクトルの場合、デバイスはそれぞれ数値0x4972と0x4973を送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FPGAハードウェアコアは、ユーザーロジックからの信号によってMSI割り込みを使用して独立してパケットを形成します。ただし、割り込みを送信するようにカーネルに命令する前に、ユーザーロジックは、必要なベクターのパケットの内容を特別なカーネルインターフェイスに提供する必要もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSI-X割り込みにより、最大2048の個別ベクトルを形成できます。構成スペースの対応するレジスターのエンドポイントは、どちらのBARアドレススペースと、ベースアドレスからのオフセットによって、割り込みテーブル（図8）と保留中の割り込みフラグのテーブル（保留ビットアレイ-PBA、図9）が配置されていること、および両方のサイズを示します。テーブル。システムは、割り込みテーブルの各行に書き込むための個別のアドレスとデータを書き込み、さらに、ベクター制御フィールドの最初のビットを介して特定のベクターの使用を許可または禁止します。特定のイベントについて、エンドポイントは保留中の割り込みのフラグテーブルにフラグを設定します。 Vector Controlフィールドでこの割り込みにマスクが設定されていない場合、エンドポイントは、パケットの指定された内容を使用して、割り込みテーブルからアドレスに割り込みを送信します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zl/6q/el/zl6qelezf6aixg5qjw-rbeotwkc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図8-MSI-X割り込みベクトルの</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/q8/ms/as/q8msasscf-ytecdpefn-ohdjc1q.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表図9-保留中の割り込みのフラグの表</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
FPGAハードウェアコアには、MSI-X割り込み専用のインターフェイスがありません。</font><font style="vertical-align: inherit;">開発者自身がユーザーロジックの割り込みテーブルと保留中の割り込みのフラグのテーブルを作成する必要があります。</font><font style="vertical-align: inherit;">割り込みパッケージも完全にユーザーが生成し、他のタイプのパッケージとともに一般的なカーネルインターフェイスを介して送信されます。</font><font style="vertical-align: inherit;">この場合のパケットフォーマットは、すでに上で述べたように、1ダブルワード長のシステムメモリへの書き込み要求に対応しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avalon-STバージョンのIntelのハードウェアコアPCI Express FPGA Vシリーズの機能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異なるメーカーのPCI Express FPGAのハードウェアコアが同様の機能を実装しているという事実にもかかわらず、個々のコアインターフェイスまたはそれらの動作の順序は異なる場合があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インテルVシリーズPCI Express FPGAハードウェアコアには、Avalon-MMとAvalon-STの2つのバージョンがあります。後者の場合、開発者はより多くの努力を必要としますが、最大の帯域幅を得ることができます。このため、Avalon-MMインターフェースを備えたカーネルは考慮されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avalon-STインターフェースを備えたPCI Expressコアのドキュメントには、カーネルパラメーター、入力信号および出力信号が詳細に記載されています。ただし、カーネルには、開発者が注意すべきいくつかの機能があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の機能グループは、PCIe要件に従ってFPGAを100ミリ秒以内に構成できるようにする方法に関するものです。 FPPタイプの並列ロードに加えて、開発者はプロトコル経由の構成（CvP）やカーネルの自律モード（自律モード）などのメソッドを提供されます。開発者は、プロトコルまたはスタンドアロンカーネルモードによる構成が、選択したPCIe速度（「レーンレート」パラメーター）でサポートされていることを確認する必要があります。プロトコルを介した構成の場合、関連情報はカーネルのドキュメントに記載されています。オフラインモードの場合、そのような情報はないため、プロジェクトをコンパイルする必要があります。スタンドアロンカーネルモードが現在のカーネル速度でサポートされていない場合、Quartusは対応するエラーを生成します（図10）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xj/hy/ok/xjhyokbx1mvolf2dweiawoytyzk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図10-オフラインモード用のPCIeカーネルのコンパイルエラー</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
開発者がプロ​​トコルを介して構成を使用する場合は、PCIeコネクタが接続されているFPGAコアにも注意を払う必要があります。これは、開発者が完成したボードではなく自分のデバイスを使用する場合に特に当てはまります。複数のPCIeハードウェアコアを備えたFPGAでは、1つのコアのみでCvPを有効にできます。 CvPをサポートするコアの場所は、FPGAのドキュメントに記載されています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の機能グループは、Avalon-STデータ転送インターフェース自体に関連しています。ユーザーロジックとカーネルの間でトランザクションレベルのパケットを転送するために使用されるのは、このインターフェイスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
受信側のカーネルには、ユーザーが受信パケットの受信を一時停止できるようにする2つの信号があります。rx_st_mask信号とrx_st_ready信号です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者は、rx_st_ready信号を使用して、すべてのタイプのパケットの出力を一時停止できます。ただし、この信号をアクティブにすると、カーネルは動作周波数の2クロックサイクル後にパケットの出力を停止します。したがって、信号のアクティブ化中、ユーザーロジックは追加のデータ量を受信する準備ができている必要があります。たとえば、開発者がFIFOの形式でバッファを使用する場合、バッファオーバーフローを回避する必要があります。そうしないと、パッケージの内容の一部が失われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者は、信号「rx_st_mask」を使用して、応答を送信する必要があるリクエストの発行を一時停止します。また、この信号はパケット出力をすぐに停止しません。ドキュメントによると、シグナルをアクティブにした後、カーネルは最大10個のリクエストを発行できます。ユーザーロジックが「rx_st_mask」をアクティブにし、受信したパケットを処理するのに十分なスペースがバッファーにない場合、これは「rx_st_ready」信号もアクティブにする可能性があります。この状況では、ユーザーロジックは内部ハードウェアカーネルバッファーからのパケットの読み取りを停止します。これは、ハードウェアカーネルバッファーをオーバーランさせるだけでなく、パケットの順序の要件にも違反します。デバイスは、応答を必要としない要求をスキップして、応答を読み取る必要があります。そうしないと、データチャネルがしっかりとブロックされます。このため、開発者は追加のバッファーを使用して応答付きのリクエストを処理し、ロジックが優先度の高いパケットをブロックしないようにする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
送信側では、tx_st_validおよびtx_st_ready信号が問題を引き起こす可能性があります。 tx_st_ready信号がアクティブの場合、ユーザーロジックが発信パケットの途中でtx_st_validをリセットすることは禁止されています。つまり、転送中に、開発者はパッケージの内容全体を提供する必要があります。データソースがカーネルインターフェイスより遅い場合、ユーザーロジックはパッケージの開始前に必要な量のデータを蓄積する必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
受信側と送信側の両方で、開発者はヘッダーのバイトオーダーとパケットの内容、およびデータの配置に注意を払う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハードウェアコアのAvalon-STパケットでは、PCIeパケットのヘッダー内の各ダブルワード内で、バイトが下位から上位に続きます。パッケージの内容-最も古いものから最も新しいものまで。開発者は、エンドポイントからルートにデータを正常に転送するために、発信パケットで同様の順序を使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハードウェアコアのAvalon-STインターフェイスは、データを64ビットの倍数に揃えます。 Avalon-STインターフェースの幅、トランザクションレベルのパケットヘッダーの長さとパケットアドレスに応じて、カーネルはパケットヘッダーとその内容の間に空のダブルワードを追加する場合があります。次に、データを送信するとき、ユーザーロジックはカーネルと同様に、事前に空のダブルワードを追加する必要があります。この空のダブルワードは、パケット長では考慮されず、ハードウェアカーネルが正しく動作するためにのみ必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の機能は、着信読み取り応答に関連しています。カーネルの説明では、識別子が発信要求と一致しない着信応答を見逃さないようになっています。同時に、ユーザーロジックは応答の待機時間に従う必要があります。待機時間を超えた場合、ユーザーロジックはフラグ「cpl_err [0]」または「cpl_err [1]」を立てる必要があります。エンドポイントが複数の読み取りリクエストを送信したときにフィルタリングがどのように機能するかは、ドキュメントから明確ではありません。ユーザーロジックは、要求の1つでタイムアウトになったことをカーネルに通知するだけで、この要求の識別子をカーネルに渡すことはできません。タイムアウトが発生したリクエストに対して、カーネルがユーザー側の応答を送信する可能性があります。したがって、開発者は着信応答に対して独自のフィルターを作成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、開発者は、発信パッケージに利用可能なローンに関する情報を使用することを強くお勧めします。</font><font style="vertical-align: inherit;">カーネルがローンをチェックし、十分なローンがない場合はパッケージをブロックするため、コアのドキュメントにはこれは不要であると記載されています。</font><font style="vertical-align: inherit;">ただし、すべてのタイプのパッケージが単一のインターフェースを介してカーネルに到着します。</font><font style="vertical-align: inherit;">カーネルパケットバッファーがオーバーフローすると、カーネルはtx_st_ready信号をゼロに下げます。</font><font style="vertical-align: inherit;">tx_st_ready信号が1に設定されるまで、ユーザーロジックは原則としてパケットを送信できません。</font><font style="vertical-align: inherit;">利用可能なローンの数は、パートナーデバイスからのパッケージによって更新されます。</font><font style="vertical-align: inherit;">ユーザーのロジックが書き込みだけでなく読み取りも頻繁に行うと、カーネルが制限カウンターを更新する速度が低下します。</font><font style="vertical-align: inherit;">最終的に、システム全体のパフォーマンスが低下します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、PCI Expressを介したデータ転送の一般的な原理、メインデータパケットのフォーマットについて説明しました。</font><font style="vertical-align: inherit;">それにもかかわらず、作成者は仮想チャネルなどのインターフェイスコンポーネントを省略し、読み取る着信応答の量を制御し、パケットの順序は厳密ではありません。</font><font style="vertical-align: inherit;">これらのトピックは、[外来源の数で詳細に説明されている</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事には、インターフェイスコントローラーの作業中に著者が遭遇したIntel Express VシリーズFPGA FPGAハードウェアコアの機能も含まれています。</font><font style="vertical-align: inherit;">この経験は他の開発者にとって役立つかもしれません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用されているソースのリスト</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1秒あたり数ギガバイトのデータ伝送のためのPCIe DMAアーキテクチャ/ L. Rota、M。Caselleなど </font><font style="vertical-align: inherit;">al。</font><font style="vertical-align: inherit;">//核科学に関するIEEEトランザクション、VOL。</font><font style="vertical-align: inherit;">62、いいえ。</font><font style="vertical-align: inherit;">2015年6月3日。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">An Efficient and Flexible Host-FPGA PCIe Communication Library / Jian Gong, Tao Wang, Jiahua Chen et. al. // 2014 24th International Conference on Field Programmable Logic and Applications.</a></li>
<li>Design and Implementation of a High-Speed Data Acquisition Card Based on PCIe Bus / Li Mu-guo, Huang Ying, Liu Yu-zhi // 《测控技术》2013年第32卷第7期。</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">Down to the TLP: How PCI express devices talk (Part I) / Eli Billauer</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">Low-Cost FPGA Solution for PCI Express Implementation / Intel Corporation.</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">Managing Receive-Buffer Space for Inbound Completions / Xilinx // Virtex-7 FPGA Gen3 Integrated Block for PCI Express v4.3, Appendix B</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">PCIe Completion Timeout / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">PCIe packet in cyclone VI GX / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">PCIe simple transaction / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">PCIe w/ Avalon ST: Equivalent of ko_cpl_spc_vc0? / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">Point me in the right Direction – PCIe / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCIE /アルテラフォーラムでのリクエストタイムアウト</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非協調受信機検証プラットフォームのPCIeに基づく高速インターフェース設計/ Li Xiao-ning、Yao Yuan-chengおよびQ​​in Ming-wei // 2016年機械、制御、電気、メカトロニクス、情報およびコンピューターに関する国際会議</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCI Express Base Specification Revision 3.0 / PCI-SIG</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCIeソリューション向けのStratix V Avalon-STインターフェイス/ Intel Corporation </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCIeソリューション用のCyclone V Avalon-STインターフェイス/ Intel Corporation</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja496686/index.html">MITER ATT＆CKによるトラフィック分析システムによるハッカーの戦術の検出方法、パート4</a></li>
<li><a href="../ja496690/index.html">コロナウイルス制御技術</a></li>
<li><a href="../ja496692/index.html">＃06-そして、バイト全体では十分ではありません... | 平らな天気</a></li>
<li><a href="../ja496696/index.html">＃07-そして、バイト全体では十分ではありません... | オンラインでの改訂</a></li>
<li><a href="../ja496700/index.html">ミニゲームで本格的なMinecraftゲームサーバーを開発します。パート2.サーバーロビー用のマップのインストール</a></li>
<li><a href="../ja496704/index.html">Saturn-5ロケットのPCB-説明付きのリバースエンジニアリング</a></li>
<li><a href="../ja496706/index.html">週末の読書：オーディオ形式の歴史-カセットの時代と音声合成技術の開発</a></li>
<li><a href="../ja496708/index.html">スペースガン、スチームロケット、オービタルミラー</a></li>
<li><a href="../ja496710/index.html">コンピュータ情報：シンプルで高速</a></li>
<li><a href="../ja496712/index.html">ペンテストに一度、または泌尿器科医とRoskomnadzorの助けを借りてすべてを壊す方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>