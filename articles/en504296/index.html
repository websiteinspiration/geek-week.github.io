<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📸 💪 🚣🏾 Generating Random Branches in Python 🖕🏾 👽 👨‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recalling Dawkins, the main idea can be expressed as follows: if you keep the tornado over the trash for a long time , then a Boeing 747 can assemble....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Generating Random Branches in Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504296/"><img src="https://habrastorage.org/webt/fy/vd/nr/fyvdnr83rzvq1tow9chyg7e0kry.gif" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recalling Dawkins, the main idea can be expressed as follows: if you </font><font style="vertical-align: inherit;">keep the tornado over the trash for a </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">long time</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then a Boeing 747 can assemble. The emergence of a structure from chaos by a durik: sorting and recombining everything in a row, from all the meaningless and disordered processes, one can see quite meaningful and ordered ones. If such processes are somehow fixed and repeated, then the system, which yesterday was a Brownian motion, today begins to look as if its behavior was set up by an invisible hand, and that it is making some actions that are meaningful from our point of view. At the same time, there is no hand at all. She set herself up.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To make sure of this again, I strive to write some kind of digital life, which, out of chaos and without unnecessary instructions from a person, will be able to randomly generate logic for itself and exist on it in its natural habitat - the operating system. Yes, in this, probably, there is a difference from many programs from the “Artificial Life” direction, which “live” in corrals, produce “predators” and “herbivores,” and co-exist in artificial fields with “food” and each other. None of these programs interact with system objects (processes, files, etc.), which means that the code does not really live. In addition, this code one way or another still performs some kind of task that a person needs and is very limited in scope because of this.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To implement code with a large degree of freedom of action in the operating system, which at the same time would not be just a chaotic set of executing instructions, a model appeared that consists of 3 modules. </font></font><br>
<a name="habracut"></a><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The module of random generation of the main executable code</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Random Education Module</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The "computer vision" module of OS objects</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article, we will talk about the first module, which so far is only the generation of random branching, i.e. constructions like "if-elif-else". Why branching? Because, by and large, the life of any living organism consists of conditioned reactions: everything we do is a response to perceived information. Cells divide if certain conditions occur, the victim tries to escape if he sees a stronger predator, and if he is weaker, he can try to attack him, cockroaches scatter if the light turns on, a person goes to eat, if he is hungry, etc. etc. - this row is endless. There are no independent, separate actions that are not conditioned by anything. Consequently, the behavior of living organisms in particular is described as a reaction to the condition: IF [something] THEN [something]. We are trying to generate this behavior.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why randomly? In order to leave the code the maximum opportunity to act independently and move the person (programmer) away from this process as far as possible (ideally completely exclude). The latter is the most difficult for the programmer, because standard programming, to which everyone is accustomed, resembles a hard training of animals, which must perform exactly what the programmer indicates, exactly as he indicates when he indicates. Here the situation is the opposite: the final generated code must act so that it is as unpredictable for the creator of its generator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before we move on to the diagrams and code of the generator, it is necessary to dwell on the decision-making function, which is used as a conductor, allowing one or the other part of the code to be executed. I wrote about her earlier</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . I was then prompted that I described the idea of ​​Reinforcement Learning and the game of John Conway, entitled "Life." It may well be that I have nothing against using what has already been developed or openly. In the end, everything new is a synthesis of the already known, and I myself admitted that I adopted the idea of ​​prioritizing flows, which is used in Windows. Here she is very suitable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Currently, the mentioned function has been slightly transformed:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_solution</span>(<span class="hljs-params">p_random, p_deter</span>):</span>                       
    deter_flag = <span class="hljs-number">0</span>
    random_flag = <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> p_random &gt;= random.random():<font></font>
            p_random-=<span class="hljs-number">0.01</span>                                  <span class="hljs-comment">#  </span>
            p_deter+=<span class="hljs-number">0.01</span>
            random_flag = <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> p_deter &gt;= random.random():<font></font>
            p_deter-=<span class="hljs-number">0.01</span>                                   <span class="hljs-comment">#  </span>
            p_random+=<span class="hljs-number">0.01</span>
            deter_flag = <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> random_flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> deter_flag == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span>(p_random, p_deter, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">elif</span> deter_flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> random_flag == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span>(p_random, p_deter, <span class="hljs-number">-1</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> (p_random, p_deter,<span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the input, it takes 2 probabilities (by default at the start they are both equal to 0.5), after which it checks their operation one by one. The triggered probability decreases itself by 1% and at the same time increases the other by 1%. Therefore, each time the probability works, it decreases, and the other increases. As a result, no probability gets too much advantage over another, and they self-balance, forming a normal distribution centered at 0.5 and with a working neighborhood of no more than + -10%, which distinguishes this function from the standard random, where the probability in our case It would always be equal to 0.5 and would not depend on previous calculations.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figuratively speaking, it is a probability pendulum with a small amplitude. If the first probability worked and the second didn’t work, it returns 1, otherwise -1 is returned, and if both worked or didn’t work, 0. Thus, the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">for 2 incoming probabilities returns one of 3 possible actions, giving a balanced forked solution with 3 possible continuation options. In the future, this function is likely to be universal, and will be able to take an indefinite number of probabilities, because the variation at the forks can be more than 3, but in the case of the if-elif-else generator, three options for continuation are quite enough.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It should also be noted here that in the code there are different, so to say, typical forks. For example, as will be seen below, in the main function of the generator there is a fork in which there is a choice of a scheme for constructing a branch, of which there are only 3, but other cases are also present in the code: insert an action block or start a recursion, how many action lines to generate, how complex it should be line with the condition, put or or and, elif or else. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I believe that the probabilistic pendulum, which we talked about above, should be set for each type of action: then the fork is balanced only on the basis of what happened earlier on this fork, and not in some other parts of the code. Those. when choosing the general branching structure, we have our own pair of probabilities, and inside, when its elements are built, another.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, you can balance all actions with one pair, but then the probability at each fork will be very difficult and will depend on all previous actions at other junctions. The randomness of such a design will be even higher, but for now I personally am inclined to the first scheme, because I like the design where other small ones swing within the framework of one large swinging pendulum, i.e. smaller balances are born in one big balance. Plus, in the second scheme, randomness is also more than sufficient. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When writing the branch generator, it was necessary to make not only workable code that produces error-free generations, but also such code that </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">could</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generate the maximum possible constructs of if-elif-else, but there are not 2 or 3 of such possible options. Consider, for example, the following possible schemes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qu/oj/i3/quoji3ppc2arksk-xwafu3lfiqm.jpeg" width="350" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By the icon </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[..]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the schemes I mean a set of expressions for a condition or a block of random actions. The most elementary scheme is 1, where the condition simply goes, and after it the action block. 2a and 2b are if variations with one elif or one else. In option 2c, if already comes in combination with several elif without else. And finally, in option 2d, the most general scheme is presented, where if contains several elif and 1 else.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything would be simple if it were not for the need to build unlimited branches. After each if, elif or else, recursion can be called, which in turn can also recurse further and produce new elif-else blocks to the “right”. Let's look at the scheme of possible options. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y0/0z/vr/y00zvr1zkcwxuceu28olrpfabpo.jpeg" width="400" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embodiments 2e and 2f show simple special cases of such recursive branching when recursion is called either after a single elif or after a single else. Option 2g describes the most complex and general case of such recursion, when after each elif there can be an action block + recursion (or immediately recursion), and the same thing can happen after else. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are still variations when recursion occurs immediately after if or after if and an action block.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/dv/ye/hxdvyem6hl667rv0v-e-mjhpiv8.jpeg" width="400" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is seen in options 3a and 3b. Option 3c shows such a scheme in the most general form. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is not to say that the above schemes cover all possible options for constructing branches, however, even in this form, the final code easily creates branches in 150 lines, going “to the right” for 10-15 steps. In any case, complicating the scheme if necessary is not difficult. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can look at an example of </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> such generation to make sure that the branches can be very diverse.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zs/8j/gd/zs8jgd-5efc6vzg0thgjztgfyq0.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You do not need to pay attention to the composition of conditional expressions and action blocks - for visual simplicity, they are generated from only combinations of two variables, 3 expressions and a small number of arithmetic and logical signs. A discussion of the real “meat” for recombination is beyond the scope of this article (this will be discussed in the discussion of 3 modules). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before proceeding to a direct examination of the generator code, it is necessary to remember that the generated blocks must be shifted horizontally to the right, if it is elif, else, if recursion or action blocks, and also “go back” to the left after the branch completes. Moreover, given that Python is very picky about horizontal indents, it is desirable to make the step the same (in our case, the step is 3).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following diagram illustrates how displacements are shifted. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mu/p8/ue/mup8uegwtzj-fydzcdcsswbsutw.jpeg" width="500" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most important thing here is that the displacements with the deepening of the branches always shift to the right. However, if we have, for example, an elif-else block in which there are several elif or a single elif-else pair, then there is a need to “return” the carriage that floated to the right, so that the next elif (or else) begins with same offsets as the previous one in the block. To do this, you must save the original offset ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wall_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and after the end of branch generation (for example, full branching of one elif), restore it. This ensures that the elif, else elements in the block are “on top of each other” evenly. Moreover, each new block has its own displacement. The same trick provides harmony in the overall if-elif-else construct (including recursions). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's move on to the code. The code with a total volume of about 200 lines consists of 8 functions, one of which we examined above. Due to recursiveness and a large number of parameters passed to functions, it can be poorly readable in places. To begin with, I will cite the very “meat” that is used to generate conditional expressions and action blocks.</font></font><br>
<br>
<pre><code class="python hljs">var_list = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]<font></font>
exp_list = [<span class="hljs-string">'a+b'</span>,<span class="hljs-string">'b-a'</span>, <span class="hljs-string">'b//a'</span>]<font></font>
sign = [<span class="hljs-string">'+'</span>,<span class="hljs-string">'-'</span>,<span class="hljs-string">'/'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'//'</span>]<font></font>
sign2 = [<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'=='</span>,<span class="hljs-string">'&gt;='</span>,<span class="hljs-string">'&lt;='</span>,<span class="hljs-string">'!='</span>]<font></font>
a = <span class="hljs-number">3</span>
b = <span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, two variables are used: a and b ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), which are initialized, 3 arithmetic expressions ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exp_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), and also two sheets with signs ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sign, sign2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). As mentioned earlier, the composition of the resulting expressions does not matter now and is not considered in this article - they are needed mainly to illustrate the code. One more peculiarity should be noted: in the generation of the elif-else block, you need to track the appearance of the else and stop the generation, otherwise else may appear before elif, which naturally will cause an error. The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flag is used for this purpose </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We begin our consideration with the main generation function.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">if_gen</span>(<span class="hljs-params">exp_list, var_list, if_str, offset_koeff, fin_else_flag, prob_list</span>):</span>             <font></font>
    choice_list = [exp_list, var_list]<font></font>
    base_offset = <span class="hljs-string">' '</span>
    <span class="hljs-comment">#   </span>
    prob_list[<span class="hljs-number">0</span>],prob_list[<span class="hljs-number">1</span>],sol = make_solution(prob_list[<span class="hljs-number">0</span>],prob_list[<span class="hljs-number">1</span>])       
    <span class="hljs-comment"># if +   (1   )        </span>
    <span class="hljs-keyword">if</span> sol == <span class="hljs-number">0</span>: 
        <span class="hljs-comment">#     +3                                                                   </span>
        action_str = action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)                 
        <span class="hljs-keyword">return</span>(base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> + action_str, offset_koeff, fin_else_flag, prob_list) 
    <span class="hljs-comment"># if + elif/else (2   )           </span>
    <span class="hljs-keyword">elif</span> sol == <span class="hljs-number">-1</span>:                                                                         <font></font>
        if_str= base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> + action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list) <span class="hljs-comment"># if [..]:</span>
        <span class="hljs-comment">#  elif/else</span>
        prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol2=make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])             
        <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:<font></font>
            ee_string=<span class="hljs-string">'elif'</span>
        <span class="hljs-keyword">else</span>:<font></font>
             ee_string=<span class="hljs-string">'else'</span>
        <span class="hljs-comment">#   elif/else</span><font></font>
        if_str, offset_koeff, fin_else_flag, prob_list = elif_else_block(ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
        <span class="hljs-keyword">return</span>(if_str, offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-comment"># if + if() (3   )</span>
    <span class="hljs-keyword">else</span>:                                                                                   <font></font>
            if_str= base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> <span class="hljs-comment"># if [..]:</span>
            <span class="hljs-comment">#  if/if+ </span>
            prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>],sol = make_solution(prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>])        
            <span class="hljs-keyword">if</span> sol==<span class="hljs-number">0</span>:
                <span class="hljs-comment">#     +3</span>
                if_str+=action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)      
            <span class="hljs-comment">#          </span><font></font>
            wall_offset = offset_koeff                                                      <font></font>
            if_rek, offset_koeff, fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, offset_koeff+<span class="hljs-number">3</span>, fin_else_flag, prob_list) <span class="hljs-comment">#  if+if</span>
            <span class="hljs-comment">#    </span><font></font>
            if_str+=if_rek   <font></font>
            <span class="hljs-comment">#   elif-else/                                                                </span>
            prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>],sol2=make_solution(prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>])         
            <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:<font></font>
                prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol3=make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
                <span class="hljs-keyword">if</span> sol3!=<span class="hljs-number">0</span>:<font></font>
                    ee_string=<span class="hljs-string">'elif'</span>
                <span class="hljs-keyword">else</span>:<font></font>
                    ee_string=<span class="hljs-string">'else'</span><font></font>
                if_str, offset_koeff, fin_else_flag, prob_list = elif_else_block(ee_string, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)  <font></font>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment">#     +3</span>
                if_str+=action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)              
            <span class="hljs-keyword">return</span>(if_str, offset_koeff,fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to lists with “meat” for generation (exp_list, var_list), the function also </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accepts if_str</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - this is the line where the generated code is collected in turn. It is accepted here because the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><b><font style="vertical-align: inherit;">itself</font></b><font style="vertical-align: inherit;"> can be called recursively, and it would be advisable not to lose the piece of code generated earlier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offset_koeff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parameter </font><font style="vertical-align: inherit;">is the offset coefficient, which is a factor for a line with one space ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) and, accordingly, it is responsible for the horizontal displacements of the code blocks. </font><font style="vertical-align: inherit;">We talked </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
about </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> above, here it is simply passed to a function that is responsible for generating if + elif / else (see below). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, there is another parameter -</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is a sheet with 10 probabilities (5 pairs of probabilities)</font></font><pre><code class="python hljs">prob_list = [<span class="hljs-number">0.5</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)] </code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and is used by the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">as we discussed above: this or that pair of probabilities from it corresponding to the type of fork is passed to it (for example, the main structural fork uses the first 2 probabilities in the sheet: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list [0]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list [1]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). The results of the probability changes in this sheet, as an example, can be seen in the following figure. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tw/_o/qc/tw_oqckdotydpm1m5djcmdc3rgw.jpeg" width="550" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The probabilities in this list change from generation to generation, if during the next generation the corresponding piece of code gets executed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the function itself, the nested choice_list is initialized at the beginning - it is needed for convenient random generation of expressions from “meat”, and the base offset </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base_offset = ''</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in one space.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After that comes the main fork, which, through the make_solution function, gets the solution into the sol variable. Sol takes one of three values ​​(0, -1.1) and determines, therefore, according to what scheme the structure will be built. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first option implements the simplest option if + [..]. The answer is formed as a string with the current offset (it is not necessarily equal to 0!), An “if” string, a random condition that is generated by the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_sub</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">(which will be discussed later), carriage return, and generation of an action block using the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">action_str</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">(see below) . As a result, we get something like:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a+b)==(b)):<font></font>
   b=b<font></font>
   a=b-a<font></font>
   a=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second option is responsible for generating this type: if [..] + elif / else-block (option 2 in the schemes). </font><font style="vertical-align: inherit;">First, an if + [..] line is formed there, then an elif / else fork occurs, which decides whether the elif-else block will be generated, just if-elif or if-else (e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lif_else_block</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">- see below). </font><font style="vertical-align: inherit;">Results may vary. </font><font style="vertical-align: inherit;">For instance:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a+b)==(a)):<font></font>
   b=a+b<font></font>
<span class="hljs-keyword">elif</span> ((b//a)==(a)):
   <span class="hljs-literal">None</span>
<span class="hljs-keyword">elif</span> ((a+b)&lt;=(a)):<font></font>
   a=b//a<font></font>
<span class="hljs-keyword">else</span>:
   <span class="hljs-keyword">if</span> ((b)&lt;=(a)):<font></font>
      a=b-a<font></font>
      b=a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)==(b-a)):<font></font>
   b=b-a<font></font>
   b=b<font></font>
   a=b<font></font>
   a=b-a<font></font>
<span class="hljs-keyword">elif</span> ((b)&gt;(b-a))<span class="hljs-keyword">and</span>((a)&lt;(b-a)):
   <span class="hljs-keyword">if</span> ((b//a)&lt;(a)):<font></font>
      b=b-a<font></font>
   <span class="hljs-keyword">elif</span> ((a+b)&lt;(b-a))<span class="hljs-keyword">and</span>((b)&lt;(a+b))<span class="hljs-keyword">or</span>((a+b)==(a+b)):<font></font>
      b=b<font></font>
      a=b-a<font></font>
   <span class="hljs-keyword">elif</span> ((a)&gt;(b-a)):
      <span class="hljs-literal">None</span></code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b)&lt;=(b-a))<span class="hljs-keyword">or</span>((a+b)&gt;=(b)):<font></font>
   a=a<font></font>
   b=b<font></font>
<span class="hljs-keyword">elif</span> ((b)&lt;=(b)):
   <span class="hljs-keyword">if</span> ((a)&gt;=(b)):<font></font>
      a=a+b<font></font>
      a=b<font></font>
<span class="hljs-keyword">elif</span> ((b)&gt;=(a)):<font></font>
   a=b-a<font></font>
   a=a<font></font>
   <span class="hljs-keyword">if</span> ((a)&gt;=(b))<span class="hljs-keyword">and</span>((b//a)==(a))<span class="hljs-keyword">and</span>((b//a)!=(b)):<font></font>
      b=b-a<font></font>
<span class="hljs-keyword">else</span>:<font></font>
   a=b//a<font></font>
   <span class="hljs-keyword">if</span> ((b//a)&lt;(b-a)):<font></font>
      a=b<font></font>
      a=b-a<font></font>
   <span class="hljs-keyword">else</span>:
      <span class="hljs-keyword">if</span> ((a)==(b)):<font></font>
         a=a<font></font>
         a=b//a<font></font>
         b=b<font></font>
         b=a+b<font></font>
         b=a<font></font>
      <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The third option implements recursion from the very beginning (option 3 in the schemes), i.e. </font><font style="vertical-align: inherit;">gives rise to a branch of the form:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)==(a)):
   <span class="hljs-keyword">if</span> ((a+b)&lt;(b)):</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
or </font></font><pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)&lt;=(a)):<font></font>
   a=a<font></font>
   <span class="hljs-keyword">if</span> ((b-a)==(b)):<font></font>
      a=a<font></font>
      a=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, the if line is formed (similarly), then a fork appears, which decides whether to insert the action block further or not, after which the offset is saved and recursion is called. The offset must be saved so that after the recursion is completed and the piece of code is returned, it is possible to add another elif-else block at the same offset as the original line with if. Here you can see how elif and else in the branch stand at the same offset with their "native" if.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)==(b)):<font></font>
<font></font>
   <span class="hljs-keyword">if</span> ((a)&gt;(a+b)):
      <span class="hljs-keyword">if</span> ((b)==(b-a)):<font></font>
         b=b<font></font>
         a=a<font></font>
      <span class="hljs-keyword">elif</span> ((b)&gt;(b)):
         <span class="hljs-literal">None</span>
      <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span><font></font>
         b=a<font></font>
         b=b</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next comes a fork in the elif-else-block / action block, which decides whether to add an action block or an elif-else block after recursion. If you decide to add an elif-else block, then there, similarly to the case described above, in scheme 2, elif or else is selected. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here it is necessary to pay attention to the fact that recursion is called with an offset of + 3 to shift the generated code to the right by a step, and the elif-else block is called with an offset of wall_offset so that this block does not go to the right after the recursion, but remains with the “native” the offset of the original if. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The results can be quite different: from simple to complex, but the appearance of recursion immediately produces the most ornate branches.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)&gt;(a+b))<span class="hljs-keyword">and</span>((b)&lt;(a+b)):
   <span class="hljs-keyword">if</span> ((b-a)&lt;=(a+b)):<font></font>
      b=b//a<font></font>
   <span class="hljs-keyword">elif</span> ((b)!=(a)):<font></font>
      a=b-a<font></font>
<span class="hljs-keyword">else</span>:
   <span class="hljs-keyword">if</span> ((a+b)!=(b-a)):<font></font>
      a=a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b)&lt;(b-a)):
   <span class="hljs-keyword">if</span> ((a+b)==(b-a))<span class="hljs-keyword">and</span>((b-a)&lt;(a+b))<span class="hljs-keyword">and</span>((b-a)==(a))<span class="hljs-keyword">and</span>((a)&gt;(b//a))<span class="hljs-keyword">or</span>((a+b)&gt;(b//a)):
      <span class="hljs-keyword">if</span> ((b)&gt;=(b-a)):<font></font>
         a=b<font></font>
         b=b<font></font>
         <span class="hljs-keyword">if</span> ((b)&gt;(b)):<font></font>
            a=a+b<font></font>
            b=a+b<font></font>
            a=a<font></font>
            b=a+b<font></font>
            b=b//a<font></font>
            b=a<font></font>
      <span class="hljs-keyword">else</span>:<font></font>
         b=a+b<font></font>
         a=b<font></font>
         a=b<font></font>
   <span class="hljs-keyword">elif</span> ((a)&lt;(b-a)):<font></font>
      a=b//a<font></font>
      a=b-a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)&gt;=(b-a))<span class="hljs-keyword">or</span>((a)&gt;=(a))<span class="hljs-keyword">or</span>((b)&lt;=(b)):<font></font>
   a=a<font></font>
   a=a<font></font>
<span class="hljs-keyword">elif</span> ((a)==(a))<span class="hljs-keyword">and</span>((b)&gt;(b-a)):<font></font>
   a=b//a<font></font>
   <span class="hljs-keyword">if</span> ((a)&lt;(b)):
      <span class="hljs-keyword">if</span> ((a+b)==(b-a)):<font></font>
         a=a<font></font>
         <span class="hljs-keyword">if</span> ((a)!=(b//a)):
            <span class="hljs-keyword">if</span> ((b//a)!=(a))<span class="hljs-keyword">and</span>((b-a)&gt;=(b)):<font></font>
               a=b<font></font>
            <span class="hljs-keyword">else</span>:
               <span class="hljs-literal">None</span><font></font>
               a=b//a<font></font>
      <span class="hljs-keyword">else</span>:<font></font>
         b=b<font></font>
         b=a+b<font></font>
         <span class="hljs-keyword">if</span> ((b-a)&lt;=(b//a)):<font></font>
            a=b<font></font>
            a=b<font></font>
            a=a+b<font></font>
<span class="hljs-keyword">else</span>:<font></font>
   a=a+b<font></font>
   <span class="hljs-keyword">if</span> ((b-a)&gt;=(a)):<font></font>
      a=b<font></font>
      <span class="hljs-keyword">if</span> ((b-a)==(a))<span class="hljs-keyword">or</span>((b)!=(b//a)):<font></font>
         a=b-a<font></font>
         a=a<font></font>
         a=a<font></font>
         a=b//a<font></font>
         a=a+b<font></font>
         b=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's look at the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else_block</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">, which is responsible for forming the elif-else block and is called from the main </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">elif_else_block</span>(<span class="hljs-params">ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list,  fin_else_flag, prob_list</span>):</span>
    <span class="hljs-keyword">if</span> ee_string==<span class="hljs-string">'elif'</span>:<font></font>
        sol3 = <span class="hljs-number">9</span>
        <span class="hljs-comment">#  </span><font></font>
        wall_offset = offset_koeff<font></font>
        <span class="hljs-comment">#  elif  </span>
        <span class="hljs-keyword">while</span> sol3!=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> fin_else_flag!=<span class="hljs-number">1</span>:<font></font>
            temp_str, offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'elif'</span>, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
            if_str+=temp_str<font></font>
            prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol3 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-comment">#  -   else   elif?</span>
        prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol = make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
        <span class="hljs-keyword">if</span> sol!=<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  else,   </span>
            fin_else_flag=<span class="hljs-number">1</span>
            temp_str,offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'else'</span>, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
            if_str+=temp_str<font></font>
        <span class="hljs-keyword">return</span>(if_str,offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-comment">#  else</span>
    <span class="hljs-keyword">else</span>: <font></font>
          temp_str,offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'else'</span>, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
          if_str+=temp_str<font></font>
          <span class="hljs-keyword">return</span>(if_str, offset_koeff, fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This function decides whether to add an elif or elif / else block to the code. She does not decide whether to simply put else, but depends on the input value e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e_string</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which she receives from the main function </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . First, the elif block is generated in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">while loop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where 2 conditions are checked: probabilistic - the number of elif in the block and the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flag </font><b><font style="vertical-align: inherit;">depend on it</font></b><font style="vertical-align: inherit;"> , which, if it suddenly turns on, it means that else was connected before that, and therefore you need to exit the loop . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The decision whether to attach else to the elif block is also decided by a fork using the same </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">, and if else is attached, the </font><b><font style="vertical-align: inherit;">fin_else_flag</font></b><font style="vertical-align: inherit;"> flag is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">turned on immediately</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which stops block generation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The direct joining of elif and else is carried out by the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">(see below). It should be noted here that when generating an elif block (and also when attaching an else </font><font style="vertical-align: inherit;">block </font><font style="vertical-align: inherit;">), the offset </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wall_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is used to smoothly build the block as a whole. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now consider the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs">&lt;b&gt;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">elif_else</span>(<span class="hljs-params">ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list</span>):</span>
    ee_str = <span class="hljs-string">''</span>
    <span class="hljs-comment">#   else:  elif [..]:</span>
    <span class="hljs-keyword">if</span> ee_string==<span class="hljs-string">'else'</span>:<font></font>
        ee_str += <span class="hljs-string">' '</span>*offset_koeff+ee_string + <span class="hljs-string">':\n'</span>
    <span class="hljs-keyword">elif</span> ee_string==<span class="hljs-string">'elif'</span>:<font></font>
        ee_str += <span class="hljs-string">' '</span>*offset_koeff+ee_string+<span class="hljs-string">' '</span>+if_sub(exp_list, var_list, sign, prob_list) + <span class="hljs-string">':\n'</span>
    <span class="hljs-comment">#   -None /  +</span>
    prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol = make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
    <span class="hljs-keyword">if</span> sol!=<span class="hljs-number">0</span>:<font></font>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  </span>
            ee_str+=action_str_gen(choice_list,offset_koeff+<span class="hljs-number">3</span>, prob_list)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># None</span>
            ee_str+=<span class="hljs-string">' '</span>*(offset_koeff+<span class="hljs-number">3</span>)+<span class="hljs-string">'None\n'</span>
        <span class="hljs-keyword">return</span>(ee_str, offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment">#   </span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2==<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  </span>
            ee_str+=action_str_gen(choice_list,offset_koeff+<span class="hljs-number">3</span>, prob_list)
        <span class="hljs-comment">#  if_gen</span>
        if_str, offset_koeff,  fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, offset_koeff+<span class="hljs-number">3</span>, fin_else_flag, prob_list)                 <font></font>
        ee_str+=if_str<font></font>
        <span class="hljs-keyword">return</span>(ee_str, offset_koeff, fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The function is responsible for the formation of the elif or else line itself, as well as for the subsequent generation of action or recursion blocks after these lines. It also takes an </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ee_string</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variable </font><font style="vertical-align: inherit;">, which contains either elif or else, and forms the corresponding string. Then there is a fork, where it is determined what will go next: (action block or None), or (action block or action block + recursion). Inside this fork, there is a division, respectively, into two sub-fork, and in each case the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function is </font><b><font style="vertical-align: inherit;">called</font></b><font style="vertical-align: inherit;"> with the appropriate parameters for making a decision. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It should be noted that when it occurs in code</font></font><code>if sol!=0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, this means that we intentionally give an advantage to one part of the code over another, because if sol! = 0, then it equals either -1, or 1, and therefore another piece of code will be executed less often (only when sol == 0). This is used, in particular, in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else_block</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">, where it is more profitable for us to let more </font><b><font style="vertical-align: inherit;">elifs</font></b><font style="vertical-align: inherit;"> form in the block, rather than giving equal probability to elif and else. Or, for example, in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><b><font style="vertical-align: inherit;">,</font></b><font style="vertical-align: inherit;"> we give an advantage to the option when an action block or None is formed rather than what the recursion is going for - otherwise the branches can grow to completely indecent sizes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We only need to consider the functions responsible for the random generation of expressions in conditions and blocks of actions. As I said above, at this stage they do not play a decisive role and are introduced here to generally show what the final generated code will look like. But since they are used in the generator, we will look at them briefly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The function responsible for generating the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">action_str</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> action </font><b><font style="vertical-align: inherit;">block</font></b><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action_str_gen</span>(<span class="hljs-params">choice_list, offset_koeff, prob_list</span>):</span>
    sol = <span class="hljs-number">9</span>
    curr_offset = <span class="hljs-string">' '</span>*offset_koeff<font></font>
    act_str = <span class="hljs-string">''</span>
    <span class="hljs-keyword">while</span> sol!=<span class="hljs-number">0</span>:<font></font>
        act_str+= curr_offset+rand(rand(choice_list[<span class="hljs-number">1</span>]))+<span class="hljs-string">'='</span>+rand(rand(choice_list))+<span class="hljs-string">'\n'</span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
    <span class="hljs-keyword">return</span>(act_str)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything is quite simple here: from the nested list choise_list, which, as we recall, consists of v </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ar_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (list of variables) and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exp_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (list of expressions), this function consists of one or more lines of this form: a = a + b or b = b . </font><font style="vertical-align: inherit;">Those. </font><font style="vertical-align: inherit;">either an expression is assigned to the variable, or another variable (including itself). </font><font style="vertical-align: inherit;">The rand function randomly selects an element from the list and is needed here solely in order not to produce monstrous strings.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rand</span>(<span class="hljs-params">t_list</span>):</span>
    <span class="hljs-keyword">return</span>(t_list[random.randint(<span class="hljs-number">0</span>,len(t_list)<span class="hljs-number">-1</span>)])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_sub</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expression generation function </font><font style="vertical-align: inherit;">for conditions looks bigger.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">if_sub</span>(<span class="hljs-params">exp_list, var_list, sign, prob_list</span>):</span>
    sub_str = <span class="hljs-string">''</span>
    sol = <span class="hljs-number">9</span><font></font>
    choice_list = [exp_list, var_list]<font></font>
    flag = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> sol!=<span class="hljs-number">0</span>:<font></font>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])<font></font>
        sub_str+=<span class="hljs-string">'(('</span>+rand(rand(choice_list))+<span class="hljs-string">')'</span>+rand(sign2)+<span class="hljs-string">'('</span>+rand(rand(choice_list))+<span class="hljs-string">'))'</span>
        <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> sol==<span class="hljs-number">1</span>:<font></font>
            sub_str+=<span class="hljs-string">')'</span>
            flag=<span class="hljs-number">0</span><font></font>
        or_and_exp = or_and(prob_list)<font></font>
        <span class="hljs-keyword">if</span> len(or_and_exp):<font></font>
            sub_str+=or_and_exp<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2 == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'D'</span> <span class="hljs-keyword">or</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'R'</span>) <span class="hljs-keyword">and</span> flag == <span class="hljs-number">0</span>:<font></font>
            sub_str+=<span class="hljs-string">'('</span>
            flag = <span class="hljs-number">1</span><font></font>
    <font></font>
    <span class="hljs-keyword">if</span> sub_str[<span class="hljs-number">-1</span>] == <span class="hljs-string">'('</span>:
        <span class="hljs-keyword">if</span> sub_str[<span class="hljs-number">-2</span>]==<span class="hljs-string">'d'</span>:<font></font>
           sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-4</span>]
        <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-2</span>]==<span class="hljs-string">'r'</span>:<font></font>
             sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-3</span>]
        <span class="hljs-keyword">else</span>:<font></font>
            sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-1</span>]
    <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'d'</span>:<font></font>
         sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-3</span>]
    <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'r'</span>:<font></font>
         sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-2</span>]
    <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span>
    <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span>:<font></font>
        sub_str+=<span class="hljs-string">')'</span>
        <span class="hljs-keyword">return</span>(sub_str)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span>(sub_str)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It generates expressions by type: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">((a)&gt; = (ba)) or ((a)&gt; = (a)) or ((b) &lt;= (b))</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">At the same time, both the left and right sides can have various options and stand as separate variables, as well as expressions or their groups. </font><font style="vertical-align: inherit;">The logical operators </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are also used here </font><font style="vertical-align: inherit;">, which are selected for convenience using the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or_and_exp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">or_and</span>(<span class="hljs-params">prob_list</span>):</span>
    prob_list[<span class="hljs-number">8</span>],prob_list[<span class="hljs-number">9</span>],sol = make_solution(prob_list[<span class="hljs-number">8</span>],prob_list[<span class="hljs-number">9</span>])
    <span class="hljs-keyword">if</span> sol==<span class="hljs-number">-1</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">'and'</span>)
    <span class="hljs-keyword">elif</span> sol==<span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">'or'</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">''</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The rest of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_sub</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">cuts off the extra tails from the expressions and adds, when necessary, closing brackets, to consider these dances with tambourines here, I think, is inexpedient. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, that's all. </font><font style="vertical-align: inherit;">You can start the generator, for example, like this:</font></font><br>
<br>
<pre><code class="python hljs">var_list = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]<font></font>
exp_list = [<span class="hljs-string">'a+b'</span>,<span class="hljs-string">'b-a'</span>, <span class="hljs-string">'b//a'</span>]<font></font>
sign = [<span class="hljs-string">'+'</span>,<span class="hljs-string">'-'</span>,<span class="hljs-string">'/'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'//'</span>]<font></font>
sign2 = [<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'=='</span>,<span class="hljs-string">'&gt;='</span>,<span class="hljs-string">'&lt;='</span>,<span class="hljs-string">'!='</span>]<font></font>
a = <span class="hljs-number">3</span>
b = <span class="hljs-number">2</span>       
prob_list = [<span class="hljs-number">0.5</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)]      
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
     if_str = <span class="hljs-string">''</span>
     if_str, offset_koeff, fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>, prob_list)
     <span class="hljs-keyword">try</span>:<font></font>
         exec(compile(if_str,<span class="hljs-string">'gen'</span>,<span class="hljs-string">'exec'</span>))<font></font>
         print(if_str)<font></font>
         input()<font></font>
         <font></font>
     <span class="hljs-keyword">except</span> ZeroDivisionError:
         <span class="hljs-literal">None</span>
     <span class="hljs-keyword">except</span>:<font></font>
         print(<span class="hljs-string">'error'</span>)<font></font>
         print(if_str)<font></font>
         input()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, the input, including a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with probabilities </font><font style="vertical-align: inherit;">, then in an infinite loop, calling the main function </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and starting the generated generated string for execution. It is worth processing separately ZeroDivisionError, because division by zero with such a random construction of expressions is very common. After the launch, just press Enter for the next generation to appear. Most often they will be quite simple, but often branched and even very branched. Well, </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">import random</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at the beginning would also be nice to insert;) For those who do not want to see collecting everything by hand, you can download the file from </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (file if_gen.py).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In conclusion, I want to say that the code I presented was tested on hundreds of thousands of generations without errors, while it demonstrated the whole palette of if-elif-else schemes that I wanted to finally see. Once, by mistake, I gave in one part of the code a too high probability of recursion and I got 52,000 (!) Lines of generation and at the same time it was working (although the comp was suspended for 30 seconds). This also indicates the reliability of the algorithm. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probably, it was possible to write more concisely somewhere, optimize somewhere, arrange the main function in another way, but the main thing is that this code works and generates about 250 generations per second, which, in my opinion, is quite acceptable.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I never considered this code as self-sufficient - it is just a module of the future digital organism and was written for research purposes, so it hardly has any practical applications. </font><font style="vertical-align: inherit;">At the same time, I am not responsible for any consequences for anyone using the above code, and I urge everyone to cut bread with a knife for cutting bread, and not something else. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the next article, we will consider the second module, which will be responsible for the random formation of experience. </font><font style="vertical-align: inherit;">This topic promises to be much more interesting than the if generator, and I will definitely post the results as soon as I have them.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en504270/index.html">Is Svelte a good choice for widget implementation?</a></li>
<li><a href="../en504276/index.html">Top 10 Developer Books</a></li>
<li><a href="../en504282/index.html">Creation of Enterprise-architecture in NSPK</a></li>
<li><a href="../en504284/index.html">The book “Pure Agile. The Basics of Flexibility</a></li>
<li><a href="../en504290/index.html">Load testing as a CI service for developers</a></li>
<li><a href="../en504306/index.html">How is Russian hardware made for storage Aerodisk Vostok on Elbrus</a></li>
<li><a href="../en504310/index.html">Dichotomy of data: rethinking the relationship with data and services</a></li>
<li><a href="../en504312/index.html">Unified register of Russian programs and GPL. My five cents</a></li>
<li><a href="../en504314/index.html">Implementation of docker pull and docker push commands without docker client via HTTP requests</a></li>
<li><a href="../en504320/index.html">Single line code or Nethermind validation using PVS-Studio C # for Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>