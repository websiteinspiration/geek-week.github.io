<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏻 🔦 👩🏼‍🍳 Prédiction de séries chronologiques à l'aide de réseaux de neurones récurrents 👨‍🎤 👑 💞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le mode de fonctionnement à distance dans le contexte de l'auto-isolation universelle peut entraîner de très graves conséquences. Et l'épuisement émot...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Prédiction de séries chronologiques à l'aide de réseaux de neurones récurrents</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495884/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mode de fonctionnement à distance dans le contexte de l'auto-isolation universelle peut entraîner de très graves conséquences. Et l'épuisement émotionnel - c'est toujours partout où il va: là, après tout, ce n'est pas loin du toit. À cet égard, comme beaucoup, il a essayé de se "calmer" en allouant du temps à d'autres classes - et a commencé à traduire les articles les plus intéressants de l'anglais vers le russe: "Vous donnez </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un apprentissage automatique</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aux masses!".) Nous devons rendre hommage: c'est très distrayant. Si vous avez des suggestions pour le contenu sémantique et la traduction de ce texte pour un lecteur russophone, rejoignez la discussion.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3d7/fe4/946/3d7fe49466cad76814b37e73ec1bc49a.jpg" alt="image"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici donc une traduction de la page </font><font style="vertical-align: inherit;">de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prévision des séries</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chronologiques de la section du manuel tensorflow: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mes ajouts ainsi que des illustrations pour la traduction visent à aider à comprendre les idées de base dans l'un des domaines les plus intéressants du ML et de l'économétrie en général - la prévision des séries chronologiques. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une petite introduction avant la traduction. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le manuel est une description de la prévision de la température de l'air basée sur des séries chronologiques unidimensionnelles </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> séries chronologiques </font><i><font style="vertical-align: inherit;">univariées)</font></i><font style="vertical-align: inherit;"> et des séries chronologiques </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">multivariées (</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> séries chronologiques </font><i><font style="vertical-align: inherit;">multivariées)</font></i><font style="vertical-align: inherit;"> . Pour chaque partie, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saisissez les données</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doivent être préparés en conséquence. En tenant compte de l'ensemble de données météorologiques considéré dans ce guide, la séparation est la suivante: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8fa/31a/a75/8fa31aa7531d8589dcee2ae93454a430.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pour les questions sur ce qu'il faut prendre pour </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et ce pour </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est-à-dire comment préparer les données pour la classe de formation supervisée, il deviendra clair à partir des illustrations suivantes. Je note seulement que la formation du vecteur cible (Y) pour travailler avec des séries temporelles à la fois unidimensionnelles et multidimensionnelles est la même: le vecteur cible est compilé sur la base du signe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T (degC)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(température de l'air). La différence entre eux est «enfouie» dans la formation d'un ensemble de caractéristiques qui sont introduites dans l'entrée du modèle: dans le cas d'une série chronologique unidimensionnelle pour prédire la température dans le futur, le vecteur d'entrée (X) se compose d'une caractéristique: en fait, la température de l'air; et pour plusieurs dimensions - plusieurs: en plus de la température de l'air, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p (mbar)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (pression atmosphérique) et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rho (g / m ** 3)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (humidité) </font><font style="vertical-align: inherit;">sont utilisés dans l'exemple du manuel en question </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au début, très superficiel, un exemple avec la prévision de température ne semble pas convaincant du point de vue de l'utilisation d'une entrée multidimensionnelle: pour prévoir la température, le signe le plus pertinent sera la température. Mais ce n'est absolument pas le cas: pour développer une prévision qualitative de la température de l'air, de nombreux facteurs doivent être pris en compte, jusqu'au frottement de l'air à la surface de la terre, etc. De plus, en pratique, certaines choses sont loin d'être évidentes, et le vecteur cible peut être sous la forme de ce méli-mélo (ou bortsch). À cet égard, l'analyse des données exploratoires avec la sélection des caractéristiques les plus pertinentes pour la formation ultérieure d'une entrée multidimensionnelle est la seule bonne décision. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la traduction du manuel est présentée ci-dessous. Le texte supplémentaire sera </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en italique</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prévision de séries chronologiques</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce guide est une introduction à la prévision de séries chronologiques à l'aide de réseaux de neurones récurrents (RNS, de l'anglais </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recurrent Neural Network, RNN</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Il se compose de deux parties: la première décrit la prévision de la température de l'air sur la base d'une série chronologique unidimensionnelle et la seconde - sur la base d'une série chronologique multidimensionnelle.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<font></font>
<font></font>
<span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
mpl.rcParams[<span class="hljs-string">'figure.figsize'</span>] = (<span class="hljs-number">8</span>, <span class="hljs-number">6</span>)<font></font>
mpl.rcParams[<span class="hljs-string">'axes.grid'</span>] = <span class="hljs-literal">False</span>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ensemble de données météorologiques</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Tous les exemples de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">séquences temporelles d'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilisation manuelle </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">de données météorologiques</font></a><font style="vertical-align: inherit;"> enregistrées dans une station hydrométéorologique de l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Institut de biogéochimie nommé d'après </font><font style="vertical-align: inherit;">Max Planck</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet ensemble de données comprend des mesures de 14 indicateurs météorologiques différents (tels que la température de l'air, la pression atmosphérique, l'humidité), effectuées toutes les 10 minutes depuis 2003. </font><font style="vertical-align: inherit;">Pour économiser du temps et de la mémoire, le manuel utilisera des données couvrant la période de 2009 à 2016. </font><font style="vertical-align: inherit;">Cette section de l'ensemble de données a été préparée par François Chollet pour son livre, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deep Learning with Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs">zip_path = tf.keras.utils.get_file(<font></font>
    origin=<span class="hljs-string">'https://storage.googleapis.com/tensorflow/tf-keras-datasets/jena_climate_2009_2016.csv.zip'</span>,<font></font>
    fname=<span class="hljs-string">'jena_climate_2009_2016.csv.zip'</span>,<font></font>
    extract=<span class="hljs-literal">True</span>)<font></font>
csv_path, _ = os.path.splitext(zip_path)<font></font>
</code></pre><br>
<pre><code class="python hljs">df = pd.read_csv(csv_path)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons voir ce que nous avons.</font></font><br>
<br>
<pre><code class="python hljs">df.head()
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/d5d/bfa/539/d5dbfa539de3da5ca04103b2db380a70.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fait que la période d'enregistrement d'observation soit de 10 minutes peut être vérifié par le tableau ci-dessus. Ainsi, en une heure vous aurez 6 observations. À son tour, 144 observations (6x24) sont accumulées par jour. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Disons que vous voulez prédire la température, qui sera dans 6 heures dans le futur. Vous faites cette prévision sur la base des données dont vous disposez pour une certaine période: par exemple, vous décidez d'utiliser 5 jours d'observation. Par conséquent, pour former le modèle, vous devez créer un intervalle de temps contenant les 720 dernières observations (5x144) (puisque différentes configurations sont possibles, cet ensemble de données est une bonne base pour les expériences). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction ci-dessous renvoie les intervalles de temps ci-dessus pour l'apprentissage du modèle. Argument</font></font><code>history_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- c'est la taille du dernier intervalle de temps, </font></font><code>target_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- un argument qui détermine jusqu'où le modèle devrait apprendre à prédire. </font><font style="vertical-align: inherit;">En d'autres termes, </font></font><code>target_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est le vecteur cible qui doit être prédit.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">univariate_data</span>(<span class="hljs-params">dataset, start_index, end_index, history_size, target_size</span>):</span><font></font>
  data = []<font></font>
  labels = []<font></font>
<font></font>
  start_index = start_index + history_size<font></font>
  <span class="hljs-keyword">if</span> end_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
    end_index = len(dataset) - target_size<font></font>
<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_index, end_index):<font></font>
    indices = range(i-history_size, i)<font></font>
    <span class="hljs-comment"># Reshape data from (history_size,) to (history_size, 1)</span>
    data.append(np.reshape(dataset[indices], (history_size, <span class="hljs-number">1</span>)))<font></font>
    labels.append(dataset[i+target_size])<font></font>
  <span class="hljs-keyword">return</span> np.array(data), np.array(labels)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les deux parties du manuel, les 300 000 premières lignes de données seront utilisées pour former le modèle, les autres pour le valider (valider). </font><font style="vertical-align: inherit;">Dans ce cas, la quantité de données d'entraînement est d'environ 2100 jours.</font></font><br>
<br>
<pre><code class="python hljs">TRAIN_SPLIT = <span class="hljs-number">300000</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour garantir des résultats reproductibles, la fonction d'amorçage est définie.</font></font><br>
<br>
<pre><code class="python hljs">tf.random.set_seed(<span class="hljs-number">13</span>)
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 1. Prévision basée sur une série chronologique unidimensionnelle</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la première partie, vous formerez le modèle en utilisant un seul attribut - température; </font><font style="vertical-align: inherit;">le modèle formé sera utilisé pour prévoir les températures futures. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, nous extrayons uniquement la température de l'ensemble de données.</font></font><br>
<br>
<pre><code class="python hljs">uni_data = df[<span class="hljs-string">'T (degC)'</span>]<font></font>
uni_data.index = df[<span class="hljs-string">'Date Time'</span>]<font></font>
uni_data.head()<font></font>
</code></pre><br>
<code>Date Time<br>
01.01.2009 00:10:00 -8.02<br>
01.01.2009 00:20:00 -8.41<br>
01.01.2009 00:30:00 -8.51<br>
01.01.2009 00:40:00 -8.31<br>
01.01.2009 00:50:00 -8.27<br>
Name: T (degC), dtype: float64<br>
</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et voyons comment ces données changent au fil du temps.</font></font><br>
<br>
<pre><code class="python hljs">uni_data.plot(subplots=<span class="hljs-literal">True</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/208/b35/242/208b35242d3ce1ed30bd25d12d956703.jpg" alt="image"><br>
<br>
<pre><code class="python hljs">uni_data = uni_data.values
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de former un réseau neuronal artificiel (ci-après - ANN), une étape importante est la mise à l'échelle des données. </font><font style="vertical-align: inherit;">L'un des moyens courants d'effectuer la mise à l'échelle est la standardisation ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">standardisation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), effectuée en soustrayant la moyenne et en divisant par l'écart-type pour chaque caractéristique. </font><font style="vertical-align: inherit;">Vous pouvez également utiliser une méthode </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">tf.keras.utils.normalize</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui met les valeurs à l'échelle dans la plage [0,1]. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la normalisation ne doit être effectuée qu'en utilisant les données de formation.</font></font><br>
<br>
<pre><code class="python hljs">uni_train_mean = uni_data[:TRAIN_SPLIT].mean()<font></font>
uni_train_std = uni_data[:TRAIN_SPLIT].std()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous effectuons la standardisation des données.</font></font><br>
<br>
<pre><code class="python hljs">uni_data = (uni_data-uni_train_mean)/uni_train_std
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous préparerons les données pour le modèle avec une entrée unidimensionnelle. </font><font style="vertical-align: inherit;">Les 20 dernières observations enregistrées de la température seront transmises à l'entrée du modèle, et le modèle doit être formé pour prédire la température au prochain pas de temps.</font></font><br>
<br>
<pre><code class="python hljs">univariate_past_history = <span class="hljs-number">20</span>
univariate_future_target = <span class="hljs-number">0</span><font></font>
<font></font>
x_train_uni, y_train_uni = univariate_data(uni_data, <span class="hljs-number">0</span>, TRAIN_SPLIT,<font></font>
                                           univariate_past_history,<font></font>
                                           univariate_future_target)<font></font>
x_val_uni, y_val_uni = univariate_data(uni_data, TRAIN_SPLIT, <span class="hljs-literal">None</span>,<font></font>
                                       univariate_past_history,<font></font>
                                       univariate_future_target)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les résultats de l'application de la fonction </font></font><code>univariate_data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history'</span>)
<span class="hljs-keyword">print</span> (x_train_uni[<span class="hljs-number">0</span>])
<span class="hljs-keyword">print</span> (<span class="hljs-string">'\n Target temperature to predict'</span>)
<span class="hljs-keyword">print</span> (y_train_uni[<span class="hljs-number">0</span>])
</code></pre><br>
<code>Single window of past history<br>
[[-1.99766294]<br>
 [-2.04281897]<br>
 [-2.05439744]<br>
 [-2.0312405 ]<br>
 [-2.02660912]<br>
 [-2.00113649]<br>
 [-1.95134907]<br>
 [-1.95134907]<br>
 [-1.98492663]<br>
 [-2.04513467]<br>
 [-2.08334362]<br>
 [-2.09723778]<br>
 [-2.09376424]<br>
 [-2.09144854]<br>
 [-2.07176515]<br>
 [-2.07176515]<br>
 [-2.07639653]<br>
 [-2.08913285]<br>
 [-2.09260639]<br>
 [-2.10418486]]<br>
<br>
Target temperature to predict<br>
-2.1041848598100876<br>
</code><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addition: la préparation des données pour un modèle avec une entrée unidimensionnelle est schématiquement illustrée dans la figure suivante (pour plus de commodité, dans cette figure et les suivantes, les données sont présentées sous une forme «brute», avant normalisation, et également sans l'attribut «Date heure» comme index):</font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fa0/d0f/530/fa0d0f530b3496324425eeb5e52baff7.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Maintenant que les données convenablement préparé, considérez un exemple concret. </font><font style="vertical-align: inherit;">Les informations transmises à l'ANN sont surlignées en bleu, une croix rouge indique la valeur future que l'ANN devrait prédire.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_time_steps</span>(<span class="hljs-params">length</span>):</span>
  <span class="hljs-keyword">return</span> list(range(-length, <span class="hljs-number">0</span>))
</code></pre><br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_plot</span>(<span class="hljs-params">plot_data, delta, title</span>):</span>
  labels = [<span class="hljs-string">'History'</span>, <span class="hljs-string">'True Future'</span>, <span class="hljs-string">'Model Prediction'</span>]<font></font>
  marker = [<span class="hljs-string">'.-'</span>, <span class="hljs-string">'rx'</span>, <span class="hljs-string">'go'</span>]<font></font>
  time_steps = create_time_steps(plot_data[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>])
  <span class="hljs-keyword">if</span> delta:<font></font>
    future = delta<font></font>
  <span class="hljs-keyword">else</span>:<font></font>
    future = <span class="hljs-number">0</span><font></font>
<font></font>
  plt.title(title)<font></font>
  <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> enumerate(plot_data):
    <span class="hljs-keyword">if</span> i:<font></font>
      plt.plot(future, plot_data[i], marker[i], markersize=<span class="hljs-number">10</span>,<font></font>
               label=labels[i])<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
      plt.plot(time_steps, plot_data[i].flatten(), marker[i], label=labels[i])<font></font>
  plt.legend()<font></font>
  plt.xlim([time_steps[<span class="hljs-number">0</span>], (future+<span class="hljs-number">5</span>)*<span class="hljs-number">2</span>])<font></font>
  plt.xlabel(<span class="hljs-string">'Time-Step'</span>)
  <span class="hljs-keyword">return</span> plt
</code></pre><br>
<pre><code class="python hljs">show_plot([x_train_uni[<span class="hljs-number">0</span>], y_train_uni[<span class="hljs-number">0</span>]], <span class="hljs-number">0</span>, <span class="hljs-string">'Sample Example'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/589/38c/574/58938c5740abfb08ed0074a1233f512f.jpg" alt="image"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solution de base (sans impliquer l'apprentissage automatique)</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Avant de commencer la formation sur le modèle, nous allons installer une solution de base simple ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">référence</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Elle consiste en ce qui suit: pour un vecteur d'entrée donné, la méthode de solution de base «scanne» tout l'historique et prédit la valeur suivante comme la moyenne des 20 dernières observations.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">baseline</span>(<span class="hljs-params">history</span>):</span>
  <span class="hljs-keyword">return</span> np.mean(history)
</code></pre><br>
<pre><code class="python hljs">show_plot([x_train_uni[<span class="hljs-number">0</span>], y_train_uni[<span class="hljs-number">0</span>], baseline(x_train_uni[<span class="hljs-number">0</span>])], <span class="hljs-number">0</span>,
           <span class="hljs-string">'Baseline Prediction Example'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/bed/941/0ef/bed9410ef6b96ad25ab68a0a3ebac05a.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons voir si nous pouvons dépasser le résultat de la «moyenne» en utilisant un réseau de neurones récurrent. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Réseau</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
neuronal récurrent </font><b><font style="vertical-align: inherit;">Un</font></b><font style="vertical-align: inherit;"> réseau neuronal récurrent (RNS) est un type d'ANN qui convient bien à la résolution de problèmes de séries chronologiques. Le RNS traite pas à pas la séquence temporelle des données, trie ses éléments et préserve l'état interne obtenu en traitant les éléments précédents. Vous pouvez trouver plus d'informations sur RNS dans le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guide</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> suivant </font><font style="vertical-align: inherit;">. Ce guide utilisera une couche spécialisée de RNC appelée </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mémoire à court terme à long terme ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSTM</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilisation ultérieure</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">tf.data</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mélangez, regroupez et mettez en cache l'ensemble de données. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajout: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus d'informations sur les méthodes de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lecture</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aléatoire, de traitement par lots et de cache sur la page </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">tensorflow</font></a><font style="vertical-align: inherit;"> :</font></font></i><br>
<br>
<pre><code class="python hljs">BATCH_SIZE = <span class="hljs-number">256</span>
BUFFER_SIZE = <span class="hljs-number">10000</span><font></font>
<font></font>
train_univariate = tf.data.Dataset.from_tensor_slices((x_train_uni, y_train_uni))<font></font>
train_univariate = train_univariate.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_univariate = tf.data.Dataset.from_tensor_slices((x_val_uni, y_val_uni))<font></font>
val_univariate = val_univariate.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La visualisation suivante devrait vous aider à comprendre à quoi ressemblent les données après le traitement par lots. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/002/e4b/3ed/002e4b3ed48fa5d17f34ccee2cbfc40d.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On peut voir que LSTM nécessite une certaine forme de saisie de données qui lui est fournie.</font></font><br>
<br>
<pre><code class="python hljs">simple_lstm_model = tf.keras.models.Sequential([<font></font>
    tf.keras.layers.LSTM(<span class="hljs-number">8</span>, input_shape=x_train_uni.shape[<span class="hljs-number">-2</span>:]),<font></font>
    tf.keras.layers.Dense(<span class="hljs-number">1</span>)<font></font>
])<font></font>
<font></font>
simple_lstm_model.compile(optimizer=<span class="hljs-string">'adam'</span>, loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vérifiez la sortie du modèle.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_univariate.take(<span class="hljs-number">1</span>):<font></font>
    print(simple_lstm_model.predict(x).shape)<font></font>
</code></pre><br>
<code>(256, 1)<br>
</code><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addition: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En termes généraux, les RNS fonctionnent avec des séquences. </font><font style="vertical-align: inherit;">Cela signifie que les données fournies à l'entrée du modèle doivent avoir la forme suivante: </font></font><br>
<br>
<code>[,  , - ]</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La forme des données d'apprentissage pour le modèle avec une entrée unidimensionnelle a la forme suivante:</font></font></i><br>
<br>
<code>print(x_train_uni.shape)<br>
(299980, 20, 1)</code><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous étudierons le modèle. </font><font style="vertical-align: inherit;">En raison de la grande taille de l'ensemble de données et afin de gagner du temps, chaque époque ne passera que par 200 étapes ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">steps_per_epoch = 200</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) au lieu des données d'entraînement complètes, comme c'est généralement le cas.</font></font><br>
<br>
<pre><code class="python hljs">EVALUATION_INTERVAL = <span class="hljs-number">200</span>
EPOCHS = <span class="hljs-number">10</span><font></font>
<font></font>
simple_lstm_model.fit(train_univariate, epochs=EPOCHS,<font></font>
                      steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                      validation_data=val_univariate, validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 2s 11ms/step - loss: 0.4075 - val_loss: 0.1351<br>
Epoch 2/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.1118 - val_loss: 0.0360<br>
Epoch 3/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0490 - val_loss: 0.0289<br>
Epoch 4/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0444 - val_loss: 0.0257<br>
Epoch 5/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0299 - val_loss: 0.0235<br>
Epoch 6/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0317 - val_loss: 0.0224<br>
Epoch 7/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0287 - val_loss: 0.0206<br>
Epoch 8/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0263 - val_loss: 0.0200<br>
Epoch 9/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0254 - val_loss: 0.0182<br>
Epoch 10/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0228 - val_loss: 0.0174<br>
</code><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prédiction à l'aide d'un modèle LSTM simple</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Après avoir terminé la préparation d'un modèle LSTM simple, nous ferons plusieurs prédictions.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_univariate.take(<span class="hljs-number">3</span>):<font></font>
  plot = show_plot([x[<span class="hljs-number">0</span>].numpy(), y[<span class="hljs-number">0</span>].numpy(),<font></font>
                    simple_lstm_model.predict(x)[<span class="hljs-number">0</span>]], <span class="hljs-number">0</span>, <span class="hljs-string">'Simple LSTM model'</span>)<font></font>
  plot.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/cf8/0f6/810/cf80f681038da62889884ae5de86722d.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il semble meilleur que le niveau de base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que vous vous êtes familiarisé avec les bases, passons à la deuxième partie, qui décrit l'utilisation d'une série chronologique multidimensionnelle.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 2: Prévision multidimensionnelle des séries chronologiques</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme indiqué, l'ensemble de données d'origine contient 14 indicateurs météorologiques différents. </font><font style="vertical-align: inherit;">Pour plus de simplicité et de commodité, dans la deuxième partie, seuls trois d'entre eux sont pris en compte: la température de l'air, la pression atmosphérique et la densité de l'air. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour utiliser plus de fonctionnalités, leurs noms doivent être ajoutés à la liste </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">feature_considered</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs">features_considered = [<span class="hljs-string">'p (mbar)'</span>, <span class="hljs-string">'T (degC)'</span>, <span class="hljs-string">'rho (g/m**3)'</span>]
</code></pre><br>
<pre><code class="python hljs">features = df[features_considered]<font></font>
features.index = df[<span class="hljs-string">'Date Time'</span>]<font></font>
features.head()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/1f8/589/b51/1f8589b51d64dcd9ba10e5f072df503e.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment ces indicateurs changent au fil du temps.</font></font><br>
<br>
<pre><code class="python hljs">features.plot(subplots=<span class="hljs-literal">True</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/7be/266/b59/7be266b59f38be1e4c365ee8562dffcd.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme précédemment, la première étape consiste à standardiser l'ensemble de données avec le calcul de la valeur moyenne et l'écart type des données d'apprentissage.</font></font><br>
<br>
<pre><code class="python hljs">dataset = features.values<font></font>
data_mean = dataset[:TRAIN_SPLIT].mean(axis=<span class="hljs-number">0</span>)<font></font>
data_std = dataset[:TRAIN_SPLIT].std(axis=<span class="hljs-number">0</span>)
</code></pre><br>
<pre><code class="python hljs">dataset = (dataset-data_mean)/data_std
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addition: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus loin dans le manuel, nous parlerons de prévisions ponctuelles et d'intervalles. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le résultat est le suivant. Si vous avez besoin du modèle pour prédire une valeur dans le futur (par exemple, la valeur de température après 12 heures) (modèle en une étape / en une seule étape), vous devez alors entraîner le modèle afin qu'il ne prédit qu'une seule valeur dans le futur. Si la tâche consiste à prédire la plage de valeurs à l'avenir (par exemple, les températures horaires au cours des 12 prochaines heures) (modèle à plusieurs étapes), le modèle doit également être formé pour prédire la plage de valeurs à l'avenir. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/906/953/08e/90695308e69c21c37e772d98553209a4.png" alt="image"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prédiction ponctuelle</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans ce cas, le modèle est formé pour prédire une valeur dans le futur en fonction de l'historique disponible.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction ci-dessous effectue la même tâche d'organisation des intervalles de temps uniquement avec la différence qu'elle sélectionne ici les dernières observations en fonction d'une taille de pas donnée.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multivariate_data</span>(<span class="hljs-params">dataset, target, start_index, end_index, history_size,
                      target_size, step, single_step=False</span>):</span><font></font>
  data = []<font></font>
  labels = []<font></font>
<font></font>
  start_index = start_index + history_size<font></font>
  <span class="hljs-keyword">if</span> end_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
    end_index = len(dataset) - target_size<font></font>
<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_index, end_index):<font></font>
    indices = range(i-history_size, i, step)<font></font>
    data.append(dataset[indices])<font></font>
<font></font>
    <span class="hljs-keyword">if</span> single_step:<font></font>
      labels.append(target[i+target_size])<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
      labels.append(target[i:i+target_size])<font></font>
<font></font>
  <span class="hljs-keyword">return</span> np.array(data), np.array(labels)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce guide, l'ANN fonctionne sur les données des cinq (5) derniers jours, soit 720 observations (6x24x5). </font><font style="vertical-align: inherit;">Supposons que la sélection des données soit effectuée non pas toutes les 10 minutes, mais toutes les heures: dans les 60 minutes, des changements brusques ne sont pas attendus. </font><font style="vertical-align: inherit;">Par conséquent, l'histoire des cinq derniers jours comprend 120 observations (720/6). </font><font style="vertical-align: inherit;">Pour un modèle qui effectue une prédiction ponctuelle, l'objectif est de lire la température après 12 heures à l'avenir. </font><font style="vertical-align: inherit;">Dans ce cas, le vecteur cible sera la température après 72 (12x6) observations ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voir l'addition suivante. - Traducteur approx.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<pre><code class="python hljs">past_history = <span class="hljs-number">720</span>
future_target = <span class="hljs-number">72</span>
STEP = <span class="hljs-number">6</span><font></font>
<font></font>
x_train_single, y_train_single = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<font></font>
                                                   TRAIN_SPLIT, past_history,<font></font>
                                                   future_target, STEP,<font></font>
                                                   single_step=<span class="hljs-literal">True</span>)<font></font>
x_val_single, y_val_single = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>],<font></font>
                                               TRAIN_SPLIT, <span class="hljs-literal">None</span>, past_history,<font></font>
                                               future_target, STEP,<font></font>
                                               single_step=<span class="hljs-literal">True</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vérifiez l'intervalle de temps.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history : {}'</span>.format(x_train_single[<span class="hljs-number">0</span>].shape))
</code></pre><br>
<code>Single window of past history : (120, 3)<br>
</code><br>
<pre><code class="python hljs">train_data_single = tf.data.Dataset.from_tensor_slices((x_train_single, y_train_single))<font></font>
train_data_single = train_data_single.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_data_single = tf.data.Dataset.from_tensor_slices((x_val_single, y_val_single))<font></font>
val_data_single = val_data_single.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br>
<pre><code class="python hljs">single_step_model = tf.keras.models.Sequential()<font></font>
single_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">32</span>,<font></font>
                                           input_shape=x_train_single.shape[<span class="hljs-number">-2</span>:]))<font></font>
single_step_model.add(tf.keras.layers.Dense(<span class="hljs-number">1</span>))<font></font>
<font></font>
single_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(), loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous vérifierons notre échantillon et en déduirons les courbes de perte aux étapes de la formation et de la vérification.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_single.take(<span class="hljs-number">1</span>):<font></font>
  print(single_step_model.predict(x).shape)<font></font>
</code></pre><br>
<code>(256, 1)<br>
</code><br>
<pre><code class="python hljs">single_step_history = single_step_model.fit(train_data_single, epochs=EPOCHS,<font></font>
                                            steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                                            validation_data=val_data_single,<font></font>
                                            validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 4s 18ms/step - loss: 0.3090 - val_loss: 0.2646<br>
Epoch 2/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2624 - val_loss: 0.2435<br>
Epoch 3/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2616 - val_loss: 0.2472<br>
Epoch 4/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2567 - val_loss: 0.2442<br>
Epoch 5/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2263 - val_loss: 0.2346<br>
Epoch 6/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2416 - val_loss: 0.2643<br>
Epoch 7/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2411 - val_loss: 0.2577<br>
Epoch 8/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2410 - val_loss: 0.2388<br>
Epoch 9/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2447 - val_loss: 0.2485<br>
Epoch 10/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2388 - val_loss: 0.2422<br>
</code><br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_train_history</span>(<span class="hljs-params">history, title</span>):</span>
  loss = history.history[<span class="hljs-string">'loss'</span>]<font></font>
  val_loss = history.history[<span class="hljs-string">'val_loss'</span>]<font></font>
<font></font>
  epochs = range(len(loss))<font></font>
<font></font>
  plt.figure()<font></font>
<font></font>
  plt.plot(epochs, loss, <span class="hljs-string">'b'</span>, label=<span class="hljs-string">'Training loss'</span>)<font></font>
  plt.plot(epochs, val_loss, <span class="hljs-string">'r'</span>, label=<span class="hljs-string">'Validation loss'</span>)<font></font>
  plt.title(title)<font></font>
  plt.legend()<font></font>
<font></font>
  plt.show()<font></font>
</code></pre><br>
<pre><code class="python hljs">plot_train_history(single_step_history,
                   <span class="hljs-string">'Single Step Training and validation loss'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/baa/481/4df/baa4814df5d278c7be5a4daf629ec8e0.jpg" alt="image"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addition: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La préparation des données pour un modèle avec une entrée multidimensionnelle effectuant une prédiction ponctuelle est schématisée dans la figure suivante. </font><font style="vertical-align: inherit;">Pour plus de commodité et une représentation plus visuelle de la préparation des données, l'argument </font></font><code>STEP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est 1. Notez que dans les fonctions de générateur données, l' </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">argument est </font></font><code>STEP </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destiné uniquement à la formation de l'historique</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et non au vecteur cible. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfd/c0b/ef1/bfdc0bef1203da6840adcb4311455645.png" alt="image"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, il </font></font><code>x_train_single</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la forme </font></font><code>(299280, 720, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quand </font></font><code>STEP=6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le formulaire prendra la forme suivante: </font></font><code>(299280, 120, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la vitesse de la fonction augmentera considérablement. </font><font style="vertical-align: inherit;">En général, il faut donner du crédit au programmeur: les générateurs présentés dans le manuel sont très voraces en termes de consommation mémoire. </font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Réalisation d'une prédiction ponctuelle</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que le modèle est formé, nous allons effectuer plusieurs prédictions de test. L'historique des observations de 3 signes pour les cinq derniers jours, sélectionnés toutes les heures (intervalle de temps = 120), est transmis à l'entrée du modèle. Puisque notre objectif est de prévoir uniquement la température, les valeurs de température passées ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">historique</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sont </font><font style="vertical-align: inherit;">affichées en bleu sur le graphique </font><font style="vertical-align: inherit;">. La prévision a été faite une demi-journée dans le futur (d'où l'écart entre l'histoire et la valeur prédite).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_single.take(<span class="hljs-number">3</span>):<font></font>
  plot = show_plot([x[<span class="hljs-number">0</span>][:, <span class="hljs-number">1</span>].numpy(), y[<span class="hljs-number">0</span>].numpy(),<font></font>
                    single_step_model.predict(x)[<span class="hljs-number">0</span>]], <span class="hljs-number">12</span>,
                   <span class="hljs-string">'Single Step Prediction'</span>)<font></font>
  plot.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/6ac/a5b/ce3/6aca5bce3fef9de56f1fac299da5527c.jpg" alt="image"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prévision d'intervalle</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans ce cas, sur la base d'un historique disponible, le modèle est formé pour prédire l'intervalle des valeurs futures. </font><font style="vertical-align: inherit;">Ainsi, contrairement à un modèle qui ne prédit qu'une seule valeur à l'avenir, ce modèle prédit une séquence de valeurs à l'avenir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que, comme dans le cas du modèle effectuant la prédiction ponctuelle, pour le modèle effectuant la prédiction d'intervalle, les données d'apprentissage correspondent aux mesures horaires des cinq derniers jours (720/6). </font><font style="vertical-align: inherit;">Cependant, dans ce cas, le modèle doit être formé pour prédire la température pour les 12 prochaines heures. </font><font style="vertical-align: inherit;">Étant donné que les observations sont enregistrées toutes les 10 minutes, la sortie du modèle devrait consister en 72 prédictions. </font><font style="vertical-align: inherit;">Pour terminer cette tâche, il est nécessaire de préparer à nouveau l'ensemble de données, mais avec un intervalle cible différent.</font></font><br>
<br>
<pre><code class="python hljs">future_target = <span class="hljs-number">72</span>
x_train_multi, y_train_multi = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<font></font>
                                                 TRAIN_SPLIT, past_history,<font></font>
                                                 future_target, STEP)<font></font>
x_val_multi, y_val_multi = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>],<font></font>
                                             TRAIN_SPLIT, <span class="hljs-literal">None</span>, past_history,<font></font>
                                             future_target, STEP)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vérifiez la sélection.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history : {}'</span>.format(x_train_multi[<span class="hljs-number">0</span>].shape))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'\n Target temperature to predict : {}'</span>.format(y_train_multi[<span class="hljs-number">0</span>].shape))
</code></pre><br>
<code>Single window of past history : (120, 3)<br>
<br>
Target temperature to predict : (72,)<br>
</code><br>
<pre><code class="python hljs">train_data_multi = tf.data.Dataset.from_tensor_slices((x_train_multi, y_train_multi))<font></font>
train_data_multi = train_data_multi.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_data_multi = tf.data.Dataset.from_tensor_slices((x_val_multi, y_val_multi))<font></font>
val_data_multi = val_data_multi.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addition: la différence dans la formation du vecteur cible pour le «modèle d'intervalle» du «modèle ponctuel» est visible dans la figure suivante. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/190/5c6/845/1905c6845d2746a1f0bc6ae88f913b99.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous préparerons la visualisation.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multi_step_plot</span>(<span class="hljs-params">history, true_future, prediction</span>):</span>
  plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<font></font>
  num_in = create_time_steps(len(history))<font></font>
  num_out = len(true_future)<font></font>
<font></font>
  plt.plot(num_in, np.array(history[:, <span class="hljs-number">1</span>]), label=<span class="hljs-string">'History'</span>)<font></font>
  plt.plot(np.arange(num_out)/STEP, np.array(true_future), <span class="hljs-string">'bo'</span>,<font></font>
           label=<span class="hljs-string">'True Future'</span>)
  <span class="hljs-keyword">if</span> prediction.any():<font></font>
    plt.plot(np.arange(num_out)/STEP, np.array(prediction), <span class="hljs-string">'ro'</span>,<font></font>
             label=<span class="hljs-string">'Predicted Future'</span>)<font></font>
  plt.legend(loc=<span class="hljs-string">'upper left'</span>)<font></font>
  plt.show()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur ce graphique et les graphiques similaires suivants, l'historique et les données futures sont horaires.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> train_data_multi.take(<span class="hljs-number">1</span>):<font></font>
  multi_step_plot(x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>], np.array([<span class="hljs-number">0</span>]))
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/245/beb/236/245beb236bc1f87f2d611ce8d2c0bc81.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme cette tâche est un peu plus compliquée que la précédente, le modèle consistera en deux couches LSTM. </font><font style="vertical-align: inherit;">Enfin, puisque 72 prédictions sont effectuées, la couche de sortie comprend 72 neurones.</font></font><br>
<br>
<pre><code class="python hljs">multi_step_model = tf.keras.models.Sequential()<font></font>
multi_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">32</span>,<font></font>
                                          return_sequences=<span class="hljs-literal">True</span>,<font></font>
                                          input_shape=x_train_multi.shape[<span class="hljs-number">-2</span>:]))<font></font>
multi_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">16</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
multi_step_model.add(tf.keras.layers.Dense(<span class="hljs-number">72</span>))<font></font>
<font></font>
multi_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(clipvalue=<span class="hljs-number">1.0</span>), loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous vérifierons notre échantillon et en déduirons les courbes de perte aux étapes de la formation et de la vérification.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_multi.take(<span class="hljs-number">1</span>):
  <span class="hljs-keyword">print</span> (multi_step_model.predict(x).shape)
</code></pre><br>
<code>(256, 72)<br>
</code><br>
<pre><code class="python hljs">multi_step_history = multi_step_model.fit(train_data_multi, epochs=EPOCHS,<font></font>
                                          steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                                          validation_data=val_data_multi,<font></font>
                                          validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 21s 103ms/step - loss: 0.4952 - val_loss: 0.3008<br>
Epoch 2/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.3474 - val_loss: 0.2898<br>
Epoch 3/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.3325 - val_loss: 0.2541<br>
Epoch 4/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.2425 - val_loss: 0.2066<br>
Epoch 5/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.1963 - val_loss: 0.1995<br>
Epoch 6/10<br>
200/200 [==============================] - 18s 90ms/step - loss: 0.2056 - val_loss: 0.2119<br>
Epoch 7/10<br>
200/200 [==============================] - 18s 91ms/step - loss: 0.1978 - val_loss: 0.2079<br>
Epoch 8/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.1957 - val_loss: 0.2033<br>
Epoch 9/10<br>
200/200 [==============================] - 18s 90ms/step - loss: 0.1977 - val_loss: 0.1860<br>
Epoch 10/10<br>
200/200 [==============================] - 18s 88ms/step - loss: 0.1904 - val_loss: 0.1863<br>
</code><br>
<pre><code class="python hljs">plot_train_history(multi_step_history, <span class="hljs-string">'Multi-Step Training and validation loss'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/479/600/430/4796004305bd5b839ead7c35120ddc69.png" alt="image"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Réalisation d'une prédiction d'intervalle</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Alors, découvrons avec quel succès un ANN formé peut faire face aux prévisions des valeurs de température futures.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_multi.take(<span class="hljs-number">3</span>):<font></font>
  multi_step_plot(x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>], multi_step_model.predict(x)[<span class="hljs-number">0</span>])
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/a3a/2fa/3cd/a3a2fa3cd17ec79c04d9ab44a3d3ad2c.jpg" alt="image"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prochaines étapes</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce guide est une brève introduction à la prévision de séries chronologiques utilisant RNS. Maintenant, vous pouvez essayer de prédire le marché boursier et devenir milliardaire </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dans l'original, juste comme ça :). - Remarque traducteur)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, vous pouvez écrire votre propre générateur pour préparer les données au lieu de la fonction </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uni / multivariate_data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afin d'utiliser la mémoire plus efficacement. Vous pouvez également vous familiariser avec le travail de « </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fenêtrage de séries chronologiques</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> » et apporter ses idées à ce guide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour une meilleure compréhension, il est recommandé de lire le chapitre 15 du livre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Apprentissage automatique de la machine avec Scikit-Learn, Keras et TensorFlow»</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Aurelien Geron, 2e édition) et le chapitre 6 du livre</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Deep Learning in Python»</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (François Scholl). </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajout final </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout en restant à la maison, prenez soin non seulement de votre santé, mais prenez aussi pitié de l'ordinateur en exécutant des exemples du manuel sur un ensemble de données tronqué. </font><font style="vertical-align: inherit;">Par exemple, en tenant compte de la proportion de 70x30 (formation / tests), vous pouvez la limiter comme suit:</font></font></i><br>
<br>
<pre><code class="python hljs">dataset = features[<span class="hljs-number">300000</span>:].values<font></font>
TRAIN_SPLIT = <span class="hljs-number">85000</span></code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr495850/index.html">La vie quotidienne des Scrum-Masters: équipe et auto-transformation</a></li>
<li><a href="../fr495852/index.html">LDA sur les articles LiveJournal + visualisation</a></li>
<li><a href="../fr495854/index.html">Comment échapper à Covid et à la surveillance?</a></li>
<li><a href="../fr495856/index.html">Intel DevCloud pour oneAPI - un service cloud pour les développeurs assis à la maison</a></li>
<li><a href="../fr495858/index.html">À distance et auto-isolement: une expérience spatiale pour aider les terriens</a></li>
<li><a href="../fr495888/index.html">PyCon Russie a ouvert CFP pour les futurs conférenciers. Formulaires de participation et sujets attendus</a></li>
<li><a href="../fr495890/index.html">Configuration d'un ensemble Nginx / LetsEncrypt dans Docker Swarm</a></li>
<li><a href="../fr495892/index.html">Savez-vous vraiment ce que sont les tableaux?</a></li>
<li><a href="../fr495894/index.html">Javascript Performance Measurement</a></li>
<li><a href="../fr495896/index.html">Package Use-sound: Effets sonores dans les applications React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>