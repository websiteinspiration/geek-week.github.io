<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📄 🗨️ 🕌 Recherche rapide de fichiers 🧕🏼 👼🏻 👩🏽‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="D'un traducteur: j'attire votre attention sur la traduction d'un très ancien article publié le 15 janvier 1983. Malgré un âge aussi impressionnant, l'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Recherche rapide de fichiers</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501226/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'un traducteur: j'attire votre attention sur la traduction d'un très ancien article publié le 15 janvier 1983. </font><font style="vertical-align: inherit;">Malgré un âge aussi impressionnant, l'article m'a paru intéressant et il est possible qu'il soit utile à quelqu'un aujourd'hui. </font><font style="vertical-align: inherit;">Cet article, en passant, est référencé dans la section d'aide de man Locate (1) sur opennet.ru: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.opennet.ru/man.shtml?topic=locate</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dq/aa/o7/dqaao7k_sxha8y9dwfcmzkkz7bc.jpeg"></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sommaire</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article décrit un mécanisme de recherche de fichiers rapide sous UNIX. Il combine deux méthodes de compression de données avec une nouvelle technique de recherche de ligne et est conçu pour rechercher rapidement des fichiers arbitraires. Le code, intégré à l'utilitaire de recherche standard, recherche la base de données précédemment créée, mise à jour quotidiennement. Cela le distingue du mécanisme habituel de recherche de correspondances clés avec les candidats, qui sont générées à la volée à partir d'une structure de répertoire dispersée (sur disque).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La base de données des chemins d'accès aux fichiers est une liste codée de manière incrémentielle et triée lexicographiquement (parfois appelée fichier «compressé de face»), qui est également soumise à un codage bigramique régulier afin d'obtenir une compression efficace. </font><font style="vertical-align: inherit;">Le taux de compression est de 5 à 6 par rapport à la représentation ASCII habituelle. </font><font style="vertical-align: inherit;">La liste est analysée à l'aide d'une recherche linéaire modifiée, spécialement adaptée au codage incrémentiel, tandis que le temps typique passé par l'algorithme est de 40 à 50% inférieur à une recherche régulière.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La recherche de fichiers dans un système informatique ou un réseau informatique est un processus complexe. Les utilisateurs UNIX peuvent l'implémenter de diverses manières, de la manipulation des commandes cd, ls et grep aux commandes spécialisées, telles que celles développées par Berkeley whereis et fleese, et à la commande find Unix plus courante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fleece</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (de Berkeley) est limité au répertoire personnel, et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">whereis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne peut rechercher que le code système et la documentation situés dans des emplacements standard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chercher:</font></font><br>
<br>
<pre><code class="bash hljs">find / -name <span class="hljs-string">"*&lt;filename&gt;*"</span> -<span class="hljs-built_in">print</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bien sûr, il peut rechercher des fichiers arbitraires, mais très lentement, car il utilise une descente récursive dans tout le système de fichiers, impitoyablement dispersée sur le disque. </font><font style="vertical-align: inherit;">L'impatience nous a incités à développer une recherche alternative (par rapport à la méthode «chercher et trouver») de chemins d'accès aux fichiers.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculs préliminaires</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi ne pas simplement construire une liste statique de tous les fichiers du système et rechercher grep dessus? </font><font style="vertical-align: inherit;">Un système typique contenant 20 000 fichiers contiendra 1 000 blocs de noms de fichiers, même si vous raccourcissez / usr en / u. </font><font style="vertical-align: inherit;">Grep sur notre système PDP-11/70 non chargé traite 30 à 40 blocs par seconde, et il faudra une demi-minute pour numériser. </font><font style="vertical-align: inherit;">Ce n'est pas acceptable pour une commande couramment utilisée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais si nous faisons un petit sacrifice - l'impossibilité de rechercher des fichiers de moins d'un jour, cela ne créera pas de gros problèmes, car celui qui a créé un tel fichier est probablement à portée de main, ou peut-être que le fichier n'est pas encore prêt utilisation. </font><font style="vertical-align: inherit;">Les fichiers plus anciens créés par d'autres groupes d'utilisateurs avec différentes conventions de dénomination de fichier sont les candidats à la recherche les plus probables.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compression</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour accélérer l'accès aux applications, vous pouvez suggérer d'utiliser une recherche binaire ou une table de hachage, mais de tels schémas ne fonctionnent pas bien pour les comparaisons partielles, si nous ne sommes intéressés que par une partie du nom. </font><font style="vertical-align: inherit;">La technique de compression ordonnée des données, connue sous le nom de codage incrémental, qui a été utilisée pour une tâche de compression de dictionnaire similaire est facilement mise en œuvre [Morris / Thompson, 1974]. </font><font style="vertical-align: inherit;">Dans ce cas, le préfixe le plus long du nom précédent est calculé. </font><font style="vertical-align: inherit;">Par exemple:</font></font><br>
<br>
<pre><code class="bash hljs">/usr/src<font></font>
/usr/src/cmd/aardvark.c<font></font>
/usr/src/cmd/armadillo.c<font></font>
/usr/tmp/zoo</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
converti en </font></font><br>
<br>
<pre><code class="bash hljs">0/usr/src<font></font>
8/cmd/aardvark.c<font></font>
14armadillo.c<font></font>
5tmp/zoo</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le décodage sera simple (déclarations de variables omises)</font></font><br>
<br>
<pre><code class="cpp hljs">fp = fopen(COMPRESSED_FILELIST, <span class="hljs-string">"r"</span>);
<span class="hljs-keyword">while</span>((count = (getc(fp) &amp; <span class="hljs-number">0177</span>)) != EOF) {
    <span class="hljs-keyword">for</span>(p = path + count; (*p++ = getc(fp)) &lt; <span class="hljs-number">0200</span>; )<font></font>
        ; <span class="hljs-comment">/*overlay old path with new*/</span><font></font>
    ungetc(*--p, fp);<font></font>
    *p-- = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">if</span>(math(path, name) == YES)
        <span class="hljs-built_in">puts</span>(path);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
où math est une fonction qui détermine si la sous-chaîne de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nom</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est contenue </font><font style="vertical-align: inherit;">dans la chaîne de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chemin d'accès</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, comme la liste codée est environ cinq fois plus courte que la liste non codée et que le décodage est très simple, le programme s'exécute trois à quatre fois plus rapidement que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grep</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur le fichier texte.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Même plus vite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette approche est déjà utile, mais laisse place à de nouvelles améliorations. </font><font style="vertical-align: inherit;">(Remarque: ce code est utilisé dans l'utilitaire find. Il n'est pas nécessaire de charger UNIX avec une autre commande [et une page de manuel] lorsque nous pouvons améliorer un programme similaire existant. Heureusement, il n'y a pas d'appel find avec deux arguments, et nous pouvons remplir le vide sans embellissement :</font></font><br>
<br>
<pre><code class="bash hljs">find name</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notez que le code ci-dessus recherche toujours la liste décompressée, bien qu'en mémoire, pas sur le disque. Cela peut être évité en comparant une chaîne avec une sous-chaîne dans le sens opposé. Laissez namend pointer vers le dernier caractère du </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nom</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la chaîne </font><font style="vertical-align: inherit;">et remplacez </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">math</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> par:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span>(s = p, cutoff = path + count; s &gt; cutoff; s--) {
    <span class="hljs-keyword">if</span>(*s == namend) { <span class="hljs-comment">/*quick first char check*/</span>
        <span class="hljs-keyword">for</span>(p = namend - <span class="hljs-number">1</span>, q = s - <span class="hljs-number">1</span>; *p != <span class="hljs-literal">NULL</span>; p--, q--)
            <span class="hljs-keyword">if</span>(*q != *p)
                <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">if</span>(*p == <span class="hljs-literal">NULL</span>) {
            <span class="hljs-built_in">puts</span>(path);
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est plus facile à comprendre en examinant trois cas. </font><font style="vertical-align: inherit;">Si la sous-chaîne est complètement à droite de la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coupure</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , la comparaison se terminera avec succès. </font><font style="vertical-align: inherit;">S'ils se chevauchent, la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coupure</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devient «douce» et la comparaison se poursuit. </font><font style="vertical-align: inherit;">Si la sous-chaîne se trouve complètement à gauche de la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coupure</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , alors une correspondance serait révélée pour les lignes précédentes, ce qui signifie que nous ne pouvons pas effectuer cette recherche! </font><font style="vertical-align: inherit;">Techniquement, la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coupure</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut être portée sur le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chemin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> immédiatement après la comparaison. </font><font style="vertical-align: inherit;">Cette condition est omise ci-dessus.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Équipement à deux niveaux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez éviter de ralentir la recherche provoquée par le traitement </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> caractères du </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">modèle de recherche</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ce faisant, nous traitons la partie du nom qui ne contient pas de métacaractères et utilisons la fonction récursive plus lente qui se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trouve</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">C'est à dire,</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">puts</span>(path)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
devient</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(globchars == NO | amatch(path, name))
    <span class="hljs-built_in">puts</span>(path);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
où </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">globchars est</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> défini si le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nom</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contient des métacaractères. </font><font style="vertical-align: inherit;">Un exemple d'utilisation d'un modèle de recherche pour une commande </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">man</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simple </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="bash hljs">vtroff -man <span class="hljs-string">'find '</span>*man*<span class="hljs-string">'"$1"'</span>.[1-9]</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Améliorations supplémentaires</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code de production de l'utilitaire find augmente le taux de compression de 20 à 25% supplémentaires en remplaçant les combinaisons de deux caractères les plus courantes par des codes ASCII non imprimables. </font><font style="vertical-align: inherit;">".c" et ".P" sont particulièrement courants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'autres algorithmes qui implémentent d'autres compromis entre le temps et la taille des données, comme l'algorithme de Huffman [Reghbati, 1981], ne semblent pas prometteurs: ils remplacent simplement la limite de performance d'E / S par la limite de performance. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des méthodes de recherche sous-linéaire de Boyer-Moore [Boyer, 1977] ou des méthodes de macro-modèle [Storer / Szymanski, 1982] peuvent être utilisées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conclusion, il convient de noter que nous avons scanné 19 000 noms de fichiers en quelques secondes, en utilisant 180 blocs et un code C qui tient sur deux pages.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Références</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Boyer, RS Un algorithme de recherche de chaîne rapide, Commun. </font><font style="vertical-align: inherit;">ACM, vol. </font><font style="vertical-align: inherit;">20, no 10, octobre 1977. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Morris, R. et Thompson, K. Webster's Second on the Head of a Pin, note technique non publiée, Bell Laboratories, Murray Hill, NY, 1974. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reghbati, HK An Overview of Data Compression Techinques, Computer, Vol. </font><font style="vertical-align: inherit;">14, non </font><font style="vertical-align: inherit;">4, avril 1981. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Storer, JA et Szymanski, TG Data Compression via Textual Substitution, J. ACM, Vol. </font><font style="vertical-align: inherit;">29, non </font><font style="vertical-align: inherit;">4, octobre 1982.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr501212/index.html">Réalisation d'animation squelettique pour des modèles tridimensionnels</a></li>
<li><a href="../fr501214/index.html">Agrégation groupée chez les pandas</a></li>
<li><a href="../fr501220/index.html">Analyse: une entreprise peut-elle avoir trop d'argent?</a></li>
<li><a href="../fr501222/index.html">Application de COBIT lors de l'élaboration d'une stratégie informatique</a></li>
<li><a href="../fr501224/index.html">Quels réseaux de neurones peuvent «chanter» et interpréter le death metal</a></li>
<li><a href="../fr501232/index.html">Comment un expert informatique peut-il gagner plus sur ses connaissances</a></li>
<li><a href="../fr501234/index.html">Routage rapide et NAT sous Linux</a></li>
<li><a href="../fr501236/index.html">Alors, de quoi s'agit-il, le «repliement des protéines»?</a></li>
<li><a href="../fr501240/index.html">Audit de sécurité du site</a></li>
<li><a href="../fr501244/index.html">Le programmeur n'a pas à résoudre les problèmes commerciaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>