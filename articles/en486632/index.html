<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🏫 🧜🏾 🧦 Mental Reactive Programming Models for Supervisors 🖐🏾 🤑 👨🏽‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is intended for a wide range of readers who would like to know what Reactive Programming is. The purpose of this article is to formulate ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Mental Reactive Programming Models for Supervisors</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486632/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="> <img src="https://habrastorage.org/webt/ez/hr/x0/ezhrx0ymj-ak_tdpfqhioagb3su.jpeg"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This article is intended for a wide range of readers who would like to know what Reactive Programming is. </font><font style="vertical-align: inherit;">The purpose of this article is to formulate in you the basic Mental Models of Reactive Programming (MM RP) without going into technical details.</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disclaimer</font></font></b><div class="spoiler_text"> ( ) —    ,   .     ,                     .<br>
   ,      :            ,          . ,      ,     .<br>
          .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But first, let’s explain what the mental models and superiors mentioned in the heading of the article have to do with it ...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About Mental Models</font></font></b><div class="spoiler_text">  ,  ,         ,       .     ,       .<br>
            ,         ,    (. [1], [2])<br>
    ?  ,    ,                   .      (),   ,      ,   .      ,    ,    «», «»     « »    .<br>
    ,   ,       (),     ,      -  ().</div></div> <br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here are the bosses ...</font></font></b><div class="spoiler_text">        .            «»  «»     ,            :   . (  ,  «»    ,      ).<br>
  ,   «»  ,     ,      ,  ,    , . ,          .   «»        «».      ,  ,    ,         .<br>
    ,    ,           ,   ..,       () — ,   ,            .<br>
 ,              .</div></div> <br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why does Reactive Programming need your project?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Many people unfamiliar with RP are initially skeptical of him, suspecting that this is just another empty fashion, covered in a couple of beautiful words. </font><font style="vertical-align: inherit;">Especially when they learn that you can evaluate RP only by trying it. </font><font style="vertical-align: inherit;">And to try it is expensive, because of the high entry threshold. </font><font style="vertical-align: inherit;">We lived and lived with OOP, what is missing from it? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let me introduce my point of view on this subject.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the dawn of Programming, when most programs were written directly in assembly language, the main working concept (an element of the Mental Model) of programmers was an instruction, or a language command. Some (primitive) data is fed to the input of a command or instruction. The instruction processes and issues some output data. The appearance of the first procedural programming languages ​​such as Fortran did not change the essence of the matter. Just the data and the operations performed (as a sequence of elementary commands) have become more complicated. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Over time, it became clear that this concept is not very consistent with the realities of the world. There can be a lot of data, they can be difficult to structure. Both the data and the functionality around them would be nice to split into parts, to develop and maintain separately, and use together.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOP solved these problems in many ways. The unit of the Mental Model of a typical OOP programmer is an object with data hidden (encapsulated) in it and an access interface to this data as a set of functions. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOP has played a huge role in the automation and computerization of many manufacturing and other processes. And along with this, his weaknesses were exposed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, in OOP there is no concept of a process as such. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
They tried to improve the situation in different ways, concentrating on various aspects. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, Event-Driven Programming [3], Dataflow-programming [4], Stream processing [5] and several other paradigms were born. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I would venture to arouse a stream of criticism of the adherents and experts on these paradigms, trying to convey in simple words their general essence.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One way or another, these paradigms operate with information flows. At the same time, Event-Driven Programming, as the name suggests, focuses on the process of the emergence of information flow elements, Dataflow programming - on flow control (splitting, merging, transformation of flows) and Stream processing on the optimal use of resources in processing flows.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reactive Programming is about the same thing, but with a focus on the specific elementary operations of creating, managing and using threads. Those. RP describes how your system reacts (English react) to elements of the information flow. In this sense, it would be more correct in Russian to use the term “Reagent Programming” (from the word “react”) or “Reaction Programming” (from the word “reaction to something”) if it weren’t for the ear to cut, and the second did not cause incorrect associations. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I would venture to express another seditious thought. What we today call in English Reactive Programming (Reactive Programming). called so for historical reasons and inclined in favor of this term the majority opinion.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This paradigm could have been called differently. </font><font style="vertical-align: inherit;">Therefore, do not focus on its current name, but try to understand its essence. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And although I will talk about RP at a fairly abstract level, I will cite the RxJS library APIs as concrete examples. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The acronym RxJS stands for Reactive Extension for JavaScript, a JavaScript extension for Reactive Programming features. </font><font style="vertical-align: inherit;">Similar extensions exist for many other programming languages, as can be seen in the picture below, taken from [6].</font></font><br>
<img src="https://habrastorage.org/webt/ii/gb/ji/iigbjinggcawbioey0iz7ztarzs.png" alt="Reactive programing extensions"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why do Mental Models of RP need your project</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Big projects are not done alone. You can often read or hear that project participants must speak the same language. My experience shows that this is hardly necessary and possible. But what is needed is for the most basic concepts of the project to be stated and understood by the project participants as equally as possible. In terms of Mental Models (MM), we can say that upper-level MMs should be as similar as possible. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But how can they be similar if analysts think in terms of Workflow and Use Cases, architects in patterns, developers in functions and data structures, and testers in test scenarios?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I do not urge all these specialists to start thinking at the same time with the categories of Reactive Programming, but I can promise them that acquaintance with these categories will simplify and increase the effectiveness of their professional communication with colleagues. </font><font style="vertical-align: inherit;">This should happen because, on the one hand, MM RPs have the power necessary to describe complex Workflows, and on the other hand, MM RPs can be directly converted to code in many programming languages.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surprises, dangers, or that in RP is not the way we are all used to </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But before we get into the description of what the Mental Models of Reactive Programming consist of, based on our own experience, I would like to warn the reader about what is not in them. </font><font style="vertical-align: inherit;">Moreover, not just not, but the very expectation of simple and understandable OOP behavior in the world leads to sad consequences. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I’m doing this not to intimidate, but rather to intrigue the reader.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Difference 1: Instead of a cursor model, a computational graph</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I’ll venture to suggest that many readers, when thinking over the next task to be realized, have a mental model in their head, which I call the cursor model. </font><font style="vertical-align: inherit;">It assumes that a step-by-step algorithm in the form of a linear list of instructions will be invented to solve the problem. </font><font style="vertical-align: inherit;">The execution of the algorithm is reduced to the step-by-step execution of the instructions one after another. </font><font style="vertical-align: inherit;">You can imagine something like a pointer to the currently executing instruction. </font><font style="vertical-align: inherit;">After the instruction is executed, the pointer (cursor) moves to the next instruction in the list and it starts to execute. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Within this model, a sequence of commands written in a conditional object-oriented programming language</font></font><br>
<pre><code class="xml hljs">1. 1 = 2<font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2<font></font>
4.  1, 2, 3<font></font>
5. 1 = 4<font></font>
6.  1, 2, 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
will give the result</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our cursor mental model perfectly predicts and explains such a result. </font><font style="vertical-align: inherit;">After processing the third line, the value X3 is set and the new value for X1 specified in line 5 cannot change it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the world of RP, depending on the interpretation of the “+” operation, the result will most likely be this</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 7</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this world, most operations connect input parameters to each other, thereby creating computational graphs through which calculations are “pushed” when one or more parameters are changed.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Difference 2: Asynchronous operations</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the framework of the cursor mental model of calculations, the next operation cannot begin earlier than the previous one. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider the following example. </font><font style="vertical-align: inherit;">Suppose that the function f1 calculates the base salary by the value of the user identifier userId, and the function f2 calculates the bonus based on userId and the value of the salary. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then the calculation of the full salary may look like this</font></font><br>
<pre><code class="xml hljs">1. X = f1(userId)<font></font>
2. Y = f2(userId, X)<font></font>
 X, Y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose a staff member has a base salary of 10,000. </font><font style="vertical-align: inherit;">and a bonus of 1000 units. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our cursor mental model tells you what to print.</font></font><br>
<pre><code class="xml hljs">10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alas, in the world of asynchronous RP, the result may, depending on the duration of operations, be</font></font><br>
<pre><code class="xml hljs">0 0 <font></font>
10000 0 <font></font>
0 1000 <font></font>
10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(I do not consider exceptions yet). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The thing is that in the asynchronous-reactive world, the next operation does not wait for the end of the previous, if it is previous) asynchronous. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To illustrate this, let's look at some important details using the realistic example shown in the figure below. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The picture shows the execution time of four instructions L1, L2, L3 and L4 that are independent of each other (their numbers are important to us, not the spelling) in synchronous (upper part of the picture) and asynchronous (lower part of the picture) modes.</font></font><br>
<img src="https://habrastorage.org/webt/vb/s5/rb/vbs5rbmbwmrmmhqtw7gtx9tivzc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As we see, in the first case, each subsequent instruction "waits" for the end of the previous one. </font><font style="vertical-align: inherit;">In the asynchronous case, all instructions begin to be executed simultaneously. </font><font style="vertical-align: inherit;">Due to the parallel execution and use of resources, most instructions run in asynchronous mode longer than in synchronous mode. </font><font style="vertical-align: inherit;">However, together they will bequeath their work earlier. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The order of completion of the instructions in both modes is also very different. </font><font style="vertical-align: inherit;">In synchronous it:</font></font><pre><code class="javascript hljs">L1, L2, L3, l4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> but in asynchronous: </font></font><pre><code class="javascript hljs">L3, L2, L1, L4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Difference 3: Incomplete chains (without consumer) do not work at all</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In many traditional programming languages, it is common to associate function calls or object properties with dots. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, the following JavaScript function call chain turns the word “good” into “dog”:</font></font><br>
<pre><code class="javascript hljs">„good“.split(„“).reverse().join(„“).replace(„oo“, „o“);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sequences (chains) can be long. </font><font style="vertical-align: inherit;">For reasons of reuse or convenience, they can be cut into pieces and partially performed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Splitting a chain in RP into two parts and calling only one of them usually leads to a lack of result, since only the full chain (with the consumer at the end) is performed.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why all this?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probably, many readers are already asking themselves the question, “Have they not gone crazy collectively, these reactive programmers? Why is it needed, such programming? ” </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I do not presume to predict what the creators and experts of the Republic of Poland would answer this question, but my answer is this: such programming is necessary, because many objects of the real world behave just like that. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computing graphs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - this is what Excel is built on, from which not only accountants, but also project managers are delighted. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous operations</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . When you make coffee or make tea in your kitchen, do you stand in the kitchen all this time and look at your coffee pot or teapot? No. The device boils water and does its job, while you are doing something else for now. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complete chain of operations.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Try unplugging your desk lamp from the wall outlet and pushing the switch. </font><font style="vertical-align: inherit;">The lamp does not light up from this. </font><font style="vertical-align: inherit;">This object works only if there is a complete chain - from the source to the consumer of electricity. </font><font style="vertical-align: inherit;">And there are many, if not most, of such objects in the real world. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I want to reassure you, your knowledge of traditional programming and cursor MM should not be thrown into the trash due to the appearance of RP. </font><font style="vertical-align: inherit;">Reactive programming left them alone and expanded them with new operations on new types of objects. </font><font style="vertical-align: inherit;">How - we’ll talk about this later.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Space of Mental Models Programming and the place of MM RP in it</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Speaking about the place of RP in the general landscape of Programming, authors often mention two dimensions - the complexity of the processed objects and the synchronism / asynchrony of operations. </font><font style="vertical-align: inherit;">An example of such a classification can be found in the book “RxJS in Action” [7], in the chapter “When and where to use RxJS”. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this classification, the dimension of objects is divided into single objects and multi-objects: arrays, lists, etc. </font><font style="vertical-align: inherit;">Operations are divided into synchronous and asynchronous. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, this classification divides the programming world into four areas. </font><font style="vertical-align: inherit;">RP is one of these areas responsible for processing multi-objects with asynchronous operations. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I find this classification very interesting, but I would like to look at it from the point of view of mental models. </font><font style="vertical-align: inherit;">The table below presents them.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Single Values ​​and Objects</font></font></th>
<th>, ,    </th>
</tr>
<tr>
<td> </td>
<td>  </td>
<td>,  (Stream)</td>
</tr>
<tr>
<td> </td>
<td>,  (Promise)</td>
<td> (Workflow)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We assume that the mental models of instructions and the cursor do not require further explanation. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The cycle</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is an extension of MM instructions and the cursor due to the additional instructions of the cycle or return to some point. This allows a set of processing instructions for a single object to “wrap” in a loop, and thereby process many such objects. In this case, the cursor moves inside the cycle as in the previous model, and having reached the transition point, it either jumps to the beginning or the processing of the cycle stops if all objects are processed. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jet.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The difference between this mental model and the previous one is that the cursor </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pointing to the object being processed remains in place, and the objects themselves “run over” it.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at this with two examples. If you paint a wooden fence, you, by analogy with the cursor model, go from board to board. But the worker on the conveyor remains in place and, by analogy with the jet model, the parts to be processed themselves approach it. Such objects are often referred to by the term English Stream, for example, in the Java language. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semaphore.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This MM is easiest to associate with a traffic light at an intersection. Asynchronous objects periodically poll the state of a public variable and perform certain actions after changing its state. (like drivers in front of a traffic light) </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waiting.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A suitable metaphor for this Mental Expectation Model is the letter on paper or Emall that you expected when you last got your job. There may be a positive or negative answer. Your behavior after receiving the letter very much depends on its content. The English term Promise is often used to describe these kinds of objects. That, from the point of view of the user is an expectation, for the contractor providing the services, it is rather a promise. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As we see from the description, movement along each dimension (from top to bottom or from right to left in the table) means a qualitative change in the Mental Model.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As can be seen from the table, the jets and expectations are neighbors on the left and on the top of the southeastern cell of interest to us. </font><font style="vertical-align: inherit;">What is new in the Mental Models of Flows inhabiting the cell of interest to us compared to them?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the extension?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The expansion of Streams in comparison with Expectations is that the expected information can arrive not once, but in many portions. In this case, the process may end without ending. Those. after a series of successful servings, we will receive an error notification. In addition, another version of the information is added - a notification of the end of the process. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This means, for example, that it is possible to receive several (but not all) portions of the expected information and (without an error message) a message about the end of processing. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recall again, with Waiting, we have only two alternative options for the resulting information. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Mental Jet Model is well suited to comprehend, discuss, and implement the process of transforming a sequence of objects of the same type. MM Stream expands it with the following aspects:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There can be many jets and we can merge them together</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The jets may be heterogeneous</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can split the jets into new ones according to different criteria</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can “close” and / or transform them into new ones within the framework of one stream. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we determined the place of MM RP (Streams) in the space or landscape of the objects of Programming. </font><font style="vertical-align: inherit;">Let’s now lower a bird’s eye view and take a closer look at Streams and their Mental Models.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streams and phases of their life cycle</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a first approximation, RP flows can be imagined as water flows in water pipes or electricity flows. </font><font style="vertical-align: inherit;">It should be remembered that like any other analogy, this analogy has its limits and is not always applicable. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Speaking about the flow, the following important aspects can be distinguished:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each thread somehow arises</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">He is somehow moving towards the consumer.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Something happens on the way with him (he transforms)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can be split into several streams or merged with other streams</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The consumer somehow uses the flow, ceasing to exist.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The listed aspects are simultaneously phases of the life cycle of individual elements of the flow. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's consider them in more detail using the example of RxJS functions.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread creation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streams can be created from passive elements such as an array or a list of objects in your program, bytes, file lines, etc. This kind of stream sources is called cold (although technically there is a more accurate definition of cold stream sources). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The so-called hot springs "live their own lives" and if you do not connect to them in time, the information will be lost. This category includes information about user actions on a computer, tablet, smartphone, for example, information about keystrokes, mouse movements or touching the screen. Also in this category are data requested by various protocols such as HTTP, data from various sensors.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It should be noted that there are so-called “warm” springs. </font><font style="vertical-align: inherit;">In addition, some “hot” springs can be “cooled”, and “cold” can be “warmed up”. </font><font style="vertical-align: inherit;">But you should read about this in special literature, for example, in the book [7]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is important for us to know that all operations of creating flows create objects of the same type, which can be further processed by the same operations, regardless of content. </font><font style="vertical-align: inherit;">In this article, we call these objects streams. </font><font style="vertical-align: inherit;">The corresponding English name is Observable.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consumer movement and flow transformation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flow transformation operations can be carried out both on the way to the consumer and by himself. </font><font style="vertical-align: inherit;">In both cases, the processing operations of the flow elements are strictly sequential, i.e. </font><font style="vertical-align: inherit;">the next operation is launched strictly only after the previous one has completed and passed its result to it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unlike Stream, which in some programming languages ​​are language constructs with their own syntax and semantics, reactive extensions like RxJS in JavaScript are forced to use the syntax and basic semantics of the extensible language. </font><font style="vertical-align: inherit;">Therefore, RxJs implements the pipe () function, inside which you can place calls to functions - handlers of both the stream itself and its individual elements. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is important to note that only special, pipeable, functions can be flow handlers.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Three-phase flow"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we continue the analogy with electricity, then the flows we are considering can be called three-phase. Along with the “normal wire” transmitting the basic information, there is also a “error wire” and a “stream termination wire”. Transformation operations allow not only changing the object, but also redirecting it to another “wire”. This technique is used, for example, when processing alleged errors in working with servers using the HTTP protocol. For example, if one server does not respond, you can try to request another without informing the user about the failure to request the first server.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is another very important element of your Mental Flow Model. </font><font style="vertical-align: inherit;">If in traditional programming paradigms the error is returned from the processing function as an error code or should be intercepted as an interruption (exception), then in the flows the error "flows" independent of the main channel. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There it can be processed. </font><font style="vertical-align: inherit;">For example, if a user has entered an incorrect password, they may be given an additional opportunity to try to enter it one or more times.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Splitting and merging flows</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The splitting of flows is carried out in two stages. At the first stage, empty threads are started. Then, in the second stage (stream processing stage), in one of the processing functions, the elements will be analyzed and redirected to the desired stream. Technically, there are many options for how to do this. For example, removing it from the current thread or cloning it before starting it in a new thread. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can merge multiple streams into one in a surprisingly large number of ways. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The simplest ways that come to mind are to merge them in the order of receipt, or first all from the first stream and then all from the second.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The method shown below in the picture allows one of two streams to form one containing ordered pairs of objects from the first and second flows. </font><font style="vertical-align: inherit;">In this case, a new pair is formed if a new element appears in one of the flows. </font><font style="vertical-align: inherit;">A contains a pair of strictly the last elements of each stream. </font><font style="vertical-align: inherit;">This leads to the fact that the same element can be included in several pairs. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The graphical notation used in this example is called Marble diagrams and is very effective in explaining the semantics of splitting and merging flows. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If this topic interests you, I advise you to study the operations and their Marble diagrams on the resource [8].</font></font><br>
<img src="https://habrastorage.org/webt/cw/q7/a1/cwq7a1t6omorptqk33hgm93yetw.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using streams</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to use the elements of the stream, the user or client must first subscribe to it. As a rule, at the end of processing, he should unsubscribe from it, since garbage collectors can not always automatically deactivate a subscription when they try to utilize a subscriber. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Many clients can subscribe to one thread. In RxJs, the subscription function is called subscribe (). In it, in most cases it is advisable to place processing calls of the "normal" elements of the stream, an error handler and (relatively rarely) a stream termination handler.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each of the subscribers to the stream receives its copy of the element or a clone of the original element. </font><font style="vertical-align: inherit;">In order not to cause problems, the stream is implemented in such a way that the elements received for processing become immutable. </font><font style="vertical-align: inherit;">In some situations, this limitation can still be circumvented, but it is better not to.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dangerous charm of streams</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streams are very complicated objects, somewhat akin to integrals in mathematics. It is one thing to know that they exist and even to roughly imagine what it is, and quite another to be able to use them. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Understanding the internal logic of their functioning, necessary to apply them well in practice, requires considerable intellectual effort. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streams are intrinsically closely related to functional programming. For the competent use of flows, it is useful to understand how it is possible to build and apply second-order functions - functions for which other functions serve as arguments. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then the beauty and elegance of the flows will be fully revealed to you. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streams are contagious. After comprehending their beauty, I want to use them in all tasks, which of course is not necessary.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In what tasks it is advisable to use flows, and where traditional methods should be used, everyone decides for himself.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summarize</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article I tried to tell you about the Mental Models of Reactive Programming (MM RP) and even partially put them in your Consciousness. </font><font style="vertical-align: inherit;">Let us repeat the main points again.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MM RP are special, not similar to the Mental Models of traditional Programming. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When embarking on Reactive Programming, we must remember that some well-established in other areas of the MM such as the cursor, call chains or loops do not work, or they do not work like that.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main Mental Model of RP is a “three-channel stream” with a channel for “normal” elements, errors and information about the end of the stream.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streams can be finite and infinite.</font></font></li>
<li>    «», «»  «» .   «»  «». </li>
<li>      .        (,       ).             .</li>
<li>     ,    .</li>
<li>       ,   .</li>
<li>       .        . </li>
<li>      ,  «».</li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you are interested in this topic, you can "play" with streams using the simulators available on the site [8]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you want to better understand the concepts of RP, I recommend that you work through the book [7], and of course, get acquainted with The Reactive Manifesto [11]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You will reach the next level in the formation of your own MM RP by working through books [9] and [10] on the design and modeling of reactive systems.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literature and references</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programming is the materialization of ideas. </font><font style="vertical-align: inherit;">(Article on Habr. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr.com/ru/post/425321</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sirotin V. RPSE: Reification as Paradigm of Software Engineering. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arxiv.org/abs/1810.01904</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event-driven programming. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.m.wikipedia.org/wiki/Event-driven_programming</font></font></a></li>
<li>Dataflow-programming. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Dataflow_programming</a></li>
<li>Stream-processing. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Stream_processing</a></li>
<li>Rx-Extensions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">reactivex.io/languages.html</a></li>
<li>RxJS in Action. – 4. August 2017. Paul P. Daniels (Autor), Luis Atencio. Manning Publications. ISBN-13: 978-1617293412</li>
<li>RxJS online Documentstion. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">xgrommx.github.io/rx-book/index.html</a></li>
<li>Reactive Design Patterns. 2017. Roland Kuhn Dr., Brian Hanafee, Jamie Allen. Manning Publications. ISBN-13: 978-1617291807</li>
<li>Functional and Reactive Domain Modeling. 2016. Debasish Ghosh.Manning Publications. ISBN-13: 978-1617292248</li>
<li>The Reactive Manifesto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">www.reactivemanifesto.org</a></li>
</ol><br>
<br>
<em> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">geralt</a></em></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en486614/index.html">Why eSIM is needed. How it works and why they talk so much about it</a></li>
<li><a href="../en486622/index.html">Parallel computing model</a></li>
<li><a href="../en486626/index.html">Svelte: getting to know Actions</a></li>
<li><a href="../en486628/index.html">Fixed distance between ticks on an axis in gnuplot</a></li>
<li><a href="../en486630/index.html">“Do not flicker in the eye”: how the technology of screen illumination of electronic readers is arranged</a></li>
<li><a href="../en486634/index.html">MSVC Backend updates in Visual Studio 2019 version 16.3 and 16.4</a></li>
<li><a href="../en486638/index.html">Blazor WebAssembly 3.2.0 Preview 1 is now available</a></li>
<li><a href="../en486640/index.html">The digest of interesting materials for the mobile developer # 331 (January 27 - February 2)</a></li>
<li><a href="../en486644/index.html">DIY antenna in 5 minutes</a></li>
<li><a href="../en486646/index.html">Get away from jQuery to Svelte, no pain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>