<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçõ üèôÔ∏è üíÉüèø Codegenerierung in Go am Beispiel des Erstellens eines Clients f√ºr die Datenbank üé∏ üßòüèΩ ‚úÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel m√∂chte ich die Probleme der Codegenerierung in Golang betrachten. Mir ist aufgefallen, dass in den Kommentaren zu Artikeln auf Go h√§...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Codegenerierung in Go am Beispiel des Erstellens eines Clients f√ºr die Datenbank</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501000/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Artikel m√∂chte ich die Probleme der Codegenerierung in Golang betrachten. </font><font style="vertical-align: inherit;">Mir ist aufgefallen, dass in den Kommentaren zu Artikeln auf Go h√§ufig die Generierung und Reflexion von Code erw√§hnt wird, was zu heftigen Debatten f√ºhrt. </font><font style="vertical-align: inherit;">Gleichzeitig gibt es auf dem Hub nur wenige Artikel zur Codegenerierung, die jedoch h√§ufig in Go-Projekten verwendet werden. </font><font style="vertical-align: inherit;">In dem Artikel werde ich versuchen, Ihnen zu erkl√§ren, was Codegenerierung ist, um den Anwendungsbereich anhand von Codebeispielen zu beschreiben. </font><font style="vertical-align: inherit;">Auch werde ich die Reflexion nicht ignorieren.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Codegenerierung verwendet wird</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf Habr√© gibt es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bereits gute Artikel zum Thema </font><font style="vertical-align: inherit;">, die ich nicht wiederholen werde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Codegenerierung sollte in folgenden F√§llen verwendet werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erh√∂hen der Geschwindigkeit des Codes, dh Ersetzen der Reflexion;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reduzierung der Routine eines Programmierers (und der damit verbundenen Fehler);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung von Wrappern nach den vorgegebenen Regeln.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anhand der Beispiele k√∂nnen wir die Stringer-Bibliothek betrachten, die im Standard-Sprachangebot enthalten ist und es Ihnen erm√∂glicht, automatisch String () -Methoden f√ºr S√§tze numerischer Konstanten zu generieren. </font><font style="vertical-align: inherit;">Mit ihm k√∂nnen Sie die Ausgabe von Variablennamen implementieren. </font><font style="vertical-align: inherit;">Beispiele der Bibliothek wurden in den obigen Artikeln ausf√ºhrlich beschrieben. </font><font style="vertical-align: inherit;">Das interessanteste Beispiel war die Ableitung des Farbnamens aus der Palette. </font><font style="vertical-align: inherit;">Durch die Anwendung der Codegenerierung wird vermieden, dass der Code beim √Ñndern der Palette an mehreren Stellen ge√§ndert wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anhand eines praktischeren Beispiels k√∂nnen wir die easyjson-Bibliothek von Mail.ru erw√§hnen. </font><font style="vertical-align: inherit;">Mit dieser Bibliothek k√∂nnen Sie die Ausf√ºhrung von masrshall / unmarshall JSON von / zur Struktur beschleunigen. </font><font style="vertical-align: inherit;">Ihre Implementierung in Benchmarks umging alle Alternativen. </font><font style="vertical-align: inherit;">Um die Bibliothek zu verwenden, m√ºssen Sie easyjson aufrufen. Sie generiert Code f√ºr alle Strukturen, die in der √ºbertragenen Datei gefunden werden, oder nur f√ºr diejenigen, f√ºr die der Kommentar // easyjson: json angegeben ist. </font><font style="vertical-align: inherit;">Nehmen Sie die Benutzerstruktur als Beispiel:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span>{<font></font>
    ID <span class="hljs-keyword">int</span>
    Login <span class="hljs-keyword">string</span>
    Email <span class="hljs-keyword">string</span>
    Level <span class="hljs-keyword">int</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºhren Sie f√ºr die Datei, in der sie enthalten ist, die Codegenerierung aus:</font></font><br>
<br>
<pre><code class="bash hljs">easyjson -all main.go</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Ergebnis erhalten wir Methoden f√ºr Benutzer:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MarshalEasyJSON (w * jwriter.Writer) - um die Struktur in ein JSON-Byte-Array zu konvertieren;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnmarshalEasyJSON (l * jlexer.Lexer) - zum Konvertieren von einem Array von Bytes in eine Struktur. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktionen MarshalJSON () ([] Byte, Fehler) und UnmarshalJSON (Daten [] Byte) Fehler sind f√ºr die Kompatibilit√§t mit der Standard-JSON-Schnittstelle erforderlich.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Easyjson-Code</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestEasyJSON</span><span class="hljs-params">()</span></span> {<font></font>
	testJSON := <span class="hljs-string">`{"ID":123, "Login":"TestUser", "Email":"user@gmail.com", "Level":12}`</span>
	JSONb := []<span class="hljs-keyword">byte</span>(testJSON)<font></font>
	fmt.Println(testJSON)<font></font>
	recvUser := &amp;User{}<font></font>
	recvUser.UnmarshalJSON(JSONb)<font></font>
	fmt.Println(recvUser)<font></font>
	recvUser.Level += <span class="hljs-number">1</span><font></font>
	outJSON, _ := recvUser.MarshalJSON()<font></font>
	fmt.Println(<span class="hljs-keyword">string</span>(outJSON))<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dieser Funktion konvertieren wir zuerst JSON in eine Struktur, f√ºgen eine Ebene hinzu und drucken den resultierenden JSON. </font><font style="vertical-align: inherit;">Die Codegenerierung durch easyjson bedeutet, die Laufzeitreflexion zu beseitigen und die Codeleistung zu steigern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Codegenerierung wird aktiv verwendet, um Microservices zu erstellen, die √ºber gRPC kommunizieren. Es verwendet das Protobuf-Format, um die Methoden der Dienste zu beschreiben - unter Verwendung der Zwischensprache EDL. Nach der Beschreibung des Dienstes wird der Protoc-Compiler gestartet, der Code f√ºr die gew√ºnschte Programmiersprache generiert. Im generierten Code erhalten wir die Schnittstellen, die auf dem Server implementiert werden m√ºssen, und die Methoden, die auf dem Client zum Organisieren der Kommunikation verwendet werden. Es stellt sich als sehr praktisch heraus, dass wir unsere Dienste in einem einzigen Format beschreiben und Code f√ºr die Programmiersprache generieren k√∂nnen, in der jedes der Interaktionselemente beschrieben wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Codegenerierung kann auch bei der Entwicklung von Frameworks verwendet werden. </font><font style="vertical-align: inherit;">Zum Beispiel, um Code zu implementieren, der nicht vom Anwendungsentwickler geschrieben werden muss, aber f√ºr den korrekten Betrieb erforderlich ist. </font><font style="vertical-align: inherit;">Zum Beispiel, um Formularfeldvalidatoren, automatische Middleware-Generierung und dynamische Generierung von Clients f√ºr das DBMS zu erstellen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go Code Generator Implementierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns in der Praxis untersuchen, wie der Mechanismus der Codegenerierung in Go funktioniert. Zun√§chst ist der AST - Abstract Syntax Tree oder Abstract Syntax Tree zu erw√§hnen. F√ºr Details k√∂nnen Sie zu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gehen </font><font style="vertical-align: inherit;">. F√ºr unsere Zwecke ist es notwendig zu verstehen, dass das gesamte Programm in Form eines Diagramms erstellt wird, in dem die Scheitelpunkte mit den Operatoren der Programmiersprache und die Bl√§tter mit den entsprechenden Operanden abgebildet (markiert) werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr den Anfang ben√∂tigen wir also Pakete: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">go / ast </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">go / parser / </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">go / token / Das</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Parsen der Datei mit dem Code und das Kompilieren des Baums erfolgt mit den folgenden Befehlen</font></font><br>
<br>
<pre><code class="go hljs"><font></font>
fset := token.NewFileSet()<font></font>
node, err := parser.ParseFile(fset, os.Args[<span class="hljs-number">1</span>], <span class="hljs-literal">nil</span>, parser.ParseComments)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir geben an, dass der Dateiname dem ersten Argument der Befehlszeile entnommen werden soll. Wir bitten au√üerdem, dem Baum Kommentare hinzuzuf√ºgen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen kann der Benutzer (der Entwickler des Codes, auf dessen Grundlage ein anderer Code generiert wird) zur Steuerung der Codegenerierung Kommentare oder Tags verwenden (w√§hrend wir "json:" "in der N√§he des Strukturfelds schreiben). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Beispiel schreiben wir einen Codegenerator f√ºr die Arbeit mit einer Datenbank. </font><font style="vertical-align: inherit;">Der Codegenerator √ºberpr√ºft die in ihn √ºbertragene Datei, sucht nach Strukturen mit einem entsprechenden Kommentar und erstellt einen Wrapper √ºber der Struktur (CRUD-Methoden) f√ºr die Datenbankinteraktion. </font><font style="vertical-align: inherit;">Wir werden die Parameter verwenden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dbe comment: {"table": "users"}, in dem Sie die Tabelle definieren k√∂nnen, in der sich die Strukturdatens√§tze befinden sollen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dbe-Tag f√ºr die Felder der Struktur, in dem Sie den Namen der Spalte angeben k√∂nnen, in die der Feldwert und die Attribute f√ºr die Datenbank eingef√ºgt werden sollen: primary_key und not_null. </font><font style="vertical-align: inherit;">Sie werden beim Erstellen der Tabelle verwendet. </font><font style="vertical-align: inherit;">Und f√ºr den Feldnamen k√∂nnen Sie "-" verwenden, um keine Spalte daf√ºr zu erstellen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde im Voraus reservieren, dass das Projekt noch nicht im Kampf ist, es wird keinen Teil der notwendigen Kontrollen und Schutzma√ünahmen enthalten. </font><font style="vertical-align: inherit;">Bei Interesse werde ich mich weiterentwickeln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir uns f√ºr die Aufgabe und die Parameter zur Steuerung der Codegenerierung entschieden haben, k√∂nnen wir mit dem Schreiben von Code beginnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Links zu allen Codes finden Sie am Ende des Artikels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir umgehen den resultierenden Baum und analysieren jedes Element der ersten Ebene. </font><font style="vertical-align: inherit;">Go verf√ºgt √ºber vordefinierte Parsing-Typen: BadDecl, GenDecl und FuncDecl.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typ Beschreibung</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs"><span class="hljs-comment">// A BadDecl node is a placeholder for declarations containing</span>
<span class="hljs-comment">// syntax errors for which no correct declaration nodes can be</span>
<span class="hljs-comment">// created.</span>
<span class="hljs-comment">//</span>
BadDecl <span class="hljs-keyword">struct</span> {<font></font>
    From, To token.Pos <span class="hljs-comment">// position range of bad declaration</span><font></font>
}<font></font>
<span class="hljs-comment">// A GenDecl node (generic declaration node) represents an import,</span>
<span class="hljs-comment">// constant, type or variable declaration. A valid Lparen position</span>
<span class="hljs-comment">// (Lparen.IsValid()) indicates a parenthesized declaration.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Relationship between Tok value and Specs element type:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// token.IMPORT *ImportSpec</span>
<span class="hljs-comment">// token.CONST *ValueSpec</span>
<span class="hljs-comment">// token.TYPE *TypeSpec</span>
<span class="hljs-comment">// token.VAR *ValueSpec</span>
<span class="hljs-comment">//</span>
GenDecl <span class="hljs-keyword">struct</span> {<font></font>
    Doc *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span>
    TokPos token.Pos <span class="hljs-comment">// position of Tok</span>
    Tok token.Token <span class="hljs-comment">// IMPORT, CONST, TYPE, VAR</span>
    Lparen token.Pos <span class="hljs-comment">// position of '(', if any</span><font></font>
    Specs []Spec<font></font>
    Rparen token.Pos <span class="hljs-comment">// position of ')', if any</span><font></font>
}<font></font>
<span class="hljs-comment">// A FuncDecl node represents a function declaration.</span>
FuncDecl <span class="hljs-keyword">struct</span> {<font></font>
    Doc *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span>
    Recv *FieldList <span class="hljs-comment">// receiver (methods); or nil (functions)</span>
    Name *Ident <span class="hljs-comment">// function/method name</span>
    Type *FuncType <span class="hljs-comment">// function signature: parameters, results, and position of "func" keyword</span>
    Body *BlockStmt <span class="hljs-comment">// function body; or nil for external (non-Go) function</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sind an Strukturen interessiert, deshalb verwenden wir GenDecl. </font><font style="vertical-align: inherit;">In diesem Stadium kann FuncDecl n√ºtzlich sein, in dem die Definitionen von Funktionen liegen und Sie sie umschlie√üen, aber jetzt brauchen wir sie nicht. </font><font style="vertical-align: inherit;">Als n√§chstes betrachten wir das Specs-Array an jedem Knoten und suchen, ob wir mit einem Typdefinitionsfeld (* ast.TypeSpec) arbeiten. Dies ist eine Struktur (* ast.StructType). </font><font style="vertical-align: inherit;">Nachdem wir festgestellt haben, dass wir eine Struktur haben, √ºberpr√ºfen wir, ob sie einen Kommentar // dbe enth√§lt. </font><font style="vertical-align: inherit;">Der vollst√§ndige Baumdurchlaufcode und die Definition, mit welcher Struktur gearbeitet werden soll, sind unten aufgef√ºhrt.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baum durchqueren und Strukturen bekommen</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> node.Decls {<font></font>
	genD, ok := f.(*ast.GenDecl)<font></font>
	<span class="hljs-keyword">if</span> !ok {<font></font>
		fmt.Printf(<span class="hljs-string">"SKIP %T is not *ast.GenDecl\n"</span>, f)
		<span class="hljs-keyword">continue</span><font></font>
	}<font></font>
	targetStruct := &amp;StructInfo{}<font></font>
	<span class="hljs-keyword">var</span> thisIsStruct <span class="hljs-keyword">bool</span>
	<span class="hljs-keyword">for</span> _, spec := <span class="hljs-keyword">range</span> genD.Specs {<font></font>
		currType, ok := spec.(*ast.TypeSpec)<font></font>
		<span class="hljs-keyword">if</span> !ok {<font></font>
			fmt.Printf(<span class="hljs-string">"SKIP %T is not ast.TypeSpec\n"</span>, spec)
			<span class="hljs-keyword">continue</span><font></font>
		}<font></font>
<font></font>
		currStruct, ok := currType.Type.(*ast.StructType)<font></font>
		<span class="hljs-keyword">if</span> !ok {<font></font>
			fmt.Printf(<span class="hljs-string">"SKIP %T is not ast.StructType\n"</span>, currStruct)
			<span class="hljs-keyword">continue</span><font></font>
		}<font></font>
		targetStruct.Name = currType.Name.Name<font></font>
		thisIsStruct = <span class="hljs-literal">true</span><font></font>
	}<font></font>
	<span class="hljs-comment">//Getting comments</span>
	<span class="hljs-keyword">var</span> needCodegen <span class="hljs-keyword">bool</span>
	<span class="hljs-keyword">var</span> dbeParams <span class="hljs-keyword">string</span>
	<span class="hljs-keyword">if</span> thisIsStruct {
		<span class="hljs-keyword">for</span> _, comment := <span class="hljs-keyword">range</span> genD.Doc.List {<font></font>
			needCodegen = needCodegen || strings.HasPrefix(comment.Text, <span class="hljs-string">"// dbe"</span>)
			<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(comment.Text) &lt; <span class="hljs-number">7</span> {<font></font>
				dbeParams = <span class="hljs-string">""</span>
			} <span class="hljs-keyword">else</span> {<font></font>
				dbeParams = strings.Replace(comment.Text, <span class="hljs-string">"// dbe:"</span>, <span class="hljs-string">""</span>, <span class="hljs-number">1</span>)<font></font>
			}<font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> needCodegen {<font></font>
		targetStruct.Target = genD<font></font>
		genParams := &amp;DbeParam{}<font></font>
		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dbeParams) != <span class="hljs-number">0</span> {<font></font>
			err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(dbeParams), genParams)
			<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
				fmt.Printf(<span class="hljs-string">"Error encoding DBE params for structure %s\n"</span>, targetStruct.Name)
				<span class="hljs-keyword">continue</span><font></font>
			}<font></font>
		} <span class="hljs-keyword">else</span> {<font></font>
			genParams.TableName = targetStruct.Name<font></font>
		}<font></font>
<font></font>
		targetStruct.GenParam = genParams<font></font>
		generateMethods(targetStruct, out)<font></font>
	}<font></font>
}</code></pre><br>
     ,  :<br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> DbeParam <span class="hljs-keyword">struct</span> {<font></font>
	TableName <span class="hljs-keyword">string</span> <span class="hljs-string">`json:"table"`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">type</span> StructInfo <span class="hljs-keyword">struct</span> {<font></font>
	Name     <span class="hljs-keyword">string</span><font></font>
	GenParam *DbeParam<font></font>
	Target   *ast.GenDecl<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt bereiten wir Informationen √ºber die Felder der Struktur vor, sodass wir basierend auf den empfangenen Informationen Tabellenerstellungsfunktionen (createTable) und CRUD-Methoden generieren.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code zum Abrufen von Feldern aus einer Struktur</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateMethods</span><span class="hljs-params">(reqStruct *StructInfo, out *os.File)</span></span> {
	<span class="hljs-keyword">for</span> _, spec := <span class="hljs-keyword">range</span> reqStruct.Target.Specs {<font></font>
		fmt.Fprintln(out, <span class="hljs-string">""</span>)<font></font>
		currType, ok := spec.(*ast.TypeSpec)<font></font>
		<span class="hljs-keyword">if</span> !ok {
			<span class="hljs-keyword">continue</span><font></font>
		}<font></font>
		currStruct, ok := currType.Type.(*ast.StructType)<font></font>
		<span class="hljs-keyword">if</span> !ok {
			<span class="hljs-keyword">continue</span><font></font>
		}<font></font>
<font></font>
		fmt.Printf(<span class="hljs-string">"\tgenerating createTable methods for %s\n"</span>, currType.Name.Name)<font></font>
<font></font>
		curTable := &amp;TableInfo{<font></font>
			TableName: reqStruct.GenParam.TableName,<font></font>
			Columns:   <span class="hljs-built_in">make</span>([]*ColInfo, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(currStruct.Fields.List)),<font></font>
		}<font></font>
<font></font>
		<span class="hljs-keyword">for</span> _, field := <span class="hljs-keyword">range</span> currStruct.Fields.List {
			<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(field.Names) == <span class="hljs-number">0</span> {
				<span class="hljs-keyword">continue</span><font></font>
			}<font></font>
			tableCol := &amp;ColInfo{FieldName: field.Names[<span class="hljs-number">0</span>].Name}
			<span class="hljs-keyword">var</span> fieldIsPrimKey <span class="hljs-keyword">bool</span>
			<span class="hljs-keyword">var</span> preventThisField <span class="hljs-keyword">bool</span>
			<span class="hljs-keyword">if</span> field.Tag != <span class="hljs-literal">nil</span> {<font></font>
				tag := reflect.StructTag(field.Tag.Value[<span class="hljs-number">1</span> : <span class="hljs-built_in">len</span>(field.Tag.Value)<span class="hljs-number">-1</span>])<font></font>
				tagVal := tag.Get(<span class="hljs-string">"dbe"</span>)<font></font>
				fmt.Println(<span class="hljs-string">"dbe:"</span>, tagVal)<font></font>
				tagParams := strings.Split(tagVal, <span class="hljs-string">","</span>)<font></font>
			PARAMSLOOP:<font></font>
				<span class="hljs-keyword">for</span> _, param := <span class="hljs-keyword">range</span> tagParams {
					<span class="hljs-keyword">switch</span> param {
					<span class="hljs-keyword">case</span> <span class="hljs-string">"primary_key"</span>:
						<span class="hljs-keyword">if</span> curTable.PrimaryKey == <span class="hljs-literal">nil</span> {<font></font>
							fieldIsPrimKey = <span class="hljs-literal">true</span>
							tableCol.NotNull = <span class="hljs-literal">true</span>
						} <span class="hljs-keyword">else</span> {<font></font>
							log.Panicf(<span class="hljs-string">"Table %s cannot have more then 1 primary key!"</span>, currType.Name.Name)<font></font>
						}<font></font>
					<span class="hljs-keyword">case</span> <span class="hljs-string">"not_null"</span>:<font></font>
						tableCol.NotNull = <span class="hljs-literal">true</span>
					<span class="hljs-keyword">case</span> <span class="hljs-string">"-"</span>:<font></font>
						preventThisField = <span class="hljs-literal">true</span>
						<span class="hljs-keyword">break</span> PARAMSLOOP
					<span class="hljs-keyword">default</span>:<font></font>
						tableCol.ColName = param<font></font>
					}<font></font>
<font></font>
				}<font></font>
				<span class="hljs-keyword">if</span> preventThisField {
					<span class="hljs-keyword">continue</span><font></font>
				}<font></font>
			}<font></font>
			<span class="hljs-keyword">if</span> tableCol.ColName == <span class="hljs-string">""</span> {<font></font>
				tableCol.ColName = tableCol.FieldName<font></font>
			}<font></font>
			<span class="hljs-keyword">if</span> fieldIsPrimKey {<font></font>
				curTable.PrimaryKey = tableCol<font></font>
			}<font></font>
			<span class="hljs-comment">//Determine field type</span>
			<span class="hljs-keyword">var</span> fieldType <span class="hljs-keyword">string</span>
			<span class="hljs-keyword">switch</span> field.Type.(<span class="hljs-keyword">type</span>) {
			<span class="hljs-keyword">case</span> *ast.Ident:<font></font>
				fieldType = field.Type.(*ast.Ident).Name<font></font>
			<span class="hljs-keyword">case</span> *ast.SelectorExpr:<font></font>
				fieldType = field.Type.(*ast.SelectorExpr).Sel.Name<font></font>
			}<font></font>
			<span class="hljs-comment">//fieldType := field.Type.(*ast.Ident).Name</span>
			fmt.Printf(<span class="hljs-string">"%s- %s\n"</span>, tableCol.FieldName, fieldType)
			<span class="hljs-comment">//Check for integers</span>
			<span class="hljs-keyword">if</span> strings.Contains(fieldType, <span class="hljs-string">"int"</span>) {<font></font>
				tableCol.ColType = <span class="hljs-string">"integer"</span>
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-comment">//Check for other types</span>
				<span class="hljs-keyword">switch</span> fieldType {
				<span class="hljs-keyword">case</span> <span class="hljs-string">"string"</span>:<font></font>
					tableCol.ColType = <span class="hljs-string">"text"</span>
				<span class="hljs-keyword">case</span> <span class="hljs-string">"bool"</span>:<font></font>
					tableCol.ColType = <span class="hljs-string">"boolean"</span>
				<span class="hljs-keyword">case</span> <span class="hljs-string">"Time"</span>:<font></font>
					tableCol.ColType = <span class="hljs-string">"TIMESTAMP"</span>
				<span class="hljs-keyword">default</span>:<font></font>
					log.Panicf(<span class="hljs-string">"Field type %s not supported"</span>, fieldType)<font></font>
				}<font></font>
			}<font></font>
			tableCol.FieldType = fieldType<font></font>
			curTable.Columns = <span class="hljs-built_in">append</span>(curTable.Columns, tableCol)<font></font>
			curTable.StructName = currType.Name.Name<font></font>
<font></font>
		}<font></font>
		curTable.generateCreateTable(out)<font></font>
<font></font>
		fmt.Printf(<span class="hljs-string">"\tgenerating CRUD methods for %s\n"</span>, currType.Name.Name)<font></font>
		curTable.generateCreate(out)<font></font>
		curTable.generateQuery(out)<font></font>
		curTable.generateUpdate(out)<font></font>
		curTable.generateDelete(out)<font></font>
	}<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen alle Felder der gew√ºnschten Struktur durch und beginnen, die Tags jedes Feldes zu analysieren. Mit Reflection erhalten wir das Tag, an dem wir interessiert sind (schlie√ülich befinden sich m√∂glicherweise andere Tags auf dem Feld, z. B. f√ºr json). Wir analysieren den Inhalt des Tags und stellen fest, ob das Feld ein Prim√§rschl√ºssel ist (wenn mehr als ein Prim√§rschl√ºssel angegeben ist, verfluchen Sie ihn und stoppen Sie die Ausf√ºhrung). Muss das Feld ungleich Null sein, m√ºssen wir mit der Datenbank f√ºr dieses Feld arbeiten und definieren Spaltenname, wenn er im Tag √ºberschrieben wurde. Wir m√ºssen auch den Typ der Tabellenspalte basierend auf dem Typ des Strukturfelds bestimmen. Es gibt eine endliche Menge von Feldtypen, die nur f√ºr Basistypen generiert werden. Wir reduzieren alle Zeilen auf den TEXT-Feldtyp. Im Allgemeinen k√∂nnen Sie den Tags jedoch eine Spaltentypdefinition hinzuf√ºgen, damit Sie sie feiner anpassen k√∂nnen. Andererseits,niemand st√∂rt sich daran, die gew√ºnschte Tabelle im Voraus in der Datenbank zu erstellen oder die automatisch erstellte zu korrigieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Parsen der Struktur starten wir die Methode zum Erstellen des Codes f√ºr die Tabellenerstellungsfunktion und die Methoden zum Erstellen der Funktionen Erstellen, Abfragen, Aktualisieren und L√∂schen. </font><font style="vertical-align: inherit;">Wir bereiten f√ºr jede Funktion einen SQL-Ausdruck und eine auszuf√ºhrende Bindung vor. </font><font style="vertical-align: inherit;">Ich habe mich nicht um die Fehlerbehandlung gek√ºmmert, sondern nur den Fehler vom Datenbanktreiber angegeben. </font><font style="vertical-align: inherit;">F√ºr die Codegenerierung ist es bequem, Vorlagen aus der Text- / Vorlagenbibliothek zu verwenden. </font><font style="vertical-align: inherit;">Mit ihrer Hilfe k√∂nnen Sie einen viel besser unterst√ºtzten und vorhersehbaren Code erhalten (der Code ist sofort sichtbar, aber nicht durch den Generatorcode verschmiert).</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabellenerstellung</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tableD *TableInfo)</span> <span class="hljs-title">generateCreateTable</span><span class="hljs-params">(out *os.File)</span> <span class="hljs-title">error</span></span> {<font></font>
	fmt.Fprint(out, <span class="hljs-string">"func (in *"</span>+tableD.StructName+<span class="hljs-string">") createTable(db *sql.DB) (error) {\n"</span>)
	<span class="hljs-keyword">var</span> resSQLq = fmt.Sprintf(<span class="hljs-string">"\tsqlQ := `CREATE TABLE %s (\n"</span>, tableD.TableName)
	<span class="hljs-keyword">for</span> _, col := <span class="hljs-keyword">range</span> tableD.Columns {<font></font>
		colSQL := col.ColName + <span class="hljs-string">" "</span> + col.ColType
		<span class="hljs-keyword">if</span> col.NotNull {<font></font>
			colSQL += <span class="hljs-string">" NOT NULL"</span><font></font>
		}<font></font>
		<span class="hljs-keyword">if</span> col == tableD.PrimaryKey {<font></font>
			colSQL += <span class="hljs-string">" AUTO_INCREMENT"</span><font></font>
		}<font></font>
		colSQL += <span class="hljs-string">",\n"</span><font></font>
		resSQLq += colSQL<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> tableD.PrimaryKey != <span class="hljs-literal">nil</span> {<font></font>
		resSQLq += fmt.Sprintf(<span class="hljs-string">"PRIMARY KEY (%s)\n"</span>, tableD.PrimaryKey.ColName)<font></font>
	}<font></font>
	resSQLq += <span class="hljs-string">")`\n"</span><font></font>
	fmt.Fprint(out, resSQLq)<font></font>
	fmt.Fprint(out, <span class="hljs-string">"\t_, err := db.Exec(sqlQ)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n"</span>)<font></font>
	fmt.Fprint(out, <span class="hljs-string">"\t return nil\n}\n\n"</span>)
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datensatz hinzuf√ºgen</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs"><font></font>
<font></font>
	fmt.Fprint(out, <span class="hljs-string">"func (in *"</span>+tableD.StructName+<span class="hljs-string">") Create(db *sql.DB) (error) {\n"</span>)
	<span class="hljs-keyword">var</span> columns, valuePlaces, valuesListParams <span class="hljs-keyword">string</span>
	<span class="hljs-keyword">for</span> _, col := <span class="hljs-keyword">range</span> tableD.Columns {
		<span class="hljs-keyword">if</span> col == tableD.PrimaryKey {
			<span class="hljs-keyword">continue</span><font></font>
		}<font></font>
		columns += <span class="hljs-string">"`"</span> + col.ColName + <span class="hljs-string">"`,"</span>
		valuePlaces += <span class="hljs-string">"?,"</span>
		valuesListParams += <span class="hljs-string">"in."</span> + col.FieldName + <span class="hljs-string">","</span><font></font>
	}<font></font>
	columns = columns[:<span class="hljs-built_in">len</span>(columns)<span class="hljs-number">-1</span>]<font></font>
	valuePlaces = valuePlaces[:<span class="hljs-built_in">len</span>(valuePlaces)<span class="hljs-number">-1</span>]<font></font>
	valuesListParams = valuesListParams[:<span class="hljs-built_in">len</span>(valuesListParams)<span class="hljs-number">-1</span>]<font></font>
<font></font>
	resSQLq := fmt.Sprintf(<span class="hljs-string">"\tsqlQ := \"INSERT INTO %s (%s) VALUES (%s);\"\n"</span>,<font></font>
		tableD.TableName,<font></font>
		columns,<font></font>
		valuePlaces)<font></font>
	fmt.Fprintln(out, resSQLq)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"result, err := db.Exec(sqlQ, %s)\n"</span>, valuesListParams)<font></font>
	fmt.Fprintln(out, <span class="hljs-string">`if err != nil {
		return err
	}`</span>)
	<span class="hljs-comment">//Setting id if we have primary key</span>
	<span class="hljs-keyword">if</span> tableD.PrimaryKey != <span class="hljs-literal">nil</span> {<font></font>
		fmt.Fprintf(out, <span class="hljs-string">`lastId, err := result.LastInsertId()
		if err != nil {
			return nil
		}`</span>)<font></font>
		fmt.Fprintf(out, <span class="hljs-string">"\nin.%s = %s(lastId)\n"</span>, tableD.PrimaryKey.FieldName, tableD.PrimaryKey.FieldType)<font></font>
	}<font></font>
	fmt.Fprintln(out, <span class="hljs-string">"return nil\n}\n\n"</span>)
	<span class="hljs-comment">//in., _ := result.LastInsertId()`)</span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datens√§tze aus einer Tabelle abrufen</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tableD *TableInfo)</span> <span class="hljs-title">generateQuery</span><span class="hljs-params">(out *os.File)</span> <span class="hljs-title">error</span></span> {<font></font>
	fmt.Fprint(out, <span class="hljs-string">"func (in *"</span>+tableD.StructName+<span class="hljs-string">") Query(db *sql.DB) ([]*"</span>+tableD.StructName+<span class="hljs-string">", error) {\n"</span>)<font></font>
<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"\tsqlQ := \"SELECT * FROM %s;\"\n"</span>, tableD.TableName)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"rows, err := db.Query(sqlQ)\n"</span>)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"results := make([]*%s, 0)\n"</span>, tableD.StructName)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">`for rows.Next() {`</span>)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"\t tempR := &amp;%s{}\n"</span>, tableD.StructName)
	<span class="hljs-keyword">var</span> valuesListParams <span class="hljs-keyword">string</span>
	<span class="hljs-keyword">for</span> _, col := <span class="hljs-keyword">range</span> tableD.Columns {<font></font>
		valuesListParams += <span class="hljs-string">"&amp;tempR."</span> + col.FieldName + <span class="hljs-string">","</span><font></font>
	}<font></font>
	valuesListParams = valuesListParams[:<span class="hljs-built_in">len</span>(valuesListParams)<span class="hljs-number">-1</span>]<font></font>
<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"\terr = rows.Scan(%s)\n"</span>, valuesListParams)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">`if err != nil {
		return nil, err
		}`</span>)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"\n\tresults = append(results, tempR)"</span>)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">`}
		return results, nil
	}`</span>)<font></font>
	fmt.Fprintln(out, <span class="hljs-string">""</span>)<font></font>
	fmt.Fprintln(out, <span class="hljs-string">""</span>)
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Update aufzeichnen (funktioniert nach Prim√§rschl√ºssel)</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tableD *TableInfo)</span> <span class="hljs-title">generateUpdate</span><span class="hljs-params">(out *os.File)</span> <span class="hljs-title">error</span></span> {<font></font>
	fmt.Fprint(out, <span class="hljs-string">"func (in *"</span>+tableD.StructName+<span class="hljs-string">") Update(db *sql.DB) (error) {\n"</span>)
	<span class="hljs-keyword">var</span> updVals, valuesListParams <span class="hljs-keyword">string</span>
	<span class="hljs-keyword">for</span> _, col := <span class="hljs-keyword">range</span> tableD.Columns {
		<span class="hljs-keyword">if</span> col == tableD.PrimaryKey {
			<span class="hljs-keyword">continue</span><font></font>
		}<font></font>
		updVals += <span class="hljs-string">"`"</span> + col.ColName + <span class="hljs-string">"`=?,"</span>
		valuesListParams += <span class="hljs-string">"in."</span> + col.FieldName + <span class="hljs-string">","</span><font></font>
	}<font></font>
	updVals = updVals[:<span class="hljs-built_in">len</span>(updVals)<span class="hljs-number">-1</span>]<font></font>
	valuesListParams += <span class="hljs-string">"in."</span> + tableD.PrimaryKey.FieldName<font></font>
<font></font>
	resSQLq := fmt.Sprintf(<span class="hljs-string">"\tsqlQ := \"UPDATE %s SET %s WHERE %s = ?;\"\n"</span>,<font></font>
		tableD.TableName,<font></font>
		updVals,<font></font>
		tableD.PrimaryKey.ColName)<font></font>
	fmt.Fprintln(out, resSQLq)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"_, err := db.Exec(sqlQ, %s)\n"</span>, valuesListParams)<font></font>
	fmt.Fprintln(out, <span class="hljs-string">`if err != nil {
		return err
	}`</span>)<font></font>
<font></font>
	fmt.Fprintln(out, <span class="hljs-string">"return nil\n}\n\n"</span>)
	<span class="hljs-comment">//in., _ := result.LastInsertId()`)</span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datensatz l√∂schen (funktioniert nach Prim√§rschl√ºssel)</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tableD *TableInfo)</span> <span class="hljs-title">generateDelete</span><span class="hljs-params">(out *os.File)</span> <span class="hljs-title">error</span></span> {<font></font>
	fmt.Fprint(out, <span class="hljs-string">"func (in *"</span>+tableD.StructName+<span class="hljs-string">") Delete(db *sql.DB) (error) {\n"</span>)<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"sqlQ := \"DELETE FROM %s WHERE id = ?\"\n"</span>, tableD.TableName)<font></font>
<font></font>
	fmt.Fprintf(out, <span class="hljs-string">"_, err := db.Exec(sqlQ, in.%s)\n"</span>, tableD.PrimaryKey.FieldName)<font></font>
<font></font>
	fmt.Fprintln(out, <span class="hljs-string">`if err != nil {
		return err
	}
	return nil
}`</span>)<font></font>
	fmt.Fprintln(out)<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Start des resultierenden Codegenerators erfolgt durch den √ºblichen Start. Wir √ºbergeben den Pfad zu der Datei, f√ºr die Sie den Code generieren m√∂chten, im Flag -name. </font><font style="vertical-align: inherit;">Als Ergebnis erhalten wir die Datei mit dem Suffix _dbe, in dem der generierte Code liegt. </font><font style="vertical-align: inherit;">Erstellen Sie f√ºr Tests Methoden f√ºr die folgende Struktur:</font></font><br>
<br>
<pre><code class="go hljs">
<span class="hljs-comment">// dbe:{"table": "users"}</span>
<span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> {<font></font>
	ID       <span class="hljs-keyword">int</span>    <span class="hljs-string">`dbe:"id,primary_key"`</span>
	Login    <span class="hljs-keyword">string</span> <span class="hljs-string">`dbe:"login,not_null"`</span>
	Email    <span class="hljs-keyword">string</span>
	Level    <span class="hljs-keyword">uint8</span>
	IsActive <span class="hljs-keyword">bool</span>
	UError   error <span class="hljs-string">`dbe:"-"`</span><font></font>
}<font></font>
</code></pre><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der resultierende Code</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> <span class="hljs-string">"database/sql"</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *User)</span> <span class="hljs-title">createTable</span><span class="hljs-params">(db *sql.DB)</span> <span class="hljs-title">error</span></span> {<font></font>
	sqlQ := <span class="hljs-string">`CREATE TABLE users (
	id integer NOT NULL AUTO_INCREMENT,
	login text NOT NULL,
	Email text,
	Level integer,
	IsActive boolean,
	PRIMARY KEY (id)
	)`</span><font></font>
	_, err := db.Exec(sqlQ)<font></font>
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> err<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *User)</span> <span class="hljs-title">Create</span><span class="hljs-params">(db *sql.DB)</span> <span class="hljs-title">error</span></span> {<font></font>
	sqlQ := <span class="hljs-string">"INSERT INTO users (`login`,`Email`,`Level`,`IsActive`) VALUES (?,?,?,?);"</span><font></font>
<font></font>
	result, err := db.Exec(sqlQ, in.Login, in.Email, in.Level, in.IsActive)<font></font>
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> err<font></font>
	}<font></font>
	lastId, err := result.LastInsertId()<font></font>
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
	}<font></font>
	in.ID = <span class="hljs-keyword">int</span>(lastId)
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *User)</span> <span class="hljs-title">Query</span><span class="hljs-params">(db *sql.DB)</span> <span class="hljs-params">([]*User, error)</span></span> {<font></font>
	sqlQ := <span class="hljs-string">"SELECT * FROM users;"</span><font></font>
	rows, err := db.Query(sqlQ)<font></font>
	results := <span class="hljs-built_in">make</span>([]*User, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">for</span> rows.Next() {<font></font>
		tempR := &amp;User{}<font></font>
		err = rows.Scan(&amp;tempR.ID, &amp;tempR.Login, &amp;tempR.Email, &amp;tempR.Level, &amp;tempR.IsActive)<font></font>
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<font></font>
		}<font></font>
		results = <span class="hljs-built_in">append</span>(results, tempR)<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> results, <span class="hljs-literal">nil</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *User)</span> <span class="hljs-title">Update</span><span class="hljs-params">(db *sql.DB)</span> <span class="hljs-title">error</span></span> {<font></font>
	sqlQ := <span class="hljs-string">"UPDATE users SET `login`=?,`Email`=?,`Level`=?,`IsActive`=? WHERE id = ?;"</span><font></font>
<font></font>
	_, err := db.Exec(sqlQ, in.Login, in.Email, in.Level, in.IsActive, in.ID)<font></font>
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> err<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(in *User)</span> <span class="hljs-title">Delete</span><span class="hljs-params">(db *sql.DB)</span> <span class="hljs-title">error</span></span> {<font></font>
	sqlQ := <span class="hljs-string">"DELETE FROM users WHERE id = ?"</span><font></font>
	_, err := db.Exec(sqlQ, in.ID)<font></font>
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> err<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Funktionsweise des generierten Codes zu testen, erstellen Sie ein Objekt mit beliebigen Daten und erstellen Sie eine Tabelle daf√ºr (wenn die Tabelle in der Datenbank vorhanden ist, wird ein Fehler zur√ºckgegeben). </font><font style="vertical-align: inherit;">Nachdem wir dieses Objekt in die Tabelle eingef√ºgt haben, lesen Sie alle Felder aus der Tabelle, aktualisieren Sie die Ebenenwerte und l√∂schen Sie das Objekt.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie die resultierenden Methoden auf</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-keyword">var</span> err error<font></font>
db, err := sql.Open(<span class="hljs-string">"mysql"</span>, DSN)
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
	fmt.Println(<span class="hljs-string">"Unable to connect to DB"</span>, err)
	<span class="hljs-keyword">return</span><font></font>
}<font></font>
err = db.Ping()<font></font>
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
	fmt.Println(<span class="hljs-string">"Unable to ping BD"</span>)
	<span class="hljs-keyword">return</span><font></font>
}<font></font>
newUser := &amp;User{<font></font>
	Login:    <span class="hljs-string">"newUser"</span>,<font></font>
	Email:    <span class="hljs-string">"new@test.com"</span>,<font></font>
	Level:    <span class="hljs-number">0</span>,<font></font>
	IsActive: <span class="hljs-literal">false</span>,<font></font>
	UError:   <span class="hljs-literal">nil</span>,<font></font>
}<font></font>
<font></font>
err = newUser.createTable(db)<font></font>
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
	fmt.Println(<span class="hljs-string">"Error creating table."</span>, err)<font></font>
<font></font>
}<font></font>
err = newUser.Create(db)<font></font>
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
	fmt.Println(<span class="hljs-string">"Error creating user."</span>, err)
	<span class="hljs-keyword">return</span><font></font>
}<font></font>
<font></font>
nU := &amp;User{}<font></font>
dbUsers, err := nU.Query(db)<font></font>
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
	fmt.Println(<span class="hljs-string">"Error selecting users."</span>, err)
	<span class="hljs-keyword">return</span><font></font>
}<font></font>
fmt.Printf(<span class="hljs-string">"From table users selected %d fields"</span>, <span class="hljs-built_in">len</span>(dbUsers))
<span class="hljs-keyword">var</span> DBUser *User
<span class="hljs-keyword">for</span> _, user := <span class="hljs-keyword">range</span> dbUsers {<font></font>
	fmt.Println(user)<font></font>
	DBUser = user<font></font>
}<font></font>
DBUser.Level = <span class="hljs-number">2</span><font></font>
err = DBUser.Update(db)<font></font>
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
	fmt.Println(<span class="hljs-string">"Error updating users."</span>, err)
	<span class="hljs-keyword">return</span><font></font>
}<font></font>
err = DBUser.Delete(db)<font></font>
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
	fmt.Println(<span class="hljs-string">"Error deleting users."</span>, err)
	<span class="hljs-keyword">return</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der aktuellen Implementierung ist die Funktionalit√§t des Clients f√ºr die Datenbank sehr eingeschr√§nkt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird nur MySQL unterst√ºtzt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht alle Feldtypen werden unterst√ºtzt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keine Filterung und Grenzen f√ºr SELECT.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Beheben von Fehlern geht jedoch bereits √ºber das Analysieren von Go-Quellcode und das Generieren von neuem Code auf dieser Grundlage hinaus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie in einem solchen Szenario einen Codegenerator verwenden, k√∂nnen Sie die in der Anwendung verwendeten Felder und Strukturtypen nur an einer Stelle √§ndern. Sie m√ºssen nicht daran denken, √Ñnderungen am Code f√ºr die Interaktion mit der Datenbank vorzunehmen. Sie m√ºssen lediglich den Codegenerator jedes Mal ausf√ºhren. </font><font style="vertical-align: inherit;">Diese Aufgabe k√∂nnte mit Hilfe der Reflexion gel√∂st werden, dies h√§tte jedoch die Leistung beeintr√§chtigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Quellcode-Generator und ein Beispiel f√ºr den generierten Code, der auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github ver√∂ffentlicht wurde</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de500986/index.html">√úberwachung im Rechenzentrum: Wie wir das alte BMS durch ein neues ersetzt haben. Teil 3</a></li>
<li><a href="../de500992/index.html">Wie ist Performance Management in den besten IT-Unternehmen</a></li>
<li><a href="../de500994/index.html">F√ºhren Sie Ameise. Lauf</a></li>
<li><a href="../de500996/index.html">So werden Sie in sechs Monaten oder noch schneller DevOps-Ingenieur. Teil 1. Einf√ºhrung</a></li>
<li><a href="../de500998/index.html">Faltungsneurales Netzwerk und seine Integration in iOS (Teil 1)</a></li>
<li><a href="../de501002/index.html">Umka: Neue statisch typisierte Skriptsprache</a></li>
<li><a href="../de501004/index.html">Tu es. Arbeit</a></li>
<li><a href="../de501006/index.html">Wir sind Freunde STM32 mit LCD-Anzeige 1604 am I2C-Bus (HAL-Bibliothek)</a></li>
<li><a href="../de501008/index.html">Dominos Pflaster</a></li>
<li><a href="../de501010/index.html">Linux Kernel TLS und Nginx</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>