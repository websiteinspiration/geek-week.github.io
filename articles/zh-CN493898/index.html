<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😼 🛂 🍟 “脚从何而来”或编程之前是什么？ 🚕 🖌️ 🦂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！前几天，作为OTUS教育平台的一部分，推出了新课程：“建筑与设计模式”。在开始时，我们举办了传统的公开课。它研究了单片应用程序，多层和无服务器体系结构的功能。我们详细研究了事件驱动系统，面向服务的系统和微服务体系结构。
 
 
 
 老师是Matvey Kalinin，他是一位具有20多年编...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>“脚从何而来”或编程之前是什么？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/493898/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大家好！</font><font style="vertical-align: inherit;">前几天，作为OTUS教育平台的一部分，推出了新课程：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“建筑与设计模式”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在开始时，我们举办了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传统的公开课</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它研究了单片应用程序，多层和无服务器体系结构的功能。</font><font style="vertical-align: inherit;">我们详细研究了事件驱动系统，面向服务的系统和微服务体系结构。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ij/hw/h9/ijhwh9xapluofd9khov5pb6auki.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
老师是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matvey Kalinin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，他是一位具有20多年编程经验的专家，并且是“建筑与设计模式”课程的作者。</font></font><a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一点背景</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初，程序确实为自己解决了任务集，并且非常孤立。但是随着时间的流逝，程序不断发展，人们开始了解到，功能的复杂性开始影响改进的速度，可靠性和对各种复杂性的抵抗力。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
确实，当我们拥有一个或两个相同且不变的程序时，编写这些程序并确保它们之间的交互并不困难。但是，当它们越来越多时，就无法避免问题，并且所涉及的软件包也不重要。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今天，大多数情况下都是分发应用程序。</font><font style="vertical-align: inherit;">它们由几个模块组成，并通过系统消息互连。</font><font style="vertical-align: inherit;">即，获得了彼此交互的程序的相当大的集团。</font><font style="vertical-align: inherit;">为了使他们成功进行互动，我们需要考虑：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快速反应；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带宽</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就一个资源单位而言的绩效；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扩展能力；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整合能力；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所使用平台的功能；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现有业务流程的特征；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及更多…</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同时，人们不禁会想起下面的话：</font></font><br>
<br>
<blockquote><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“正确的程序代码创建和维护不需要大量的人工成本。</font><font style="vertical-align: inherit;">快速，轻松地进行更改。</font><font style="vertical-align: inherit;">错误很少。</font><font style="vertical-align: inherit;">人工成本最小，而功能和灵活性最大</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">” </font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
罗伯特·塞西尔·马丁</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，理想情况下只编写一次程序（如果编写得当），改进将很小。</font><font style="vertical-align: inherit;">如何实现这一目标并相互链接？</font><font style="vertical-align: inherit;">为了回答这个问题，我们转向历史。</font></font><br>
<br>
<ul>
<li><b>1968 </b>:  -       ,          (<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">«The Structure of the «THE»-Multiprogramming System»</a>).        ,           .     !</li>
<li><b>1970 </b>:      «<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">On the Criteria To Be Used in Decomposing Systems into Modules</a>»             ,     .     ,      .        ;</li>
<li><b>1996 </b>:        Carnegie Mellon     «  :   » (<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://marian.shaw-weil.com/displaypaper.php%3FPAPER_ID%3D31%26header%3Dhttp://spoke.compose.cs.cmu.edu/shaweb/p/pubstop.txt%26trailer%3D">«Software Architecture: Perspectives on an Emerging Discipline»</a>),       ,   ,  (connectors),   . .;</li>
<li><b>2007 </b>:         — IEEE 1471: ANSI / IEEE 1471 — 2000:      .      ISO ISO / IEC 42010:2007.</li>
</ul><br>
<h3>   ?</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们意识到我们需要适当地构建软件产品的结构。但是软件架构的目的是什么？无论如何，为什么我们在本文标题中使用“腿长”一词？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
问题是，当您开始编程时，您已经知道要构建的内容。最初，一切都从业务流程开始。有一个订单和一个客户（至少以文字形式）描述了他的系统应该如何工作。首先，该系统仅以其描述的形式存在。然后，对这一过程进行形式化和概述，但这仍然是成功的一半，因为进一步的开发开始了。并且开发人员需要将此过程转换为软件产品，该软件产品应该... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后是时候回顾另一句话：</font></font><br>
<br>
<blockquote><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“软件体系结构的目标是减少创建和维护系统所需的人力。” </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
罗伯特·塞西尔·马丁</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目标是由这样的通用短语构成的，这并不奇怪。</font><font style="vertical-align: inherit;">事实是架构生活在抽象的思想中。</font><font style="vertical-align: inherit;">为什么？</font><font style="vertical-align: inherit;">因为从事软件体系结构</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的人员将业务客户的愿景转换为开发人员的愿景</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">而且，如果我们谈论的是开发团队的架构师和企业架构师，那么</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他们每个人都有不同的目标，但是他们两个都在努力一</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">件事</font><font style="vertical-align: inherit;">-减少人工成本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，有趣的是看一下软件的价值：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该代码符合业务流程的要求；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行为可能会迅速改变。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
问题就在这里：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么它更重要，系统的操作还是更改它的简便性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font><font style="vertical-align: inherit;">为了回答这个问题，让我们从实用性的角度看一下该程序：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果有一个正常工作的程序不允许更改，那么当需求改变时，这样的程序最终将变得无关紧要。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果程序无法正常运行，但是可以对其进行更改，则可以在不断变化的需求框架内使其正常运行。</font><font style="vertical-align: inherit;">该程序将始终保持有用。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编程范例（模型）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您认为最著名的（最先）编程模型是什么？当然是一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">巨石</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。现在可以适当地暂时回到1968年，并回顾一下Edsger Dijkstra，他证明了对转换的无节制使用（goto指令）对程序的结构有害。他建议用更易于理解的if / then / else和do / while /直到构造替换过渡。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，goto指令的显示频率降低了。但是以前，goto指令很常见。通常，这是一种邪恶的形式，因为当您看到其中包含goto指令的代码时，您会感觉到您可能找不到它的终点。越是跳转，就越复杂，即得到了意大利面条代码。现在，我们将该代码称为“意大利面条”，例如，其中20个嵌套的ifs，可能还有1个goto。这也不是很清楚的代码。想象一下，您进入10-15，并且您正在尝试了解循环的工作原理-这就是Dijkstra的想法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Spaghetti代码是结构不良，令人困惑且难以理解的程序，其中包含许多goto语句（尤其是跳转），异常以及降低结构的其他构造。</font><font style="vertical-align: inherit;">通常，这是一种众所周知且相当普遍的编程反模式。</font><font style="vertical-align: inherit;">这样的程序需要大量的时间来理解，支持和测试。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构化程序设计</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有编程语言，他们实现了一些目标。</font><font style="vertical-align: inherit;">在一定程度上，程序的结构并没有对实施产生很大影响。</font><font style="vertical-align: inherit;">但是程序不断发展，它们之间形成了无数联系。</font><font style="vertical-align: inherit;">有一次，一个人觉得将算法打包到一个易于阅读，测试的结构中很重要。</font><font style="vertical-align: inherit;">在程序结构级别已开始进行更改。</font><font style="vertical-align: inherit;">即，不仅程序本身必须满足结果，而且程序结构也必须满足某些标准。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们顺利地切换到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构化编程</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">据他介绍，该程序是在不使用goto运算符的情况下构建的，它包含三个基本控制结构：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序列， </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分枝 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">周期。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用子程序，开发本身是从上到下逐步进行的。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再说一次，回到1966年……今年，Ole-Johan Dahl和Kristen Nyugor注意到，在ALGOL语言中，可以将函数调用堆栈的框架移到动态内存（堆）中，以便在函数内部声明的局部变量可以在以后保存。从它退出。</font><font style="vertical-align: inherit;">结果，函数变成了类的构造函数，局部变量变成了实例变量，而嵌套函数变成了方法。</font><font style="vertical-align: inherit;">这导致通过严格使用函数指针来发现多态。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">面向对象编程</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
众所周知，在OOP中，程序被表示为对象的集合，每个对象都是特定类的实例，并且类形成继承层次结构。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结构化的基本原则：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遗产;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多态性。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以从另一个角度看待所有这些原则。</font><font style="vertical-align: inherit;">罗伯特·马丁（Robert Martin）开发了SOLID的原理，一方面确定了程序员如何处理抽象，另一方面又形成了多态，继承的过程。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令式编程</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命令式程序类似于计算机必须执行的命令。</font><font style="vertical-align: inherit;">这些程序的特点是：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指令写在程序的源代码中；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须按顺序执行说明；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行先前指令期间获得的数据可以由后续指令从存储器中读取；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过执行指令获得的数据可以写入存储器。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也是很古老的设计。</font><font style="vertical-align: inherit;">命令式语言</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的主要特征</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用命名变量；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用赋值运算符；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复合表达式的使用；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用例程。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，我们继续“时间旅行”。</font><font style="vertical-align: inherit;">这次我们将在1936年再回来（！）。</font><font style="vertical-align: inherit;">有趣的是，今年的Alonzo Church发明了</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lambda演算</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（或λ演算），后来在1958年构成了John McCarthy发明的LISP语言的基础。</font><font style="vertical-align: inherit;">λ演算的基本概念是不变性-即不可能更改符号的值。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功能编程</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
函数式编程涉及根据源数据和其他函数的结果来计算函数的结果，并不意味着程序状态的显式存储。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，这意味着功能语言没有赋值语句。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们用一个例子来看看命令式和功能式之间的区别：</font></font><br>
<br>
<pre><code class="plaintext hljs">#  <font></font>
target = []  #   <font></font>
for item in source_list:  #     <font></font>
    trans1 = G(item)  #   G()<font></font>
    trans2 = F(trans1)  #   F()<font></font>
    target.append(trans2)  #     <font></font>
#  <font></font>
compose2 = lambda A, B: lambda x: A(B(x))<font></font>
target = map(compose2(F, G), source_list)</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那么什么是软件架构？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
软件体系结构是有关软件系统组织的一组决策。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这包括：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择结构元件及其界面；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所选元素和界面的行为，它们之间的相互作用；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将选定的结构和行为要素组合成更大的系统；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指导整个组织的建筑风格。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意：首先我们得出的结论是goto不适合我们，然后我们发现存在某些规则（封装，继承，多态），然后我们意识到这些规则不仅有效，而且符合某些原则。第四点是建筑风格，我们将在后面讨论。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该体系结构的主要目的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是支持系统的生命周期。良好的体系结构使系统易于学习，易于开发，维护和部署。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最终目标</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是在系统的整个生命周期内最小化成本，并最大程度提高程序员（更准确地说，开发团队）的生产率。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们讨论了编写程序所需的规则。</font><font style="vertical-align: inherit;">但是，除了编写程序外，还提供支持，开发和部署。</font><font style="vertical-align: inherit;">也就是说，架构没有捕获编程的特定区域，而是整个开发周期。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个好的架构应该提供：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各种用例和有效的系统操作。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统维护简单。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">易于系统设计。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">易于系统部署。</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建筑风格</font></font></h2><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整体式</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，让我们谈谈著名的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">巨石</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，在小型系统中仍然可以找到这种样式。</font><font style="vertical-align: inherit;">整体架构意味着您的应用程序是一个大型的，相互连接的模块。</font><font style="vertical-align: inherit;">所有组件均设计为可协同工作，共享内存和资源。</font><font style="vertical-align: inherit;">所有功能或其主要部分都集中在一个过程或容器中，该过程或容器分为内部层或库。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/bo/tw/mtbotwtpxxin1o2dasmj3mijjco.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优点：</font></font></b><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">易于实现。</font><font style="vertical-align: inherit;">无需浪费时间考虑进程间通信。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开发端到端测试很容易。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">易于部署。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用Loadbalancer在您的应用程序的多个实例之间轻松扩展。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">易于操作。</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/pi/wv/t9/piwvt9fuf1rkinvhqgxtdnns6ga.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是</font><font style="vertical-align: inherit;">现在他还有更多</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺点</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强大的凝聚力会导致应用程序的发展陷入困境。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组件的独立缩放会导致复杂性和功能的完全重新测试。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比较难理解。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着复杂性的增加，开发时间也会增加。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺少组件隔离。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方面，整体是好的，但是一旦您开始开发它，就会遇到困难。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么是服务？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在每个人都知道什么是服务。</font><font style="vertical-align: inherit;">它可以定义为执行重复任务的可见资源，并由外部指令描述。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现代服务具有以下</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功能</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务不是基于IT能力，而是针对业务需求； </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 服务是自给自足的，并根据服务的接口，操作，语义，动态特性，策略和属性进行描述；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 服务的重用由其模块化计划提供；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务协议是在称为供应商和用户的实体之间达成的，并不影响服务本身的实施；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在其生命周期中，通过服务元数据，注册中心和存储库托管服务并使它们可见。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">聚合：将一个或多个企业的业务流程和复杂的应用程序结合在一起，以松散耦合的服务为基础。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于上述特征，出现了面向服务的体系结构（SOA）的概念。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">面向服务的体系结构（SOA）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SOA是一种用于创建企业IT体系结构的体系结构样式，它使用面向服务的原理来实现业务及其支持信息系统之间的紧密联系。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xu/yj/qc/xuyjqcdvjyh02fewwrstf9pmks0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SOA具有以下</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特征</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改善企业架构与业务之间的关系。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许您从集成服务集创建复杂的应用程序。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建灵活的业务流程。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它不依赖于一组技术。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在独立发展和部署的意义上是自治的。</font></font></li>
</ol><br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOA </font><b><font style="vertical-align: inherit;">部署模型</font></b><font style="vertical-align: inherit;">包括业务智能和开发以及IT智能和开发。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该程序集</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包括编程服务和构建复杂的应用程序。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">托管</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包括托管应用程序和运行时工具，例如企业服务总线（ESB）。</font><font style="vertical-align: inherit;">至于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手册</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它包括支持操作环境，监视服务的性能以及监视对服务策略的遵守情况。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oy/k-/zo/oyk-zoy0tw2nrdmghzedkcicq2k.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">微服务架构</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在该讨论</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">微服务架构了</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在其中，应用程序由小型独立服务应用程序组成，每个应用程序都有自己的资源。</font><font style="vertical-align: inherit;">服务彼此交互以执行与其商机有关的任务。</font><font style="vertical-align: inherit;">有几个部署单元。</font><font style="vertical-align: inherit;">每个服务都是独立部署的。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mi/s0/-z/mis0-zbnnjhzxvwjsm0wy5oow7o.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优点：</font></font></b><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持整个系统的模块化。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不相关的服务更易于修改以服务于不同的应用程序。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同的服务可能属于不同的团队。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务服务可以在整个公司内重复使用。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">易于理解和测试。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与其他服务中使用的技术无关。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务的隔离提高了所有功能的整体可靠性。</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/tn/zu/gy/tnzugy3vao-tup7zxv4oduikezq.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺点：</font></font></b><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整体功能（日志记录，访问权限等）的实施困难。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行端到端的系统测试很困难。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更加艰苦的操作和支持。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比整体而言，需要更多的设备。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几个团队的支持导致他们之间互动的协调。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
值得注意的是，在这种架构中，没有DevOps很难做任何事情。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分层架构</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分层架构是最常见的架构模式。</font><font style="vertical-align: inherit;">它也称为n层体系结构，其中n是级别数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该系统分为多个级别，每个级别仅与两个相邻的级别交互。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
体系结构并不意味着任何强制性的级别-可以有三个，四个，五个或更多。</font><font style="vertical-align: inherit;">大多数情况下，使用三层系统：表示层（客户端），逻辑层和数据层。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最常见的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">层是</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示层（用于与用户一起工作）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用层（服务-安全，访问）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">业务逻辑层（域实现）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据访问层（数据库接口的表示）。</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">封闭层</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
级别隔离的概念严格地将一个级别与另一个级别分开：您只能从一个级别转到另一个级别，并且不能一次跳过多个级别。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/e8/_f/lg/e8_flg8ejq48jeuqktddqsq73qm.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开放层</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该系统允许您跳过打开的级别并落在下面的级别上。 </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ju/hj/4m/juhj4mg2ia4fiqlrszcnjcsgkec.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MVC</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MVC的概念在1978年被描述。</font><font style="vertical-align: inherit;">MVC概念的最终版本仅在1988年发表在Technology Object杂志上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主要目标是将业务逻辑（模型）与其可视化（表示，视图）分开。</font><font style="vertical-align: inherit;">它有什么作用：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码重用的可能性增加了。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户可以在不同的上下文中同时看到相同的数据。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/wl/3r/sz/wl3rszlu169w_9qnp0en4o9jvg8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该模型提供数据并响应控制器命令，从而更改其状态。</font><font style="vertical-align: inherit;">该视图负责向用户显示模型数据，以响应模型更改。</font><font style="vertical-align: inherit;">控制器解释用户的操作，通知模型需要更改。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c-/ra/k1/c-rak1dk8qubkbyklt6wyq7bybi.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件驱动架构</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个有趣的架构。</font><font style="vertical-align: inherit;">它用于开发和实现在松耦合的软件元素之间传输事件的系统。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由不同的单一目的事件处理组件组成，这些组件异步接收和处理事件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该模板由两个主要拓扑组成-中介和代理。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转销商拓扑</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在某些过程中，需要控制步骤的顺序。</font><font style="vertical-align: inherit;">在这里，我们是有用的中介。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
体系结构组件的主要类型：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件队列；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件的调解员；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件的渠道；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件处理程序。</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
事件可以定义为“状态的重大变化”。</font><font style="vertical-align: inherit;">一个事件可以包括两个部分：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标头（事件名称，事件时间戳和事件类型）； </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正文（描述实际发生的情况）。</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中介器拓扑</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
客户端将事件发送到事件队列，该事件队列用于将事件发送到中介器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
调解器接收初始事件，并为过程的每个步骤将其他异步事件发送到事件通道。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
侦听事件通道的事件处理器从中介程序接收事件，并通过处理事件来执行某些业务逻辑。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/87/fy/dx/87fydxxf0konwhzlvlbi4dubjq4.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经纪人拓扑</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代理的拓扑与中间拓扑的不同之处在于，没有中央事件中介器。</font><font style="vertical-align: inherit;">消息流通过轻量级消息代理（例如ActiveMQ，HornetQ等）在链中的事件处理器组件之间分配。</font><font style="vertical-align: inherit;">当事件处理流程相对简单并且不需要集中的事件编排时，此拓扑很有用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事件处理器的每个组件负责处理一个事件并发布一个新事件，以指示该操作刚刚完成。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kl/kj/hn/klkjhni6aexdxz2x0vsuabfzon8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果第一种情况在“某处下方”是异步的，那么第二种情况可能是完全异步的。</font><font style="vertical-align: inherit;">一个事件生成多个事件，并且它们可以增加和增加。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优点</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 事件驱动架构：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些组件是隔离的，并允许每个组件完成而不影响系统的其余部分；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">易于部署；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高性能。</font><font style="vertical-align: inherit;">允许并行异步操作；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扩展良好。</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺点：</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难以测试；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于明显的异步性，很难开发。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无服务器架构</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是无需基础架构管理即可创建和运行应用程序和服务的方法。</font><font style="vertical-align: inherit;">该应用程序仍在服务器上运行，但是平台完全控制了这些服务器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
整个基础结构受第三方提供商的支持，并且以负责身份验证过程，消息传递等</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
的</font><font style="vertical-align: inherit;">服务的形式提供了必要的功能。</font><font style="vertical-align: inherit;">区分以下术语：</font></font><br>
<br>
<ol>
<li><b>  </b> (Function-as-a-Service) — ,             .</li>
<li><b>  </b> (Backend as a Service) — ,   -            API,   .   ,   ,  ,     .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们考虑“客户端-服务器”的体系结构，则系统中的大多数逻辑（身份验证，页面导航，搜索，事务）都由服务器应用程序实现。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rh/pl/kr/rhplkrevomwpe8q5rxrwr7eippc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在无服务器架构中，一切都有些不同。</font><font style="vertical-align: inherit;">身份验证被第三方BaaS服务（现成的云服务）替代，对数据库的访问也被另一BaaS服务替代。</font><font style="vertical-align: inherit;">应用程序逻辑部分已经在客户端内部-例如，跟踪用户的会话。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
客户端已经成为单页应用程序。</font><font style="vertical-align: inherit;">可以通过搜索服务（FaaS-作为服务）进行搜索。</font><font style="vertical-align: inherit;">购买功能也作为单独的服务（FaaS）与客户隔离。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jc/iu/jg/jciujgcrqd6hyvosnjrmdhlkqjk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好了，仅此而已，如果您对这些细节感兴趣，请观看整个视频。</font><font style="vertical-align: inherit;">至于新课程，您可以</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">在这里</font></a><font style="vertical-align: inherit;">熟悉其课程</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN493882/index.html">机器人培养：入职，指导和倦怠</a></li>
<li><a href="../zh-CN493884/index.html">STM32MP1-内核+ Linux =完美的微控制器</a></li>
<li><a href="../zh-CN493890/index.html">流氓风格的历史：从流氓到以撒的束缚</a></li>
<li><a href="../zh-CN493892/index.html">如何在家工作。删除人的清单</a></li>
<li><a href="../zh-CN493896/index.html">英特尔Pohoiki Springs-一只老鼠的神经形态簇</a></li>
<li><a href="../zh-CN493904/index.html">如何对AI失去信心，或如何用Gradient Photo Editor欺负他人</a></li>
<li><a href="../zh-CN493906/index.html">有毒的Windows快捷方式：一种旧的工件，未被黑客遗忘，但部分被取证人员遗忘</a></li>
<li><a href="../zh-CN493914/index.html">Web2Text：深度结构化的网页内容提取</a></li>
<li><a href="../zh-CN493918/index.html">大流行如何影响VPN提供商</a></li>
<li><a href="../zh-CN493920/index.html">关于...中的一个漏洞</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>