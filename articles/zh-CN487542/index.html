<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚙️ 🧚 👇 当前-超轻量级块加密（原始PRESENT的翻译：超轻量级块密码） ⏸️ 🛀🏾 👇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！这是Robert B. Weide Bogdanov，Lender，Paar，Poshman，Robshav，Seurin和Wikkelsoy撰写的原始文章“当前：超轻量级密码”的译文。
 
 
 注解
 随着AES的引入，对新的分组密码算法的需求急剧下降，因为在大多数情况下，AES是一个很...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>当前-超轻量级块加密（原始PRESENT的翻译：超轻量级块密码）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487542/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈Ha！</font><font style="vertical-align: inherit;">这是</font><strike><font style="vertical-align: inherit;">Robert B. Weide</font></strike><font style="vertical-align: inherit;"> Bogdanov，Lender，Paar，Poshman，Robshav，Seurin和Wikkelsoy撰写</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原始文章“当前：超轻量级密码”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">译文。</font></font><strike><font style="vertical-align: inherit;"></font></strike><font style="vertical-align: inherit;"></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/n7/eg/txn7egneg1_32856cpillz8r9_a.jpeg" width="400"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注解</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
随着</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><abbr title="Advanced Encryption Standard"><font style="vertical-align: inherit;">AES</font></abbr></a><font style="vertical-align: inherit;">的引入，</font><font style="vertical-align: inherit;">对新的分组密码算法</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><abbr title="Advanced Encryption Standard"><font style="vertical-align: inherit;">的</font></abbr></a><font style="vertical-align: inherit;">需求急剧下降，因为在大多数情况下，</font><acronym><font style="vertical-align: inherit;">AES</font></acronym><font style="vertical-align: inherit;">是一个很好的解决方案。</font><font style="vertical-align: inherit;">但是，尽管易于实施，但</font><acronym><font style="vertical-align: inherit;">AES</font></acronym><font style="vertical-align: inherit;">并不适合于极其有限的环境，例如</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><abbr title="Radio Frequency IDentification"><font style="vertical-align: inherit;">RFID</font></abbr></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">标签和读取器</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">本文将介绍超轻量级块加密算法PRESENT。</font><font style="vertical-align: inherit;">在算法开发过程中，既考虑了铁的实现效率，又考虑了加密的可靠性。</font><font style="vertical-align: inherit;">结果，系统要求的结果可与当今领先的紧凑流密码相媲美。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"> <abbr title="先进的加密标准"><font style="vertical-align: inherit;"></font></abbr></a><font style="vertical-align: inherit;"></font><acronym><font style="vertical-align: inherit;"></font></acronym><font style="vertical-align: inherit;"></font><acronym><font style="vertical-align: inherit;"></font></acronym><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><abbr title="射频识别"><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.简介</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本世纪IT的主要发展方向是小型计算设备的开发，这些设备不仅用于消费类产品，而且还构成了环境中不可或缺的组成部分-通信基础架构。已经揭示出，这样的实现产生了一系列非常具体的安全威胁。同时，可用的密码解决方案，即使是原始的密码解决方案，通常也不适合在资源高度受限的环境中使用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我们提供了一种新的，经过硬件优化的块密码算法，该算法以最大可能的大小和功率限制开发。同时，我们试图避免破坏数据。为此，我们利用了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><abbr title="数据加密标准-对称加密算法"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DES的</font></font></abbr></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经验</font><font style="vertical-align: inherit;">并补充了属性</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><abbr title="AES竞赛决赛入围者算法"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蛇</font></font></abbr></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在硬件方面表现出惊人的性能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也许值得解释为什么我们决定开发一种新的分组密码，因为公认的事实是流密码可能更紧凑。确实，在开始的时候，我们努力在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eSTREAM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目的工作过程中了解紧凑流密码的设计</font><font style="vertical-align: inherit;">，以及其他一些有希望的速效假设。但是我们注意到了仍然选择分组密码的几个原因。首先，块加密是通用和原始的，并且在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加密模式下使用时</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即使用已经加密的块来加密以下内容，我们将获得流加密。其次，并且也许主要是，与流加密算法的操作原理相比，似乎更好地研究了分组密码操作原理的复杂性。例如，虽然有一个广泛的理论基于使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有线性反馈</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">移位寄存器</font></a><font style="vertical-align: inherit;">，但是以一种安全的方式组合这些模块并不容易。我们假设，设计整齐的分组密码可能比新创建的流密码更安全。因此，我们发现，与密闭流密码一样需要大量铁资源的分组密码可能非常有趣。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要的是要注意，当创建新的分组密码算法时，尤其是在具有引人注目的性能时，我们不仅追求创新。相反，密码的开发和实施是齐头并进的，揭示了一些基本限制和固有限制。例如，给定的安全级别对最小密钥和块长度施加了限制。即使使用80位密钥处理64位状态也限制了最小设备大小。您还可以注意到，硬件中的实施例-尤其是硬件实现的紧凑性-有助于重复性。即使很小的变化也会对设备的体积产生不利影响。但是，密码分析家还重视可重复性，并寻找易于在许多轮中相乘的数学结构。那么可以使用多少个简单的重复结构而不会影响系统安全性？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，本文将介绍紧凑块密码PRESENT。</font><font style="vertical-align: inherit;">在简短回顾现有文献之后，我们以标准形式设计了本文的其余部分。</font><font style="vertical-align: inherit;">在第3节中描述了代码，在第4节中描述了设计决策。</font><font style="vertical-align: inherit;">在第5节中，我们将考虑安全性，而第6节中将对性能进行详细分析。</font><font style="vertical-align: inherit;">这项工作以我们的结论结束。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.现有作品</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管致力于廉价密码学的工作量在不断增长，但是致力于超轻密码技术的文章数量却惊人地少。将重点放在协议设备上，我们将不再参考廉价的通信和识别协议。 eSTREAM项目目前是紧凑型实施方面最广泛的工作之一。作为该项目一部分的一部分，提出了适用于在硬件中有效实施的新流密码。在这项工作的过程中，概述了有希望的候选人。到目前为止，这些比率是近似的，但是从实施手册中可以得出，eSTREAM项目的紧凑密码将需要大约1300-2600 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GE（当量门）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在分组密码中，考虑到设备的效率，创建了一种广为人知的密码，即DES。考虑到1970年代初期半导体的发展非常有限，DES具有非常有竞争力的实现特性也就不足为奇了。在开发过程中，在DES上花费了3000GE，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序列化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">后</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">，</font></a><font style="vertical-align: inherit;">这个数字下降到2300GE。但是，DES密钥的长度限制了它在许多应用中的用途，并导致这样一个事实，即在其基础上进行了专门的修改，例如，增加了加密强度或扩展了密钥。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于现代分组密码，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供了对低成本</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">AES</font></a><font style="vertical-align: inherit;">的全面分析</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，其实现需要大约3,600 GE，这是对8位和32位处理器罚款设计的间接结果。</font><font style="vertical-align: inherit;">系统要求&lt;a href =“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TEA是</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未知的，但据估计，它们需要大约2100 GE。还有4种针对低成本设备设计的解决方案：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mCRYPTON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（精确执行2949 GE），</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HIGH</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（大约3000 GE），</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（大约2280 GE）和CGEN（也大约是2280 GE），尽管后者并未被视为分组密码。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.当前的分组密码</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当前是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SP网络</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的特例</font><font style="vertical-align: inherit;">，由31轮组成。块长度为64位，并且支持80位和128位两种版本的密钥。对于通常用于基于标签进行部署的低安全性应用程序，此保护级别应该足够了，此外，更重要的是，PRESENT的设计功能与eSTREAM项目的流密码在很大程度上相吻合，并针对硬件中的有效实现进行了优化，从而使我们能够进行充分比较其。</font></font><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原始文章的附录中提供了128位版本的安全要求和操作属性。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
31个回合中的每个回合都包含XOR操作，以输入1≤i≤32的密钥K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“删除”密钥</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，线性按位排列和非线性替换层（或更简单地说，增加加密强度）。非线性层使用单独的4位</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S块</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，每轮并行应用16次。图中显示了伪代码描述的密码：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/39/jf/bc/39jfbcgtriqxlsbdkyojjycyc_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在依次确定每个阶段。在第4节中给出了设计依据，并且从头开始在一个块或一个字中从头开始对位进行编号。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加一个回合键（addRoundKey）。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">圆形键K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中1≤i≤32，以及当前状态b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。添加回合密钥到当前状态发生模2（B </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ĵ</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = B </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ĵ</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ⊕ķ </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ĵ</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中0≤Ĵ≤63）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S-Box层（sBoxlayer）。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRESENT中使用的S块将4位块映射到4位块。下表显示了该块在十六进制系统中的作用：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5d/dv/2a/5ddv2ahldslwpoziqdpth4a5dwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于S块层，当前状态b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为16个4位字w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i + 3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> || b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i + 2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> || b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> || b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示0≤i≤15。帧输出S [w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]以明显的方式返回更新的状态值。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">置换层（pLayer）。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下表中定义的PRESENT按位排列使用（位i的状态转移到位置P（i））：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/et/bh/ng/etbhngoueocjgcnf0hhswl-lobs.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">密钥转换（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">密钥调度</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRESENT可以使用80位和128位密钥，但是，我们将重点介绍80位版本。用户提供的密钥存储在密钥寄存器K中，表示为k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在第i个回合上，一个64位回合密钥K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">62</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，由寄存器K当前内容的64个左位组成。因此，在第i轮中，我们有：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">62</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在打开圆形密钥K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i的</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包装后</font><sub><font style="vertical-align: inherit;">，</font></sub><font style="vertical-align: inherit;">密钥寄存器K = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0的</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新如下：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] = [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">千</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">77</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">76</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] = S [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">77</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">76</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] = [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]⊕round_counter </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，寄存器密钥向左移动61个位置，通过S块和round_counter的最左边4个位将i的值与k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font><sub><font style="vertical-align: inherit;">15</font></sub><font style="vertical-align: inherit;">取</font><font style="vertical-align: inherit;">模2</font></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从K开始，从round_counter到右边的最低有效位。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/jl/5d/o1/jl5do1gwvqcgmezpu_id0cdsxhi.png"><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在原始文章的附录中可以找到128位算法的密钥转换。</font></font></em><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. PRESENT的设计特征</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了安全和有效的实现，PRESENT的主要成就是它的简单性。</font><font style="vertical-align: inherit;">因此，在其他情况下采用类似的项目，甚至将其用作学生的教科书也就不足为奇了。</font><font style="vertical-align: inherit;">在本节中，我们将说明在设计PRESENT时所做的决定的合理性。</font><font style="vertical-align: inherit;">但是，首先，我们描述了预期的应用程序需求。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1。</font><font style="vertical-align: inherit;">目的和应用环境</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在设计适用于严格约束环境的分组密码时，重要的是要了解我们并未创建肯定适用于许多情况的分组密码-为此需要使用AES。</font><font style="vertical-align: inherit;">相反，我们针对的是AES不适合的非常特殊的应用。</font><font style="vertical-align: inherit;">前述确定以下特征。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 密码将在“硬件”中实现</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅需要应用程序来调整安全级别。</font><font style="vertical-align: inherit;">因此，一个80位密钥将是一个可靠的解决方案。</font><font style="vertical-align: inherit;">请注意，eSTREAM项目的流密码的开发人员坚持相同的立场。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用程序不需要加密大量数据。</font><font style="vertical-align: inherit;">因此，可以在不进行太多更改的情况下针对性能或空间优化实现。</font></font></li>
<li>     ,      .   ,       (       ).</li>
<li>      ,  ,         , , ,      .</li>
<li>  ,      ,        (encryption-only mode).  ,      - (challenge-response)  , ,    ,          ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"> </a>.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基于这些考虑，我们决定将PRESENT创建为具有80位密钥的64位分组密码。在这种情况下，加密和解密具有大致相同的物理要求。具有支持加密和解密的能力，PRESENT将比仅支持AES加密更紧凑。而且在仅加密执行的情况下，我们的密码将是完全超级容易的。加密</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子密钥</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将随时计算。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文献中有许多例子说明了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间，日期和记忆之间的折衷</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">攻击，或使用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">生日</font></a><font style="vertical-align: inherit;">悖论的攻击</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加密大量数据时。</font><font style="vertical-align: inherit;">但是，这些攻击仅取决于密码的参数，而不使用内部结构。</font><font style="vertical-align: inherit;">我们的目标是使这些攻击尽可能地对我们使用。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三方通道</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">攻击和直接断片攻击对PRESENT的威胁与其他</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加密原语</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一样多</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，对于可能的应用程序，适度的安全性要求实际上使攻击者的利益非常有限。</font><font style="vertical-align: inherit;">在风险评估中，此类威胁不被视为重要因素。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2。</font><font style="vertical-align: inherit;">排列层</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在选择按键混合层时，我们对硬件效率的关注需要一个线性层，该层可以用最少数量的控制元件（例如晶体管）来实现。</font><font style="vertical-align: inherit;">这导致按位排列。</font><font style="vertical-align: inherit;">注意简单性，我们选择了常规的按位排列，这有助于进行透明的安全性分析（请参阅第5节）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3。</font><font style="vertical-align: inherit;">S块。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在PRESENT，我们使用单独的S块将4位转换为4位（F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> →F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。这是我们对硬件效率的渴望的直接结果，并且这种S块的实现通常比8位S块紧凑得多。由于我们将位图置换用于线性扩散层，因此类似AES的扩散技术不是我们密码的选择。因此，我们在S块上放置一些附加条件，以减少所谓的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“雪崩效应”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。更精确地，S-块PRESENT满足下述条件，在这里我们通过表示傅立叶系数S </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小号</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W¯¯ </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（A）=Σ（-1）</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的&lt;b，S（x）的&gt; + &lt;A，X&gt;</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，x∈F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1.对于任何固定的非零输入偏置Δ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∈˚F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和任何固定非零输入偏置Δ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ö</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∈˚F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的S-块内，我们要求</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
＃{X∈˚F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | S（X）+ S（X +Δ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）=Δ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ö</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> }≤4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.对于任何固定的非零输入差分Δ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∈˚F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和任何固定非零输出差Δ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ö</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∈˚F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，使得重量（Δ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）=重量（Δ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ø</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）= 1 ，我们有</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{x∈F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">| S（x）+ S（x + ∆ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）= ∆ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> } =∅3 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.对于所有非零a∈F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和所有非零b∈F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4，</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其| S </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（a）| </font><font style="vertical-align: inherit;">≤8 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.对于所有非零a∈F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和所有非零b∈F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，使得wt（a）= wt（b）= 1，S </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（a）=±4 </font><font style="vertical-align: inherit;">成立，</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从第5节清楚可见这些条件确保PRESENT能够抵抗</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">差分</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性攻击</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用满足上述条件的所有4位S块的分类，我们选择了S块，它特别适合于高效的硬件实现。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.安全性分析</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们将介绍PRESENT安全分析的结果。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">差分和线性密码分析</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
差分和线性密码分析是密码分析人员可用的一些最强大的方法。</font><font style="vertical-align: inherit;">为了测量PRESENT对差分和线性密码分析的抵抗力，我们为参与差分（或线性）特性的所谓活动S块的数量设置了下限。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">差分密码分析</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下定理涵盖了差分密码分析的情况。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定理1. </font></font></b> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PRESENT的任何五回路微分特性都具有至少10个活动S块。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定理1在原始文章的附录3中得到了证明，我们将继续观察。</font><font style="vertical-align: inherit;">我们将16个S块分为4组：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cu/vb/xb/cuvbxb5bl5psjid8dpwqxjwpkiq.png"><br>
<br>
<sub><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入（上面）的数字表示上一步中S块的编号，而输出（底部）的数字表示下一个编号。</font></font></em></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
请注意：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S块的输入位来自同一组的4个不同的S块。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">四个S块组的输入位来自16个不同的S块。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来自特定S块的四个输出位包含在四个不同的S块中，每个S块在下一轮中都属于一个单独的S块组。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同组中s块的输出位进入不同的s块。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据定理1，超过25轮PRESENT的任何微分特性必须至少具有5×10 = 50个活动S块。 PRESENT S块的最大微分概率为2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">--2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此单个25轮微分特性的概率限制为2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-100</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">先进的方法允许密码分析者从密码中删除外部回合以使用较短的特征;但是，即使我们允许攻击者从密码中删除六回合（这是前所未有的情况），使用其余25轮差分特征所需的数据也将超过可用数量。</font><font style="vertical-align: inherit;">因此，安全边界不仅仅是可靠的。</font><font style="vertical-align: inherit;">但是，我们实际上已经确认了定理1中活动S块数的边界是紧密的。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际确认</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以定义特征，包括五个回合中的十个S块。接下来的两轮迭代特征是每轮包含两个S块，并在</font><font style="vertical-align: inherit;">5轮内</font><font style="vertical-align: inherit;">保持</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2-25</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的概率</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
保持更复杂的特征的概率</font><font style="vertical-align: inherit;">为5轮</font><font style="vertical-align: inherit;">2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-21</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管此第二个特征的概率非常接近2 </font><sup><font style="vertical-align: inherit;">-20</font></sup><font style="vertical-align: inherit;">的边界</font></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它不是迭代的，几乎没有实用价值。</font><font style="vertical-align: inherit;">相反，我们通过实验确认了两轮迭代微分的可能性。</font><font style="vertical-align: inherit;">在使用223个选定的明文对使用100多个独立子键进行的实验中，可以预测观察到的概率。</font><font style="vertical-align: inherit;">这似乎表明，对于该特定特征，没有伴随的显着差异。</font><font style="vertical-align: inherit;">但是，即使我们的初步分析令人鼓舞，确定任何差异影响的程度也是一项复杂且耗时的任务。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性密码分析</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在以下定理中考虑了线性PRESENT密码分析的情况，在该定理中，我们分析了四轮PRESENT的最佳线性近似。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定理2。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">令E </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4R</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为使用PRESENT进行的四轮近似的最大线性位移。那么E </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4R</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ≤2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该定理的证明包含在原始文章的附录4中。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，对于28轮，最大排量将为</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×E </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4R </font></font></sub><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-43</font></font></sup><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，假设密码分析家在PRESENT中仅需要31轮中的28轮来发起密钥恢复攻击，那么线性密码密码分析将需要大约2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">84个</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已知的明文/密码文。</font><font style="vertical-align: inherit;">此类数据要求超出了可用文本。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一些高级差分/线性攻击</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PRESENT结构使我们可以考虑一些特殊的攻击形式。但是，没有一个方法导致攻击所需要的文本少于线性密码分析所要求的文本下限。在杰出的攻击中，我们考虑了一种使用回文差异的攻击，因为对称差异在扩散层和某些高级版本的差分线性攻击中持续存在的可能性为一个（即始终）。尽管这些攻击在几轮攻击中似乎很有希望，但它们很快失去了实用价值，不太可能在当前的密码分析中有用。我们还发现</font><font style="vertical-align: inherit;">，尽管接下来的两轮</font><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">截短的差分密码分析</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的价值可能有限。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
截断的扩展概率为1。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
即使当用于减小已经确定的差分特性的长度时，数据需求仍然过多。</font><font style="vertical-align: inherit;">排名扩展的可能性为1。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2。</font><font style="vertical-align: inherit;">结构性攻击</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
诸如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集成密码分析</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和瓶颈分析之</font><font style="vertical-align: inherit;">类的结构攻击</font><font style="vertical-align: inherit;">非常适合于分析类似AES的密码。</font><font style="vertical-align: inherit;">这样的密码具有很强的类单词结构，其中的单词通常是字节，但是，表示结构几乎完全是按位的，尽管置换操作有些规律，但密码结构中按位操作破坏了单词结构的发展和分布。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3。</font><font style="vertical-align: inherit;">代数攻击</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代数攻击用于</font><font style="vertical-align: inherit;">流密码而不是阻塞时</font><font style="vertical-align: inherit;">，通常</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">导致成功失败。但是，PRESENT的简单结构意味着它们值得认真研究。通过字段G（2）上的八个输入/输出位变量的21个二次方程式描述了PRESENT S块。这并不奇怪，因为众所周知，至少可以用21个这样的方程式描述任何四位S块。然后，可以通过变量v = n×8中的二次方程e = n×21来描述整个密码，其中n是加密和密钥变换算法中S块的数量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于PRESENT，我们有n =（31×16）+ 31，所以整个系统由11,067个二次方程组成，包含4,216个变量，求解一个多维二次方程组的一般问题是NP-hard。但是，获得的用于分组密码的系统非常罕见，因为它们由n个由简单线性层连接的小系统组成。但是，尚不清楚这一事实是否可以用于所谓的代数攻击。已经提出了一些专门的方法，例如XL和XSL，尽管在这两种方法中都发现了缺点。相反，通过应用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buchberger</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">F4</font></a><font style="vertical-align: inherit;">算法可以获得关于分组密码的代数密码分析的唯一实际结果。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为岩浆的一部分。在小规模版本的AES上进行的建模表明，除了最小的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SP网络之外</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">所有其他</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">网络</font></a><font style="vertical-align: inherit;">在时间和内存复杂性方面都会迅速出现困难。现在也一样。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际确认。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用岩浆中的F4算法对小规模版本进行了仿真。</font><font style="vertical-align: inherit;">当有一个S块（即一个很小的块，大小为4位）时，岩浆可以多次求解所得方程组。</font><font style="vertical-align: inherit;">但是，随着块大小的增加和S块的添加以及线性扩散层的相应变体，方程组很快变得太大。</font><font style="vertical-align: inherit;">即使考虑由七个S块组成的系统（即块大小为28位），我们也无法在合理的时间内获得通过两轮的缩短密码版本的解决方案。</font><font style="vertical-align: inherit;">我们的分析表明，代数攻击不太可能对PRESENT构成威胁。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.4。</font><font style="vertical-align: inherit;">密钥转换攻击</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于没有针对关键转换的开发的既定指南，因此既存在各种各样的项目，又有基于项目特征的各种各样的攻击。</font><font style="vertical-align: inherit;">最有效的攻击属于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对相关密钥</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">攻击</font></a><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">剪切攻击</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的总称</font><font style="vertical-align: inherit;">，二者均基于不同子密钥集之间可识别关系的构建。</font><font style="vertical-align: inherit;">为了应对这种威胁，我们使用了与轮数相关的计数器，因此子密钥集不容易“转移”，并且我们使用非线性运算来混合密钥寄存器K的内容。特别是：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">密钥寄存器中的所有位都是用户在第21轮提供的80位密钥的非线性函数，</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第21轮之后，密钥寄存器中的每个位都取决于至少四个用户提供的密钥位，并且</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到我们得到K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32时</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，六位是80个用户提供的密钥位中第二级的表达式，24位是三级，而其余位是六级或九位用户提供的密钥位的函数。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们相信这些属性足以抵御基于密钥转换的密钥攻击。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.“铁”的生产率</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VHDL中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现了PRESENT-80，</font><font style="vertical-align: inherit;">并基于UMC L180 0.18μ1P6M Logic将其调整为适用于标准虚拟硅单元库（VST）。我们使用Mentor Graphics Modelsim SE PLUS 5.8 c进行仿真，并使用Synopsys Design Compilerversion Y-2006.06进行功耗的综合和建模。使用铸造厂的典型值（核心电压为1.8伏，温度为25°C），并使用建议的导线负载模型对功率进行建模。请注意，这种仿真是针对大约10,000 GE的结构，因此对于小得多的结构，功率结果将是悲观的。在图像上</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tt/8i/bg/tt8ibga5aprmwzqrrckekekzv2a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所示的数据路径是经过空间优化的PRESENT-80，没有解密的可能性（仅加密），每个循环执行一次回合，即数据路径为64位宽。请注意，在目前的设计阶段，我们使用16次相同的S块，而不是使用16个不同的S块，这有利于项目的进一步序列化，即使用4位数据通道。我们的实现需要32个时钟周期来使用80位密钥加密64位明文，占用1570 GE，调制时功耗为5 micW。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ek/7o/xq/ek7oxqtiawboi4wjqqrivgxvzmy.png"><br>
<br>
<em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前空间需求</font></font></sup></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大部分区域被用于存储密钥和数据状态的触发器占用，随后是S层和XOR密钥部门。</font><font style="vertical-align: inherit;">仅当实现到达布局和布线阶段时，简单的置换位置换才会增加面积。</font><font style="vertical-align: inherit;">请注意，我们实现的主要目标是少量硬件，但是，我们还综合了针对功耗进行优化的过程。</font><font style="vertical-align: inherit;">如果再增加53 GE，我们的能耗仅为3.3μW，而当前的128 GE将占据1886 GE的估计面积。</font><font style="vertical-align: inherit;">除了很小的尺寸外，PRESENT还具有相当高的吞吐量，每比特能量高。</font><font style="vertical-align: inherit;">下表中提供了与其他密码的比较：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m9/yt/7j/m9yt7jonvvcpkjnluz273z1ksga.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.结论</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我们描述了新的PRESENT分组密码。</font><font style="vertical-align: inherit;">我们的目标是提供一种超轻型密码，它提供与64位块和80位密钥的大小相称的安全级别。</font><font style="vertical-align: inherit;">结果，PRESENT具有类似于许多紧凑流密码的实现要求。</font><font style="vertical-align: inherit;">因此，我们认为这具有理论和实践意义。</font><font style="vertical-align: inherit;">像所有新提案一样，我们不鼓励立即部署PRESENT，而是敦促对其进行分析。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">告白</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
欧盟委员会通过欧盟研究与开发框架计划6（ST。UbiSec＆Sens）的STREP UbiSec＆Sens（www.ist-ubisecsens.org）部分支持了本文档中介绍的工作。</font><font style="vertical-align: inherit;">本文档中包含的观点和结论是作者的观点和结论，不应解释为构成UbiSec＆Sens项目或欧洲委员会表达或认可的官方政策或认可。</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN487524/index.html">为什么硬件启动黑客马拉松需要</a></li>
<li><a href="../zh-CN487528/index.html">Изменения в пользовательском соглашении и политике конфиденциальности на сервисах Хабра</a></li>
<li><a href="../zh-CN487534/index.html">etcd 3.4.3：存储可靠性和安全性研究</a></li>
<li><a href="../zh-CN487538/index.html">.NET Interactive在这里！| .NET笔记本预览2</a></li>
<li><a href="../zh-CN487540/index.html">HighLoad ++，Anastasia Tsymbalyuk，Stanislav Tselovalnikov（Sberbank）：我们如何成为MDA</a></li>
<li><a href="../zh-CN487544/index.html">.NET文档：一月份的新增功能</a></li>
<li><a href="../zh-CN487548/index.html">新实验：使用gRPC-Web从浏览器调用.NET gRPC服务</a></li>
<li><a href="../zh-CN487550/index.html">Python中的3D图片（几乎）具有正常性能</a></li>
<li><a href="../zh-CN487552/index.html">Swift 5.2-有什么新功能？</a></li>
<li><a href="../zh-CN487556/index.html">OpenStreetMap第497号世界的新闻（01/21 / 2020-27.01.2020）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>