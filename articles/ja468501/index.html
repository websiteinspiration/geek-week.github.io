<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏻 😰 👩🏻‍🌾 100万回実行しても画像が破損しないフィルターを作成する方法 🏇🏼 💪🏽 📸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="新しいWebコミックMeow the InfiniteのWebアーキテクチャの作成が完了したので、長い間延滞していた技術記事を書くときがきたと判断しました。この記事では、数年前に開発したフィルターに焦点を当てます。それはやる価値があるように思えますが、ビデオ圧縮の分野ではこれまで議論されたことはあり...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>100万回実行しても画像が破損しないフィルターを作成する方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468501/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいWebコミック</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meow the Infinite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のWebアーキテクチャの作成が完了したので、</font><font style="vertical-align: inherit;">長い間延滞していた技術記事を書く</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ときがきた</font></a><font style="vertical-align: inherit;">と判断しました。この記事では、数年前に開発したフィルターに焦点を当てます。それはやる価値があるように思えますが、ビデオ圧縮の分野ではこれまで議論されたことはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2011年に「ハーフペルフィルター」を開発しました。これは特別な種類のフィルターで、入力画像を受け取り、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正確に半分のピクセルを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シフトしたときに画像がどのように見えるかを最も説得力のある方法で表示します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこのようなフィルターが必要なのか疑問に思われるでしょう。実際、これらは現代のビデオコーデックでは非常に一般的です。ビデオコーデックは同様のフィルターを使用して、前のフレームのフラグメントを取得し、後続のフレームで使用します。古いコーデックはフレームデータを一度にピクセル全体しか移動しませんでしたが、新しいコーデックはさらに進んで、小さな動きをよりよく送信するために半分または1/4ピクセルのシフトを可能にしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従来のハーフペルフィルターの動き補償アルゴリズムの動作を分析するとき、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェフロバーツ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、連続するフレームに繰り返し適用するとすぐに劣化し、アーティファクトを修正するために必要以上のデータをビデオコンプレッサーの他の部分に使用させることを発見しました。</font><font style="vertical-align: inherit;">これらの修正を無効にして、ハーフペルフィルターの「生の」結果を見ると、これは元の画像です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これに変わります：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオの1秒後。</font><font style="vertical-align: inherit;">当然のことながら、各フレームは画像を半ピクセルずつシフトするため、横にシフトします。</font><font style="vertical-align: inherit;">しかし、結果は元の画像の置き換えられたバージョンのようには見えず、ひどく歪んでいます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「1秒のビデオ」の間、フィルターは実際に何度も適用されます。ビデオが60フレーム/秒の頻度で再生される場合は60です。しかし、理想的には、このような歪みに耐性のあるフィルターが必要です。それらがあったとしても、スムーズにスクロールするビデオはそれほど多くのアーティファクト修正でエンコードされていなかったでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオ圧縮の領域に精通している場合は、なぜハーフペルフィルターを2回以上使用する必要があるのか​​疑問に思われるかもしれません。最後に、ハーフペルフィルターを2回適用すると、既に1つのピクセル全体が移動しているので、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレーム</font><font style="vertical-align: inherit;">のデータを使用して</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取得</font><i><font style="vertical-align: inherit;">する</font></i><font style="vertical-align: inherit;">だけでは</font><font style="vertical-align: inherit;">どうでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
答えはそれほど単純ではありません。まず、データをエンコードするために必要なデータが多いほど、圧縮率が低くなります。したがって、「どのフレームからデータを取得するか」など、あまり多くのデータを必要とせずにエンコードを開始すると、ビデオはあまり圧縮されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これは最も重要ではありません。主な問題は、前のフレームから情報を取得する必要がある場合、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらを保存する必要があること</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。 1つではなく前の2つのフレームを保持するには、メモリが2倍あることを推測する必要があります。最近のCPUの場合、これは特別な問題ではなく、大量のメモリがあり、そのような些細なことはそれらを気にしません。しかし、これは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題です</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少量のメモリを搭載したデバイス（携帯電話、内蔵電子機器など）で動作する、高速でポータブルな、広く使用されているビデオ形式を作成する場合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハーフペルフィルターを使用しないように、動きを補正するために実際に複数のフレームを保存することは望ましくありません。</font><font style="vertical-align: inherit;">そのため、ここで何が起こっているのかを正確に調べ、そのような問題のないフィルターを作成できるかどうかを確認するように指示されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それ以前は、フィルターを使用したことがなく、フィルターが通常どのように開発されるのかわかりませんでした。</font><font style="vertical-align: inherit;">奇妙なことに、私はこの問題を偏見なく見なければならなかったので、それは私の好意であることがわかりました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基礎</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も人気のあるハーフペルフィルターが同様の構造を持っていることにすぐに気付きました。出力画像の各ピクセルに対して、入力画像の2〜8ピクセルが取得され、サンプリングされて特定の係数と混合されます。異なるフィルターは、サンプリングされたソースピクセルの数（多くの場合、フィルター開発者の専門用語ではタップと呼ばれます）とピクセル混合係数のみが異なります。これらの係数は「フィルターカーネル」と呼ばれることが多く、フィルターを完全に説明するために必要なのはこれだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像のあらゆる種類のサンプリングまたはリサンプリング（たとえば、画像のスケーリング）に精通している場合、これは明らかです。</font><font style="vertical-align: inherit;">基本的に、フィルターは同じことを行います。</font><font style="vertical-align: inherit;">ビデオ圧縮はさまざまな研究が行われている広大な領域である</font><font style="vertical-align: inherit;">ため、単純なフィルタリング以外の動きを補正する方法</font><font style="vertical-align: inherit;">が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にもたくさんあることは明らかです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、一般的なコーデックは通常、画像スケーリングフィルターと本質的に同じハーフペルフィルターを使用した動き補償手順を使用します。元のピクセルを取得し、いくつかの重みを掛け、それらを加算して出力ピクセルを取得します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「切れ味」の必要性</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、画像を半ピクセルずつシフトする必要があります。あなたがグラフィックスプログラマーであるが、フィルタリングにあまり詳しくない場合は、「問題もあるので、バイリニアフィルターを使用する」と考えるかもしれません。これは、ここで発生するように、2つの受信データ要素間の中間値を計算する必要がある場合に、グラフィックを操作する際の標準的なプロセスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピクセルのちょうど半分を移動するための双線形フィルターは、次のフィルターコアで簡単に説明できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// NOTE(casey): Simple bilinear filter</span>
BilinearKernel[] = {<span class="hljs-number">1.0</span>/<span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>/<span class="hljs-number">2.0</span>};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは機能しますが、問題がないわけではありません。目標が高品質の画像であり、ビデオ圧縮の場合の目標はそれだけである場合、双線形フィルターは、必要以上にぼかしを結果に加えるため、最良の解決策ではありません。それほど</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多く</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はありません</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">、他のフィルターが作成する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以上の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを明確に示すために、最も一般的なフィルターを1回適用した後の元の画像からのセイウチの目の近似画像を次に示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/97d/17e/1b097d17ed0bf71252e43527442a852b.png" width="670" height="140"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左側はオリジナル、右側はバイリニアフィルタリングです。それらの間には、ビデオコーデックに最も広く使用されているハーフペルフィルターがあります。よく見ると、</font><font style="vertical-align: inherit;">ほんの少しぼやけ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ている</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイリニア</font><font style="vertical-align: inherit;">画像を</font><i><font style="vertical-align: inherit;">除いて、</font></i><font style="vertical-align: inherit;">ほとんどすべての画像が似ていることがわかります</font><font style="vertical-align: inherit;">。ぼやけはそれほど多くありませんが、主な目的が画質である場合、これはバイリニアフィルターよりも別のフィルターを選ぶのに十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、他のフィルターはどのようにして鮮明度を「維持」し、ぼかしを回避するのでしょうか。バイリニアブラーのコアがどのように見えるかを思い出してみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs">BilinearKernel[] = {<span class="hljs-number">1.0</span>/<span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>/<span class="hljs-number">2.0</span>};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とてもシンプルです。画像を半分のピクセルだけシフトするために、ピクセルを取り、それを隣接ピクセルと50％混合します。それで全部です。明るい白のピクセルが暗い黒に隣接している場所では、これらの2つのピクセルはバイリニアフィルタリング中に平均化され、境界を「柔らかく」する灰色のピクセルを作成するため、これがどのように画像を「ぼかす」か想像できます。これはすべてのピクセルで発生するため、文字通り、色や明るさがはっきりと異なるすべての領域で発生します。スムーズに。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、高品質のコーデックでは、バイリニアフィルタリングは動き補償に使用されません（ただし、他のケースでは使用できます）。代わりに、次のようなシャープネスを保持するフィルターが使用されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// NOTE(casey): Half-pel filters for the industry-standard h.264 and HEVC video codecs</span>
h264Kernel[] = {<span class="hljs-number">1.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">-5.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">20.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">20.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">-5.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">1.0</span>/<span class="hljs-number">32.0</span>};<font></font>
HEVCKernel[] = {<span class="hljs-number">-1.0</span>/<span class="hljs-number">64.0</span>, <span class="hljs-number">4.0</span>/<span class="hljs-number">64.0</span>, <span class="hljs-number">-11.0</span>/<span class="hljs-number">64.0</span>, <span class="hljs-number">40.0</span>/<span class="hljs-number">64.0</span>, <span class="hljs-number">40</span>/<span class="hljs-number">64.0</span>, <span class="hljs-number">-11.0</span>/<span class="hljs-number">64.0</span>, <span class="hljs-number">4.0</span>/<span class="hljs-number">64.0</span>, <span class="hljs-number">-1.0</span>/<span class="hljs-number">64.0</span>};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、バイリニアフィルタリングで考慮されたのは2ピクセルのみですが、これらのフィルターでは6（h.264）ピクセルまたは8（HEVC）ピクセルさえ考慮されています。さらに、これらのピクセルの通常の加重平均値を計算するだけでなく、一部のピクセル</font><font style="vertical-align: inherit;">に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">負の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重み</font><font style="vertical-align: inherit;">を使用して、</font><font style="vertical-align: inherit;">これらのピクセルを他の値から</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">減算し</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜ彼らはそれをしているのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは非常に簡単に理解できます。正の値と負の値の両方を使用し、さらに広い「ウィンドウ」を考慮して、フィルターは</font><i><font style="vertical-align: inherit;">違い</font></i><font style="vertical-align: inherit;">を考慮に入れることができます</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隣接するピクセル間で、最も近い2つの最も近いピクセルのシャープネスをシミュレートします。</font><font style="vertical-align: inherit;">これにより、ピクセルが隣接ピクセルと大きく異なる場所でも、結果の画像の鮮明さを維持できると同時に、平均化を使用して「ハーフピクセル」シフトの信頼できる値を作成できます。これは、入力画像のピクセルの組み合わせを反映している必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不安定なフィルタリング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、問題は解決されましたか？はい、可能ですが、ハーフピクセルのオフセットを1つだけ行う必要がある場合。ただし、これらの "シャープ化"フィルター（ここでは意図的にこの用語を使用しています）は、実際には</font><font style="vertical-align: inherit;">バイリニアフィルタリング</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と同じよう</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">、危険な</font><font style="vertical-align: inherit;">ことをしています。彼らはそれを隠す方法をよく知っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
双一次フィルタリング</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像の鮮明度を</font><i><font style="vertical-align: inherit;">低下させる</font></i><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、これらの標準フィルター</font><font style="vertical-align: inherit;">は、ある種のグラフィックスプログラムの</font><font style="vertical-align: inherit;">鮮鋭化</font><font style="vertical-align: inherit;">操作のように、</font><font style="vertical-align: inherit;">鮮明度を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向上さ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">せます。鮮鋭化の量は非常に少ないので、フィルターを1回だけ実行しても、気付かないでしょう。ただし、フィルタリングが数回実行されると、これは非常に顕著になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、残念ながら、この鮮明化は手続き型であり、ピクセル間の違いに依存</font><font style="vertical-align: inherit;">するため、画像を破壊するまで同じ境界を繰り返し鮮明に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するフィードバックループ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><i><font style="vertical-align: inherit;">作成します</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これを具体例で示すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上-元の画像、下-バイリニアフィルタリングあり、60フレームで実行：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご想像のとおり、ぼかしは、かなりぼやけるまで画像の鮮明度を下げ続けます。</font><font style="vertical-align: inherit;">これで、オリジナルが一番上になり、h.264コーデックハーフペルフィルターが60フレームで実行されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このゴミを全部見ましたか？</font><font style="vertical-align: inherit;">フィルターは、バイリニアフィルタリングの「ぼかし」効果と同じですが、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逆も同様です。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「画像の鮮明さを増し」、ディテールが強く歪んだ明るい/暗いパターンに変わったすべての部分を再現しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8ピクセルを使用するHEVCコーデックはより良い動作をしますか？</font><font style="vertical-align: inherit;">まあ、それは間違いなくh.264よりも優れています：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、時間を60フレーム（1秒）から120フレーム（2秒）に増やしても、フィードバックがあり、画像が破壊されていることがわかります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
信号処理が好きな人のために、参照用にウィンドウ付きシンクフィルター（Lanczosフィルターと呼ばれる）も追加します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// NOTE(casey): Traditional 6-tap Lanczos filter</span>
LanczosKernel[] = {<span class="hljs-number">0.02446</span>, <span class="hljs-number">-0.13587</span>, <span class="hljs-number">0.61141</span>, <span class="hljs-number">0.61141</span>, <span class="hljs-number">-0.13587</span>, <span class="hljs-number">0.02446</span>};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、なぜ誰かが「ウィンドウ化されたsinc」に関心を持つ可能性があるのか​​は説明しませんが、このフィルターは理論的な理由で人気があると言えば十分なので、60フレーム（1秒）を処理するときの外観を見てください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
120フレーム（2秒）を処理する場合：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
h.264より優れており、HEVCとほぼ同じです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安定したフィルタリング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
h.264、HEVC、ウィンドウ化されたsincよりも優れた結果を得るにはどうすればよいですか？そして、彼らはどれほど良くなることができますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオ圧縮に関する文献で</font><font style="vertical-align: inherit;">同様の質問</font><i><font style="vertical-align: inherit;">を</font></i><font style="vertical-align: inherit;">見る</font><font style="vertical-align: inherit;">と</font><i><font style="vertical-align: inherit;">予想し</font></i><font style="vertical-align: inherit;">、それらは圧縮の専門家にはよく知られているはずですが、実際には（少なくとも2011年は）、これが問題であると少なくとも述べた人は見つかりませんでした。だから私は一人で解決策を考え出さなければなりませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、問題の定式化は非常に簡単です。できるだけ多く適用できるフィルターを作成して、画像が最初とほぼ同じように見えるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、これはフィルタープロパティと考えることができるため、この定義を「安定したフィルタリング」と呼びます。フィルターは、フィードバックループに入らない場合、つまり、アーティファクトを作成せずに繰り返し適用できる場合、「安定」しています。繰り返し使用によって増幅され、最終的に画像を破壊するアーティファクトを作成する場合、フィルターは「不安定」です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しますが、ビデオコーデックや画像処理に関する文献でこのトピックが考慮されていない理由がわかりません。おそらく別の用語を使用していますが、私はそれを満たしていません。 「フィードバック」の概念は、サウンドを扱う分野で確立されています。しかし、画像処理では重要な問題ではありません。おそらく、通常、フィルターは一度だけ適用する必要があるためでしょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私がこの分野の専門家であれば、私はおそらくこの問題について意見を持っていました。おそらく、この問題の解決策がすでに存在する専門文献のいくつかの知識を知っているでしょう。ただし、記事の冒頭で述べたように、これまでフィルターを作成することはできなかったため、よく知られている記事だけを調べました（ただし、このようなことを聞​​いたことがない、有名な人物が少なくとも1人いることは注目に値します）。 ）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、午前中に彼らは私たちにこのフィルターが必要だと私に言った、そして私は一日中それを作成しようとした。私のアプローチはシンプルでした。フィルターを数百回実行するプログラムを作成し、最後に画像を生成して、長い実行の結果を確認できるようにしました。次に、さまざまなフィルター係数を試して、結果を観察しました。文字通り方向性のある試行錯誤のプロセスでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
約1時間後、私はこのタスクに適した最良のフィルター係数を選びました（ただし、記事の2番目の部分で説明する1つの欠陥がありました）。</font></font><br>
<br>
<pre><code class="cpp hljs">MyKernel[] = {<span class="hljs-number">1.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">-4.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">19.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">19.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">-4.0</span>/<span class="hljs-number">32.0</span>, <span class="hljs-number">1.0</span>/<span class="hljs-number">32.0</span>};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコアは、シャープ化とぼかしの危機に瀕しています。シャープネスは常に鮮明で明白なアーティファクトを作成するフィードバックにつながるため、このフィルターコアは少しぼかしを優先して、画像が少し「くすんだ」ように見えるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、60フレーム後の様子です。参考までに、元の画像（フィルタリングなし）、私のフィルター、バイリニア、ランチョス、h.264、HEVCの順にすべてのフィルターを示しました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc8/c7e/cd1/fc8c7ecd131c285b080ca8c6375c66b5.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のように、私のフィルターはシャープフィルターよりも少しぼやけた結果になりますが、60フレーム後に許容できないシャープネスアーティファクトはありません。</font><font style="vertical-align: inherit;">ただし、アーティファクトをシャープにするためにアーティファクトをぼかした方がよい場合があるため、最適なシャープフィルター（Lanczos）とマイニングのどちらかを選択できます。</font><font style="vertical-align: inherit;">ただし、数を120フレームに増やすと、フィルターが競合しなくなります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44a/a48/c5e/44aa48c5ef416f191097379547061625.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a13/3a5/f66/a133a5f66fa5ddd6d5a9073a23f02b2e.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/410/92a/849/41092a8499f2ea7beab529cdeca274bc.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
300フレーム後、私のフィルターを除くすべてのフィルターが悪い冗談のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/1ca/007/2d21ca007ccba46c3a9427dd767d6fb7.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/816/ca3/619/816ca36196d48266af8218a585744068.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de4/45d/377/de445d3777d9d35e988585af3f83581f.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c5/0e4/31f/5c50e431ff7a624e078fe95479cafbe2.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/ac8/5b7/8d9ac85b768064dfaacd5bdb8019b8c5.png" width="1000" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
600フレーム後、ジョークはさらに残酷になります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/69e/d51/f2369ed51c63439be8c3281c706e10d7.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/344/544/b61/344544b6152756bcdce564d58ee61cc0.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/536/25d/943/53625d9435b36876edf087a753a63c61.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55d/32c/66a/55d32c66a716e40c2826bd5150e3e34f.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f5/b92/c95/4f5b92c95825178ca0ce82320c37a2bc.png" width="1000" height="284"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
900フレーム後に何が起こるかを言う必要さえありません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09c/46f/617/09c46f617c7dfe04b5cb7e7c1010ba62.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1c/f58/7a4/b1cf587a4ceea34f13f97bece1f70a07.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/860/34d/27186034d68d111643b325559a3d5b13.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/ac6/d55/f9dac6d551ef448f6b8a042a43af17b6.png" width="1000" height="284"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32e/742/9dd/32e7429dd6fa7f0d704f40d28e92e0dc.png" width="1000" height="284"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どれくらい安定していますか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、自然に不思議に思います。私のフィルターは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本当に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安定し</font><font style="vertical-align: inherit;">ています</font><i><font style="vertical-align: inherit;">か</font></i><font style="vertical-align: inherit;">、それとも、非常に遅いブラーで、バイリニアフィルタリングよりもはるかに遅いのですか？おそらく数千回の繰り返しの後、私のフィルター</font><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">徐々に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像をぼかしますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
驚いたことに、答えは否定的なようです。最初のオーバーレイの約100の間に少しぼかしが追加されますが、フィルター</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像の安定した表現に</font><i><font style="vertical-align: inherit;">収束</font></i><font style="vertical-align: inherit;">し、</font><font style="vertical-align: inherit;">劣化する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことはないよう</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。セイウチの目の別の拡大画像を次に示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4a/26d/19f/e4a26d19f9ba6142ab7c45aeaea765ec.png" width="768" height="128"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左から右へ：元の画像、私のフィルターは60回、120回、300回、600、900回適用されました。ご覧のように、ブラーは安定した状態に収束し、何百ものフィルターオーバーレイの後でも劣化しなくなりました。対照的に、これを同じ数のサンプル（タップ）のウィンドウ同期と比較し、アーティファクトがフィードバックを形成し、役に立たない結果を作成する方法を確認してください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/2ff/2f2/1222ff2f2fe380cfab03df453f06ce2f.png" width="768" height="128"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のフィルターは非常に安定しているように見え、私が見たすべてのフィルターと比較して、繰り返し使用した後に最良の結果が得られます。これは、データが（制限された）平滑化された画像にすばやく収束し、この平滑化された画像が保存され、無制限の劣化を実行してガベージを完全に行わない、特定の「漸近的」プロパティを持っているようです。</font><i><font style="vertical-align: inherit;">100万を</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
フィルタリングしてみました</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間、および最初の数百のオーバーレイの後、それ以上劣化しないようです。</font><font style="vertical-align: inherit;">より優れた数学的分析がなければ（そして、それを正確に証明できる数学的解法をまだ見つけていませんが、それがどこかにあることは確かです）、何十億または1兆のオーバーレイの後のどこかに確実にあるとは言えません-壊れません。</font><font style="vertical-align: inherit;">妥当なテストでは、それ以上の劣化を検出できませんでした。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6タップに最適な安定したHalfpelフィルターですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階では、質問をするのが理にかなっています。これは本当に見つけることができる最高のものですか？</font><font style="vertical-align: inherit;">直感では、そうではないことがわかります。私はフィルターの開発についてまったく知識がなく、文献をほとんど調べなかったため、このフィルターをわずか1時間で入手しました。</font><font style="vertical-align: inherit;">少なくとも、この</font><font style="vertical-align: inherit;">ような簡単な調査の後では、私が決定的に最高のすべてを征服する優れたフィルターを見つけられなかった</font><font style="vertical-align: inherit;">と考えること</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この仮定は正しいですか？</font><font style="vertical-align: inherit;">そして、もし真実なら、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が最後の最良のフィルターでしょうか？</font><font style="vertical-align: inherit;">これについては、記事の後半で詳しく説明します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja468485/index.html">美しいGUIが必要だが、GPUが不要な場合</a></li>
<li><a href="../ja468489/index.html">HTTPリクエストの密輸-新しいアプローチ</a></li>
<li><a href="../ja468491/index.html">ハブラのカルマの呪い</a></li>
<li><a href="../ja468493/index.html">データサイエンスプロジェクトの航空写真ビューの構造</a></li>
<li><a href="../ja468497/index.html">3分の時限ブラッシングタイマー</a></li>
<li><a href="../ja468503/index.html">メールが500マイル以上進まない-FAQ</a></li>
<li><a href="../ja468509/index.html">UnixライクなOS開発-キャラクターデバイスドライバー（8）</a></li>
<li><a href="../ja468511/index.html">D-Link DFLゲートウェイを介してサーバーを公開する</a></li>
<li><a href="../ja468515/index.html">新しいプロジェクトへの統合に役立つヒント</a></li>
<li><a href="../ja468517/index.html">2.エクストリームネットワークススイッチのテクニカルサポートと保証の概要</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>