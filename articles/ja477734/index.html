<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔪 👨‍💻 👩🏼‍🤝‍👩🏻 写真アプリでUICollectionViewLayoutを理解する 🤳🏾 🥝 🧜🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！私の名前はニキータです。ABBYYでモバイルSDKを担当しています。また、スマートフォンで複数ページのドキュメントをスキャンして簡単に表示するためのUIコンポーネントにも携わっています。このコンポーネントは、ABBYY Mobile Captureテクノロジーに基づくアプリケーシ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>写真アプリでUICollectionViewLayoutを理解する</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/abbyy/blog/477734/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！私の名前はニキータです。ABBYYでモバイルSDKを担当しています。また、スマートフォンで複数ページのドキュメントをスキャンして簡単に表示するためのUIコンポーネントにも携わっています。このコンポーネントは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ABBYY Mobile Captureテクノロジーに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基づくアプリケーションの開発時間を短縮し、</font><font style="vertical-align: inherit;">いくつかの部分で構成されます。まず、ドキュメントをスキャンするためのカメラ。次に、キャプチャ結果（つまり、自動的に撮影された写真）を含むエディタ画面と、ドキュメントの境界を修正するための画面。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者がいくつかのメソッドを呼び出すだけで十分です-そして、このアプリケーションでは、ドキュメントを自動的にスキャンするカメラがすでに利用可能です。</font><font style="vertical-align: inherit;">ただし、構成済みのカメラに加えて、スキャン結果への便利なアクセスを顧客に提供する必要があります。</font><font style="vertical-align: inherit;">自動的に写真を撮った。</font><font style="vertical-align: inherit;">そして、クライアントが契約書や憲章をスキャンした場合、そのような写真がたくさんある可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、ドキュメントキャプチャの結果を使用して、エディタ画面の実装中に発生した問題について説明します。</font><font style="vertical-align: inherit;">画面自体は2つです</font></font><code>UICollectionView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はそれらを大小と呼びます。</font><font style="vertical-align: inherit;">ドキュメントの境界線を手動で調整したり、ドキュメントでの他の作業を行ったりする可能性を省略し、スクロール中のアニメーションとレイアウト機能に焦点を当てます。</font><font style="vertical-align: inherit;">下のGIFで、最後に何が起こったかを確認できます。</font><font style="vertical-align: inherit;">リポジトリへのリンクは記事の最後にあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/r2/xs/of/r2xsofivnhzdmlxt67ld_2atq-q.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
参考までに、私はよくAppleシステムのアプリケーションに注意を払います。</font><font style="vertical-align: inherit;">アニメーションやその他のアプリケーションのインターフェースソリューションを注意深く見ると、さまざまなささいなことに対する彼らの注意深い態度に感心し始めます。</font><font style="vertical-align: inherit;">ここで、参考として</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写真</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーション</font><font style="vertical-align: inherit;">（iOS 12）</font><font style="vertical-align: inherit;">を見てみましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このアプリケーションの特定の機能に注意を向け、実装を試みます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カスタマイズの可能性のほとんどをカバーし</font></font><code>UICollectionViewFlowLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、視差やカルーセルなどの一般的なトリックがどのように実装されるかを確認し、セルを挿入および削除するときのカスタムアニメーションに関連する問題についても説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能レビュー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
詳細を追加するために、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写真</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーション</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">私に喜ばれた具体的な小さなことを説明</font><font style="vertical-align: inherit;">し、適切な順序で実装します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大規模なコレクションでの視差効果</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さなコレクションの要素が中央に配置されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さなコレクション内のアイテムの動的サイズ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スモールセルの要素を配置するロジックは、contentOffsetだけでなく、ユーザーの操作にも依存します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移動と削除のカスタムアニメーション</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「アクティブ」セルのインデックスは、向きを変更しても失われません</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.視差</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
視差とは？</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">視差スクロールは、背景画像が前景画像よりもカメラを通過する速度が遅いコンピューターグラフィックスの手法であり、2Dシーンに奥行きの錯覚を作り出し、仮想体験に没入感を加えます。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> スクロールすると、セルのフレームがその中の画像よりも速く移動することがわかります。 </font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/9u/qc/7j/9uqc7jfa_e81lg-_9h6uleidmdg.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/oc/jt/nv/ocjtnvvyckaotg52-tooulyfddq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
始めましょう！</font><font style="vertical-align: inherit;">セルのサブクラスを作成し、UIImageViewをその中に配置します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PreviewCollectionViewCell</span>: <span class="hljs-title">UICollectionViewCell</span> </span>{<font></font>
    <font></font>
    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> imageView = <span class="hljs-type">UIImageView</span>()<font></font>
​<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(frame: <span class="hljs-type">CGRect</span>) {
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(frame: frame)<font></font>
        addSubview(imageView)<font></font>
        clipsToBounds = <span class="hljs-literal">true</span><font></font>
        imageView.snp.makeConstraints {<font></font>
            $<span class="hljs-number">0</span>.edges.equalToSuperview()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、シフト方法を理解</font></font><code>imageView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、視差効果を作成</font><font style="vertical-align: inherit;">する必要があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これを行うには、スクロール中のセルの動作を再定義する必要があります。</font><font style="vertical-align: inherit;">林檎：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブクラス化を避け</font></font><code>UICollectionView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">コレクションビューの外観はほとんどまたはまったくありません。</font><font style="vertical-align: inherit;">代わりに、データソースオブジェクトからすべてのビューを取得し、レイアウトオブジェクトからすべてのレイアウト関連情報を取得します。</font><font style="vertical-align: inherit;">アイテムを3次元でレイアウトする場合、適切な方法は、各セルの3D変換を設定して適切に表示するカスタムレイアウトを実装することです。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイアウトオブジェクトを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成しましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それは</font></font><code>UICollectionView </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性質がある</font></font><code>collectionViewLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それが細胞の位置に関する情報を学習しているからです。</font><font style="vertical-align: inherit;">プロパティ</font></font><code>UICollectionViewFlowLayout </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">である抽象の実装です</font><font style="vertical-align: inherit;">。</font></font><code>UICollectionViewLayout</code><font style="vertical-align: inherit;"></font><code>collectionViewLayout</code><font style="vertical-align: inherit;"></font><br>
<blockquote><code>UICollectionViewLayout </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誰かがサブクラス化して適切なコンテンツを提供するのを待っています。</font><font style="vertical-align: inherit;">セルがグリッド状に配置されるように、4つのすべてのメンバーが実装され</font></font><code>UICollectionViewFlowLayout </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た具象クラスです</font></font><code>UICollectionViewLayout </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブクラス</font></font><code>UICollectionViewFlowLayout </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成して</font><font style="vertical-align: inherit;">再定義し</font></font><code>layoutAttributesForElements(in:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。このメソッドは、</font></font><code>UICollectionViewLayoutAttributes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のセルを表示する方法に関する情報を提供</font><font style="vertical-align: inherit;">する配列</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">返します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コレクション</font></font><code>contentOffset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、レイアウトが無効であるときだけでなく、</font><font style="vertical-align: inherit;">変更されるたびに属性を要求します</font><font style="vertical-align: inherit;">。さらに</font></font><code>parallaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、セルのフレームから画像のフレームがどれだけ遅れるかを決定</font><font style="vertical-align: inherit;">するプロパティ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">追加して、カスタム属性を作成します</font><font style="vertical-align: inherit;">。サブクラスの場合、属性を再定義する必要があります</font></font><code>NSCopiyng</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。林檎：</font></font><br>
<blockquote>If you subclass and implement any custom layout attributes, you must also override the inherited isEqual: method to compare the values of your properties. In iOS 7 and later, the collection view does not apply layout attributes if those attributes have not changed. It determines whether the attributes have changed by comparing the old and new attribute objects using the isEqual: method. Because the default implementation of this method checks only the existing properties of this class, you must implement your own version of the method to compare any additional properties. If your custom properties are all equal, call <code>super </code>and return the resulting value at the end of your implementation.<br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見つける方法は</font></font><code>parallaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font><font style="vertical-align: inherit;">セルが中心に立つようにセルの中心を移動する必要がある量を計算してみましょう。</font><font style="vertical-align: inherit;">この距離がセルの幅よりも大きい場合は、ハンマーで叩きます。</font><font style="vertical-align: inherit;">それ以外の場合は、この距離を</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幅で割り</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">この距離がゼロに近いほど、視差効果は弱くなります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParallaxLayoutAttributes</span>: <span class="hljs-title">UICollectionViewLayoutAttributes</span> </span>{
    <span class="hljs-keyword">var</span> parallaxValue: <span class="hljs-type">CGFloat?</span><font></font>
}<font></font>
​<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PreviewLayout</span>: <span class="hljs-title">UICollectionViewFlowLayout</span> </span>{
    <span class="hljs-keyword">var</span> offsetBetweenCells: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">44</span><font></font>
​<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shouldInvalidateLayout</span><span class="hljs-params">(forBoundsChange newBounds: CGRect)</span></span> -&gt; <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
    }<font></font>
​<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">var</span> <span class="hljs-title">layoutAttributesClass</span>: <span class="hljs-title">AnyClass</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-type">ParallaxLayoutAttributes</span>.<span class="hljs-keyword">self</span><font></font>
    }<font></font>
​<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutAttributesForElements</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; [<span class="hljs-type">UICollectionViewLayoutAttributes</span>]? {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.layoutAttributesForElements(<span class="hljs-keyword">in</span>: rect)?<font></font>
            .<span class="hljs-built_in">compactMap</span> { $<span class="hljs-number">0</span>.copy() <span class="hljs-keyword">as</span>? <span class="hljs-type">ParallaxLayoutAttributes</span> }<font></font>
            .<span class="hljs-built_in">compactMap</span>(prepareAttributes)<font></font>
    }<font></font>
​<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prepareAttributes</span><span class="hljs-params">(attributes: ParallaxLayoutAttributes)</span></span> -&gt; <span class="hljs-type">ParallaxLayoutAttributes</span> {
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> collectionView = <span class="hljs-keyword">self</span>.collectionView <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> attributes }<font></font>
​<font></font>
        <span class="hljs-keyword">let</span> width = itemSize.width
        <span class="hljs-keyword">let</span> centerX = width / <span class="hljs-number">2</span>
        <span class="hljs-keyword">let</span> distanceToCenter = attributes.center.x - collectionView.contentOffset.x
        <span class="hljs-keyword">let</span> relativeDistanceToCenter = (distanceToCenter - centerX) / width<font></font>
​<font></font>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(relativeDistanceToCenter) &gt;= <span class="hljs-number">1</span> {<font></font>
            attributes.parallaxValue = <span class="hljs-literal">nil</span><font></font>
            attributes.transform = .identity<font></font>
        } <span class="hljs-keyword">else</span> {<font></font>
            attributes.parallaxValue = relativeDistanceToCenter<font></font>
            attributes.transform = <span class="hljs-type">CGAffineTransform</span>(translationX: relativeDistanceToCenter * offsetBetweenCells, y: <span class="hljs-number">0</span>)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> attributes<font></font>
    }<font></font>
}</code></pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/2u/pw/f3/2upwf3rrqmsjxh-btqrm3zau7tm.png"></div><br>
<br>
<img src="https://habrastorage.org/webt/bz/x_/ol/bzx_olvusogre4usqir2uvl3uxm.png" alt="画像"><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/pi/9z/fxpi9zj22hrlkywk5ptjieqq9ma.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コレクションが必要な属性を受け取ると、セル</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらを</font><b><font style="vertical-align: inherit;">適用</font></b><font style="vertical-align: inherit;">します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この動作は、セルのサブクラスでオーバーライドできます。</font><font style="vertical-align: inherit;">に</font></font><code>imageView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">応じた量だけ</font><font style="vertical-align: inherit;">シフト</font><font style="vertical-align: inherit;">し</font></font><code>parallaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ただし、これが正しく機能するためには、画像をこれからシフトする</font></font><code>contentMode == .aspectFit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だけでは不十分です。これは、画像のフレーム</font></font><code>imageView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、でコンテンツがトリミングされる</font><font style="vertical-align: inherit;">フレームと一致しないため</font></font><code>clipsToBounds == true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">画像のサイズに合ったマスクを適用し、</font></font><code>contentMode </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要に応じて更新します。</font><font style="vertical-align: inherit;">今、すべてがうまくいきます！</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">PreviewCollectionViewCell</span> </span>{<font></font>
​<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutSubviews</span><span class="hljs-params">()</span></span> {<font></font>
​<font></font>
        <span class="hljs-keyword">super</span>.layoutSubviews()
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> imageSize = imageView.image?.size <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
        <span class="hljs-keyword">let</span> imageRect = <span class="hljs-type">AVMakeRect</span>(aspectRatio: imageSize, insideRect: bounds)<font></font>
​<font></font>
        <span class="hljs-keyword">let</span> path = <span class="hljs-type">UIBezierPath</span>(rect: imageRect)
        <span class="hljs-keyword">let</span> shapeLayer = <span class="hljs-type">CAShapeLayer</span>()<font></font>
        shapeLayer.path = path.cgPath<font></font>
        layer.mask = shapeLayer<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-number">_</span> layoutAttributes: UICollectionViewLayoutAttributes)</span></span> {<font></font>
​<font></font>
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> attrs = layoutAttributes <span class="hljs-keyword">as</span>? <span class="hljs-type">ParallaxLayoutAttributes</span> <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.apply(layoutAttributes)<font></font>
        }<font></font>
        <span class="hljs-keyword">let</span> parallaxValue = attrs.parallaxValue ?? <span class="hljs-number">0</span>
        <span class="hljs-keyword">let</span> transition = -(bounds.width * <span class="hljs-number">0.3</span> * parallaxValue)<font></font>
        imageView.transform = <span class="hljs-type">CGAffineTransform</span>(translationX: transition, y: .zero)<font></font>
    }<font></font>
}</code></pre><div style="text-align:center;"><img src="https://habrastorage.org/webt/j_/9e/-h/j_9e-hdvix9nueitnhf0elsk80o.png"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.小​​さなコレクションの要素が中央に配置される</font></font></h3><br>
 <img src="https://habrastorage.org/getpro/habr/post_images/6cc/d9e/a78/6ccd9ea78faa45a085233d593c6feddb.gif"> <br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/c9/ld/ra/c9ldral4qoinyvhoacyfveqbwtm.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではすべてが非常に単純です。</font><font style="vertical-align: inherit;">この効果は</font></font><code>inset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、左右両方に</font><font style="vertical-align: inherit;">大きな</font><font style="vertical-align: inherit;">sを</font><font style="vertical-align: inherit;">設定することで実現できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">右/左にスクロールする</font></font><code>bouncing </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、最後のセルが表示されているコンテンツを離れたときにのみ開始する</font><font style="vertical-align: inherit;">必要</font><font style="vertical-align: inherit;">があります。</font><font style="vertical-align: inherit;">つまり、表示されるコンテンツはセルのサイズと等しくなければなりません。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ThumbnailFlowLayout</span> </span>{<font></font>
​<font></font>
    <span class="hljs-keyword">var</span> farInset: <span class="hljs-type">CGFloat</span> {
      <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> collection = collectionView <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> .zero }
      <span class="hljs-keyword">return</span> (collection.bounds.width - itemSize.width) / <span class="hljs-number">2</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> insets: <span class="hljs-type">UIEdgeInsets</span> {
        <span class="hljs-type">UIEdgeInsets</span>(top: .zero, <span class="hljs-keyword">left</span>: farInset, bottom: .zero, <span class="hljs-keyword">right</span>: farInset)<font></font>
    }<font></font>
​<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prepare</span><span class="hljs-params">()</span></span> {<font></font>
        collectionView?.contentInset = insets<font></font>
        <span class="hljs-keyword">super</span>.prepare()<font></font>
    }<font></font>
}</code></pre><div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/me/ty/vvmetyazz7-6mzze8-7knxoasxw.png"></div><br>
<br>
<img src="https://habrastorage.org/webt/hr/qa/k6/hrqak6wkoeqsf7nvy8bky_tauym.jpeg" alt="画像"><div style="text-align:center;"><img src="https://habrastorage.org/webt/he/pk/br/hepkbrq20vpteyatek3hv8pi8mg.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中央揃えの詳細：コレクションがスクロールを完了すると、レイアウトは</font></font><code>contentOffset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">停止</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">場所を</font><font style="vertical-align: inherit;">要求</font><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">これを行うには、をオーバーライドします</font></font><code>targetContentOffset(forProposedContentOffset:withScrollingVelocity:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">林檎：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクロール動作を特定の境界にスナップさせる場合は、このメソッドをオーバーライドして、それを使用して停止するポイントを変更できます。</font><font style="vertical-align: inherit;">たとえば、このメソッドを使用して、アイテムの途中で停止するのではなく、常にアイテム間の境界でスクロールを停止することができます。</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてを美しくするために、私たちは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も近いセルの中央に立ち止まります。</font><font style="vertical-align: inherit;">最も近いセルの中心を計算するのは簡単な作業ですが、注意して考慮する必要があります</font></font><code>contentInset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">targetContentOffset</span><span class="hljs-params">(forProposedContentOffset proposedContentOffset: CGPoint,
                                  withScrollingVelocity velocity: CGPoint)</span></span> -&gt; <span class="hljs-type">CGPoint</span> {
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> collection = collectionView <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.targetContentOffset(forProposedContentOffset: proposedContentOffset,<font></font>
                                         withScrollingVelocity: velocity)<font></font>
    }<font></font>
    <span class="hljs-keyword">let</span> cellWithSpacing = itemSize.width + config.distanceBetween
    <span class="hljs-keyword">let</span> relative = (proposedContentOffset.x + collection.contentInset.<span class="hljs-keyword">left</span>) / cellWithSpacing
    <span class="hljs-keyword">let</span> leftIndex = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, floor(relative))
    <span class="hljs-keyword">let</span> rightIndex = <span class="hljs-built_in">min</span>(ceil(relative), <span class="hljs-type">CGFloat</span>(itemsCount))
    <span class="hljs-keyword">let</span> leftCenter = leftIndex * cellWithSpacing - collection.contentInset.<span class="hljs-keyword">left</span>
    <span class="hljs-keyword">let</span> rightCenter = rightIndex * cellWithSpacing - collection.contentInset.<span class="hljs-keyword">left</span><font></font>
​<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(leftCenter - proposedContentOffset.x) &lt; <span class="hljs-built_in">abs</span>(rightCenter - proposedContentOffset.x) {
        <span class="hljs-keyword">return</span> <span class="hljs-type">CGPoint</span>(x: leftCenter, y: proposedContentOffset.y)<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-type">CGPoint</span>(x: rightCenter, y: proposedContentOffset.y)<font></font>
    }<font></font>
}</code></pre><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/n4/dj/ed/n4djedqhgual-kqq4o3vg-mjxay.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/0x/bj/xn/0xbjxn8vk5gxiuwvjvjklvhfusa.png"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.小さなコレクションの要素の動的サイズ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大きなコレクションをスクロール</font></font><code>contentOffset </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すると、小さな</font><font style="vertical-align: inherit;">コレクションに</font><font style="vertical-align: inherit;">変わります。</font><font style="vertical-align: inherit;">さらに、小さなコレクションの中央のセルは他のセルほど大きくありません。</font><font style="vertical-align: inherit;">サイドセルのサイズは固定されており、中央のセルは、含まれる画像の縦横比と同じです。</font></font><br>
<br>
 <img src="https://habrastorage.org/getpro/habr/post_images/6e3/c61/03e/6e3c6103e3602c9a3cbf0b7553a05386.gif"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hw/8q/ma/hw8qma82pik2sus_ul5rbvu8rbm.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
視差の場合と同じテクニックを使用できます。</font></font><code>UICollectionViewFlowLayout </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さなコレクション用に</font><font style="vertical-align: inherit;">カスタムのもの</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成し、</font><font style="vertical-align: inherit;">それを再定義し</font></font><code>prepareAttributes(attributes:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。さらに、小さなコレクションのレイアウトのロジックは複雑になるので、セルのジオメトリを格納および計算するための個別のエンティティを作成します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cell</span> </span>{
    <span class="hljs-keyword">let</span> indexPath: <span class="hljs-type">IndexPath</span><font></font>
​<font></font>
    <span class="hljs-keyword">let</span> dims: <span class="hljs-type">Dimensions</span>
    <span class="hljs-keyword">let</span> state: <span class="hljs-type">State</span><font></font>
​<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updated</span><span class="hljs-params">(new state: State)</span></span> -&gt; <span class="hljs-type">Cell</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-type">Cell</span>(indexPath: indexPath, dims: dims, state: state)<font></font>
    }<font></font>
}<font></font>
​<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Cell</span> </span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dimensions</span> </span>{<font></font>
​<font></font>
        <span class="hljs-keyword">let</span> defaultSize: <span class="hljs-type">CGSize</span>
        <span class="hljs-keyword">let</span> aspectRatio: <span class="hljs-type">CGFloat</span>
        <span class="hljs-keyword">let</span> inset: <span class="hljs-type">CGFloat</span>
        <span class="hljs-keyword">let</span> insetAsExpanded: <span class="hljs-type">CGFloat</span><font></font>
    }<font></font>
​<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span> </span>{<font></font>
​<font></font>
        <span class="hljs-keyword">let</span> expanding: <span class="hljs-type">CGFloat</span><font></font>
​<font></font>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> `<span class="hljs-keyword">default</span>`: <span class="hljs-type">State</span> {
            <span class="hljs-type">State</span>(expanding: .zero)<font></font>
        }<font></font>
    }<font></font>
}</code></pre><div style="text-align:center;"><img src="https://habrastorage.org/webt/0c/ma/im/0cmaim03nqx9dpkohrfumymr11a.png"></div><br>
<code>UICollectionViewFlowLayout </code><font style="vertical-align: inherit;"></font><code>collectionViewContentSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクロール可能な領域のサイズを決定</font><font style="vertical-align: inherit;">するプロパティがあります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私たちの生活を複雑にしないために、中央の細胞のサイズとは無関係に、それを一定のままにしておきましょう。</font><font style="vertical-align: inherit;">各セルの正しいジオメトリについては、</font></font><code>aspectRatio </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像とセルの中心からの距離</font><font style="vertical-align: inherit;">を知る必要があります</font></font><code>contentOffset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">近いセルは、近いそれがある</font></font><code>size.width / size.height</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font><code>aspectRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">特定のセルのサイズを変更する場合、残りのセルを（セルの左右に）移動し</font></font><code>affineTransform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">特定のセルのジオメトリを計算するには、近傍（可視）の属性を知る必要があることがわかります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Cell</span> </span>{<font></font>
​<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">attributes</span><span class="hljs-params">(from layout: ThumbnailLayout,
                    with sideCells: [Cell])</span></span> -&gt; <span class="hljs-type">UICollectionViewLayoutAttributes?</span> {<font></font>
​<font></font>
        <span class="hljs-keyword">let</span> attributes = layout.layoutAttributesForItem(at: indexPath)<font></font>
​<font></font>
        attributes?.size = size<font></font>
        attributes?.center = center<font></font>
​<font></font>
        <span class="hljs-keyword">let</span> translate = sideCells.<span class="hljs-built_in">reduce</span>(<span class="hljs-number">0</span>) { (current, cell) -&gt; <span class="hljs-type">CGFloat</span> <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> indexPath &lt; cell.indexPath {
                <span class="hljs-keyword">return</span> current - cell.additionalWidth / <span class="hljs-number">2</span><font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> indexPath &gt; cell.indexPath {
                <span class="hljs-keyword">return</span> current + cell.additionalWidth / <span class="hljs-number">2</span><font></font>
            }<font></font>
            <span class="hljs-keyword">return</span> current<font></font>
        }<font></font>
        attributes?.transform = <span class="hljs-type">CGAffineTransform</span>(translationX: translate, y: .zero)<font></font>
​<font></font>
        <span class="hljs-keyword">return</span> attributes<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> additionalWidth: <span class="hljs-type">CGFloat</span> {<font></font>
        (dims.defaultSize.height * dims.aspectRatio - dims.defaultSize.width) * state.expanding<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> size: <span class="hljs-type">CGSize</span> {
        <span class="hljs-type">CGSize</span>(width: dims.defaultSize.width + additionalWidth,<font></font>
               height: dims.defaultSize.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> center: <span class="hljs-type">CGPoint</span> {
        <span class="hljs-type">CGPoint</span>(x: <span class="hljs-type">CGFloat</span>(indexPath.row) * (dims.defaultSize.width + dims.inset) + dims.defaultSize.width / <span class="hljs-number">2</span>,<font></font>
                y: dims.defaultSize.height / <span class="hljs-number">2</span>)<font></font>
    }<font></font>
}</code></pre><br>
<code>state.expanding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とほぼ同じと見なされ</font></font><code>parallaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cell</span><span class="hljs-params">(<span class="hljs-keyword">for</span> index: IndexPath, offsetX: CGFloat)</span></span> -&gt; <span class="hljs-type">Cell</span> {<font></font>
​<font></font>
    <span class="hljs-keyword">let</span> cell = <span class="hljs-type">Cell</span>(<font></font>
        indexPath: index,<font></font>
        dims: <span class="hljs-type">Cell</span>.<span class="hljs-type">Dimensions</span>(<font></font>
            defaultSize: itemSize,<font></font>
            aspectRatio: dataSource(index.row),<font></font>
            inset: config.distanceBetween,<font></font>
            insetAsExpanded: config.distanceBetweenFocused),<font></font>
        state: .<span class="hljs-keyword">default</span>)<font></font>
​<font></font>
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> attribute = cell.attributes(from: <span class="hljs-keyword">self</span>, with: []) <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> cell }<font></font>
​<font></font>
    <span class="hljs-keyword">let</span> cellOffset = attribute.center.x - itemSize.width / <span class="hljs-number">2</span>
    <span class="hljs-keyword">let</span> widthWithOffset = itemSize.width + config.distanceBetween
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(cellOffset - offsetX) &lt; widthWithOffset {
        <span class="hljs-keyword">let</span> expanding = <span class="hljs-number">1</span> - <span class="hljs-built_in">abs</span>(cellOffset - offsetX) / widthWithOffset
        <span class="hljs-keyword">return</span> cell.updated(by: .expand(expanding))<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> cell<font></font>
}<font></font>
​<font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutAttributesForElements</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; [<span class="hljs-type">UICollectionViewLayoutAttributes</span>]? {
    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span> ..&lt; itemsCount)<font></font>
        .<span class="hljs-built_in">map</span> { <span class="hljs-type">IndexPath</span>(row: $<span class="hljs-number">0</span>, section: <span class="hljs-number">0</span>) }<font></font>
        .<span class="hljs-built_in">map</span> { cell(<span class="hljs-keyword">for</span>: $<span class="hljs-number">0</span>, offsetX: offsetWithoutInsets.x) }<font></font>
        .<span class="hljs-built_in">compactMap</span> { $<span class="hljs-number">0</span>.attributes(from: <span class="hljs-keyword">self</span>, with: cells) }<font></font>
}</code></pre><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.スモールセルの要素を配置するロジックは、contentOffsetだけでなく、ユーザーの操作にも依存します。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーが小さなコレクションをスクロールすると、すべてのセルが同じサイズになります。大きなコレクションをスクロールする場合、これはそうではありません。 （</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gif 3および5を参照</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。レイアウトプロパティを更新するアニメーターを作成してみましょう</font></font><code>ThumbnailLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。アニメータは自分自身に保存し、</font></font><code>DisplayLink </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1秒あたり60回ブロックを呼び出し、現在の進行状況へのアクセスを提供します。アニメーターに様々な締め付けが簡単</font></font><code>easing functions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。実装は、投稿の最後のリンクにあるgithubで確認できます。</font><font style="vertical-align: inherit;">誰も</font><font style="vertical-align: inherit;">が掛け算</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
する</font></font><code>ThumbnailLayout </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティ</font><font style="vertical-align: inherit;">に入りましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">特定の画像が中央に配置されると、そのサイズに</font><font style="vertical-align: inherit;">どの程度</font><font style="vertical-align: inherit;">影響</font><font style="vertical-align: inherit;">するかを示し</font><font style="vertical-align: inherit;">ていること</font><font style="vertical-align: inherit;">がわかり</font><font style="vertical-align: inherit;">ます。で</font></font><code>expandingRate</code><font style="vertical-align: inherit;"></font><code>expanding </code><font style="vertical-align: inherit;"></font><code>Cell</code><font style="vertical-align: inherit;"></font><code>expandingRate </code><font style="vertical-align: inherit;"></font><code>aspectRatio </code><font style="vertical-align: inherit;"></font><code>expandingRate == 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのセルは同じサイズになります。</font><font style="vertical-align: inherit;">小さなコレクションのスクロールの開始時に、</font></font><code>expandingRate </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0に</font><font style="vertical-align: inherit;">変換するアニメーターを実行</font><font style="vertical-align: inherit;">し、逆にスクロールの最後に1に実行します。実際、レイアウトを更新すると、中央のセルと</font></font><code>transform </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイドの</font><font style="vertical-align: inherit;">セルのサイズが変わり</font><font style="vertical-align: inherit;">ます。</font></font><code>contentOffset </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">けいれんで</font><font style="vertical-align: inherit;">混乱しないで</font><font style="vertical-align: inherit;">ください！</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollAnimation</span>: <span class="hljs-title">NSObject</span> </span>{<font></font>
​<font></font>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> `<span class="hljs-title">Type</span>` </span>{
        <span class="hljs-keyword">case</span> begin
        <span class="hljs-keyword">case</span> end<font></font>
    }<font></font>
​<font></font>
    <span class="hljs-keyword">let</span> type: <span class="hljs-type">Type</span><font></font>
​<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">(completion: @escaping <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span>) {
        <span class="hljs-keyword">let</span> toValue: <span class="hljs-type">CGFloat</span> = <span class="hljs-keyword">self</span>.type == .begin ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>
        <span class="hljs-keyword">let</span> currentExpanding = thumbnails.config.expandingRate
        <span class="hljs-keyword">let</span> duration = <span class="hljs-type">TimeInterval</span>(<span class="hljs-number">0.15</span> * <span class="hljs-built_in">abs</span>(currentExpanding - toValue))<font></font>
​<font></font>
        <span class="hljs-keyword">let</span> animator = <span class="hljs-type">Animator</span>(onProgress: { current, <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">let</span> rate = currentExpanding + (toValue - currentExpanding) * current
            <span class="hljs-keyword">self</span>.thumbnails.config.expandingRate = rate
            <span class="hljs-keyword">self</span>.thumbnails.invalidateLayout()<font></font>
        }, easing: .easeInOut)<font></font>
​<font></font>
        animator.animate(duration: duration) { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span><font></font>
            completion()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><div style="text-align:center;"><img src="https://habrastorage.org/webt/sy/sz/ff/syszffr_19xmccnvyw-do9lcqhy.png"></div><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scrollViewWillBeginDragging</span><span class="hljs-params">(<span class="hljs-number">_</span> scrollView: UIScrollView)</span></span> {
    <span class="hljs-keyword">if</span> scrollView == thumbnails.collectionView {<font></font>
        handle(event: .beginScrolling) <span class="hljs-comment">// call ScrollAnimation.run(type: .begin)</span><font></font>
    }<font></font>
}<font></font>
​<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scrollViewDidEndDragging</span><span class="hljs-params">(<span class="hljs-number">_</span> scrollView: UIScrollView, willDecelerate decelerate: Bool)</span></span> {
    <span class="hljs-keyword">if</span> scrollView == thumbnails.collectionView &amp;&amp; !decelerate {<font></font>
        thumbnailEndScrolling()<font></font>
    }<font></font>
}<font></font>
​<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scrollViewDidEndDecelerating</span><span class="hljs-params">(<span class="hljs-number">_</span> scrollView: UIScrollView)</span></span> {
    <span class="hljs-keyword">if</span> scrollView == thumbnails.collectionView {<font></font>
        thumbnailEndScrolling()<font></font>
    }<font></font>
}<font></font>
​<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">thumbnailEndScrolling</span><span class="hljs-params">()</span></span> {<font></font>
    handle(event: .endScrolling) <span class="hljs-comment">// call ScrollAnimation.run(type: .end)</span>
}</code></pre><div style="text-align:center;"><img src="https://habrastorage.org/webt/nu/v0/x7/nuv0x7phez1lg2osumphtri1wao.png"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.移動と削除のカスタムアニメーション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カスタムアニメーションを作成してセルを更新する方法を説明する記事はたくさんありますが、私たちの場合は役に立ちません。</font><font style="vertical-align: inherit;">記事とチュートリアルでは、更新されたセルの属性をオーバーライドする方法について説明しています。</font><font style="vertical-align: inherit;">私たちのケースでは、削除されたセルのレイアウトを変更すると副作用が発生します- </font></font><code>expanding </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隣接するセル</font><font style="vertical-align: inherit;">が変更</font><font style="vertical-align: inherit;">され、アニメーション中に削除されたセルの代わりになる傾向があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
のコンテンツの更新</font></font><code>UICollectionViewFlowLayout </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は次のよう</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">機能します。</font><font style="vertical-align: inherit;">セルを削除/追加した後、</font><font style="vertical-align: inherit;">インデックスがどのセルで更新/削除/追加されたかを知らせる</font></font><code>prepare(forCollectionViewUpdates:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列</font></font><code>UICollectionViewUpdateItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">提供する</font><font style="vertical-align: inherit;">メソッドが起動</font><font style="vertical-align: inherit;">されます。</font><font style="vertical-align: inherit;">次に、レイアウトはメソッドのグループを呼び出します</font></font><br>
<br>
<pre><code class="swift hljs">finalLayoutAttributesForDisappearingItem(at:)<font></font>
initialLayoutAttributesForAppearingDecorationElement(ofKind:at:)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
と装飾/補足ビューのための彼らの友人。</font><font style="vertical-align: inherit;">更新されたデータの属性を受け取ると、と呼ばれ</font></font><code>finalizeCollectionViewUpdates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">林檎：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コレクションビューは、変更をアニメーション化する前の最後のステップとして、このメソッドを呼び出します。</font><font style="vertical-align: inherit;">このメソッドは、挿入、削除、移動のすべてのアニメーションを実行するために使用されるアニメーションブロック内で呼び出されるため、必要に応じてこのメソッドを使用して追加のアニメーションを作成できます。</font><font style="vertical-align: inherit;">それ以外の場合は、それを使用して、レイアウトオブジェクトの状態情報の管理に関連する直前のタスクを実行できます。</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新された</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セル</font><font style="vertical-align: inherit;">に対してのみ属性を特化でき</font><font style="vertical-align: inherit;">、すべてのセルに対して、さまざまな方法で</font><font style="vertical-align: inherit;">属性</font><font style="vertical-align: inherit;">を変更する必要があることです。</font><font style="vertical-align: inherit;">新しい中央セルが変更され</font></font><code>aspectRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、セカンダリ</font><font style="vertical-align: inherit;">セルが変更され</font></font><code>transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
 <img src="https://habrastorage.org/getpro/habr/post_images/223/6ad/9e0/2236ad9e0cff5fac58a4b490570340c4.gif"> <div style="text-align:center;"><img src="https://habrastorage.org/webt/1b/wa/pf/1bwapfugwecsrwjnnw3imlnviyk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
削除/挿入時のコレクションセルのデフォルトアニメーションがどのように機能するかを調べたところ、セル内のレイヤーセルには</font><font style="vertical-align: inherit;">、残りのセルのアニメーションをカスタマイズする場合に変更できる</font><font style="vertical-align: inherit;">セル</font></font><code>finalizeCollectionViewUpdates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が含まれ</font></font><code>CABasicAnimation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ていることが</font><font style="vertical-align: inherit;">わかりました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ログが間ことが示されたとき、すべてが悪化した</font></font><code>performBatchUpdates </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とは</font></font><code>prepare(forCollectionViewUpdates:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼ばれ</font></font><code>prepareAttributes(attributes:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すでに彼らはものの、細胞の数が間違っがあるかもしれない</font></font><code>collectionViewUpdates </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まだ始まっていない、これを維持し、理解することは非常に困難です。</font><font style="vertical-align: inherit;">これについて何ができますか？</font><font style="vertical-align: inherit;">これらの組み込みアニメーションを無効にできます！</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prepare</span><span class="hljs-params">(forCollectionViewUpdates updateItems: [UICollectionViewUpdateItem])</span></span> {
    <span class="hljs-keyword">super</span>.prepare(forCollectionViewUpdates: updateItems)
    <span class="hljs-type">CATransaction</span>.begin()
    <span class="hljs-type">CATransaction</span>.setDisableActions(<span class="hljs-literal">true</span>)<font></font>
}<font></font>
​<font></font>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">finalizeCollectionViewUpdates</span><span class="hljs-params">()</span></span> {
    <span class="hljs-type">CATransaction</span>.commit()<font></font>
}<font></font>
</code></pre><div style="text-align:center;"><img src="https://habrastorage.org/webt/69/ja/x4/69jax4yhfpsjyr5jej-xxpb6pkc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに記述されたアニメーターを準備して、削除のリクエストに応じて必要なすべてのアニメーションを実行し、アニメーション</font></font><code>dataSource </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の最後に</font><font style="vertical-align: inherit;">更新</font><font style="vertical-align: inherit;">を開始します。</font><font style="vertical-align: inherit;">したがって、セルの数がいつ変化するかは自分で制御するため、更新時にコレクションのアニメーションを単純化します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">delete</span><span class="hljs-params">(
    at indexPath: IndexPath,
    dataSourceUpdate: @escaping <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span>,<font></font>
    completion: (() -&gt; <span class="hljs-type">Void</span>)?) {<font></font>
​<font></font>
    <span class="hljs-type">DeleteAnimation</span>(thumbnails: thumbnails, preview: preview, index: indexPath).run {
        <span class="hljs-keyword">let</span> previousCount = <span class="hljs-keyword">self</span>.thumbnails.itemsCount
        <span class="hljs-keyword">if</span> previousCount == indexPath.row + <span class="hljs-number">1</span> {
            <span class="hljs-keyword">self</span>.activeIndex = previousCount - <span class="hljs-number">1</span><font></font>
        }<font></font>
        dataSourceUpdate()<font></font>
        <span class="hljs-keyword">self</span>.thumbnails.collectionView?.deleteItems(at: [indexPath])
        <span class="hljs-keyword">self</span>.preview.collectionView?.deleteItems(at: [indexPath])<font></font>
        completion?()<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなアニメーションはどのように機能しますか？</font></font><code>ThumbnailLayout </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のセルの形状を更新するオプションのパンフレットを保存して</font><font style="vertical-align: inherit;">みましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThumbnailLayout</span> </span>{<font></font>
​<font></font>
    <span class="hljs-keyword">typealias</span> <span class="hljs-type">CellUpdate</span> = (<span class="hljs-type">Cell</span>) -&gt; <span class="hljs-type">Cell</span>
    <span class="hljs-keyword">var</span> updates: [<span class="hljs-type">IndexPath</span>: <span class="hljs-type">CellUpdate</span>] = [:]<font></font>
    <font></font>
    <span class="hljs-comment">// ...</span><font></font>
    <font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutAttributesForElements</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; [<span class="hljs-type">UICollectionViewLayoutAttributes</span>]? {<font></font>
​<font></font>
        <span class="hljs-keyword">let</span> cells = (<span class="hljs-number">0</span> ..&lt; itemsCount)<font></font>
            .<span class="hljs-built_in">map</span> { <span class="hljs-type">IndexPath</span>(row: $<span class="hljs-number">0</span>, section: <span class="hljs-number">0</span>) }<font></font>
            .<span class="hljs-built_in">map</span> { cell(<span class="hljs-keyword">for</span>: $<span class="hljs-number">0</span>, offsetX: offsetWithoutInsets.x) }<font></font>
            .<span class="hljs-built_in">map</span> { cell -&gt; <span class="hljs-type">Cell</span> <span class="hljs-keyword">in</span>
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> update = <span class="hljs-keyword">self</span>.config.updates[cell.indexPath] {
                    <span class="hljs-keyword">return</span> update(cell)<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span> cell<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> cells.<span class="hljs-built_in">compactMap</span> { $<span class="hljs-number">0</span>.attributes(from: <span class="hljs-keyword">self</span>, with: cells) <font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなツールがあれば、セルのジオメトリを使って何でもでき、アニメーターの作業中に更新をスローし、お世辞にそれらを削除できます。</font><font style="vertical-align: inherit;">また、アップデートを組み合わせる可能性もあります。</font></font><br>
<br>
<pre><code class="swift hljs">updates[index] = newUpdate(updates[index])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アニメーションの削除コードはかなり扱いにくく</font><font style="vertical-align: inherit;">、リポジトリの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DeleteAnimation.swift</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル</font><font style="vertical-align: inherit;">にあります。</font><font style="vertical-align: inherit;">セル間のフォーカス切り替えのアニメーションも同様に実装されています。</font></font><br>
<br>
 <img src="https://habrastorage.org/getpro/habr/post_images/001/d8d/ca0/001d8dca06df6b68773652760a019bf3.gif"> <div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/6q/bs/mi6qbskcng_u5ehyixy1q0xp_ce.png"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.向きを変えても「アクティブ」セルのインデックスは失われません</font></font></h3><br>
<code>scrollViewDidScroll(_ scrollView:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは</font></font><code>contentOffset </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、向きを変えたときだけでなく、何らかの値を取得</font><font style="vertical-align: inherit;">した場合でも呼び出さ</font><font style="vertical-align: inherit;">れます。</font><font style="vertical-align: inherit;">2つのコレクションのスクロールを同期すると、レイアウトの更新中に問題が発生する場合があります。</font><font style="vertical-align: inherit;">以下のトリックができます：更新にレイアウトを設定することが可能</font></font><code>scrollView.delegate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ScrollSynchronizer</span> </span>{<font></font>
​<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bind</span><span class="hljs-params">()</span></span> {<font></font>
        preview.collectionView?.delegate = <span class="hljs-keyword">self</span>
        thumbnails.collectionView?.delegate = <span class="hljs-keyword">self</span><font></font>
    }<font></font>
​<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unbind</span><span class="hljs-params">()</span></span> {<font></font>
        preview.collectionView?.delegate = <span class="hljs-literal">nil</span>
        thumbnails.collectionView?.delegate = <span class="hljs-literal">nil</span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方向変更時にセルサイズを更新すると、次のようになります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">PhotosViewController</span> </span>{<font></font>
​<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewWillTransition</span><span class="hljs-params">(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator)</span></span> {
        <span class="hljs-keyword">super</span>.viewWillTransition(to: size, with: coordinator)<font></font>
​<font></font>
        contentView.synchronizer.unbind()<font></font>
        coordinator.animate(alongsideTransition: <span class="hljs-literal">nil</span>) { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">self</span>?.contentView.synchronizer.bind()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
向きを変更する際に必要なを失わないためには</font></font><code>contentOffset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、あなたが更新することができます</font></font><code>targetIndexPath </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font><code>scrollView.delegate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">向きを変更すると、レイアウトが再定義されると無効になります</font></font><code>shouldInvalidateLayout(forBoundsChange:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">変更すると、</font></font><code>bounds </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイアウトは明確にするように求めます。明確</font></font><code>contentOffset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にするために、再定義する必要があります</font></font><code>targetContentOffset(forProposedContentOffset:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">林檎：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイアウトの更新中、またはレイアウト間での移行時に、コレクションビューはこのメソッドを呼び出して、アニメーションの最後に使用する提案されたコンテンツオフセットを変更する機会を提供します。</font><font style="vertical-align: inherit;">アニメーションまたはトランジションによってアイテムがデザインに最適でない方法で配置される可能性がある場合は、このメソッドをオーバーライドできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コレクションビューは、</font></font><code>prepare()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>collectionViewContentSize </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを</font><font style="vertical-align: inherit;">呼び出した後にこのメソッドを呼び出し</font><font style="vertical-align: inherit;">ます。</font></font></blockquote><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">targetContentOffset</span><span class="hljs-params">(forProposedContentOffset proposedContentOffset: CGPoint)</span></span> -&gt; <span class="hljs-type">CGPoint</span> {
    <span class="hljs-keyword">let</span> targetOffset = <span class="hljs-keyword">super</span>.targetContentOffset(forProposedContentOffset: proposedContentOffset)
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> layoutHandler = layoutHandler <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> targetOffset<font></font>
    }<font></font>
    <span class="hljs-keyword">let</span> offset = <span class="hljs-type">CGFloat</span>(layoutHandler.targetIndex) / <span class="hljs-type">CGFloat</span>(itemsCount)
    <span class="hljs-keyword">return</span> <span class="hljs-type">CGPoint</span>(<font></font>
        x: collectionViewContentSize.width * offset - farInset,<font></font>
        y: targetOffset.y)<font></font>
}</code></pre><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/i5/5r/sf/i55rsfdujvblk7om3yq2yerabhu.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/ls/6w/ngls6wjfkhkajrg3706i_g11lyo.png"></div><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読んでくれてありがとう！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/YetAnotherRzmn/PhotosAppにあります</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja477722/index.html">C ++のGoogleスタイルガイド。パート8</a></li>
<li><a href="../ja477724/index.html">HRブランドhabraseminar：才能、狩猟、コンテンツについて</a></li>
<li><a href="../ja477728/index.html">チームが燃え尽きないようにティムリダをどうするか</a></li>
<li><a href="../ja477730/index.html">ChipWhisperer：マグマへのエネルギー攻撃</a></li>
<li><a href="../ja477732/index.html">水中ナビゲーションシステムの誤った指分類</a></li>
<li><a href="../ja477736/index.html">テスターの道：「ハンドブレーキ」から自動化まで</a></li>
<li><a href="../ja477738/index.html">iKassa、または「デジタルキャッシャー」の手入れ方法</a></li>
<li><a href="../ja477740/index.html">そして、あなたの目でこの望遠鏡をどこに見るのですか？</a></li>
<li><a href="../ja477742/index.html">「こんにちは、Checkmarx！」Checkmarx SASTのリクエストを作成し、クールな脆弱性を見つける方法</a></li>
<li><a href="../ja477744/index.html">なぜ専門家は時々悪いアプリケーションを作成するのですか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>