<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôãÔ∏è üñêüèæ üéôÔ∏è Ir: deserializaci√≥n JSON con tipeo incorrecto, o c√≥mo evitar errores de desarrollador de API üë®üèæ‚Äçüé§ üéÉ üèÇüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, desarroll√© un cliente http en Go para un servicio que proporciona una API REST con json como formato de codificaci√≥n. Una tarea est√°nda...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Ir: deserializaci√≥n JSON con tipeo incorrecto, o c√≥mo evitar errores de desarrollador de API</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502176/"><img src="https://habrastorage.org/webt/pf/hz/xm/pfhzxmp9antvvecnexqujg6pkzk.jpeg" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recientemente, desarroll√© un cliente http en Go para un servicio que proporciona una API REST con json como formato de codificaci√≥n. </font><font style="vertical-align: inherit;">Una tarea est√°ndar, pero en el curso del trabajo tuve que enfrentar un problema no est√°ndar. </font><font style="vertical-align: inherit;">Te digo cu√°l es el punto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como sabes, el formato json tiene tipos de datos. </font><font style="vertical-align: inherit;">Cuatro primitivas: cadena, n√∫mero, booleano, nulo; </font><font style="vertical-align: inherit;">y dos tipos estructurales: un objeto y una matriz. </font><font style="vertical-align: inherit;">En este caso, estamos interesados ‚Äã‚Äãen los tipos primitivos. </font><font style="vertical-align: inherit;">Aqu√≠ hay un ejemplo de c√≥digo json con cuatro campos de diferentes tipos:</font></font><br>
<br>
<pre><code class="json hljs">{
	<span class="hljs-attr">"name"</span>:<span class="hljs-string">"qwerty"</span>,
	<span class="hljs-attr">"price"</span>:<span class="hljs-number">258.25</span>,
	<span class="hljs-attr">"active"</span>:<span class="hljs-literal">true</span>,
	<span class="hljs-attr">"description"</span>:<span class="hljs-literal">null</span>,<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como muestra el ejemplo, el valor de la cadena est√° entre comillas. Num√©rico: no tiene comillas. Un tipo booleano solo puede tener uno de dos valores: verdadero o falso (sin comillas). Y el tipo nulo es en consecuencia nulo (tambi√©n sin comillas).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y ahora el problema en s√≠. En alg√∫n momento, en un examen detallado del c√≥digo json recibido de un servicio de terceros, descubr√≠ que uno de los campos (llam√©moslo precio) peri√≥dicamente tiene un valor de cadena (el n√∫mero entre comillas) adem√°s del valor num√©rico. Es decir, la misma consulta con diferentes par√°metros puede devolver un n√∫mero como n√∫mero, o puede devolver el mismo n√∫mero como una cadena. No puedo imaginar c√≥mo el c√≥digo que devuelve dichos resultados est√° organizado en el otro extremo, pero aparentemente esto se debe al hecho de que el servicio en s√≠ es un agregador y extrae datos de diferentes fuentes, y los desarrolladores no llevaron la respuesta del servidor json a un solo formato. Sin embargo, es necesario trabajar con lo que es.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero luego estaba a√∫n m√°s sorprendido. </font><font style="vertical-align: inherit;">El campo l√≥gico (llam√©moslo activo), adem√°s de verdadero y falso, devolvi√≥ los valores de cadena "verdadero", "falso" e incluso los n√∫meros 1 y 0 (verdadero y falso, respectivamente).</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toda esta confusi√≥n sobre los tipos de datos no ser√≠a cr√≠tica si procesara json say en PHP con un tipo d√©bil, pero Go tiene un tipo fuerte y requiere una indicaci√≥n clara del tipo de campo deserializado. </font><font style="vertical-align: inherit;">Como resultado, era necesario implementar un mecanismo que permitiera convertir todos los valores del campo activo a un tipo l√≥gico durante el proceso de deserializaci√≥n, y cualquier valor del campo de precio a uno num√©rico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos con el campo de precios. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que tenemos un c√≥digo json como este:</font></font><br>
<br>
<pre><code class="json hljs">[<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">2.58</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">7.15</span>}<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, json contiene una matriz de objetos con dos campos de tipo num√©rico. </font><font style="vertical-align: inherit;">El c√≥digo de deserializaci√≥n est√°ndar para este json en Go se ve as√≠:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id    <span class="hljs-keyword">int</span>     <span class="hljs-string">`json:"id"`</span>
	Price <span class="hljs-keyword">float64</span> <span class="hljs-string">`json:"price"`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	jsonString := <span class="hljs-string">`[{"id":1,"price":2.58},
					{"id":4,"price":7.15}]`</span><font></font>
<font></font>
	targets := []Target{}<font></font>
<font></font>
	err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(jsonString), &amp;targets)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
		fmt.Println(err)<font></font>
		<span class="hljs-keyword">return</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> targets {<font></font>
		fmt.Println(t.Id, <span class="hljs-string">"-"</span>, t.Price)<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este c√≥digo, deserializaremos el campo id a int y el campo price a float64. </font><font style="vertical-align: inherit;">Ahora supongamos que nuestro c√≥digo json se ve as√≠:</font></font><br>
<br>
<pre><code class="json hljs">[<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">2.58</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-string">"2.58"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">7.15</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">4</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-string">"7.15"</span>}<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, el campo de precio contiene valores de un tipo num√©rico y una cadena. </font><font style="vertical-align: inherit;">En este caso, solo los valores num√©ricos del campo de precio se pueden decodificar en tipo float64, mientras que los valores de cadena causar√°n un error sobre la incompatibilidad de los tipos. </font><font style="vertical-align: inherit;">Esto significa que ni float64 ni ning√∫n otro tipo primitivo son adecuados para deserializar este campo, y necesitamos nuestro propio tipo personalizado con su propia l√≥gica de deserializaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como tal tipo, declare una estructura CustomFloat64 con un solo campo Float64 de tipo float64.</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> CustomFloat64 <span class="hljs-keyword">struct</span>{<font></font>
	Float64 <span class="hljs-keyword">float64</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E inmediatamente indique este tipo para el campo Precio en la estructura Objetivo:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id    <span class="hljs-keyword">int</span>           <span class="hljs-string">`json:"id"`</span>
	Price CustomFloat64 <span class="hljs-string">`json:"price"`</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora necesita describir su propia l√≥gica para decodificar un campo de tipo CustomFloat64. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El paquete encoding / json proporciona dos m√©todos especiales: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MarshalJSON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnmarshalJSON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que est√°n dise√±ados para personalizar la l√≥gica de codificaci√≥n y decodificaci√≥n de un tipo de datos de usuario espec√≠fico. Es suficiente anular estos m√©todos y describir su propia implementaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anule el m√©todo UnmarshalJSON para un tipo arbitrario CustomFloat64. En este caso, es necesario seguir estrictamente la firma del m√©todo; de lo contrario, simplemente no funcionar√° y, lo m√°s importante, no producir√° un error.</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf *CustomFloat64)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la entrada, este m√©todo toma una porci√≥n de bytes (datos), que contiene el valor de un campo particular del json decodificado. Si convertimos esta secuencia de bytes en una cadena, veremos el valor del campo exactamente en la forma en que est√° escrito en json. Es decir, si es un tipo de cadena, veremos exactamente una cadena con comillas dobles ("258"), si es un tipo num√©rico, veremos una cadena sin comillas (258).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para distinguir un valor num√©rico de un valor de cadena, debe verificar si el primer car√°cter es una comilla. Dado que el car√°cter de comillas dobles en la tabla UNICODE ocupa un byte, solo necesitamos verificar el primer byte del segmento de datos compar√°ndolo con el n√∫mero de caracteres en UNICODE. Este es el n√∫mero 34. Tenga en cuenta que, en general, un car√°cter no es equivalente a un byte, ya que puede tomar m√°s de un byte. Un s√≠mbolo en Go es equivalente a rune (rune). En nuestro caso, esta condici√≥n es suficiente:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == <span class="hljs-number">34</span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si se cumple la condici√≥n, el valor tiene un tipo de cadena, y necesitamos obtener la cadena entre comillas, es decir, el byte de corte entre el primer y el √∫ltimo byte. </font><font style="vertical-align: inherit;">Este segmento contiene un valor num√©rico que puede decodificarse en el tipo primitivo float64. </font><font style="vertical-align: inherit;">Esto significa que podemos aplicarle el m√©todo json.Unmarshal, mientras guardamos el resultado en el campo Float64 de la estructura CustomFloat64.</font></font><br>
<br>
<pre><code class="go hljs">err := json.Unmarshal(data[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(data)<span class="hljs-number">-1</span>], &amp;cf.Float64)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el segmento de datos no comienza con una comilla, entonces ya contiene un tipo de datos num√©ricos y podemos aplicar el m√©todo json.Unmarshal directamente a todo el segmento de datos.</font></font><br>
<br>
<pre><code class="go hljs">err := json.Unmarshal(data, &amp;cf.Float64)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ est√° el c√≥digo completo para el m√©todo UnmarshalJSON:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf *CustomFloat64)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == <span class="hljs-number">34</span> {<font></font>
		err := json.Unmarshal(data[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(data)<span class="hljs-number">-1</span>], &amp;cf.Float64)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		err := json.Unmarshal(data, &amp;cf.Float64)<font></font>
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, utilizando el m√©todo json.Unmarshal para nuestro c√≥digo json, todos los valores del campo de precio se convertir√°n de manera transparente a un tipo primitivo float64 para nosotros, y el resultado se escribir√° en el campo Float64 de la estructura CustomFloat64. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora es posible que necesitemos convertir la estructura de destino nuevamente a json. Pero, si aplicamos el m√©todo json.Marshal directamente al tipo CustomFloat64, serializamos esta estructura como un objeto. Necesitamos codificar el campo de precio en un valor num√©rico. Para personalizar la l√≥gica de codificaci√≥n del tipo personalizado CustomFloat64, implementamos el m√©todo MarshalJSON, mientras observamos estrictamente la firma del m√©todo:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf CustomFloat64)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cf.Float64)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo lo que necesita hacer en este m√©todo es usar nuevamente el m√©todo json.Marshal, pero ya no lo aplica a la estructura CustomFloat64, sino a su campo Float64. </font><font style="vertical-align: inherit;">Del m√©todo devolvemos el segmento de bytes recibido y el error. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ est√° el c√≥digo completo que muestra los resultados de la serializaci√≥n y deserializaci√≥n (la comprobaci√≥n de errores se omite por brevedad, el n√∫mero del byte con el s√≠mbolo de comillas dobles est√° en constante):</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"encoding/json"</span>
	<span class="hljs-string">"errors"</span>
	<span class="hljs-string">"fmt"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">type</span> CustomFloat64 <span class="hljs-keyword">struct</span> {<font></font>
	Float64 <span class="hljs-keyword">float64</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> QUOTES_BYTE = <span class="hljs-number">34</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf *CustomFloat64)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == QUOTES_BYTE {<font></font>
		err := json.Unmarshal(data[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(data)<span class="hljs-number">-1</span>], &amp;cf.Float64)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		err := json.Unmarshal(data, &amp;cf.Float64)<font></font>
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf CustomFloat64)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cf.Float64)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id    <span class="hljs-keyword">int</span>           <span class="hljs-string">`json:"id"`</span>
	Price CustomFloat64 <span class="hljs-string">`json:"price"`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	jsonString := <span class="hljs-string">`[{"id":1,"price":2.58},
					{"id":2,"price":"2.58"},
					{"id":3,"price":7.15},
					{"id":4,"price":"7.15"}]`</span><font></font>
<font></font>
	targets := []Target{}<font></font>
<font></font>
	_ := json.Unmarshal([]<span class="hljs-keyword">byte</span>(jsonString), &amp;targets)<font></font>
<font></font>
	<span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> targets {<font></font>
		fmt.Println(t.Id, <span class="hljs-string">"-"</span>, t.Price.Float64)<font></font>
	}<font></font>
<font></font>
	jsonStringNew, _ := json.Marshal(targets)<font></font>
	fmt.Println(<span class="hljs-keyword">string</span>(jsonStringNew))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resultado de ejecuci√≥n del c√≥digo:</font></font><br>
<br>
<pre><code class="bash hljs">1 - 2.58<font></font>
2 - 2.58<font></font>
3 - 7.15<font></font>
4 - 7.15<font></font>
[{<span class="hljs-string">"id"</span>:1,<span class="hljs-string">"price"</span>:2.58},{<span class="hljs-string">"id"</span>:2,<span class="hljs-string">"price"</span>:2.58},{<span class="hljs-string">"id"</span>:3,<span class="hljs-string">"price"</span>:7.15},{<span class="hljs-string">"id"</span>:4,<span class="hljs-string">"price"</span>:7.15}]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pasemos a la segunda parte e implementemos el mismo c√≥digo para la deserializaci√≥n de json con valores inconsistentes del campo l√≥gico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que tenemos un c√≥digo json como este:</font></font><br>
<br>
<pre><code class="json hljs">[<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-literal">true</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"true"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"1"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">4</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-number">1</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">5</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-literal">false</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">6</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"false"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">7</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"0"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">8</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-number">0</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">9</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">""</span>}<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, el campo activo implica un tipo l√≥gico y la presencia de solo uno de dos valores: verdadero y falso. </font><font style="vertical-align: inherit;">Los valores no booleanos deber√°n convertirse a booleanos durante la deserializaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el ejemplo actual, admitimos las siguientes coincidencias. </font><font style="vertical-align: inherit;">Los valores verdaderos corresponden a: verdadero (l√≥gico), verdadero (cadena), 1 (cadena), 1 (num√©rico). </font><font style="vertical-align: inherit;">El valor falso corresponde a: falso (l√≥gico), falso (cadena), 0 (cadena), 0 (num√©rico), "" (cadena vac√≠a). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, declararemos la estructura objetivo para la deserializaci√≥n. </font><font style="vertical-align: inherit;">Como el tipo del campo Activo, especificamos inmediatamente el tipo personalizado CustomBool:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id     <span class="hljs-keyword">int</span>        <span class="hljs-string">`json:"id"`</span>
	Active CustomBool <span class="hljs-string">`json:"active"`</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CustomBool es una estructura con un solo campo bool de tipo bool:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> CustomBool <span class="hljs-keyword">struct</span> {<font></font>
	Bool <span class="hljs-keyword">bool</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementamos el m√©todo UnmarshalJSON para esta estructura. </font><font style="vertical-align: inherit;">Te dar√© el c√≥digo de inmediato:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CustomBool)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">switch</span> <span class="hljs-keyword">string</span>(data) {
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"true"`</span>, <span class="hljs-string">`true`</span>, <span class="hljs-string">`"1"`</span>, <span class="hljs-string">`1`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">true</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"false"`</span>, <span class="hljs-string">`false`</span>, <span class="hljs-string">`"0"`</span>, <span class="hljs-string">`0`</span>, <span class="hljs-string">`""`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">false</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomBool: parsing \""</span> + <span class="hljs-keyword">string</span>(data) + <span class="hljs-string">"\": unknown value"</span>)<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que el campo activo en nuestro caso tiene un n√∫mero limitado de valores, podemos usar la construcci√≥n de may√∫sculas y min√∫sculas para decidir cu√°l deber√≠a ser el valor del campo Bool de la estructura CustomBool. Para verificar, solo necesita dos bloques de cajas. En el primer bloque, verificamos el valor de verdadero, en el segundo - falso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al registrar posibles valores, debe prestar atenci√≥n al papel de la grava (esta es una comilla en la tecla con la letra E en el dise√±o en ingl√©s). Este personaje te permite escapar de comillas dobles en una cadena. Para mayor claridad, enmarqu√© los valores con comillas y sin comillas con este s√≠mbolo. Por lo tanto, `false` corresponde a la cadena false (sin comillas, escriba bool en json), y` false 'corresponde a la cadena ‚Äúfalse‚Äù (con comillas, escriba string en json). Lo mismo con los valores de '1' y '1'. El primero es el n√∫mero 1 (escrito en json sin comillas), el segundo es la cadena "1" (en json escrito con comillas). Esta entrada `` "` es una cadena vac√≠a, es decir, en formato json se ve as√≠: "". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El valor correspondiente (verdadero o falso) se escribe directamente en el campo Bool de la estructura CustomBool:</font></font><br>
<br>
<pre><code class="go hljs">cb.Bool = <span class="hljs-literal">true</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el bloque predeterminado, devolvemos un error que indica que el campo tiene un valor desconocido:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomBool: parsing \""</span> + <span class="hljs-keyword">string</span>(data) + <span class="hljs-string">"\": unknown value"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora podemos aplicar el m√©todo json.Unmarshal a nuestro c√≥digo json, y los valores del campo activo se convertir√°n a un tipo bool primitivo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementamos el m√©todo MarshalJSON para la estructura CustomBool:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb CustomBool)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cb.Bool)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nada nuevo aqu√≠. </font><font style="vertical-align: inherit;">El m√©todo serializa el campo Bool de la estructura CustomBool. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ est√° el c√≥digo completo que muestra los resultados de la serializaci√≥n y deserializaci√≥n (verificaci√≥n de errores omitida por brevedad):</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"encoding/json"</span>
	<span class="hljs-string">"errors"</span>
	<span class="hljs-string">"fmt"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">type</span> CustomBool <span class="hljs-keyword">struct</span> {<font></font>
	Bool <span class="hljs-keyword">bool</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CustomBool)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">switch</span> <span class="hljs-keyword">string</span>(data) {
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"true"`</span>, <span class="hljs-string">`true`</span>, <span class="hljs-string">`"1"`</span>, <span class="hljs-string">`1`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">true</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"false"`</span>, <span class="hljs-string">`false`</span>, <span class="hljs-string">`"0"`</span>, <span class="hljs-string">`0`</span>, <span class="hljs-string">`""`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">false</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomBool: parsing \""</span> + <span class="hljs-keyword">string</span>(data) + <span class="hljs-string">"\": unknown value"</span>)<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb CustomBool)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cb.Bool)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id     <span class="hljs-keyword">int</span>        <span class="hljs-string">`json:"id"`</span>
	Active CustomBool <span class="hljs-string">`json:"active"`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	jsonString := <span class="hljs-string">`[{"id":1,"active":true},
					{"id":2,"active":"true"},
					{"id":3,"active":"1"},
					{"id":4,"active":1},
					{"id":5,"active":false},
					{"id":6,"active":"false"},
					{"id":7,"active":"0"},
					{"id":8,"active":0},
					{"id":9,"active":""}]`</span><font></font>
<font></font>
	targets := []Target{}<font></font>
<font></font>
	_ = json.Unmarshal([]<span class="hljs-keyword">byte</span>(jsonString), &amp;targets)<font></font>
<font></font>
	<span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> targets {<font></font>
		fmt.Println(t.Id, <span class="hljs-string">"-"</span>, t.Active.Bool)<font></font>
	}<font></font>
<font></font>
	jsonStringNew, _ := json.Marshal(targets)<font></font>
	fmt.Println(<span class="hljs-keyword">string</span>(jsonStringNew))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resultado de ejecuci√≥n del c√≥digo:</font></font><br>
<br>
<pre><code class="bash hljs">1 - <span class="hljs-literal">true</span>
2 - <span class="hljs-literal">true</span>
3 - <span class="hljs-literal">true</span>
4 - <span class="hljs-literal">true</span>
5 - <span class="hljs-literal">false</span>
6 - <span class="hljs-literal">false</span>
7 - <span class="hljs-literal">false</span>
8 - <span class="hljs-literal">false</span>
9 - <span class="hljs-literal">false</span>
[{<span class="hljs-string">"id"</span>:1,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:2,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:3,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:4,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:5,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:6,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:7,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:8,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:9,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>}]</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeramente. </font><font style="vertical-align: inherit;">Anular los m√©todos MarshalJSON y UnmarshalJSON para tipos de datos arbitrarios le permite personalizar la serializaci√≥n y deserializaci√≥n de un campo de c√≥digo json espec√≠fico. </font><font style="vertical-align: inherit;">Adem√°s de los casos de uso indicados, estas funciones se utilizan para trabajar con campos anulables. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En segundo lugar. </font><font style="vertical-align: inherit;">El formato de codificaci√≥n de texto json es una herramienta ampliamente utilizada para el intercambio de informaci√≥n, y una de sus ventajas sobre otros formatos es la disponibilidad de tipos de datos. </font><font style="vertical-align: inherit;">El cumplimiento de estos tipos debe ser estrictamente monitoreado.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es502154/index.html">Escribir autotests de manera efectiva - Pruebas subcut√°neas</a></li>
<li><a href="../es502156/index.html">Caso Rambler v. NGINX: Mesa de Riesgos Criminales de Digitalizaci√≥n 16 de mayo</a></li>
<li><a href="../es502158/index.html">C√≥mo organizar las pruebas para acelerar y estabilizar los lanzamientos de productos. Parte 2</a></li>
<li><a href="../es502160/index.html">El desarrollo de aplicaciones m√≥viles personalizadas es econ√≥mico: realidad o ilusi√≥n</a></li>
<li><a href="../es502166/index.html">Fantasmas Windows 3.1</a></li>
<li><a href="../es502178/index.html">oVirt en 2 horas. Parte 3. Configuraciones avanzadas</a></li>
<li><a href="../es502180/index.html">El d√≠a que desapareci√≥ el per√≠metro. Soluciones de seguridad de Microsoft y socios</a></li>
<li><a href="../es502182/index.html">De nuevo sobre MikroTik o el tan esperado SOCKS5</a></li>
<li><a href="../es502186/index.html">Seminario web Seguridad de la informaci√≥n: SOC en cuarentena</a></li>
<li><a href="../es502196/index.html">–í –ø–æ–¥—Ö–æ–¥–µ –∫ –º–∞—Ç–µ–º–∞—Ç–∏–∫–µ —Å—Ç–æ–ª–µ—Ç–Ω–µ–π –¥–∞–≤–Ω–æ—Å—Ç–∏ –Ω–∞–π–¥–µ–Ω—ã –Ω–æ–≤—ã–µ –∫–ª—é—á–∏ –∫ —Ä–∞–∑–≥–∞–¥–∫–µ –ø—Ä–∏—Ä–æ–¥—ã –≤—Ä–µ–º–µ–Ω–∏</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>