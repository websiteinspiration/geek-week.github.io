<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✅ 🔲 ☀️ グラフストレージのデータ構造：既存および2つの「ほぼ新しい」のレビュー 🕵🏻 🤷🏽 🕞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="みなさん、こんにちは。
 
 このノートでは、コンピューターサイエンスでグラフを格納するために使用される主なデータ構造をリストすることにし、私が何らかの形で結晶化した他のいくつかの構造についても話します。
 
 それでは始めましょう。しかし、最初からではありません-グラフとは何か、そしてそれらが何で...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>グラフストレージのデータ構造：既存および2つの「ほぼ新しい」のレビュー</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469967/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">みなさん、こんにちは。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このノートでは、コンピューターサイエンスでグラフを格納するために使用される主なデータ構造をリストすることにし、私が何らかの形で結晶化した他のいくつかの構造についても話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは始めましょう。</font><font style="vertical-align: inherit;">しかし、最初からではありません-グラフとは何か、そしてそれらが何であるか（方向性、非方向性、重み付け、非重み付け、複数のエッジとループの有無）、私たちはすでに知っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
じゃ、行こう。</font><font style="vertical-align: inherit;">「グラフストレージ」のデータ構造のオプションは何ですか。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.マトリックスデータ構造</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.1 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隣接行列。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隣接行列は、行と列の見出しがグラフの頂点の数に対応する行列であり、その要素a（i、j）のそれぞれの値は、頂点iとjの間のエッジの有無によって決定されます（無向グラフのような行列であることは明らかです）対称になるか、または、主な対角線より上にのみすべての値を保存することに同意できます）。重み付けされていないグラフの場合、a（i、j）はiからjまでのエッジの数（そのようなエッジがない場合はa（i、j）= 0）で指定でき、重み付けされたグラフの場合は、前述のエッジの重み（合計重み）でも指定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発生行列。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この場合、グラフはテーブルにも保存されます。このテーブルでは、原則として、行番号はその頂点の番号に対応し、列番号は事前に番号付けされたエッジに対応します。</font><font style="vertical-align: inherit;">頂点とエッジが互いに入射している場合、対応するセルにゼロ以外の値が書き込まれます（無向グラフの場合、頂点とエッジの入射の場合は1が書き込まれます。有向グラフの場合、エッジが頂点を「残す」場合は「1」、書き込まれている場合は「-1」）それは「入る」（マイナス記号も数字の「-1」に「含まれる」ように見えるので、それは非常に簡単に記憶されます））。</font><font style="vertical-align: inherit;">加重グラフの場合も、1と-1の代わりに、エッジの総ウェイトを指定できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.列挙型データ構造</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.1 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隣接リスト。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さて、すべてが単純なようです。一般に、グラフの各頂点は、この列挙に隣接するすべての頂点の数が格納される列挙構造（リスト、ベクトル、配列など）に関連付けることができます。有向グラフの場合、属性の頂点から「有向」エッジがある頂点のみをリストします。加重グラフの場合、実装はより複雑になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">肋骨のリスト。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">かなり人気のあるデータ構造。エッジのリストは、キャプテンエビデンスが教えているように、実際にはグラフのエッジのリストであり、それぞれが最初の頂点と最後の頂点によって定義されます（無向グラフの場合、順序はここでは重要ではありませんが、たとえば、順序を指定して頂点を指定するなど、さまざまなルールを統合に使用できます）昇順）と重み（重み付きグラフのみ）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のリストについては、マトリックスをより詳細に（およびイラスト付きで）表示でき</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.3 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隣接配列。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も一般的な構造ではありません。</font><font style="vertical-align: inherit;">基本的には、隣接リストを1つの列挙構造（配列、ベクトル）に「パック」する形式です。</font><font style="vertical-align: inherit;">このような配列の最初のn（グラフの頂点の数による）要素には、同じ配列の開始インデックスが含まれ、そこから隣接するすべての頂点がそこに続けて書き込まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで私は（私自身にとって）最も理解しやすい説明を見つけました：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ejuo.livejournal.com/4518.html</font></font></a> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.隣接ベクトルと連想隣接配列</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、これらの行の作成者がプロのプログラマーではなく、定期的にグラフを処理するようになったためであり、ほとんどの場合、エッジのリストを処理していました。実際、グラフに複数のループとエッジがある場合は便利です。そして今、エッジの古典的なリストの開発では、それらの「開発/分岐/修正/突然変異」、すなわち隣接ベクトルと隣接の連想配列に注意を払うことを提案します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1隣接ベクトル</font></font></b><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ケース（a1）：重み付けさ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
れていないグラフ重み付けされていないグラフの隣接ベクトルを、偶数の整数（a [2i]、a [2i + 1]、...、iはc 0と番号付け）の順序付けられたコレクションと呼びます。数値のペアa [2i]、a [2i + 1]は、それぞれ頂点a [2i]とa [2i + 1]の間のグラフのエッジを定義します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記録形式には、グラフが方向付けられているかどうかの情報は含まれていません（両方のオプションが可能です）。ダイグラフ形式を使用する場合、エッジは[2i]から[2i + 1]に向けられていると想定されます。以下：無向グラフの場合、必要に応じて、頂点を記録する順序の要件を適用できます（たとえば、割り当てられた番号の値が小さい方の頂点が最初になるようにします）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++では、このデータ構造の名前が選択されたstd ::ベクトルを使用して隣接ベクトルを指定することをお勧めします。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ケース（a2）：重み付けされていないグラフ、整数のエッジの重み</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ケース（a1）との類推により、整数エッジの重みを持つ重み付きグラフの隣接ベクトルを、数値の順序付けされたセット（動的配列）（a [3i]、a [3i + 1]、a [3i + 2]、...、ここでiはc 0）と番号付けされます。ここで、a [3i]、a [3i + 1]、a [3i + 2]の各「トリプレット」は、a [3i]とa [3i + 1]の下の頂点間のグラフのエッジをそれぞれ定義します。 [3i + 2]の値は、このエッジの重みです。このようなグラフは、方向付けされている場合とそうでない場合があります。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ケース（b）：重み付けされていないグラフ、整数でないエッジの重み</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異種要素は1つの配列（ベクトル）に格納できないため、たとえば次のような実装が可能です。グラフは1対のベクトルに格納され、最初のベクトルは重みを指定しないグラフの隣接ベクトルであり、2番目のベクトルは対応する重みを含みます（C ++の可能な実装はstd ::ペア&lt;std ::ベクトル、std ::ベクトル&gt;です）。したがって、最初のベクトルのインデックス2i、2i + 1の下にある1組の頂点によって定義されるエッジの場合、重みは2番目のベクトルのインデックスiの下の要素に等しくなります。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さて、なぜこれが必要なのでしょうか？</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
さて、いくつかの問題を解決するためのこれらの行の作者にとって、これは非常に便利に思えました。まあ、正式な観点から、そのような利点があります：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隣接ベクトルは、他の「列挙型」構造と同様に、十分にコンパクトで、隣接行列（スパースグラフの場合）よりもメモリ使用量が少なく、実装が比較的簡単です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラフの頂点は、原則として負の数でマークできます。</font><font style="vertical-align: inherit;">突然、そのような「倒錯」も必要になります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラフには、複数のエッジと複数のループを含めることができ、重みは異なります（正、負、さらにはゼロ）。</font><font style="vertical-align: inherit;">ここに制限はありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リブにはさまざまなプロパティを割り当てることができますが、これについては4項を参照してください。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私は認めざるを得ません。この「リスト」は肋骨への迅速なアクセスを意味するものではありません。</font><font style="vertical-align: inherit;">そして、ここでは連想隣接配列が助けを急いでいます-それについて-以下。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2連想隣接配列</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、特定のエッジにアクセスする場合、その重みやその他のプロパティが重要であり、メモリ要件で隣接行列の使用が許可されていない場合は、隣接ベクトルを変更してこの問題を解決する方法を考えてみましょう。したがって、重要なのはグラフのエッジであり、整数の順序付けられたペアとして定義できます。それはどのように見えますか？連想配列のキーになるのでしょうか？もしそうなら、なぜこれを実装しないのですか？このような連想配列を考えてみましょう。各キー（順序付けられた整数のペア）は、値（整数またはエッジの重みを指定する実数）に関連付けられます。 C ++では、std ::マップコンテナー（std :: map &lt;std ::ペア&lt;int、int&gt;、int&gt;またはstd :: map &lt;std ::ペア&lt;int、int&gt;、double&gt;）に基づいてこの構造を実装することをお勧めしますまたはstd :: multimap、複数のエッジが想定されている場合。さて、ここにグラフを保存するための構造があります。これは、「マトリックス」構造よりもメモリを消費せず、複数のループとエッジを備えたグラフを設定でき、頂点数の非負性に対する厳密な要件がなくても（誰がそれを必要とするのかわかりませんが、それでも）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.データ構造は少なくとも「洪水」ですが、何かが欠落しています</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、真実は次のとおりです。多くの問題を解決するとき、いくつかの属性をグラフのエッジに割り当てて、それらを保存する必要がある場合があります。</font><font style="vertical-align: inherit;">これらの機能を整数に明確に削減できる場合は、隣接バージョンの拡張バージョンと連想隣接配列を使用して、このような「追加機能付きグラフ」を保存できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、重み付けされていないグラフを作成します。各エッジには、たとえば、整数で指定された2つの追加属性を格納する必要があります。この場合、隣接ベクトルを、「ペア」ではなく、整数の「カルテット」（a [2i]、a [2i + 1]、a [2i + 2]、a [2i + 3]の順序付きセットとして指定できます。 。）、[2i + 2]と[2i + 3]は対応するエッジの特徴を決定します。整数のエッジの重みを持つグラフの場合、順序は一般に似ています（唯一の違いは、符号がエッジの重みに続き、要素a [2i + 3]およびa [2i + 4]によって与えられ、エッジ自体が指定されることです） 4つではなく、5つの注文番号）。また、エッジの重みが整数でないグラフの場合、属性は重み付けされていないコンポーネントに書き込むことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エッジの重みが整数のグラフに連想隣接配列を使用する場合、個別の数値ではなく、エッジの重みに加えて、その他すべての必要な属性を指定する数値の配列（ベクトル）を指定できます。</font><font style="vertical-align: inherit;">同時に、非整数の重みの場合の不便は、浮動小数点数で文字を指定する必要があることです（はい、これは不便ですが、そのような記号がそれほど多くなく、それらを「トリッキー」な二重に設定しない場合、それは何もないかもしれません）。 。</font><font style="vertical-align: inherit;">したがって、C ++では、拡張連想隣接配列は次のように定義できます。std :: map &lt;std :: pair &lt;int、int&gt;、std :: vector&gt;またはstd :: map &lt;std :: pair &lt;int、int&gt;、 std :: vector、「vector-value-by-key」の最初の値はエッジの重みであり、その特徴の数値指定が特定されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文献：</font></font></h2><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的なグラフとアルゴリズムについて：</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1.コーメン、トーマスH.、リーザーソン、チャールズI.、リベスト、ロナルドL.、スタイン、クリフォード。アルゴリズム：構築と分析、第2版：Per。英語から-M </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。：</font><font style="vertical-align: inherit;">ウィリアムズパブリッシングハウス、2011年</font><font style="vertical-align: inherit;">。2. Harari Frank。グラフ理論。 M：ミール、1973年</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの同じベクトルと隣接の連想配列についての著者のレポート：</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
3. Chernoukhov SAグラフを表現および保存する方法としての隣接ベクトルと連想隣接配列/ SA Chernouhov。グラフを表すデータ構造としての隣接ベクトルと隣接マップ//国際的な科学的および実用的な会議「革新的な開発の結果を実装する際の問題とそれらを解決する方法」（Saratov、09/14/2019）の記事のコレクション。 -Sterlitamak：AMI、2019、p。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トピックに関する</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 65-69 </font><i><font style="vertical-align: inherit;">有用なインターネットソース：</font></i></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
4。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prog-cpp.ru/data-graph</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
5. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ejuo.livejournal.com/4518.html</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja469949/index.html">ユーリクノロゾフの誕生日に向けて：マヤ文字の基礎を学びます</a></li>
<li><a href="../ja469951/index.html">日曜大工のセグメント化されたコントロール、iOS 13.0以降</a></li>
<li><a href="../ja469955/index.html">Custdev、洗練されたサービス、プレゼンテーションアート：VTBアクセラレータの参加者に教えたこと</a></li>
<li><a href="../ja469961/index.html">MicrosoftでのRust（またはSecurity Daemon Azure IoT Edgeの作成）</a></li>
<li><a href="../ja469963/index.html">SonarQubeとIntelliJ IDEA：正しい統合</a></li>
<li><a href="../ja469971/index.html">10ページのdisdock-Pixonicのゲームの例を含むScott Rogersの本に基づくテンプレート</a></li>
<li><a href="../ja469975/index.html">ノートパソコンとサンティアゴの道</a></li>
<li><a href="../ja469977/index.html">3人のクラスメートがFacebookパートナーになった経緯-Revealbotストーリー</a></li>
<li><a href="../ja469979/index.html">2番目のiOS mitap Redmadrobotからのレポートの記録</a></li>
<li><a href="../ja469981/index.html">チャットボットの内部には何がありますか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>