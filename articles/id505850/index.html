<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏼 🥀 🎡 Polimorfisme Berbasis Konsep C ++ dalam Kode Produk: PassManager dalam LLVM ⚒️ ☯️ 👩🏾‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kita akan berbicara tentang satu idiom menarik yang diperkenalkan oleh Sean Parent (Adobe), seorang tokoh terkenal di komunitas C ++. Dia ser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Polimorfisme Berbasis Konsep C ++ dalam Kode Produk: PassManager dalam LLVM</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/samsung/blog/505850/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hari ini kita akan berbicara tentang satu idiom menarik yang diperkenalkan oleh Sean Parent (Adobe), seorang tokoh terkenal di komunitas C ++. </font><font style="vertical-align: inherit;">Dia sering memberikan presentasi dan menerbitkan serangkaian artikel Better Code. </font><font style="vertical-align: inherit;">Salah satu idenya yang digunakan Photoshop adalah Konsep-Berbasis Polimorfisme. </font><font style="vertical-align: inherit;">Ini adalah ketika kita menerapkan polimorfisme bukan melalui pewarisan eksplisit, tetapi menggunakan teknik yang mencakup pemrograman umum, dan sebagai hasilnya kita mendapatkan beberapa keuntungan tambahan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini disusun sebagai berikut:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa itu Polimorfisme Berbasis Konsep dan Mengapa Dibutuhkan?</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sedikit tentang LLVM dan perangkatnya</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh Polimorfisme Berbasis Konsep di LLVM PassManager</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keuntungan dari Pendekatan</font></font><br>
</li>
</ol><br>
<br>
<img src="https://habrastorage.org/webt/hg/ru/az/hgruazi6vbztkex50vkgdcfgknw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebuah gambar yang menggambarkan tesis "Warisan adalah kejahatan." </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber</font></font></a></i><br>
<a name="habracut"></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa itu Polimorfisme Berbasis Konsep dan Mengapa Dibutuhkan?</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam C ++, polimorfisme dinamis diimplementasikan menggunakan fungsi virtual dan pewarisan, dan polimorfisme statis menggunakan pola. </font><font style="vertical-align: inherit;">Di sini kita menggabungkan dua pendekatan ini dan mengambil yang terbaik dari mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penggunaan warisan secara eksplisit sering menyebabkan konektivitas kode yang berlebihan dan pelanggaran prinsip pemisahan antarmuka ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Bagaimana menerapkan polimorfisme dinamis tanpa kerugian ini? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sean Parent mengusulkan idiom yang disebut Polymorphism Berbasis Konsep, di mana warisan tersirat dan tersembunyi dari pengguna. </font><font style="vertical-align: inherit;">Anda dapat mempelajari lebih lanjut tentang ini dari laporannya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inheritance Is The Base Class Of Evil</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - di mana ia menunjukkan seluruh ide menggunakan Photoshop dan riwayat tindakan sebagai contoh - Anda akan belajar bagaimana "sikat sejarah" sebenarnya bekerja.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sedikit tentang LLVM dan perangkatnya</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin menunjukkan kelebihan idiom ini menggunakan contoh LLVM. </font><font style="vertical-align: inherit;">Siapa yang tidak tahu, LLVM adalah infrastruktur untuk mengembangkan kompiler. </font><font style="vertical-align: inherit;">Di bawah ini adalah arsitektur LLVM tingkat sangat tinggi, yang hanya mencakup entitas yang digunakan nanti dalam artikel. </font><font style="vertical-align: inherit;">Untuk informasi lebih lanjut, lihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dokumentasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resmi </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eu/zw/wa/euzwwalazlbmv9kqy8mzbrv95hw.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah arsitektur LLVM, dan, pada prinsipnya, dari setiap kompiler modern.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bagian utamanya adalah sebagai berikut:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Front End mengambil kode sumber program dan mengubahnya menjadi representasi perantara (IR). </font><font style="vertical-align: inherit;">Ini menyederhanakan pekerjaan sisa kompiler sehingga tidak berurusan dengan kode C ++ kompleks.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Middle End - satu set optimisasi, analisis dan transformasi. </font><font style="vertical-align: inherit;">Dalam bentuknya yang paling umum, itu adalah seperangkat pass (Lulus). </font><font style="vertical-align: inherit;">Semua pass terdaftar dan diluncurkan oleh komponen khusus yang disebut PassManager.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back End menghasilkan langsung kode target.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompiler menyajikan program dalam bentuk beberapa entitas dasar. </font><font style="vertical-align: inherit;">Ini adalah modul (file .cpp kondisional), fungsi, unit dasar yang berisi serangkaian instruksi. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ig/vi/0i/igvi0icjbjtgmhbfvdwvvtbyy0c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVM sekarang memiliki dua versi PassManager:&nbsp;</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LegacyPassManager, menggunakan polimorfisme berbasis run-time klasik. </font><font style="vertical-align: inherit;">Hierarki warisan mencakup lintasan yang dijalankan pada modul, fungsi, loop, dll.&nbsp;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PassManager - versi baru, hanya berdasarkan polimorfisme Berbasis Konsep, diusulkan untuk menggantikan LegacyPassManager. </font><font style="vertical-align: inherit;">Kedua versi ada secara paralel dan berkembang secara independen.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ide artikel ini adalah untuk menunjukkan konsep kode produk nyata, yang diimplementasikan dalam dua cara yang berbeda, dan menunjukkan keuntungan dari pendekatan yang terakhir.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh Polimorfisme Berbasis Konsep di LLVM PassManager</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagaimana diimplementasikan dalam Legacy</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, bagaimana semuanya diatur secara klasik, di LegacyPassManager. </font><font style="vertical-align: inherit;">Katakanlah kita memiliki PassManager kelas dan ada Pass kelas - satu lulus. </font><font style="vertical-align: inherit;">Kami memiliki hierarki seperti itu: ModulePass, dari mana kelas kami mewarisi, misalnya, Propagasi Konstan. </font><font style="vertical-align: inherit;">Ada metode runOnModule, ini dia virtual. </font><font style="vertical-align: inherit;">Jadi kita memiliki polimorfisme runtime yang biasa:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/// ModulePass class - This class is used to implement unstructured</span>
<span class="hljs-comment">/// interprocedural optimizations and analyses. ModulePasses may do anything</span>
<span class="hljs-comment">/// they want to the program.</span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModulePass</span> :</span> <span class="hljs-keyword">public</span> Pass {<font></font>
...<font></font>
<span class="hljs-comment">/// runOnModule - Virtual method overriden by subclasses to process the module</span>
<span class="hljs-comment">/// being operated on.</span>
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/// IPCP - The interprocedural constant propagation pass</span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IPCP</span> :</span> <span class="hljs-keyword">public</span> ModulePass {<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> <span class="hljs-keyword">override</span></span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat kodenya, apa masalahnya di sini? Kita melihat bahwa dalam hierarki ini, metode untuk memulai sebuah bagian berbeda tergantung pada apa yang harus dilakukan pada (pada fungsi - runOnFunction, modul - runOnModule, siklus - runOnLoop, dll.). Pada gilirannya, ini membuat tidak mungkin untuk memproses pengumpulan pass yang bekerja dengan entitas IR yang berbeda dalam satu cara (sebenarnya menerapkan polimorfisme). Tampaknya, jelas, bagaimana melakukannya dengan benar: Anda memerlukan metode menjalankan virtual, yang akan didefinisikan ulang dalam ahli waris. Tetapi kemudian muncul masalah: metode yang dijalankan di kelas penerus akan memiliki tanda tangan yang berbeda, karena parameter selalu dilewati dari jenisnya - fungsi, modul, dan sebagainya. Jadi, Anda harus membuat kelas dasar dummy untuk Module, Function, dll., Meneruskan sebuah pointer ke kelas ini dalam proses, dan melakukan down-cast di dalam metode,tergantung pada objek apa yang terletak pada pointer ini. Dan sesuatu yang aneh dimulai: ketika entitas bawahan baru muncul, kita sekarang dipaksa untuk menulis ulang kode superior setiap kali, yang bertentangan dengan semua prinsip desain.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat secara manual menulis kelas adaptor untuk setiap kasing. </font><font style="vertical-align: inherit;">Tapi ini lama dan tidak menarik, dan memang ide yang aneh untuk menulis kelas pembungkus untuk operasi yang mudah hanya melayani komponen. </font><font style="vertical-align: inherit;">Akan lebih baik untuk menghasilkan kode ini secara otomatis menggunakan template. </font><font style="vertical-align: inherit;">Inilah yang diusulkan untuk dibahas dalam pendekatan yang sedang dibahas. </font><font style="vertical-align: inherit;">Plus, seperti yang akan Anda lihat nanti, kami akan mendapatkan beberapa konsekuensi yang lebih bermanfaat.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang disarankan dalam versi baru</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut ini terjadi di PassManager baru. </font><font style="vertical-align: inherit;">Konsep objek polimorfik digeneralisasi sebagai berikut. </font><font style="vertical-align: inherit;">Kami mengatakan bahwa jika suatu objek mengimplementasikan beberapa metode, maka kami memperkenalkan serangkaian metode yang kami ingin menjadi polimorfik, dan kami mengatakan bahwa semua kelas yang menerapkan metode ini adalah polimorfik, yaitu, kita dapat menggunakannya dalam konteks yang dapat dipertukarkan di ini adalah PassManager. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan kelas PassManager di LLVM. </font><font style="vertical-align: inherit;">Ini adalah versi yang disederhanakan, dan yang lengkap dapat ditemukan di llvm / include / llvm / IR / PassManager.h. </font><font style="vertical-align: inherit;">Parameter templat IR secara langsung berspesialisasi dalam entitas yang kami lewati (fungsi run). </font><font style="vertical-align: inherit;">Itu bisa berupa modul, fungsi, atau siklus. </font><font style="vertical-align: inherit;">Kami melihat kode, penjelasan lebih lanjut adalah:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassManager</span> {</span>
<span class="hljs-keyword">public</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; Pass : Passes) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pass-&gt;run(graph, args...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PassT&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addPass</span><span class="hljs-params">(PassT Pass)</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passes.emplace_back(<span class="hljs-keyword">new</span> detail::PassModel&lt;IR, PassT, ArgTs...&gt;(<span class="hljs-built_in">std</span>::move(Pass)));<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;detail::PassConcept&lt;IR, ArgTs...&gt;&gt;&gt; Passes;<font></font>
<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat entitas dasar berikut:</font></font><br>
<br>
<ul>
<li> run     ,        run<br>
</li>
<li> addPass     (      )    PassT<br>
</li>
<li> Passes — ,      .         ,       ,        type erasure,     <br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi seperti apa jenis ini? </font><font style="vertical-align: inherit;">Apa yang disimpan dalam vektor Passes? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, mari kita lihat apa itu PassModel dan PassConcept. </font><font style="vertical-align: inherit;">Ini adalah kelas pembantu internal untuk PassManager. </font><font style="vertical-align: inherit;">Keduanya ada dalam ruang nama detail. </font><font style="vertical-align: inherit;">Pertama, mari kita lihat seperti apa tampilan kelas PassConcept. </font><font style="vertical-align: inherit;">Ini berisi metode jalankan yang sama lagi, ini dia metode virtual murni.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> detail {<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassConcept</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">virtual</span> ~PassConcept() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> </span>= <span class="hljs-number">0</span>;<font></font>
<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas kedua, PassModel, juga boilerplate. </font><font style="vertical-align: inherit;">Itu diwarisi dari PassConcept.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span> PassT, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassModel</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> PassConcept&lt;IR, ArgTs...&gt; {
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">PassModel</span><span class="hljs-params">(PassT Pass)</span> : <span class="hljs-title">pass_</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::move(pass))</span> </span>{}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> <span class="hljs-keyword">final</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass_.run(ir, args...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PassT pass_;<font></font>
<font></font>
};<font></font>
<font></font>
} <span class="hljs-comment">// end namespace detail</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang dikandungnya:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kolom pribadi pass_ jenis PassT</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstruktor yang menerima objek tipe PassT sebagai input. </font><font style="vertical-align: inherit;">Itu tidak menarik, hanya menginisialisasi pass_ menggunakan semantik gerakan</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode run, yang hanya memanggil metode run on pass. </font><font style="vertical-align: inherit;">Lewat, masing-masing, semua argumen yang mungkin ada.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita ingat sekarang di mana kita mulai. Pada gilirannya, PassManager menyimpan semua bagian ini. Dalam Passes vektor dari elemen tipe PassConcept. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, gambaran besarnya. Dibuat oleh PassManager. Menggunakan AddPass, ia mencatat lintasan yang ingin kita buat di atas modul, fungsi, perulangan, dll. Misalnya, sebaris, propagasi konstan, loop terbuka, dll. Mereka sendiri tidak diwarisi dari siapa pun, mereka hanya boleh menjalankan metode. Dan seluruh konsep ini menyediakan ini. Bagaimana?&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Katakanlah kita memiliki optimasi inline. Kami menambahkan objek tipe Inline ke addPass. Oleh karena itu, dalam Passes, dalam vektor, kami menempatkan Inline ini, sudah dalam bentuk PassConcept. Bagaimana kita bisa melakukan ini? Inline tidak diwarisi dari kelas PassConcept. Bagaimana kita meletakkan elemen dalam vektor? Kita tidak bisa melakukan casting ke tipe dasar (upcasting) karena tidak ada warisan. Dan di sini trik semacam itu dilakukan. Kami memiliki kelas pembantu PassConcept yang mendefinisikan antarmuka. Dia mengatakan bahwa semua keturunannya harus menerapkan metode lari. Kami memiliki PassModel, yang pada gilirannya adalah boilerplate. Jadi, ketika kita meletakkan Inline, PassModel ini dipakai dengan tipe Inline ini, objek ini dikompilasi di dalam kelas ini. PassModel sendiri mendefinisikan ulang run, yang untuk dirinya sendiri sudah memanggil run untuk bagian ini,mis. lari dari kelas Inline. Semua ini diselesaikan dalam waktu kompilasi: jika Inline tidak mendefinisikan metode jalankan, kita akan memiliki kesalahan waktu kompilasi.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, polimorfisme ini dicapai tanpa warisan. Mungkin timbul pertanyaan: bagaimana mungkin bukan warisan, karena ini dia, PassModel diwarisi dari PassConcept? Jawaban: ada warisan, tetapi bersifat internal, tidak menonjol, pengguna tidak tahu apa-apa tentang itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami berbicara pada tingkat konseptual. Di sini kami memiliki pengguna, ia ingin mengganti metode tertentu. Pada saat yang sama, ia tidak ingin diwariskan, agar tidak menarik ketergantungan tambahan pada dirinya sendiri. Bagaimana cara melakukannya? Kita berada di dalam diri kita, melalui PassConcept, PassModel, membuat polimorfisme runtime, melalui warisan, tetapi pengguna tidak mengetahuinya: ini semua adalah interior dari dua kelas ini, mereka didefinisikan dalam namespace mereka.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekali lagi, bagaimana ini dicapai? </font><font style="vertical-align: inherit;">Saya punya kelas, sebut saja, biarkan itu Inline, dalam hal kompiler. </font><font style="vertical-align: inherit;">Kami menambahkan Inline ke vektor, masing-masing, membuat objek PassModel. </font><font style="vertical-align: inherit;">Ini memiliki konstruktor yang mengambil objek parameter template ini. </font><font style="vertical-align: inherit;">Jadi, ketika kita memanggil metode run di PassManager, ia menjalankan semua bagian, dalam hal ini kita hanya memiliki satu pass, ia memiliki tipe Inline. </font><font style="vertical-align: inherit;">Itu memanggil metode runC dari PassConcept. </font><font style="vertical-align: inherit;">Metode run yang sama yang terletak di dalam PassModel, yang dipakai oleh tipe Inline. </font><font style="vertical-align: inherit;">Dan sudah metode ini memanggil metode menjalankan pada bagian terdaftar, dalam hal ini, Inline, dan sebagai hasilnya, dijalankan pada Inline disebut.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keuntungan dari Pendekatan</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah bagaimana kami melakukan perilaku yang berbeda tanpa secara eksplisit menggunakan warisan. Kami sekarang tidak memiliki ketergantungan eksplisit yang sebelumnya di LegacyPassManager.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ternyata hal rekursif yang tidak biasa ternyata. Kita bisa menggunakan polimorfisme untuk objek apa pun yang mengabaikan metode run. Karena metode run menimpa PassManager itu sendiri, ia dapat mendaftarkan dirinya sendiri, yaitu menanamkan dirinya dalam vektor pass Pass dan memanggil dirinya lagi.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ternyata kita bisa mencampur semuanya. PassManager yang lama, yaitu Legacy, memiliki pemisahan yang jelas. Ada optimasi modular, yang dilakukan pada modul; ada optimasi yang terjadi pada fungsi. Dan di sini semuanya terjadi dengan lancar. Kami membuat PassManager, instantiate dengan tipe "Module", letakkan Inline di dalamnya, sesuatu yang lain, beberapa optimasi modular lainnya. Kemudian PassManager kedua, kita instantiate dengan tipe "Function", beri optimisasi pada fungsi tersebut. Dan kemudian di PassManager, yang dipakai oleh modul, Anda dapat menempatkan PassManager lain, yang dipakai oleh fungsi, melalui vektor Passes ini.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs">PassManager&lt;Module&gt; MPM;
<span class="hljs-comment">// ... register passes on module</span><font></font>
MPM.addPass(GlobalDCEPass())<font></font>
MPM.addPass(PGOInstrumentationGen());<font></font>
<span class="hljs-comment">//... register passes on function</span><font></font>
PassManager&lt;Function&gt; FPM;&nbsp;<font></font>
FPM.addPass(CallSiteSplittingPass());<font></font>
<span class="hljs-comment">//... register all registered passes on function in module pass manager MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Punya waktu untuk mengikuti? Kami memiliki dua PassManagers. Satu dengan tipe IR Module, yang lainnya dengan tipe IR Function. Katakanlah pada modul yang memiliki modul, kita sudah memasukkan beberapa pass. Sekarang kita ingin mencampurnya dengan pass yang dieksekusi pada suatu fungsi. Apa yang kita lakukan? Kami memanggil addPass dan meneruskan PassManager sebagai Pass, yang dipakai dengan tipe IR "Function" (dalam kode sebenarnya, bukan PassManager yang ditempatkan di sana, tetapi kelas khusus yang membungkusnya, tetapi pada level konseptual itu tidak masalah).&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, kita dapat menggabungkan berbagai tingkat optimisasi - berkat nesting dari PassManagers, secara berurutan melakukan oper ke modul, fungsi, siklus, dll. </font><font style="vertical-align: inherit;">Di Legacy PassManager, ini lebih rumit, ada kelas terpisah untuk modul yang memiliki fungsi virtual runOnModule, kelas terpisah untuk fungsi dengan metode virtual runOnFunction, dll. </font><font style="vertical-align: inherit;">Kedua kelas ini diwarisi dari leluhur umum Pass, tetapi mereka independen satu sama lain dan memiliki antarmuka yang berbeda, yang membuat menggunakan LegacyPassManager tidak nyaman untuk memanggil pass pada entitas IR yang berbeda (modul, fungsi, loop) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahan bacaan tambahan:</font></font><br>
&nbsp;<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM untuk Siswa Lulusan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Pengantar Sederhana untuk LLVM</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presentasi oleh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chandler Carrut tentang bagaimana pengaturan LLVM diatur</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presentasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chandler Carruth tentang detail implementasi PassManager</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di milis yang membahas perbedaan antara LegacyPassManager dan PassManager</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penulis: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/73/et/tp/73ettpg9jylifuwfvohspok-nv4.png" align="left"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roman Rusyaev, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pakar Insinyur </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tim Kompiler AI </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Institut R&amp;D Samsung, Rusia </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Segera Roman akan berbicara di konferensi C ++ Russia 2020 Moskow dengan Anton Polukhin: di sana mereka akan berbicara tentang pemilihan salinan saat ini dan di masa depan: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan ke laporan</font></font></a><br>
<br clear="all">
<img src="https://habrastorage.org/webt/ay/fa/a2/ayfaa2i4aukgor-uh5ija7gstie.png" align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tatyana Volkova, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pemimpin Spesialis </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisnis Tim Pengembangan </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Samsung R&amp;D Institute, Rusia</font></font></i><br>
<br clear="all"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id505824/index.html">Panduan: VPN L2TP Anda Sendiri</a></li>
<li><a href="../id505826/index.html">Cara mendapatkan visi 100% dan bahkan lebih</a></li>
<li><a href="../id505834/index.html">Sampel Median. Interval Keyakinan dan Perbandingan</a></li>
<li><a href="../id505838/index.html">Teknologi FPGA untuk ribuan aplikasi</a></li>
<li><a href="../id505846/index.html">Apa masalah matematika sebenarnya ketika mengembangkan vaksin dari COVID-19?</a></li>
<li><a href="../id505856/index.html">Dari Brute-Force hingga upaya privasi - apa yang dihadapi penyedia SaaS</a></li>
<li><a href="../id505860/index.html">Spring Boot, Hibernate, dan Kotlin untuk pemula langkah demi langkah</a></li>
<li><a href="../id505870/index.html">Cara mempromosikan game dan aplikasi seluler di Jepang, Korea, dan Cina</a></li>
<li><a href="../id505872/index.html">Sejarah kendaraan tak berawak</a></li>
<li><a href="../id505880/index.html">Bagaimana cara menulis indeks Anda di Tarantool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>