<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ûø ‚ô®Ô∏è ü§ûüèª Display search results and performance issues üë®üèæ‚Äçüöí ‚è∏Ô∏è üòÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the typical scenarios in all familiar applications is to search for data according to certain criteria and display them in a form that is easy ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Display search results and performance issues</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/epam_systems/blog/493438/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the typical scenarios in all familiar applications is to search for data according to certain criteria and display them in a form that is easy to read. </font><font style="vertical-align: inherit;">There may also be additional opportunities for sorting, grouping, pagination. </font><font style="vertical-align: inherit;">The task, in theory, is trivial, but when solving it, many developers make a number of mistakes, which then suffer from performance. </font><font style="vertical-align: inherit;">Let's try to consider various solutions to this problem and formulate recommendations for choosing the most effective implementation.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ms/kc/-s/mskc-s_1t4wcxa9w7i04zg4cjjq.jpeg" alt="image"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paging Option # 1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The simplest option that comes to mind is to paginate the search results in its most classic form.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rd/xx/vs/rdxxvst5xhcdfxzvlgrob1csxdk.png" width="498" height="232"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose an application uses a relational database. </font><font style="vertical-align: inherit;">In this case, to display information in this form, you will need to execute two SQL queries:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get rows for the current page.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculate the total number of lines that match the search criteria - this is necessary for showing pages.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider the first query using the test MS SQL database </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AdventureWorks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for 2016 server </font><font style="vertical-align: inherit;">as an example </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For this purpose, we will use the table Sales.SalesOrderHeader:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The above query will display the first 50 orders from a list sorted in descending order by date of addition, in other words, the last 50 orders. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It runs quickly on a test basis, but let's look at the execution plan and I / O statistics:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rw/e8/u8/rwe8u8un-1t5bm3yttan4qsfqrg.png" width="624" height="144"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 698, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can get I / O statistics for each request by running the SET STATISTICS IO ON command in the query runtime. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see from the execution plan, the most resource-intensive is to sort all the rows of the source table by the date of addition. </font><font style="vertical-align: inherit;">And the problem is that the more rows appear in the table, the ‚Äúharder‚Äù the sorting will be. </font><font style="vertical-align: inherit;">In practice, such situations should be avoided, so add the index on the date of addition and see if resource consumption has changed:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/7y/so/g1/7ysog13xd9kalhv9fakieghj4je.png" width="720" height="148"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 165, physical reads 0, read-ahead reads 5, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviously, it got a lot better. </font><font style="vertical-align: inherit;">But have all the problems been resolved? </font><font style="vertical-align: inherit;">Let's change the search request for orders where the total cost of goods exceeds $ 100:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> SubTotal &gt; <span class="hljs-number">100</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yn/_c/7s/yn_c7stdebp1utx8_ck4fbrvxjq.png" width="800" height="137"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 1081, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have a funny situation: the query plan is slightly worse than the previous one, but the actual number of logical readings is almost twice as much as with a full table scan. </font><font style="vertical-align: inherit;">There is a way out - if we make the composite price from the existing index and add the total price of the goods as the second field, then again we get 165 logical reads:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> IX_SalesOrderHeader_OrderDate_SubTotal <span class="hljs-keyword">on</span> Sales.SalesOrderHeader(OrderDate, SubTotal);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This series of examples can be continued for a long time, but the two main thoughts that I want to express here are:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adding any new criterion or sort order to the search query can significantly affect the speed of its execution.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But if we need to subtract only a part of the data, and not all the results that fit the search conditions, there are many ways to optimize such a query.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's move on to the second query, mentioned at the very beginning - to the one that counts the number of records that meet the search criteria. </font><font style="vertical-align: inherit;">Take the same example - finding orders that cost more than $ 100:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> SubTotal &gt; <span class="hljs-number">100</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the presence of the composite index indicated above, we obtain:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nb/tg/yz/nbtgyzsg7her2lswpnfq2jbmotk.png" width="517" height="197"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 698, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The fact that the query passes through the entire index is not surprising, since the SubTotal field is not in the first position, so the query cannot use it. The problem is solved by adding another index to the SubTotal field, and as a result gives already only 48 logical reads. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can give a few more examples of requests for counting the quantity, but the essence remains the same: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">receiving a portion of data and counting the total quantity are two fundamentally different requests</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and each requires its own measures for optimization. In the general case, you cannot find a combination of indexes that works equally well for both queries.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Accordingly, one of the important requirements that should be clarified when developing such a search solution is whether it is really important for the business to see the total number of objects found. </font><font style="vertical-align: inherit;">It often happens that no. </font><font style="vertical-align: inherit;">And navigation to specific page numbers, in my opinion, is a solution with a very narrow scope, since most paging scenarios look like "go to the next page."</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paging Option # 2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose users don‚Äôt care about knowing the total number of objects found. </font><font style="vertical-align: inherit;">Let's try to simplify the search page:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/pr/1t/tcpr1teevrkdz8tcwsbjmx_dl5i.png" width="498" height="230"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, only the fact that there is no way to go to specific page numbers has changed, and now this table does not need to know how many of them can be displayed. But the question arises - how does the table know if there is data for the next page (in order to correctly display the ‚ÄúNext‚Äù link)? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The answer is very simple: you can subtract from the database one record more than you need to display, and the presence of this "additional" record will show whether there is the next portion. Thus, to get one page of data, you will need to complete only one query, which significantly improves performance and makes it easier to support this functionality. In my practice, there was a case when refusing to count the total number of records accelerated the output of results by 4-5 times.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For this approach, there are several options for the user interface: the ‚Äúback‚Äù and ‚Äúforward‚Äù commands, as in the example above, the ‚Äúload more‚Äù button, which simply adds a new portion to the displayed results, ‚Äúinfinite scrolling‚Äù, which works on the principle of ‚Äúload more‚Äù ", But the signal to get the next portion is the user to scroll through all the displayed results to the end. </font><font style="vertical-align: inherit;">Whatever the visual solution, the principle of data sampling remains the same.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The nuances of implementing paging</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In all the examples of the queries above, the approach "offset + quantity" is used, when the query itself indicates in which order the result lines and how many rows should be returned. </font><font style="vertical-align: inherit;">First, consider how best to organize the transfer of parameters in this case. </font><font style="vertical-align: inherit;">In practice, I met several ways:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The serial number of the requested page (pageIndex), page size (pageSize).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The serial number of the first record to be returned (startIndex), the maximum number of records as a result (count).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The serial number of the first record to be returned (startIndex), the serial number of the last record to be returned (endIndex).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At first glance, it might seem that this is so elementary that there is no difference. </font><font style="vertical-align: inherit;">But this is not so - the most convenient and universal option is the second (startIndex, count). </font><font style="vertical-align: inherit;">There are several reasons for this:</font></font><br>
<br>
<ul>
<li>    +1 ,  ,    pageIndex  pageSize  . ,    50   .    ,      ,  .   ¬´+1¬ª    , ,          1  51,   ‚Äî  51  101  ..     51   pageIndex,      52  102  .. ,             ‚Äî     ¬´¬ª ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The third option does not make sense at all, since to execute queries in most databases, you will still need to transfer the quantity, not the index of the last record. </font><font style="vertical-align: inherit;">Let the subtraction of startIndex from endIndex and an elementary arithmetic operation, but it is superfluous here.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we should describe the shortcomings of the implementation of paging through "offset + quantity":</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getting each next page will be more expensive and slower than the previous one, because the database will still need to go through all the records ‚Äúfrom the beginning‚Äù according to the search and sort criteria, and then stop at the desired fragment.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not all DBMSs can support this approach.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are alternatives, but they are also imperfect. </font><font style="vertical-align: inherit;">The first of these approaches is called ‚Äúkeyset paging‚Äù or ‚Äúseek method‚Äù and consists in the following: after receiving a portion, you can remember the values ‚Äã‚Äãof the fields in the last record on the page, and then use them to get the next portion. </font><font style="vertical-align: inherit;">For example, we performed the following request:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And in the last record we got the value of the order date '2014-06-29'. </font><font style="vertical-align: inherit;">Then, to get the next page, you can try to do this:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> OrderDate &lt; <span class="hljs-string">'2014-06-29'</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problem is that OrderDate is a non-unique field, and the condition mentioned above is likely to skip a lot of the required lines. </font><font style="vertical-align: inherit;">To make this request unambiguous, you need to add a unique field to the condition (suppose 75074 is the last value of the primary key from the first portion):</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> (OrderDate = <span class="hljs-string">'2014-06-29'</span> <span class="hljs-keyword">AND</span> SalesOrderID &lt; <span class="hljs-number">75074</span>)
   <span class="hljs-keyword">OR</span> (OrderDate &lt; <span class="hljs-string">'2014-06-29'</span>)
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>, SalesOrderID <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This option will work correctly, but in the general case it will be difficult to optimize, since the condition contains the OR operator. If the value of the primary key grows with the growth of OrderDate, then the condition can be simplified by leaving only the filter by SalesOrderID. But if there is no strict correlation between the values ‚Äã‚Äãof the primary key and the field by which the result is sorted - in most DBMSs this OR cannot be avoided. The exception known to me is PostgreSQL, where tuple comparison is fully supported, and the above condition can be written as ‚ÄúWHERE (OrderDate, SalesOrderID) &lt;('2014-06-29', 75074). If you have a composite key with these two fields, a similar request should be fairly easy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second alternative approach can be found, for example, in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ElasticSearch scroll API</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cosmos DB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - when a query in addition to data returns a special identifier with which you can get the next batch of data. </font><font style="vertical-align: inherit;">If this identifier has an unlimited lifetime (as in Comsos DB), then this is a great way to implement paging with sequential transition between pages (option # 2 mentioned above). </font><font style="vertical-align: inherit;">Its possible disadvantages: not all DBMSs are supported; </font><font style="vertical-align: inherit;">the received next batch identifier may have a limited lifetime, which is generally not suitable for implementing user interaction (such as the ElasticSearch scroll API).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complex filtering</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We complicate the task further. </font><font style="vertical-align: inherit;">Suppose there is a requirement to implement the so-called faceted search, which is familiar to everyone from online stores. </font><font style="vertical-align: inherit;">The above examples based on the order table are not very indicative in this case, so we will switch to the Product table from the AdventureWorks database:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/di/ws/13/diws13cm-qjxoy3igxslnbvizca.png" width="595" height="234"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is the idea of ‚Äã‚Äãfaceted search? </font><font style="vertical-align: inherit;">In that, for each filter element, the number of records matching this criterion is shown </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">taking into account the filters selected in all other categories</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, if we select the Bikes category and the color Black in this example, the table will only display black bikes, but at the same time:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each criterion of the ‚ÄúCategories‚Äù group, the number of products from this category in black will be shown.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each criterion of the Colors group, the number of bikes of that color will be shown.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is an example of outputting the result for such conditions:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/y8/v2/q2/y8v2q2j76mcfnmjmirzu8jrnhyu.png" width="605" height="234"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If in addition to marking the category ‚ÄúClothing‚Äù, the table will also show the black clothes that are available. </font><font style="vertical-align: inherit;">The number of black products in the ‚ÄúColor‚Äù section will also be recalculated according to the new conditions, only in the ‚ÄúCategories‚Äù section nothing will change ... I hope these examples are enough to understand the familiar faceted search algorithm. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now imagine how this can be implemented on a relational basis. </font><font style="vertical-align: inherit;">Each group of criteria, such as Category and Color, will require a separate request:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> pc.ProductCategoryID, pc.Name, <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Production.Product p
  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Production.ProductSubcategory ps <span class="hljs-keyword">ON</span> p.ProductSubcategoryID = ps.ProductSubcategoryID
  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Production.ProductCategory pc <span class="hljs-keyword">ON</span> ps.ProductCategoryID = pc.ProductCategoryID
<span class="hljs-keyword">WHERE</span> p.Color = <span class="hljs-string">'Black'</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> pc.ProductCategoryID, pc.Name
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DESC</span>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mf/79/az/mf79azaflzgu-1gatq4gtbhcdzw.png" width="331" height="90"></div><br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> Color, <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Production.Product p
  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Production.ProductSubcategory ps <span class="hljs-keyword">ON</span> p.ProductSubcategoryID = ps.ProductSubcategoryID
<span class="hljs-keyword">WHERE</span> ps.ProductCategoryID = <span class="hljs-number">1</span> <span class="hljs-comment">--Bikes</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Color
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DESC</span>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/ec/r5/cfecr5njjmi93lsdrei1teygmhi.png" width="190" height="110"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is wrong with this decision? </font><font style="vertical-align: inherit;">Very simple - it does not scale well. </font><font style="vertical-align: inherit;">Each filter section requires a separate query for counting quantities, and these queries are not the easiest. </font><font style="vertical-align: inherit;">In online stores, in some sections, there may be several dozen sections of the filter, which can be a serious problem for performance. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usually, after these statements, they offer me some solutions, namely:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combine all quantity counts into one query. </font><font style="vertical-align: inherit;">Technically, this is possible using the UNION keyword, only this will not help much in performance - anyway, the database will have to execute each of the fragments from scratch.</font></font></li>
<li> .      ,    .   ,      . ,   10 ¬´¬ª,     5 .   ¬´¬ª    ,       -.         9- ,  ,        .     50 ,    ,     2<sup>50</sup>.         ,  .     ,            5-10 . ,          ,  -  ,      ,                (     ).</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, such a task has long had sufficiently effective solutions that predictably work on large amounts of data. For any of these options, it makes sense to divide the facet recount and get the results page into two parallel calls to the server and organize the user interface in such a way that loading the data on the facets ‚Äúdoes not interfere‚Äù with the display of the search results.</font></font><br>
<br>
<ul>
<li>   ¬´¬ª   . ,        ,       ,   ,      ‚Äî ¬´1425  , ?¬ª       ,    ¬´¬ª.                 ¬´¬ª.  ,   ,             .        -. ,       ,        .</li>
<li> search engine      ,   Solr, ElasticSearch, Sphinx  .      ¬´¬ª         .    ,          ,       ‚Äî     .      ,  search engine       ,    :     ,    ,    ;       search engine      .       ‚Äî     .      ¬´ ¬ª.          ¬´¬ª    ,   ,            .      ,   -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">transactional outbox</a>      .</li>
</ul><br>
<h2></h2><br>
<ol>
<li>     ‚Äî  ,             .   ¬´¬ª  ¬´¬ª ‚Äî    ,      :<br>
<ul>
<li>                   ‚Äî       .</li>
<li>   ,         ,    ,     .  -          ‚Äî    .</li>
</ul></li>
<li>                ,          ‚Äî         #2.</li>
<li>     faceted search,        :<br>
<ul>
<li>        .</li>
<li> search engine   Solr, ElasticSearch, Sphinx  .   ,         ,            . </li>
</ul></li>
<li>   faceted search              .      ,   ,        .</li>
<li>   SQL   ,   ,    ,           (   ¬´¬ª ).           ,   ‚Äî  ¬´¬ª.           ,        .</li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en493426/index.html">Organization of code in microservices and my approach of using hexagonal architecture and DDD</a></li>
<li><a href="../en493428/index.html">"We will not give rise to conspiracy theories." Talk about ML conferences with people from science and IT companies</a></li>
<li><a href="../en493430/index.html">Net Architecture for Web Applications</a></li>
<li><a href="../en493432/index.html">Why not start a career in a small non-IT company</a></li>
<li><a href="../en493436/index.html">Program for changing access rights and register of file / directory names on Bash</a></li>
<li><a href="../en493440/index.html">Influencer Marketing in China: what it is based on and what influencers can offer in the context of emergencies</a></li>
<li><a href="../en493442/index.html">PPE Reminder</a></li>
<li><a href="../en493444/index.html">The project "Glass". Energy Efficiency Disposable Tea / Coffee Cups</a></li>
<li><a href="../en493446/index.html">Weekend Reading: 10 Unusual Sound Stories - From Spy Games and Conspiracy Theories to Relaxing ASMR</a></li>
<li><a href="../en493448/index.html">Spring - efficient routing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>