<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏻 👷🏼 🌥️ 最新のフロントエンドアーキテクチャ（パート2） 😘 🐾 🐒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="記事の「パート2 現代のフロントエンドアーキテクチャ」では、データストリームの分散という観点からフロントエンドのアーキテクチャについて説明しています。ここからスタート
 
 実装
 DOMによって生成されたアルゴリズム（DOM注入アルゴリズム）
jQuery ライブラリーによって導入および習得された...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>最新のフロントエンドアーキテクチャ（パート2）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501874/"><img src="https://habrastorage.org/getpro/habr/post_images/8b5/f6a/a95/8b5f6aa95f6481a90520d2d3a3328da4.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の「パート2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現代のフロントエンドアーキテクチャ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」では、データストリームの分散という観点からフロントエンドのアーキテクチャについて説明しています。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ここから</font></a><font style="vertical-align: inherit;">スタート</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DOMによって生成されたアルゴリズム（DOM注入アルゴリズム）</font></font></h3><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jQuery</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ライブラリーによって導入および習得されたこの手法は</font><font style="vertical-align: inherit;">、実際には大規模なクライアントアプリケーションを作成する最初の段階でしたが、実際にはjQueryはアーキテクチャの問題を解決しませんでした。これは、ブラウザーの動作に矛盾が多すぎる場合に、DOMツリーの操作を容易にするように設計されました。これにより、ブラウザに依存しないAPIが提供されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは意図的なものではないと思いますが、jQueryはDOM APIを単純化しているため、通常のプログラミング言語APIと区別することが困難でした。これにより、開発者はDOM APIレベル（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）とビジネスロジック（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を文字通り混在させることができました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでも、同じサーバー側MVCのコンテキストにいます。</font><font style="vertical-align: inherit;">これは単なる続編です。</font><font style="vertical-align: inherit;">制御の実際の反転はありません。</font><font style="vertical-align: inherit;">ビュー/ページの一般的な制御は、依然としてサーバー側コードによって決定されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2k/v-/15/2kv-15oimujnta9v66c8_5fyemu.png"><br>
<br>
<img src="https://habrastorage.org/webt/ya/wm/ol/yawmolshfjijra9q082ghcdf8we.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコードスニペットでは、モデル、プレゼンテーション、プレゼンター/コントローラーが何らかの方法で1つのモノリシックコード構造に結合されています。</font><font style="vertical-align: inherit;">これは、モデルが1つのプロパティのみで構成される場合です。</font><font style="vertical-align: inherit;">（SPAのような）サーバー参照サイクルなしでWebアプリケーションを作成しようとしていると想像してください。</font><font style="vertical-align: inherit;">これらすべてを便利な方法で処理することは不可能です。</font><font style="vertical-align: inherit;">DOMとやり取りするためのコードは、残りのアプリケーションロジックによって貫通されるため、それはDOMインフューズドアルゴリズムとして知られています（そのような用語が正式にあるかどうかはわかりません）</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Backbone.js-MV *</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまで見てきたように、jQueryでは、アプリケーションを開発するときに、コードを構造化および編成する方法が明らかにありません。これが、Backbone.jsが次の進化的ソリューションとして登場した場所です。これは、クライアント側のMVCスタイルの利点をもたらした最初のライブラリの1つでした。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vm/y-/hm/vmy-hmzjujs4fynowrnf5nor-gw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックボーンデータフロー図を見ると、モデルとビューがはっきりとわかりますが、コントローラーに相当するオブジェクトはありません。テンプレートは進化しており、クライアント側のMVCは以前のMVCアーキテクチャの進化形にすぎません。この進化の過程で、JavaScriptコミュニティの多くはモデルとビューの定義に同意しましたが、コントローラーに関するコンセンサスはありませんでした。クライアント環境を考えると、コントローラーのアイデアはあまり適していません。コントローラは解釈のために開いたままです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックボーンに関しては、その中にコントローラーはありません。これは何ですか？それはMVC、MVP、またはMVVMですか？サーバーMVCの定義を借用して、コントローラーには2つの役割があります。つまり、着信HTTP要求の形式でユーザーアクションに応答し、モデルを制御してビュー（HTMLページ）を作成します。バックボーンの場合、これらの責任は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routerの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間で共有され</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。ただし、コントローラーまたはプレゼンターの独立した概念がありません。</font></font><br>
<blockquote>  ,  Backbone —  MVP,  View   Presenter, Template —  View,  Model  Collection  Model.<br>
<br>
      ,       Backbone  -   .          ,     Backbone     MVC,   MVP.                ,    .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがMV *またはModel-View-Whatever（「whatever」）の誕生方法です。詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addi Osmaniのブログ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をチェックすることを強くお勧めします</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">。</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
以前のjQueryと比較して、Backboneはより構造化されたコードの作成に役立ちました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/g6/7n/mv/g67nmvkuqea6gffurmj1hwyjiua.png"><br>
<br>
<img src="https://habrastorage.org/webt/d5/px/jj/d5pxjj4ntyzvhbg5txk0dvdoqxu.png"><br>
<br>
<img src="https://habrastorage.org/webt/hs/pn/m0/hspnm0cxfshnycudmsozwyw6hv0.png"><br>
<br>
<img src="https://habrastorage.org/webt/6j/zl/wn/6jzlwnrwpnnvgtaxg6_quysmohg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の前半で、私はバックボーンを次の進化的ソリューションと呼びました。その理由は、それを補完するためにサーバー側のMVCを単純に拡張したからです。たとえば、サーバーがRESTfulであり、フロントエンドコードがサーバー側のモデルを表す手段にすぎないことを示唆している場合、BackboneはAPIと同期するように事前構成されています。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/mm/zg/8l/mmzg8lm2wtseoo_p15cdknviuw8.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、バックボーンに組み込まれている他の多くの小さな規則があり、拡張機能のように感じられます。</font><font style="vertical-align: inherit;">結論として、当時はバックボーンだけが解決策ではなかったかもしれませんが、コードの構造と編成の点で本当に画期的な作業でした。</font><font style="vertical-align: inherit;">jQueryと同様に、多くの製品で使用されています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knockout.js-フロントエンドのデータバインディング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Knockout.jsは、基本的なテンプレートを使用した最新の例です。</font><font style="vertical-align: inherit;">MVVM-JavaScriptのModel-View-ViewModelの実装を目的としています。</font><font style="vertical-align: inherit;">そしてそうです。</font><font style="vertical-align: inherit;">バックボーンは編成とコード構造の問題に取り組みましたが、ノックアウトは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣言型データバインディングを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">備えたビューレイヤーの効率的な実装です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">宣言的バインディングの利点は、宣言的プログラミング構造と同じです。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読みやすい：宣言型コードはプログラミングに役立ちます </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準テンプレートの短縮：バインディングにより、ViewModelが変更されるたびにDOMを自動的に更新し、ユーザー入力によってViewが変更されるたびにViewModelを更新することもできます。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">観察可能：Knockoutは、イベントに対してより高いレベルの抽象化を提供します。</font><font style="vertical-align: inherit;">これにより、KnockoutはViewModelプロパティ間の依存関係を自動的に追跡できます。</font><font style="vertical-align: inherit;">必要に応じて、Observableプロパティをサブスクライブできます。</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/ry/v6/9i/ryv69iyvghlvmz-xcipifx_bqwm.png"><br>
<br>
<img src="https://habrastorage.org/webt/qq/fz/z9/qqfzz9f0_pdfolzs5l9wd321ddm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KnockoutはViewとViewModelの明確に定義された構成を提供しますが、アプリケーションモデルがどうあるべきかについては何も述べていません。</font><font style="vertical-align: inherit;">これにより、フレームワークの代わりにライブラリとして使用できるため、Knockoutは非常に絞り込まれ、用途が広がります。</font><font style="vertical-align: inherit;">私自身の経験から、Webアプリケーションが複数のページで構成され、各ページが小さなKnockoutアプリケーションであるSPAミニアプリケーションの作成に使用されていることがわかりました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StackOverflowに対する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">回答</font></a><font style="vertical-align: inherit;">は、KnockoutでのMVVMの範囲を明確に定義しています。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの場合、モデルではKnockoutがサーバー側にあると想定されています。</font><font style="vertical-align: inherit;">ViewModelは、Ajaxまたは同等のものを使用してサーバー側モデルを要求するだけです。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Knockoutは、jQueryとDOM更新用のハンドルバーなどのテンプレートソリューションを置き換えますが、アニメーション、Ajax、およびその他のユーティリティにはjQueryを使用します。</font><font style="vertical-align: inherit;">バックボーンと組み合わせると、MVVMテンプレートの完全な実装として機能します。</font><font style="vertical-align: inherit;">理論的には、これが発生する可能性がありますが、発生する前に、これらの概念はすでに次世代のツールで開発されていました。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angular 1、Aurelia、Ember.jsなどの革命的な動きが始まります。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETの世界との密接な関係により、KnockoutはASP.NET MVCアプリケーションで広く使用されています。バックボーンと同様に、これはわずかに異なる問題に対するもう1つの進化的な解決策でした。また、クライアント側のコードはサーバー側のMVCパターンの単なる拡張であるという仮定は変わっていません。サーバー側は依然として主要なアーキテクチャでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KnockoutとBackboneはどちらもJavaScriptライブラリです。</font><font style="vertical-align: inherit;">いずれにしても、Backboneはフレームワークと見なされていました。</font><font style="vertical-align: inherit;">どうして？</font><font style="vertical-align: inherit;">明確な答えはありませんが、おそらく見解ではありませんでした。</font><font style="vertical-align: inherit;">バックボーンは、コード構造に重点を置いているため、常により高いレベルの抽象化で処理されてきました。</font><font style="vertical-align: inherit;">さらに、バックボーンはユビキタスjQuery（2019年でも、上位10,000,000のWebサイトの70％がjQueryを使用している）を置き換えることを意図したものではありませんでしたが、KnockoutはjQueryコア、つまりDOM操作と重複しており、Knockoutを複雑化させていました。</font><font style="vertical-align: inherit;">したがって、ノックアウトの適応はバックボーンと比較して制限されていました。</font><font style="vertical-align: inherit;">しかし、それはまだフロントエンドコミュニティ用の宣言型データバインディングの最初の実装の1つであり、特筆に値します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angular 1-コントロールしてください</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
jQueryがDOMで行ったこと、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angular 1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はフロントエンドエコシステム全体で行った。これにより、大規模なクライアントアプリケーションを作成するという考え方が永遠に変わりました。彼は、モジュラーシステム、依存関係の注入、制御の逆転、より簡単なデータバインディングなどの基礎として多くの概念を提示しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正しいJavaScriptライブラリを選択し、フロントエンドに最適なテクノロジースタックを作成することは、当時も今も難しい作業です。 Angular 1は、よりシンプルでまとまりのある代替手段を提供しました。 Ember.jsや他の同様のシステムについても同じことが言えますが、Angular 1の適用可能性は、当時の代替案とは異なる質的レベルでした。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angular 1は、ページ全体にクライアント側コードが散在している単純なサーバー側MVC拡張のアイデアからの脱却を明確に示したという意味で、革新的なソリューションです。</font><font style="vertical-align: inherit;">Angular 1は、SPAを次世代のユーザーエクスペリエンスを作成するための事実上事実上のソリューションにしています。</font></font></blockquote><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレームワークまたはライブラリ？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前のソリューションは、フレームワークよりも多くのライブラリでした。</font><font style="vertical-align: inherit;">Angular 1は間違いなく明確な構造です。</font><font style="vertical-align: inherit;">プラットフォームとライブラリを区別するために必要な要素は、</font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOC</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Inversion of Controlです。</font><font style="vertical-align: inherit;">さらに、Angular 1をフレームワークとして認定するために、次のことに注意してください。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 明確に定義されたMVVM：Angular 1には明確なModel、View、およびViewModelオブジェクトがあります。</font></font></li>
<li>  (DI): Angular 1    DI,        Model.  Angular 1       (Service).      ,      . </li>
<li>  (data binding)   :    ,     .     ,     MVVM.   .       (Angular 1   ).       .        .        MVC.     ,           . </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュール式システム：Angular 1は、フレームワークに固有のモジュール式システムを導入します。</font><font style="vertical-align: inherit;">モジュールは、ほとんどすべての言語のコードを編成するための基礎です。</font><font style="vertical-align: inherit;">JavaScriptには、2015年までモジュラーシステムがありませんでした（ブラウザーは2018年までそれをサポートしていませんでした）。</font><font style="vertical-align: inherit;">Angularは、組織の面でその時代をはるかに超えています。</font></font><br>
 </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、Angular 1は、その複雑さについても批判されました。</font><font style="vertical-align: inherit;">最も重要な批判は、サーバー側の設計に基づいてモデル化されたことです。</font><font style="vertical-align: inherit;">これはフロントエンド開発者にとって一般的ではありません。</font><font style="vertical-align: inherit;">いくつかは率直に言って悪いことでした：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前空間の衝突：DIはすばらしいものでしたが、グローバル名前空間を使用するService Locatorパターンを使用して実装されました。</font><font style="vertical-align: inherit;">これにより、サービスのプレフィックスがほぼ必須になりました。</font></font></li>
<li>  . ,       ,      ,      .  React     .      -,    . </li>
<li>  .   ,  Angular 1,    . , Angular 1  $scope,    ViewModel,    Controller,    $scope. ,     VMFactory  .  ,  Angular 1      ,     . </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他にも多くの小さな問題がありました。</font><font style="vertical-align: inherit;">Angular 2、または単にAngularは、まったく新しいフレームワークのように見えるほど完全に画期的なものでした。</font><font style="vertical-align: inherit;">名前といくつかの概念を除いて、私はそれらの間に共通点は何もありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4e/wr/r0/4ewrr0pwbrg4edyiyu2x3_rcwwo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長年にわたって、Angular 1の小さなリリースがあり、その使用の小さな複雑さの多くが修正されました。</font><font style="vertical-align: inherit;">これらの中で最も重要なのは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントモデルの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加で</font><font style="vertical-align: inherit;">あり、フロントエンドの開発傾向のほとんどが収束しました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angular 1は長生きし、フロントエンドコミュニティで引き続き使用されています</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">すべての長所と短所を備え、コミュニティがソフトウェアアーキテクチャの重要性を理解するのに役立ち、スケーラブルなアプリケーションを作成するための基礎を提供しました。</font><font style="vertical-align: inherit;">その短所と短所は、将来のアーキテクチャの問題を解決するための基礎となりました。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja501864/index.html">アシスタントまたはインスペクター：ロボットは誰を呼び出していますか？</a></li>
<li><a href="../ja501866/index.html">ロボットが破壊するジョブの数</a></li>
<li><a href="../ja501868/index.html">会計士に自分を投げ込ませない方法、または1Cをクラウドに転送する方法。ステップバイステップの説明</a></li>
<li><a href="../ja501870/index.html">列挙型パートIIの値の最大数</a></li>
<li><a href="../ja501872/index.html">サイバネティックシステムの研究場所</a></li>
<li><a href="../ja501880/index.html">「はじまり」「はじまり」の翻訳について、始まり、始まり、最初なし</a></li>
<li><a href="../ja501882/index.html">コンピュータービジョンアルゴリズムの使用方法：OpenCV.jsを使用したモバイルブラウザーでのビデオ処理</a></li>
<li><a href="../ja501884/index.html">電子医療情報アーカイブが病気の診断をより効果的にする方法</a></li>
<li><a href="../ja501886/index.html">スペースは思ったほど単純ではありません。</a></li>
<li><a href="../ja501888/index.html">ランサムウェアランサムウェアに関連するリスクを減らす方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>