<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕤 👨🏽‍🎓 📙 Comment j'ai appris à mon ordinateur à jouer à Dobble avec OpenCV et Deep Learning 👨‍🏫 🤽🏼 🕺🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour chers abonnés! Vous savez probablement déjà que nous avons lancé un nouveau cours, «Vision par ordinateur», qui commencera les cours dans les ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Comment j'ai appris à mon ordinateur à jouer à Dobble avec OpenCV et Deep Learning</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/498800/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour chers abonnés! </font><font style="vertical-align: inherit;">Vous savez probablement déjà que nous avons lancé un nouveau cours, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Vision par ordinateur»,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui commencera les cours dans les prochains jours. </font><font style="vertical-align: inherit;">En prévision du début des cours, nous avons préparé une autre traduction intéressante pour l'immersion dans le monde du CV.</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/q9/rm/5j/q9rm5jisb3ecqro7lnwivk2wwqc.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon hobby est de jouer à des jeux de société, et comme je suis un peu familier avec les réseaux de neurones convolutionnels, j'ai décidé de créer une application qui peut battre une personne dans un jeu de cartes. </font><font style="vertical-align: inherit;">Je voulais construire un modèle à partir de zéro en utilisant mon propre ensemble de données et voir à quel point cela fonctionne avec un petit ensemble de données. </font><font style="vertical-align: inherit;">J'ai décidé de commencer par le simple jeu Dobble (également connu sous le nom de Spot it!).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous ne savez pas ce qu'est Dobble, je rappellerai brièvement les règles du jeu: Dobble est un jeu de reconnaissance de formes simple dans lequel les joueurs essaient de trouver une image représentée simultanément sur deux cartes. </font><font style="vertical-align: inherit;">Chaque carte du jeu Dobble original contient huit personnages différents, et sur différentes cartes, ils sont de tailles différentes. </font><font style="vertical-align: inherit;">Deux cartes ont un seul symbole commun. </font><font style="vertical-align: inherit;">Si vous trouvez d'abord le symbole, prenez une carte. </font><font style="vertical-align: inherit;">Lorsque le jeu de 55 cartes se termine, celui avec le plus de cartes gagne. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qt/b7/sw/qtb7swvb0bghekmkzqswukrkwoy.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essayez-le par vous-même: quel symbole est commun à ces deux cartes?</font></font></i><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Où commencer?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première étape de la résolution de toute tâche d'analyse de données consiste à collecter des données. </font><font style="vertical-align: inherit;">J'ai pris six photos de chaque carte au téléphone. </font><font style="vertical-align: inherit;">Au total, 330 photos se sont avérées. </font><font style="vertical-align: inherit;">Vous en voyez quatre ci-dessous. </font><font style="vertical-align: inherit;">Vous vous demandez peut-être si cela suffit pour créer un bon réseau de neurones convolutionnels? </font><font style="vertical-align: inherit;">Nous y reviendrons!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cf/8s/c5/cf8sc5csfihv8q9ngt4r5wipzom.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traitement d'image</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OK, les données que nous avons, quelle est la prochaine étape? </font><font style="vertical-align: inherit;">Probablement la partie la plus importante sur la voie du succès: le traitement d'image. </font><font style="vertical-align: inherit;">Nous devons obtenir des personnages de chaque image. </font><font style="vertical-align: inherit;">Quelques difficultés nous attendent ici. </font><font style="vertical-align: inherit;">Sur les photos ci-dessus, on remarque que certains personnages sont plus difficiles à distinguer que d'autres: le bonhomme de neige et le fantôme (sur la troisième photo) et l'aiguille (sur la quatrième) de couleurs claires, et les taches (sur la deuxième photo) et le point d'exclamation (sur la quatrième photo) sont constitués de plusieurs parties . </font><font style="vertical-align: inherit;">Pour traiter les caractères clairs, nous ajouterons du contraste. </font><font style="vertical-align: inherit;">Après cela, nous allons redimensionner et enregistrer l'image.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajouter du contraste</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ajouter du contraste, nous utilisons l'espace colorimétrique </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lab. </font><font style="vertical-align: inherit;">L</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la légèreté, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la composante chromatique dans la gamme du vert au magenta, et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la composante chromatique dans la gamme du bleu au jaune. </font><font style="vertical-align: inherit;">Nous pouvons facilement extraire ces composants en utilisant </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="plaintext hljs">import cv2<font></font>
import imutils<font></font>
imgname = 'picture1'<font></font>
image = cv2.imread(f’{imgname}.jpg’)<font></font>
lab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)<font></font>
l, a, b = cv2.split(lab)</code></pre><br>
<img src="https://habrastorage.org/webt/2u/rf/xs/2urfxs4kcjdhokrytfnpggg_l3s.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De gauche à droite: l'image d'origine, le composant de luminosité, le composant a et le composant b</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Maintenant, nous ajoutons du contraste au composant de luminosité, combinons à nouveau tous les composants ensemble et convertissons en une image normale:</font></font><br>
<br>
<pre><code class="plaintext hljs">clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8,8))<font></font>
cl = clahe.apply(l)<font></font>
limg = cv2.merge((cl,a,b))<font></font>
final = cv2.cvtColor(limg, cv2.COLOR_LAB2BGR)</code></pre><br>
<img src="https://habrastorage.org/webt/6i/fc/wy/6ifcwytem84rmka2rwsn8e2iicu.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De gauche à droite: l'image d'origine, la composante de luminosité, l'image avec un contraste élevé et l'image reconvertie en RVB</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changement de taille</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, redimensionnez et enregistrez l'image:</font></font><br>
<br>
<pre><code class="plaintext hljs">resized = cv2.resize(final, (800, 800))<font></font>
# save the image<font></font>
cv2.imwrite(f'{imgname}processed.jpg', blurred)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terminé!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reconnaissance des cartes et des caractères</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que l'image est traitée, nous pouvons détecter une carte dans l'image. </font><font style="vertical-align: inherit;">En utilisant OpenCV, nous recherchons des contours externes. </font><font style="vertical-align: inherit;">Ensuite, nous convertissons l'image en demi-teintes, sélectionnons la valeur de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seuil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (dans notre cas, 190) pour créer une image en noir et blanc et recherchons un chemin. </font><font style="vertical-align: inherit;">Le code:</font></font><br>
<br>
<pre><code class="plaintext hljs">image = cv2.imread(f’{imgname}processed.jpg’)<font></font>
gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)<font></font>
thresh = cv2.threshold(gray, 190, 255, cv2.THRESH_BINARY)[1]<font></font>
# find contours<font></font>
cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)<font></font>
cnts = imutils.grab_contours(cnts)<font></font>
output = image.copy()<font></font>
# draw contours on image<font></font>
for c in cnts:<font></font>
    cv2.drawContours(output, [c], -1, (255, 0, 0), 3)</code></pre><br>
<img src="https://habrastorage.org/webt/bh/y6/24/bhy624atzopnzxchn5gz0navg0e.jpeg"><br>
 <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image traitée convertie en demi-teintes en utilisant le seuil et en sélectionnant les contours externes</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Si nous trions les contours externes par zone, nous trouverons le contour avec la plus grande zone - ce sera notre carte. </font><font style="vertical-align: inherit;">Pour extraire les caractères, nous pouvons créer un fond blanc.</font></font><br>
<br>
<pre><code class="plaintext hljs"># sort by area, grab the biggest one<font></font>
cnts = sorted(cnts, key=cv2.contourArea, reverse=True)[0]<font></font>
# create mask with the biggest contour<font></font>
mask = np.zeros(gray.shape,np.uint8)<font></font>
mask = cv2.drawContours(mask, [cnts], -1, 255, cv2.FILLED)<font></font>
# card in foreground<font></font>
fg_masked = cv2.bitwise_and(image, image, mask=mask)<font></font>
# white background (use inverted mask)<font></font>
mask = cv2.bitwise_not(mask)<font></font>
bk = np.full(image.shape, 255, dtype=np.uint8)<font></font>
bk_masked = cv2.bitwise_and(bk, bk, mask=mask)<font></font>
# combine back- and foreground<font></font>
final = cv2.bitwise_or(fg_masked, bk_masked)</code></pre><br>
<img src="https://habrastorage.org/webt/j3/lh/dn/j3lhdnzj07y84s5uqiiuphysety.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masque, arrière-plan, image de premier plan, image finale</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Il est maintenant temps de reconnaître les caractères! </font><font style="vertical-align: inherit;">Nous pouvons utiliser l'image résultante pour détecter à nouveau les contours externes, ces contours seront des symboles. </font><font style="vertical-align: inherit;">Si nous créons un carré autour de chaque symbole, nous pouvons extraire cette zone. </font><font style="vertical-align: inherit;">Ici, le code est un peu plus long:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># just like before (with detecting the card)</span><font></font>
gray = cv2.cvtColor(final, cv2.COLOR_RGB2GRAY)<font></font>
thresh = cv2.threshold(gray, <span class="hljs-number">195</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)[<span class="hljs-number">1</span>]<font></font>
thresh = cv2.bitwise_not(thresh)<font></font>
cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)<font></font>
cnts = imutils.grab_contours(cnts)<font></font>
cnts = sorted(cnts, key=cv2.contourArea, reverse=<span class="hljs-literal">True</span>)[:<span class="hljs-number">10</span>]
<span class="hljs-comment"># handle each contour</span>
i = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> cnts:
    <span class="hljs-keyword">if</span> cv2.contourArea(c) &gt; <span class="hljs-number">1000</span>:
        <span class="hljs-comment"># draw mask, keep contour</span><font></font>
        mask = np.zeros(gray.shape, np.uint8)<font></font>
        mask = cv2.drawContours(mask, [c], <span class="hljs-number">-1</span>, <span class="hljs-number">255</span>, cv2.FILLED)
        <span class="hljs-comment"># white background</span><font></font>
        fg_masked = cv2.bitwise_and(image, image, mask=mask)<font></font>
        mask = cv2.bitwise_not(mask)<font></font>
        bk = np.full(image.shape, <span class="hljs-number">255</span>, dtype=np.uint8)<font></font>
        bk_masked = cv2.bitwise_and(bk, bk, mask=mask)<font></font>
        finalcont = cv2.bitwise_or(fg_masked, bk_masked)<font></font>
        <span class="hljs-comment"># bounding rectangle around contour</span><font></font>
        output = finalcont.copy()<font></font>
        x,y,w,h = cv2.boundingRect(c)<font></font>
        <span class="hljs-comment"># squares io rectangles</span>
        <span class="hljs-keyword">if</span> w &lt; h:<font></font>
            x += int((w-h)/<span class="hljs-number">2</span>)<font></font>
            w = h<font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            y += int((h-w)/<span class="hljs-number">2</span>)<font></font>
            h = w<font></font>
        <span class="hljs-comment"># take out the square with the symbol</span><font></font>
        roi = finalcont[y:y+h, x:x+w]<font></font>
        roi = cv2.resize(roi, (<span class="hljs-number">400</span>,<span class="hljs-number">400</span>))
        <span class="hljs-comment"># save the symbol</span>
        cv2.imwrite(<span class="hljs-string">f"<span class="hljs-subst">{imgname}</span>_icon<span class="hljs-subst">{i}</span>.jpg"</span>, roi)<font></font>
        i += <span class="hljs-number">1</span></code></pre><br>
<img src="https://habrastorage.org/webt/qf/pf/vk/qfpfvkmhh5u674jgxpbiecjcovg.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image en noir et blanc (seuillée), contours détectés, symbole fantôme et symbole coeur (caractères extraits avec des masques)</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri des caractères</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant le plus ennuyeux! </font><font style="vertical-align: inherit;">Vous devez trier les caractères. </font><font style="vertical-align: inherit;">Vous aurez besoin des répertoires de formation, de test et de validation, 57 répertoires chacun (nous avons 57 caractères différents au total). </font><font style="vertical-align: inherit;">La structure des dossiers est la suivante:</font></font><br>
<br>
<pre><code class="python hljs">symbols<font></font>
 ├── test<font></font>
 │   ├── anchor<font></font>
 │   ├── apple<font></font>
 │   │   ...<font></font>
 │   └── zebra<font></font>
 ├── train<font></font>
 │   ├── anchor<font></font>
 │   ├── apple<font></font>
 │   │   ...<font></font>
 │   └── zebra<font></font>
 └── validation<font></font>
     ├── anchor<font></font>
     ├── apple<font></font>
     │   ...<font></font>
     └── zebra</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il faudra un certain temps pour mettre les caractères extraits (plus de 2500 pièces) dans les répertoires nécessaires! </font><font style="vertical-align: inherit;">J'ai du code pour créer des sous-dossiers, une suite de tests et un kit de validation sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Peut-être que la prochaine fois, il vaut mieux faire le tri basé sur l'algorithme de clustering ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formation au réseau neuronal convolutif</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après la partie ennuyeuse, le plaisir revient! </font><font style="vertical-align: inherit;">Il est temps de créer et de former un réseau neuronal convolutionnel. </font><font style="vertical-align: inherit;">Vous pouvez </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trouver des</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> informations sur les réseaux de neurones convolutifs </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">ici</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Architecture du modèle</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons pour tâche de classer plusieurs classes avec une seule étiquette. </font><font style="vertical-align: inherit;">Pour chaque personnage, nous avons besoin d'une étiquette. </font><font style="vertical-align: inherit;">C'est pourquoi nous aurons besoin d'une fonction pour activer la couche </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">softmax de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sortie </font><font style="vertical-align: inherit;">avec 57 nœuds et une entropie croisée catégorielle comme fonction de perte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'architecture du modèle final est la suivante:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># imports</span>
<span class="hljs-keyword">from</span> keras <span class="hljs-keyword">import</span> layers
<span class="hljs-keyword">from</span> keras <span class="hljs-keyword">import</span> models
<span class="hljs-keyword">from</span> keras <span class="hljs-keyword">import</span> optimizers
<span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword">import</span> ImageDataGenerator
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-comment"># layers, activation layer with 57 nodes (one for every symbol)</span><font></font>
model = models.Sequential()<font></font>
model.add(layers.Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, input_shape=(<span class="hljs-number">400</span>, <span class="hljs-number">400</span>, <span class="hljs-number">3</span>)))<font></font>
model.add(layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))  <font></font>
model.add(layers.Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>))<font></font>
model.add(layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<font></font>
model.add(layers.Conv2D(<span class="hljs-number">128</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>))<font></font>
model.add(layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<font></font>
model.add(layers.Conv2D(<span class="hljs-number">256</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>))<font></font>
model.add(layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<font></font>
model.add(layers.Conv2D(<span class="hljs-number">256</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>))<font></font>
model.add(layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<font></font>
model.add(layers.Conv2D(<span class="hljs-number">128</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>))<font></font>
model.add(layers.Flatten())<font></font>
model.add(layers.Dropout(<span class="hljs-number">0.5</span>)) <font></font>
model.add(layers.Dense(<span class="hljs-number">512</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
model.add(layers.Dense(<span class="hljs-number">57</span>, activation=<span class="hljs-string">'softmax'</span>))<font></font>
model.compile(loss=<span class="hljs-string">'categorical_crossentropy'</span>,       optimizer=optimizers.RMSprop(lr=<span class="hljs-number">1e-4</span>), metrics=[<span class="hljs-string">'acc'</span>])</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Augmentation des données</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour améliorer les performances, j'ai utilisé l'augmentation des données. </font><font style="vertical-align: inherit;">L'augmentation des données est le processus d'augmentation du volume et de la variété des données d'entrée. </font><font style="vertical-align: inherit;">Cela peut être fait en faisant pivoter, déplacer, redimensionner, recadrer et retourner les images existantes. </font><font style="vertical-align: inherit;">Keras peut facilement augmenter les données:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># specify the directories</span>
train_dir = <span class="hljs-string">'symbols/train'</span>
validation_dir = <span class="hljs-string">'symbols/validation'</span>
test_dir = <span class="hljs-string">'symbols/test'</span>
<span class="hljs-comment"># data augmentation with ImageDataGenerator from Keras (only train)</span>
train_datagen = ImageDataGenerator(rescale=<span class="hljs-number">1.</span>/<span class="hljs-number">255</span>, rotation_range=<span class="hljs-number">40</span>, width_shift_range=<span class="hljs-number">0.1</span>, height_shift_range=<span class="hljs-number">0.1</span>, shear_range=<span class="hljs-number">0.1</span>, zoom_range=<span class="hljs-number">0.1</span>, horizontal_flip=<span class="hljs-literal">True</span>, vertical_flip=<span class="hljs-literal">True</span>)<font></font>
test_datagen = ImageDataGenerator(rescale=<span class="hljs-number">1.</span>/<span class="hljs-number">255</span>)<font></font>
train_generator = train_datagen.flow_from_directory(train_dir, target_size=(<span class="hljs-number">400</span>,<span class="hljs-number">400</span>), batch_size=<span class="hljs-number">20</span>, class_mode=<span class="hljs-string">'categorical'</span>)<font></font>
validation_generator = test_datagen.flow_from_directory(validation_dir, target_size=(<span class="hljs-number">400</span>,<span class="hljs-number">400</span>), batch_size=<span class="hljs-number">20</span>, class_mode=<span class="hljs-string">'categorical'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous étiez intéressé, le fantôme augmenté ressemble à ceci: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hj/wq/_c/hjwq_ckmzjkvmyr9xu9fr5pyq0w.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'image originale du fantôme sur la gauche, des fantômes augmentés dans toutes les autres images</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formation modèle</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entraînons le modèle, enregistrons-le pour l'utiliser pour les prévisions et vérifions les résultats.</font></font><br>
<br>
<pre><code class="python hljs">history = model.fit_generator(train_generator, steps_per_epoch=<span class="hljs-number">100</span>, epochs=<span class="hljs-number">100</span>, validation_data=validation_generator, validation_steps=<span class="hljs-number">50</span>)
<span class="hljs-comment"># don't forget to save your model!</span>
model.save(<span class="hljs-string">'models/model.h5'</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/uz/c2/qm/uzc2qml9v4-zezvickpgjezm8ly.gif"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des prédictions parfaites!</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">résultats</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le modèle de base que j'ai formé sans augmentation de données, abandons et avec moins de couches. </font><font style="vertical-align: inherit;">Ce modèle a donné les résultats suivants: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lc/tg/u3/lctgu3nfsj3felc31tuhtg68neg.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les résultats du modèle de base A</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
l'œil nu, il est clair que ce modèle est recyclé. </font><font style="vertical-align: inherit;">Les résultats de la version finale du modèle (son code est présenté dans les sections précédentes) sont bien meilleurs. </font><font style="vertical-align: inherit;">Sur le graphique ci-dessous, vous pouvez voir la précision et les pertes pendant la formation et sur l'ensemble de validation. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/tn/s2/bwtns2xrfdgnlzuxmwppzdqhyom.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résultats du modèle final</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sur le banc d'essai, ce modèle n'a commis qu'une seule erreur, il a reconnu la bombe comme une goutte. </font><font style="vertical-align: inherit;">J'ai décidé de rester sur ce modèle, la précision sur l'ensemble de test était de 0,995.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reconnaissance d'un symbole commun sur deux cartes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez maintenant commencer à rechercher des symboles communs sur deux cartes. </font><font style="vertical-align: inherit;">Nous utilisons deux photographies, nous allons faire des prédictions pour chaque image séparément et utiliser l'intersection d'ensembles pour savoir quel symbole est sur les deux cartes. </font><font style="vertical-align: inherit;">Nous avons 3 options de travail:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une erreur s'est produite lors de la prédiction: aucun personnage commun n'a été trouvé.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a un symbole à l'intersection (la prédiction peut être vraie ou fausse).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a plus d'un caractère à l'intersection. </font><font style="vertical-align: inherit;">Dans ce cas, je choisis le symbole avec la probabilité la plus élevée (la moyenne des deux prédictions).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code pour prédire toute la combinaison des deux images dans les mensonges de catalogue avec </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font></font><code>main.py</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et voici les résultats:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kz/6h/em/kz6hemmqhp7bhdq25ywzipipdou.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 N'est-ce pas le modèle parfait? Malheureusement non. Quand j'ai pris de nouvelles photos des cartes et leur ai donné les modèles de prédiction, il y avait des problèmes avec le bonhomme de neige. Parfois, il reconnaissait l'œil ou le zèbre comme un bonhomme de neige! En conséquence, parfois les résultats étaient étranges: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/b0/y4/e8/b0y4e8nw6kq7juigw_oekx2jjtk.jpeg"> <br>
 <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, où est le bonhomme de neige ici?</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ce modèle est-il meilleur que l'homme? Selon ce dont nous avons besoin: les gens reconnaissent parfaitement, mais le modèle le fait plus rapidement! J'ai remarqué le temps pendant lequel l'ordinateur fait face: j'ai donné un jeu de 55 cartes et j'ai dû obtenir un symbole commun pour chaque combinaison de deux cartes. Au total, ce sont 1485 combinaisons. L'ordinateur l'a fait en moins de 140 secondes. Il a fait quelques erreurs, mais il battra certainement n'importe qui en matière de vitesse!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t2/pn/ce/t2pncemklqifymf39ixawz9ejsg.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Je ne pense pas qu'il soit difficile de créer un modèle 100% fonctionnel. </font><font style="vertical-align: inherit;">Cela peut être réalisé grâce à une formation de transfert. </font><font style="vertical-align: inherit;">Pour comprendre ce que fait le modèle, nous pourrions visualiser des couches pour l'image de test. </font><font style="vertical-align: inherit;">Vous pouvez le faire la prochaine fois!</font></font><br>
<br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En savoir plus sur le cours et réussir le test d'entrée</font></font></a><br>
<br>
<hr></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr498768/index.html">Utilisation d'un détecteur de fumée dans les véhicules</a></li>
<li><a href="../fr498782/index.html">Expérimentateurs de bataille - Science du sable et du bâton - Inoculation de la pensée scientifique dans l'esprit du public</a></li>
<li><a href="../fr498788/index.html">Apprentissage d'un mini moteur pas à pas</a></li>
<li><a href="../fr498796/index.html">Politique de sécurité du contenu dans Magento 2</a></li>
<li><a href="../fr498798/index.html">Continuez à apprendre et à apprendre avec JetBrains</a></li>
<li><a href="../fr498808/index.html">Vim avec prise en charge YAML pour Kubernetes</a></li>
<li><a href="../fr498814/index.html">Vous avez échoué une question théorique sur la sécurité sociale, et ils ont mis fin à vous. C'est normal? // Nous sommes condamnés # 3</a></li>
<li><a href="../fr498816/index.html">La vérité tout d'abord, ou pourquoi le système doit être conçu en fonction du périphérique de base de données</a></li>
<li><a href="../fr498820/index.html">Quelques questions plus délicates sur .NET et C #</a></li>
<li><a href="../fr498826/index.html">SIL et Salesforce</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>