<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺 ☮️ 🤳 書籍「.NETプラットフォームでの高性能コード。第二版 👨🏻‍🎨 🤰🏻 🦒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この本では、.NET環境の利点をまったく犠牲にすることなく、または最悪の場合は最小限の数を犠牲にせずに、マネージコードのパフォーマンスを最大化する方法について説明します。合理的なプログラミング方法を学び、回避すべきことを学び、おそらく最も重要なこととして、特別な困難なしにパフォーマンスのレベルを測定...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>書籍「.NETプラットフォームでの高性能コード。第二版</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/458520/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/sl/sj/0d/slsj0dvgahq6ejfp9lenc9s8mzu.jpeg" align="left" alt="画像"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この本では、.NET環境の利点をまったく犠牲にすることなく、または最悪の場合は最小限の数を犠牲にせずに、マネージコードのパフォーマンスを最大化する方法について説明します。合理的なプログラミング方法を学び、回避すべきことを学び、おそらく最も重要なこととして、特別な困難なしにパフォーマンスのレベルを測定するために無料で入手できるツールの使用方法を学びます。トレーニング資料には最小限の水が含まれます-最も必要なものだけです。本はあなたが知る必要があることを正確に与えます、それは関連していて簡潔です、あまり含まれていません。ほとんどの章は、一般的な情報と背景で始まり、特定のヒントが続き、レシピのように設定され、最後に、さまざまなシナリオの段階的な測定とデバッグのセクションが続きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その過程で、ベンワトソンは.NET環境の特定のコンポーネント、特にその下にある共通言語ランタイム（CLR）に没頭し、マシンのメモリがどのように管理され、コードが生成され、マルチスレッド実行が編成され、さらに多くのことが行われるかがわかります。 。</font><font style="vertical-align: inherit;">.NETアーキテクチャがソフトウェアツールをどのように制限し、追加の機能を提供するか、およびプログラミングパスの選択がアプリケーションの全体的なパフォーマンスに大きく影響する方法を示します。</font><font style="vertical-align: inherit;">おまけとして、著者は過去9年間にMicrosoftで非常に大規模で複雑な高性能.NETシステムを作成した経験からのストーリーを共有します。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抜粋：適切なスレッドプールサイズを選択する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間の経過とともに、スレッドプールは個別に構成されますが、最初は履歴がなく、初期状態で開始されます。ソフトウェア製品が非常に非同期で、中央プロセッサを大幅に使用している場合、さらに多くのスレッドの作成と可用性のために、初期起動コストが法外に高くなる可能性があります。起動パラメータを調整すると、アプリケーションが起動した瞬間から、一定数の既製のスレッドを自由に使えるように、定常状態をより速く達成するのに役立ちます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> int MinWorkerThreads = <span class="hljs-number">25</span>;
<span class="hljs-keyword">const</span> int MinIoThreads = <span class="hljs-number">25</span>;<font></font>
ThreadPool.SetMinThreads(MinWorkerThreads, MinIoThreads);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで注意してください。 Taskオブジェクトを使用する場合、そのディスパッチは、これに使用できるスレッドの数に基づいて行われます。それらの数が多すぎると、タスクオブジェクトが過度のスケジューリングを受ける可能性があり、少なくとも頻繁にコンテキストが切り替えられるため、中央プロセッサの効率が低下します。ワークロードがそれほど高くない場合、スレッドプールは、スレッド数を減らすアルゴリズムを使用するように切り替えて、指定した数よりも少ない数にすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SetMaxThreadsメソッドを使用して最大数を設定することもできますが、この手法には同様のリスクがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要なスレッド数を見つけるには、このパラメーターをそのままにして、ThreadPool.GetMaxThreadsメソッドとThreadPool.GetMinThreadsメソッド、またはプロセスに関与するスレッドの数を示すパフォーマンスカウンターを使用して、アプリケーションを安定した状態で分析します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フローを中断しないでください</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のスレッドの作業と調整せずにスレッドの作業を中断することは、かなり危険な手順です。ストリームは自分自身をクリーンアップする必要があり、ストリームのAbortを呼び出しても、マイナスの影響なしに閉じることはできません。スレッドが破棄されると、アプリケーションの一部が未定義の状態になります。プログラムをクラッシュさせた方がよいでしょうが、理想的にはクリーンな再起動が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドを安全にシャットダウンするには、ある種の共有状態を使用する必要があり、スレッド関数自体がこの状態をチェックして、シャットダウンするタイミングを決定する必要があります。セキュリティは首尾一貫して達成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、常にTaskオブジェクトを使用する必要があります。タスクを中断するためのAPIは提供されていません。</font><font style="vertical-align: inherit;">常にスレッドを終了できるようにするには、前述のように、CancellationTokenトークンを使用する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドの優先順位を変更しないでください</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、スレッドの優先順位を変更することは、非常にうまくいっていません。</font><font style="vertical-align: inherit;">Windowsでは、スレッドのディスパッチは優先度レベルに従って実行されます。</font><font style="vertical-align: inherit;">高優先度のスレッドが常に実行する準備ができている場合、低優先度のスレッドは無視され、まれに実行される可能性があります。</font><font style="vertical-align: inherit;">スレッドの優先度を上げることにより、その作業は他のプロセスを含む他のすべての作業よりも優先されると言います。</font><font style="vertical-align: inherit;">これは安定したシステムにとって安全ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドが通常の優先順位のタスクの完了まで待機できる何かを実行している場合は、スレッドの優先順位を下げることをお勧めします。スレッドの優先度を下げる1つの理由は、無限ループを実行している制御不能のスレッドを発見することである可能性があります。スレッドを安全に中断することは不可能であるため、特定のスレッドとプロセッサリソースを返す唯一の方法は、プロセスを再起動することです。ストリームを閉じてきれいに実行できるようになるまでは、制御不能なストリームの優先度を下げることで、結果を最小限に抑えることができます。優先度の低いスレッドであっても、時間の経過とともに実行されることが保証されていることに注意してください。スレッドの起動が奪われる時間が長いほど、Windowsによって動的優先度が高く設定されます。例外は、アイドル優先度THREAD_ ‑ PRIORITY_IDLEです。この場合、オペレーティングシステムは、文字どおり開始するものがない場合にのみスレッドの実行をスケジュールします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まれな状況に迅速に対応する必要があるなど、フローの優先度を上げる理由は十分に正当化される場合があります。</font><font style="vertical-align: inherit;">ただし、このような手法の使用は非常に注意が必要です。</font><font style="vertical-align: inherit;">Windowsでのスレッドのスケジューリングは、それらが属するプロセスに関係なく実行されるため、プロセスからの優先度の高いスレッドは、他のスレッドだけでなく、システムで実行されている他のアプリケーションからのすべてのスレッドを犠牲にして起動されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドプールが使用されている場合、スレッドがプールに戻るたびに、優先度の変更はすべて破棄されます。</font><font style="vertical-align: inherit;">Task Parallelライブラリを使用しているときにベーススレッドの管理を続ける場合は、プールに戻る前に、いくつかのタスクが同じスレッドで起動される可能性があることに注意してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドの同期とブロッキング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
会話がいくつかのスレッドに到達するとすぐに、それらを同期する必要があります。同期は、クラスフィールドなどの共有状態への1つのスレッドのみのアクセスを提供することにあります。通常、スレッドは、Monitor、Semaphore、ManualResetEventなどの同期オブジェクトを使用して同期されます。非公式にロックと呼ばれることもあり、特定のスレッドでの同期プロセスはロックと呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロックに関する基本的な真実の1つはこれです。ロックがパフォーマンスを向上させることはありません。</font><font style="vertical-align: inherit;">最良のシナリオ-同期プリミティブが適切に実装され、競合がない場合-ブロッキングは中立です。</font><font style="vertical-align: inherit;">これは、他のスレッドによる有用な作業の実行を停止させ、CPU時間を浪費し、コンテキストの切り替え時間を増やし、他の悪影響を引き起こします。</font><font style="vertical-align: inherit;">正確さは単純なパフォーマンスよりもはるかに重要であるため、これに我慢する必要があります。</font><font style="vertical-align: inherit;">間違った結果がすぐに計算されるかどうかは問題ではありません！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロック装置の使用に関する問題を解決する前に、最も基本的な原則を検討します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスを気にする必要はありますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に生産性を向上させる必要性を正当化します。これにより、第1章で説明した原則に戻ります。パフォーマンスは、すべてのアプリケーションコードにとって等しく重要ではありません。すべてのコードがn次の最適化を受ける必要があるわけではありません。原則として、すべては「内部ループ」（最も頻繁に実行されるコード、またはパフォーマンスにとって最も重要なコード）から始まり、コストが受け取ったメリットを超えるまですべての方向に広がります。コードには、パフォーマンスの点でそれほど重要ではない多くの領域があります。このような状況で、ロックが必要な場合は、静かに適用してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今、あなたは注意する必要があります。重要でないコードがスレッドプールのスレッドで実行され、それを長時間ブロックすると、スレッドプールが他の要求を処理するためにさらにスレッドを挿入し始める場合があります。 1つまたは2つのスレッドが時々これを行う場合、それは問題ありません。しかし、多くのスレッドがこのようなことを行うと、問題が発生する可能性があります。これは、このため、実際の作業を行う必要があるリソースが無駄に消費されるためです。重要な一定の負荷でプログラムを開始するときの不注意は、不必要なコンテキストの切り替えやスレッドプールの不当な関与が原因で、パフォーマンスが重要ではない部分からでもシステムに悪影響を与える可能性があります。他のすべての場合と同様に、状況を評価するために測定を行う必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本当にロックが必要ですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も効果的なロック機構は、そうでないものです。</font><font style="vertical-align: inherit;">スレッド同期の必要性を完全に排除できる場合、これは高いパフォーマンスを得るための最良の方法です。</font><font style="vertical-align: inherit;">これは、実現がそれほど容易ではない理想です。</font><font style="vertical-align: inherit;">通常、これは、変更可能な共有状態がないことを確認する必要があることを意味します。アプリケーションを通過する各リクエストは、別のリクエストや集中化された変更可能な（読み書き）データとは無関係に処理できます。</font><font style="vertical-align: inherit;">この機能は、高パフォーマンスを実現するための最良のシナリオです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、まだ注意してください。</font><font style="vertical-align: inherit;">再構築を行うと、コードを無理にやりすぎて、コードをごちゃごちゃした混乱に変えるのは簡単です。</font><font style="vertical-align: inherit;">高い生産性が本当に重要な要素であり、他の方法では達成できない場合を除いて、あまり遠くに行くべきではありません。</font><font style="vertical-align: inherit;">コードを非同期で独立したものにしますが、コードは明確なままです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のスレッドが変数から読み取るだけの場合（そしてストリームからそれに書き込むヒントがない場合）、同期は必要ありません。</font><font style="vertical-align: inherit;">すべてのスレッドが無制限にアクセスできます。</font><font style="vertical-align: inherit;">これは、文字列や不変タイプの値などの不変オブジェクトに自動的に適用されますが、複数のスレッドによる読み取り中にその値の不変性を保証する場合は、任意のタイプのオブジェクトに適用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
共有変数に書き込むスレッドが複数ある場合は、ローカル変数の使用に移行することで、同期アクセスを排除できるかどうかを確認します。</font><font style="vertical-align: inherit;">作業用に一時的なコピーを作成できれば、同期の必要性はなくなります。</font><font style="vertical-align: inherit;">これは、繰り返し同期アクセスする場合に特に重要です。</font><font style="vertical-align: inherit;">複数のスレッドで共有されているコレクションに項目を追加する次の簡単な例のように、共有変数への1回限りのアクセスに続いて、共有変数への再アクセスからローカル変数への再アクセスに移行する必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs">object syncObj = <span class="hljs-keyword">new</span> object();
<span class="hljs-keyword">var</span> masterList = <span class="hljs-keyword">new</span> List&lt;long &gt;();
<span class="hljs-keyword">const</span> int NumTasks = <span class="hljs-number">8</span>;<font></font>
Task[] tasks = <span class="hljs-keyword">new</span> Task[NumTasks];<font></font>
<font></font>
<span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; NumTasks; i++)<font></font>
{<font></font>
     tasks[i] = Task.Run(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span><font></font>
     {<font></font>
           <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000000</span>; j++)<font></font>
           {<font></font>
                lock (syncObj)<font></font>
                {<font></font>
                      masterList.Add(j);<font></font>
                }<font></font>
            }<font></font>
      });<font></font>
}<font></font>
Task.WaitAll(tasks);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは次のように変換できます。</font></font><br>
<br>
<pre><code class="javascript hljs">object syncObj = <span class="hljs-keyword">new</span> object();
<span class="hljs-keyword">var</span> masterList = <span class="hljs-keyword">new</span> List&lt;long &gt;();
<span class="hljs-keyword">const</span> int NumTasks = <span class="hljs-number">8</span>;<font></font>
Task[] tasks = <span class="hljs-keyword">new</span> Task[NumTasks];<font></font>
<font></font>
<span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; NumTasks; i++)<font></font>
{<font></font>
     tasks[i] = Task.Run(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span><font></font>
     {<font></font>
           <span class="hljs-keyword">var</span> localList = <span class="hljs-keyword">new</span> List&lt;long &gt;();
           <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000000</span>; j++)<font></font>
           {<font></font>
                localList.Add(j);<font></font>
           }<font></font>
           lock (syncObj)<font></font>
           {<font></font>
                masterList.AddRange(localList);<font></font>
           }<font></font>
      });<font></font>
}<font></font>
Task.WaitAll(tasks);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のマシンでは、2番目のバージョンのコードは、最初のバージョンの2倍以上の速度で実行されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終的に、変更可能な共有状態は、パフォーマンスの根本的な敵です。</font><font style="vertical-align: inherit;">データのセキュリティのために同期が必要であり、パフォーマンスが低下します。</font><font style="vertical-align: inherit;">デザインに少なくともブロックを回避するためのわずかな機会があれば、理想的なマルチスレッドシステムを実装することになります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優先順位の同期</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同期の種類が必要かどうかを判断する場合、それらすべてが同じパフォーマンスまたは動作特性を持っているわけではないことを理解する必要があります。ほとんどの状況では、ロックを使用するだけでよく、通常はこれが元のオプションです。ブロッキング以外のものを使用する場合は、追加の複雑さを正当化するために集中的な測定が必要です。一般に、同期メカニズムは次の順序で検討します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.ロック/クラスモニター-コードのシンプルさ、わかりやすさを維持し、パフォーマンスのバランスをとります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.同期の完全な欠如。</font><font style="vertical-align: inherit;">共有されている変更可能な状態を取り除き、再構成して最適化します。</font><font style="vertical-align: inherit;">これはより困難ですが、成功した場合は基本的にブロッキングを適用するよりもうまく機能します（エラーが発生した場合やアーキテクチャが低下した場合を除きます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.インターロックの単純なインターロック方式-一部のシナリオではより適切な場合がありますが、状況がより複雑になるとすぐに、ロックロックの使用に進みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、それらの使用の利点を本当に証明できる場合は、より複雑で複雑なロックを使用します（覚えておいてください。期待どおりに役立つことはめったにありません）。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期ロック（この章の後半で説明します）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その他。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の状況により、これらのテクノロジーの一部の使用が指示または妨げられる場合があります。</font><font style="vertical-align: inherit;">たとえば、複数のInterlockedメソッドを組み合わせても、単一のロックステートメントよりもパフォーマンスが高くなることはほとんどありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»書籍の詳細については、上で見つけることができます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版社のウェブサイト</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抜粋</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
クーポンのためにKhabrozhiteley 25％割引- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ブックの紙のバージョンのための支払いを受信すると、電子書籍を電子メールで送信されます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja458504/index.html">時間を節約する13のnpmトリック</a></li>
<li><a href="../ja458506/index.html">ポータル3ではなく、近い：ダイヤモンド内の情報の量子テレポーテーション</a></li>
<li><a href="../ja458508/index.html">Inside View：EPFLの大学院。パート4.2：財務面</a></li>
<li><a href="../ja458514/index.html">GDPRの違反はより積極的に罰せられます-新鮮な罰金とEU外の規制の影響</a></li>
<li><a href="../ja458516/index.html">Jiraから作業ログを取得</a></li>
<li><a href="../ja458524/index.html">膝の上のVC単語の雲</a></li>
<li><a href="../ja458530/index.html">Zabbix、時系列、TimescaleDB</a></li>
<li><a href="../ja458532/index.html">新技術のパイオニア：Vadim Artsevは、彼が盲目でなくなった方法を語りました</a></li>
<li><a href="../ja458536/index.html">Python + Pyside2または単に「電卓」</a></li>
<li><a href="../ja458546/index.html">自動化の日、または自動テストレイヤーの構築方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>