<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏿 🐢 🛀 Consejos y trucos de Kubernetes: elegantes funciones de tiempo de ejecución de apagado en NGINX y PHP-FPM 📰 🏂🏿 🚏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una condición típica para implementar CI / CD en Kubernetes: la aplicación debe poder dejar de aceptar nuevas solicitudes de clientes antes de detener...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Consejos y trucos de Kubernetes: elegantes funciones de tiempo de ejecución de apagado en NGINX y PHP-FPM</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/489994/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una condición típica para implementar CI / CD en Kubernetes: la aplicación debe poder dejar de aceptar nuevas solicitudes de clientes antes de detenerse, y lo más importante, completar con éxito las existentes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ka/ry/ef/karyefzfd99wtpxne9r_o73wies.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El cumplimiento de esta condición le permite lograr un tiempo de inactividad cero durante la implementación. </font><font style="vertical-align: inherit;">Sin embargo, incluso cuando se utilizan paquetes muy populares (como NGINX y PHP-FPM), puede encontrar dificultades que provocarán una oleada de errores con cada implementación ...</font></font><a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teoría. </font><font style="vertical-align: inherit;">Cómo vive la vaina</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya hemos publicado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este artículo en</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> detalle sobre el ciclo de vida de la cápsula </font><font style="vertical-align: inherit;">. En el contexto de este tema, estamos interesados ​​en lo siguiente: en el momento en que el pod ingresa al estado de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminación</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dejan de enviarse nuevas solicitudes (el pod </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se elimina</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la lista de puntos finales para el servicio). Por lo tanto, para evitar el tiempo de inactividad durante la implementación, por nuestra parte, es suficiente para resolver el problema de detener correctamente la aplicación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También debe recordarse que el período de gracia es de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30 segundos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de forma predeterminada </font><font style="vertical-align: inherit;">: después de esto, el pod se cerrará y la aplicación debería procesar todas las solicitudes antes de este período. </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: aunque cualquier solicitud que se ejecute durante más de 5-10 segundos ya es problemática, y el apagado correcto ya no lo ayudará ...</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Para comprender mejor lo que sucede cuando el pod finaliza su trabajo, es suficiente estudiar el siguiente esquema: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zx/pt/ou/zxptou-qe7zxqgab6pszsdo5vlk.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A1, B1 - Obteniendo cambios sobre estado de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A2: Enviar SIGTERM </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
B2 - Eliminar el pod de los puntos finales </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
B3 - Obtener cambios (la lista de puntos finales ha cambiado) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
B4 - Actualizar las reglas de iptables</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nota: eliminar el pod de puntos finales y enviar SIGTERM no se realiza de forma secuencial, sino en paralelo. Y debido al hecho de que Ingress no recibe una lista actualizada de Endpoints de inmediato, se enviarán nuevas solicitudes de los clientes al pod, lo que causará 500 errores durante la finalización del pod.</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traducido</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> materiales más detallada sobre esta cuestión </font><font style="vertical-align: inherit;">)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Debe resolver este problema de las siguientes maneras:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Envíe los encabezados de la conexión: cierre la respuesta (si se trata de una aplicación HTTP).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si no hay forma de realizar cambios en el código, el artículo describe una solución que le permitirá procesar las solicitudes hasta el final del período de gracia.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teoría. </font><font style="vertical-align: inherit;">Cómo NGINX y PHP-FPM finalizan sus procesos</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos con NGINX, ya que todo es más o menos obvio con él. </font><font style="vertical-align: inherit;">Inmersos en la teoría, aprendemos que NGINX tiene un proceso maestro y varios "trabajadores": estos son procesos secundarios que procesan las solicitudes de los clientes. </font><font style="vertical-align: inherit;">Se proporciona una característica conveniente: usar el comando para </font></font><code>nginx -s &lt;SIGNAL&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finalizar procesos en modo de apagado rápido o en apagado correcto. </font><font style="vertical-align: inherit;">Obviamente, estamos interesados ​​precisamente en la última opción. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces todo es simple: debe agregar un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comando</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">gancho preStop</font></a><font style="vertical-align: inherit;"> que enviará una señal sobre el apagado </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">correcto</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esto se puede hacer en Implementación, en el bloque contenedor:</font></font><br>
<br>
<pre><code class="plaintext hljs">       lifecycle:<font></font>
          preStop:<font></font>
            exec:<font></font>
              command:<font></font>
              - /usr/sbin/nginx<font></font>
              - -s<font></font>
              - quit</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, en el momento en que la cápsula completa su trabajo en los registros del contenedor NGINX, veremos lo siguiente:</font></font><br>
<br>
<pre><code class="plaintext hljs">2018/01/25 13:58:31 [notice] 1#1: signal 3 (SIGQUIT) received, shutting down<font></font>
2018/01/25 13:58:31 [notice] 11#11: gracefully shutting down</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y eso significará lo que necesitamos: NGINX espera la finalización de las consultas y luego elimina el proceso. </font><font style="vertical-align: inherit;">Sin embargo, se discutirá un problema común a continuación, debido a que, incluso si hay un comando, el </font></font><code>nginx -s quit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proceso </font><font style="vertical-align: inherit;">no </font><font style="vertical-align: inherit;">se completa correctamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y en esta etapa hemos terminado con NGINX: al menos puedes entender por los registros que todo funciona como debería. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué pasa con PHP-FPM? </font><font style="vertical-align: inherit;">¿Cómo maneja el apagado elegante? </font><font style="vertical-align: inherit;">Vamos a hacerlo bien.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP-FPM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el caso de PHP-FPM, un poco menos de información. </font><font style="vertical-align: inherit;">Si se concentra en el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manual oficial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre PHP-FPM, le indicará que se reciben las siguientes señales POSIX:</font></font><br>
<br>
<ol>
<li> <code>SIGINT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>SIGTERM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- apagado rápido;</font></font></li>
<li> <code>SIGQUIT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - cierre elegante (lo que necesitamos).</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resto de las señales en este problema no son necesarias, por lo tanto, se omite su análisis. </font><font style="vertical-align: inherit;">Para completar el proceso correctamente, deberá escribir el siguiente enlace preStop:</font></font><br>
<br>
<pre><code class="plaintext hljs">        lifecycle:<font></font>
          preStop:<font></font>
            exec:<font></font>
              command:<font></font>
              - /bin/kill<font></font>
              - -SIGQUIT<font></font>
              - "1"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primera vista, esto es todo lo que se requiere para realizar un apagado correcto en ambos contenedores. </font><font style="vertical-align: inherit;">Sin embargo, la tarea es más complicada de lo que parece. </font><font style="vertical-align: inherit;">A continuación, examinamos dos casos en los que el cierre correcto no funcionó y causó una inaccesibilidad a corto plazo del proyecto durante la implementación.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Práctica. </font><font style="vertical-align: inherit;">Posibles problemas con el apagado elegante</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, es útil recordar: además de ejecutar el comando, </font></font><code>nginx -s quit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay otro paso al que debe prestar atención. Nos encontramos con un problema cuando NGINX en lugar de una señal SIGQUIT envió SIGTERM de todos modos, debido a que las solicitudes no se completaron correctamente. Se pueden encontrar casos similares, por ejemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Desafortunadamente, no pudimos establecer una razón específica para este comportamiento: había una sospecha de la versión NGINX, pero no se confirmó. La sintomatología fue que en los registros del contenedor NGINX se observaron los mensajes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"abra el zócalo # 10 dejado en la conexión 5"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , después de lo cual la cápsula se detuvo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos observar este problema, por ejemplo, por las respuestas al Ingress que necesitamos: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/um/sz/ip/umszip1dlpudotn2dstg17qfnzs.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indicadores de código de estado en el momento del despliegue</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, obtenemos solo el código de error 503 del propio Ingress: no puede acceder al contenedor NGINX, ya que ya no está disponible. </font><font style="vertical-align: inherit;">Si observa los registros del contenedor con NGINX, contienen lo siguiente:</font></font><br>
<br>
<pre><code class="plaintext hljs">[alert] 13939#0: *154 open socket #3 left in connection 16<font></font>
[alert] 13939#0: *168 open socket #6 left in connection 13</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de cambiar la señal de parada, el contenedor comienza a detenerse correctamente: esto se confirma por el hecho de que ya no se observa un error 503. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si encuentra un problema similar, tiene sentido averiguar qué señal de parada se usa en el contenedor y cómo se ve exactamente el gancho preStop. </font><font style="vertical-align: inherit;">Es posible que la razón radique precisamente en esto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP-FPM ... y más</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema con PHP-FPM se describe de manera trivial: no espera la finalización de los procesos secundarios, los finaliza, por lo que hay 502 errores durante la implementación y otras operaciones. Desde 2005 ha habido varios mensajes de error en bugs.php.net (por ejemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) que describen este problema. Pero probablemente no verá nada en los registros: PHP-FPM anunciará la finalización de su proceso sin errores ni notificaciones de terceros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vale la pena aclarar que el problema en sí mismo puede, en mayor o menor medida, depender de la aplicación misma y puede no aparecer, por ejemplo, en el monitoreo. Si aún lo encuentra, le viene a la mente una solución simple: agregue un gancho preStop con</font></font><code>sleep(30)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se le permitirá completar todas las solicitudes que habían sido antes (no se aceptan los nuevos, ya que la vaina es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que ya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminación</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del estado </font><font style="vertical-align: inherit;">), y después de 30 segundos la vaina sí terminará con una señal </font></font><code>SIGTERM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resulta que </font></font><code>lifecycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para el contenedor se verá así:</font></font><br>
<br>
<pre><code class="plaintext hljs">    lifecycle:<font></font>
      preStop:<font></font>
        exec:<font></font>
          command:<font></font>
          - /bin/sleep<font></font>
          - "30"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, debido a la indicación de 30 segundos, </font></font><code>sleep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tendremos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significativamente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aumentar el tiempo de implementación, ya que cada vaina se dará por terminado por </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al menos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 30 segundos, lo que es malo. ¿Qué se puede hacer con esto? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pasemos a la parte responsable de la ejecución directa de la aplicación. En nuestro caso, se trata de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP-FPM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por defecto no supervisa la ejecución de sus procesos secundarios</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : el proceso maestro finaliza de inmediato. Este comportamiento se puede cambiar mediante una directiva </font></font><code>process_control_timeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que especifica los límites de tiempo para esperar las señales del maestro por parte de los procesos secundarios. Si establece el valor en 20 segundos, esto cubrirá la mayoría de las solicitudes que se ejecutan en el contenedor y, una vez completado, el proceso maestro se detendrá.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con este conocimiento, volveremos a nuestro último problema. Como ya se mencionó, Kubernetes no es una plataforma monolítica: lleva algún tiempo la interacción entre sus diversos componentes. Esto es especialmente cierto cuando consideramos el trabajo de Ingresss y otros componentes relacionados, porque debido a tal retraso en el momento de la implementación, es fácil obtener un aumento de 500 errores. Por ejemplo, puede producirse un error en la etapa de envío de una solicitud al flujo ascendente, pero el "intervalo de tiempo" de interacción entre los componentes es bastante corto, menos de un segundo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en conjunción</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con la directiva ya mencionada </font></font><code>process_control_timeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se puede utilizar la siguiente construcción para </font></font><code>lifecycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">lifecycle:<font></font>
  preStop:<font></font>
    exec:<font></font>
      command: ["/bin/bash","-c","/bin/sleep 1; kill -QUIT 1"]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, compensamos la demora del equipo </font></font><code>sleep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y no aumentamos significativamente el tiempo de implementación: ¿hay una diferencia notable entre 30 segundos y uno? ... Esencialmente </font></font><code>process_control_timeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">toma el "trabajo principal" </font><font style="vertical-align: inherit;">, pero se </font></font><code>lifecycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa solo como una "red de seguridad" en caso de retraso. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En términos generales, el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comportamiento descrito y la solución alternativa correspondiente conciernen no solo a PHP-FPM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Una situación similar puede surgir de una forma u otra al usar otros lenguajes / marcos. </font><font style="vertical-align: inherit;">Si no puede solucionar el apagado correcto de otras maneras, por ejemplo, reescriba el código para que la aplicación procese correctamente las señales de terminación, puede usar el método descrito. </font><font style="vertical-align: inherit;">Puede que no sea la más hermosa, pero funciona.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Práctica. </font><font style="vertical-align: inherit;">Prueba de carga para verificar el rendimiento del pod</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La prueba de carga es una forma de verificar cómo funciona el contenedor, ya que este procedimiento lo acerca a las condiciones reales de combate cuando los usuarios visitan el sitio. Puede usar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex.Tank</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para probar las recomendaciones anteriores </font><font style="vertical-align: inherit;">: cubre perfectamente todas nuestras necesidades. Los siguientes son consejos y trucos para probar con claridad, gracias a los gráficos de Grafana y Yandex.Tank, un ejemplo de nuestra experiencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo más importante aquí es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verificar los cambios en las etapas.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Después de agregar una nueva solución, ejecute la prueba y vea si los resultados han cambiado en comparación con el lanzamiento anterior. De lo contrario, será difícil identificar soluciones ineficaces, y en el futuro solo puede hacer daño (por ejemplo, aumentar el tiempo de implementación). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra advertencia: observe los registros del contenedor durante su finalización. ¿Se registra allí información graciosa de apagado? ¿Hay algún error en los registros al acceder a otros recursos (por ejemplo, un contenedor PHP-FPM vecino)? ¿Errores de la propia aplicación (como en el caso de NGINX descrito anteriormente)? Espero que la información introductoria de este artículo ayude a comprender mejor lo que le sucede al contenedor durante su finalización. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, la primera prueba se realizó sin </font></font><code>lifecycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y sin directivas adicionales para el servidor de aplicaciones (</font></font><code>process_control_timeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en PHP-FPM). El propósito de esta prueba fue identificar el número aproximado de errores (y si existen). Además, a partir de información adicional, se debe saber que el tiempo promedio de implementación de cada hogar fue de aproximadamente 5-10 segundos hasta el estado de plena preparación. Los resultados son los siguientes: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ce/yw/ap/ceywapg8q2kpztr-zdslhjy8brm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
en el panel de información de Yandex.Tank aparece un toque de 502 errores, que ocurrió en el momento del despliegue y duró hasta 5 segundos en promedio. Presumiblemente, esto finalizó las solicitudes existentes al antiguo pod cuando se finalizó. Después de eso, aparecieron 503 errores, que fueron el resultado de un contenedor NGINX detenido, que también se desconectó debido al backend (por lo que Ingress no pudo conectarse). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos a ver como</font></font><code>process_control_timeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en PHP-FPM nos ayudará a esperar la finalización de los procesos secundarios, es decir </font><font style="vertical-align: inherit;">Corregir tales errores. </font><font style="vertical-align: inherit;">Despliegue repetido usando esta directiva: ¡ </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t5/8g/0c/t58g0cs5b6umhjkmvlhjktbkio0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No hay más errores durante el despliegue de los 500! </font><font style="vertical-align: inherit;">La implementación es exitosa, el cierre correcto funciona. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, vale la pena recordar el momento con los contenedores de Ingress, un pequeño porcentaje de errores en los que podemos obtener debido a un retraso de tiempo. </font><font style="vertical-align: inherit;">Para evitarlos, queda agregar la construcción </font></font><code>sleep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y repetir el despliegue. </font><font style="vertical-align: inherit;">Sin embargo, en nuestro caso particular, no hubo cambios visibles (no hubo errores nuevamente).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para completar correctamente el proceso, esperamos el siguiente comportamiento de la aplicación:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Espere unos segundos, luego deje de aceptar nuevas conexiones.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Espere a que se completen todas las solicitudes y cierre todas las conexiones de keepalive que no ejecutan solicitudes.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Completa tu proceso.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, no todas las aplicaciones pueden funcionar de esta manera. </font><font style="vertical-align: inherit;">Una solución al problema en las realidades de Kubernetes es:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregar un gancho previo a la parada que esperará unos segundos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estudiando el archivo de configuración de nuestro backend para los parámetros relevantes.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El ejemplo de NGINX nos permite comprender que incluso una aplicación que inicialmente debe procesar correctamente las señales para su finalización puede no hacerlo, por lo que es fundamental verificar si hay 500 errores durante el despliegue de la aplicación. También le permite ver el problema de manera más amplia y no concentrarse en una cápsula o contenedor por separado, sino observar toda la infraestructura en su conjunto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex.Tank se puede utilizar como herramienta de prueba junto con cualquier sistema de monitoreo (en nuestro caso, los datos de Grafana con un backend en forma de Prometheus se tomaron para la prueba). Los problemas con el apagado correcto son claramente visibles bajo cargas pesadas que el punto de referencia puede generar, y el monitoreo ayuda a analizar la situación con más detalle durante o después de la prueba.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En respuesta a los comentarios sobre el artículo: vale la pena mencionar que los problemas y las soluciones se describen aquí en relación con NGINX Ingress. </font><font style="vertical-align: inherit;">Para otros casos, existen otras soluciones que, quizás, consideraremos en los siguientes materiales del ciclo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PD</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otros del ciclo de consejos y trucos de K8s:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Páginas de error personalizadas en NGINX Ingress</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ";</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre la asignación de nodos y la carga en la aplicación web</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ";</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acceso a sitios de desarrollo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ";</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acelerar el arranque de grandes bases de datos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">.</font></a></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es489984/index.html">AMA sobre udalenka: pregunta - respondemos</a></li>
<li><a href="../es489986/index.html">Power Stage Designer Utility - Herramienta para desarrolladores de Power Electronics</a></li>
<li><a href="../es489988/index.html">“¡Levanta las manos en el aire!”: Una mono revisión de la consola Playme TIO S</a></li>
<li><a href="../es489990/index.html">¿Cómo salvó Service Desk a una empresa de servicios, o qué sucede si su negocio crece?</a></li>
<li><a href="../es489992/index.html">Corregir el cierre del pod en el clúster de Kubernetes</a></li>
<li><a href="../es489998/index.html">11. Fortinet Getting Started v6.0. Licencia</a></li>
<li><a href="../es490002/index.html">Cómo GraphQL en Kotlin y Micronaut y crear un único punto de acceso a la API de varios microservicios</a></li>
<li><a href="../es490006/index.html">Programa educativo para especificaciones técnicas.</a></li>
<li><a href="../es490010/index.html">Examen del sistema de tipos para verificar la exactitud de la música.</a></li>
<li><a href="../es490012/index.html">Alertas y errores de almacenamiento, ¿cómo lidiar con ellos?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>