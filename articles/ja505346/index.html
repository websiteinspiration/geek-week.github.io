<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍺 📩 ↔️ Civilization VIからUnityへの戦争の霧の実装 ⛹🏽 🦇 🙌🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Civilization VIのfog of warエフェクトは、計算シェーダーの単純な構造の好例です。そのようなシェーダーのプログラミングの基本について常に学びたいと思っているなら、このチュートリアルはあなたのためです。シェーダーやC＃でのプログラミングの知識がなくても理解できます。経験豊富な開発...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Civilization VIからUnityへの戦争の霧の実装</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505346/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c9/6b0/eb8/3c96b0eb83174e6090382b9d16727259.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Civilization VIのfog of warエフェクトは、計算シェーダーの単純な構造の好例です。</font><font style="vertical-align: inherit;">そのようなシェーダーのプログラミングの基本について常に学びたいと思っているなら、このチュートリアルはあなたのためです。</font><font style="vertical-align: inherit;">シェーダーやC＃でのプログラミングの知識がなくても理解できます。</font><font style="vertical-align: inherit;">経験豊富な開発者は導入をスキップできます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">効果分析</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームの効果を調べて分析することからプロジェクトを始めましょう。</font><font style="vertical-align: inherit;">さいわい、Civilizationはターン制のゲームなので、効果を必要なだけ観察できます。</font><font style="vertical-align: inherit;">古い保存をアップロードし、世界のさまざまな地域のスクリーンショットをいくつか撮りました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/682/cfc/25f/682cfc25fb14224ea2c3034d10ccd8d2.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に注意する必要があるのは、表示領域と非表示領域の境界です。</font><font style="vertical-align: inherit;">「隠れた」エリアは、戦争の霧に覆われた手描きの地図を連想させるエリアです。</font><font style="vertical-align: inherit;">境界が六角形のフィールドと正確に一致していないこと、ノイズがほとんどないこと、明らかにパーリンノイズであることがはっきりとわかります。</font></font><br>
<a name="habracut"></a><br>
<blockquote><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノイズパーリン</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーリンノイズは、オーガニックフォームのモデリングに使用されるノイズの一種です。</font><font style="vertical-align: inherit;">通常、救済の高さおよび溶解効果はそれに基づいて作成されます。</font></font></blockquote><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23d/e6e/5c7/23de6e5c78426f5db713e5031b472d46.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、非表示領域のグラフィックコンポーネントを見てみましょう。これに対する効果は、シーン内の静的メッシュ（建物、植生など）上の画像の効果（境界線の輪郭と影に似たもの）に似ています。明らかに、戦争の霧の下にある動的なオブジェクトは見えなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、空のタイルで特に目立つ、手描きのレリーフテクスチャ（草など）があります。このプロジェクトでは、これらのテクスチャのみを使用します。これは、シェーダーに加えて同様の画像効果を作成することは、1つのチュートリアルでは大きすぎるタスクになるためです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/6ae/3ea/42f6ae3ea2da6099aaf4418e8826a335.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、戦争の霧の効果を生み出す2つの側面があります。</font><font style="vertical-align: inherit;">1つは領域の境界の勾配であり、海のタイルではっきりと見ることができます。</font><font style="vertical-align: inherit;">また、一定の厚みがないこと、つまり、前述のパーリンノイズに基づいていることもわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、エフェクトの上に小さなノイズがあり、大きな空のタイルの単調性を破壊します。</font><font style="vertical-align: inherit;">南の海のタイル上にあります（海岸の波がないタイル上）。</font><font style="vertical-align: inherit;">これには、Perlinノイズテクスチャを使用することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このチュートリアル用のプロジェクトテンプレートを準備しました。このテンプレートには、予備的な構造がすでに作成されています。</font><font style="vertical-align: inherit;">ない場合は、GitHubから複製またはダウンロードできます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトテンプレート</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のセクションでは、プロジェクト構造の重要な部分、特にC＃計算シェーダー制御スクリプトについて簡単に説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unityプロジェクト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assets / SampleScene.unityを開くことから始めましょう。</font><font style="vertical-align: inherit;">ご覧のとおり、シーンにはほとんど何もありません。六角形の単純なグリッド、指向性照明のソース、およびカメラだけです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30a/b58/68d/30ab5868d81e4901ff33912fc30790b5.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、カメラの後処理のセットアップとマテリアル構造の2つの側面に注目したいと思います。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/900/923/40e90092378c9c51747b076f03ffed28.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインカメラを選択すると、後処理のボリュームとレイヤーが表示されます。</font><font style="vertical-align: inherit;">ここではUnity後処理パッケージを使用します。</font><font style="vertical-align: inherit;">適用される効果は非常に簡単です。</font><font style="vertical-align: inherit;">ニュートラルな色調補正、わずかなケラレ、被写界深度があります。</font><font style="vertical-align: inherit;">これらのエフェクトを自由に試して、結果の外観を変更したい場合は、新しいエフェクトを追加してください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed7/ff2/aff/ed7ff2aff2e76a340c562e1f8090244e.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーン内の任意の六角形フィールドを選択すると、表示されます。</font><font style="vertical-align: inherit;">彼はすでに資料を割り当てられていること。</font><font style="vertical-align: inherit;">それらはすべて同じシェーダーを使用しますが、異なるタイプのタイルは異なるスプライトを使用します。</font><font style="vertical-align: inherit;">上の画像の場合、タイルは後で風車になります。</font><font style="vertical-align: inherit;">私たちのプロジェクトは9種類のタイルを使用しており、そのマテリアルは「Assets / Materials」フォルダにあります </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、テクスチャがタイル化されます。</font><font style="vertical-align: inherit;">「Assets / Textures」フォルダには、各タイルのカラーテクスチャと、接尾辞「_Map」が付いた手描きバージョンが含まれています。</font><font style="vertical-align: inherit;">カラーテクスチャは、ケニーの六角形パックからのものです。</font></font><br>
<br>
<blockquote><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ケニーの資産</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サイト</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kenney.nl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には、プロジェクトで使用できる無料のアセットリスト（2D、3D、オーディオ）がたくさんあります。</font><font style="vertical-align: inherit;">それらのほとんどは、クリエイティブコモンズライセンスさえ持っています。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのテクスチャの手描きバージョンは、カラーテクスチャに対応します。これは、効果にとって重要です。戦争の霧の境界では、元のタイルに対してどのような変位もないはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このフォルダには、さらに2つのテクスチャがあります。</font><font style="vertical-align: inherit;">PerlinNoiseは、Perlinノイズのテクスチャです。</font></font><br>
<br>
<blockquote><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャージェネレーター</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーリンのノイズテクスチャを作成するために、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリスチャンペトリテクスチャジェネレータをオンラインで</font><font style="vertical-align: inherit;">使用し</font><font style="vertical-align: inherit;">ました。</font><font style="vertical-align: inherit;">他のノイズ値を試してみたい場合は、プロジェクトのテクスチャを新しいものに置き換えるだけです。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のテクスチャ（「MapBackground」）は、大きな空の表面の単調性に違反する戦争の霧の場所に使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テクスチャを扱ったので、シェーダーとスクリプトに移りましょう。 Assets / Shadersフォルダーには2つのシェーダーがあります。MaskComputeは、可視領域と非表示領域のマスクを生成するために使用される計算シェーダーです。タイルシェーダーは、タイルマテリアルに適用されるシェーダーです。計算シェーダーによって作成されたマスクテクスチャの値をサンプリングし、それに基づいてタイルテクスチャまたは戦争の霧をレンダリングします。次のセクションでは、シェーダーについてさらに詳しく見ていきます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assets / Scriptsにも2つのスクリプトがあります。シェーダーで何が起こるかを理解するには、C＃のロジックを理解することが重要です。それぞれを順番に見ていきましょう。 GridCellから始めましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスクリプトは、シーン内の各六角形のセルに添付されています。</font><font style="vertical-align: inherit;">これは、セルの表示を制御し、マウスを操作するときにセルの表示を切り替えるように設計されています。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    MaskRenderer.RegisterCell(<span class="hljs-keyword">this</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、各セルは、RegisterCell関数を呼び出すことにより、MaskRendererスクリプトのセルのリストにセルを追加します。</font><font style="vertical-align: inherit;">完成したゲームでは、このリストはインスペクターの助けを借りて単純に埋める必要がありますが、プロトタイプを作成するには、同様の機能があると非常に便利です。これにより、不要なアクションなしでマップのサイズを大きくすることができます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseDown</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    ToggleVisibility();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseEnter</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    ToggleVisibility();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デモを操作してセルの表示を切り替えられるようにしたいと考えています。</font><font style="vertical-align: inherit;">このため、各セルにはコライダーがあります。</font><font style="vertical-align: inherit;">OnMouseDown（）およびOnMouseEnter（）を使用して、画面上でマウスカーソルをドラッグし、途中ですべてのセルの表示を切り替えることができます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">AnimateVisibility</span>(<span class="hljs-params"><span class="hljs-keyword">float</span> targetVal</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">float</span> startingTime = Time.time;
    <span class="hljs-keyword">float</span> startingVal = Visibility;
    <span class="hljs-keyword">float</span> lerpVal = <span class="hljs-number">0.0f</span>;
    <span class="hljs-keyword">while</span>(lerpVal &lt; <span class="hljs-number">1.0f</span>)<font></font>
    {<font></font>
        lerpVal = (Time.time - startingTime) / <span class="hljs-number">1.0f</span>;<font></font>
        Visibility = Mathf.Lerp(startingVal, targetVal, lerpVal);<font></font>
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
    }<font></font>
    Visibility = targetVal;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコルチンを見てみましょう。</font><font style="vertical-align: inherit;">その中で使用されるパターンは、C＃スクリプトによって制御されるアニメーションの標準です。</font><font style="vertical-align: inherit;">Unityでアニメーションを準備して再生する代わりに独自の計算を行う利点は、いつでもアニメーションを一時停止できることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリプト「MaskRenderer.cs」を開きます。</font><font style="vertical-align: inherit;">計算シェーダーのロジックを制御するため、完全に理解することが重要です。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;GridCell&gt; cells;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterCell</span>(<span class="hljs-params">GridCell cell</span>)</span><font></font>
{<font></font>
        cells.Add(cell);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述のように、各セルは、マスクレンダラーが使用するセルのリストに追加されます。</font><font style="vertical-align: inherit;">後で、シェーダーに便利な変数のリストを含む計算バッファーを作成します。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">SerializeField, Range(64, 4096)</span>]
<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> TextureSize = <span class="hljs-number">1024</span>;<font></font>
<font></font>
[<span class="hljs-meta">SerializeField</span>]
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> MapSize = <span class="hljs-number">0</span>;<font></font>
<font></font>
[<span class="hljs-meta">SerializeField</span>]
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> Radius = <span class="hljs-number">1.0f</span>;<font></font>
<font></font>
[<span class="hljs-meta">SerializeField, Range(0.0f, 1.0f)</span>]
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> BlendDistance = <span class="hljs-number">0.8f</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エディターに開かれているいくつかの変数を以下に示します。エフェクトの主要なパラメータを設定します。 「TextureSize」は、作成されたマスクのテクスチャのサイズです。理想的には、2の累乗である必要があります。 MapSizeは、Unity単位の六角形の物理セルサイズです。後で、グリッドにマスクテクスチャを適用するためにこの数が必要になります。 「半径」は1つのセルの半径です。中心と角度の間の距離。現在計算されているテクセルが六角形のフィールド内にあるかどうかを判断する代わりに、フィールドを記述する円の中にあるかどうかを確認します。最後のパラメータはBlendDistanceで、可視領域の周囲の幅を定義します。これは、不可視領域とブレンドするために使用されます。セルの周囲の混合領域の内側の半径は、「半径」変数によって定義されます。外部-「Radius」+「BlendDistance」という値。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> RenderTexture maskTexture;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、計算シェーダーに書き込むテクスチャです。</font><font style="vertical-align: inherit;">レンダーテクスチャを使用する場合、他のUnity C＃オブジェクトと比較すると、非常に低レベルであると考えられる多くの側面があります。</font><font style="vertical-align: inherit;">他のオブジェクトとは異なり、ガベージコレクターはオブジェクトをクリアしません。そのため、他の情報のためにメモリを解放するには、不要になった後、Release（）を手動で呼び出す必要があります。</font></font><br>
<br>
<blockquote><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリレンダーテクスチャ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レンダーテクスチャデータはGPUメモリに保存されます。つまり、すべての操作がGPU側で実行された場合にのみ機能します。これは、私たちの場合と同様に（計算シェーダーで書き込み、タイルシェーダーで読み取ります）。</font><font style="vertical-align: inherit;">ただし、CPUメモリにコピーして戻すときに、フレームの計算時間のかなり大きなピークに気づくでしょう。</font></font></blockquote><br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> textureSizeId = Shader.PropertyToID(<span class="hljs-string">"_TextureSize"</span>);
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> cellCountId = Shader.PropertyToID(<span class="hljs-string">"_CellCount"</span>);
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> mapSizeId = Shader.PropertyToID(<span class="hljs-string">"_MapSize"</span>);<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> radiusId = Shader.PropertyToID(<span class="hljs-string">"_Radius"</span>);
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> blendId = Shader.PropertyToID(<span class="hljs-string">"_Blend"</span>);<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> maskTextureId = Shader.PropertyToID(<span class="hljs-string">"_Mask"</span>);<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> cellBufferId = Shader.PropertyToID(<span class="hljs-string">"_CellBuffer"</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このCスクリプトでは、かなりの数の変数を設定し、それらのほとんどはすべてのフレームで設定されます。</font><font style="vertical-align: inherit;">各呼び出しでの文字列比較を回避するために、プロパティIDを整数としてキャッシュします。</font><font style="vertical-align: inherit;">これは、C＃スクリプトでシェーダーを操作する場合は常に行う必要があります。</font><font style="vertical-align: inherit;">ここで、Unityエンジンが変数を設定できるように、各変数の名前はシェーダーと同じままにする必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CellBufferElement</span>
{</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> PositionX;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> PositionY;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Visibility;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> List&lt;CellBufferElement&gt; bufferElements;
<span class="hljs-keyword">private</span> ComputeBuffer buffer = null;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計算バッファーは、計算シェーダーのセル情報を解析するために使用されます。</font><font style="vertical-align: inherit;">各構造体の値に同じタイプを使用するため、将来的には、float3を使用して計算シェーダーの各セルのデータを指定できます。</font><font style="vertical-align: inherit;">後で、このバッファがどのように機能するかを確認します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    cells = <span class="hljs-keyword">new</span> List&lt;GridCell&gt;();<font></font>
<font></font>
    maskTexture = <span class="hljs-keyword">new</span> RenderTexture(TextureSize, TextureSize, <span class="hljs-number">0</span>, RenderTextureFormat.ARGB32)<font></font>
    {<font></font>
        enableRandomWrite = <span class="hljs-literal">true</span><font></font>
    };<font></font>
    maskTexture.Create();<font></font>
<font></font>
    computeShader.SetInt(textureSizeId, TextureSize);<font></font>
    computeShader.SetTexture(<span class="hljs-number">0</span>, maskTextureId, maskTexture);<font></font>
<font></font>
    Shader.SetGlobalTexture(maskTextureId, maskTexture);<font></font>
    Shader.SetGlobalFloat(mapSizeId, MapSize);<font></font>
<font></font>
    bufferElements = <span class="hljs-keyword">new</span> List&lt;CellBufferElement&gt;();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェーダーの基本的なパラメーターを設定し、テクスチャをレンダリングします。</font><font style="vertical-align: inherit;">注意：ここで使用されるテクスチャフォーマットはリソースの無駄な無駄であり、別のものに置き換えることができるという事実（マスク値のみが必要なため、1つのチャネルを持つフォーマットがあったはずです）にもかかわらず、任意の記録を有効にする必要があります。</font><font style="vertical-align: inherit;">計算シェーダーのテクスチャサイズとテクスチャ自体をグローバル変数として設定します。</font></font><br>
<br>
<blockquote><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバルシェーダー変数</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大規模なプロジェクトでは、グローバル変数を使用しないでください。</font><font style="vertical-align: inherit;">ただし、これらの変数は追加の設定なしで任意のシェーダーで使用できるため、プロトタイピングには非常に役立ちます。</font></font></blockquote><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    buffer?.Dispose();<font></font>
    maskTexture?.Release();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のように、メモリを個別に管理する必要がある低レベルのUnityオブジェクトがあります。</font><font style="vertical-align: inherit;">私たちの場合、これは計算バッファであり、テクスチャをレンダリングします。</font></font><br>
<br>
<pre><code class="cs hljs">bufferElements.Clear();
<span class="hljs-keyword">foreach</span> (GridCell cell <span class="hljs-keyword">in</span> cells)<font></font>
{<font></font>
    CellBufferElement element = <span class="hljs-keyword">new</span> CellBufferElement<font></font>
    {<font></font>
        PositionX = cell.transform.position.x,<font></font>
        PositionY = cell.transform.position.z,<font></font>
        Visibility = cell.Visibility<font></font>
    };<font></font>
<font></font>
    bufferElements.Add(element);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリプトの最後の部分はUpdate（）関数です。</font><font style="vertical-align: inherit;">まず、各セルの計算バッファー要素を作成し、要素のリストに追加します。</font><font style="vertical-align: inherit;">セルが表示されているかどうかに応じて表示値が変化するため、フレームごとに更新する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">if</span>(buffer == <span class="hljs-literal">null</span>)<font></font>
    buffer = <span class="hljs-keyword">new</span> ComputeBuffer(bufferElements.Count * <span class="hljs-number">3</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計算バッファーがない場合（これは最初のフレームでのみ発生します）、新しいバッファーを作成します。最初のコンストラクタパラメータは要素の総数です。私たちの場合、これは各セルの3つの要素を掛けたセルの数です。 2番目のパラメータは、各要素のサイズ（つまり、各要素のバイト数）です。最も簡単な方法は</font></font><code>sizeof</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、渡された型のサイズを返す</font><font style="vertical-align: inherit;">演算子</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用してサイズを決定</font><font style="vertical-align: inherit;">することです。</font></font><br>
<br>
<pre><code class="cs hljs">buffer.SetData(bufferElements);<font></font>
computeShader.SetBuffer(<span class="hljs-number">0</span>, cellBufferId, buffer);<font></font>
<font></font>
computeShader.SetInt(cellCountId, bufferElements.Count);<font></font>
computeShader.SetFloat(radiusId, Radius / MapSize);<font></font>
computeShader.SetFloat(blendId, BlendDistance / MapSize);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この部分はそれ自体で理解できます-計算シェーダーで必要になるすべての変数の値を設定するだけです。</font><font style="vertical-align: inherit;">ここで言及する価値のある2つの側面があります。</font><font style="vertical-align: inherit;">まず、SetBuffer（）関数に値0を渡します。これは、バッファーを設定するコンピューティングカーネルのインデックスを示します。</font><font style="vertical-align: inherit;">1つしかないため、インデックスは0です。2番目に、半径と混合距離をマップの物理的なサイズで割ります。</font><font style="vertical-align: inherit;">すべての長さが同じスケールであることを確認する必要があります。</font><font style="vertical-align: inherit;">テクスチャを操作する場合、最も単純なスケールはUV [0; 1]スケールです。</font></font><br>
<br>
<pre><code class="cs hljs">computeShader.Dispatch(<span class="hljs-number">0</span>, Mathf.CeilToInt(TextureSize / <span class="hljs-number">8.0f</span>), Mathf.CeilToInt(TextureSize / <span class="hljs-number">8.0f</span>), <span class="hljs-number">1</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスパッチ機能は、計算カーネル自体によって実行されます。</font><font style="vertical-align: inherit;">最初のパラメーターもカーネルインデックスで、この場合は0です。他の3つのパラメーターは、x、y、z方向のスレッドグループの数です。</font><font style="vertical-align: inherit;">おそらく混乱しているので、GPUでのシェーダーの実行方法について少し説明しましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPUは、異なるデータに対して同じ命令を並列実行するように設計されています。たとえば、頂点シェーダーに関数「x + = 1」がある場合、頂点のセットのxに1を並列に追加します。データは頂点である必要はなく、ピクセル、または計算シェーダーの場合はほとんど何でもかまいません。これらのグループのサイズは、計算シェーダーで設定できます。この例では、値を8x8x1に設定します。これは、テクスチャの8x8テクセルを同時にレンダリングする計算シェーダーと考えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、計算シェーダーをスケジュールする場合、レンダリングテクスチャ全体をカバーするためにx、y、z方向に実行する必要がある頻度を計算することが重要です。</font><font style="vertical-align: inherit;">2Dで作業するため、zを無視して、値1を割り当てます。xとy方向のストリームグループの数を計算し、テクスチャ解像度を8で除算します-各グループのサイズ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テクスチャのサイズが512 x 512の場合、計算コア（512/8）x（512/8）= 64 x 64 = 4096回実行する必要があります。</font><font style="vertical-align: inherit;">将来的には、より詳細に検討されるチュートリアルを公開する予定ですが、今のところ、このようなトピックへの簡単な紹介で十分です。</font><font style="vertical-align: inherit;">シェーダーを書き始めましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンピューティングマスクシェーダー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「Assets / Shaders / MaskCompute.compute」シェーダーを開くと、私が作成したワークピースが表示されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> kernel CSMain</span><font></font>
<font></font>
[<span class="hljs-meta">numthreads(8,8,1)</span>]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CSMain</span> (<span class="hljs-params">uint3 id : SV_DispatchThreadID</span>)</span><font></font>
{<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の行は、Unityに計算コアの名前を伝えます。 1つあるので、ここではすべてが単純です。 2行目は、Unityにスレッドグループのサイズを通知します。この例では、8x8x1です。前のセクションでスレッドグループの基本について説明しました。ここでの最後の要素はidパラメータで、これを関数に解析します。この変数には、現在作業中のスレッドのIDが3次元で格納されます。この場合、id.xyは、現在のストリームの値が計算されるピクセルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、C＃スクリプトにメイン変数を追加します。ここでは予期しないことは何もないはずです。半径と混合距離はすでにUVスケールで設定されていることに注意してください。</font></font><br>
<br>
<pre><code class="cs hljs">   <span class="hljs-keyword">int</span> _CellCount;
   <span class="hljs-keyword">int</span> _TextureSize;
   <span class="hljs-keyword">float</span> _MapSize;
   <span class="hljs-keyword">float</span> _Radius;
   <span class="hljs-keyword">float</span> _Blend;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのセルのデータを含む計算バッファー用の別の変数が必要です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バッファの各要素には3つの浮動小数点値が含まれていることを覚えていますか？</font><font style="vertical-align: inherit;">シェーダーでは、これらをfloat3で組み合わせることができます。これにより、バッファーでの作業が簡略化されます。</font></font><br>
<br>
<pre><code class="cs hljs">  StructuredBuffer&lt;float3&gt; _CellBuffer;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に必要な変数は、マスクのテクスチャです。</font><font style="vertical-align: inherit;">書き込みを行う必要があるため、型に対して読み取り/書き込みを有効にする必要があるため、これはRWTexture2Dです。</font><font style="vertical-align: inherit;">テクスチャの各ピクセルはfloat4型であるため、チャネルごとに1つの浮動小数点があります。</font></font><br>
<br>
<pre><code class="cs hljs"> RWTexture2D&lt;float4&gt; _Mask;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、計算関数自体を作成できます。</font><font style="vertical-align: inherit;">まず、現在のテクセルを0に設定します。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">numthreads(8,8,1)</span>]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CSMain</span> (<span class="hljs-params">uint3 id : SV_DispatchThreadID</span>)</span><font></font>
{<font></font>
   _Mask[id.xy] = float4(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのセルをループして、セルがテクセル間隔内にあるかどうか、およびセルが表示されているかどうかを判断する必要があります。</font><font style="vertical-align: inherit;">はいの場合は、マスクに値1を割り当て、そうでない場合は0のままにします。これを行うには、単純なループを使用できます。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">numthreads(8,8,1)</span>]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CSMain</span> (<span class="hljs-params">uint3 id : SV_DispatchThreadID</span>)</span><font></font>
{<font></font>
    _Mask[id.xy] = float4(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; _CellCount; i++)<font></font>
   {<font></font>
   <font></font>
   }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在のテクセルと各セルの間の距離を計算するには、両方の位置が同じ空間になければなりません。</font><font style="vertical-align: inherit;">上記では、値をUV空間に変換し始めたので、セルの中心を持つテクセル位置に対してこれを繰り返しましょう。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">numthreads(8,8,1)</span>]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CSMain</span> (<span class="hljs-params">uint3 id : SV_DispatchThreadID</span>)</span><font></font>
{<font></font>
    _Mask[id.xy] = float4(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; _CellCount; i++)<font></font>
    {<font></font>
        float2 UVPos = id.xy / (<span class="hljs-keyword">float</span>)_TextureSize;<font></font>
        float2 centerUVPos = float2(_CellBuffer[i].x, _CellBuffer[i].y) / _MapSize;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、長さ（）を使用してそれらの間の距離を計算できます。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">numthreads(8,8,1)</span>]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CSMain</span> (<span class="hljs-params">uint3 id : SV_DispatchThreadID</span>)</span><font></font>
{<font></font>
    _Mask[id.xy] = float4(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; _CellCount; i++)<font></font>
    {<font></font>
        float2 UVPos = id.xy / (<span class="hljs-keyword">float</span>)_TextureSize;<font></font>
        float2 centerUVPos = float2(_CellBuffer[i].x, _CellBuffer[i].y) / _MapSize;<font></font>
        <span class="hljs-keyword">float</span> UVDistance = length(UVPos - centerUVPos);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、半径が短いかどうかを計算するだけでよく、そうである場合は、マスク値を1に変更します。境界で滑らかな混合が必要なため、混合距離に応じて、smoothstepを使用できます。</font><font style="vertical-align: inherit;">マスク内の可視セルのみをレンダリングするには、この値にセルの可視性を掛ける必要があります。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">numthreads(8,8,1)</span>]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CSMain</span> (<span class="hljs-params">uint3 id : SV_DispatchThreadID</span>)</span><font></font>
{<font></font>
    _Mask[id.xy] = float4(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; _CellCount; i++)<font></font>
    {<font></font>
        float2 UVPos = id.xy / (<span class="hljs-keyword">float</span>)_TextureSize;<font></font>
        float2 centerUVPos = float2(_CellBuffer[i].x, _CellBuffer[i].y) / _MapSize;<font></font>
        <span class="hljs-keyword">float</span> UVDistance = length(UVPos - centerUVPos);<font></font>
<font></font>
        <span class="hljs-keyword">float</span> val = smoothstep(_Radius + _Blend, _Radius, UVDistance) * _CellBuffer[i].z;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数「UVDistanceは」「_radius + _Blend」よりも大きい場合、変数は以下「_radius」よりある場合、それは0を返し、それはそれらの間の1を返し、値がスムーズに0から1に補間されている次のようにSmoothstepは働く</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはする必要があり別の側面。</font><font style="vertical-align: inherit;">バッファ内のセルは特定の順序で並んでいないため、テクセルは表示されているセルの半径内にあり、マスク値は1になります。</font><font style="vertical-align: inherit;">しかし同時に、テクセルが次のセルの半径の内側にないため、マスクの値はサイクルの後半で0だけ変化する可能性があります。</font><font style="vertical-align: inherit;">これは、マスクの値が既存の値よりも大きい場合にのみ記録されるようにすることで修正できます。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">numthreads(8,8,1)</span>]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CSMain</span> (<span class="hljs-params">uint3 id : SV_DispatchThreadID</span>)</span><font></font>
{<font></font>
    _Mask[id.xy] = float4(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; _CellCount; i++)<font></font>
    {<font></font>
        float2 UVPos = id.xy / (<span class="hljs-keyword">float</span>)_TextureSize;<font></font>
        float2 centerUVPos = float2(_CellBuffer[i].x, _CellBuffer[i].y) / _MapSize;<font></font>
        <span class="hljs-keyword">float</span> UVDistance = length(UVPos - centerUVPos);<font></font>
<font></font>
        <span class="hljs-keyword">float</span> val = smoothstep(_Radius + _Blend, _Radius, UVDistance) * _CellBuffer[i].z;<font></font>
        val = max(_Mask[id.xy].r, val);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マスク値を割り当てた後、次に進むことができます。</font><font style="vertical-align: inherit;">簡単ですよね？</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">numthreads(8,8,1)</span>]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CSMain</span> (<span class="hljs-params">uint3 id : SV_DispatchThreadID</span>)</span><font></font>
{<font></font>
    _Mask[id.xy] = float4(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; _CellCount; i++)<font></font>
    {<font></font>
        float2 UVPos = id.xy / (<span class="hljs-keyword">float</span>)_TextureSize;<font></font>
        float2 centerUVPos = float2(_CellBuffer[i].x, _CellBuffer[i].y) / _MapSize;<font></font>
        <span class="hljs-keyword">float</span> UVDistance = length(UVPos - centerUVPos);<font></font>
<font></font>
        <span class="hljs-keyword">float</span> val = smoothstep(_Radius + _Blend, _Radius, UVDistance) * _CellBuffer[i].z;<font></font>
        val = max(_Mask[id.xy].r, val);<font></font>
<font></font>
        _Mask[id.xy] = float4(val, val, val, <span class="hljs-number">1</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「Assets / Shaders / TileShader.shader」を開き、少し変更してマスクを表示しましょう。このシェーダーはテンプレートサーフェイスシェーダーであり、特別なことは何もありません。単純なサーフェスシェーダーの構造については、前</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のDawnのGears Hammer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チュートリアルで詳しく説明しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">struct</span> Input<font></font>
{<font></font>
    float3 worldPos;<font></font>
};<font></font>
<font></font>
  <span class="hljs-keyword">float</span> _MapSize;<font></font>
  sampler2D _Mask;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span> (<span class="hljs-params">Input IN, inout SurfaceOutputStandard o</span>)</span><font></font>
{<font></font>
    o.Albedo = tex2D(_Mask, IN.worldPos.xz / _MapSize).rgb;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グリッドにマスクテクスチャを適用するには、ワールド空間での頂点の位置が必要です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーフェスシェーダーでは、「worldPos」変数を入力構造体に追加することで取得できます。</font><font style="vertical-align: inherit;">また、変数「_MapSize」とテクスチャ「_Mask」も必要です。これは、ワールド内の位置をスケーリングし、計算された座標でテクスチャをサンプリングするためです。</font><font style="vertical-align: inherit;">グローバルシェーダー変数をどのように使用したか覚えていますか？</font><font style="vertical-align: inherit;">それらの値は、C＃のスクリプトによって自動的に設定されます。</font><font style="vertical-align: inherit;">これで、テクスチャをサンプリングして、出力構造体サーフェスのアルベドカラーにマスクカラーを割り当てることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェーダーを変更することで、再生モードを開始し、グリッドをクリックして、マスクがその値をどのように変更するかを確認できます。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お使いのブラウザはHTML5ビデオをサポートしていません。</font></font><source src="https://lexdev.net/images/case_studies/civilization_fogofwar/MaskRendering.mp4" type="video/mp4"></video></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マスクを理解したら、タイルシェーダーに進むことができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">六角形タイルシェーダー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、シェーダーにいくつかのプロパティを追加します。</font><font style="vertical-align: inherit;">それぞれが何をするか見てみましょう。</font></font><br>
<br>
<pre><code class="cs hljs">Properties<font></font>
{<font></font>
    [<span class="hljs-meta">NoScaleOffset</span>] _MainTex(<span class="hljs-string">"Color Texture"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span> {}<font></font>
    [<span class="hljs-meta">NoScaleOffset</span>]_MapTex(<span class="hljs-string">"Map Texture"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span> {}<font></font>
<font></font>
    [<span class="hljs-meta">NoScaleOffset</span>]_Noise(<span class="hljs-string">"Noise"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"black"</span> {}<font></font>
<font></font>
    _Cutoff(<span class="hljs-string">"Map Cutoff"</span>, <span class="hljs-keyword">float</span>) = <span class="hljs-number">0.4</span><font></font>
<font></font>
    _MapColor(<span class="hljs-string">"Map Color"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<font></font>
    _MapEdgeColor(<span class="hljs-string">"Map Edge Color"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<font></font>
<font></font>
    [<span class="hljs-meta">NoScaleOffset</span>]_MapBackground(<span class="hljs-string">"Map Background Texture"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span> {}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「_MainTex」はタイルのカラー画像を含むテクスチャ、「_ MapTex」はその手描きバージョンです。 「_Noise」は、戦争の霧の境界に使用するPerlinノイズテクスチャです。値「_Cutoff」は、カラータイルから戦争の霧に切り替えるマスクの値を定義します。この移行を急にしたいと考えています。 「_MapColor」は戦争の霧の地図の基本色で、通常は薄茶色です。 「_MapEdgeColor」は境界に影響を与える色です。最後に、「_ MapBackground」は透明度の高い背景テクスチャであり、多様性を高めるために戦争の霧の霧の上に配置します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「_MainTex」と「_MapTex」をサンプリングするには、UV座標が必要です。入手できる着信する構造体に接頭辞「uv」が付いたfloat2変数を追加します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">struct</span> Input<font></font>
{<font></font>
    float3 worldPos;<font></font>
    float2 uv_MainTex;<font></font>
    float2 uv_MapTex;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロパティはインスペクターで変数を表示するために使用されるUnity構成体であるため、CGシェーダーコードを含むファイルの部分に同じ名前の変数を追加する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">float</span> _MapSize;<font></font>
sampler2D _Mask;<font></font>
<font></font>
  sampler2D _MainTex;<font></font>
  sampler2D _MapTex;<font></font>
<font></font>
  sampler2D _Noise;<font></font>
<font></font>
  <span class="hljs-keyword">float</span> _Cutoff;<font></font>
<font></font>
  float4 _MapColor;<font></font>
  float4 _MapEdgeColor;<font></font>
  sampler2D _MapBackground;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、表面関数自体の作業を開始できます。</font><font style="vertical-align: inherit;">まず、2つのテクスチャタイルをサンプリングします。</font><font style="vertical-align: inherit;">これを行っている間、マスク値を別の変数に保存しましょう。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span> (<span class="hljs-params">Input IN, inout SurfaceOutputStandard o</span>)</span><font></font>
{<font></font>
    float4 maskVal = tex2D(_Mask, IN.worldPos.xz / _MapSize);<font></font>
    float4 tile = tex2D(_MainTex, IN.uv_MainTex);<font></font>
    float4 tileMap = tex2D(_MapTex, IN.uv_MapTex);<font></font>
<font></font>
    o.Albedo = mask.rgb;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、マップの背景テクスチャとノイズテクスチャをサンプリングする必要があります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span> (<span class="hljs-params">Input IN, inout SurfaceOutputStandard o</span>)</span><font></font>
{<font></font>
    float4 maskVal = tex2D(_Mask, IN.worldPos.xz / _MapSize);<font></font>
    float4 tile = tex2D(_MainTex, IN.uv_MainTex);<font></font>
    float4 tileMap = tex2D(_MapTex, IN.uv_MapTex);<font></font>
    float4 mapBackground = tex2D(_MapBackground, IN.worldPos.xz / _MapSize);<font></font>
    <span class="hljs-keyword">float</span> noise = tex2D(_Noise, IN.worldPos.xz / _MapSize).r;<font></font>
<font></font>
    o.Albedo = mask.rgb;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この形式で現在のマスクを使用すると、可視領域の周りの円の形でかなり単調な境界が得られますが、見栄えがよくありません。</font><font style="vertical-align: inherit;">境界のノイズを増やしたいため、マスク値からノイズ値を差し引くことができます。</font><font style="vertical-align: inherit;">将来の奇妙で不確実な動作を回避するために、結果を0から1までの間隔に制限します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span> (<span class="hljs-params">Input IN, inout SurfaceOutputStandard o</span>)</span><font></font>
{<font></font>
    float4 maskVal = tex2D(_Mask, IN.worldPos.xz / _MapSize);<font></font>
    float4 tile = tex2D(_MainTex, IN.uv_MainTex);<font></font>
    float4 tileMap = tex2D(_MapTex, IN.uv_MapTex);<font></font>
    float4 mapBackground = tex2D(_MapBackground, IN.worldPos.xz / _MapSize);<font></font>
    <span class="hljs-keyword">float</span> noise = tex2D(_Noise, IN.worldPos.xz / _MapSize).r;<font></font>
<font></font>
    <span class="hljs-keyword">float</span> maskNoise = clamp(maskVal - noise, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<font></font>
<font></font>
    o.Albedo = mask.rgb;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、この機能には問題があります。</font><font style="vertical-align: inherit;">ノイズ値は0から1の範囲内の任意の値にすることができるため、マスクを表示する場所でマスクから1を引くと、スポットが戦争の霧としてレンダリングされます。</font><font style="vertical-align: inherit;">これを修正するには、マスク値の逆数に等しい値をノイズに乗算します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span> (<span class="hljs-params">Input IN, inout SurfaceOutputStandard o</span>)</span><font></font>
{<font></font>
    float4 maskVal = tex2D(_Mask, IN.worldPos.xz / _MapSize);<font></font>
    float4 tile = tex2D(_MainTex, IN.uv_MainTex);<font></font>
    float4 tileMap = tex2D(_MapTex, IN.uv_MapTex);<font></font>
    float4 mapBackground = tex2D(_MapBackground, IN.worldPos.xz / _MapSize);<font></font>
    <span class="hljs-keyword">float</span> noise = tex2D(_Noise, IN.worldPos.xz / _MapSize).r;<font></font>
<font></font>
    <span class="hljs-keyword">float</span> maskNoise = clamp(maskVal - (<span class="hljs-number">1.0f</span> - maskVal) * noise, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<font></font>
<font></font>
    o.Albedo = mask.rgb;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実験中に、セルの半径に近づくとノイズの影響が少なくなるため、ノイズの影響が混合領域全体のように見えなくなることに気付きました。</font><font style="vertical-align: inherit;">指数関数を追加することで、混合領域に対するノイズの影響を増やすことができます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span> (<span class="hljs-params">Input IN, inout SurfaceOutputStandard o</span>)</span><font></font>
{<font></font>
    float4 maskVal = tex2D(_Mask, IN.worldPos.xz / _MapSize);<font></font>
    float4 tile = tex2D(_MainTex, IN.uv_MainTex);<font></font>
    float4 tileMap = tex2D(_MapTex, IN.uv_MapTex);<font></font>
    float4 mapBackground = tex2D(_MapBackground, IN.worldPos.xz / _MapSize);<font></font>
    <span class="hljs-keyword">float</span> noise = tex2D(_Noise, IN.worldPos.xz / _MapSize).r;<font></font>
<font></font>
    <span class="hljs-keyword">float</span> maskNoise = clamp(maskVal - pow(<span class="hljs-number">1.0f</span> - maskVal, <span class="hljs-number">0.01f</span>) * noise, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<font></font>
<font></font>
    o.Albedo = mask.rgb;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、適応されたノイズ値が指定された値 "_Cutoff"より小さいかどうかを確認できます。小さい場合は、戦争の霧をレンダリングします。</font><font style="vertical-align: inherit;">戦争の霧の外観は、「_ MapColor」、手描きのタイルと背景テクスチャの組み合わせです。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span> (<span class="hljs-params">Input IN, inout SurfaceOutputStandard o</span>)</span><font></font>
{<font></font>
    float4 maskVal = tex2D(_Mask, IN.worldPos.xz / _MapSize);<font></font>
    float4 tile = tex2D(_MainTex, IN.uv_MainTex);<font></font>
    float4 tileMap = tex2D(_MapTex, IN.uv_MapTex);<font></font>
    float4 mapBackground = tex2D(_MapBackground, IN.worldPos.xz / _MapSize);<font></font>
    <span class="hljs-keyword">float</span> noise = tex2D(_Noise, IN.worldPos.xz / _MapSize).r;<font></font>
<font></font>
    <span class="hljs-keyword">float</span> maskNoise = clamp(maskVal - pow(<span class="hljs-number">1.0f</span> - maskVal, <span class="hljs-number">0.01f</span>) * noise, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<font></font>
                                <font></font>
    <span class="hljs-keyword">if</span>(maskNoise &lt; _Cutoff)<font></font>
        tile = _MapColor * tileMap * mapBackground;<font></font>
<font></font>
    o.Albedo = tile.rgb;<font></font>
}</code></pre><br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お使いのブラウザはHTML5ビデオをサポートしていません。</font></font><source src="https://lexdev.net/images/case_studies/civilization_fogofwar/MapWithoutEdge.mp4" type="video/mp4"></video></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
境界線をより暗い色にしたいので</font></font><code>lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、適応したマスク値に応じて、</font><font style="vertical-align: inherit;">戦争の霧の色に単純な関数を追加でき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span> (<span class="hljs-params">Input IN, inout SurfaceOutputStandard o</span>)</span><font></font>
{<font></font>
    float4 maskVal = tex2D(_Mask, IN.worldPos.xz / _MapSize);<font></font>
    float4 tile = tex2D(_MainTex, IN.uv_MainTex);<font></font>
    float4 tileMap = tex2D(_MapTex, IN.uv_MapTex);<font></font>
    float4 mapBackground = tex2D(_MapBackground, IN.worldPos.xz / _MapSize);<font></font>
    <span class="hljs-keyword">float</span> noise = tex2D(_Noise, IN.worldPos.xz / _MapSize).r;<font></font>
<font></font>
    <span class="hljs-keyword">float</span> maskNoise = clamp(maskVal - pow(<span class="hljs-number">1.0f</span> - maskVal, <span class="hljs-number">0.01f</span>) * noise, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<font></font>
                                <font></font>
    <span class="hljs-keyword">if</span>(maskNoise &lt; _Cutoff)<font></font>
        tile = lerp(_MapColor * tileMap * mapBackground, _MapEdgeColor, maskNoise / _Cutoff);<font></font>
<font></font>
    o.Albedo = tile.rgb;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、コードは終わりました！</font><font style="vertical-align: inherit;">次のセクションでは、材料パラメータについて簡単に説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕上げ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのマテリアルは同じ構造で、カラーテクスチャとマップのみが異なります。</font><font style="vertical-align: inherit;">私の例では、カットオフ値0.3を使用しています。私の場合のマップの色は＃BCA76Eで、境界線の色は＃574A36です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d4/ae1/41f/8d4ae141f19fb93c0a5945c0f197d078.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マップを変更しなかった場合、サイズは26になるはずです。半径は1.0、混合距離は0.8を使用します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/0d8/4d1/02b0d84d10d940cffca32e136baf015f.jpg"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">できた！</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このチュートリアルは前のチュートリアルよりも短くなっています。</font><font style="vertical-align: inherit;">ただし、彼との作業はお楽しみください。</font><font style="vertical-align: inherit;">作業中に問題が発生した場合は、プロジェクトの完成版を確認してください。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成したプロジェクト</font></font></a><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お使いのブラウザはHTML5ビデオをサポートしていません。</font></font><source src="https://lexdev.net/images/case_studies/civilization_fogofwar/Final.mp4" type="video/mp4"></video></div></div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja505336/index.html">方法：マネまたはモネ？ニューラルネットワークが応答する</a></li>
<li><a href="../ja505338/index.html">長期短期記憶を備えたリカレントニューラルネットワークを使用した時系列の間隔予測...</a></li>
<li><a href="../ja505340/index.html">ウォルマートの従業員は、盗難防止AIが機能しないことを証明しようとします</a></li>
<li><a href="../ja505342/index.html">依存関係の注入と依存関係の逆転の原則は同一ではありません</a></li>
<li><a href="../ja505344/index.html">SOCを起動するか、外部に接続しますか？</a></li>
<li><a href="../ja505348/index.html">PostgreSQLクエリプランを理解することはさらに便利です</a></li>
<li><a href="../ja505358/index.html">RX-Modulus：完全にモジュラーなコンピューターマウス</a></li>
<li><a href="../ja505362/index.html">Vite-Vueにバンドルなしで開発をリード</a></li>
<li><a href="../ja505368/index.html">ミロの最初の人事ストーリー：オーケストラ、ピープルチームの構造、エクセレンス＆ソリューションアプローチ</a></li>
<li><a href="../ja505370/index.html">オンラインストアプロモーションを開始する場所</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>