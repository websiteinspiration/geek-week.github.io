<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤺 👨🏿‍🤝‍👨🏽 👼🏼 À la question de l'apophénie, de la télégonie et du voyage dans le temps (et fonctionne avec _ au début) 📚 👩🏿‍💻 🌐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En 1958, le neuropsychologue allemand Klaus Konrad a inventé le terme «apophénie» (du latin apophène - exprimer le jugement, le rendre explicite; le t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>À la question de l'apophénie, de la télégonie et du voyage dans le temps (et fonctionne avec _ au début)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505926/"><blockquote><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En 1958, le neuropsychologue allemand Klaus Konrad a inventé le terme «apophénie» (du latin apophène - exprimer le jugement, le rendre explicite; le terme renvoie à des textes de révélations religieuses, où il signifie des connaissances acquises en dehors du processus de cognition), impliquant par là la propriété de la psyché, consistant dans la capacité voir les relations dans des faits ou des données sans signification ou aléatoires, et trouver un sens dans des coïncidences. L'illusion d'une communication significative. Notre cerveau recherche constamment des modèles, mais fait souvent des erreurs et il y a un désir irrationnel de voir des modèles là où ils n'existent pas. Un désir particulier d'obéir aux coïncidences et aux contingences. C'est ce qu'on appelle l'apophénie. En statistique mathématique, il s'agit d'une erreur type du premier type. </font></font></i><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nepryakhin N. «Je te manipule»</font></font></i></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi ai-je retenu ce terme, notamment sur une ressource informatique? </font><font style="vertical-align: inherit;">Parce que la recherche de relations entre des faits disparates lors du débogage du programme est l'un des principaux facteurs déterminant son succès. </font><font style="vertical-align: inherit;">Un certain nombre d'inexactitudes aléatoires dans le travail, dont chacune ne montre pas les raisons de son apparition et n'affecte pas le fonctionnement du programme dans son ensemble, peut sembler chaotique. </font><font style="vertical-align: inherit;">Cependant, si vous essayez de trouver une relation entre eux, vous pouvez immédiatement résoudre beaucoup de problèmes avec une seule ligne de code ... Ou assurez-vous que la relation n'est rien de plus qu'un jeu de l'esprit, un produit de l'imagination du développeur.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapitre 1. «Agent et coordinateur»</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout a commencé lors du développement d'un programme d'agent qui effectue un certain nombre de tâches sur un serveur distant, recevant une liste de tâches via un mécanisme client-serveur. L'agent a levé le serveur sur le port 34002, un coordinateur local connecté à celui-ci, ils ont vérifié l'autorisation de l'autre et si tout s'est bien passé, alors l'agent a effectué les actions requises et a fait rapport en haut. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tr/mz/kl/trmzklssjskomt-sxqhxfdpbihq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schéma simplifié du programme</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Une étape évidente de la part de l'agent a été de créer votre propre fork dans lequel exécuter n'importe quelle fonction de la famille exec afin de remplacer le processus par le programme en cours de lancement. Dans ce cas, l'agent a reçu le pid du processus, ce qui a permis d'attendre son achèvement ou de le terminer de force. Tout s'est bien passé, cependant, pour que le coordinateur reçoive un rapport sur le travail accompli, il a fallu rendre les conclusions de stdout et stderr.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce problème peut être résolu par plusieurs méthodes - passez le processus new (dup2) FD pour stdout et stderr, puis lisez-les dans le processus parent; rediriger stderr vers stdout et utiliser popen; remplacer les descripteurs stdout et stderr en tant que fichiers et les lire une fois terminé. Nous avons choisi cette dernière méthode, car la lecture par la première méthode nécessitait du code et une synchronisation supplémentaires (et si vous ne le lisez pas en continu, après avoir atteint 2 Mo, l'enregistrement s'arrêtera lorsque le tampon du tuyau sera épuisé), et par la seconde, nous avons perdu la distinction entre stdout et stderr. Par conséquent, la méthode la plus simple a été choisie - pour fermer stdout et stderr à un nouveau processus, puis ouvrir les fichiers via open où nous voulons remplacer notre sortie. Selon la documentation pour open, il utilise l'index FD disponible minimum, c'est pourquoi le code sera simple et élégant:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> pid = fork();
<span class="hljs-keyword">switch</span> (pid) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span> :
        <span class="hljs-keyword">return</span> BADFORK;
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> :<font></font>
        close(<span class="hljs-built_in">stdout</span>);<font></font>
        close(<span class="hljs-built_in">stderr</span>);<font></font>
        open(fileout, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        open(fileerr, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        execve(arguments[<span class="hljs-number">0</span>], arguments, environ);
        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);
    <span class="hljs-keyword">default</span> :
        <span class="hljs-keyword">return</span> pid;<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code simplifié ressemble à ceci (vérification des erreurs supprimée pour la lisibilité). </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code a été lancé, la sortie de la commande a été écrite avec succès dans le fichier, elle a été terminée et était prête à fonctionner sur les systèmes de «combat». </font><font style="vertical-align: inherit;">Ou pas? </font><font style="vertical-align: inherit;">Au stade des tests, un petit bug est apparu, "prouvant" la possibilité de voyager dans le temps (ou du moins la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">télégraphie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapitre 2. «Telegonia»</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La chose était la suivante: après la fin du programme, et également après la fin de l'agent lui-même, la ligne suivante a été trouvée dans le fichier qui devrait contenir la sortie du programme en cours de démarrage (vers laquelle nous redirigeons la sortie standard du programme enfant):</font></font><br>
<br>
<pre><code class="plaintext hljs">[2020-06-05 16:58:49]      :34002</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attends une minute! Mais ceci est une ligne de la sortie de l'agent lui-même - le processus parent qui a appelé fork ()! Non seulement cela, l'agent affiche cette ligne quelque temps après la fin du programme appelé! Comment tout le reste de la sortie de l'agent peut-il être écrit sur stdout, et l'une des lignes peut entrer dans un fichier, tout le travail de l'agent consiste à le lire une fois waitpid terminé? Peut-être qu'une erreur lors de la lecture d'un fichier donne une mémoire battue?</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _exec_readfile(struct frs_json * target, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * filename) {<font></font>
    FILE * fp;<font></font>
    <span class="hljs-keyword">char</span> linebuff[VEN_PIPE_READ_SIZE + <span class="hljs-number">1</span>] = { <span class="hljs-number">0</span> };<font></font>
    fp = fopen(filename, <span class="hljs-string">"r"</span>);
    <span class="hljs-keyword">if</span> (!fp)<font></font>
        frs_err(<span class="hljs-string">" \"%s\"    "</span>, filename);
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">while</span>(fgets(linebuff, VEN_PIPE_READ_SIZE, fp))<font></font>
            frs_json_string(target, <span class="hljs-literal">NULL</span>, bxi_strtrimr(linebuff));<font></font>
    }<font></font>
    fclose(fp);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il semble que rien ne puisse battre la mémoire (frs_ * sont couverts par des tests). </font><font style="vertical-align: inherit;">Alors, comment ce fp affecte-t-il la sortie de l'agent, qui se produit quelques minutes après l'exécution de cette fonction? </font><font style="vertical-align: inherit;">Naturellement, une sorte de télégraphie - ils ont touché le fichier pour la lecture, et après 9 mois, nous recevons une ligne du "premier partenaire". </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9g/pv/c7/9gpvc7fjwrn55pggacmexfxbohm.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mon FD a été touché par un zèbre</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Valgrind n'a pas trouvé de problèmes, ce qui nous a quelque peu bouleversés. </font><font style="vertical-align: inherit;">Après tout, ses analyseurs omnipotents n'ont pas vu d'erreur d'accès à la mémoire, ils n'ont passé que beaucoup de temps en vain sur l'analyse. </font><font style="vertical-align: inherit;">Ou pas en vain? </font><font style="vertical-align: inherit;">S'il n'y a pas d'erreur d'accès à la mémoire, cela signifie une erreur logique. </font><font style="vertical-align: inherit;">Mais quelle erreur logique pourrait conduire à un tel effet?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapitre 3. «Deux serveurs»</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant ce temps, un deuxième bug a été trouvé. </font><font style="vertical-align: inherit;">Lors du lancement sous le débogage de QtCreator (nous l'utilisons comme environnement de développement, le projet C lui-même) a réussi tous les processus liés au programme et ce bug n'est pas apparu. </font><font style="vertical-align: inherit;">Cependant, cela valait la peine d'essayer de démarrer le programme directement, puis de le terminer (par des méthodes légales), car il a cessé de démarrer une deuxième fois.</font></font><br>
<br>
<pre><code class="plaintext hljs">^C[2020-06-05 16:58:46]    "Interrupt",   <font></font>
[2020-06-05 16:58:49]      :34002<font></font>
[2020-06-05 16:58:49]      :34002<font></font>
[2020-06-05 16:58:49]      :34002<font></font>
[2020-06-05 16:58:49]     <font></font>
[2020-06-05 16:58:50]      </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il était juste de penser à de petits gremlins qui détruisent le mécanisme du programme de l'intérieur, brisant une partie du programme, puis l'autre. </font><font style="vertical-align: inherit;">Mais le flair du programmeur suggérait qu'il y avait une relation entre ces bugs. </font><font style="vertical-align: inherit;">Laquelle? </font><font style="vertical-align: inherit;">Qui sait, mais c'est pourquoi ce n'est pas pour rien! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trouver la cause de l'échec du lancement s'est avéré facile. </font><font style="vertical-align: inherit;">Il suffisait de regarder les journaux système du programme, dans lesquels il définissait clairement et clairement la raison:</font></font><br>
<br>
<pre><code class="plaintext hljs">[2020-06-06 14:40:12] frs_socket_bind  :34002   ("Address already in use" (98))<font></font>
[2020-06-06 14:40:12]      :34002<font></font>
[2020-06-06 14:40:12] ven_server_start     </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment est-il déjà lancé? </font><font style="vertical-align: inherit;">Qui a lancé? </font><font style="vertical-align: inherit;">Vous avez terminé il y a une minute!</font></font><br>
<br>
<pre><code class="plaintext hljs">$ ps aux | grep vento<font></font>
alex     14144  0.0  0.0 156780  7212 pts/0    Sl+  14:39   0:00 ./vento</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vraiment lancé. </font><font style="vertical-align: inherit;">Mais peut-être juste un accident?</font></font><br>
<br>
<pre><code class="plaintext hljs">kill -9 14144</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et encore une fois, le programme démarre, mais après la fin du programme, le processus propriétaire du port 34002 reste:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
vento     14144 alex    3u  IPv4 12275384      0t0  TCP *:34002 (LISTEN)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et qui finit alors? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérez la sortie de lsof -i lors de l'exécution. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous lançons:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
vento     151640 alex    3u  IPv4 12275384      0t0  TCP *:34002 (LISTEN)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, un socket, un serveur </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, un Reich</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
_Postman  25078 alex  104u  IPv4 12885232      0t0  TCP localhost:46154-&gt;localhost:34002 (ESTABLISHED)<font></font>
vento     27468 alex    3u  IPv4 12890254      0t0  TCP *:34002 (LISTEN)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, le client est connecté et définit une commande ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais qu'est-ce que c'est?</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
_Postman  25078 alex  104u  IPv4 12885232      0t0  TCP localhost:46154-&gt;localhost:34002 (ESTABLISHED)<font></font>
vento     27468 alex    3u  IPv4 12890254      0t0  TCP *:34002 (LISTEN)<font></font>
vento     27506 alex    3u  IPv4 12890254      0t0  TCP *:34002 (LISTEN)<font></font>
vento     27506 alex    4u  IPv4 12890329      0t0  TCP localhost:34002-&gt;localhost:46154 (ESTABLISHED)</code></pre><br>
<img src="https://habrastorage.org/webt/wp/wq/62/wpwq62hwasqdflzz9bxomgjvebq.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fait amusant # 197766: tôt ou tard, une référence à Star Wars devrait apparaître</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Deux ports de serveur? </font><font style="vertical-align: inherit;">Malgré le fait que notre serveur n'utilise pas l'indicateur REUSEPORT.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapitre 4. «CLOEXEC»</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hmm ... Peut-être que le drapeau CLOEXEC manque dans l'implémentation du serveur? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinons de plus près le drapeau:</font></font><br>
<br>
<pre><code class="plaintext hljs">$man fork<font></font>
       *  The child process is created  with  a  single  thread—the  one  that<font></font>
          called  fork().   The  entire virtual address space of the parent is<font></font>
          replicated in the child, including the states of mutexes,  condition<font></font>
          variables,  and other pthreads objects; the use of pthread_atfork(3)<font></font>
          may be helpful for dealing with problems that this can cause.<font></font>
<font></font>
       *  The child inherits copies of the parent's set of open file  descrip‐<font></font>
          tors.   Each  file  descriptor  in the child refers to the same open<font></font>
          file description (see open(2)) as the corresponding file  descriptor<font></font>
          in  the parent.  This means that the two file descriptors share open<font></font>
          file status flags, file offset,  and  signal-driven  I/O  attributes<font></font>
          (see the description of F_SETOWN and F_SETSIG in fcntl(2)).<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'appel de la fonction fork () créera une copie du thread actuel du processus et créera une copie de chaque descripteur de processus ouvert (et puisque sur les systèmes UNIX [-like] "tout est un fichier", alors les descripteurs de réseau seront inclinés avec les descripteurs de fichiers)</font></font><br>
<br>
<pre><code class="plaintext hljs">$man exec<font></font>
       The exec() family of functions replaces the current process image with a new process image.  The functions described in<font></font>
       this manual page are front-ends for execve(2).  (See the manual page  for  execve(2)  for  further  details  about  the<font></font>
       replacement of the current process image.)</code></pre><br>
<pre><code class="plaintext hljs">$man execve<font></font>
       *  By  default,  file  descriptors  remain open across an execve().  File descriptors that are marked close-on-exec are<font></font>
          closed; see the description of FD_CLOEXEC in fcntl(2).  (If a file descriptor is closed, this will cause the release<font></font>
          of  all record locks obtained on the underlying file by this process.  See fcntl(2) for details.)  POSIX.1 says that<font></font>
          if file descriptors 0, 1, and 2 would otherwise be closed after a successful execve(), and the  process  would  gain<font></font>
          privilege because the set-user-ID or set-group_ID mode bit was set on the executed file, then the system may open an<font></font>
          unspecified file for each of these file descriptors.  As a general principle, no portable  program,  whether  privi‐<font></font>
          leged or not, can assume that these three file descriptors will remain closed across an execve().</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous ne voulons pas que le processus appelé reçoive une copie du descripteur, nous devons lui attribuer l'indicateur FD_CLOEXEC / SOCK_CLOEXEC. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En général, il serait logique si elle était marquée avec des </font><font style="vertical-align: inherit;">balises que vous souhaitez copier, afin d'éviter les </font><font style="vertical-align: inherit;">fuites dans les </font><font style="vertical-align: inherit;">fichiers racine d'accès, mais le drapeau est </font><font style="vertical-align: inherit;">apparu dans Posix-2001, alors maintenant il est notre héritage, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">controversé</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br>
<pre><code class="cpp hljs">server-&gt;socket = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC, <span class="hljs-number">0</span>);</code></pre><br>
<pre><code class="cpp hljs">fcntl(client, F_SETFD, FD_CLOEXEC);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, non, nos drapeaux sont définis comme ils le devraient. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que se passe-t-il alors? </font><font style="vertical-align: inherit;">Le noyau ignore-t-il l'indicateur? </font><font style="vertical-align: inherit;">Quelqu'un le vide? </font><font style="vertical-align: inherit;">Et surtout, pourquoi, une fois l'application terminée, le processus occupant le port reste dans le système? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons de fermer le serveur principal et de nous connecter au processus restant à l'aide de gdb:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ sudo gdb -p 27506<font></font>
GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git<font></font>
[...]<font></font>
Reading symbols from /lib/x86_64-linux-gnu/libgcc_s.so.1...(no debugging symbols found)...done.<font></font>
0x00007f503d50c9f3 in futex_wait_cancelable (private=[optimized out], expected=0, futex_word=0x55f485d383b8)<font></font>
    at ../sysdeps/unix/sysv/linux/futex-internal.h:88<font></font>
88	../sysdeps/unix/sysv/linux/futex-internal.h:     .<font></font>
(gdb) bt<font></font>
#0  0x00007f503d50c9f3 in futex_wait_cancelable (private=[optimized out], expected=0, futex_word=0x55f485d383b8)<font></font>
    at ../sysdeps/unix/sysv/linux/futex-internal.h:88<font></font>
#1  __pthread_cond_wait_common (abstime=0x0, mutex=0x55f485d38368, cond=0x55f485d38390) at pthread_cond_wait.c:502<font></font>
#2  __pthread_cond_wait (cond=0x55f485d38390, mutex=0x55f485d38368) at pthread_cond_wait.c:655<font></font>
#3  0x00007f503d948097 in _frs_signal_wait (signal=0x55f485d38340, filename=0x7f503d7315c8 "fen_server.c", fileline=298)<font></font>
    at ./projects/shared/libforseti/code/thread/frs_signal.c:250<font></font>
#4  0x00007f503d728044 in _server_wait (server=0x55f485d38270) at ./projects/shared/libfenrir/code/server/fen_server.c:298<font></font>
#5  0x00007f503d72822d in fen_server_free (server=0x55f485d38270) at ./projects/shared/libfenrir/code/server/fen_server.c:351</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stop stop stop, qu'est-ce que server_free? </font><font style="vertical-align: inherit;">Avons-nous terminé le mauvais processus? </font><font style="vertical-align: inherit;">Après tout, voici le lancement de l'application écho! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou ne devrait-il pas en être ainsi?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapitre 5. «Un caractère»</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous envoyons l'écho de la chaîne, mais vous devez mettre le chemin complet de l'application dans exec, car nous ne l'exécutons pas dans l'environnement shell, contrairement au même système. </font><font style="vertical-align: inherit;">Passez à / bin / echo et notez que le problème a disparu. </font><font style="vertical-align: inherit;">Mais il s'avère que lorsque nous donnons une commande incorrecte du point de vue de l'exec, nous continuons à travailler dans le même processus et ne la remplaçons pas par une application en cours d'exécution, ce qui signifie que ...</font></font><br>
<br>
<pre><code class="cpp hljs">        execve(arguments[<span class="hljs-number">0</span>], arguments, environ);
        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien oui, la sortie est faite. </font><font style="vertical-align: inherit;">Mais comment cela arrête-t-il le serveur?</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/*! \brief   */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _free(<span class="hljs-keyword">void</span>) __attribute__((destructor));
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _free(<span class="hljs-keyword">void</span>) {<font></font>
    fen_server_free(g_server);<font></font>
    frs_inf(<span class="hljs-string">"   "</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, tout s'est mis en place. </font><font style="vertical-align: inherit;">Ces deux bogues étaient vraiment interconnectés, et maintenant vous pouvez même dire exactement comment: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/g0/sk/-s/g0sk-sf74ratdovfkkoqny7ongu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, il reste à corriger le système qui ne fonctionne pas correctement. </font><font style="vertical-align: inherit;">Et nous le ferons comme dans une blague sur le maître de télévision et un coup avec un marteau: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un symbole</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "_" au mot exit:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> pid = fork();
<span class="hljs-keyword">switch</span> (pid) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span> :
        <span class="hljs-keyword">return</span> BADFORK;
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> :<font></font>
        close(<span class="hljs-built_in">stdout</span>);<font></font>
        close(<span class="hljs-built_in">stderr</span>);<font></font>
        open(fileout, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        open(fileerr, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        execve(arguments[<span class="hljs-number">0</span>], arguments, environ);<font></font>
        _exit(EXIT_FAILURE);<font></font>
    <span class="hljs-keyword">default</span> :
        <span class="hljs-keyword">return</span> pid;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qu'est ce qu'il se passe maintenant? </font><font style="vertical-align: inherit;">Rien de spécial, sauf que maintenant le processus de fin se terminera sans appeler les fonctions enregistrées via atexit. </font><font style="vertical-align: inherit;">Sur les anciennes implémentations de la glibc, ce sera un appel à l'appel système _exit; sur les plus récentes, exit_group sera appelé pour terminer tous les threads de programme plus correctement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, les deux bugs ont été vaincus, et vous avez dit "apofenia", "vous vous demandez seulement", "il n'y a pas de connexion". </font><font style="vertical-align: inherit;">Je vais </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">déplacer la</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> boîte sur l'étagère, sinon l'humanité ne volera plus dans l'espace.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr505898/index.html">Claude Shannon: valet de tous les métiers, farceur et père de la théorie de l'information</a></li>
<li><a href="../fr505900/index.html">Dépendances personnelles: pleine grandeur 40 mm, sans fil, pendant 72 heures pour 8000 roubles</a></li>
<li><a href="../fr505904/index.html">JUG Ru Group # 5 Semaine de diffusion en ligne</a></li>
<li><a href="../fr505906/index.html">Walkthrough Bandit de overthewire.org</a></li>
<li><a href="../fr505918/index.html">Interface téléphonique Sony - Publicité non désactivée</a></li>
<li><a href="../fr505928/index.html">Pourquoi la programmation fonctionnelle est si compliquée</a></li>
<li><a href="../fr505946/index.html">Stockage d'images à l'aide de Django / Django REST</a></li>
<li><a href="../fr505954/index.html">Alpine.js - événements et entrepôt de données mondial</a></li>
<li><a href="../hi486176/index.html">कॉर्पोरेट ईमेल पत्राचार मेमो</a></li>
<li><a href="../hi486178/index.html">FOSS News No. 1 - 27 जनवरी - 2 फरवरी, 2020 के लिए स्वतंत्र और मुक्त स्रोत समाचार की समीक्षा</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>