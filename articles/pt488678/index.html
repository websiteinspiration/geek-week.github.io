<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛠️ 🖖 👨🏿‍🍳 Grandes apetites para pequenos amortecedores no Node.js 👩🏻‍💻 👨‍🚒 💖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu já falei sobre o serviço de monitoramento de consultas ao PostgreSQL , para o qual implementamos um coletor de logs de servidores online, cuja prin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Grandes apetites para pequenos amortecedores no Node.js</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/488678/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu já falei sobre o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serviço de monitoramento de consultas ao PostgreSQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , para o qual implementamos um coletor de logs de servidores online, cuja principal tarefa é receber simultaneamente fluxos de logs de um grande número de hosts de uma só vez, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analisá-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> los rapidamente </font><b><font style="vertical-align: inherit;">em linhas</font></b><font style="vertical-align: inherit;"> , agrupá-los em pacotes de acordo com certas regras, processar e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escrever resultam em</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> armazenamento </font><b><font style="vertical-align: inherit;">PostgreSQL</font></b><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vk/dn/xj/vkdnxj5l8luuvnk31xevce4auae.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No nosso caso, estamos falando de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">várias centenas de servidores</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e milhões de solicitações e planos que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geram mais de 100 GB de logs por dia</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Portanto, não foi surpresa quando descobrimos que a maior parte dos recursos é gasta precisamente nessas duas operações: analisando linhas e gravando no banco de dados.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mergulhamos nas entranhas do criador de perfil e encontramos alguns recursos ao trabalhar com o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Buffer</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node.js., cujo conhecimento pode economizar muito tempo e recursos do servidor.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carga da CPU</font></font></h2><br>
<img src="https://habrastorage.org/webt/od/uv/lm/oduvlmuc8wmu5obyljyygjnc8vw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A maior parte do tempo do processador foi gasta processando o fluxo de logs de entrada, o que é compreensível. </font><font style="vertical-align: inherit;">Mas o que não ficou claro foi a intensidade de recursos do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"fatiamento"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> primitivo </font><b><font style="vertical-align: inherit;">do fluxo de entrada de blocos binários em linhas</font></b><font style="vertical-align: inherit;"> por </font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: O </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dk/v4/tb/dkv4tbigt2rwylskt8x_iqzcurc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
desenvolvedor atento notará imediatamente aqui um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ciclo de bytes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não tão eficiente </font><font style="vertical-align: inherit;">através do buffer de entrada. </font><font style="vertical-align: inherit;">Bem, como a linha pode ser “dividida” entre os blocos vizinhos, também existe um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“anexo de cauda” funcional que</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobrou do bloco processado anterior.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentando readline</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma rápida revisão das soluções disponíveis nos levou ao </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">módulo readline</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> regular </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">,</font></a><font style="vertical-align: inherit;"> exatamente com a funcionalidade necessária para dividir em linhas: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/px/0v/hepx0v5do7wgj9osz0cwyhuljvg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de implementado, o "fatiamento" da parte superior do criador de perfil foi mais profundo: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jc/5x/et/jc5xetsqi24hpgggyg0yss6ggww.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mas, como se viu, o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readline força a string para o UTF-8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> internamente </font><font style="vertical-align: inherit;">, o que é impossível. faça se a entrada de log (solicitação, plano, texto de erro) tiver uma codificação de origem diferente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, mesmo em um servidor PostgreSQL, vários bancos de dados podem estar ativos simultaneamente, cada um dos quais gera saída para um log de servidor comum exatamente </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em sua codificação original</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como resultado, os proprietários de bancos de dados no win-1251 (às vezes é conveniente usá-lo para economizar espaço em disco se um UNICODE multibyte "honesto" não for necessário) foram capazes de observar seus planos com aproximadamente os mesmos nomes "russos" de tabelas e índices:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mb/6w/ri/mb6wriic6gmbvaz0koz8vddn_gm.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modificando a bicicleta</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É um problema ... Ainda assim, você deve fazer o corte por conta própria, mas com otimizações como a verificação de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Buffer.indexOf()</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"bytes": </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ii/kf/h0/iikfh0v9mn2pyjd56eislxit69a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tudo parece estar bem, a carga no ciclo de teste não aumentou, os nomes do win1251 foram reparados, estamos lançando a batalha ... Ta-dam! </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O uso da CPU ultrapassa periodicamente o teto em 100%</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<br>
<img src="https://habrastorage.org/webt/0r/k_/3u/0rk_3ujn57ml6uf2qs5xiuztnto.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
como está? .. Acontece que é nossa culpa </font></font><code>Buffer.concat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pela qual “enfiamos a cauda” do bloco anterior: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/j6/nx/hw/j6nxhw_xyt8rhrz9z9dlfbaz7fo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mas só temos uma cola </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando uma linha passa por um bloco</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas não devem ser muitos - realmente, realmente? .. Bem, quase. Somente agora, às vezes, vêm </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"strings" de várias centenas de segmentos de 16 KB</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<img src="https://habrastorage.org/webt/iq/rk/54/iqrk54dnsrr9xhfgvawz5pptc90.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agradecemos aos colegas desenvolvedores que tiveram o cuidado de gerar isso. </font><font style="vertical-align: inherit;">Isso acontece "raramente, mas com precisão", portanto não foi possível ver com antecedência no circuito de teste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É claro que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">colar várias centenas de vezes no buffer por vários megabytes de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pequenos pedaços é um caminho direto para o abismo das realocações de memória com o consumo de recursos da CPU, que observamos. </font><font style="vertical-align: inherit;">Então, não vamos colar até a linha terminar completamente. </font><font style="vertical-align: inherit;">Apenas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">colocaremos as "peças" em uma matriz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> até a hora de deixar a linha inteira "fora": </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5i/d8/ol/5id8olet5wr0mxddkn4u3ieuwu0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
agora a carga retornou aos indicadores da linha de leitura.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consumo de memória</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muitas pessoas que escreveram em idiomas com alocação dinâmica de memória sabem que um dos mais desagradáveis ​​"assassinos de desempenho" é a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atividade em segundo plano do</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Garbage Collector (GC), que verifica os objetos criados na memória e exclui aqueles que são maiores. ninguém é necessário. </font><font style="vertical-align: inherit;">Esse problema também nos ultrapassou - em algum momento, começamos a perceber que a atividade do GC era de alguma maneira excessiva e deslocada. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hg/pp/ht/hgppht17ouvqyv9xdqv7wf4n5kq.png"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As "reviravoltas" tradicionais</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> realmente não ajudaram ... "Se tudo mais falhar, despeje!" </font><font style="vertical-align: inherit;">E a sabedoria popular não decepcionou - vimos uma </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuvem de buffer de 8360 bytes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com um tamanho total de 520MB ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s7/ct/km/s7ctkmzfmorz0qhbsaw1v3aorpw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E eles foram gerados dentro do CopyBinaryStream - a situação começou a se esclarecer ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CÓPIA ... DE STDIN COM BINÁRIO</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para reduzir a quantidade de tráfego transmitido ao banco de dados, usamos o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">formato binário COPY</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">De fato, para cada registro, você precisa enviar um buffer para o fluxo, consistindo em "partes" - o número de campos no registro (2 bytes) e, em seguida, a representação binária dos valores de cada coluna (4 bytes por tipo ID + dados). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como essa linha da tabela quase sempre tem um comprimento variável "resumido", alocar imediatamente um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buffer de um comprimento fixo não é uma opção</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; a realocação se houver falta de tamanho "consome" facilmente o desempenho; já foi mais alto. </font><font style="vertical-align: inherit;">Portanto, também vale a pena "colar de pedaços" usando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Buffer.concat()</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memorando</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, como temos muitas peças repetidas várias vezes (por exemplo, o número de campos nos registros da mesma tabela) - vamos apenas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lembrá-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> los </font><b><font style="vertical-align: inherit;">e, em seguida, pegar os prontos,</font></b><font style="vertical-align: inherit;"> gerados uma vez no primeiro acesso. </font><font style="vertical-align: inherit;">Com base no formato COPY, existem poucas opções - peças típicas têm 1, 2 ou 4 bytes de comprimento: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dx/32/c2/dx32c2pramljew4m2x2ztitewio.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E ... bam, chegou um ancinho! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5e/vd/mx/5evdmx_4gln9ccxajf2weqv2z4w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, sim, toda vez que você cria um buffer, uma parte de 8 KB de memória é alocada por padrão, para que </font><font style="vertical-align: inherit;">pequenos buffers </font><font style="vertical-align: inherit;">criados </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em uma linha</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> possam ser empilhados "ao lado de" na memória já alocada. </font><font style="vertical-align: inherit;">E nossa alocação funcionou “sob demanda” e acabou por não estar “próxima” - é por isso que cada um dos nossos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-2-4 bytes de buffer ocupa o cabeçalho de 8KB + fisicamente ocupado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - aqui estão eles, nossos 520MB!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memorando inteligente</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hmm ... Por que precisamos esperar até que este ou aquele buffer de 1/2 byte seja necessário? </font><font style="vertical-align: inherit;">Com 4 bytes é uma questão separada, mas algumas dessas opções diferentes para um total de 256 + 65536. Então, deixe o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nagenerimim sua </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linha de</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uma só vez</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Ao mesmo tempo, cortamos a condição para a existência de cada verificação - ela também funcionará mais rápido, pois a inicialização é realizada apenas no início do processo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fs/yq/ge/fsyqgetrrresipf9qmqpifnt-ku.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, além dos buffers de 1/2 byte, inicializamos imediatamente os valores mais em execução (menos 2 bytes e -1) para os de 4 bytes. </font><font style="vertical-align: inherit;">E - ajudou, apenas 10MB em vez de 520MB!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7l/7h/ot/7l7hotlahibczpu7nvmjsdxxo7a.png"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt488662/index.html">Extensões de navegador exigidas por todo desenvolvedor web</a></li>
<li><a href="../pt488664/index.html">Encontrando o Kit de Ferramentas Perfeito: Analisando Modelos de Projeto Python Populares</a></li>
<li><a href="../pt488666/index.html">10 Reagir componentes para todas as ocasiões</a></li>
<li><a href="../pt488668/index.html">Encadeamento de CI / CD e automação de Docker</a></li>
<li><a href="../pt488674/index.html">Infográfico com Excel e PowerPoint</a></li>
<li><a href="../pt488682/index.html">Como testar as habilidades de programação Python? Tarefas do Yandex</a></li>
<li><a href="../pt488686/index.html">Usando redes Flowmon para monitorar o desempenho de aplicativos e bancos de dados distribuídos</a></li>
<li><a href="../pt488690/index.html">Levenshtein menos reconhecimento de caracteres à distância</a></li>
<li><a href="../pt488692/index.html">Como migrar um processo grande do IBM BPM para Camunda e não parar o desenvolvimento de recursos</a></li>
<li><a href="../pt488696/index.html">Liderando as tendências</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>