<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏽 👨🏾‍🚒 🔎 Kubernetes Storage Patterns 👩‍👩‍👦‍👦 🚴 🤣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! 
 
 We remind you that we have released another extremely interesting and useful book on Kubernetes patterns. It all started with Brendan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kubernetes Storage Patterns</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/490180/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/webt/ku/xh/fw/kuxhfwyrk51o4xpq6d1km-gpfbg.png"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hello, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We remind you that we have released another extremely interesting and useful </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">book</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on Kubernetes patterns. </font><font style="vertical-align: inherit;">It all started with </font><font style="vertical-align: inherit;">Brendan Burns's </font><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patterns,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” and, by the way, work in this segment is in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">full swing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Today we invite you to read an article from the MinIO blog that summarizes the trends and specifics of data storage patterns in Kubernetes.</font></font><br>
<a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes fundamentally changed the traditional patterns of application development and deployment. </font><font style="vertical-align: inherit;">Now the team can take days to develop, test and deploy the application - in different environments, and all this within the Kubernetes clusters. </font><font style="vertical-align: inherit;">Such work with technology from previous generations usually took weeks, if not months.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Such acceleration was made possible thanks to the abstraction provided by Kubernetes - that is, due to the fact that Kubernetes itself interacts with low-level details of physical or virtual machines, allowing users to declare, among other parameters, the desired processor, the required memory, the number of container instances. As Kubernetes is supported by a huge community, and the scope of Kubernetes is constantly expanding, it leads by a wide margin among all container orchestration platforms. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As the use of Kubernetes expands, so does the confusion about the storage patterns used in it</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With general competition for a piece of Kubernetes pie (that is, for data storage), when it comes to talking about data storage, the signal is drowning in loud noise. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes embodies a modern model for developing, deploying, and managing applications. Such a modern model detaches data storage from computing. To fully understand this detachment in the context of Kubernetes, you also need to understand what stateful and stateless applications are, and how data storage is combined with this. This is where the REST API approach used by S3 has clear advantages over the POSIX / CSI approach that is typical of other solutions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article we will talk about storage patterns in Kubernetes and we will separately discuss the debate about state-safe and stateless applications, so that we can clearly understand the difference between them and why it is important. </font><font style="vertical-align: inherit;">Further in the text, we will consider applications and the patterns of data storage used in them in the light of best practices for working with containers and Kubernetes.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stateless Containers</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Containers are inherently lightweight and ephemeral. </font><font style="vertical-align: inherit;">They can be easily stopped, deleted or deployed on another node - all this takes a matter of seconds. </font><font style="vertical-align: inherit;">In a large container orchestration system, such operations occur all the time, and users do not even notice such changes. </font><font style="vertical-align: inherit;">However, movements are possible only if the container has no dependencies on the node on which it is located. </font><font style="vertical-align: inherit;">These containers are said to work </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">without state preservation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stateful Containers</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the container stores data on locally connected devices (or on a block device), then the data warehouse on which it is located will have to be moved to a new node along with the container itself - in case of failure. This is important, because otherwise the application running in the container will not be able to function correctly, since it needs to access data stored on local media. These containers are said to be </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stateful</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From a purely technical point of view, stateful containers can also be moved to other nodes. Typically, this is achieved using distributed file systems or block network storages attached to all nodes on which containers operate. Thus, containers gain access to volumes for persistent data storage, and information is stored on disks located throughout the network. I will call such a method a “ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">state-preserving container approach</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,” and in the rest of the article I will call it for the sake of uniformity.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y1/cs/6z/y1cs6zoudpecfzs6ww-aw8ocxyg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In a typical stateful container approach, all application pods are attached to one distributed file system — a kind of shared storage is obtained, where all application data is acquired. </font><font style="vertical-align: inherit;">While some variations are possible, this is a high-level approach. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's look at why the stateful container approach in the cloud-based world is antipattern.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud-Based Application Design</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Traditionally, applications used databases for structured storage of information and local disks or distributed file systems, where all unstructured or even semi-structured data was dumped. As the volume of unstructured data grew, the developers realized that POSIX was too talkative, associated with significant costs and, ultimately, interferes with the application when moving to a really large scale.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This mainly contributed to the emergence of a new standard for data storage, that is, cloud-based storages that work primarily on the basis of the REST API and free the application from the burdensome maintenance of the local data warehouse. In this case, the application actually enters the operation mode without saving the state (since the state is in the remote storage). Modern applications are being built from scratch already taking this factor into account. As a rule, any modern application that processes data of one kind or another (logs, metadata, blobs, etc.) is built on a cloud-oriented paradigm, where the state is transferred to a software system specially allocated for its storage.</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A stateful container approach makes this whole paradigm roll back exactly to where it started!</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
When using POSIX interfaces for storing data, applications work in the same way as if they maintained state, and because of this, depart from the most important postulates of cloud-based design, that is, from the ability to vary the size of application workflows depending on the incoming load, move to a new node as soon as the current node fails, and so on.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A closer look at this situation reveals that when choosing a data warehouse, we again and again face the dilemma “POSIX versus REST API”, BUT with additional aggravation of POSIX problems caused by the distributed nature of Kubernetes environments. In particular,</font></font><br>
<br>
<ul>
<li><b>POSIX </b>:  POSIX         ,     .     ,     . API   ,  , S3 API,    ,   ,   «»  .     ,       .        .</li>
<li><b> </b>:    ,     ,          . ,  ,            (    ),         ,     . -  POSIX       .   , S3 API       ,      ,  ,     .</li>
<li><b></b>:   POSIX     :          .      - .      ,   API,       ,   ,     ..</li>
<li><b></b>:       ,   .       ,    ,     ,      .  ,     ,      ,   .</li>
</ul><br>
<h4>   </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Whereas the container data storage interface (CSI) helped a lot with the distribution of the Kubernetes volume level, partially passing it to third-party data warehouse vendors, but also accidentally contributed to the conviction that the stateful container approach was the recommended method of data storage in Kubernetes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSI was developed as a standard for providing arbitrary block and file storage systems for legacy applications when working with Kubernetes. And, as was shown in this article, the only situation where a stateful container approach (and CSI in its current form) is appropriate is when the application itself is a legacy system in which it is impossible to add support for the object data storage API.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is important to understand that using CSI in its current form, that is, when mounting volumes when working with modern applications, we will encounter approximately the same problems as those encountered in systems where data storage is organized in the POSIX style.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Better approach</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, it is important to understand that most applications are inherently not tailored specifically to work with or without state preservation. </font><font style="vertical-align: inherit;">This behavior depends on the overall architecture of the system and on the specific options selected during design. </font><font style="vertical-align: inherit;">Let's talk a bit about stateful applications. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In principle, all application data can be divided into several broad types:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Log Data</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time stamp data</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaction data</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metadata</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Container images</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blob data (blobs)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All of these data types are very well supported on modern data storage platforms, and there are several cloud-based platforms adapted to deliver data in each of these specific formats. For example, transaction data and metadata may reside in a modern cloud-based database such as CockroachDB, YugaByte, etc. Container images or blob data can be stored in the docker registry based on MinIO. Time stamp data can be stored in a time series database, such as InfluxDB, etc. We will not go into details of each type of data and related applications, but the general idea is to avoid persistent data storage based on local disk mounting.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/us/gk/li/usgklihtry8ddkgmpkumtziiv3y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, it is often effective to provide a temporary caching layer, which serves as a kind of temporary file storage for applications, but applications should not depend on this level as a source of truth.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stateful Application Storage</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
While in most cases it is useful to keep applications stateless, those applications that are designed to store data - for example, databases, object stores, key and value stores - should keep state. </font><font style="vertical-align: inherit;">Let's see why these applications are deployed to Kubernetes. </font><font style="vertical-align: inherit;">Take MinIO as an example, but similar principles apply to any other large cloud-based storage systems.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cloud-centric applications are designed to maximize the use of the flexibility inherent in containers. This means that they make no assumptions about the environment in which they will be deployed. For example, MinIO uses an internal erasure coding mechanism, which provides the system with sufficient stability so that it remains operational even if half of the drives fail. MinIO also manages data integrity and security using its own server-side hashing and encryption.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For such cloud-based applications, local persistent volumes (PV) are most convenient as backup storage. </font><font style="vertical-align: inherit;">Local PV provides the ability to store raw data, while applications running on top of these PVs independently collect information to scale data and manage growing data requirements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This approach is much simpler and significantly better scalable compared to CSI-based PV, which bring their own levels of data management and redundancy to the system; </font><font style="vertical-align: inherit;">the fact is that these levels usually conflict with applications designed according to the principle of state preservation.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Confident Movement to Unpin Data from Computing</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article, we talked about how applications are reoriented to work without saving state, or, in other words, data storage is delimited from computing on them. In conclusion, we consider a few real-world examples of such a trend. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the renowned data analysis platform, has traditionally been used with stateful deployment and deployment to the HDFS file system. However, as Spark transitions to a cloud-based world, this platform is increasingly being used without state preservation using `s3a`. Spark uses s3a to transfer state to other systems, while Spark containers themselves work entirely without state preservation. Other large enterprise players in the field of big data analytics, in particular, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teradata</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Greenplum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> also go to work with the division of data storage and computing over them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Similar patterns can also be seen on other large analytical platforms, including Presto, Tensorflow to R, Jupyter. </font><font style="vertical-align: inherit;">Uploading state to remote cloud storage systems makes it much easier to manage and scale your application. </font><font style="vertical-align: inherit;">In addition, it helps portability of the application to a variety of environments.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en490164/index.html">Interview with software engineer Sony PlayStation Now. Internal Kitchen, Functional Teams, Core Division</a></li>
<li><a href="../en490168/index.html">Analysis of the quality of the chatbot in the IBM Watson Assistant</a></li>
<li><a href="../en490170/index.html">Project Manager in a vice. Why so and what to do about it</a></li>
<li><a href="../en490174/index.html">DNS lookup in Kubernetes</a></li>
<li><a href="../en490178/index.html">While everyone is heading west, I moved to Armenia</a></li>
<li><a href="../en490184/index.html">Alphabet has a second, secret group of quantum computer developers</a></li>
<li><a href="../en490186/index.html">What we made JET BI from. Architecture Business Intelligence System without lyric digressions</a></li>
<li><a href="../en490190/index.html">I'm going to search: host geo-positioning by IP address in the global Internet using the Binance crypto exchange as an example</a></li>
<li><a href="../en490194/index.html">Using RabbitMQ with MonsterMQ Part 4</a></li>
<li><a href="../en490196/index.html">[Flipper Zero] refuse Raspberry Pi, make our own board from scratch. Finding the right WiFi chip</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>