<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õÖÔ∏è ‚úãüèø ‚ô¶Ô∏è Weak heap sorting üå≤ üè≥Ô∏è‚Äçüåà ü§¶üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Of the entire zoo heaps, this structure is perhaps the most unusual. At the same time, the elegant simplicity of the algorithm is quite a match for it...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Weak heap sorting</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/499786/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><div style="text-align:center;"><img width="765" height="430" src="https://habrastorage.org/webt/hh/ve/rt/hhvertyrtwsbd99rbboihxxyjjk.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of the entire zoo heaps, this structure is perhaps the most unusual. </font><font style="vertical-align: inherit;">At the same time, the elegant simplicity of the algorithm is quite a match for its amazing eccentricity. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When sorting using a weak heap, there are always fewer comparisons and exchanges than using a regular heap. </font><font style="vertical-align: inherit;">So yes, a weak pile is stronger than an ordinary pile.</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" title="EDISON Software - web-development"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - web-development"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This article was written with the support of EDISON. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We are engaged in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creation of embedded software</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as well as the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">development of web applications and sites</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We love the theory of algorithms! </font><font style="vertical-align: inherit;">;-)</font></font></blockquote><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weak pile</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A regular heap is a sorting tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in which any parent is greater (or equal) than any of its descendants. </font><font style="vertical-align: inherit;">In a weak heap, this requirement is weakened - any parent is greater than (or equal to) any descendant only from its right subtree. </font><font style="vertical-align: inherit;">In the left subtree, the descendants can be both smaller and larger than the parent, there you are so lucky.</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="299" src="https://habrastorage.org/webt/by/f6/ef/byf6efzj8swlst2y_2dvb7onduu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This approach can significantly reduce the cost of maintaining the data set in a heap state. </font><font style="vertical-align: inherit;">After all, it is necessary to ensure the principle ‚Äúa descendant is no more than a parent‚Äù not for the whole structure, but only for half of it. </font><font style="vertical-align: inherit;">At the same time, a weak heap, not being a 100% sorting tree, sorts no worse than an ordinary heap, and in some ways even better. </font><font style="vertical-align: inherit;">Did half the battle - walk boldly! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the root of the heap, even a weak one, needs exactly the largest element, the root of the left subtree does not.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimizing the number of comparisons</font></font></h2><br>
<img align="left" width="215" height="199" src="https://habrastorage.org/webt/ng/cu/e1/ngcue1zei7olyudhfpge5blkcgu.jpeg"><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ronald D. Dutton, a specialist in algorithms and graph theory, presented us with a weak bunch in 1993. </font><font style="vertical-align: inherit;">A conceptually weak pile is more difficult to understand (but this difficulty is more likely not in complexity, but in extravagance, you have to break your consciousness patterns through the knee) than an ordinary pile, so it has not received much practical distribution. </font><font style="vertical-align: inherit;">However, when Dutton invented this structure, he not only wanted to practice abstract abstractions, but he pursued a completely pragmatic goal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a theoretical lower limit for estimating the minimum number of comparisons (in those sortings in which these comparisons are widely used): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">= </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / ln 2 + O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), where 1 / ln 2 = 1.4426 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In sorting by a weak heap, the number of comparisons is minimized and is close enough to the lower limit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This can be of practical importance if you need to arrange objects whose comparison is expensive, for example, if it comes to sorting long strings.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juggling descendants</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚ÄúLeft‚Äù and ‚Äúright‚Äù in a weak heap is a situational phenomenon. A subtree can be either a left or a right descendant for its parent node - moreover, this ‚Äúleft / right‚Äù relation for the subtree and the parent can repeatedly switch from one value to the opposite during the process. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To indicate for the parent who has his right son and who is his left daughter is not simple, but very simple. To do this, you need an additional bitmap (consisting of only 0/1 values) for those nodes that have descendants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recall how the index </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -th parent element, we define the indices of its left and right descendant in a conventional pile (indices of the array measured from zero): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Left descendant 2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Right descendant 2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In a weak heap, we have a cherry on the cake - a root that has only the right subtree, so we will adjust these formulas for the descendant indices by adding a reverse shift to 1 position: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Left descendant: 2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Right descendant: 2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And finally , needed additional bitmap (call it </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), wherein for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -th element noted was whether the exchange places between its left and right subtrees. If the value for an element is 0, then there was no exchange. If the value is 1, then the left and right children go in the opposite order. And the formulas in this case are as follows: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Left descendant: 2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Right descendant: 2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is how it looks. </font><font style="vertical-align: inherit;">Elements whose descendants are located ‚Äúvice versa‚Äù are highlighted in blue. </font><font style="vertical-align: inherit;">The values ‚Äã‚Äãin the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> array </font><font style="vertical-align: inherit;">for them are 1.</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="330" src="https://habrastorage.org/webt/h0/by/bm/h0bybmjxpw21mdj1x3uyamtsyk4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can check by substituting the parent values </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the corresponding 0/1 from the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> array </font><font style="vertical-align: inherit;">in the descendant formulas </font><font style="vertical-align: inherit;">- the indices of the descendants will turn out as needed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, for any parent to swap the left and right subtrees, in the array itself, the group of elements does not need to be moved anywhere. </font><font style="vertical-align: inherit;">Only the 0/1 value for the parent in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> array is </font><b><font style="vertical-align: inherit;">switched</font></b><font style="vertical-align: inherit;"> and that‚Äôs it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next - a session of magic with its subsequent exposure.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Build a weak pile</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Swapping left and right descendants is the main tool for converting into a weak heap a set of data from an array. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the process of forming the primary weak heap, we need to sort through the elements of the array in the reverse order (starting from the last) and for each of them find up the branch of the first (right) parent, for which it will be the right subtree. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the element is someone's </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">right descendant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then you do not have to go far. </font><font style="vertical-align: inherit;">Its immediate parent is what you need:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="304" src="https://habrastorage.org/webt/tg/_4/01/tg_401fvyqumg-j_nbwm1-n_bna.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the element is someone‚Äôs </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">left descendant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then you need to go up a number of levels before you meet the desired grandparent, for which the element is in the right subtree:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="304" src="https://habrastorage.org/webt/lk/ud/-f/lkud-fixce2hbm1d7ejuil3pnh8.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then you need to compare the descendant and the progenitor found somewhere above. </font><font style="vertical-align: inherit;">And if the descendant is larger than the progenitor, then the following must be done:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the descendant has his descendants, then swap his left and right subtrees (i.e. switch 0/1 in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> array </font><font style="vertical-align: inherit;">for this element).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exchange the values ‚Äã‚Äãof the descendant node and the progenitor node.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Take a look at a specific example. </font><font style="vertical-align: inherit;">Let‚Äôs say the following situation arose:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/8f/-8/kr/8f-8krbczd6kxh2o-cbbe4hdkdc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the element of the array </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] = 87, the necessary progenitor </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1] = 76 was found. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The progenitor </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1] is smaller than the element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] (76 &lt;87). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] has left and right subtrees (marked in shades of green). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You need to swap these subtrees </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(that is, for element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> array, </font><font style="vertical-align: inherit;">change the value from 0 to 1). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is also necessary to exchange the values ‚Äã‚Äãof the elements </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1].</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
After the necessary actions are completed:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/zy/fb/vb/zyfbvbqsvoyyidown3ljp5pe8mk.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6], the left and right subtrees were exchanged </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(that is, in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> array </font><font style="vertical-align: inherit;">for element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6], the value from 0 was changed to 1). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There was also an exchange of values ‚Äã‚Äãbetween </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1]. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you go through the array from the end to the beginning and along the way perform this procedure for all elements, you will end up with a weak heap. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why this strange mechanism works is an explanation closer to the end of the article.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parsing a weak pile</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A heap is a heap if the maximum element is at the root. Using this fact, all heap sortings work the same way. The root (where the maximum is located) exchanges values ‚Äã‚Äãwith the last element of the unsorted part of the array - as a result, the unsorted part of the array decreases, and the sorted part of the array increases. After this exchange, the heap ceases to be a heap, since the current maximum element is no longer in its root. The heap needs to be restored, that is, make the resulting tree a heap again - find another maximum element and move it to the root. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How to recover a regular binary heap, we know - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the help of a sifter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . But how to restore a weak heap? To do this, do the following.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From the root we descend down the left descendants (right up to the lowest):</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/ka/d1/t8/kad1t8a7egmsgtgrpuqk6txqajc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then we go up the left descendants back up and along the way each left descendant is compared with an element in the heap root. </font><font style="vertical-align: inherit;">And if the next left descendant is larger than the root, then we do the same as in the previous stage: at the left descendant we swap the subtrees (if he has one) and change the values ‚Äã‚Äãof the left descendant and root. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, we will restore the weak heap - the maximum element that is in the remaining tree will pop up at its root. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And again, we have this mystical carousel with subtrees that replace each other. </font><font style="vertical-align: inherit;">So what is the secret to success? </font><font style="vertical-align: inherit;">Why, if during the exchange of nodes with values, the left and right descendants of the lower node are interchanged, do we end up with a sorted array? </font><font style="vertical-align: inherit;">You will never guess, although the answer is simple in its genius.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weak heap sorting :: Weak heap sort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the final algorithm:</font></font><br>
<br>
<ul>
<li><b>I.     :</b><ul>
<li><b>I.1.</b>    -.</li>
<li><b>I.2.</b>           ¬´¬ª .</li>
<li><b>I.3.</b>       .</li>
<li><b>I.4.</b>       , :<ul>
<li><b>I.4..</b>   ( ‚áî )     ,     .</li>
<li><b>I.4..</b>    ¬´¬ª      .</li>
</ul></li>
</ul></li>
<li><b>II.            ,     :</b><ul>
<li><b>II.1.</b>           .</li>
<li><b>II.2.</b>             .         .</li>
<li><b>II.3.</b>        ,        .   :<ul>
<li><b>II.3..</b>          .</li>
<li><b>II.3..</b>        ,      .</li>
<li><b>II.3..</b>     ,    , :<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.3.c. 1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We swap (left ‚áî right) subtrees with descendants for the node in which the current left descendant is located.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.3.c.2. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We change the heap root and the node with the current left child.</font></font></li>
</ul></li>
</ul></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.4. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the root of the weak heap is again the maximum element for the remaining unsorted part of the array. </font><font style="vertical-align: inherit;">We return to paragraph II.1 and repeat the process until all the elements are sorted.</font></font></li>
</ul></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animation (array indices in my animations start with one):</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/1l/ay/j-/1layj-xmzm4dl7p5yv7_5iag5pa.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ Code</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the bottom of the ‚ÄúLinks‚Äù section, those interested can familiarize themselves with the implementation of this sorting in C ++. </font><font style="vertical-align: inherit;">Here I give only the part that illustrates the algorithm itself.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GETFLAG(r, x) ((r[(x) &gt;&gt; 3] &gt;&gt; ((x) &amp; 7)) &amp; 1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TOGGLEFLAG(r, x) (r[(x) &gt;&gt; 3] ^= 1 &lt;&lt; ((x) &amp; 7))</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WeakHeap::WeakHeapMerge</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *r, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>{
  <span class="hljs-keyword">if</span> (wheap[i] &lt; wheap[j]) {<span class="hljs-comment">//""  ?</span>
    <span class="hljs-comment">//  ,   </span>
    <span class="hljs-comment">//( "",   "")</span><font></font>
    TOGGLEFLAG(r, j);<font></font>
    <span class="hljs-comment">//  ""  </span><font></font>
    swap(wheap[i], wheap[j]);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WeakHeap::WeakHeapSort</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> n = Size();
  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>) {<font></font>
		<font></font>
    <span class="hljs-keyword">int</span> i, j, x, y, Gparent;
    <span class="hljs-keyword">int</span> s = (n + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> * r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> [s];<font></font>
		<font></font>
    <span class="hljs-comment">//  ,    </span>
    <span class="hljs-comment">// "",   ""</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">8</span>; ++i) r[i] = <span class="hljs-number">0</span>;<font></font>
		<font></font>
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">for</span>(i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) {<font></font>
      j = i;<font></font>
      <span class="hljs-comment">//    , </span>
      <span class="hljs-comment">//   ""  </span>
      <span class="hljs-keyword">while</span> ((j &amp; <span class="hljs-number">1</span>) == GETFLAG(r, j &gt;&gt; <span class="hljs-number">1</span>)) j &gt;&gt;= <span class="hljs-number">1</span>;
      <span class="hljs-comment">//       ""  </span>
      Gparent = j &gt;&gt; <span class="hljs-number">1</span>;
      <span class="hljs-comment">//  ,   </span>
      <span class="hljs-comment">//   ""</span><font></font>
      WeakHeapMerge(r, Gparent, i);<font></font>
    }<font></font>
		<font></font>
    <span class="hljs-comment">//      --&gt;</span>
    <span class="hljs-comment">//  --&gt;    </span>
    <span class="hljs-keyword">for</span>(i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">2</span>; --i) {
      <span class="hljs-comment">//      </span>
      <span class="hljs-comment">//       </span>
      swap(wheap[<span class="hljs-number">0</span>], wheap[i]);<font></font>
      x = <span class="hljs-number">1</span>;
      <span class="hljs-comment">//    "" </span>
      <span class="hljs-keyword">while</span>((y = <span class="hljs-number">2</span> * x + GETFLAG(r, x)) &lt; i) x = y;
      <span class="hljs-comment">//  ""     </span>
      <span class="hljs-comment">//        </span>
      <span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>) {<font></font>
        WeakHeapMerge(r, <span class="hljs-number">0</span>, x);<font></font>
        x &gt;&gt;= <span class="hljs-number">1</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">//  -   </span>
    <span class="hljs-comment">//    </span>
    swap(wheap[<span class="hljs-number">0</span>], wheap[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">delete</span>[] r;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I especially like how the binary tree is traversed easily and naturally using bitwise operations.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extra memory complexity</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It seems like O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - an additional array is required, in which for nodes with descendants (there are about half of those in the array), the order of the left / right subtrees is fixed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, there is an opinion that the sorting complexity here is actually O (1)! </font><font style="vertical-align: inherit;">For an element, we need only one additional bit (zero / one) to indicate the order of the descendants. </font><font style="vertical-align: inherit;">If we sort, for example, strings, then it is quite feasible to append this additional bit to the element itself. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another way to turn O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) into O (1) is to store flags in a whole number. </font><font style="vertical-align: inherit;">Binary expansion of numbers - a set of zeros and ones responsible for the order of subtrees of all elements of the array. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> th element of the array corresponds to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> th bit of the number.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time complexity</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By time, O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) is the same as a regular heap. </font><font style="vertical-align: inherit;">When sorting rows (especially long ones), a weak heap can be faster than a regular heap. </font><font style="vertical-align: inherit;">But this is if we sort the long lines. </font><font style="vertical-align: inherit;">If we sort the numbers, then, according to rumors, an ordinary heap is faster to manage.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full sifting up</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the stage of formation of the initial weak heap, by analogy with the usual heap, the quite obvious idea suggests raising large elements as high as possible. </font><font style="vertical-align: inherit;">That is, if we exchanged the values ‚Äã‚Äãof the lower node and its ancestor, then it would be logical to immediately repeat the steps for the ancestor - to find his nearest right ancestor for him and compare (and if it is also necessary to exchange values ‚Äã‚Äã+ exchange of subtrees). </font><font style="vertical-align: inherit;">And, if possible, raise a large element to the very root. </font><font style="vertical-align: inherit;">This is how it looks at the first stage (the actions at the second stage of the algorithm are unchanged):</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/9x/9-/pa/9x9-panzenovigxgpzzal8phtri.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The time complexity score remains the same.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomial pile</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All that was up to this point is a deception, an illusion. Of course, we formally perform some manipulations with the binary tree there, change the nodes with values, rearrange the subtrees and all that. However, the algorithm has a double bottom, which we will now look into. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To understand this sort, you need to understand what a weak heap really is. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we take an array in which the number of elements is a power of two, then the weak heap and binomial heap constructed on its basis are isomorphic.</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="222" src="https://habrastorage.org/webt/nk/ge/qu/nkgequw_s9eaecxl7h9fiz9v2ua.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Do not look at the fact that a weak heap is binary, and binomial is not. </font><font style="vertical-align: inherit;">In a weak heap, the left and right subtrees are essentially different. </font><font style="vertical-align: inherit;">The right subtree is a descendant in the classical sense, but the left subtree is rather a ‚Äúbrother‚Äù. </font><font style="vertical-align: inherit;">Although not. </font><font style="vertical-align: inherit;">The left subtree is not even a ‚Äúbrother‚Äù, but a vector of ‚Äúbrothers‚Äù with fewer nodes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, the weak heap and binomial heap are not 100% the same, although they are the closest relatives. </font><font style="vertical-align: inherit;">The difference is obvious, if you take an array whose number of elements is not equal to 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Binomial decomposition of such an array will give a connected list of several ideal heaps (the number of nodes in each of them is a certain power of two):</font></font><br>
<br>
<div style="text-align:center;"><img width="484" height="222" src="https://habrastorage.org/webt/k_/o8/zk/k_o8zk8rbi4n25ojy9ijrwh8jre.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A weak heap in this case will be one imperfect binary tree:</font></font><br>
<br>
<div style="text-align:center;"><img width="691" height="188" src="https://habrastorage.org/webt/eb/7a/-y/eb7a-yq54lycrpazacxsu6ci0em.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The binomial pile and the weak pile are twin brothers. </font><font style="vertical-align: inherit;">DNA is the same, although in appearance you can‚Äôt tell.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secret algorithm</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Given that a weak heap is a cryptobinomial heap, shuffling subtrees suddenly finds a simple explanation.</font></font><br>
<br>
<div style="text-align:center;"><img width="497" height="199" src="https://habrastorage.org/webt/xa/tb/p7/xatbp7kfjag7awytapkrebfwdxk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With a weak heap, sweep away the pseudobinary tinsel and look at the real relations between the nodes in the binomial heap style. </font><font style="vertical-align: inherit;">Everything becomes clear. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no "weakness", it is a full-fledged sorting (non-binary) tree in which the principle "any parent is greater than any of its descendants" is achieved and maintained.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At all stages, we compare the descendants not with their ancestors, but with their immediate parents.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What looks like an exchange of values ‚Äã‚Äãbetween a descendant and an ancestor + an exchange of places of subtrees in a descendant - it turns out to be the exchange of the ratio itself (descendant / parent). </font><font style="vertical-align: inherit;">If the parent node is smaller than the descendant by value, then the parent itself becomes the descendant, and the descendant becomes the parent.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is an honest visualization:</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/s0/zb/m_/s0zbm_vg9ocfnzzgwhldn70v7he.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next series</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next pile that I would like to talk about is my favorite - the Cartesian tree. </font><font style="vertical-align: inherit;">This is not only a bunch, but also a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">binary search tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">But then first, in the next article, something interesting needs to be clarified about BST trees. </font><font style="vertical-align: inherit;">And only then, through the article, and about Cartesian talk.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weak Heap</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomial Heap</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomial </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/fn/cd/py/fncdpynfktllvkdjtmpif0kd1zc.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap C ++ Weak Heap Implementation </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/pt/js/7k/ptjs7kchs12_zg8dfph-ld6yp_4.gif"> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ronald D. Dutton: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personal Page</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UCF Website Profile </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/yv/lm/2t/yvlm2t2kl5affkpm0hzqh7qw5ly.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weak Heaps and Friends: Recent Developments </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Weak-Heap Data Structure: Variants and Applications </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the Performance of WEAK-HEAPSORT </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adaptive heapsort: Source code </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/mp/mv/ie/mpmviex2wi0oknklc_zrg5tgfhe.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Kopeliovich - Lecture Hall - Weak pile (from 48:32 to 1:16:06)</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Series Articles:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel application AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exchange Sorts</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insertion Sorts</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sort by selection</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: N-Pyramids</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Leonardo Numbers</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap sort: weak heap</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bunch Sorts: Cartesian Tree</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Other heap sortings: mirror heap, mini-heap, sifting bottom-up</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merge Sorts</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sort by distribution</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybrid Sorting</font></font></a></li>
</ul><br>
<img align="right" width="349" height="264" src="https://habrastorage.org/webt/kf/cj/xj/kfcjxjqyku6wcl2spe8hqzgefz0.png"><br clear="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Today‚Äôs sorting is added to the AlgoLab application by a weak bunch, who uses it - update the excel file with macros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the comments to the cell with the name of the sort, you can specify some settings. </font><font style="vertical-align: inherit;">If you set siftup = 1, then the sorting will use the full screening up in the first stage (by default siftup = 0). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you prescribe binomial = 1, then the tree will be a la ‚Äúbinomial heap‚Äù (by default binomial = 0, that is, just a weak heap).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en499770/index.html">Learn while self-isolation</a></li>
<li><a href="../en499772/index.html">It will be very, very much: how 5G technology will change the advertising market</a></li>
<li><a href="../en499774/index.html">Not a day without sports - 2: reprogramming a Chinese bracelet</a></li>
<li><a href="../en499776/index.html">Features of the implementation of the MSH language</a></li>
<li><a href="../en499784/index.html">What touch virtual walls?</a></li>
<li><a href="../en499788/index.html">Free online course "Technical documentation in IT projects"</a></li>
<li><a href="../en499792/index.html">Load Testing Atlassian Jira, Confluence, Bitbucket Part 1</a></li>
<li><a href="../en499794/index.html">PostgreSQL and JDBC squeeze all the juices. Vladimir Sitnikov</a></li>
<li><a href="../en499796/index.html">How Courts in the USA Are Held Through Zoom, and Why This Is Considered A Problem</a></li>
<li><a href="../en499798/index.html">Two tapas to money: how we developed a financial chat bot with instant card issuance in Azerbaijan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>