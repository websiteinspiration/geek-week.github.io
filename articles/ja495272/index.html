<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦍 🤘🏽 👆🏾 SNESエミュレーターは、完全な完成からわずか数ピクセル離れています。 🚰 💦 🚡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私たちは、実際のハードウェアとSNESソフトウェアのすべての機能を完全に再現できるエミュレーターの作成に非常に近いです。
 
 過去15年間、bsnesエミュレーターのコーダーとして、スーパーニンテンドーエミュレーションを完成させようとしましたが、最後の問題であるSNESビデオプロセッサーのクロック...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SNESエミュレーターは、完全な完成からわずか数ピクセル離れています。</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495272/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/f3b/e14/44bf3be14304180044d2e7deb216f07d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは、実際のハードウェアとSNESソフトウェアのすべての機能を完全に再現できるエミュレーターの作成に非常に近いです。</font></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">過去15年間、</font></font></a><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bsnes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エミュレーターのコーダーとして</font><font style="vertical-align: inherit;">、スーパーニンテンドーエミュレーションを完成させようとしましたが、最後の問題であるSNESビデオプロセッサーのクロックサイクルの正確なタイミングに直面しています。</font><font style="vertical-align: inherit;">このエミュレーションの正確さの最終段階に到達するには、コミュニティ全体の助けが必要であり、私はあなたのサポートを願っています。</font><font style="vertical-align: inherit;">しかし、最初に、私たちがすでに達成したことをお話します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在の状態</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日、SNESエミュレーションの状況は非常に良好です。エミュレーションに抵抗する珍しい周辺機器（たとえば、</font><font style="vertical-align: inherit;">日本</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">で競馬の賭けのため</font></a><font style="vertical-align: inherit;">に日本で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">使用さ</font></a><font style="vertical-align: inherit;">れ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ている光センサー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自転車シミュレーター</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ダイヤルアップモデムを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">備え</font></a><font style="vertical-align: inherit;">た</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ゴルフクラブ</font></a><font style="vertical-align: inherit;">）を除いて、すべての公式にライセンスされたSNESゲームは完全にプレイできます。明らかな問題のあるゲームはありません。</font><font style="vertical-align: inherit;">
SNESエミュレーションは非常に正確になったため、エミュレータを2つのバージョンに分割する必要が</font><font style="vertical-align: inherit;">ありました。ハードウェアドキュメントとの完全な正確性と一貫性を追求する</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">higanと</font></a><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">速度、幅広い機能、使いやすさを追求する</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">bsnes</font></a><font style="vertical-align: inherit;">です。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近、SNESエミュレーションの分野では、次のような多くの興味深い成果が得られています。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのSNESコプロセッサーの低レベルエミュレーション</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HDモード7のサポート</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブレーキの取り外し</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワイドスクリーンのサポート</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CD-audioおよびFMV用のMSU1</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅延を減らすための予備的な実行</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なオーディオとビデオの同期のための動的データレート制御</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
…そしてもっと！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで完了ですか？みんなうまくいきましたか、さようなら、そして魚に感謝しますか？まあ、かなり。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日では、ほぼすべてのSNESコンポーネントのビートレベルで精度を達成しています。唯一の例外は、画面に送信されるビデオフレームを生成するために使用されるPPU（画像処理ユニット、画像処理モジュール）でした。私たちは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、主に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのようにのPPUの仕事を知っているが、いくつかの機能のために、私たちは不完全な精度で、そのリードを当て推量を使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的なスケールでは、残りの問題はかなり小さなものです。アートの愛に対するエミュレーションの絶対的に完璧な理想性を追求しないと、PPUエミュレーションをさらに改善する必要があることを説得できません。どの分野でもそうですが、理想に近づくほど、収益は低くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがために重要である理由しかし、私は言うことができる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：これは私の人生の仕事である、と私は私が私が得たと言うことはしたくない</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ので、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後のステップを取ることなく近く完成します。</font><font style="vertical-align: inherit;">私は老いていて、永遠ではありません。</font><font style="vertical-align: inherit;">パズルの最後のピースを解決してほしいので、引退した後、エミュレーションのおかげでSNESのレガシーが信頼でき、完全に保存されていると確信しました。</font><font style="vertical-align: inherit;">問題は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解決</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したと言いたい</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも興味をそそられるなら、問題の背景と私が提供する解決策を知るために読み続けてください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SNESアーキテクチャのモデリング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SNESを構成するコンポーネントをリストすることから始めましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3c/f4f/e25/c3cf4fe250fbbed2b897e46ef58628bd.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スーパーファミコンシステム図。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
矢印はさまざまなSNESプロセッサが相互にデータを交換できる方向を示し、点線はメモリチップへの接続を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちにとって今最も重要なことは、ビデオとサウンドの出力がPPUとDSPから直接送信されることに気づくことです。</font><font style="vertical-align: inherit;">これは、それらが「ブラックボックス」として機能することを意味し、内部で何が起こっているかを確認できません。</font><font style="vertical-align: inherit;">後でそれは私たちにとって重要になります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正しさ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのレジスタ（変数）を取り、それらを乗算し、結果と、結果の状態を示すいくつかのフラグ（例：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">overflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を受け取るCPUコマンド「multiply」をエミュレートするとします</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0から255までの任意の値を係数および乗数として乗算するプログラムを作成できます。次に、数値とフラグの乗算結果を導出できます。したがって、65 536要素のテーブルが2つ取得されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのテーブルを分析することにより、CPU計算の結果が特定の方法でどこにどのように設定されているかを正確に判断できます。次に、エミュレータを変更して、同じテストを実行したときに、まったく同じテーブルを同時に取得できるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、CPUが16ビットx 16ビットの乗算を実行できるとしましょう。すべての可能な値をテストすると、40億の結果が生成されます。これは、妥当な時間でテストすることはほとんど不可能です。 CPUに32ビットx 32ビットの乗算がある場合、実際には、宇宙の熱死の前に（少なくとも現在の技術レベルでは）入力値のすべての組み合わせをテストすることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような場合は、テストでより選択的に動作し、フラグが正確に変更できる時期、結果がオーバーフローする可能性がある時期などを判断しようとします。それ以外の場合は、終了しないテストを実行する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
乗算はかなり些細な演算ですが、同じ原理をリバースエンジニアリングのプロセス全体に拡張できます。たとえば、ビームの水平戻り中のDMA（ダイレクトメモリアクセス）を介したデータ送信など、より複雑な演算を含みます。</font><font style="vertical-align: inherit;">ボーダーラインのケースで何が起こるかを判断しようとするテストを作成し、次に、エミュレーションが実際のSNESの動作と同じように動作するかどうかを確認します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信号発生器とビート</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SNESには、約21 MHzの周波数で動作する水晶発振器（CPUおよびPPUモジュールを制御）と、SMPおよびDSPを制御する約24 MHzの周波数で動作するセラミック共振器の2つの信号発生器（発振器）があります。</font><font style="vertical-align: inherit;">カートリッジコプロセッサでは、21 MHz水晶発振器が使用されることもあれば、独自の信号発生器が他の周波数で動作することもあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97d/ecb/bc1/97decbbc1161fcf170f063d2fd42795d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このSuper Famicom回路基板をコードで再作成することは、思ったより難しいです。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
クロックはあらゆるシステムのタイミングの基本要素であり、SNESは特定の周波数と時間間隔でさまざまなタスクを実行するように設計されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
100ヘルツのクロックを想像すると、これはバイナリ出力が信号の高論理状態（たとえば、+ 5 V）に切り替わり、信号の低状態（0 V、またはグラウンド）に1秒あたり100回切り替わるデバイスになります。つまり、出力の電圧は毎秒200倍変動します。つまり、100倍に増加し、100倍に低下すると、クロック信号のフロントが低下します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クロックサイクルは通常、1つの完全な遷移と見なされます。つまり、100 Hzサイクルは1秒あたり100クロックサイクルを生成します。</font><font style="vertical-align: inherit;">一部のシステムでは、立ち上がりエッジと立ち下がりエッジを区別する必要があります。それらのシステムでは、サイクルを半サイクルに分割して、クロック信号の各フェーズ（高または低）を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正確なエミュレータの最も重要なタスクは、実際の機器とまったく同じ方法で、まったく同じ時間にタスクを完了することです。</font><font style="vertical-align: inherit;">ただし、</font><font style="vertical-align: inherit;">タスクの実行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それほど重要ではありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">重要なのは、エミュレータが同じ入力信号を受け取り、実際のハードウェアと同じ時間に同じ出力信号を生成することです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイミング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時々操作に時間がかかります。 SNES CPUでの乗算を例にとります。乗算が完了するのを一時停止して待機する代わりに、SNES CPUは、CPUオペコードの8クロックサイクルの間、乗算の結果をバックグラウンドで一度に1ビットずつ計算します。これにより、乗算が完了するのを待っている間、コードが他のタスクを実行できる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、商用ソフトウェアはこれらの8サイクルを待機します。準備ができる前に結果を読み取ろうとすると、部分的に完了した結果が得られるためです。ただし、SNESエミュレータが</font><font style="vertical-align: inherit;">これらの追加のクロックサイクルを待たず</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">即座</font></i><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">正しい結果を出す前</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンソールのファンがエミュレータで自己記述型ソフトウェアを作成してテストし始めたとき、この不一致が特定の問題を引き起こし始めました。ソフトウェアの一部、たとえば最初の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スーパーマリオワールド</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ROMハックの多くは、</font><font style="vertical-align: inherit;">これらの古いエミュレータでのみ正しく機能し、実際のSNESハードウェアでは機能しませんでした。これは、乗算の結果を瞬時に（実際の機器から見ると信頼できない）取得することを考慮して開発されたためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エミュレーターを改善する過程で、古いソフトウェアの互換性が失われたため、これらのプログラムを失わないように、新しいエミュレーターに互換性オプションを追加する必要がありました。はい、どんなに現実味があっても、今日のエミュレータは他のエミュレータをエミュレートする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CPUにおけるこの乗算の遅延の利便性は、それが非常に予測可能であるという事実にあります。8クロックサイクルの計算が、乗算演算の要求の直後に始まります。</font><font style="vertical-align: inherit;">各サイクル後に結果を読み取るコードを記述することにより、SNES CPU </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がブースアルゴリズム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">し</font></a><font style="vertical-align: inherit;">て乗算していることを確認できました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クロック同期</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の操作はバックグラウンドで非同期に実行されるため、モデル化が容易ではありません。そのようなケースの1つは、セントラルSNESプロセッサのDRAMアップデートです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ラスターラインのレンダリング中、RAMチップの内容が更新されている間、特定のステージのSNES CPU全体がその動作を一時停止します。 SNESのコストを削減するために、CPUのメインメモリとして静的ではなく動的なRAMが使用されたため、これが必要です。ダイナミックRAMの内容を保存するには、定期的に更新する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d61/cb1/ab9/d61cb1ab914186314069b09f88218fcf.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真に完璧なエミュレータを作成するだけでは、3万5千本すべてのSNESゲームのプレイアビリティを保証するには不十分です。また、システムの各機能のシミュレーションを完璧なタクト精度で実現することも必要です。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これらの操作の正確なタイミングの分析における重要な要素は、水平および垂直PPUカウンターの使用の可能性でした。これらのカウンターはインクリメントを実行し、各水平方向および垂直方向のビームが反転するたびにリセットされます。ただし、その精度はSNES CPU信号発生器の周波数の4分の1にすぎません。つまり、水平カウンタは4クロックサイクルごとにインクリメントします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カウンターの値を数回読み取ったところ、カウンターが調整されているクロックサイクルの4分の1を特定できました。この知識と、ユーザーが指定した正確なクロックサイクル数に一歩近づくことができる特別に作成された関数を組み合わせると、SNES CPUを必要なクロックサイクルの正確な位置に完全に一致させることができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのクロックサイクルを繰り返した結果、特定の操作（たとえば、DRAMの更新、HDMAの送信、割り込みポーリングなど）が正確に行われている時期を特定することができました。その後、私はこれらすべてをエミュレーションで正確に再現できました。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SMPチップ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SNESコンソールにも独自のタイマーがあり、このプロセッサーに対してもリバースエンジニアリングが成功しています。</font><font style="vertical-align: inherit;">記事全体をSMP TESTレジスターにのみ当てることができます。これにより、プログラマーはSMP分周器とそのタイマーを制御でき、他のひどいことは言うまでもありません。</font><font style="vertical-align: inherit;">それは簡単で迅速なプロセスではなかったと言っても十分でしょうが、最終的には勝ちました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コプロセッサーを収集します</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ce/8ec/80c/1ce8ec80c157a980c0222eb7462679e9.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SuperFXチップは、SNESエミュレーターが処理できる多くのカートリッジコプロセッサーの1つにすぎません。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
さまざまなゲームカートリッジの内部で使用されているSNESコプロセッサはたくさんあります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SuperFX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA-1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの個々の汎用CPUから</font><font style="vertical-align: inherit;">、DSP-1やCx4などのデジタルシグナルプロセッサから、S-DD1やSPC7110などの解凍アクセラレータ、またはSharpやEpsonのリアルタイムクロックなど、さまざまなものがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、SNESエミュレータはSuperFX命令とピクセルキャッシュに対応する必要があります。 SA-1メモリバスの競合解決スキーム（SNESとSA-1 CPUが同じROMとRAMチップを同時に使用できるようにする）;統合されたファームウェアDSP-1およびCx4;予測ベースの算術エンコーダS-DD1およびSPC7110を使用。リアルタイムジェネレーターでのBCD（2進化10進数）の奇妙な境界線の場合も同様です。ゆっくりと確実に、上記の正確さとタイミングを決定するためのすべての手法を使用して、これらのすべてのチップをほぼ完全にエミュレートする方法を学ぶことができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チップカバーを取り外し、さまざまなゲームで使用されているデジタルシグナルプロセッサからファームウェアを削除するには、多大な労力と数千ドルがかかりました。あるケースでは、NEC uPD772xエミュレーションが許可されています</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">higanのコードを使用して故スティーブンホーキングの声を保存してください！</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のケースでは、Hitachi HG51Bアーキテクチャのドキュメントセットを誰も発行したことがないため、Hitachi HG51Bアーキテクチャの一連の命令全体をリバースエンジニアリングする必要がありました。</font><font style="vertical-align: inherit;">別のケースでは、あるゲーム（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hayazashi Nidan Morita</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shougi </font><em><font style="vertical-align: inherit;">2</font></em><font style="vertical-align: inherit;">）は、周波数21 MHzの強力な32ビットARM6 CPUを備えており、日本の将棋ゲームを加速することがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのSNESコプロセッサーを保存するだけでも、困難と驚きに満ちた長期的なプロセスであることがわかりました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デジタル信号処理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソニーのS-DSP（デジタルシグナルプロセッサ）チップは、DSP-1カートリッジコプロセッサーと混同しないようにして、独特のSNESサウンドを生成しました。このチップでは、4ビットADPCMエンコーディングの8つのオーディオチャネルが接続され、16ビットステレオ信号の作成が保証されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外側に、そして上記のシステム図から、最初はDSPが「ブラックボックス」のように見えます。サウンドチャネルとミキサーパラメーターを調整し、その後、チップがスピーカーに送信されるサウンドを生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、1つの重要な機能により、blarggというニックネームの開発者は、このチップの完全なリバースエンジニアリングを実行できました。これはエコーバッファーでした。</font><font style="vertical-align: inherit;">SNES DSPには、前のサンプルからの出力を混合してエコー効果を作成する機能があります。</font><font style="vertical-align: inherit;">これは、サウンド生成プロセスの最後に発生します（最後の1つのサウンドブロッキングフラグは別として、これはサウンド出力全体をオフにするために使用できます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
測定の正しいタイミングでコードを記述し、結果のエコーを追跡することにより、DSPが実行する操作の正確な順序を決定して生成することができました各サンプルの完璧なサウンドとビート精度を作成します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPUの節約</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがすべて、SNESアーキテクチャスキームの最後の部分であるPPU-1およびPPU-2チップにつながりました。</font><font style="vertical-align: inherit;">John McMasterのおかげで、S-PPU1（リビジョン1）およびS-PPU2（リビジョン3）チップのスキャンが20倍になりました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/678/641/68e/67864168e9f383375b8e081ffff1606f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のPPU SNESのクリスタルの20倍スキャン...</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fad/524/a23/fad524a235729831ae880c3edf1bb4b8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...と2番目のPPU</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
両方のクリスタルスキャンにより、チップは明らかに汎用CPUではなく、ファームウェアプログラムの内部ROMからオペレーションコードを実行する特殊なアーキテクチャでもないことがわかりました。これらは、ハードコードされたロジックを備えた個別のロジック回路であり、さまざまなレジスタやメモリから着信信号を受け取り、一度に1つのラスターラインをモニターするビデオ信号を作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のすべてのコンポーネントとは異なり、PPU </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は実際に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はブラックボックスであるため</font><font style="vertical-align: inherit;">、PPU </font><i><font style="vertical-align: inherit;">は</font></i><font style="vertical-align: inherit;"> SNESのエミュレーションに対する最後の障害</font><font style="vertical-align: inherit;">です。それらを任意の状態に設定できますが、SNES CPUはそれらが生成するものを直接監視できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
類推として乗算を使用する前の例を使用する場合、3 * 7の結果を要求したが、バイナリの回答ではなく、数字「21」のあいまいなアナログ画像が画面に表示されたとします。あなたのソフトウェアを実行する人は誰でも</font><font style="vertical-align: inherit;">21 </font><font style="vertical-align: inherit;">を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見る</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こと</font><i><font style="vertical-align: inherit;">が</font></i><font style="vertical-align: inherit;">でき</font><font style="vertical-align: inherit;">ますが、彼が正しい答えを見つけたかどうかを自動的にチェックするテストプログラムを書くことはできません。このような結果を人間が手動で検証することは、数千を超えるテストにスケールすることはできず、PPUの動作を最大化するには数百万が必要になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「しかし、キャプチャカードを使用して画像処理を実行し、エミュレータのデジタル画面上の画像と大まかに比較して、これに基づいてテストを実行する方が簡単ですか？」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ええ、それは可能です！</font><font style="vertical-align: inherit;">特に、テストが画面全体を占める2つの巨大な数をチェックする場合です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、テストに多くのニュアンスがあり、1ピクセルのハーフトーンの色の違いを認識しようとしている場合はどうでしょうか。</font><font style="vertical-align: inherit;">100万回のテストを順番に実行したいが、何を生成するかが常にわからないが、結果をエミュレーションの出力と比較したい場合はどうでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デジタルデータの利便性と精度に勝るものはありません。一致するか一致しないかの正確なビットストリームです。</font><font style="vertical-align: inherit;">CRT信号のアナログの性質はこれを提供できません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どうしてそれが重要ですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つのゲーム（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を除いて、すべての正式にライセンスされたSNESソフトウェア（ラスター文字列に基づく必要があります）。これらのゲームは、現在レンダリングされているラスターラインの途中でPPUレンダリングの状態を変更しようとはしません（プログラマーによるこのようなトリックは、「ラスターエフェクト」と呼ばれます）。つまり、大多数のゲームの実行タイミングは、特に正確である必要はありません。次の完全なラスタラインの時間がある場合は、すべて順調です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これは1つのゲームにとって重要です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/c75/08c/349c7508c9724e946a687c60881e77fc.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a4/7ee/5b2/3a47ee5b2b9ceacabcf2c4f1c34a1fe3.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77e/149/23c/77e14923ce342dc49287fa908aea5b93.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この一連の画像は、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrolの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Good Luck」メッセージで使用されている複雑なエミュレーション効果を示しています</font><font style="vertical-align: inherit;">。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
上の画像では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からのフレームごとのテキスト「Good Luck」が表示されています</font><font style="vertical-align: inherit;">。ゲームは、背景レイヤー3（BG3）を垂直方向にスクロールする位置を変更することで実装します。ただし、左側のダッシュボードディスプレイ（プレーヤーが39個のミサイルを持っていることがわかります）も同じ背景レイヤーにあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームは、左のダッシュボードをレンダリングした後、テキスト「Good Luck」がレンダリングされ始める前に、各ラスターラインのBG3スクロールの位置を変更することによって、この分離を実行します。ダッシュボードとテキストの外側では、BG3は透明であり、垂直スクロールレジスタの値に関係なく、これら2つのポイントの間に描画するものがないため、これを行うことができます。この動作は、スクロールレジスタ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリングのどの段階でも変更</font><em><font style="vertical-align: inherit;">できることを</font></em><font style="vertical-align: inherit;">示してい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/880/658/047/8806580479dcbbaf6671fc971c12ba8b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
飛行機の下のこの小さな影は、精度にこだわったエミュレータ開発者に多くの頭痛の種をもたらしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の画像は、飛行機の悪名高い影を示しています。この効果は、5つのラスターラインにわたって短いリップルで画面の明るさレジスターを変更することによってレンダリングされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲーム中、この影はかなり混沌としていることがわかります。上の画像では、文字「c」に少し似ていますが、各ラスターラインの形状は、フレームごとに長さと開始点が変化します。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の開発者は</font><font style="vertical-align: inherit;">、影が表示される場所を大まかに概説し、この問題を直接解決しました。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどの場合、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これでうまくいきます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような動作を正しくエミュレートするには、完璧なタイミングが必要</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">これをエミュレータで取得</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">ことは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">困難です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c5/b7f/fa2/1c5b7ffa2601b6480209321b60a131a1.png"></div><br>
<i><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrolの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一時停止画面</font><font style="vertical-align: inherit;">では、他のSNESゲームでは意図的に使用されていなかったラスター効果が使用されています。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
次に、一時停止画面について説明します。 BG3をオンにして左側に黄黒の境界線を描画し、同じ右側にある境界線でBG3を再びオフにして画面に灰色の線を描画します。また、フレームを交互に切り替えて、これらの灰色の線が表示されているラスター線を切り替えて、オーバーレイジッタの効果を作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のエミュレートされた画像を拡大すると、これらの灰色の線の左隅にあるラスター線のペアの間に、いくつかの欠落しているピクセルがあることに気づくでしょう。これは、私のPPUエミュレーションがクロックサイクルで100％不完全であるために発生しました。この場合、BG3を有効にする必要があるよりも少し遅れて有効になるという効果があります。</font></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像が正しくレンダリングされる</font><font style="vertical-align: inherit;">
ように、タイミングを非常に簡単に変更でき</font><font style="vertical-align: inherit;">ます。ただし、そのような変更は</font><font style="vertical-align: inherit;">、ラスターラインの中央でPPUディスプレイレジスタを変更する</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム</font><font style="vertical-align: inherit;">に悪影響を与える可能性があり</font><font style="vertical-align: inherit;">ます。が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エアストライクパトロールが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目的でこれを行う唯一のゲームで、これが偶然に起こっている少なくともダースのゲームは（おそらくIRQがあまりにも遅かれ早かれそれらの中に発射する）があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、写真に一時的に目立った損傷が発生することがありますが、開発中は注意が払われません（たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フルスロットルレーシングでは）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストアとゲームの間の移行中）。残りの部分が透明な画面のレンダリング中に記録が実行される場合があるため、視覚的な異常は発生しません（たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大怪獣物語II</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でHPステータスを表示する場合</font><font style="vertical-align: inherit;">など）。最も生産的なエミュレータで使用されています。</font><i><font style="vertical-align: inherit;">Air Strike Patrol</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を無視しても</font><font style="vertical-align: inherit;">、SNESソフトウェアのこれらすべてのランダムな（ただし有効な）ラスタ効果では、完全なクロック精度でラスタライン全体を生成するPPUレンダラーを機能的に設計できません。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長年の試行錯誤によるbsnesの場合、「ラスター効果」を備えたそのようなゲームのリストを作成しました。</font><font style="vertical-align: inherit;">また、ラスターラインに基づいてより高速なレンダリングを可能にする個別のレンダリング位置を作成し、これらすべてのゲームを正しく表示します（</font><font style="vertical-align: inherit;">もちろん、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を除く</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">しかし、本質的に、これは特定のゲーム用に設計された、私たちにとって不愉快なハックの集まりです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのすべてのハックを必要としないクロックベースのPPUレンダラーもありますが、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air Strike Patrolの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上のスクリーンショットのように、実際の機器のレンダリングと時々小さな（1〜4ピクセル）違いが生じ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部ラッチレジスタ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべての小さなミスの理由は、タイミングのスナップに起因します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SNESがその</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有名なモード7を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリングするとし</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。これは、各ラスターラインでパラメーターを変更するアフィンテクスチャ変換です。</font><font style="vertical-align: inherit;">画面のピクセルを決定するには、同様の計算を実行する必要があります。</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">px = a *クリップ（hoffset-hcenter）+ b *クリップ（voffset-vcenter）+</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b * y +（hcenter &lt;&lt; 8）</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
py = c *クリップ（hoffset-hcenter）+ d *クリップ（voffset-vcenter）+</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
d * y +（vcenter &lt;&lt; 8）</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際のSNESは、フレームにレンダリングされる各ピクセルに対してこれらの6つの乗算すべてを十分に速く完了することができません。</font><font style="vertical-align: inherit;">ただし、これらの値はピクセルごとに変化しないため（または、少なくとも変化しないはずです）、各ラスタラインの先頭でpxとpyを1回計算するだけで済みます。</font><font style="vertical-align: inherit;">つまり、PPUは静的な結果をキャッシュにキャッシュします。ラッチは基本的にPPUレジスタのコピーです。</font><font style="vertical-align: inherit;">将来的には、変換されるか、変更されないままになる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、x、y座標がモード7によって次のように変換されます。</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ox =（px + a * x）&gt;&gt; 8</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
oy =（py + c * x）&gt;&gt; 8</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
xはピクセルごとに異なりますが、増分は毎回1つずつ実行されることがわかっています。内部ドライブのストレージのおかげで、各ピクセルに対して2つの乗算を実行するのではなく、定数値aおよびcを各ピクセルのoxおよびoyに単純に追加できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、私たちの前で問題が発生します：クロックサイクルの特定の位置で、PPUは、CPUがアクセスする外部PPUレジスタからaおよびcの値を読み取りますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
早すぎると、一部のゲームが中断する可能性があります。遅すぎると、他のゲームが壊れる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も簡単な方法は、バグレポートを待ち、これらの位置を調整して、特定の各ゲームの問題を修正することです。しかし、この場合、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正確な</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位置を</font><font style="vertical-align: inherit;">見つけることはでき</font><font style="vertical-align: inherit;">ず、それらの近似のみを</font><font style="vertical-align: inherit;">見つけます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これらの変数の1つを変更するたびに、SNESライブラリの3万5千ゲームすべてを再テストして、変更によって生じる可能性のある劣化を検出することは非現実的です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フライパンから火の中に</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/741/b84/c0a741b84071dd0252021ae422277c1a.jpg"></div> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エミュレーションエラーを排除するプロセスの芸術的な解釈。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
同様のスタイルのテスト方法論、「私たちはどんなコストででも作業したいゲームを作るだけです」は、私がエミュレーションを「火から、火の中へ」と呼んでいる現象につながりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、ゲーム内で発生したときに、非常にSNESエミュレーションの開発の初めに、その後、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕事にそれを許可され、このゲームでの補正は、エミュレータに受け入れて、コメントを追加しました。この修正は必然的に他のゲームを壊しました。そして、彼らは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム</font><font style="vertical-align: inherit;">を修正</font><i><font style="vertical-align: inherit;">し</font></i><font style="vertical-align: inherit;">、その後3番目のゲームが壊れました。 3番目のゲームを修正すると、最初のゲームが壊れました。これは何年も続いた。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの間違いは、開発者が一度に1つの変数のみを考慮に入れようとしたことです。ゲームがあり、それが機能するためには、イベントがメジャー20と120の間で発生する必要があると仮定します。正確なメジャーがわからないので、ちょうど真ん中の70を選択します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
後で別のゲームのバグレポートを取得し、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム</font><font style="vertical-align: inherit;">が機能</font><font style="vertical-align: inherit;">するためには、測定値が10〜60である必要がある</font><font style="vertical-align: inherit;">と判断しました。</font><i><font style="vertical-align: inherit;">これで</font></i><font style="vertical-align: inherit;">、両方のゲームで機能する40に変更します。論理的に聞こえます！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、その後、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3番目の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム</font><font style="vertical-align: inherit;">が表示</font><font style="vertical-align: inherit;">され、イベントはメジャー80と160の間で機能します。現在、3つのゲームすべてを同じ値で同時に動作させることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、エミュレータ開発者は特定のゲームのハックを作成する必要がありました。</font><font style="vertical-align: inherit;">プログラマーは</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マリオ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゼルダ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メトロイドを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行できないエミュレーターをリリースしたくありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、一般的なケースでは、クロックサイクル40が使用されますが、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metroid</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">ロードするときに</font><font style="vertical-align: inherit;">、タイミング値を100に強制します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはどのようにして可能ですか、2つのゲームで異なる値が必要なのはなぜですか？</font><font style="vertical-align: inherit;">これは、1つの変数だけが関係しているわけではないために発生します。</font><font style="vertical-align: inherit;">以前に別のイベントをトリガーするために使用したタイミングは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントに</font><font style="vertical-align: inherit;">必要なタイミング値に影響を与える可能性があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを単純な代数式の形で想像してみてください。</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2x + y = 120</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
x = 10、y = 100を取ることで解決できます。または、x = 20、y = 80。または、x = 30、y = 60。 1セットのゲームを同時に実行できるxの値のみを考える場合、問題は実際には間違ったyにある可能性があるという事実を見逃しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
互換性を高めるためのエミュレータの最初のバージョンでは、実行中のゲームに応じてxの値を再定義しました。 xの正しい単一の値が後で発見されたとしても、そのような個々のゲームハックは持続しました。したがって、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題</font><font style="vertical-align: inherit;">は決して解決されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、SNESの場合、1つまたは2つの変数が同時に関与することはありません。 SNESコンソールPPUだけでも52の外部レジスターがあり、これは約130のパラメーターです。単一のラスターラインをレンダリングするプロセスでは、これらのパラメーターの130個すべてと、不明な数の内部レジスターおよびラッチが関係します。これは、特定の時点でのPPUの完全な状態を実現するのに外部の誰かにとってはあまりにも多くの情報です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エミュレーションのこの側面は、初心者には明らかではありませんが、非常に公平です：</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">精度は</font></font></em><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">互換性に</font></em><font style="vertical-align: inherit;">等しく</font><em><font style="vertical-align: inherit;">あり</font></em><font style="vertical-align: inherit;">ません</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ゲームの10％を実行できる99％の精度のエミュレータを作成できます。</font><font style="vertical-align: inherit;">また、98％のゲームを実行する80％の正確なエミュレータを作成できます。</font><font style="vertical-align: inherit;">短期間に正しく実装すると、人気のゲームが壊れる場合があります。</font><font style="vertical-align: inherit;">これは、100％の精度</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100％の互換性の</font><font style="vertical-align: inherit;">両方を実現しようとしている場合に必要な犠牲です</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題を解く</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演繹推論と実際の結果のおかげで、PPUエミュレーションの現在の段階に到達しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのPPUが2つのVRAMチップにアクセスできることはわかっています。</font><font style="vertical-align: inherit;">各チップから、ラスタラインごとに既知の数のデータバイトを読み取ることができることはわかっています。</font><font style="vertical-align: inherit;">各SNESビデオモードがどのように機能するかの大まかな詳細はわかっています。</font><font style="vertical-align: inherit;">これに基づいて、アーキテクチャがどのように見えるかという一般的なパターンを概説できます。</font><font style="vertical-align: inherit;">たとえば、最初の3つのSNESビデオモードがどのように機能するかの簡単な例を次に示します。</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if（io.bgMode == 0）{</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg4.fetchNameTable（）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchNameTable（）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchNameTable（）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchNameTable（）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg4.fetchCharacter（0）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchCharacter（0）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchCharacter（0）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchCharacter（0）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
if（io.bgMode == 1）{</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchNameTable（）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchNameTable（）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchNameTable（）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg3.fetchCharacter（0）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchCharacter（0）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchCharacter（1）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchCharacter（0）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchCharacter（1）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
if（io.bgMode == 2）{</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg2.fetchNameTable（）;</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bg1.fetchNameTable（）;</font></font><font></font>
<font></font>
bg3.fetchOffset(0);<font></font>
<font></font>
bg3.fetchOffset(8);<font></font>
<font></font>
bg2.fetchCharacter(0);<font></font>
<font></font>
bg2.fetchCharacter(1);<font></font>
<font></font>
bg1.fetchCharacter(0);<font></font>
<font></font>
bg1.fetchCharacter(1);<font></font>
<font></font>
}</pre></blockquote><br>
<h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PPUは、その状態のほんの一部のみをサードパーティのオブザーバーに明らかにします：水平および垂直後方（水平/垂直ブランキング）フラグ、水平および垂直ピクセル数、およびスプライトの間隔のタイルオーバーレイフラグ。これはそれほど多くありませんが、繰り返しますが、観察者がアクセスできる状態のすべての小さな要素が私たちを助けます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レンダリング中のPPUチップのVRAM（ビデオRAM、ビデオメモリ）は、読み取り用であってもSNES CPUに対して閉じられています。しかし結局のところ、OAM（スプライトメモリ）とCGRAM（パレットメモリ）は開いています。トリックは、現時点でPPUがアドレスバスを制御していることです。したがって、画面のレンダリング中にOAMとCGRAMを読み取ると、PPUがこれらの2つのメモリブロックから何が非常に重要な時に得られるかを観察できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらはすべてのパズルのピースではありませんが、スプライトを取得するための実際的に正しいパターンを実装するには十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オープンOAMおよびCGRAMのアクセスパターン、PPUフラグ、さまざまなゲームのエラーレポートからの一般的な観測（つまり、推測）および演繹的推論を使用して、</font><font style="vertical-align: inherit;">リリースされたすべてのゲームを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほぼ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全に</font><font style="vertical-align: inherit;">起動</font><font style="vertical-align: inherit;">できるクロックベースのPPUレンダラーを作成できました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、状況は依然として不安定です。誰かがティックとラスターエフェクトの正確なタイミングを使用して自作のゲームを作成し始めると、すべての最新のエミュレーターはこれを処理できなくなります。 FPGAに基づくソフトウェアとハ​​ードウェアの実装を含みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私ははっきりと言わなければなりません：今日</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべて</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼らは、SNESコンソールのPPUチップにおける動作の内部順序とスナップ動作のみを認識しています。</font><font style="vertical-align: inherit;">それらを完全にエミュレートする方法は誰にもわかり</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">少なくとも今のところは。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能な解決策</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで何をしようか？</font><font style="vertical-align: inherit;">SNES CPUの観点から、それが「ブラックボックス」である場合、PPUでの操作の正確な順序を決定する方法は？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考えられるオプションは4つあります。ロジックアナライザー、テストモードでのデジタルビデオ出力、ライザー、チップからのカバーの取り外しです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロジックアナライザー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のPPUクリスタルのスキャンを見ると、チップの端に黒い領域があることがわかります。これらは、チップの接点に接続するプラットフォームです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのピンは、各クロックサイクル中のPPUチップの状態を格納します。ここでは、チップがビデオメモリチップにアクセスする現在のアドレス、1つのPPUから2番目のPPUに転送されるデータの値などを見つけることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この情報は、SNES CPUで実行されているコードでは利用できませんが、PPU演算の内部順序に関する貴重な観察結果を提供します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c8/157/c0d/2c8157c0df8caaebd7e24f620bf2c60f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super NESコンソールPPUを同様のロジックアナライザーに接続することは、ブラックボックスの鍵となります。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロジックアナライザーの重大な問題は、管理が非常に不便であることです。稼働中のシステムからライブデータをサンプリングしようとすると、解読がかなり難しい結果のストリームが得られます。</font><font style="vertical-align: inherit;">システムのアナログRGB出力を分析しようとすると、同じ問題が発生します。このデータをキャプチャするには、各テストを手動で実行する必要があります。</font><font style="vertical-align: inherit;">このようなシステムは、再現可能な自動回帰テストの作成にはあまり適していません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストモードでのデジタルビデオ出力</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近、20倍の倍率でクリスタルスライスをスキャンすることにより、SNESコンソールのPPUチップに秘密のテストモードが発見されました。ハードウェアに小さな変更を加えると</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、PPUは15ビットのデジタルRGB信号を出力し始めます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはほとんど必要なものです！ただし、有名なモード7では正しい画像を表示できないため、このモードには問題があります。この機能は完全には完了していないようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、この方法を実装するには、SNESコンソールを手動で変更し、テストモードで出力をキャプチャして分析するための適切なメカニズムが必要です。</font><font style="vertical-align: inherit;">ただし、アナログRGB信号をキャプチャするソリューションとは異なり、このようなデジタル信号は自動的にテストできるため、PPUリバースエンジニアリングで大量の作業をすばやく完了することができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライザー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PPUが静的であることを考えると、稼働中のSNESコンソールからPPUチップを取り外し、2つのVRAMチップとともにプロトタイピングボードまたはカスタムメイドの回路基板に接続することができます。</font><font style="vertical-align: inherit;">その後、PPUとUSBインターフェイスの間にマイクロコントローラーを配置し、インターフェイスをPCに接続すると、エンコーダーがすべての外部ビデオメモリレジスタとPPUをプログラムできるようになります。</font><font style="vertical-align: inherit;">さらに、エンコーダーはPPUクロックサイクルを手動で制御し、I / Oコネクタ、レジスター、および各クロックサイクルでPPUメモリ内の結果の信号を読み取ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I / Oコネクターの同じ内部値を生成するようにソフトウェアエミュレーターを変更することで、リアルタイムでも、実際のハードウェアをエミュレーションと直接比較できます。</font><font style="vertical-align: inherit;">ただし、内部のPPU操作をまだ確認できないため、これは非常に困難な作業になります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カバーの取り外し</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、最も極端な解決策は、チップカバーを取り外して水晶をさらに調べることです。</font><font style="vertical-align: inherit;">すでに20倍の倍率のクリスタルスキャンがありますが、その解像度は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Visual 6502プロジェクトで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行われ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">た</font></a><font style="vertical-align: inherit;">ように、個々の論理回路を分析して再作成するには十分ではありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">100倍の倍率で両方のPPUのクリスタルスキャンを取得できれば、PPU回路をコンパイルして接続テーブルまたはVHDLコードに変換するというハードワークを始めることができます。</font><font style="vertical-align: inherit;">その後、FPGAで直接使用することができ、C ++や他のプログラミング言語に移植して、ソフトウェアエミュレータの作成に適用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前にこれを行った専門家の1人が大まかな見積もりを出しました。両方のPPUをマッピングするのに約600時間かかります。</font><font style="vertical-align: inherit;">このタスクは、「募金で資金を集めて誰かに支払いましょう」のレベルよりはるかに高く、理想的には「独自のスキルを持つ非常に才能のある誰かが自発的に手助けしてくれることを願っています」というカテゴリーに分類されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これは私が誰かに彼らの援助に対して経済的に報いることに満足していないという意味ではありません、必要な詳細と仕事にお金を払うことができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">助けを求める</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要約すると、私は自分のSNESエミュレータープロジェクトで可能な限り行っており、この最後のタスクを完了するために助けが必要です。</font><font style="vertical-align: inherit;">最後まで読んだら、あなたは助けたいかもしれません！</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHubのbsnesプロジェクト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">への参加を含むあらゆるサポート、</font><font style="vertical-align: inherit;">またはPPUチップの内部動作に関するあらゆる研究ドキュメントは、私たちにとって非常に貴重です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読んでいただき、ありがとうございます。</font><font style="vertical-align: inherit;">15年間、私はSNESエミュレーションコミュニティのメンバーになれたことを誇りに思っています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja495256/index.html">メールサーバーのポートと暗号化について</a></li>
<li><a href="../ja495258/index.html">ズームがコロナウイルスの時代で最も重要な企業になった経緯</a></li>
<li><a href="../ja495262/index.html">PostgreSQLバージョンのアップグレード方法。アンドレイ・サルニコフ</a></li>
<li><a href="../ja495266/index.html">ルネサンスeラーニング。2020年に遠隔教育のすべての利点が示される理由</a></li>
<li><a href="../ja495268/index.html">UI / UXケース：空港駐車場の自動化</a></li>
<li><a href="../ja495274/index.html">ルートリークを修正する方法</a></li>
<li><a href="../ja495276/index.html">そして、Uptime Instituteでの運用の持続可能性監査にどのように合格したかを示します。</a></li>
<li><a href="../ja495278/index.html">データベース、カード、チェックリスト、またはなぜビジネスナレッジマネージャー</a></li>
<li><a href="../ja495280/index.html">Max Patrol SIEM。情報セキュリティイベント管理システムの概要</a></li>
<li><a href="../ja495282/index.html">XSD、JAXB、Spring Frameworkを使用したXML検証</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>