<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëü üíæ üí™üèæ Function timer for Simatic S7-1200 industrial controller üïâÔ∏è üè¥‚Äç‚ò†Ô∏è üëµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Even for the S7-300 and S7-400 series, under Step 7, the classic versions of the timers offered to the developer were quite enough - these are standar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Function timer for Simatic S7-1200 industrial controller</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491200/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even for the S7-300 and S7-400 series, under Step 7, the classic versions of the timers offered to the developer were quite enough - these are standard IEC timers, implemented as function blocks, and S5 timers (which, by the way, still exist for the S7- series 1500). However, in some cases, the developer did not use standard tools and implemented his own timers, most often in the form of functions. Such timers-functions were necessary with an ‚ÄúIT‚Äù approach to programming, in which they operated not with separate instances of the functional blocks of technological equipment, with the corresponding binding of inputs and outputs, but with arrays of structures. For example, an array of a discrete input type structure. Or an array of an aggregate structure. This approach to programming has a right to exist, since it allows you to seriously save the working memory of the CPU, but,on the other hand, makes program code hard to read. A third-party programmer and with a simple look of a program on LAD can not figure it out right away, but heaps of indices, arrays, and functions for processing them are out of the question; here, without documentation for the software (and without a half liter, of course), nowhere.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These arrays of structures were typically processed in functions. In principle, nothing prevented the processing of function blocks, but there was always an important question - how to work with timers in these cases? Standard timers assume either a number (S5) or an instance of a function block (IEC). This, I remind you, is about processing arrays of structures for classic Simatic PLCs, and to ‚Äútwist‚Äù timer numbers into these structures, and even more so, instances are either difficult or simply impossible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For this reason, we created our own timer functionality as a function. In principle, for the operation of any timer, you need to know only a few things - the state of the input, the time setting and how much time has passed since activation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the 300 and 400 series, there were two ways to determine this time. </font><font style="vertical-align: inherit;">The first is to look at the runtime of the main OB1 (there is a corresponding variable in OB1 itself) or cyclic OBs and increase the internal time accumulator with each timer call, provided that the ‚Äútruth‚Äù is input. </font><font style="vertical-align: inherit;">Not a good option, since this time is different for OB1 and cyclic OBs. </font><font style="vertical-align: inherit;">The second method is the TIME_TCK system function, which, with each call, returned a single value - the internal millisecond counter of the central processor. </font></font><br>
<br>
<img src="https://sun9-40.userapi.com/c855036/v855036198/1f8065/UwCQvxh507k.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, for a timer of the TON type (on delay), the operation algorithm was as follows:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on the rising edge of the response request, reset the output and remember the current value of the system timer TIME_TCK</font></font></li>
<li>       ¬´¬ª          ,        (   ,  TIME_TCK    0  (2 ^ 31 ‚Äî 1),          ).   ,        .    ,    ¬´¬ª,    ‚Äî ¬´¬ª</li>
<li>      ¬´¬ª,   </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With the advent of the "thousandth" series, the situation has changed a bit. The fact is that the S7-1500 line inherited support for the TIME_TCK system call, and lovers of the ‚Äústanding and in a hammock‚Äù approach (how else can you call a program that just does it that processes arrays of structures, while operating with creepy indexes?) calmly continue to use their achievements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The S7-1200 series of base controllers is based on a different architecture, and it has a number of differences from the S7-1500. Including the lack of a TIME_TCK system call. In the ranks of developers who do not have sufficient flexibility of thinking, dissatisfaction has gone - it is impossible to execute copies / pastes of old programs. However, the task of determining how much time has passed since the previous call can be performed using the </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">runtime</font></a><font style="vertical-align: inherit;"> function</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This function returns the time elapsed since its previous call, in seconds, as a double precision real number LREAL. Details are described in the help. For internal purposes, an additional MEM variable (also of the LREAL type) is required. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will give the sources of the first approximation of the function, and I will give some notes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Function declaration:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">FUNCTION</span> "<span class="hljs-title">PerversionTON</span>" :</span> Void
<span class="hljs-comment">{ S7_Optimized_Access := 'TRUE' }</span>
VERSION : <span class="hljs-number">0.1</span><font></font>
   VAR_INPUT <font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//    </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_OUTPUT <font></font>
      Q : Bool;   <span class="hljs-comment">//  </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_IN_OUT <font></font>
      INPrv : Bool;<font></font>
      MEM : LReal;<font></font>
      TimeACC : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
   VAR_TEMP <font></font>
      udiCycle : UDInt;<font></font>
      udiPT : UDInt;<font></font>
   END_VAR<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With the inputs / outputs, everything is clear: IN, Q and PT. I set the time setting in the form of a real one, it's seconds. Just wanted to (but in vain, but more on that below). Further about variables of the InOut area. Since we have a function, we don‚Äôt have a STAT area, there are no variables that retain their value during the next function call, and such variables are needed: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INPrv - to determine the positive edge of the request </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MEM - auxiliary variable for the system call to work runtime </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TimeACC - time accumulator , which will store the number of microseconds of the currently running delay.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The variables TimeACC, udiCycle and udiPT are specified in the UDINT format, an unsigned integer, 4 bytes. </font><font style="vertical-align: inherit;">Despite the fact that I specified the time as real, and the runtime function returns real as much as double precision, I prefer to perform simple operations of summing and comparing with integer operands to save processor time. </font><font style="vertical-align: inherit;">Time in my case is taken into account to the microsecond. </font><font style="vertical-align: inherit;">The reason is simple - if you coarsen the time to a millisecond, then with almost empty OB1 (for example, if only one timer is called in the entire controller program and nothing more), ‚Äúskips‚Äù of cycles are possible, the program sometimes runs for 250 Œºs. </font><font style="vertical-align: inherit;">But in this case, the maximum allowable value of the time accumulator will be 4,294 seconds, almost 4,295 (2 ^ 32 - 1 = 4,294,967,295). </font><font style="vertical-align: inherit;">There is nothing to be done, such ‚Äúoptimization‚Äù requires sacrifice.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Function text.</font></font><br>
<br>
<pre><code class="delphi hljs">#udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
#udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">IF</span> (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> (<span class="hljs-keyword">NOT</span> #INPrv)) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//         </span>
    #TimeACC := <span class="hljs-number">0</span>;<font></font>
    #Q := FALSE;<font></font>
ELSIF (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> #INPrv) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//     ""</span>
    #TimeACC += #udiCycle; <span class="hljs-comment">//     "    "</span>
    <span class="hljs-keyword">IF</span> #TimeACC &gt;=  #udiPT <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//      </span>
        #Q := TRUE; <span class="hljs-comment">//  ""</span>
        #TimeACC := #udiPT; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//      </span>
        #Q := FALSE; <span class="hljs-comment">// </span><font></font>
    END_IF;<font></font>
<span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//    -      </span><font></font>
    #Q := FALSE;<font></font>
    #TimeACC := <span class="hljs-number">0</span>;<font></font>
END_IF;<font></font>
<font></font>
#INPrv := #<span class="hljs-keyword">IN</span>; <span class="hljs-comment">//  </span><font></font>
<font></font>
ENO := #Q; <span class="hljs-comment">// ENO         LAD  FBD</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first two lines are the recalculation of the timer setting from the number of seconds specified in the REAL format to the number of microseconds. </font><font style="vertical-align: inherit;">The time in microseconds elapsed from the previous program block call is also determined. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further, the algorithm is as follows, and I have already given it:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on the rising edge of input IN, reset output Q and reset the time accumulator</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if the ‚Äútruth‚Äù continues to be input, we increase the time accumulator by the already known udiCycle value and compare it with the time setting. </font><font style="vertical-align: inherit;">If the time setting is exceeded, the timer has worked, give the output ‚Äútrue‚Äù, otherwise, give the output ‚Äúfalse‚Äù</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the case of applying false input to the IN input, reset the Q output and reset the time accumulator.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the end of the function, in order to determine the edge of the input IN, remember its previous value. </font><font style="vertical-align: inherit;">Also give the output ENO (when using a function in graphical languages, such as LAD) the value of the output Q. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We make sure that the function is working, after which it becomes interesting to evaluate its speed and, if necessary, improve (it already appears at first glance that a number of calculations go to idle and wasting CPU time in vain). </font><font style="vertical-align: inherit;">To evaluate performance, I declare an array of 1000 timer data structures. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Declaration of the structure. </font><font style="vertical-align: inherit;">Its fields duplicate the input and output variables of the timer function.</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">TYPE</span> "typePervTONdata"<font></font>
VERSION : <span class="hljs-number">0.1</span><font></font>
   STRUCT<font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//   </span>
      Q : Bool;   <span class="hljs-comment">//  </span>
      INPrv : Bool;   <span class="hljs-comment">//    </span>
      MEM : LReal;   <span class="hljs-comment">//    </span>
      TimeACC : UDInt;   <span class="hljs-comment">//  </span><font></font>
   END_STRUCT;<font></font>
<font></font>
END_TYPE</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An array of structures is declared in the TortureTON global data block:</font></font><br>
<br>
<pre><code class="delphi hljs">TONs : <span class="hljs-keyword">Array</span>[<span class="hljs-number">0</span>..<span class="hljs-number">999</span>] <span class="hljs-keyword">of</span> "typePervTONdata";
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following code is executed in the organizational block OB1:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">FOR</span> #i := <span class="hljs-number">0</span> <span class="hljs-keyword">TO</span> <span class="hljs-number">999</span> <span class="hljs-keyword">DO</span>
    "TortureTON".TONs[#i].<span class="hljs-keyword">IN</span> := "startton";<font></font>
    "PerversionTON"(<span class="hljs-keyword">IN</span> := "TortureTON".TONs[#i].<span class="hljs-keyword">IN</span>,<font></font>
                    PT := "TortureTON".TONs[#i].PT,<font></font>
                    Q := "TortureTON".TONs[#i].Q,<font></font>
                    INPrv := "TortureTON".TONs[#i].INPrv,<font></font>
                    MEM := "TortureTON".TONs[#i].MEM,<font></font>
                    TimeACC := "TortureTON".TONs[#i].TimeACC);<font></font>
END_FOR;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Announced 1000 ‚Äúinstances‚Äù of timers, each set a time of 10 seconds. All 1000 timers start counting the time by the value of the startton marker variable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I launch the diagnostic functions of the controller (S7-1214C DC / DC / DC, version FW 4.4, version Step7 - V16) and watch the scan cycle time of the controller. At ‚Äúidle‚Äù (when ‚Äúfalse‚Äù arrives at the input of the timers), the entire thousand are processed on average for 36-42 milliseconds. During the countdown of ten seconds, this reading grows by about 6-8 milliseconds and sometimes rolls over for 50 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We look at what can be improved in the function code. Firstly, the lines at the very beginning of the program block:</font></font><br>
<br>
<pre><code class="delphi hljs">#udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
#udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
They are always called, regardless of whether the timer counts the time, does not count, or has already counted. A big waste of money is to load the not very powerful CPU of the 1200 series with calculations involving double precision materials. It is reasonable to transfer both lines to the part of the code that processes the countdown (if the ‚Äútruth‚Äù continues to come in). It is also necessary to duplicate the udiCycle calculation into a code that processes a positive edge at the input of the timer. This should relieve the ‚Äúidle operation‚Äù of the timer when the input value is false. In practice, timers in programmable logic controllers most often work ‚Äúidle‚Äù. For example, the filtering time of contact bounce is tens of milliseconds. The control pulse of a discrete output is a few hundred milliseconds, usually from 0.5 to 1.0 seconds.The time for monitoring the execution of the unit command (for example, the time the valve opens completely) is from tens of seconds to several minutes. PLC in production works 24 hours a day and 365 (and sometimes more!) Days a year. That is, most often the input of the timer is either ‚Äúzero‚Äù, and the timer does not count anything, or a ‚Äúunit‚Äù arrives for a long time, and the timer has already counted everything. To unload the second-stage CPU idle (the timer has already counted), it is necessary to check at the stage ‚Äúthe input continues to receive the truth‚Äù - if the timer has already counted all the time and set the output to true. In this case, no calculations should be performed.most often the input of the timer is either ‚Äúzero‚Äù, and the timer does not count anything, or a ‚Äúunit‚Äù arrives for a long time, and the timer has already counted everything. To unload the second-stage CPU idle (the timer has already counted), it is necessary to check at the stage ‚Äúthe input continues to receive the truth‚Äù - if the timer has already counted all the time and set the output to true. In this case, no calculations should be performed.most often the input of the timer is either ‚Äúzero‚Äù, and the timer does not count anything, or a ‚Äúunit‚Äù arrives for a long time, and the timer has already counted everything. To unload the second-stage CPU idle (the timer has already counted), it is necessary to check at the stage ‚Äúthe input continues to receive the truth‚Äù - if the timer has already counted all the time and set the output to true. In this case, no calculations should be performed.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To make these changes, it is necessary to transfer the output of the Q timer from the OUTPUT area to the IN_OUT area, and the output value will be stored in external variables (in this example, in an array of structures). After refinement, the entire function code, including the declaration, is as follows:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">FUNCTION</span> "<span class="hljs-title">PerversionTON</span>" :</span> Void
<span class="hljs-comment">{ S7_Optimized_Access := 'TRUE' }</span>
VERSION : <span class="hljs-number">0.1</span><font></font>
   VAR_INPUT <font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//    </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_IN_OUT <font></font>
      Q : Bool;   <span class="hljs-comment">//  </span><font></font>
      INPrv : Bool;<font></font>
      MEM : LReal;<font></font>
      TimeACC : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
   VAR_TEMP <font></font>
      udiCycle : UDInt;<font></font>
      udiPT : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">BEGIN</span>
	<span class="hljs-keyword">IF</span> (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> (<span class="hljs-keyword">NOT</span> #INPrv)) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//         </span>
	    #TimeACC := <span class="hljs-number">0</span>;<font></font>
	    #Q := FALSE;<font></font>
	    #udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">// " "  </span>
	ELSIF (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> #INPrv) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//     ""</span>
	    <span class="hljs-keyword">IF</span> (<span class="hljs-keyword">NOT</span> #Q) <span class="hljs-keyword">THEN</span>
	        #udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
	        #udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span>
	        #TimeACC += #udiCycle; <span class="hljs-comment">//     "    "</span>
	        <span class="hljs-keyword">IF</span> #TimeACC &gt;= #udiPT <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//      </span>
	            #Q := TRUE; <span class="hljs-comment">//  ""</span>
	            #TimeACC := #udiPT; <span class="hljs-comment">//  </span><font></font>
	        END_IF;<font></font>
	    END_IF;<font></font>
	<span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//    -      </span><font></font>
	    #Q := FALSE;<font></font>
	    #TimeACC := <span class="hljs-number">0</span>;<font></font>
	END_IF;<font></font>
	<font></font>
	#INPrv := #<span class="hljs-keyword">IN</span>; <span class="hljs-comment">//  </span><font></font>
	<font></font>
	ENO := #Q; <span class="hljs-comment">// ENO         LAD  FBD</span><font></font>
END_FUNCTION<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After that, the execution time improves: the idle time processing of the timers is 23 ms, with a working filtering time of 37-40 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This function code does not check for an invalid value of the timer setting - a negative value (when the material is converted to an unsigned integer, the setting will be distorted) or a value greater than 4294.9 seconds (the time setting will overflow and distort). You must either control the value of the PT value in the code, or entrust the task of checking the range of the time setting (from 0 to 4294.9 seconds) to the top-level operator system. Checking the range by means of the PLC program increases the processing time to approximately 45-46 ms (and, in general, the most correct way is to set the timer time not in REAL format, but in UDINT format in milliseconds and to do nonsense).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The application project with a timer for the TIA Portal Step 7 version 16 environment is available </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en491188/index.html">What the backend tester should know</a></li>
<li><a href="../en491190/index.html">Creating an Online Store on Nuxt.js 2 Walkthrough Part 3</a></li>
<li><a href="../en491192/index.html">Figmiro. Making a plugin for Figma (and a little bit for Miro)</a></li>
<li><a href="../en491194/index.html">Genetics of origin. Population composition</a></li>
<li><a href="../en491198/index.html">Six tips for making the right game tutorial</a></li>
<li><a href="../en491202/index.html">Engineers vs. Designers</a></li>
<li><a href="../en491208/index.html">7 habits that will turn any introvert into a master of communication</a></li>
<li><a href="../en491210/index.html">Mini-series of videos with character animation about the bully game Monster Hustle</a></li>
<li><a href="../en491212/index.html">Oil and vodka: how do we get rid of stickers from laptops</a></li>
<li><a href="../en491214/index.html">9 strategies for marketing mobile games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>