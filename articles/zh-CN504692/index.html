<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏾 🧕 🕋 ZFS基础知识：存储和性能 🈶 📜 👷🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今年春天，我们已经讨论了一些入门主题，例如如何检查磁盘速度以及RAID是什么。在它们的第二个中，我们甚至承诺继续研究ZFS中各种多磁盘拓扑的性能。这是下一代文件系统，从Apple到Ubuntu，到处都有实现。
 
 好吧，今天是了解ZFS的最佳日子，好奇的读者。请注意，根据OpenZFS开发人员Ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ZFS基础知识：存储和性能</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504692/"><img src="https://habrastorage.org/getpro/habr/post_images/abf/883/e96/abf883e96b01dbc78420e0dc1a158460.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今年春天，我们已经讨论了一些入门主题，例如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何检查磁盘速度</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAID是什么</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在它们的第二个中，我们甚至承诺继续研究ZFS中各种多磁盘拓扑的性能。</font><font style="vertical-align: inherit;">这是下一代文件系统，从</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubuntu，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到处都有实现</font><font style="vertical-align: inherit;">。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，今天是了解ZFS的最佳日子，好奇的读者。</font><font style="vertical-align: inherit;">请注意，根据OpenZFS开发人员Matt Arens的保守评估，“它确实很复杂”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，在得出数字之前，我保证，对于所有变种vosmidiskovoy ZFS配置，您都需要讨论</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行ZFS在磁盘上存储数据。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zpool，vdev和设备</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/674/1c6/ab3/6741c6ab310f4e0edf2adf7e2ca4c6bb.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这个完整的池图包括三个辅助vdev，每个类一个，四个RAIDz2，</font></font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b9f/82c/887/b9f82c88748c44d1f86cc412a053bf94.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常没有理由创建不适当的</font></font></font></i><font style="vertical-align: inherit;"><i><font color="gray"><font style="vertical-align: inherit;">vdev </font></font></i><i><font color="gray"><font style="vertical-align: inherit;">类型和大小的池-但是，如果您愿意，没有什么可以阻止您这样做的。</font></font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
要真正了解ZFS文件系统，您需要仔细查看其实际结构。</font><font style="vertical-align: inherit;">首先，ZFS将传统级别的卷管理和文件系统结合在一起。</font><font style="vertical-align: inherit;">其次，它在写入时使用事务复制机制。</font><font style="vertical-align: inherit;">这些功能意味着该系统在结构上与普通文件系统和RAID阵列有很大不同。</font><font style="vertical-align: inherit;">需要了解的第一组基本构建块：存储池（zpool），虚拟设备（vdev）和实际设备（设备）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zpool</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
zpool存储池是最顶层的ZFS结构。每个池包含一个或多个虚拟设备。反过来，它们每个都包含一个或多个实际设备（设备）。虚拟池是自治块。一台物理计算机可能包含两个或多个单独的池，但是每个池完全独立于其他池。池不能共享虚拟设备。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS的冗余是在虚拟设备级别，而不是在池级别。在池级别上，绝对没有冗余-如果丢失了任何vdev驱动器或特殊的vdev，则整个池也会随之丢失。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现代存储池可以在丢失高速缓存或虚拟设备日志的情况下幸免-尽管如果在断电或系统崩溃期间丢失vdev日志，它们可能会丢失少量脏数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
常见的误解是ZFS的“数据带”（条带）记录在整个池中。这不是真的。 Zpool根本不是一个有趣的RAID0，它是一个有趣的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JBOD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，具有复杂的可变分发机制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在大多数情况下，条目是根据可用空间在可用虚拟设备之间分配的，因此从理论上讲，它们将同时填充。在更高版本的ZFS中，考虑了vdev的当前使用（利用率）-如果一个虚拟设备的负载比另一个虚拟设备的负载大得多（例如，由于读取负载），尽管存在最高可用空间系数，但仍会暂时跳过该虚拟设备的写入操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内置于现代ZFS记录分发方法中的回收检测机制可以减少异常高负载期间的等待时间并提高吞吐量-但这不是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">万能的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一个池中非自愿地混合慢速硬盘和快速固态硬盘。</font><font style="vertical-align: inherit;">这样的不平等池仍将以最慢的设备的速度工作，也就是说，好像它完全由此类设备组成。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vdev</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个存储池均包含一个或多个虚拟设备（虚拟设备，vdev）。</font><font style="vertical-align: inherit;">每个vdev依次包含一个或多个实际设备。</font><font style="vertical-align: inherit;">大多数虚拟设备用于轻松存储数据，但是有多个辅助vdev类，包括CACHE，LOG和SPECIAL。</font><font style="vertical-align: inherit;">这些vdev类型中的每一种都可以具有五种拓扑之一：单设备，RAIDz1，RAIDz2，RAIDz3或镜像。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAIDz1，RAIDz2和RAIDz3是旧时所说的RAID双（对角）奇偶校验的特殊变体。 1、2和3表示为每个数据段分配了多少个奇偶校验块。虚拟RAIDz设备将奇偶校验均匀分布在各个磁盘上，而不是使用单独的磁盘进行奇偶校验。 RAIDz阵列可能丢失具有奇偶校验块的磁盘；如果他输了另一个，他将失败并带走存储池。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在镜像的虚拟设备（镜像vdev）中，每个块都存储在vdev中的每个设备上。尽管最常见的两幅宽镜面，但镜中可以有任意数量的设备-在大型安装中，通常使用三层镜来提高读取性能和容错能力。当vdev中的至少一台设备继续工作时，vdev镜像可以承受任何故障。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
单个vdev本质上是危险的。这样的虚拟设备将无法幸免单个故障-如果将其用作存储设备或特殊的vdev，则其故障将导致整个池的破坏。在这里要非常非常小心。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以使用上述任何一种拓扑来创建CACHE，LOG和SPECIAL虚拟设备-但请记住，丢失SPECIAL虚拟设备意味着丢失池，因此强烈建议使用过多的拓扑。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设备</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在ZFS中，这可能是最容易理解的术语-实际上，它是一个块随机访问设备。请记住，虚拟设备由单个设备组成，而池则由虚拟设备组成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
磁盘-磁性或固态磁盘-是用作vdev构建块的最常见的块设备。但是，任何在/ dev中带有句柄的设备都适用-因此，您可以将整个硬件RAID阵列用作单独的设备。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个简单的原始文件是可以构建vdev的最重要的替代块设备之一。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">稀疏文件中的</font></a><font style="vertical-align: inherit;">测试池</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;-一种非常方便的方式来检查池命令，并查看此拓扑的池或虚拟设备中有多少可用空间。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5cf/aa5/62c/5cfaa562cb208b654af113f7535b8f57.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以在短短几秒钟内从稀疏文件创建测试池-但不要忘记稍后删除整个池及其组件。</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
假设您要将服务器放在八个磁盘上，并计划使用10 TB磁盘（〜9300 GiB）-但是您不确定拓扑最适合您的需求。在上面的示例中，在短短的几秒钟内，我们从稀疏文件中构建了一个测试池-现在我们知道，来自八个10 TB驱动器的RAIDz2 vdev提供了50 TiB的可用容量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一类特殊的设备是SPARE（备用）。与常规设备不同，热交换设备属于整个池，而不仅仅是一个虚拟设备。如果池中的某些vdev发生故障，并且备用设备已连接到池且可用，则它将自动加入受影响的vdev。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
连接到受影响的vdev后，备用设备将开始接收丢失设备上应有的数据副本或重建数据。在传统RAID中，这称为重建，而在ZFS中，其称为“重新同步”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要的是要注意，替换设备不会永久替换故障设备。</font><font style="vertical-align: inherit;">这只是临时替换，以减少观察到vdev降级的时间。</font><font style="vertical-align: inherit;">管理员更换发生故障的vdev设备后，将冗余恢复到该永久设备，并且SPARE与vdev断开连接，并作为整个池的备用设备恢复工作。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据集，块和扇区</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们通过ZFS的过程中，您需要了解的下一组构建块不是太多的硬件，而是数据的组织和存储方式。</font><font style="vertical-align: inherit;">我们在这里跳过了几个层次（例如metaslab），以免在保持对整体结构的理解的同时不堆积细节。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据集</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/bd3/c48/d9d/bd3c48d9dff6e0f493a5d90d1dca6d1d.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我们第一次创建数据集时，它将显示所有可用的池空间。然后我们设置配额-并更改安装点。魔法！</font></font></font></i> <br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a18/3de/210/a183de210cdc57cd1421652201cbf2c3.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zvol在大多数情况下只是一个数据集，没有文件系统层，在这里我们将其替换为完全普通的ext4</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
文件系统，ZFS数据集与标准挂载文件系统大致相同。乍看之下，就像常规文件系统一样，它似乎只是“另一个文件夹”。而且，与常规挂载文件系统一样，每个ZFS数据集都有其自己的基本属性集。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，数据集可以具有分配的配额。如果已安装</font></font><code>zfs set quota=100G poolname/datasetname</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则您写入的文件夹不能</font></font><code>/poolname/datasetname</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超过100 GiB。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意每行开头是否存在斜杠？每个数据集在ZFS层次结构和系统安装层次结构中都有其自己的位置。 ZFS层次结构中没有斜杠-您从池的名称开始，然后是从一个数据集到下一个数据集的路径。例如，</font></font><code>pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于</font><font style="vertical-align: inherit;">在广告素材池中</font></font><code>child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">父数据</font><font style="vertical-align: inherit;">集</font><font style="vertical-align: inherit;">下</font><font style="vertical-align: inherit;">命名</font><font style="vertical-align: inherit;">的数据集</font></font><code>parent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其名称为Creative </font></font><code>pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
默认情况下，数据集的安装点将等效于其名称在ZFS层次结构中，并在其开始处带有斜杠-名称为的池</font></font><code>pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装为</font></font><code>/pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，数据集</font></font><code>parent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装在</font></font><code>/pool/parent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，子</font><font style="vertical-align: inherit;">数据集</font><font style="vertical-align: inherit;">安装</font></font><code>child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>/pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是，可以更改数据集的系统安装点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们指出</font></font><code>zfs set mountpoint=/lol pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后将数据集作为</font></font><code>pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">装入系统中</font></font><code>/lol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了数据集，我们还应该提到体积（zvols）。</font><font style="vertical-align: inherit;">卷实际上与数据集大致相似，不同之处在于它实际上没有文件系统-它只是一个块设备。</font><font style="vertical-align: inherit;">例如，您可以</font></font><code>zvol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用name </font><font style="vertical-align: inherit;">创建</font></font><code>mypool/myzvol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后使用ext4文件系统对其进行格式化，然后挂载此文件系统-现在您有了ext4文件系统，但支持所有ZFS安全功能！</font><font style="vertical-align: inherit;">这在一台计算机上看似很愚蠢，但在导出iSCSI设备时作为后端更有意义。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">积木</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/74b/4dd/d00/74b4ddd009e67db1b1b6c4467bcf6fa3.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个文件由一个或多个块表示。每个块都存储在一个虚拟设备上。块大小通常等于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recordsize</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数</font><font style="vertical-align: inherit;">，但</font><font style="vertical-align: inherit;">如果它包含元数据或小文件</font><font style="vertical-align: inherit;">，则可以减小到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 ^ ashift</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8d1/7fd/ad2/8d17fdad2eda641c801e5e6a302f6e38.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们真的，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真的是</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不开玩笑了巨大的性能损害，如果你安装过小ashift</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在ZFS池，所有的数据，包括元数据，存储在块。每个数据集的最大块大小在属性</font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（记录大小）中</font><font style="vertical-align: inherit;">定义</font><font style="vertical-align: inherit;">。记录的大小可能会有所不同，但这不会更改已写入数据集的任何块的大小或位置-仅在写入新块时才有效。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除非另有说明，否则默认情况下，当前记录大小为128 KiB。这是一种困难的折衷，在这种折衷中，性能并不理想，但在大多数情况下并不可怕。</font></font><code>Recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以将其设置为4K到1M之间的任何值（通过其他设置，</font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以设置更多值，但这不是一个好主意）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任何块都仅指一个文件的数据-您不能将两个不同的文件压缩到一个块中。每个文件由一个或多个块组成，具体取决于大小。如果文件大小小于记录大小，则将文件保存在较小的块中-例如，具有2 KiB文件的块将仅占用磁盘上的一个4 KiB扇区。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果文件足够大并且需要几个块，则该文件的所有记录都将具有大小</font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;-包括最后一条记录，该记录的主要部分可能是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未使用的空间</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zvol卷没有属性</font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;-而是具有等效的属性</font></font><code>volblocksize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部门</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，最基本的组成部分是该部门。这是可以写入或读取基本单元的最小物理单元。几十年来，大多数磁盘使用512字节扇区。最近，大多数驱动器配置用于4 KiB扇区，在某些驱动器中，尤其是SSD，配置了8 KiB甚至更多扇区。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS具有允许您手动设置扇区大小的属性。这是一个属性</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。转移是二的幂，这有点令人困惑。例如，这</font></font><code>ashift=9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意味着扇区大小为2 ^ 9，即512字节。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当将每个块设备添加到新的vdev中时，ZFS会要求操作系统提供有关每个块设备的详细信息，并且理论上会根据该信息自动正确地设置移位。不幸的是，许多驱动器都依赖于其扇区大小，以保持与Windows XP的兼容性（Windows XP无法理解其他扇区大小的驱动器）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着强烈建议ZFS管理员知道其设备的实际扇区大小并手动安装</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果设置的移位太小，则读/写操作的数量将急剧增加。因此，将512字节的“扇区”写入实际的4 KiB扇区意味着写入第一个“扇区”，然后读取4 KiB扇区，将其更改为第二个512字节的“扇区”，然后将其写回到新的4 KiB扇区，依此类推。对于每个条目。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在现实世界中，这种惩罚超过了三星EVO </font></font><code>ashift=13</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSD </font><font style="vertical-align: inherit;">，它必须为此采取行动</font><font style="vertical-align: inherit;">，但是这些SSD取决于其扇区大小，因此默认情况下将其设置</font></font><code>ashift=9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果经验丰富的系统管理员没有更改此设置，则此SSD的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速度将比</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常规磁性HDD </font><i><font style="vertical-align: inherit;">慢</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了比较，尺寸太大</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几乎没有罚款。</font><font style="vertical-align: inherit;">生产力并没有真正的降低，并且未使用空间的增加是无限小的（在启用压缩的情况下等于零）。</font><font style="vertical-align: inherit;">因此，我们强烈建议甚至安装那些真正使用512字节扇区的驱动器，</font></font><code>ashift=12</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或者甚至</font></font><code>ashift=13</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对未来充满信心。</font><font style="vertical-align: inherit;">许多人错误地认为，</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该属性是</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为每个vdev虚拟设备而</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是为池设置的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且在安装后不会更改。</font><font style="vertical-align: inherit;">如果您</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在向池中添加新的vdev时</font><font style="vertical-align: inherit;">不小心将其关闭</font><font style="vertical-align: inherit;">，则您将使用性能低下的设备对该池进行了不可挽回的污染，通常，除了销毁池并重新开始之外，别无其他方法。</font><font style="vertical-align: inherit;">即使删除vdev也不会使您摆脱损坏的设置</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br>
<br>
<h3>   </h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/38b/a1e/4a8/38ba1e4a8fa0e255081ed8db259a302f.gif"><br>
<i><font color="gray">      &nbsp;—     ,   </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/90d/4cb/a35/90d4cba35ffa5a3e44a7ca5f61d4491b.gif"><br>
<i><font color="gray">         ,     </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c8b/2af/ffb/c8b2afffbc46f63f6a7fe1167edf5dcb.gif"><br>
<i><font color="gray">  ,      ,   « »   « »,        </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4c1/e2b/818/4c1e2b818077cb07d651527e214363fe.gif"><br>
<i><font color="gray">     ,       —      ,     ,       </font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
写时复制（CoW）是使ZFS如此出色的基本基础。基本概念很简单-如果您要求传统文件系统修改文件，它将按照您的要求进行操作。如果您要求在录制过程中进行复制的文件系统也这样做，它将说“好”-但这对您来说是骗人的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
相反，复制-写入文件系统将写入修改后的块的新版本，然后更新文件元数据以断开与旧块的链接，并将您刚刚写入其中的新块关联起来。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
断开旧单元的连接并连接新单元是一次操作，因此它不会被打断-如果您在这种情况发生后重新设置电源，则文件具有新版本，而如果您较早地重新设置电源，则您具有旧版本。</font><font style="vertical-align: inherit;">无论如何，文件系统都不会发生冲突。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
写入ZFS时的复制不仅发生在文件系统级别，而且发生在磁盘管理级别。</font><font style="vertical-align: inherit;">这意味着ZFS不受记录空间的限制（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAID中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">孔</font></a><font style="vertical-align: inherit;">）-这种现象是当条带仅在系统崩溃之前设法部分记录时，重新启动后阵列会损坏。</font><font style="vertical-align: inherit;">在这里，剥离是原子的，vdev始终是一致的，而</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bob是您的叔叔</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZIL：ZFS意图日志</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/567/71c/73f/56771c73f9a28ebaed161e02313deadb.png"><br>
<i><font color="gray"> ZFS     &nbsp;—  ,      ZIL,            </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/cec/7c5/437/cec7c5437087f6816f9cdea5f6829820.png"><br>
<i><font color="gray"> ,   ZIL,    .      </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/075/65a/d6b/07565ad6b2f431db3e6bc20cd24a653b.png"><br>
<i><font color="gray">SLOG,   LOG-, —   &nbsp;— , ,  &nbsp;—&nbsp;vdev,  ZIL      </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/927/0f7/539/9270f7539b759aa37896d41e04c4ec47.png"><br>
<i><font color="gray">      ZIL &nbsp;—    ZIL   SLOG,      </font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
写入操作主要分为两类-同步（同步）和异步（异步）。对于大多数工作负载，绝大多数写操作都是异步的-文件系统使您可以聚合它们并分批交付它们，从而减少碎片并显着提高吞吐量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同步录音是完全不同的事情。当应用程序请求同步写入，它告诉文件系统：“你需要提交这非易失性存储器</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，现在</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在那之前我可以更什么都不做。”因此，同步记录应立即提交到磁盘-如果增加碎片或减少带宽，那就也是如此。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS对同步记录的处理方式不同于常规文件系统-ZFS不会立即将它们上传到常规存储中，而是将它们记录在称为ZFS意向日志（ZFS意向日志或ZIL）的特殊存储区域中。诀窍在于，这些记录</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保留在内存中，并与常规的异步写入请求一起聚合，然后作为完全正常的TXG（事务组，事务组）转储到存储中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在正常操作中，将记录ZIL，并且不再读取。片刻之后，如果将来自ZIL的记录固定在普通TXG中的RAM的主存储器中，则它们与ZIL断开连接。从ZIL读取内容时，唯一的事情就是导入池。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果ZFS崩溃-操作系统崩溃或断电-当ZIL中有数据时，该数据将在下一次导入池时读取（例如，紧急系统重启时）。 ZIL中的所有内容都将被读取，合并为TXG组，提交到主存储，然后在导入过程中与ZIL断开连接。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
vdev帮助程序类之一称为LOG或SLOG，即辅助LOG设备。他的任务是-为池提供一个单独的（最好更快），具有很高的写电阻的vdev设备，用于存储ZIL，而不是将ZIL存储在主vdev存储中。 ZIL本身的行为与存储位置无关，但是如果带LOG的vdev具有很高的写入性能，则同步写入会更快。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将具有LOG的vdev添加到池中</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提高异步写入性能-即使您使用强制对ZIL进行所有写入</font></font><code>zfs set sync=always</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它们仍将以与没有日志时相同的方式和速度与TXG中的主存储库绑定。</font><font style="vertical-align: inherit;">唯一直接的性能改进是同步记录中的延迟（因为更高的日志速度可加快操作速度</font></font><code>sync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，在已经需要大量同步写入的环境中，vdev LOG可以间接加速异步写入和未缓存的读取。</font><font style="vertical-align: inherit;">将ZIL记录上传到单独的vdev LOG意味着在主存储中对IOPS的竞争较少，这在一定程度上提高了所有读取和写入操作的性能。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快照</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
写复制机制还是原子ZFS快照和增量异步复制的必要基础。</font><font style="vertical-align: inherit;">活动文件系统具有一个指针树，该指针树用当前数据标记所有记录-拍摄快照时，您只需复制该指针树即可。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当活动文件系统中的记录被覆盖时，ZFS首先将块的新版本写入未使用的空间。</font><font style="vertical-align: inherit;">然后，它将旧版本的块与当前文件系统分离。</font><font style="vertical-align: inherit;">但是，如果某些快照引用了旧块，则它仍然保持不变。</font><font style="vertical-align: inherit;">直到所有链接到该块的快照都被销毁为止，旧块才真正恢复为可用空间！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复写</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/e69/167/01d/e6916701d4aa3ff27bb42efc43be60da.png"><br>
<i><font color="gray">  Steam  2015   158&nbsp;   126&nbsp;927 .        rsync&nbsp;—  ZFS    « »  750% .</font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/25f/376/0ab/25f3760ab64d6647571b9c02804b39f0.png"><br>
<i><font color="gray">      40-     Windows 7&nbsp;—   .  ZFS   289  ,  rsync&nbsp;—  «»  161  ,    ,   rsync   --inplace.</font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/776/46b/a3a/77646ba3ac20eeb0933d7dc7d644296c.png"><br>
<i><font color="gray">    ,  rsync    .  1,9         &nbsp;—    ,   ZFS   1148  ,  rsync,    rsync --inplace</font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一旦了解了快照的工作原理，就很容易掌握复制的本质。由于快照只是指向记录的指针的树，因此，如果我们创建</font></font><code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快照，则将发送此树以及与其关联的所有记录。当我们通过此</font></font><code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>zfs receive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目标对象，它写入的块的两端的实际内容和引用该块到目标数据指针集合树。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二件事变得更加有趣</font></font><code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。现在我们有两个系统，每个系统都包含</font></font><code>poolname/datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您可以拍摄一个新的快照</font></font><code>poolname/datasetname@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，在源池中有</font></font><code>datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>datasetname@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在目标池中到目前为止只有第一个快照</font></font><code>datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我们在源和目标之间有一个共同的快照</font></font><code>datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们可以</font><font style="vertical-align: inherit;">在此基础上</font><font style="vertical-align: inherit;">进行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增量</font></font></i> <code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。当我们告诉系统时</font></font><code>zfs send -i poolname/datasetname@1 poolname/datasetname@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它会比较两个指针树。</font></font><code>@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然，</font><font style="vertical-align: inherit;">仅存在于中的任何指针都</font><font style="vertical-align: inherit;">引用新块-因此我们需要这些块的内容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在远程系统上，增量处理</font></font><code>send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样简单。首先，我们记录流中包含的所有新条目</font></font><code>send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后将指针添加到这些块。瞧，在我们的</font></font><code>@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新系统中！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS异步增量复制是对rsync之类的早期非快照方法的巨大改进。在这两种情况下，仅传输更改的数据-但必须先</font><i><font style="vertical-align: inherit;">读取</font></i><font style="vertical-align: inherit;"> rsync</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从磁盘两侧的所有数据中检查数据量并进行比较。</font><font style="vertical-align: inherit;">相比之下，ZFS复制只读取指针树-以及常规快照中未表示的任何块。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内联压缩</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
写入时复制机制还简化了内置压缩系统。在传统的文件系统中，压缩存在问题-更改后的数据的旧版本和新版本都位于同一空间中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您考虑一个文件中间的一条数据，该数据以0x00000000的兆字节零开始存储，依此类推-将其压缩到磁盘上的一个扇区非常容易。但是，如果用兆字节不可压缩的数据（例如JPEG或伪随机噪声）替换此兆字节的零，会发生什么情况呢？突然，这一兆字节的数据将不需要一个，而是需要256个4 KiB的扇区，并且在磁盘上的此位置仅保留了一个扇区。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS不会出现这样的问题，因为更改后的记录始终会写入未使用的空间-原始块仅占用一个4 KiB扇区，而一条新记录将占用256，但这不是问题-最近更改的文件“中间”部分将被写入未使用的空间不管其大小是否已更改，因此对于ZFS来说都是正常情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
默认情况下，内置ZFS压缩是禁用的，并且系统提供了插件算法-现在包括LZ4，gzip（1-9），LZJB和ZLE。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LZ4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一种流算法，即使在相当慢的CPU上，也能在大多数情况下提供极快的压缩和解压缩性能，并获得性能提升。</font></font><br>
</li>
<li><b>GZIP</b> —  ,       Unix-.        1-9,       CPU      9.       (   )  ,    &nbsp;   c CPU&nbsp;—    ,     .<br>
</li>
<li><b>LZJB</b> —    ZFS.       , LZ4     .<br>
</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZLE-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">零级编码，零级编码。</font><font style="vertical-align: inherit;">它根本不涉及正常数据，但是压缩大的零序列。</font><font style="vertical-align: inherit;">对于完全不可压缩的数据集（例如JPEG，MP4或其他已经压缩的格式）很有用，因为它会忽略不可压缩的数据，但会压缩结果记录中未使用的空间。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们建议几乎所有用例都使用LZ4压缩。</font><font style="vertical-align: inherit;">遇到不可压缩数据的性能损失非常小，并且</font><font style="vertical-align: inherit;">典型数据</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">性能</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增益</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显着。</font><font style="vertical-align: inherit;">在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">此2015年测试中</font></a><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">为新安装的Windows操作系统（新安装的OS，尚无数据）复制虚拟机映像的</font></font><code>compression=lz4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速度比</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">此方法</font></a><font style="vertical-align: inherit;">快27％</font><font style="vertical-align: inherit;">。</font></font><code>compression=none</code><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARC-自适应替换缓存</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS是我们已知的唯一现代文件系统，它使用自己的读取缓存机制，并且不依赖操作系统页面缓存将最近读取的块的副本存储在RAM中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管其自身的缓存并非没有问题-ZFS不能像内核一样快地响应新的内存分配请求，所以如果新的</font></font><code>malloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存分配</font><font style="vertical-align: inherit;">调用</font><font style="vertical-align: inherit;">需要ARC当前占用的RAM，则它可能会失败。</font><font style="vertical-align: inherit;">但是至少在目前，有充分的理由使用自己的缓存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有著名的现代操作系统，包括MacOS，Windows，Linux和BSD，都使用LRU算法（最近最少使用）来实现页面缓存。这是一种原始算法，它在每次读取后将高速缓存的块“上移”，并根据需要将“下行队列”的块推入以增加新的高速缓存未命中（应该从磁盘读取而不是从高速缓存中读取的块）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，该算法可以正常工作，但是在具有大量工作数据集的系统上，LRU容易导致抖动-挤出经常需要的块以腾出空间，以容纳不再从缓存中再次读取的块。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弧</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;-天真得多的算法，可以将其视为“加权”缓存。每次读取缓存的块后，它都会变得“重”一点，并且变得更难挤出-甚至在挤出</font><font style="vertical-align: inherit;">一定时间</font><font style="vertical-align: inherit;">后仍会</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跟踪</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该块</font><font style="vertical-align: inherit;">。已被挤出但随后需要读回高速缓存的块也将变得“更重”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这一切的最终结果是命中率高得多的缓存-命中率（从缓存中读取）与未命中（从磁盘中读取）之间的比率。</font><font style="vertical-align: inherit;">这是非常重要的统计信息-不仅缓存命中本身的速度要快几个数量级，而且缓存命中的速度也可以更快，因为缓存命中次数越多，并发磁盘请求越少，应该处理的其余未命中的延迟就越少驾驶。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在研究了ZFS的基本语义（写时如何复制以及存储池，虚拟设备，块，扇区和文件之间的关系）之后，我们准备讨论具有实数的实际性能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在下一部分中，我们将比较带镜像的vdev和RAIDz的池的实际性能，以及彼此之间的比较，以及与我们</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之前</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">过的</font></a><font style="vertical-align: inherit;">传统Linux内核RAID拓扑的比较</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初，我们只想考虑基础知识-ZFS拓扑本身-但在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之后，</font><font style="vertical-align: inherit;">我们将准备讨论更高级的ZFS调优和调优，包括使用辅助vdev类型，例如L2ARC，SLOG和特殊分配。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN504680/index.html">SpaL的NLP库概述</a></li>
<li><a href="../zh-CN504682/index.html">怀旧邮报：j2me，重力定义，64kb</a></li>
<li><a href="../zh-CN504686/index.html">如何画猫</a></li>
<li><a href="../zh-CN504688/index.html">面具没用：KOVID-19对社会政策的科学批评</a></li>
<li><a href="../zh-CN504690/index.html">我如何在React和React Native第3部分上配置Azure AD B2C的故事（教程）</a></li>
<li><a href="../zh-CN504694/index.html">如何编译装饰器-C ++，Python及其自身的实现。第1部分</a></li>
<li><a href="../zh-CN504696/index.html">来自OpenStreetMap 513世界的新闻（12.05.2020-18.05.2020）</a></li>
<li><a href="../zh-CN504698/index.html">在远程站点上入职</a></li>
<li><a href="../zh-CN504700/index.html">苏联图形平板“素描”</a></li>
<li><a href="../zh-CN504702/index.html">人们不想英语</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>