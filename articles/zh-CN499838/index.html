<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦒 🤚🏽 🧑🏽‍🤝‍🧑🏽 .NET：依赖关系处理 👨‍👨‍👦‍👦 🎳 👨🏼‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="谁没有由于程序集重定向而遇到问题？最有可能的是，开发相对较大的应用程序的每个人迟早都会遇到此问题。
 
 现在，我在JetBrains Rider项目的JetBrains工作，并参与了将Rider迁移到.NET Core的任务。以前在Circuit（基于云的应用程序托管平台）中从事共享基础结构的工作...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.NET：依赖关系处理</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/499838/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谁没有由于程序集重定向而遇到问题？</font><font style="vertical-align: inherit;">最有可能的是，开发相对较大的应用程序的每个人迟早都会遇到此问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我在JetBrains Rider项目的JetBrains工作，并参与了将Rider迁移到.NET Core的任务。</font><font style="vertical-align: inherit;">以前在Circuit（基于云的应用程序托管平台）中从事共享基础结构的工作。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/je/f5/e-/jef5e-nc0okqm_ssla0qhniugio.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在过场动画的下面是我在DotNext 2019莫斯科会议上的报告的笔录，在那次会议上我谈到了在.NET中使用程序集时遇到的困难，并通过实际示例演示了会发生什么以及如何处理它。</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/fMlTLw1agE0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我作为.NET开发人员工作的所有项目中，我都不得不处理连接依赖项和加载程序集的各种问题。</font><font style="vertical-align: inherit;">我们将讨论这个。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">职位结构：</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依赖问题</font></font></b></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">严格的钻机装载</font></font></b></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绑定重定向</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强大的命名</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET核心</font></font></a></b> <br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共享框架.runtimeconfig.json</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依赖清单（.deps.json）</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Core上运行JetBrains Rider的技巧</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调试程序集下载</font></font></a> </b><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">融合日志</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行时事件</font></font></a></li>
</ul><br>
</li>
</ol><br>
<a name="problems"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有哪些依赖性问题？</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当他们在2000年代初开始开发.NET Framework时，所有库中的开发人员都允许中断更改，并且这些库变得与已编译的代码不兼容时，就已经知道Dependency hell问题。</font><font style="vertical-align: inherit;">如何解决这样的问题？</font><font style="vertical-align: inherit;">第一个解决方案是显而易见的。</font><font style="vertical-align: inherit;">始终保持向后兼容性。</font><font style="vertical-align: inherit;">当然，这不是很现实，因为打破变更很容易放入代码中。</font><font style="vertical-align: inherit;">例如：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/un/gj/tv/ungjtvaiofi7qkm6a4if5cpgh10.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重大更改和.NET库</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是特定于.NET的示例。我们有一个方法，我们决定为其添加一个带有默认值的参数。如果我们重新组装代码，则代码将继续编译，但是对于二进制文件，它将是两种完全不同的方法：一种方法的参数为零，第二种方法的参数为一个。如果依赖项中的开发人员以这种方式破坏了向后兼容性，那么我们将无法使用在先前版本中使用此依赖项编译的代码。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解决依赖关系问题的第二种方法是添加库，程序集的版本控制-任何东西。版本控制规则可能不同，关键是我们可以以某种方式将同一库的不同版本区分开来，并且您可以了解更新是否中断。不幸的是，一旦我们引入了版本，就会出现另一种问题。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/xc/wu/vgxcwufmesq4jly-ecfrh5p-ko8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
版本地狱是无法使用二进制兼容的依赖项，但同时具有的版本与运行时不匹配，或者具有其他组件无法检查这些版本。在.NET中，尽管文件位于磁盘上，但典型的地狱版本是FileLoadException，但由于某种原因它并未随运行时一起加载。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qy/wg/5m/qywg5mjhpkuogm6yez7uhnxitji.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在.NET中，程序集具有许多不同的版本-他们试图以各种方式修复版本地狱，并查看发生了什么。我们有一个包裹</font></font><code>System.Collections.Immutable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。很多人认识他。他拥有NuGet软件包1.6.0的最新版本。它包含一个库，以及版本为1.2.4.0的程序集。您已经收到您没有版本库1.2.4.0。如何理解它位于1.6.0 NuGet软件包中？没那么简单。除了程序集版本外，该库还有其他几个版本。例如，程序集文件版本，程序集信息版本。此NuGet软件包实际上包含具有相同版本的三个不同程序集（用于.NET Standard的不同版本）。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET文档</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opbuild标准</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于如何在.NET中使用程序集，已经写了很多文档。</font><font style="vertical-align: inherit;">有一个.NET指南可用于开发.NET的现代应用程序，其中考虑了.NET Framework，.NET标准，.NET Core，开源以及所有可能的功能。</font><font style="vertical-align: inherit;">整个文档中约有30％用于加载程序集。</font><font style="vertical-align: inherit;">我们将分析可能出现的特定问题和示例。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么这一切都是必要的？</font><font style="vertical-align: inherit;">首先，避免踩耙。</font><font style="vertical-align: inherit;">其次，您可以使您的库用户的生活更加轻松，因为使用您的库，他们将不会遇到习惯的依赖问题。</font><font style="vertical-align: inherit;">它还将帮助您应对将复杂应用程序迁移到.NET Core的问题。</font><font style="vertical-align: inherit;">最重要的是，您可以成为一名SRE，这是一名高级（绑定）重定向工程师，团队中的每个人都来参加该会议，并询问如何编写另一个重定向。</font></font><a name="assembly"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">严格装配</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
严格的程序集加载是.NET Framework开发人员面临的主要问题。</font><font style="vertical-align: inherit;">用表示</font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在继续进行严格的程序集加载之前，让我提醒您一些基本知识。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成.NET应用程序时，输出是一些工件，通常位于Bin / Debug或Bin / Release中，并且包含一组特定的程序集程序集和配置文件。</font><font style="vertical-align: inherit;">程序集将通过名称（程序集名称）相互引用。</font><font style="vertical-align: inherit;">重要的是要了解，程序集链接直接位于引用该程序集的程序集中；没有用于写入程序集引用的魔术配置文件。</font><font style="vertical-align: inherit;">即使在您看来，此类文件也存在。</font><font style="vertical-align: inherit;">引用本身是二进制形式的程序集。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在.NET中，有一个程序集解析过程-当程序集定义已转换为真实程序集时，该程序集位于磁盘上或加载到内存中的某个位置。程序集解析执行两次：在构建阶段，当您在* .csproj中具有引用时，在运行时阶段，当您在程序集内部具有引用时，根据某些规则，它们将变为可下载的程序集。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//简单名称</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MyAssembly，版本= 6.0.0.0，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文化=中性，PublicKeyToken = null </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//强名</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Newtonsoft.Json，版本= 6.0.0.0，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文化=中性，PublicKeyToken = 30ad4fe6b2a6aeed // PublicKey</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们继续解决这个问题。程序集名称主要有两种。第一种程序集名称是简单名称。由于它们具有PublicKeyToken = null，因此很容易识别它们。有一个强名称，很容易通过它们的PublicKeyToken不是null而是某个值的事实来识别它们。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/40/0v/uf/400vuf0e3w-ykw2fkdx2-ufdutq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们举个例子。我们有一个依赖于MyUtils实用程序的库的程序，而MyUtils的版本是9.0.0.0。同一程序具有指向另一个库的链接。该库还希望使用MyUtils，但版本为6.0.0.0。 MyUtils 9.0.0.0版和6.0.0.0版的PublicKeyToken = null，也就是说，它们具有简单名称。哪个版本将属于二进制工件6.0.0.0或9.0.0.0？第9版。 MyLibrary可以使用MyUtils版本9.0.0.0（该版本已包含在二进制工件中）吗？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/js/fs/2x/jsfs2xd1erckl8dkphbrhojfhxk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，可以这样，因为MyUtils具有简单名称，因此不存在对其进行严格程序集加载的情况。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kz/tn/a6/kztna61effl0kkiuwnkvi1gpad8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个例子。</font><font style="vertical-align: inherit;">除了MyUtils，我们还有NuGet的完整库，其中有一个Strong名称。</font><font style="vertical-align: inherit;">NuGet中的大多数库都有一个强名称。</font></font><br>
<br>
<a name="redirects"></a><img src="https://habrastorage.org/webt/rr/xp/qi/rrxpqilvehdbvemijol2iuutbie.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在构建阶段，将9.0.0.0版复制到BIN，但是在运行时我们得到了著名的BIN </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了使MyLibrary（希望将6.0.0.0 </font></font><code>Newtonsoft.Json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">版更新为）能够使用9.0.0.0版，您必须编写Binding redirect到</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绑定重定向</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/lw/d_/yq/lwd_yq2otb7kqsbpkpglszjlr-y.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重定向程序集版本</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
声明具有这样名称和publicKeyToken的程序集应从这样的版本范围重定向到这样的版本范围。</font><font style="vertical-align: inherit;">它似乎是一个非常简单的记录，但是它位于此处</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但可以位于其他文件中。</font></font><code>machine.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Framework内部</font><font style="vertical-align: inherit;">有一个文件</font><font style="vertical-align: inherit;">，运行时内部</font><font style="vertical-align: inherit;">有一个文件</font><font style="vertical-align: inherit;">，其中定义了一些标准的重定向集，该版本可能因.NET Framework的版本而异。</font><font style="vertical-align: inherit;">可能会发生在4.7.1上对您不起作用的情况，但在4.7.2上它已经起作用，反之亦然。</font><font style="vertical-align: inherit;">您需要记住，重定向不仅可以来自您的重定向</font></font><code>.App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而且在调试时应该考虑到这一点。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们简化了重定向的编写</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没有人愿意用手书写绑定重定向。让我们将此任务交给MSBuild！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pg/qk/ct/pgqkctk1hwcp0lewpamhi5wn35o.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何启用和禁用自动绑定重定向</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
有关如何简化使用绑定重定向的一些技巧。提示一：在MSBuild中启用绑定重定向自动生成。由中的属性开启</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。构建项目时，它将落入一个二进制工件中</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">工件</font><font style="vertical-align: inherit;">指示重定向到相同工件中的库的版本。这仅适用于运行应用程序，控制台应用程序，WinExe。对于库，这不起作用，因为对于库</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常它根本不相关，因为它与启动和加载程序集本身的应用程序相关。如果为库进行了配置，则在应用程序中，某些依赖项可能与构建库时的依赖项有所不同，事实证明，库的配置没有多大意义。尽管如此，有时对于库配置仍然有意义。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ik/g6/6n/ikg66nyqel3ejmqbln9xb1magyq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们编写测试时的情况。测试通常在ClassLibrary中找到，它们也需要重定向。测试框架能够识别带有测试的库具有dll-config，并将其中的重定向交换为测试中的代码。您可以自动生成这些重定向。如果我们有旧格式</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而不是SDK样式，您可以采用简单的方法，将OutputType更改为Exe并添加一个空的入口点，这将强制MSBuild生成重定向。您可以采用其他方式使用hack。您可以向添加另一个属性</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这使MSBuild认为对于此OutputType，您仍然需要生成绑定重定向。这种方法虽然看上去很hack，但可以让您为无法在Exe中重做的库以及其他类型的项目（测试除外）生成重定向。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于新格式，</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果使用现代的Microsoft.NET.Test.Sdk </font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">则会自行生成重定向。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第三个技巧：不要将绑定重定向生成与NuGet一起使用。 NuGet能够为从软件包传递到最新版本的库生成绑定重定向，但这不是最佳选择。所有这些重定向都必须添加</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并提交，如果使用MSBuild生成重定向，则在生成过程中会生成重定向。如果提交它们，则可能存在合并冲突。您自己可以简单地忘记更新文件中的Binding重定向，并且如果它们是在构建期间生成的，您将不会忘记。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fr/zq/yifrzq4fnvwitenrhkteup1cjfq.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决程序集引用</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成绑定重定向</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那些想更好地了解绑定重定向的工作原理的家庭作业：了解其工作原理，请参见代码。转到.NET目录，使用name属性更改所有位置，以用于生成。通常这是一种常见的方法，如果MSBuild有一些奇怪的属性，则可以利用它的用法。幸运的是，属性通常在XML配置中使用，您可以轻松地找到它们的用法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果检查这些XML目标中的内容，您将看到此属性触发了两个MSBuild任务。第一个任务称为</font></font><code>ResolveAssemblyReferences</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将生成一组重定向到文件的重定向。第二个任务</font></font><code>GenerateBindingRedirects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将第一个任务的结果写入</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">XML逻辑可以稍微纠正第一个任务的操作，并删除一些不必要的重定向或添加新的重定向。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XML配置的替代方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在XML配置中保留重定向并不总是很方便。</font><font style="vertical-align: inherit;">我们可能会遇到这种情况，即应用程序下载了该插件，而该插件使用了其他需要重定向的库。</font><font style="vertical-align: inherit;">在这种情况下，我们可能不知道我们需要的重定向集，或者我们可能不想生成XML。</font><font style="vertical-align: inherit;">在这种情况下，我们可以创建一个AppDomain，并在创建AppDomain时仍将其转移到具有必要重定向的XML所在的位置。</font><font style="vertical-align: inherit;">我们还可以在运行时立即处理程序集加载错误。</font><font style="vertical-align: inherit;">Rantime .NET提供了这样的机会。</font></font><br>
<br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (sender, eventArgs) =&gt; <font></font>
{ <font></font>
   <span class="hljs-keyword">var</span> name = eventArgs.Name; 
   <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
   <font></font>
   <span class="hljs-keyword">return</span> Assembly.LoadFrom(...); <span class="hljs-comment">// PublicKeyToken should be equal</span><font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它有一个事件，称为</font></font><code>CurrentDomain.AssemblyResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。订阅此事件，我们将收到有关所有失败的程序集下载的错误。我们得到未加载的程序集的名称，并得到请求第一个程序集加载的程序集程序集。在这里，我们可以从正确的位置手动加载程序集，例如，删除版本，仅从文件中获取版本，然后从处理程序中返回此事件。如果无法加载任何程序集，则返回空值，否则返回null。 PublicKeyToken应该是相同的，具有不同PublicKeyToken的程序集决不是彼此的朋友。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8q/m7/ge/8qm7ge64h4pbldvju9ya91uz8zm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此事件仅适用于一个应用程序域。</font><font style="vertical-align: inherit;">如果我们的插件在其内部创建了AppDomain，则运行时中的此重定向将无法在其中运行。</font><font style="vertical-align: inherit;">您需要以某种方式在插件创建的所有AppDomain中订阅此事件。</font><font style="vertical-align: inherit;">我们可以使用AppDomainManager做到这一点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AppDomainManager是一个单独的程序集，其中包含实现特定接口的类，该接口的方法之一将允许您初始化在应用程序中创建的任何新AppDomain。</font><font style="vertical-align: inherit;">创建AppDomain后，将调用此方法。</font><font style="vertical-align: inherit;">您可以在其中订阅此活动。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">严格的程序集加载和.NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在.NET Core中，没有所谓的“严格程序集加载”问题，这是由于签名的程序集需要确切要求的版本。还有另一个要求。对于所有程序集，无论它们是否用“强名称”签名，都将检查运行时加载的版本是否大于或等于前一个版本。如果我们遇到的是带有插件的应用程序，那么我们可能会遇到这样的情况，例如，该插件是从新版本的SDK构建的，并且下载了该应用程序的应用程序到目前为止使用的是旧版本的SDK，而不是分崩离析，我们也可以订阅此事件，但已经在.NET Core中，并加载我们拥有的程序集。我们可以编写以下代码：</font></font><br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (s, eventArgs) =&gt; <font></font>
{ <font></font>
     CheckForRecursion(); <font></font>
     <span class="hljs-keyword">var</span> name = eventArgs.Name;
     <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
    <font></font>
     name.Version = <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <font></font>
     <font></font>
     <span class="hljs-keyword">return</span> Assembly.Load(name); <font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们具有未引导的程序集的名称，我们使版本无效并</font></font><code>Assembly.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从相同版本</font><font style="vertical-align: inherit;">调用它</font><font style="vertical-align: inherit;">。这里将没有递归，因为我已经检查了递归。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/cs/kr/mtcskrokxuvcn8i4gueywowb3_m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必须下载MyUtils 0.0.2.0版。在BIN中，我们有MyUtils版本0.0.1.0。我们从版本0.0.2.0重定向到版本0.0。版本0.0.1.0将不会随我们一起加载。一个出口将飞向我们，表明无法使用0.0.2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16–1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">版本加载程序集</font><font style="vertical-align: inherit;">。 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16–1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) == <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>) <font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Version</span> { 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Build; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Revision; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Major; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Minor; <font></font>
} <font></font>
(<span class="hljs-keyword">ushort</span>) <span class="hljs-number">-1</span> == <span class="hljs-number">65535</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Version类中，并非所有组件都是强制性的，并且不是存储可选组件–1，而是在内部某处发生溢出，并获得2个</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16–1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果有兴趣，您可以尝试准确找到溢出发生的位置。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m5/bl/vl/m5blvl8u1xrfdigr0ay45_ps3q8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您使用反射程序集并希望获取所有类型，则可能会发现并非所有类型都可以获取GetTypes方法。程序集具有一个类，该类继承自未加载的程序集中的另一个类。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> IEnumerable <span class="hljs-title">GetTypesSafe</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Assembly assembly</span>)</span> <font></font>
{ <font></font>
    <span class="hljs-keyword">try</span> <font></font>
    { <font></font>
        <span class="hljs-keyword">return</span> assembly.GetTypes(); <font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (ReflectionTypeLoadException e) <font></font>
   { <font></font>
        <span class="hljs-keyword">return</span> e.Types.Where(x =&gt; x != <span class="hljs-literal">null</span>); <font></font>
    } <font></font>
}<font></font>
<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，问题将是将引发ReflectionTypeLoadException。</font><font style="vertical-align: inherit;">里面</font></font><code>ReflectionTypeLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一个属性，其中仍有那些类型仍然可以加载。</font><font style="vertical-align: inherit;">并非所有流行的图书馆都考虑到这一点。</font><font style="vertical-align: inherit;">AutoMapper，至少是它的一个版本，如果遇到ReflectionTypeLoadException，它就会掉下来，而不是从异常内部进行选择。</font></font><a name="name"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强大的命名</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强名称程序集</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
让我们讨论导致严格程序集加载的原因，这是强名称。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
强名称是使用非对称加密的某些私钥对程序集的签名。 PublicKeyToken是此程序集的公钥哈希。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过强命名，您可以区分具有相同名称的不同程序集。例如，MyUtils不是唯一的名称，可能有多个具有相同名称的程序集，但是如果您签署强名称，则它们将具有不同的PublicKeyToken，我们可以通过这种方式来区分它们。在某些程序集加载方案中，必须使用强名。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，为了在全局程序集缓存中安装程序集或一次并排下载多个版本。</font><font style="vertical-align: inherit;">最重要的是，强命名程序集只能引用其他强命名程序集。</font><font style="vertical-align: inherit;">由于某些用户希望使用Strong名称签名其版本，因此库开发人员也会对其库进行签名，以便用户更轻松地安装它们，从而使用户不必重新签名这些库。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强名：旧版？</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强命名和.NET库</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Microsoft在MSDN上明确表示不应出于安全目的使用强名称，它们仅用于区分具有相同名称的不同程序集。组装密钥不能以任何方式更改；如果更改了密钥，则将中断对所有用户的重定向。如果您的“强名”密钥的私密部分已泄露给公众访问，则您将无法以任何方式撤回此签名。强名称所在的SNK文件格式不会提供这种机会，其他用于存储密钥的格式至少包含指向CRL证书吊销列表的链接，通过该链接可以理解该证书不再有效。 SNK中没有类似的东西。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
开源指南具有以下建议。首先，出于安全目的，还使用其他技术。其次，如果您有一个开放源代码库，通常建议将密钥的私有部分提交给存储库，这样人们可以更轻松地分叉您的库，对其进行重建并将其放入现成的应用程序中。第三，永远不要更改强名称。破坏性太大。尽管它破坏力太大，并在《开放源代码指南》中对此进行了说明，但Microsoft有时仍会对其自己的库产生问题。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ue/kg/l3/uekgl3iwrexq7ejjbabccq4y4p4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一个名为System.Reactive的库。</font><font style="vertical-align: inherit;">以前，这些是几个NuGet软件包，其中一个是Rx-Linq。</font><font style="vertical-align: inherit;">这只是一个例子，其余的包也一样。</font><font style="vertical-align: inherit;">在第二个版本中，它是用Microsoft密钥签名的。</font><font style="vertical-align: inherit;">在第三个版本中，他移至</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/dotnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目中的存储库，</font><font style="vertical-align: inherit;">并开始具有.NET Foundation签名。</font><font style="vertical-align: inherit;">实际上，该库已更改为Strong名称。</font><font style="vertical-align: inherit;">NuGet包已重命名，但程序集的内部调用与之前完全相同。</font><font style="vertical-align: inherit;">如何从第二个版本重定向到第三个版本？</font><font style="vertical-align: inherit;">此重定向无法完成。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强名验证</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何：禁用强名绕过功能</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于强名称已经是过去的事情并且仍然纯粹是形式的另一种说法是，它们未经验证。我们有一个已签名的程序集，我们想修复其中的某种错误，但是我们无权访问源代码。我们可以使用dnSpy-这是一个实用程序，可让您反编译并修复已编译的程序集。一切都会为我们工作。因为默认情况下，启用了强名称验证绕过，即，它仅检查PublicKeyToken是否相等，并且不检查签名本身的完整性。可能有一些环境研究仍在对其签名进行验证，这里有一个生动的例子是IIS。在IIS上检查签名完整性（默认情况下，禁用强名称验证旁路），并且如果我们编辑签名程序集，一切都会中断。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加成：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公共符号</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">禁用程序集的签名验证</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">。</font></a><font style="vertical-align: inherit;">有了它，仅使用公钥进行签名，从而确保了程序集名称的安全。 Microsoft使用的公共密钥发布</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Rider中，可以在项目属性中启用公共符号。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vl/_j/ct/vl_jctjjgui-mbcgo5uyzd26lrc.png"><br>
<br>
<img src="https://habrastorage.org/webt/ni/if/hp/niifhpriuvymkfhz78sdeaigs54.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何时更改文件汇编版本</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
开源指南还提供了一些版本控制策略，其目的是减少NET Framework上用户必需的绑定重定向和对其进行更改的次数。此版本控制政策是，我们不应不断更改程序集版本。当然，这可能会导致在GAC中进行安装时出现问题，从而使已安装的本机映像可能与程序集不对应，因此您必须再次执行JIT编译，但是在我看来，这比版本控制的问题少。对于CrossGen，本机程序集不会全局安装-不会有问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，NuGet软件包Newtonsoft.Json，它具有多个版本：12.0.1、12.0.2，等等-所有这些软件包都有一个版本为12.0.0.0的程序集。</font><font style="vertical-align: inherit;">建议当NuGet软件包的主要版本更改时，应更新程序集版本。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请遵循.NET Framework的提示：手动生成重定向，并尝试在解决方案的所有项目中使用相同版本的依赖项。</font><font style="vertical-align: inherit;">这将大大减少重定向的数量。</font><font style="vertical-align: inherit;">仅当您有需要的特定构建加载方案，或者正在开发库并希望为真正需要“强命名”的用户简化工作时，才需要“强命名”。</font><font style="vertical-align: inherit;">请勿更改强名称。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET标准</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们通过.NET标准。它与.NET Framework中的版本地狱密切相关。 .NET Standard是用于编写与.NET平台的各种实现兼容的库的工具。实现是指.NET Framework，.NET Core，Mono，Unity和Xamarin。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/-a/-u/hk-a-u16d-oitjurhvta7lhafdi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*链接到文档</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是.NET Standard支持表，用于不同版本的运行时的各种版本。在这里我们可以看到.NET Framework完全不支持.NET Standard版本2.1。尚未计划支持.NET Standard 2.1和更高版本的.NET Framework版本。如果您要开发一个库并希望它可以在.NET Framework上为用户使用，则必须具有.NET Standard 2.0的目标。除了.NET Framework不支持最新版本的.NET Standard的事实之外，我们还要注意星号。 .NET Framework 4.6.1支持.NET Standard 2.0，但带有星号。在文档中直接有一个脚注，我从哪里获得此表。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/mq/yu/aymqyunvnqjivv13dpqkrzvac6i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑一个示例项目。 .NET Framework上的一个应用程序，具有一个针对.NET Standard的依赖项。这样的东西：ConsoleApp和ClassLibrary。目标库.NET标准。当我们将这个项目放在一起时，在我们的BIN中就是这样。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/62/og/fh62og_vou9gzibnv5gdd2mp_uk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将在那里有一百个DLL，其中只有一个与应用程序相关，其他所有东西都是为了支持.NET Standard。事实是，.NET Standard 2.0的出现晚于.NET Framework 4.6.1，但同时它们证明是与API兼容的，因此开发人员决定将Standard 2.0支持添加到.NET 4.6.1。我们不是本机地（通过包含</font></font><code>netstandard.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在运行时本身中）进行此操作，而是将.NET Standard * .dll和所有其他程序集外观直接放置在BIN中。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/af/15/am/af15amgkrw698xqylhfwemd67uy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们查看我们所针对的.NET Framework版本的依赖性以及落入BIN的库的数量，我们会发现在4.7.1中并没有那么多，而且从4.7.2开始，根本没有其他库。.NET本地标准支持。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/wu/va/rfwuvalfp3bi6zijyw5kjz-wjva.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是来自.NET开发人员的一则推文，它描述了此问题，如果拥有.NET Standard库，则建议使用.NET Framework 4.7.2版。</font><font style="vertical-align: inherit;">这里甚至不是2.0版，而是1.5版。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果可能，将项目中的目标框架至少提高到4.7.1，最好是4.7.2。</font><font style="vertical-align: inherit;">如果要开发一个库以使库用户的工作更轻松，请为.NET Framework创建一个单独的Target，它将避免大量可能与某些内容冲突的dll。</font></font><a name="dotnet"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET核心</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从一般理论开始。</font><font style="vertical-align: inherit;">我们将讨论如何在.NET Core上启动JetBrains Rider，以及为什么我们应该完全谈论它。</font><font style="vertical-align: inherit;">Rider是一个非常大的项目，它具有一个庞大的企业解决方案，其中包含大量不同的项目，一个复杂的依赖系统，您不能只接受它并一次迁移到另一个运行时。</font><font style="vertical-align: inherit;">为此，我们必须使用一些技巧，我们还将对此进行分析。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core应用程序</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
典型的.NET Core应用程序是什么样的？取决于部署的精确程度以及最终的用途。我们可以有几种情况。第一个是框架相关的部署。当应用程序使用计算机上预安装的运行时时，这与.NET Framework中的相同。它可以是一个独立的部署，这是应用程序带有运行时的时间。可能会有一个单文件部署，这是当我们获得一个exe文件时，但是在此exe文件中包含.NET Core的情况下，存在一个自包含应用程序的工件，这是一个自解压的存档。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/yi/3c/hxyi3c3yxhavujn9ljcmtxkuvj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将仅考虑依赖框架的部署。我们必须与该应用程序的DLL，有两个配置文件，其中第一个是必需的，这</font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">从.NET Core 3.0开始，将生成一个exe文件，该文件使该应用程序更易于运行，因此，如果我们在Windows上，则无需输入.NET命令。</font><font style="vertical-align: inherit;">从.NET Core 3.0开始，在.NET Core 2.1中，依赖关系就属于这种工件，您需要在.NET Core 2.1中发布或使用其他属性</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><a name="config"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共享框架 </font></font><code>.runtimeconfig.json</code></h3><br>
<br>
<img src="https://habrastorage.org/webt/cc/a5/ab/cca5ab5zhb3v6b1itc9jjbsiwje.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含运行它所需的运行时设置。它指示将在哪个Shared Framework上启动应用程序，看起来像这样。我们指示该应用程序将在“ Microsoft.NETCore.App” 3.0.0版下运行，可能还有其他共享框架。其他设置也可能在这里。例如，您可以启用服务器垃圾收集器。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c5/un/ic/c5unicttj2dp5ol0jiewknhb48i.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在项目组装过程中生成的。而且，如果要启用服务器GC，则甚至在组装项目或手动添加之前，都需要预先以某种方式修改此文件。您可以像这样在此处添加设置。</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果.NET开发人员提供了该属性，或者可以不提供该属性，</font><font style="vertical-align: inherit;">我们可以在其中包含属性</font><font style="vertical-align: inherit;">，我们可以创建一个名为</font></font><code>runtimeconfig.template.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并在此处写下必要的设置。在组装过程中，其他必要的设置将被添加到该模板中，例如，相同的共享框架。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/bu/e9/rlbue9y7cikkyzwenefcu2rdxy8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
共享框架是一组运行时和库。实际上，它与.NET Framework运行时相同，以前仅在计算机上安装过一次，而对于所有版本来说都是一个版本。与单个.NET Framework运行时不同，可以对共享框架进行版本控制，不同的应用程序可以使用安装的运行时的不同版本。共享框架也可以被继承。可以在磁盘上通常安装在系统上的这些位置中查看共享框架本身。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nc/df/7i/ncdf7ioj8afrolkvnlouh77jiaq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有几种标准的共享框架，例如，运行常规控制台应用程序的Microsoft.NETCore.App，用于Web应用程序的AspNetCore.App和用于运行桌面应用程序的.NET Core 3中的新共享框架WindowsDesktop.App。在Windows Forms和WPF上。最后两个Shared Framework本质上是对控制台应用程序所需的第一个的补充，也就是说，它们不携带全新的运行时，而只是用必要的库来补充现有的运行时。这种继承看起来在Shared Framework目录</font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中也有指定基本Shared Framework的</font><font style="vertical-align: inherit;">目录</font><font style="vertical-align: inherit;">。</font></font><a name="man"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
依赖清单（</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/sc/qv/qbscqv1sh6jb_r19ps_qrusogfi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认探测-.NET Core</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
第二个配置文件是这个</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该文件包含对应用程序或Shared Framework或库的所有依赖项的描述，库</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也有此文件。它包含所有依赖项，包括可传递的依赖项。 .NET Core运行时的行为</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因应用程序</font><font style="vertical-align: inherit;">是否</font><font style="vertical-align: inherit;">具有而</font><font style="vertical-align: inherit;">有所不同</font><font style="vertical-align: inherit;">。如果</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是，应用程序将能够加载所有的，这是它的共享框架或在其BIN目录中的组件。如果存在</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则启用验证。如果</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未</font><font style="vertical-align: inherit;">列出其中一个程序集</font><font style="vertical-align: inherit;">，则该应用程序将无法启动。您将看到上面显示的错误。如果应用程序尝试在运行时加载某些程序集，</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 例如，如果使用程序集加载方法或在程序集的解析过程中，您将看到与“严格的程序集加载”非常相似的错误。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetbrains骑士</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rider是.NET IDE。并非所有人都知道Rider是一个IDE，由基于IntelliJ IDEA的前端（用Java和Kotlin编写）和后端组成。后端本质上是R＃，可以与IntelliJ IDEA通信。该后端现在是一个跨平台的.NET应用程序。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它在哪里运行？ Windows使用安装在用户计算机上的.NET Framework。在其他信息系统上，在Linux和Mac上，使用Mono。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当到处都有不同的运行时时，这不是一个理想的解决方案，我想进入下一个状态，以便Rider在.NET Core上运行。为了提高性能，因为在.NET Core中所有最新功能都与此相关联。减少内存消耗。现在，Mono如何处理内存存在问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
切换到.NET Core可以使您放弃旧的，不受支持的技术，并允许对运行时中发现的问题进行一些修复。</font><font style="vertical-align: inherit;">切换到.NET Core将允许您控制运行时的版本，即Rider将不再在用户计算机上安装的.NET Framework上运行，而是在特定版本的.NET Core上运行，该版本可以被禁止作为独立的部署。</font><font style="vertical-align: inherit;">向.NET Core的过渡最终将允许使用专门在Core中导入的新API。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在的目标是启动一个原型，然后启动它，只是检查它如何工作，潜在的故障点是什么，必须再次重写哪些组件，这需要进行全局处理。</font></font><br>
<br>
<a name="rider"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难以将Rider转换为.NET Core的功能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
即使未安装R＃，Visual Studio也会</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从大型解决方案的内存不足中崩溃，大型解决方案中包含SDK样式* .csproj的项目</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">SDK样式* .csproj是完全.NET Core重定位的主要条件之一。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个问题，因为Rider基于R＃，它们生活在同一个存储库中，R＃开发人员希望使用Visual Studio在其产品中开发自己的产品以使其成为食品。</font><font style="vertical-align: inherit;">在R＃中，有一些链接需要特定的框架库。</font><font style="vertical-align: inherit;">在Windows上，我们可以将Framework用于桌面应用程序，而在Linux和Mac上，Mock已经用于具有最小功能的Windows库。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">决断</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们决定暂时保留旧版本</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在完整的Framework上进行组装，但是由于Framework和Core的程序集是二进制兼容的，因此可以在Core上运行它们。</font><font style="vertical-align: inherit;">我们不会使用不兼容的功能，请手动添加所有必需的配置文件，并下载.NET Core依赖项的特殊版本（如果有）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您必须去什么黑客？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个技巧：我们想调用一个仅在Framework中可用的方法，例如，R＃中需要此方法，而Core中则不需要。</font><font style="vertical-align: inherit;">问题在于，如果没有方法，那么在JIT编译期间调用该方法的方法会更早</font></font><code>MissingMethodException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">即，不存在的方法破坏了调用它的方法。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params"></span>)</span> { 
  <span class="hljs-keyword">if</span> (NetFramework) <font></font>
     CallNETFrameworkOnlyMethod();<font></font>
<font></font>
  ... <font></font>
} <font></font>
[<span class="hljs-meta">MethodImpl(MethodImplOptions.NoInlining)</span>] 
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallNETFrameworkOnlyMethod</span>(<span class="hljs-params"></span>)</span> { <font></font>
  NETFrameworkOnlyMethod(); <font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解决方案在这里：我们将不兼容的方法调用到单独的方法中。还有一个问题：这种方法可能会内联，因此我们用attribute标记它</font></font><code>NoInlining</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
技巧二：我们需要能够在相对路径中加载程序集。我们为框架提供了一个程序集，为.NET Core提供了一个特殊版本。我们如何下载.NET Core的.NET Core版本？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qm/zm/w7/qmzmw79gtllee8uyswgrn0oqnum.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他们会帮助我们的</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。让我们看一下</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Diagnostics.PerformanceCounter库。这样的图书馆在</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它有一个运行时部分，其中指示了库的一个版本及其相对路径。在这个库中，程序集将在所有运行时中加载，并且仅引发执行。例如，如果它在Linux上加载，则PerformanceCounter在Linux上的设计上不起作用，并且PlatformNotSupportedException从那里飞行。此</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分</font><font style="vertical-align: inherit;">中还有</font><font style="vertical-align: inherit;">一个runtimeTargets部分</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">此处已指示该程序集的版本专门用于Windows，PerformanceCounter应该在该版本上工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们使用运行时部分并在其中写入要加载的库的相对路径，这将无济于事。运行时部分实际上在NuGet包内设置了相对路径，而不是相对于BIN。如果我们在BIN中查找此程序集，则仅从那里使用文件名。 runtimeTargets部分已经包含一个诚实的相对路径，一个相对于BIN的诚实路径。我们将在runtimeTargets部分中为程序集规定一个相对路径。代替运行时标识符（这里是“ win”），我们可以选择另一个我们喜欢的标识符。例如，我们将运行时标识符写为“ any”，并且该程序集通常会在所有平台上加载。或者，我们将编写“ unix”，它将在Linux，Mac等上启动。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一个技巧：我们想在Linux和Mac Mock上下载以构建WindowsBase。问题在于</font></font><code>Microsoft.NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即使我们不在Windows上，</font><font style="vertical-align: inherit;">共享框架中也已经存在名为WindowsBase的程序集</font><font style="vertical-align: inherit;">。在Windows共享框架上，</font></font><code>Microsoft.WindowsDesktop.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowsBase重新定义中的版本</font></font><code>NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。让我们看一下</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些框架，更准确地</font><font style="vertical-align: inherit;">看一下</font><font style="vertical-align: inherit;">描述WindowsBase的那些部分。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gc/ox/f3/gcoxf3q7mbfm_a9hzmcujfin5zc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
区别在于：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5q/pz/wq/5qpzwq-n21m38b_0xedi9txpwoc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果某些库发生冲突并且存在多个库，则为</font><font style="vertical-align: inherit;">和</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组成的对中选择最大的</font><font style="vertical-align: inherit;">库</font><font style="vertical-align: inherit;">。 .NET指南说，</font><font style="vertical-align: inherit;">只需要在Windows资源管理器中显示它，但不是，它属于</font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"></font><code>fileVersion</code><font style="vertical-align: inherit;"></font><code>fileVersion</code><font style="vertical-align: inherit;"></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这是我知道的版本中规定的唯一案例</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且</font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，被实际使用。在所有其他情况下，我看到的行为是，无论</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写入</font><font style="vertical-align: inherit;">什么版本</font><font style="vertical-align: inherit;">，程序集都将继续加载。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/re/j8/bwrej8fa8_gyuyvcjnt3ixvljce.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第四hack。任务：前两个hack有一个.deps.json文件，我们只需要特定的依赖项即可。由于它们是</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在半手动模式下生成的，因此我们有一个脚本，根据对应该到达那里的内容的一些描述，可以在构建过程中生成它，因此我们希望将其保持在</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小程度，以便我们能够理解其中的内容。我们要禁用验证，并允许下载BIN中未描述的程序集</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解决方案：在runtimeconfig中启用自定义配置。</font><font style="vertical-align: inherit;">为了与.NET Core 1.0向后兼容，实际上需要此设置。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，</font></font><code>.runtime.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET的核心-这是一种类似物</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让您执行相同的操作，例如以相对的方式加载程序集。</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果情况非常复杂，则可以</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">手动重写它，来在.NET Core上自定义程序集的加载。</font></font><a name="load"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调试程序集下载</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我讨论了一些类型的问题，因此您需要能够调试装入程序集的问题。</font><font style="vertical-align: inherit;">有什么可以帮助呢？</font><font style="vertical-align: inherit;">首先，运行时编写有关如何加载程序集的日志。</font><font style="vertical-align: inherit;">其次，您可以更仔细地观察飞向您的执行。</font><font style="vertical-align: inherit;">您还可以关注运行时事件。</font></font><a name="fusion"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">融合日志</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/jl/4v/be/jl4vbeqsyjzmab2rx0xvdg-lpi4.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返璞归真：使用Fusion Log Viewer调试模糊错误</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusion</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在.NET Framework中加载程序集的机制称为Fusion，它知道如何将所做的操作记录到磁盘上。要启用日志记录，您需要向注册表添加特殊设置。这不是很方便，因此使用实用程序（即Fusion Log Viewer和Fusion ++）有意义。 Fusion Log Viewer是Visual Studio随附的标准实用程序，可以从Visual Studio命令行Visual Studio开发人员命令提示符启动。 Fusion ++是此工具的开源类似物，具有更好的界面。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/9h/bt/ou9hbtdgx1yjp6rjjdm3q61efpu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fusion Log Viewer看起来像这样。这比WinDbg更糟糕，因为此窗口甚至不会拉伸。尽管如此，您仍可以在此处打上对勾标记，尽管并不总是很明显哪个对勾标记是正确的。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/h2/by/guh2byfmgazm8yvbxfa_jhf25wo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fusion ++具有一个“开始记录”按钮，然后出现“停止记录”按钮。在其中，您可以查看有关加载程序集的所有记录，并阅读有关实际发生情况的日志。这些日志以简洁的方式看起来像这样。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zf/ep/5m/zfep5myuovdov4t7mmtw4czhwqc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是严格装配加载的豁免。</font><font style="vertical-align: inherit;">如果我们查看Fusion日志，将会看到在处理完所有配置后需要下载9.0.0.0版本。</font><font style="vertical-align: inherit;">我们发现一个文件中怀疑有我们需要的程序集。</font><font style="vertical-align: inherit;">我们看到此文件中有6.0.0.0版。</font><font style="vertical-align: inherit;">我们有一个警告，我们比较了程序集的全名，并且它们的主要版本不同。</font><font style="vertical-align: inherit;">然后发生错误-版本不匹配。</font></font><a name="events"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行时事件</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/pu/np/bn/punpbnrdvfv_mm5bpweej75ofq8.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记录运行时事件</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在Mono上，您可以启用使用环境变量进行记录，并且最终会将日志写入</font></font><code>stdout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。不太方便，但是解决方案有效。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rj/vv/g9/rjvvg9dfv0ji5sbxm_crgu3ok0a.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认探测-.NET Core </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文档/设计文档/主机跟踪</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
.NET Core还具有一个特殊的环境变量</font></font><code>COREHOST_TRACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中包括登录</font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。使用.NET Core 3.0，您可以通过在变量中指定文件的路径来将日志写入文件</font></font><code>COREHOST_TRACEFILE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<img src="https://habrastorage.org/webt/eo/b5/yf/eob5yf90z7cgilees68uxtrhw0w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当程序集无法加载时，将触发一个事件。这是一个事件</font></font><code>AssembleResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。还有第二个有用的事件this </font></font><code>FirstChanceException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。您可以订阅它，并得到关于加载程序集的错误，即使有人写了try..catch并错过了所有执行的地方</font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生了。</font><font style="vertical-align: inherit;">如果应用程序已经编译过，则可以启动它</font></font><code>perfview</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且它可以监视.NET执行，并在那里可以找到与下载文件有关的内容。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将工作转移到工具，开发工具，IDE，MSBuild，这使您可以生成重定向。</font><font style="vertical-align: inherit;">您可以切换到.NET Core，然后您将忘记什么是“严格的程序集加载”，并且您将能够使用新的API，就像我们想要在Rider中实现它一样。</font><font style="vertical-align: inherit;">如果连接.NET Standard库，则将.NET Framework的目标版本提高到至少4.7.1。</font><font style="vertical-align: inherit;">如果您似乎处在绝望的境地，请寻找黑客，使用它们，或者针​​对绝望的情况提出自己的骇客。</font><font style="vertical-align: inherit;">并使用调试工具武装自己。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我强烈建议您阅读以下链接：</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">.NET Guide</a>;</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">     .NET Core</a>.</li>
</ul><br>
<br>
<blockquote>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DotNext 2020 Piter</a> .       ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 8   JUG Ru Group</a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN499824/index.html">2020年5月人力资源和IT招聘人员的事件摘要</a></li>
<li><a href="../zh-CN499826/index.html">血压分布</a></li>
<li><a href="../zh-CN499832/index.html">如何快速安全地组织员工的远程工作？我们讨论了不同的方法：不仅限于VDI</a></li>
<li><a href="../zh-CN499834/index.html">认识Felix测力计</a></li>
<li><a href="../zh-CN499836/index.html">乌达伦卡vs. 开发团队办公室</a></li>
<li><a href="../zh-CN499842/index.html">人们为什么要重新学习</a></li>
<li><a href="../zh-CN499846/index.html">什么时候开始单独的垃圾收集工作，为什么需要对垃圾容器的站点进行视频监视</a></li>
<li><a href="../zh-CN499850/index.html">如何在40分钟内分析竞争对手并制定数字策略</a></li>
<li><a href="../zh-CN499852/index.html">Angular的英语文档</a></li>
<li><a href="../zh-CN499854/index.html">Apache Bigtop和当今Hadoop发行版的选择</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>