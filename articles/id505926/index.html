<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏻 ✋🏽 👩🏽‍🎤 Untuk pertanyaan tentang Apophenia, Telegonia dan Time Travel (dan berfungsi dengan _ pada awalnya) 🗒️ ◽️ 📅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada tahun 1958, ahli saraf Jerman Klaus Konrad menciptakan istilah "apophenia" (dari bahasa Latin apophene - mengekspresikan penilaian, membuatnya me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Untuk pertanyaan tentang Apophenia, Telegonia dan Time Travel (dan berfungsi dengan _ pada awalnya)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505926/"><blockquote><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahun 1958, ahli saraf Jerman Klaus Konrad menciptakan istilah "apophenia" (dari bahasa Latin apophene - mengekspresikan penilaian, membuatnya menjadi eksplisit; istilah tersebut kembali ke teks-teks wahyu agama, di mana itu berarti pengetahuan yang dicapai di luar proses kognisi), yang menyiratkan padanya properti jiwa, yang terdiri dari kemampuan jiwa, yang terdiri dari kemampuan jiwa. melihat hubungan dalam fakta atau data yang tidak bermakna atau acak, dan menemukan makna dalam kebetulan. Ilusi komunikasi yang bermakna. Otak kita terus mencari pola, tetapi sering membuat kesalahan dan ada keinginan irasional untuk melihat pola di mana mereka tidak ada. Keinginan aneh untuk mematuhi kebetulan dan kemungkinan. Ini disebut apophenia. Dalam statistik matematika, ini adalah kesalahan standar dari jenis pertama. </font></font></i><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nepryakhin N. "Saya memanipulasi Anda"</font></font></i></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa saya ingat istilah ini, terutama pada sumber daya TI? </font><font style="vertical-align: inherit;">Karena pencarian hubungan antara fakta yang berbeda selama debugging program adalah salah satu faktor utama yang menentukan keberhasilannya. </font><font style="vertical-align: inherit;">Sejumlah ketidakakuratan acak dalam pekerjaan, yang masing-masing tidak menunjukkan alasan terjadinya dan tidak memengaruhi operasi program secara keseluruhan, mungkin tampak kacau balau. </font><font style="vertical-align: inherit;">Namun, jika Anda mencoba menemukan hubungan di antara mereka, Anda dapat segera menyelesaikan banyak masalah dengan satu baris kode ... Atau pastikan hubungan tersebut tidak lebih dari permainan pikiran, produk dari imajinasi pengembang.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bab 1. "Agen dan koordinator"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya dimulai selama pengembangan program agen yang melakukan sejumlah tugas pada server jauh, menerima daftar tugas melalui mekanisme client-server. Agen mengangkat server pada port 34002, koordinator lokal yang terhubung, mereka memeriksa satu sama lain otorisasi dan jika semuanya berjalan dengan baik, agen melakukan tindakan yang diperlukan dan melaporkan kembali ke atas. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tr/mz/kl/trmzklssjskomt-sxqhxfdpbihq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skema program yang disederhanakan</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Langkah yang jelas dari agen adalah membuat garpu sendiri untuk menjalankan fungsi apa pun dari keluarga eksekutif untuk mengganti proses dengan program yang diluncurkan. Dalam hal ini, agen menerima pid dari proses, yang memungkinkan untuk menunggu penyelesaiannya atau menghentikannya secara paksa. Namun, semuanya berjalan dengan baik, agar koordinator menerima laporan tentang pekerjaan yang dilakukan, perlu untuk mengembalikan kesimpulan stdout dan stderr.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah ini dapat diselesaikan dengan beberapa metode - melewati proses FD baru (dup2) untuk stdout dan stderr, dan kemudian membacanya dalam proses induk; redirect stderr ke stdout dan gunakan popen; menimpa stdout dan stderr deskriptor sebagai file dan membacanya setelah selesai. Kami memilih metode yang terakhir, karena membaca dengan metode pertama memerlukan kode tambahan dan sinkronisasi (dan jika Anda tidak membacanya terus-menerus, maka setelah mencapai 2 MB, rekaman akan berhenti ketika penyangga pipa habis), dan pada detik kami kehilangan perbedaan antara stdout dan stderr. Oleh karena itu, metode paling sederhana dipilih - untuk menutup stdout dan stderr ke proses baru, dan kemudian membuka file melalui buka di mana kami ingin menimpa output kami. Menurut dokumentasi untuk open, ia menggunakan indeks FD minimum yang tersedia, itulah sebabnya kodenya akan sederhana dan elegan:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> pid = fork();
<span class="hljs-keyword">switch</span> (pid) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span> :
        <span class="hljs-keyword">return</span> BADFORK;
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> :<font></font>
        close(<span class="hljs-built_in">stdout</span>);<font></font>
        close(<span class="hljs-built_in">stderr</span>);<font></font>
        open(fileout, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        open(fileerr, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        execve(arguments[<span class="hljs-number">0</span>], arguments, environ);
        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);
    <span class="hljs-keyword">default</span> :
        <span class="hljs-keyword">return</span> pid;<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode yang disederhanakan terlihat seperti ini (pengecekan error dihapus agar mudah dibaca). </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode diluncurkan, output perintah berhasil ditulis ke file, selesai dan siap untuk bekerja pada sistem "tempur". </font><font style="vertical-align: inherit;">Atau tidak? </font><font style="vertical-align: inherit;">Pada tahap pengujian, bug kecil muncul, "membuktikan" kemungkinan perjalanan waktu (atau setidaknya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">telegrafi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bab 2. "Telegonia"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya adalah ini: setelah program selesai, dan juga setelah agen itu sendiri selesai, baris berikut ditemukan dalam file yang harus berisi output dari program yang sedang dimulai (yang kami mengarahkan stdout program anak):</font></font><br>
<br>
<pre><code class="plaintext hljs">[2020-06-05 16:58:49]      :34002</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tunggu sebentar! Tapi ini adalah garis dari output agen itu sendiri - proses induk yang disebut fork ()! Tidak hanya itu, agen menampilkan baris ini beberapa saat setelah program yang dipanggil berakhir! Bagaimana semua sisa agen dapat ditulis ke stdout, dan salah satu baris bisa masuk ke file, semua agen bekerja dengan membacanya setelah waitpid selesai? Mungkin kesalahan saat membaca file memberikan memori yang babak belur?</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _exec_readfile(struct frs_json * target, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * filename) {<font></font>
    FILE * fp;<font></font>
    <span class="hljs-keyword">char</span> linebuff[VEN_PIPE_READ_SIZE + <span class="hljs-number">1</span>] = { <span class="hljs-number">0</span> };<font></font>
    fp = fopen(filename, <span class="hljs-string">"r"</span>);
    <span class="hljs-keyword">if</span> (!fp)<font></font>
        frs_err(<span class="hljs-string">" \"%s\"    "</span>, filename);
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">while</span>(fgets(linebuff, VEN_PIPE_READ_SIZE, fp))<font></font>
            frs_json_string(target, <span class="hljs-literal">NULL</span>, bxi_strtrimr(linebuff));<font></font>
    }<font></font>
    fclose(fp);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tampaknya bukan apa-apa yang bisa mengalahkan memori (frs_ * dicakup oleh tes). </font><font style="vertical-align: inherit;">Jadi bagaimana fp ini mempengaruhi output agen, yang terjadi beberapa menit setelah fungsi ini dieksekusi? </font><font style="vertical-align: inherit;">Secara alami, semacam telegrafi - mereka menyentuh file untuk dibaca, dan setelah 9 bulan kami mendapatkan garis dari "pasangan pertama" di dalamnya. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9g/pv/c7/9gpvc7fjwrn55pggacmexfxbohm.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD saya tersentuh oleh zebra</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Valgrind tidak menemukan masalah, yang agak membuat kami kesal. </font><font style="vertical-align: inherit;">Bagaimanapun, analisanya yang mahakuasa tidak melihat kesalahan akses memori, mereka hanya menghabiskan banyak waktu dengan sia-sia untuk menganalisis. </font><font style="vertical-align: inherit;">Atau tidak sia-sia? </font><font style="vertical-align: inherit;">Jika tidak ada kesalahan akses memori, itu berarti kesalahan logis. </font><font style="vertical-align: inherit;">Tetapi kesalahan logis apa yang dapat menyebabkan efek seperti itu?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bab 3. "Dua server"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sementara itu, bug kedua ditemukan. </font><font style="vertical-align: inherit;">Selama peluncuran di bawah QtCreator debugging (kami menggunakannya sebagai lingkungan pengembangan, proyek C itu sendiri) berhasil menyelesaikan semua proses yang berkaitan dengan program dan bug ini tidak muncul. </font><font style="vertical-align: inherit;">Namun, ada baiknya mencoba memulai program secara langsung, dan kemudian menghentikannya (dengan metode hukum), karena berhenti memulai kedua kalinya.</font></font><br>
<br>
<pre><code class="plaintext hljs">^C[2020-06-05 16:58:46]    "Interrupt",   <font></font>
[2020-06-05 16:58:49]      :34002<font></font>
[2020-06-05 16:58:49]      :34002<font></font>
[2020-06-05 16:58:49]      :34002<font></font>
[2020-06-05 16:58:49]     <font></font>
[2020-06-05 16:58:50]      </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memang benar untuk memikirkan gremlin kecil yang menghancurkan mekanisme program dari dalam, menghancurkan satu bagian dari program, lalu yang lain. </font><font style="vertical-align: inherit;">Tetapi bakat programmer menunjukkan bahwa ada hubungan antara bug ini. </font><font style="vertical-align: inherit;">Yang mana? </font><font style="vertical-align: inherit;">Siapa yang tahu, tapi itu sebabnya tidak sia-sia! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menemukan penyebab kegagalan peluncuran ternyata mudah. </font><font style="vertical-align: inherit;">Cukup dengan melihat log sistem dari program, di mana ia dengan jelas dan jelas menjelaskan alasannya:</font></font><br>
<br>
<pre><code class="plaintext hljs">[2020-06-06 14:40:12] frs_socket_bind  :34002   ("Address already in use" (98))<font></font>
[2020-06-06 14:40:12]      :34002<font></font>
[2020-06-06 14:40:12] ven_server_start     </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana ini sudah diluncurkan? </font><font style="vertical-align: inherit;">Siapa yang diluncurkan? </font><font style="vertical-align: inherit;">Anda berakhir semenit yang lalu!</font></font><br>
<br>
<pre><code class="plaintext hljs">$ ps aux | grep vento<font></font>
alex     14144  0.0  0.0 156780  7212 pts/0    Sl+  14:39   0:00 ./vento</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Benar-benar diluncurkan. </font><font style="vertical-align: inherit;">Tapi mungkin hanya kecelakaan?</font></font><br>
<br>
<pre><code class="plaintext hljs">kill -9 14144</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan lagi, program dimulai, tetapi setelah program berakhir, proses yang memiliki port 34002 tetap:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
vento     14144 alex    3u  IPv4 12275384      0t0  TCP *:34002 (LISTEN)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan siapa yang berakhir? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan output lsof -i saat runtime. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami meluncurkan:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
vento     151640 alex    3u  IPv4 12275384      0t0  TCP *:34002 (LISTEN)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, satu soket, satu server </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, satu Reich</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
_Postman  25078 alex  104u  IPv4 12885232      0t0  TCP localhost:46154-&gt;localhost:34002 (ESTABLISHED)<font></font>
vento     27468 alex    3u  IPv4 12890254      0t0  TCP *:34002 (LISTEN)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini klien terhubung dan menetapkan beberapa perintah ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi apa itu?</font></font><br>
<br>
<pre><code class="plaintext hljs">$ lsof -i | grep 34002<font></font>
_Postman  25078 alex  104u  IPv4 12885232      0t0  TCP localhost:46154-&gt;localhost:34002 (ESTABLISHED)<font></font>
vento     27468 alex    3u  IPv4 12890254      0t0  TCP *:34002 (LISTEN)<font></font>
vento     27506 alex    3u  IPv4 12890254      0t0  TCP *:34002 (LISTEN)<font></font>
vento     27506 alex    4u  IPv4 12890329      0t0  TCP localhost:34002-&gt;localhost:46154 (ESTABLISHED)</code></pre><br>
<img src="https://habrastorage.org/webt/wp/wq/62/wpwq62hwasqdflzz9bxomgjvebq.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fakta menyenangkan # 197766: cepat atau lambat, referensi ke Star Wars akan muncul</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dua port server? </font><font style="vertical-align: inherit;">Terlepas dari kenyataan bahwa server kami tidak menggunakan bendera REUSEPORT.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bab 4. "CLOEXEC"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hmm ... Mungkin flag CLOEXEC tidak ada dalam implementasi server? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat lebih dekat pada bendera:</font></font><br>
<br>
<pre><code class="plaintext hljs">$man fork<font></font>
       *  The child process is created  with  a  single  thread—the  one  that<font></font>
          called  fork().   The  entire virtual address space of the parent is<font></font>
          replicated in the child, including the states of mutexes,  condition<font></font>
          variables,  and other pthreads objects; the use of pthread_atfork(3)<font></font>
          may be helpful for dealing with problems that this can cause.<font></font>
<font></font>
       *  The child inherits copies of the parent's set of open file  descrip‐<font></font>
          tors.   Each  file  descriptor  in the child refers to the same open<font></font>
          file description (see open(2)) as the corresponding file  descriptor<font></font>
          in  the parent.  This means that the two file descriptors share open<font></font>
          file status flags, file offset,  and  signal-driven  I/O  attributes<font></font>
          (see the description of F_SETOWN and F_SETSIG in fcntl(2)).<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memanggil fungsi fork () akan membuat salinan utas proses saat ini dan membuat salinan setiap deskriptor proses terbuka (dan karena pada sistem UNIX [-seperti] “semuanya adalah file”, file jaringan akan cenderung bersama dengan deskriptor file)</font></font><br>
<br>
<pre><code class="plaintext hljs">$man exec<font></font>
       The exec() family of functions replaces the current process image with a new process image.  The functions described in<font></font>
       this manual page are front-ends for execve(2).  (See the manual page  for  execve(2)  for  further  details  about  the<font></font>
       replacement of the current process image.)</code></pre><br>
<pre><code class="plaintext hljs">$man execve<font></font>
       *  By  default,  file  descriptors  remain open across an execve().  File descriptors that are marked close-on-exec are<font></font>
          closed; see the description of FD_CLOEXEC in fcntl(2).  (If a file descriptor is closed, this will cause the release<font></font>
          of  all record locks obtained on the underlying file by this process.  See fcntl(2) for details.)  POSIX.1 says that<font></font>
          if file descriptors 0, 1, and 2 would otherwise be closed after a successful execve(), and the  process  would  gain<font></font>
          privilege because the set-user-ID or set-group_ID mode bit was set on the executed file, then the system may open an<font></font>
          unspecified file for each of these file descriptors.  As a general principle, no portable  program,  whether  privi‐<font></font>
          leged or not, can assume that these three file descriptors will remain closed across an execve().</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita tidak ingin proses yang dipanggil menerima salinan deskriptor, maka kita harus mengatur flag FD_CLOEXEC / SOCK_CLOEXEC padanya. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, akan logis jika itu ditandai dengan tag yang Anda ingin menyalin, untuk kebocoran menghindari dalam file akar-akses, tapi bendera muncul di POSIX-2001, jadi sekarang itu warisan kami, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meskipun</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kontroversial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br>
<pre><code class="cpp hljs">server-&gt;socket = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC, <span class="hljs-number">0</span>);</code></pre><br>
<pre><code class="cpp hljs">fcntl(client, F_SETFD, FD_CLOEXEC);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, tidak, bendera kami ditetapkan sebagaimana mestinya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lalu apa yang terjadi? </font><font style="vertical-align: inherit;">Apakah kernel mengabaikan flag? </font><font style="vertical-align: inherit;">Seseorang mencampakkannya? </font><font style="vertical-align: inherit;">Dan yang paling penting, mengapa, setelah aplikasi selesai, proses menempati port tetap dalam sistem? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita coba untuk menutup server utama dan terhubung ke proses yang tersisa menggunakan gdb:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ sudo gdb -p 27506<font></font>
GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git<font></font>
[...]<font></font>
Reading symbols from /lib/x86_64-linux-gnu/libgcc_s.so.1...(no debugging symbols found)...done.<font></font>
0x00007f503d50c9f3 in futex_wait_cancelable (private=[optimized out], expected=0, futex_word=0x55f485d383b8)<font></font>
    at ../sysdeps/unix/sysv/linux/futex-internal.h:88<font></font>
88	../sysdeps/unix/sysv/linux/futex-internal.h:     .<font></font>
(gdb) bt<font></font>
#0  0x00007f503d50c9f3 in futex_wait_cancelable (private=[optimized out], expected=0, futex_word=0x55f485d383b8)<font></font>
    at ../sysdeps/unix/sysv/linux/futex-internal.h:88<font></font>
#1  __pthread_cond_wait_common (abstime=0x0, mutex=0x55f485d38368, cond=0x55f485d38390) at pthread_cond_wait.c:502<font></font>
#2  __pthread_cond_wait (cond=0x55f485d38390, mutex=0x55f485d38368) at pthread_cond_wait.c:655<font></font>
#3  0x00007f503d948097 in _frs_signal_wait (signal=0x55f485d38340, filename=0x7f503d7315c8 "fen_server.c", fileline=298)<font></font>
    at ./projects/shared/libforseti/code/thread/frs_signal.c:250<font></font>
#4  0x00007f503d728044 in _server_wait (server=0x55f485d38270) at ./projects/shared/libfenrir/code/server/fen_server.c:298<font></font>
#5  0x00007f503d72822d in fen_server_free (server=0x55f485d38270) at ./projects/shared/libfenrir/code/server/fen_server.c:351</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stop stop stop, server_free apa? </font><font style="vertical-align: inherit;">Sudahkah kita menyelesaikan proses yang salah? </font><font style="vertical-align: inherit;">Bagaimanapun, di sini harus ada peluncuran aplikasi gema! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atau seharusnya tidak?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bab 5. "Satu karakter"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mengirim string echo, tetapi Anda harus meletakkan path lengkap ke aplikasi di exec, karena kami tidak menjalankannya di lingkungan shell, tidak seperti sistem yang sama. </font><font style="vertical-align: inherit;">Ubah ke / bin / echo, dan perhatikan bahwa masalahnya sudah hilang. </font><font style="vertical-align: inherit;">Tapi kemudian ternyata ketika kita memberikan perintah yang salah dari sudut pandang exec, kita terus bekerja dalam proses yang sama dan tidak menggantinya dengan aplikasi yang sedang berjalan, yang berarti bahwa ...</font></font><br>
<br>
<pre><code class="cpp hljs">        execve(arguments[<span class="hljs-number">0</span>], arguments, environ);
        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, keluar sudah selesai. </font><font style="vertical-align: inherit;">Tetapi bagaimana ini membuat server dimatikan?</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/*! \brief   */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _free(<span class="hljs-keyword">void</span>) __attribute__((destructor));
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _free(<span class="hljs-keyword">void</span>) {<font></font>
    fen_server_free(g_server);<font></font>
    frs_inf(<span class="hljs-string">"   "</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang semuanya jatuh ke tempatnya. </font><font style="vertical-align: inherit;">Kedua bug ini benar-benar saling berhubungan, dan sekarang Anda bahkan dapat mengatakan dengan tepat caranya: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/g0/sk/-s/g0sk-sf74ratdovfkkoqny7ongu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, masih memperbaiki sistem yang tidak berfungsi dengan benar. </font><font style="vertical-align: inherit;">Dan kita akan melakukannya seperti dalam lelucon tentang master televisi dan satu pukulan dengan palu: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan satu simbol</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “_” ke kata exit:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> pid = fork();
<span class="hljs-keyword">switch</span> (pid) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span> :
        <span class="hljs-keyword">return</span> BADFORK;
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> :<font></font>
        close(<span class="hljs-built_in">stdout</span>);<font></font>
        close(<span class="hljs-built_in">stderr</span>);<font></font>
        open(fileout, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        open(fileerr, O_CREAT | O_WRONLY, <span class="hljs-number">0777</span>);<font></font>
        execve(arguments[<span class="hljs-number">0</span>], arguments, environ);<font></font>
        _exit(EXIT_FAILURE);<font></font>
    <span class="hljs-keyword">default</span> :
        <span class="hljs-keyword">return</span> pid;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang terjadi sekarang? </font><font style="vertical-align: inherit;">Tidak ada yang istimewa, kecuali bahwa sekarang proses terminating akan berakhir tanpa memanggil fungsi yang terdaftar melalui atexit. </font><font style="vertical-align: inherit;">Pada implementasi glibc yang lebih lama, ini akan menjadi panggilan ke panggilan sistem _exit; pada yang lebih baru, exit_group akan dipanggil untuk menyelesaikan semua utas program dengan lebih benar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nah, kedua bug telah dikalahkan, dan Anda mengatakan "apofenia", "Anda hanya bertanya-tanya," "tidak ada koneksi". </font><font style="vertical-align: inherit;">Saya akan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memindahkan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kotak di rak, jika tidak manusia tidak akan lagi terbang ke luar angkasa.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id505898/index.html">Claude Shannon: jack semua perdagangan, pelawak dan bapak teori informasi</a></li>
<li><a href="../id505900/index.html">Kecanduan pribadi: ukuran penuh 40 mm, tanpa kawat, selama 72 jam untuk 8000 rubel</a></li>
<li><a href="../id505904/index.html">JUG Ru Group # 5 Streaming Minggu Online</a></li>
<li><a href="../id505906/index.html">Walkthrough Bandit dari overthewire.org</a></li>
<li><a href="../id505918/index.html">Sony Phone Interface - Non-Disabled Advertising</a></li>
<li><a href="../id505928/index.html">Mengapa pemrograman fungsional sangat rumit</a></li>
<li><a href="../id505946/index.html">Menyimpan Gambar Menggunakan Django / Django REST</a></li>
<li><a href="../id505954/index.html">Alpine.js - acara dan gudang data global</a></li>
<li><a href="../ja451092/index.html">ソーシャルプロジェクト「Remember Everyone」のソフトウェア実装をオープンソースにした経験</a></li>
<li><a href="../ja451098/index.html">プロジェクトのオーディオサンプルの入手先：9つのテーマ別リソースの選択</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>