<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥚 ⛪️ ♈️ 我们抽跑步机 📢 🛶 👩🏿‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，我决定为自己进行一次非常奇怪的购买。是的，我买了跑步机。
 
 
 
 很快我就意识到，没有像骑自行车那样详细的统计信息。如果是自行车，手机上的应用程序会记录我的速度，心率，脚踏圈速和举重。在培训过程中控制所有这些参数，以便能够查看图表并不时比较结果，这是非常好奇的。
 
 因此，我决定对跑步...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>我们抽跑步机</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502368/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最近，我决定为自己进行一次非常奇怪的购买。</font><font style="vertical-align: inherit;">是的，我买了跑步机。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/iw/er/bm/iwerbme5xz1jbn_rah5ihonnyv4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
很快我就意识到，没有像骑自行车那样详细的统计信息。</font><font style="vertical-align: inherit;">如果是自行车，手机上的应用程序会记录我的速度，心率，脚踏圈速和举重。</font><font style="vertical-align: inherit;">在培训过程中控制所有这些参数，以便能够查看图表并不时比较结果，这是非常好奇的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我决定对跑步机执行类似的操作：将其连接到智能手机或平板电脑以收集和显示统计信息。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
像往常一样，我的故事是通过传统的文字文章和视频的形式。</font><font style="vertical-align: inherit;">如您所愿。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频</font></font></h2><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ChTILq0P7Ok" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设计</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
即使在我收集跑步机的那一刻，我也注意到遥控器和跑带本身仅连接了四根电线。显然，其中一些用于为控制台供电，因为画布本身已连接至220伏特网络，并且需要其余电线沿相反方向传输控制信号-从控制台到画布，它们控制轨道的速度和角度。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将示波器与这些导线并联连接，尝试使用不同的组合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，我发现一切都与我预期的相同。一根导线接地，另一根为12伏电源。其余的传输数字数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其中之一，信号在切换速度和角度时发生变化。</font><font style="vertical-align: inherit;">这正是我所需要的！</font><font style="vertical-align: inherit;">信号幅度约为4伏。</font><font style="vertical-align: inherit;">但是该协议看起来不像是标准协议，并且信号非常嘈杂，当轨道开启时，您需要以某种方式对其进行过滤。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gm/nu/wq/gmnuwqpcnnxeo0ut0uxqs3wpnk0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后一根导线只是具有恒定频率的脉冲。</font><font style="vertical-align: inherit;">显然，控制台可以看到与跑带的连接。</font><font style="vertical-align: inherit;">如果断开此线的连接，遥控器将立即发出错误消息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些电线上脉冲传感器发出的指示显然不会传送，但这不是必需的。</font><font style="vertical-align: inherit;">最好连接一个单独的胸部传感器，骑自行车时我已经使用了很长时间。</font><font style="vertical-align: inherit;">此外，事实证明，跑步机本身的心率传感器躺在地上，低估了读数。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设备组装</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，下一个任务是组装一块与这些电线平行连接的板，读取当前的速度和角度，然后以某种方式将其无线传输到平板电脑或智能手机。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我再次决定使用Onion Omega2单板计算机。他必须做得很好。仅需将电源电压降低至3.3伏，并过滤掉干扰数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了降低电压，我现在将这些现成的板与DC-DC转换器一起使用。它们要花费几分钱，可以承受几安培的电流，并且可以通过扭曲来调节输出电压。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ac/lj/xo/acljxovuyfsah8j57fccxnxpboi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同时，该板的结论是直接焊接到另一个板上，非常方便。最主要的是在电路中安装后不要扭曲电压。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了滤除数据线上的噪声，我制作了一个常规的RC滤波器：一个2.2千欧的电阻和一个22皮法拉的电容器。</font><font style="vertical-align: inherit;">这样可以滤除高频噪声，留下低频信号。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原来是一条小围巾。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0k/bt/2e/0kbt2easvesiu_xpo5hwwr-wyzq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将其连接到跑步机导线上，以查看信号在打开时的滤波效果如何，显然，波形已变得几乎完美。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i-/dt/jo/i-dtjo2zc2onozxqv1i2ai7alse.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内核模块</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，检查熨斗的性能并不容易。正如我们</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
之前在示波器上所</font><font style="vertical-align: inherit;">看到</font><font style="vertical-align: inherit;">的，信号运行非常快，我们不使用微控制器，而是使用装有Linux的单板Omega2计算机。在Linux下，我们将无法如此迅速地处理来自用户空间的信号。但是从核心来看我们可以！因此，是时候编写Linux内核模块了！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，您需要下载Linux内核源代码（在我们的情况下，这是Omega2的OpenWRT程序集），并创建一个目录，其中包含我们模块的源代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编写模块代码很像对微控制器进行编程。我们还用C编写，所有内容都是低级的，我们还处理中断，还介绍了GPIO结论。仅在这里，除了上述所有内容之外，我们仍在通过伪文件与用户空间进行交互。因此，我们的内核模块成为硬件和普通应用程序之间的一种适配器。实际上，这称为驱动程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
起初，我不知道如何解码信号，所以我只是推导出它们的持续时间。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v2/qg/ou/v2qgouholyhcstqxsph1nkjyfyy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
很快就清楚了，信号是用高电平持续时间编码的。长度为600微秒或1200微秒。除初始序列外，低电平始终为600微秒。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总共有17个这样的下降。</font><font style="vertical-align: inherit;">显然，这是16位数据加上初始序列。</font><font style="vertical-align: inherit;">我进行了解码，并以此为依据，长的高差是逻辑零，而短的高差是逻辑单位，我就知道发生了什么。</font><font style="vertical-align: inherit;">我立即看到了我需要的数据！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d0/if/oh/d0ifohb7jktcyh6poivdersopr8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所知，16位是两个字节。</font><font style="vertical-align: inherit;">第一个字节指示要传输的数据类型：倾斜角度或速度，第二个字节指示数据本身。</font><font style="vertical-align: inherit;">驱动程序非常简单。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
唯一的驱动程序参数是端口号。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Module parameters */</span>
<span class="hljs-keyword">static</span> u8 receive_pin = <span class="hljs-number">11</span>;<font></font>
module_param(receive_pin, byte, S_IRUGO);<font></font>
MODULE_PARM_DESC(receive_pin,<span class="hljs-string">"Treadmill receiver pin number (default 11)"</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初始化时，将其配置为输入并设置中断，每次中断级别更改时都会触发该中断。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Allocate and init the timer */</span>
data_recv_timer = kzalloc(<span class="hljs-keyword">sizeof</span>(struct hrtimer), GFP_KERNEL);
<span class="hljs-keyword">if</span> (!data_recv_timer) {<font></font>
    pr_err(<span class="hljs-string">"treadmill: can't allocate memory for timer\n"</span>);<font></font>
    treadmill_free();<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}<font></font>
hrtimer_init(data_recv_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);<font></font>
data_recv_timer-&gt;function = recv_timer_callback;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种中断下，我们首先查看当前时间。接下来，我们使用此值来计算自上一次触发中断以来已过去了多少时间，并将其放入数组中。当然，我们会记住当前时间以进行下一次计算。此外，您必须重新启动特殊计时器。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* IRQ fired every rising/falling edge of receiver pin */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">irq_handler_t</span> <span class="hljs-title">treadmill_irq_handler</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> irq,
    <span class="hljs-keyword">void</span> *dev_id, struct pt_regs *regs)</span>
</span>{<font></font>
    u64 now = ktime_to_us(ktime_get_boottime());<font></font>
    u8 value = gpio_get_value(receive_pin);<font></font>
    u64 time_passed;<font></font>
    reset_recv_timer();<font></font>
<font></font>
    <span class="hljs-keyword">if</span> ((timings_pos &amp; <span class="hljs-number">1</span>) == value)<font></font>
    {<font></font>
        time_passed = now - last_time;<font></font>
        <span class="hljs-keyword">if</span> (timings_pos &lt; TIMINGS_BUFFER_SIZE)<font></font>
        {<font></font>
            timings[timings_pos] = time_passed;<font></font>
            timings_pos++;<font></font>
        }<font></font>
        last_time = now;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">/* Announce that the IRQ has been handled correctly */</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">irq_handler_t</span>) IRQ_HANDLED;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
诀窍在于，如果计时器仍然可以工作，则意味着该引脚长时间没有电平下降，因此该是处理收集到的信息的时候了。</font><font style="vertical-align: inherit;">在计时器调用的函数中，检查是否恰好有34个滴，然后我们查看每个间隔有多长时间。</font><font style="vertical-align: inherit;">如果有600微秒，然后是1200微秒，那么我们要花900国外；如果间隔较小，则在结果中写入1，然后将其移动一位。</font><font style="vertical-align: inherit;">处理完每个间隔后，我们将结果发送到打开的伪文件中，从而将数据传输到用户空间。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Timer */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> hrtimer_restart <span class="hljs-title">recv_timer_callback</span><span class="hljs-params">(struct hrtimer *timer)</span>
</span>{
    <span class="hljs-keyword">int</span> i, p;<font></font>
    u16 data;<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (timings_pos != <span class="hljs-number">34</span>) {<font></font>
        pr_debug(<span class="hljs-string">"treadmill: invalid edges count: %d"</span>, timings_pos);<font></font>
        timings_pos = <span class="hljs-number">0</span>; 
        <span class="hljs-keyword">return</span> HRTIMER_NORESTART;<font></font>
    }<font></font>
<font></font>
    data = <span class="hljs-number">0</span>;   
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt; timings_pos; i += <span class="hljs-number">2</span>)<font></font>
    {<font></font>
        data &gt;&gt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (timings[i] &lt; <span class="hljs-number">900</span>) <span class="hljs-comment">// 600us = 1, 1200 us = 0</span>
            data |= <span class="hljs-number">0x8000</span>;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">for</span> (p = <span class="hljs-number">0</span>; p &lt; <span class="hljs-number">2</span>; p++) {
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; treadmill_number_opens; i++) {
            <span class="hljs-keyword">if</span> (!(opened_files[i]-&gt;f_mode &amp; FMODE_READ)) <span class="hljs-keyword">continue</span>;<font></font>
            ((struct <span class="hljs-keyword">cfile_t</span>*)opened_files[i]-&gt;private_data)-&gt;receiver_buffer[<font></font>
                ((struct <span class="hljs-keyword">cfile_t</span>*)opened_files[i]-&gt;private_data)-&gt;receiver_write_pos++<font></font>
                % RECEIVER_BUFFER_SIZE] = (data &gt;&gt; (<span class="hljs-number">8</span> * p)) &amp; <span class="hljs-number">0xFF</span>;<font></font>
        }<font></font>
    };<font></font>
    wake_up_interruptible(&amp;wq_data);<font></font>
<font></font>
    timings_pos = <span class="hljs-number">0</span>; <font></font>
   <font></font>
    <span class="hljs-keyword">return</span> HRTIMER_NORESTART;<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python服务器和速度检测</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后剩下的就是编写一个Python脚本，该脚本将从伪文件中读取它们并将它们作为JSON字符串通过网络发送。似乎一切都很简单。但是，如果倾斜角度的一切都很简单，而第二个字节中的值恰好与倾斜角度的百分比相对应，那么在速度方面，一切都会变得更加混乱。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
值9表示每小时一公里，值160表示每小时18公里。也就是说，数据对实际速度的依赖性一点都不明显。我手动写出所有值，将它们驱入Excel，绘制并绘制出非常不均匀的曲线。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p0/cp/gt/p0cpgtrosoipnmqnjmfluzntiiu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当遥控器上的读数不同时，速度也会有所提高，但是轨道本身的数据和速度却保持不变！例如，5.2 km / h和5.3 km / h实际上是相同的速度。到处都是作弊。我想知道到底有多快？以某种方式对其进行测量，但留待以后使用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了将鹦鹉转移到每小时公里之外，该脚本非常简单。我们从Linux伪文件中读取数据，对其进行解码，接受网络连接，并将数据作为JSON字符串传输到通过网络连接的客户端。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreadmillServer</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, device = <span class="hljs-string">"/dev/treadmill"</span>, port = <span class="hljs-number">11010</span>, interface = <span class="hljs-string">'0.0.0.0'</span></span>):</span><font></font>
        self._device = device<font></font>
        self._port = port<font></font>
        self._interface = interface<font></font>
        self._working = <span class="hljs-literal">False</span><font></font>
        self._clients = []<font></font>
        self._server_sock = <span class="hljs-literal">None</span>
        self.incline = <span class="hljs-number">0</span>
        self.speed = <span class="hljs-number">0</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self</span>):</span>
        self._working = <span class="hljs-literal">True</span><font></font>
        self._server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<font></font>
        self._server_sock.bind((self._interface, self._port))<font></font>
        self._server_sock.listen(<span class="hljs-number">10</span>)<font></font>
        print(<span class="hljs-string">"Listening port"</span>, self._port)<font></font>
        Thread(target=self._port_listener, name=<span class="hljs-string">"Treadmill port listener"</span>, daemon=<span class="hljs-literal">True</span>).start()<font></font>
        Thread(target=self._device_listener, name=<span class="hljs-string">"Treadmill device listener"</span>, daemon=<span class="hljs-literal">True</span>).start()<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop</span>(<span class="hljs-params">self</span>):</span>
        self._working = <span class="hljs-literal">False</span>
        <span class="hljs-keyword">if</span> self._server_sock != <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">try</span>:<font></font>
                self._server_sock.close()<font></font>
            <span class="hljs-keyword">except</span>:
                <span class="hljs-keyword">pass</span>
            self._server_sock = <span class="hljs-literal">None</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self</span>):</span><font></font>
        self.stop()<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_port_listener</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">while</span> self._working <span class="hljs-keyword">and</span> self._server_sock:
            <span class="hljs-keyword">try</span>:<font></font>
                conn, addr = self._server_sock.accept()<font></font>
                print(<span class="hljs-string">'Connected: {0}'</span>.format(addr))<font></font>
                TreadmillClientConnection(self, conn, addr)<font></font>
            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<font></font>
                print(<span class="hljs-string">"Error:"</span>, e)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为这里不需要授权和安全性。</font><font style="vertical-align: inherit;">跑步机的状态不是我想要保护免受黑客攻击的数据类型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将此脚本放入启动阶段，然后删除跑步机内部的板。</font><font style="vertical-align: inherit;">,，它仅适合将控制台连接到跑步带的金属管中。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/q9/s3/ab/q9s3abxgl3zhcxxepbj4n46onog.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所知，金属屏蔽了无线电信号，因此我将Wi-Fi天线从管道中拿出，但是放在了隐藏电线的塑料外壳下面。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k8/j4/op/k8j4op4zjjbwby41ltcahq_hgxa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这台直接的“智能”跑步机上即可使用。</font><font style="vertical-align: inherit;">她已经知道如何通过网络分发统计信息。</font><font style="vertical-align: inherit;">只为她写一个客户！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android客户端</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为应该是这样的客户。</font><font style="vertical-align: inherit;">这是一个Android应用程序，我将在平板电脑或智能手机上运行该应用程序，并将其分别放在跑步机本身的显示屏上，它应该在屏幕上显示锻炼中的所有信息，从而代替跑步机本身的显示屏。</font><font style="vertical-align: inherit;">该应用程序应该能够在后台运行，以便我可以在慢跑时观看视频而不会出现问题。</font><font style="vertical-align: inherit;">此外，它还应保留运行的详细统计信息，使一切与云同步，并绘制出脉冲对速度和倾斜角度的依赖性图表。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种应用程序的核心应该是在后台运行，以无限循环连接到跑步机，接收数据并对其进行解码的服务。</font><font style="vertical-align: inherit;">在这方面没有特别的困难。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">心率传感器</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最困难的事情是突然使用心率传感器。</font><font style="vertical-align: inherit;">发现了许多陷阱。</font><font style="vertical-align: inherit;">我这里有这样的胸部心率监测器：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c5/sy/w1/c5syw10i53ey_zkbcjjrdpmxpzm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
骑自行车时，我已经使用了很长时间了。</font><font style="vertical-align: inherit;">它是非常标准的，可以在BLE和蓝牙低功耗蓝牙上工作，可以与手机和Garmin导航仪配对，而不会出现任何问题。</font><font style="vertical-align: inherit;">我什至不能认为从我的应用程序中使用它会变得如此显而易见。</font><font style="vertical-align: inherit;">这种传感器具有用于不同读数的标准GUID。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要开始接收心率，您必须首先将心率监视器配置为定期发送读数。</font><font style="vertical-align: inherit;">我只能通过研究非工作示例并通过键入来做到这一点。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，我编写了一个与心率传感器一起使用的类，该类会自动尝试连接到它并定期报告当前心率。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三星健康SDK</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至于统计和图表。</font><font style="vertical-align: inherit;">我决定不重新发明轮子，而是使用骑自行车时已经使用的东西，即以某种方式通过出色的Samsung Health应用结识朋友。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在可能看起来像是我再次在宣传三星。</font><font style="vertical-align: inherit;">但是在自行车上，此应用程序确实非常出色。</font><font style="vertical-align: inherit;">令我惊讶的是，它可以毫无问题地连接到所有传感器，同时显示节奏和车轮速度，并指示耳机中的统计数据，并使用图形显示相同的统计数据，并给出成果并将所有内容存储在云中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
搜索结果显示，三星健康拥有自己的SDK，尽管不是完全可理解，但仍在文档中：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">img-developer.samsung.com/onlinedocs/health/android/data/index.html</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用它实际上是在使用一个数据库，该数据库存储从采取的步骤和心率测量到血糖和睡眠阶段的各种读数。</font><font style="vertical-align: inherit;">但是我们现在对运动记录感兴趣，包括运动类型，时间，距离，持续时间，燃烧的卡路里等标量值，以及心率，速度和坐标的历史记录等实时数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这些数据必须正确存储和准备。</font><font style="vertical-align: inherit;">需要计算一些。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高度计算</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，提升高度。</font><font style="vertical-align: inherit;">从跑步机上，我们知道每个时间点的爬升角度，以百分比为单位。</font><font style="vertical-align: inherit;">仰角百分比是爬升距离的比例。</font><font style="vertical-align: inherit;">事实证明，垂直速度等于通常速度乘以斜率的百分比并除以一百。</font><font style="vertical-align: inherit;">知道了垂直速度，我们可以计算每个时刻的当前高度。</font><font style="vertical-align: inherit;">因此，尽管在练习中它们没有变化并且没有被考虑，但必须将其输入当前坐标。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据这些数据，Samsung Health应用程序将显示我应该攀登的高度以及每次训练时的垂直速度。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">卡路里计数</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是如何计算卡路里？此外，卡路里计数是三星健康的必需品。同时，燃烧的卡路里是一个非常不准确的指标，它取决于许多不同的因素。不知道对它们进行计数是否有意义。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我没有提出自己的建议，只是用谷歌计算器（https://42.195km.net/e/treadsim/）并从我的javascript（https://42.195km.net/e/treadsim/treadsim107）复制了算法.js）。在入口处，他以行进距离，仰角和重量为准。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我可以手动设置体重，但是由于我们正在与Samsung Health合作，因此我可以从那里获取当前体重。</font><font style="vertical-align: inherit;">毕竟，我使用小米的智能秤，该智能秤与手机上的Google Fit同步，通过单独的应用程序的Google FIt与Samsung Health同步，通过云的Samsung Health与平板电脑上的自身同步，我的应用程序已经在其中接收了它。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用外观</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在视觉上，该应用程序的任务是大规模显示主要指标：速度，角度，心率，距离，卡路里。最好在黑色背景上以白色进行此操作，以使使用AMOLED屏幕时的电池消耗最少，因为我们明确表示在显示活动时，屏幕应始终打开。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ss/qz/6b/ssqz6bqch_3xljgjpbrzba3ykzy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当跑步机处于活动状态时，按钮将自动隐藏。您只能以零速度开始和停止训练。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，您需要支持“画中画”模式。只需几行即可完成。您只需要在清单中指出活动支持此模式，并在最小化应用程序时在代码中注明。因此，您可以观看例如YouTube，并在屏幕一角看到跑步机读数。原来很方便。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yt/0c/ls/yt0clswyb0ua3o3x5oopusvy5ie.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是在这个阶段，我终于被Android开发人员的痛苦所取代，因为我已经获得了四种不同的屏幕尺寸：手机和平板电脑处于正常模式，它们也处于“画中画”模式。碰巧的是，如果我为一个屏幕大小选择了正常的字体大小，那么在其他情况下，一切都太小了，然后又太大了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在为Android开发时，屏幕分为几类，您可以自动为它们应用不同的设置，但就我而言，这还不够。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，我不得不计算并设置代码中的字体大小，我认为这是非常错误的。</font><font style="vertical-align: inherit;">但是，它可以完美地工作。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是结果。</font><font style="vertical-align: inherit;">我们打开应用程序，等待与跑步机和心率传感器的连接，开始训练并照常使用跑步机。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
锻炼结束后，我们停止跑步机。</font><font style="vertical-align: inherit;">达到零速时，将显示“完成训练”按钮。</font><font style="vertical-align: inherit;">单击它，统计信息将发送到Samsung Health。</font><font style="vertical-align: inherit;">打开它并查看所有数据。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xz/-q/e5/xz-qe5ipelysxlqfmfzayv8m6uc.png"><br>
<br>
<img src="https://habrastorage.org/webt/jn/m9/md/jnm9mdprmuyul2_bcdqbd8clzrc.png"><br>
<br>
<img src="https://habrastorage.org/webt/tg/gh/lx/tgghlxokyu_l7sxghej5fzm1u0s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以查看脉搏，速度和上升的图表，比较不同时间间隔的进度，所有这些都存储在云中，并且可以从所有设备访问。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以将其与Google Fit同步。</font><font style="vertical-align: inherit;">美丽。</font><font style="vertical-align: inherit;">我对结果感到满意。</font><font style="vertical-align: inherit;">现在最主要的是不要抛出类。</font><font style="vertical-align: inherit;">您可以添加该应用程序的功能，以便在长时间懒惰时类似于训练。</font><font style="vertical-align: inherit;">但是我已经懒得去做这个功能。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN502354/index.html">IaaS提供商正在争夺欧洲市场-讨论情况和行业事件</a></li>
<li><a href="../zh-CN502358/index.html">WinForms应用程序中基于ApplicationController和IoC的MVP的实现</a></li>
<li><a href="../zh-CN502360/index.html">灰熊放电或超级钻</a></li>
<li><a href="../zh-CN502362/index.html">学习Windows的事件跟踪：理论与实践</a></li>
<li><a href="../zh-CN502366/index.html">比较开源Python的工作-用于识别命名实体的库</a></li>
<li><a href="../zh-CN502370/index.html">将游戏“ Snake”放在实验板上。第1部分：状态机</a></li>
<li><a href="../zh-CN502372/index.html">盒装Bitrix24的定制问题和原则</a></li>
<li><a href="../zh-CN502374/index.html">FT8通信协议-工作原理</a></li>
<li><a href="../zh-CN502380/index.html">芹菜+异步</a></li>
<li><a href="../zh-CN502382/index.html">接口自行车有毒的祖父。“谎言，威胁和勒索。” （s1 e6）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>