<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüî¨ üë®üèæ‚Äçüè≠ üëæ Implementamos convers√µes de c√≥digo Python üïµüèø ü§ï üíÉüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√°, Habr. 
 
 Hoje, oferecemos uma tradu√ß√£o de um artigo que aborda um t√≥pico que n√£o √© o mais discutido: compila√ß√£o de c√≥digo em Python, a saber: tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Implementamos convers√µes de c√≥digo Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/493424/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ol√°, Habr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoje, oferecemos uma tradu√ß√£o de um artigo que aborda um t√≥pico que n√£o √© o mais discutido: compila√ß√£o de c√≥digo em Python, a saber: trabalhar com √°rvore de sintaxe abstrata (AST) e c√≥digo de bytes. Embora o Python seja uma linguagem interpretada, esses recursos s√£o extremamente importantes do ponto de vista da otimiza√ß√£o. Hoje falaremos sobre eles.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ j√° se perguntou como exatamente o compilador otimiza seu c√≥digo para que ele funcione mais r√°pido? </font><font style="vertical-align: inherit;">Deseja saber o que √© uma √°rvore de sintaxe abstrata (AST) e para que ela pode ser usada? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artigo de revis√£o descreve como o c√≥digo Python √© convertido em formato de √°rvore (AST). </font><font style="vertical-align: inherit;">Depois de criar o AST do seu programa, voc√™ pode prosseguir na busca por op√ß√µes de otimiza√ß√£o e transforma√ß√£o para o seu c√≥digo. </font><font style="vertical-align: inherit;">No entanto, lembre-se de que otimizar programas Python de maneiras n√£o triviais √© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extremamente dif√≠cil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥digo de programa como uma √°rvore</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como um computador pode garantir que ele avalie express√µes do seu c√≥digo na ordem correta? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fazer isso, ele primeiro refaz o c√≥digo do programa em uma estrutura de √°rvore chamada AST. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao trabalhar com uma linguagem de programa√ß√£o interpretada (como Python), geralmente √© aceito que o int√©rprete passe pelo seu c√≥digo e fa√ßa tudo o que encontrar, no local, sem converter o c√≥digo Python em c√≥digo de m√°quina de forma alguma. No entanto, na pr√°tica, esse esquema de execu√ß√£o causa muitos problemas, o que o torna muito inconveniente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tomemos, por exemplo, um problema simples como a prioridade dos operadores. Em uma express√£o de exibi√ß√£o </font></font><code>3 + 4 * x </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a pe√ßa √© calculada primeiro</font></font><code>4 * x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e somente ent√£o 3 podem ser adicionados ao resultado da multiplica√ß√£o. Talvez voc√™ tenha aprendido a preced√™ncia dos operadores nas aulas de matem√°tica desenhando essas √°rvores sob a express√£o: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xw/lr/sp/xwlrspwopyld8gohdzt4jxgwauu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python usa as regras padr√£o da nota√ß√£o matem√°tica (multiplica√ß√£o primeiro, depois adi√ß√£o). Para n√£o confundir nada com a prioridade dos operadores, no Python, primeiro √© constru√≠da uma √°rvore como na figura anterior. A opera√ß√£o geral √© a adi√ß√£o (na raiz da √°rvore) e, enquanto o lado esquerdo dessa soma √© um n√∫mero regular, √† direita temos o produto. A estrutura de dados resultante √© assim:</font></font><br>
<br>
<pre><code class="python hljs">BinOp(<font></font>
  left  = Num(<span class="hljs-number">3</span>),<font></font>
  op    = Add(),<font></font>
  right = BinOp(<font></font>
            left  = Num(<span class="hljs-number">4</span>),<font></font>
            op    = Mult(),<font></font>
            right = Name(<span class="hljs-string">'x'</span>)<font></font>
          )<font></font>
)<font></font>
</code></pre><br>
<code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significa Opera√ß√£o Bin√°ria (Opera√ß√£o Bin√°ria) e indica que em opera√ß√µes como adi√ß√£o e multiplica√ß√£o - dois operandos. Naturalmente, voc√™ n√£o receber√° nenhuma adi√ß√£o se a parte certa da express√£o n√£o tiver o valor correto. Portanto, voc√™ deve primeiro se multiplicar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na teoria dos compiladores e linguagens de programa√ß√£o, essa √°rvore √© chamada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstract Syntax Tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AST,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para abreviar. O AST no exemplo acima inclui dois n√≥s </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dois n√≥s </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e um n√≥ </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° um recurso interessante no Python - a capacidade de exibir e exibir diretamente o AST para qualquer programa espec√≠fico do Python. Tudo o que √© necess√°rio √© importar um m√≥dulo padr√£o</font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, analisando o programa e exibindo o resultado na tela (a prop√≥sito, analisar √© o processo de convers√£o do c√≥digo-fonte do programa na √°rvore AST).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
my_tree = ast.parse(<span class="hljs-string">"3 + 4*x"</span>)<font></font>
print(ast.dump(my_tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, voc√™ notar√° que haver√° n√≥s e campos adicionais no AST gerados pelo Python, e ele ser√° exibido em uma linha, o que torna √† primeira vista mais complicado do que realmente √©. </font></font><br>
<br>
<pre><code class="python hljs">Module(body=[Expr(value=BinOp(left=Num(n=<span class="hljs-number">3</span>), op=Add(), right=BinOp(left=Num(n=<span class="hljs-number">4</span>), op=Mult(), right=Name(id=<span class="hljs-string">'x'</span>, ctx=Load()))))])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos dividi-lo em n√≥s separados, como da √∫ltima vez - e reabrir o AST, j√° no topo, como parte de toda a √°rvore: </font></font><br>
<br>
<pre><code class="python hljs">Module(body = [<font></font>
    Expr(<font></font>
        value = BinOp(<font></font>
            left  = Num(n=<span class="hljs-number">3</span>),<font></font>
            op    = Add(),<font></font>
            right = BinOp(<font></font>
                left  = Num(n=<span class="hljs-number">4</span>),<font></font>
                op    = Mult(),<font></font>
                right = Name(id=<span class="hljs-string">'x'</span>, ctx=Load())<font></font>
            )<font></font>
        )<font></font>
    )<font></font>
])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, o Python "pensa" que a linha que fornecemos para an√°lise √© um m√≥dulo inteiro. O corpo do m√≥dulo √© uma lista de todas as instru√ß√µes contidas nele. A √∫nica instru√ß√£o em nosso exemplo √© uma express√£o </font></font><code>Expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cujo significado √© exatamente o que discutimos acima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota: o n√≥ </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">possui um campo adicional </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(abreviado como "contexto"), que possui um valor </font></font><code>Load()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ent√£o, o Python diz que usamos o valor armazenado na vari√°vel </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e n√£o (re) definimos ou exclu√≠mos o nome </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Agora, sua jogada, tente analisar algo como voc√™ </font></font><code>del x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font><font style="vertical-align: inherit;">voc√™ </font></font><code>x = 123</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e voc√™ ver√° como o campo </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no n√≥ </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muda para </font></font><code>Del()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>Store()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, respectivamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A prop√≥sito: se voc√™ instalar o m√≥dulo</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">astunparse</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a sa√≠da AST para a tela pode ficar muito mais bonita e at√© converter o AST novamente em c√≥digo Python ativo.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O processo de compila√ß√£o: o restante</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de coletar os programas AST, √© poss√≠vel, em princ√≠pio, concluir todo o programa, percorrendo o AST e executando as opera√ß√µes na ordem em que s√£o indicados. No entanto, essa abordagem tem pelo menos duas desvantagens. Em primeiro lugar, o AST pode ocupar uma quantidade relativamente grande de mem√≥ria, especialmente se contiver informa√ß√µes redundantes. Em segundo lugar, o percurso AST pode levar mais tempo do que o necess√°rio. Em resumo: isso pode ser feito, mas √© ineficiente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O compilador n√£o processa o AST diretamente, mas prepara o bytecode, que √© ent√£o executado na m√°quina virtual Python. Embora discutir os detalhes desse processo esteja al√©m do escopo deste artigo, o princ√≠pio b√°sico √© que o compilador converte o AST em nota√ß√£o polonesa reversa (RPN). Em vez de colocar um operador</font></font><code>+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entre os operandos esquerdo e direito, colocamos ap√≥s os dois operandos. No exemplo </font></font><code>3 + 4*x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acima, obtemos a sequ√™ncia </font></font><code>3 4 x * +</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(e essa nota√ß√£o √© especialmente boa porque voc√™ pode ver imediatamente a partir da sequ√™ncia: primeiro voc√™ precisa executar a multiplica√ß√£o e somente depois a adi√ß√£o). Como cada um dos cinco elementos nessa sequ√™ncia pode, em princ√≠pio, ser representado como um √∫nico byte, esse c√≥digo √© chamado de c√≥digo de byte. O Python usa a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√°quina virtual empilhada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para executar esse c√≥digo com efici√™ncia.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em outras palavras, o processo de compila√ß√£o de um programa escrito em Python ocorre em dois est√°gios. </font><font style="vertical-align: inherit;">Primeiro, o programa recebido pela entrada √© analisado e o resultado √© uma √°rvore de sintaxe abstrata (AST). </font><font style="vertical-align: inherit;">O compilador passa pelo AST e gera o bytecode. </font><font style="vertical-align: inherit;">Depois disso, o int√©rprete Python executa esse bytecode. </font><font style="vertical-align: inherit;">Tendo adotado a otimiza√ß√£o, ela pode ser aplicada no n√≠vel AST ou no n√≠vel do bytecode. </font><font style="vertical-align: inherit;">Ambas as op√ß√µes t√™m suas pr√≥prias vantagens e desvantagens. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por fim, lembre-se de que, embora o AST seja comum em qualquer implementa√ß√£o do Python, o processo de convers√£o do AST em bytecode pode ser diferente e, em algumas implementa√ß√µes do Python, digamos, JavaScript, em vez de bytecode, pode ser gerado no est√°gio intermedi√°rio.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paradigmas de outras linguagens de programa√ß√£o</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nem todas as linguagens de programa√ß√£o usam nota√ß√£o infix, como no Python. </font><font style="vertical-align: inherit;">Dois exemplos dignos de nota nesse caso s√£o o PostScript, onde o programa √© escrito diretamente em nota√ß√£o polonesa reversa e o Lisp, √© claro, onde os programas geralmente s√£o escritos em nota√ß√£o polonesa. </font><font style="vertical-align: inherit;">Ent√£o, a nossa express√£o do exemplo acima, em Lisp tomaria a seguinte forma: </font></font><code>(+ 3 (* 4 x))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convers√£o de n√≥ no AST</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tendo um programa AST, como converter partes individuais desta √°rvore? Com os convenientes recursos internos do Python. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se dermos uma olhada no AST e, por exemplo, descobrirmos que os campos </font></font><code>left</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e os </font></font><code>right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√≥s </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√£o n√∫meros (n√≥s </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), podemos executar os c√°lculos correspondentes com anteced√™ncia e substitu√≠-los por um </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√≥ normal </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, voc√™ precisa agir com muito cuidado para n√£o alterar o comportamento do programa, fazendo essas transforma√ß√µes. Por exemplo, em </font></font><code>len([a(), b(), c(), d()])</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, fica claro que o resultado √© 4. Mas n√£o podemos substituir toda a express√£o do n√∫mero 4 porque quatro fun√ß√µes </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ainda foram devidamente invocado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Novamente, comece com uma otimiza√ß√£o simples. Sempre que um nome aparecer no c√≥digo-fonte de um programa </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, substitua-o pelo valor 3.14159265. O m√≥dulo Python </font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j√° fornece as estruturas de dados necess√°rias para fazer isso: uma classe de conversor </font></font><code>NodeTransformer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que passa por todos os ASTs e verifica se cada n√≥ pode ser substitu√≠do. Por padr√£o, o m√©todo de transforma√ß√£o simplesmente retorna o n√≥ de origem para cada n√≥, para que obtenhamos o mesmo AST a partir do qual come√ßamos. Mas podemos facilmente substituir o m√©todo para n√≥s </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, digamos, para que ele verifique </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se √© e, em seguida, retorne o n√≥ em </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez do n√≥ com o nome original ...</font></font><br>
<br>
<pre><code class="python hljs">	<span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:
            <span class="hljs-keyword">return</span> ast.Num(n=<span class="hljs-number">3.14159265</span>)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que o conversor / otimizador passe pela nossa √°rvore, √© necess√°rio chamar seu m√©todo </font></font><code>visit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que retornar√° uma nova √°rvore alterada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, √© imposs√≠vel compilar e executar o AST resultante; a raz√£o para isso √© um detalhe t√©cnico. Isso ainda n√£o est√° vis√≠vel, mas (quase) todos os n√≥s no AST tamb√©m possuem campos </font></font><code>lineno</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>col_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Eles indicam a posi√ß√£o exata de um n√≥ espec√≠fico no c√≥digo-fonte. Se voc√™ n√£o instal√°-los corretamente, o compilador jurar√° e se recusar√° a trabalhar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, vamos copiar os campos apropriados do n√≥ de origem </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o novo n√≥ </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Voc√™ pode ent√£o compilar e executar o AST resultante:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)<font></font>
            result.lineno = node.lineno<font></font>
            result.col_offset = node.col_offset<font></font>
            <span class="hljs-keyword">return</span> result
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"print(2 * pi)"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
code = compile(tree, <span class="hljs-string">"&lt;string&gt;"</span>, <span class="hljs-string">"exec"</span>)<font></font>
exec(code)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a fun√ß√£o de compila√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requer n√£o apenas o c√≥digo-fonte (em que pode ser um programa em si, ou a linha de AST), mas o nome do arquivo (como pedimos </font></font><code>"&lt;string&gt;"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), bem como um dos tr√™s: </font></font><code>"exec"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>"eval"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>"single"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A necessidade de copiar os campos que descrevem a posi√ß√£o do n√≥ no c√≥digo-fonte surge com bastante frequ√™ncia. Portanto, o m√≥dulo </font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">possui uma fun√ß√£o dedicada </font></font><code>copy_location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas para esse fim, e podemos escrever:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por fim, voc√™ pode estender o exemplo anterior para que ele efetivamente otimize, ou seja, no n√≥ </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De acordo com a regra de transforma√ß√£o, primeiro devemos transformar / otimizar a esquerda e depois o n√≥ direito como parte do BinOp. </font><font style="vertical-align: inherit;">Se, como resultado, os n√≥s esquerdo e direito forem n√∫meros, os c√°lculos poder√£o ser realizados no local e substituir o original pelo </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resultado num√©rico da opera√ß√£o.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_BinOp</span>(<span class="hljs-params">self, node: ast.BinOp</span>):</span><font></font>
        node.left = self.visit(node.left)<font></font>
        node.right = self.visit(node.right)<font></font>
        <span class="hljs-keyword">if</span> isinstance(node.left, ast.Num) <span class="hljs-keyword">and</span> isinstance(node.right, ast.Num):
            <span class="hljs-keyword">if</span> isinstance(node.op, ast.Add):<font></font>
                result = ast.Num(n = node.left.n + node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
            <span class="hljs-keyword">elif</span> isinstance(node.op, ast.Mult):<font></font>
                result = ast.Num(n = node.left.n * node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi + 1"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A prop√≥sito, o compilador CPython j√° est√° otimizando os n√≥s, </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como mostrado aqui. </font><font style="vertical-align: inherit;">O c√≥digo correspondente √© escrito em C e √© fornecido em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python / ast_opt.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Observe: o otimizador CPython √© mais universal e funciona n√£o apenas com n√∫meros, como no exemplo que estamos considerando, mas com diferentes tipos de valores constantes.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificando n√≥s no AST</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como garantir que as transforma√ß√µes que fizemos foram corretas? Primeiro, voc√™ precisa ignorar completamente o AST e inspecionar todo o programa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O otimizador apresentado acima continua sendo uma falha s√©ria. O que acontece se voc√™ redefinir em algum lugar do programa </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Imagine algo t√£o simples e intelig√≠vel quanto </font></font><code>pi = 4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nosso otimizador simplesmente substituir√° pi no lado esquerdo da express√£o pelo valor num√©rico 3.14159265, e o Python se recusar√° a compilar porque n√£o pode atribuir nada a um valor literal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Talvez esse seja exatamente o comportamento que voc√™ buscou, tornando pi uma constante verdadeira, que √© substitu√≠da na compila√ß√£o e nunca pode ser reatribu√≠da, ou seja, n√£o pode obter um valor diferente. No entanto, isso definitivamente viola a sem√¢ntica do Python.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, o que fazer se quisermos manter a sem√¢ntica do Python, mas substituir pi sempre que poss√≠vel? Nesse caso, voc√™ primeiro precisa percorrer todo o programa e verificar se o valor de est√° atribu√≠do em algum lugar </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. At√© complicarmos: n√£o recorreremos √† substitui√ß√£o de pi se pelo menos um ponto do programa tiver uma atribui√ß√£o de valor para </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora usamos o n√≥ visitante, semelhante ao n√≥ conversor descrito acima. Diferentemente do conversor, o visitante n√£o pretende alterar nenhum n√≥, ele simplesmente passa pelo AST e examina os n√≥s (os visita). Assim, os m√©todos de visita n√£o retornam nada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No nosso caso, vamos verificar se o n√≥ refere-se </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e faz outra coisa sen√£o colocar o valor</font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(lembre-se do campo de contexto </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeVisitor</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>
        self.modify_pi = <span class="hljs-literal">False</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_FunctionDef</span>(<span class="hljs-params">self, node: ast.FunctionDef</span>):</span>
        <span class="hljs-keyword">if</span> node.name == <span class="hljs-string">'pi'</span>:<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
        self.generic_visit(node)<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> isinstance(node.ctx, ast.Load):<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
 <font></font>
program = <span class="hljs-string">"""
def pi():
    return 3.1415
print(2 * pi())
"""</span><font></font>
tree = ast.parse(program)<font></font>
my_visitor = MyVisitor()<font></font>
my_visitor.visit(tree)<font></font>
print(<span class="hljs-string">"Pi modified:"</span>, my_visitor.modify_pi)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O m√©todo </font></font><code>generic_visit(node)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© chamado pelo visitante para cada n√≥ para o qual n√£o fornecemos um m√©todo de visita especializado. </font><font style="vertical-align: inherit;">Em outras palavras: n√£o existe tal m√©todo </font></font><code>visit_FunctionDef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na classe </font></font><code>NodeVisitor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que poder√≠amos chamar usando </font></font><code>super()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em rela√ß√£o √†s defini√ß√µes de fun√ß√£o, devemos chamar um visitante gen√©rico para garantir que todo o corpo da fun√ß√£o tamb√©m seja processado corretamente. </font><font style="vertical-align: inherit;">Caso contr√°rio, poder√≠amos ocultar a instru√ß√£o na fun√ß√£o </font></font><code>global pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e alterar globalmente o valor </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para que nosso otimizador n√£o notasse nada.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valores locais em Python</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosso m√©todo, que nos permite determinar se o programador mudou pi, acabou sendo bastante rude. </font><font style="vertical-align: inherit;">No entanto, o compilador Python age de maneira muito semelhante quando determina quais nomes no escopo de uma fun√ß√£o correspondem √†s vari√°veis ‚Äã‚Äãlocais. </font><font style="vertical-align: inherit;">Se uma vari√°vel for alterada em algum lugar no escopo da fun√ß√£o (e n√£o for explicitamente globalizada, por exemplo, usando a instru√ß√£o global), essa vari√°vel ser√° considerada local em todo o escopo da fun√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O exemplo a seguir ser√° executado sem a quarta linha. </font><font style="vertical-align: inherit;">Mas, embora </font></font><code>x = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a quarta linha nunca seja executada, ainda √© considerada uma atribui√ß√£o a</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e, portanto, x se torna uma vari√°vel local na escala de toda a fun√ß√£o e at√© na linha 3. √â por isso que o Python jura que a vari√°vel x na terceira linha ainda n√£o importa.</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_x</span>():</span><font></font>
    print(x)<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>: x = <span class="hljs-number">0</span>
print_x()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ estiver interessado nos detalhes de exatamente como o Python funciona aqui, consulte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python / symtable.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclus√£o</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No Python, como na maioria das linguagens de programa√ß√£o, um programa espec√≠fico n√£o √© executado diretamente do c√≥digo-fonte. </font><font style="vertical-align: inherit;">De fato, a tradu√ß√£o do c√≥digo-fonte ocorre em dois est√°gios: primeiro, √© feita uma √°rvore de sintaxe abstrata (AST) e, em seguida, o c√≥digo de bytes para a m√°quina virtual empilhada. </font><font style="vertical-align: inherit;">O Python tamb√©m fornece v√°rios recursos muito bons para analisar e at√© transformar o AST de qualquer programa Python espec√≠fico, ap√≥s o qual o AST modificado pode ser compilado e executado. </font><font style="vertical-align: inherit;">Assim, podemos implementar facilmente nossas pr√≥prias otimiza√ß√µes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Claro, simplesmente omiti muitos detalhes aqui. </font><font style="vertical-align: inherit;">Garantir que sua otimiza√ß√£o funcione corretamente em todos os casos e circunst√¢ncias poss√≠veis √© uma quest√£o muito trivial. </font><font style="vertical-align: inherit;">No entanto, o objetivo deste artigo n√£o √© informar sobre a otimiza√ß√£o pronta para uso na produ√ß√£o, mas fornecer uma id√©ia b√°sica de como o Python analisa o c√≥digo do programa, para que voc√™ possa aprender como convert√™-lo corretamente e otimiz√°-lo.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt493408/index.html">DJI Mavic mini helic√≥ptero caiu como um p√© de cabra</a></li>
<li><a href="../pt493412/index.html">Jogos com Wifi no ESP32</a></li>
<li><a href="../pt493416/index.html">IDA Pro e t√©cnicas de engenharia reversa</a></li>
<li><a href="../pt493418/index.html">Por que o aprendizado de m√°quina usa dados "sint√©ticos"</a></li>
<li><a href="../pt493420/index.html">Minha maneira de apresentar Python aos alunos do ensino m√©dio</a></li>
<li><a href="../pt493426/index.html">Organiza√ß√£o do c√≥digo em microsservi√ßos e minha abordagem do uso da arquitetura hexagonal e DDD</a></li>
<li><a href="../pt493428/index.html">"N√£o daremos origem a teorias da conspira√ß√£o". Fale sobre confer√™ncias de ML com pessoas de empresas de ci√™ncia e TI</a></li>
<li><a href="../pt493430/index.html">Arquitetura de rede para aplicativos da Web</a></li>
<li><a href="../pt493432/index.html">Por que n√£o iniciar uma carreira em uma pequena empresa que n√£o √© de TI</a></li>
<li><a href="../pt493436/index.html">Programa para altera√ß√£o de direitos de acesso e registro de nomes de arquivos / diret√≥rios no Bash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>