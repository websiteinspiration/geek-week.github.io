<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐥 💳 🤜🏻 Apache Igniteでのデータ配布 🧘🏻 🎬 😶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは！この投稿は、Apache Igniteコミュニティミーティングでの私の名を冠した講演を少し要約したものです。ここで質問と回答とともに完全なビデオバージョンを見ることができ、ここからスライドをダウンロードできます。レポートでは、Apache Igniteでデータがどのように配布されるかを例...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Apache Igniteでのデータ配布</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/gridgain/blog/489962/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは！</font><font style="vertical-align: inherit;">この投稿は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache Ignite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コミュニティミーティングでの私の名を冠した講演を少し要約したものです</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で質問と回答とともに完全なビデオバージョンを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">見る</font></a><font style="vertical-align: inherit;">ことができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、ここ</font></a><font style="vertical-align: inherit;">からスライドを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダウンロードできます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">レポートでは、Apache Igniteでデータがどのように配布されるかを例で示してみました。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜ何かを配布する必要があるのですか</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データの保存と処理を必要とするシステムの開発のかなり標準的な歴史は、一定の上限の達成です。大量のデータがあり、それらが物理的にストレージデバイスに配置されていないか、1つのサーバーがそのような数の要求を処理できなくなるほどの速度で負荷が増大しています。両方が発生するケースが頻繁にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、既存のストレージをシャーディングするか、分散データベースに切り替えるという2つのソリューションのいずれかになります。どちらのソリューションにもいくつかの共通機能がありますが、最も明白なのは、データを操作するために複数のノードを使用することです。さらに、多くのノードをトポロジーと呼びます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トポロジノード間のデータ分散の問題は、一連の要件として定式化できます。この要件は、次の要件を満たす必要があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トポロジーのすべてのノードとクライアントアプリケーションが、特定のオブジェクト（またはキー）がどのノードにあるかについて同じ結論に到達できるようにするアルゴリズムが必要です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分布の均一性。</font><font style="vertical-align: inherit;">データがノード間でより均等に分散されるほど、これらのノードの負荷はより均等に分散されます。</font><font style="vertical-align: inherit;">ここでは、ノードがほぼ同じリソースを持っていると仮定しています。</font></font></li>
<li>  .      ,       ,    .   ,       ,       ,     .<br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の2つの要件を達成するのはかなり簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能的に同等のサーバー間で負荷を分散し、Nを法として分割する場合によく使用されるよく知られたアプローチ。Nはトポロジ内のノード数であり、ノード番号とその識別子は1対1で対応します。次に、オブジェクトのキーをハッシュ関数を使用して数値として表し、得られた値からNで割った余りを取得するだけです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zi/7x/ii/zi7xiiu8xmrjgaeghuc8xkekubk.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図は、3つのノードにわたる16個のキーの分布を示しています。この分布は均一であり、オブジェクトのノードを取得するアルゴリズムは単純であり、トポロジのすべてのノードがこのアルゴリズムを使用する場合、同じキーと同じNに対して同じ結果が得られることが保証されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、4番目のノードをトポロジーに導入するとどうなりますか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/82/ro/-i/82ro-ipa6d3lw8stb_fx7e9_wos.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数が変更されました。除算の残りの部分は3ではなく4になります。関数が変更された場合、分布も変更されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、3つのノードのトポロジの以前のバージョンのオブジェクトの以前の場所が赤で示され、4つのノードのトポロジの新しいバージョンのオブジェクトの位置がそれぞれ緑です。これは通常のdiffファイルとよく似ていますが、ファイルの代わりにノードがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データが新しいノードに移動しただけでなく、すでにトポロジー内にあったノード間でデータの交換があったことは簡単にわかります。それら。ノード間の偽のトラフィックを観察し、分布の最小限の変更という要件が満たされていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストされた要件を考慮して、データ配布の問題を解決する一般的な2つの方法は次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一貫したハッシュ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランデブーハッシュとも呼ばれる最大ランダムウェイトアルゴリズム（HRW）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのアルゴリズムはどちらも非常に単純です。</font><font style="vertical-align: inherit;">ウィキペディアでの彼らの説明はいくつかの文章に当てはまります。</font><font style="vertical-align: inherit;">それらを明白と呼ぶのは難しいですが。</font><font style="vertical-align: inherit;">興味のある方は、元の記事「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consistent Hashing and Random Trees：Distributed Caching Protocols for Relieting Hot Spots on the World Wide Web</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Name-BasedMapping Scheme for Rendezvous」を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読むことをお勧めし</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">最も理解できるのは、私の意見では、一貫性のあるハッシュアルゴリズムのアイデアが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このスタンフォードコースで伝えられ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ている</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">こと</font></a><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのアルゴリズムをさらに詳しく見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一貫したハッシュ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一貫性のあるハッシュアルゴリズムの基礎となるトリックは、ノードと格納されたオブジェクトの両方を同じ識別子空間にマップすることです。</font><font style="vertical-align: inherit;">これにより、一見異なるエンティティ、オブジェクト、ノードを比較できるようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなマッピングを取得するには、オブジェクトのキーとノードの識別子に同じハッシュ関数を適用するだけです。</font><font style="vertical-align: inherit;">ノードのハッシュ関数の結果はトークンと呼ばれますが、これは後で役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
識別子スペースを円の形で表します。</font><font style="vertical-align: inherit;">識別子の最大値は、識別子の最小値の直後に続くと単純に想定しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、オブジェクトがどのノードに存在するかを判断するには、そのキーからハッシュ関数の値を取得し、途中のノードのトークンに遭遇するまで円を時計回りに移動するだけです。移動の方向は重要ではありませんが、修正する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
架空の時計回りの動きは、機能的には、ノードトークンの並べ替えられた配列のバイナリ検索と同等です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ca/dh/fy/cadhfyrlc9b_maoinnjw0kvp6fm.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この図では、特定の色の各セクターは、特定のノードが担当する識別子スペースを反映しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいノードを追加すると、... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v7/an/3r/v7an3r9bwxn9hnziy-w7umr5viq.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...セクターの1つが2つの部分に分割され、対応するキーが完全に引き継がれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、ノード3がノード1のキーの一部を引き継ぎました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、このアプローチでは、ノード間でオブジェクトの分布がかなり不均一になります。ノード自体の識別子に大きく依存しています。このアプローチはどのように改善できますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のトークンをノード（通常は数百）に割り当てることができます。これは、たとえば、ノードに多くのハッシュ関数（トークンごとに1つ）を導入するか、同じハッシュ関数を前のステップで取得したトークンに繰り返し適用することで実現できます。しかし、衝突を忘れてはなりません。同じトークンを持つ2つのノードがあってはなりません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7i/m2/ay/7im2ay5cr_ydc5hh62vlwcaqhp0.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、各ノードに4つのトークンがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他に重要なことは何ですか。ノードがトポロジーを離れた場合にデータの安全性を確保したい場合、キーを複数のノード（いわゆるレプリカまたはバックアップ）に保存する必要があります。</font><font style="vertical-align: inherit;">一貫性のあるハッシュアルゴリズムの場合、レプリカはサークル上の次のN-1ノードになります。Nはレプリケーションファクターです。</font><font style="vertical-align: inherit;">もちろん、ノードの順序は特定のトークン（最初のトークンなど）によって決定する必要があります。</font><font style="vertical-align: inherit;">それぞれに複数のトークンを使用する場合、ノードの配置が異なる場合があります。</font><font style="vertical-align: inherit;">スキームに注意してください。ノードの繰り返しの明確なパターンはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トポロジーを変更する際の分布の最小限の変更の要件に関しては、円上のノードの相互の順序が変更されていないため、これは満たされています。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">トポロジからノードを削除しても、残りのノード間の順序関係は変わりません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランデブーハッシュ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランデブーハッシュアルゴリズムは、一貫性のあるハッシュよりもさらにシンプルに見えます。アルゴリズムは、順序関係の不変の同じ原理に基づいています。ただし、ノードとオブジェクトを比較可能にする代わりに、特定のオブジェクトのノードのみを比較可能にします。それら。各オブジェクトのノード間の順序関係を個別に決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合も、ハッシュは私たちを助けます。しかし、ここで、特定のオブジェクトOのノードNの重みを決定するために、オブジェクトの識別子をノードの識別子と混合し、この混合からハッシュを取得します。各ノードに対してこの操作を実行すると、ノードをソートするための一連の重みが得られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のノードであり、オブジェクトの格納を担当します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トポロジのすべてのノードは同じ入力データを使用するため、それらの結果は同じになります。これは最初の要件を満たします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ox/hs/bw/oxhsbwgq8xrlfrirs8xupmx3hww.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を考えてみましょう。ここでは、4つの異なるキーの3つのノード間に順序関係があります。黄色は、重みが最も高いノード、つまり最終的に特定のキーを担当するノード。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トポロジに別のノードを追加します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hc/a9/4s/hca94sz_p5pz-lwflppuqlm7c54.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考えられるすべてのオプションを考慮に入れるために、意図的に対角線上に配置しました。ここでは、緑色で示されているノード3がトポロジーに入りました。したがって、各キーのノードの重みの分布が変更されました。赤は、特定のキーのリストで場所を変更したノードを示します。これらのノードの重みは、追加されたノードの重みよりも少なかった。ただし、この変更は、キーの1つであるK3にのみ影響しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トポロジからノードを危険にさらしてみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ds/gr/d_/dsgrd_q9ai9yi9p5x08ubfgflem.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでも、変更は1つのキー、今回はK1にのみ影響しました。残りのオブジェクトは影響を受けませんでした。一貫したハッシュの場合と同様に、その理由は、ノードのペア間の順序関係の不変性です。それら。分布の最小変更の要件が満たされ、ノード間に偽のトラフィックがありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランデブーのディストリビューションは見栄えがよく、トークンのような一貫したハッシュと比較して追加のトリックを必要としません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レプリケーションをサポートする場合、リストの次のノードはオブジェクトの最初のレプリカになり、次のノードは2番目のレプリカになります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache Igniteでのランデブーハッシュの使用方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いわゆるアフィニティ関数は、Apache Igniteでのデータの配布を担当します（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AffinityFunction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェイスを参照</font><font style="vertical-align: inherit;">）。デフォルトの実装はランデブーハッシュです（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RendezvousAffinityFunction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスを参照</font><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意する必要がある最初のことは、Apache Igniteが格納されたオブジェクトをトポロジノードに直接マップしないことです。代わりに、パーティションという追加の概念が導入されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーティションは、オブジェクトとレプリケーションユニットのコンテナーです。さらに、特定のキャッシュのパーティション数（これはおなじみのデータベースのテーブルに類似しています）は構成段階で設定され、キャッシュのライフサイクル中に変更されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、効果的なモジュロ分割を使用してパーティションにオブジェクトを表示し、ランデブーハッシュを使用してパーティションをノードにマッピングできます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/wr/vt/wdwrvtuau9ywcgq4uqk0hhqscu8.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜならキャッシュのパーティション数は一定であり、ノードごとのパーティション分布を一度計算して、トポロジが変更されるまで結果をキャッシュできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ノードはこの分布を個別に計算しますが、同じ入力データを持つすべてのノードでこの分布は同一になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーティションには複数のコピーを含めることができます。これらをバックアップと呼びます。 1次区画は1次区画と呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーティション間およびノー​​ドごとのパーティション間でキーを最適に分散するには、次のルールが満たされている必要があります。パーティションの数はノードの数よりも大幅に多く、キーの数はパーティションの数よりも大幅に多い必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Igniteのキャッシュはパーティション化され、複製されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーティション化されたキャッシュでは、バックアップの数はキャッシュの作成段階で設定されます。パーティション-プライマリとバックアップ-はノード間で均等に分散されます。このようなキャッシュは、運用データの操作に最適です。バックアップの数に直接依存する、最高の書き込みパフォーマンスを提供します。一般に、バックアップが多いほど、より多くのノードがキーレコードを確認する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hh/fs/_u/hhfs_ujczi2m1p8kl4c5z3p2ra4.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、キャッシュに1つのバックアップがあります。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">ノードを1つ失うだけでデータを失うことはありません。</font><font style="vertical-align: inherit;">パーティションのバックアップは、プライマリパーティションまたは他のバックアップと同じノードに保存されることはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複製されたキャッシュでは、バックアップの数は常にトポロジノードの数から1を引いた数に等しくなります。つまり、</font><font style="vertical-align: inherit;">各ノードには常にすべてのパーティションのコピーが含まれています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/n-/fk/by/n-fkbyie-hipm40twvyg_erjjm0.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなキャッシュは、ほとんど変更されないデータ（ディレクトリなど）の操作に最適であり、次のように最大の可用性を提供します。</font><font style="vertical-align: inherit;">データを失うことなくN-1ノード（この場合は3）を失う可能性があります。</font><font style="vertical-align: inherit;">また、このオプションでは、プライマリパーティションとバックアップの両方からデータを読み取ることができれば、最大の読み取りパフォーマンスが得られます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache Igniteのデータコロケーション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最高のパフォーマンスを得るために留意すべき重要な概念は、コロケーションです。コロケーションとは、同じ場所にオブジェクトを配置することです。私たちの場合、オブジェクトはキャッシュに格納されたエンティティであり、場所はノードです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトが同じアフィニティ関数のパーティションによって分散されている場合、同じアフィニティキーを持つオブジェクトが同じパーティションに分類されるため、同じノードに分類されます。 Igniteでは、これはアフィニティコロケーションと呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトでは、アフィニティキーはオブジェクトの主キーです。ただし、Igniteでは、オブジェクトの他のフィールドをアフィニティキーとして使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コロケーションは、計算またはSQLクエリを実行するためにノード間で送信されるデータの量を大幅に削減します。これにより、これらのタスクに費やされる時間が短縮されます。この概念を例で考えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データモデルを2つのエンティティで構成するとします：注文（Order）と注文位置（OrderItem）。 1回の注文で多くの商品に対応できます。オーダーとラインアイテムの識別子は独立していますが、ラインアイテムには対応するオーダーを参照する外部キーがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各注文に対してこの注文の位置の計算を実行するというタスクを実行する必要があると仮定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトでは、アフィニティキーは主キーです。したがって、順序と位置は、主キーに応じてノード間で分散されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/q-/vq/tkq-vq1_sbghpcqdsz8ythpehim.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この図では、次数は四角で、位置は円で表されています。色は、アイテムが注文に属していることを示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデータの分散により、架空のタスクが目的の注文が配置されているノードに送信され、他のすべてのノードから位置を読み取るか、これらのノードにサブタスクを送信して計算結果を取得する必要があります。これは、回避できる、または回避すべき不必要なネットワーク相互作用です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注文アイテムは注文自体と同じノードに配置する必要があることをIgniteに伝えたらどうなるでしょうか。データを収集します？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポジションのアフィニティキーとして、外部キーOrderIdを取得します。このフィールドは、レコードが属するパーティションを計算するときに使用されます。さらに、パーティション内では、主キーによって常にオブジェクトを見つけることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/uq/kg/lvuqkgzf9gpoot8gjnr25uxb6ve.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、両方のキャッシュ（OrderとOrderItem）が同じパラメーターで同じアフィニティ関数を使用する場合、データは近くにあり、注文アイテムのネットワークを移動する必要はありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache Igniteのアフィニティ構成</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在の実装では、affinity functionオブジェクトはキャッシュ構成パラメーターです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アフィニティ関数自体は、作成時に次の引数を取ります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パーティションの数。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックアップの数（実際、これはキャッシュの構成パラメーターでもあります）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックアップフィルター;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグexcludeNeighbors。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの設定は変更できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーティションとバックアップの数で、すべてがはっきりしているようです。バックアップフィルターとexcludeNeighborsフラグについては、少し後で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行時に、入力アフィニティ関数は現在のクラスタートポロジ（基本的にクラスターノードのリスト）を受け取り、ランデブーハッシュアルゴリズムについて説明したときに示した例に従って、ノードごとのパーティション分布を計算します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックアップフィルターに関しては、これは、アフィニティ関数が、述語がfalseを返したノードにバックアップパーティションを割り当てることを禁止できる述語です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、物理ノード（サーバー）がデータセンターの異なるラックに配置されているとします。通常、各ラックには独自の独立した電力があります...</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5e/ts/wy/5etswypgpotv2e9exzu3gsyl9f8.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...そして、ラックを失うと、データも失われます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nz/hy/5d/nzhy5dzl77t7pxhtxbtqubcbzek.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、パーティションの半分を失いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、適切なバックアップフィルターを設定すると、ディストリビューションは次のように変化します</font></font><br>
<br>
<img src="https://habrastorage.org/webt/20/90/gy/2090gyzlg_0-80-dhkw8hvplftm.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... ...ラックが失われた場合でも、データが失われることはなく、引き続き使用できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oo/eg/k5/ooegk5vas7xhk7qzrergws5ieli.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
excludeNeighborsフラグは同様の機能を実行し、実際、これは特定のケースの略語です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、複数のIgniteノードが同じ物理ホスト上で実行されます。このケースは、データセンターにラックがある場合の例と非常によく似ていますが、ここでは、データ損失を、ラックではなくホストの損失と戦っています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/ze/wn/tkzewnmjc5iigjd_appzyvfoheo.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残りは同じです。この動作は、バックアップフィルターを使用して実装できます。このフラグは歴史的な遺産であり、Igniteの次のメジャーリリースで削除される可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apache Igniteを使用する開発者が知っておく必要のあるすべてのアフィニティ機能とデータ配布について話したようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論として、3つのノードのトポロジによる16のパーティションの分散の例を見てみましょう。単純化と明確化のために、パーティションにはバックアップがないと考えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は実際の分布をもたらす小さなテストを受けて書いたところ</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yy/lm/np/yylmnpenoifogzoo0lig3kzw_5g.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
です。ご覧のとおり、分布の均一性は理想的ではありません。ただし、ノードとパーティションの数が増えると、エラーは著しく低くなります。守らなければならない主なルールは、パーティションの数がノードの数よりも大幅に多いことです。 Igniteでは、パーティション化されたキャッシュのデフォルトのパーティション数は1024です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、トポロジに新しいノードを追加します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xd/xf/sp/xdxfspt29ky3x0gfceqi_xiswv0.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーティーの一部は彼に移動しました。同時に、分布の最小限の変更の要件が確認されました。新しいノードはパーティションの一部を受け取りましたが、他のノードはパーティションを交換しませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の段階でトポロジーに存在していたノードをトポロジーから削除します。これで、ゼロノード</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ym/b5/il/ymb5ilednyy4dxf6ynojfva7gao.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
に関連付けられたすべてのパーティションが、トポロジーの他のノードに再配布され、配布要件に違反することはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のように、複雑な問題の解決策は、完全ではないものの、かなり自明なアイデアに基づいていることがよくあります。</font><font style="vertical-align: inherit;">説明されているソリューションはほとんどの分散データベースで使用されており、適切に機能します。</font><font style="vertical-align: inherit;">しかし、これらの決定はランダム化されているため、分布の均一性は理想からかけ離れています。</font><font style="vertical-align: inherit;">パフォーマンスやその他の分配要件を犠牲にすることなく、均一性を改善できますか？</font><font style="vertical-align: inherit;">問題は未解決のままです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja489952/index.html">ライブでやる気に満ちたデスクトップの壁紙</a></li>
<li><a href="../ja489954/index.html">Seagate SkyHawk AI-巨大で復讐的な</a></li>
<li><a href="../ja489956/index.html">ViewPager2に切り替えることなく、RecyclerViewを簡単にアニメーション化します</a></li>
<li><a href="../ja489958/index.html">説明：HaskellのwcがCのアナログよりも「速い」ことが判明した理由</a></li>
<li><a href="../ja489960/index.html">Delphiアプリケーションの自動ビルド</a></li>
<li><a href="../ja489968/index.html">静電容量から0.3の電流でAAおよびAAAバッテリーの劣化を検出します</a></li>
<li><a href="../ja489970/index.html">プログラマー、パック、ジョンスタインベック</a></li>
<li><a href="../ja489974/index.html">Kha vs HTML5：C ++でJavaScriptをコンパイルする</a></li>
<li><a href="../ja489984/index.html">udalenkaに関するAMA：質問-私たちは答えます</a></li>
<li><a href="../ja489986/index.html">Power Stage Designerユーティリティ-Power Electronics Developer Tool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>