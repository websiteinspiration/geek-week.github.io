<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐓 🤦 🙇🏾 Huffman-Komprimierungsalgorithmus 👱 👷 🗒️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Vorfeld des Kursbeginns haben "Algorithmen für Entwickler" für Sie eine Übersetzung eines weiteren nützlichen Materials vorbereitet.
 
 
 
 Die Huf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Huffman-Komprimierungsalgorithmus</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/497566/"><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Vorfeld des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kursbeginns haben "Algorithmen für Entwickler"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für Sie eine Übersetzung eines weiteren nützlichen Materials vorbereitet.</font></font></b></i><br>
<br>
<img src="https://habrastorage.org/webt/u2/bz/ax/u2bzaxiq2huxqrzfavfpesnofvo.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Huffman-Codierung ist ein Datenkomprimierungsalgorithmus, der die Grundidee der Dateikomprimierung formuliert. In diesem Artikel werden wir über Codierung mit fester und variabler Länge, eindeutig decodierte Codes, Präfixregeln und die Konstruktion eines Huffman-Baums sprechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wissen, dass jedes Zeichen als Folge von 0 und 1 gespeichert ist und 8 Bits benötigt. Dies wird als Codierung mit fester Länge bezeichnet, da jedes Zeichen dieselbe feste Anzahl von Bits zum Speichern verwendet.</font></font><a name="habracut"></a><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nehmen wir an, der Text ist gegeben. Wie können wir den Speicherplatz reduzieren, der zum Speichern eines Zeichens erforderlich ist?</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Die Grundidee ist die Codierung mit variabler Länge. Wir können die Tatsache nutzen, dass einige Zeichen im Text häufiger vorkommen als andere ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siehe hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), um einen Algorithmus zu entwickeln, der dieselbe Zeichenfolge mit weniger Bits darstellt. Beim Codieren einer variablen Länge weisen wir den Zeichen eine variable Anzahl von Bits zu, abhängig von der Häufigkeit ihres Auftretens in diesem Text. Letztendlich können einige Zeichen nur 1 Bit und andere 2 Bit, 3 oder mehr, aufnehmen. Das Problem bei der Codierung mit variabler Länge ist nur die nachfolgende Decodierung der Sequenz. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann man die Reihenfolge der Bits kennen, um sie eindeutig zu dekodieren?</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie die Zeichenfolge </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"aabacdab"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es hat 8 Zeichen und beim Codieren einer festen Länge werden 64 Bit benötigt, um es zu speichern. Beachten Sie, dass die Häufigkeit der Zeichen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"a", "b", "c"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"d"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4, 2, 1, 1 beträgt. Versuchen wir uns </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"aabacdab" mit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> weniger Bits </font><font style="vertical-align: inherit;">vorzustellen, wobei </font><i><font style="vertical-align: inherit;">wir</font></i><font style="vertical-align: inherit;"> die Tatsache verwenden, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"a"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> häufiger als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"b"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"b"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> häufiger als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"c"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"d" ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Zunächst codieren wir </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"a"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit einem Bit gleich 0, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"b"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> weisen wir einen Zwei-Bit-Code 11 zu und codieren mit drei Bits 100 und 011 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"c"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"D"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Ergebnis werden wir erfolgreich sein:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elf</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">011</font></font></td>
</tr>
</tbody></table></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codieren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir </font><i><font style="vertical-align: inherit;">die</font></i><font style="vertical-align: inherit;"> Zeichenfolge </font><i><font style="vertical-align: inherit;">"aabacdab"</font></i><font style="vertical-align: inherit;"> unter </font><font style="vertical-align: inherit;">Verwendung der oben angegebenen Codes </font><font style="vertical-align: inherit;">als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">00110100011011 (0 | 0 | 11 | 0 | 100 | 011 | 0 | 11)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Das Hauptproblem wird jedoch die Dekodierung sein. </font><font style="vertical-align: inherit;">Wenn wir versuchen, die Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">00110100011011</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu dekodieren </font><font style="vertical-align: inherit;">, erhalten wir ein mehrdeutiges Ergebnis, da es wie </font><i><font style="vertical-align: inherit;">folgt</font></i><font style="vertical-align: inherit;"> dargestellt werden kann:</font></font><br>
<br>
<pre><code class="plaintext hljs">0|011|0|100|011|0|11    adacdab<font></font>
0|0|11|0|100|0|11|011   aabacabd<font></font>
0|011|0|100|0|11|0|11   adacabab <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Mehrdeutigkeit zu vermeiden, müssen wir sicherstellen, dass unsere Codierung einem Konzept wie einer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Präfixregel entspricht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was wiederum impliziert, dass Codes auf nur eine eindeutige Weise decodiert werden können. Eine Präfixregel stellt sicher, dass kein Code ein Präfix eines anderen ist. Mit Code meinen wir Bits, die zur Darstellung eines bestimmten Zeichens verwendet werden. Im obigen Beispiel ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das Präfix </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">011</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das gegen die Präfixregel verstößt. Wenn unsere Codes die Präfixregel erfüllen, können wir sie eindeutig dekodieren (und umgekehrt). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehen wir uns das obige Beispiel an. Dieses Mal werden wir die Zeichen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"a", "b", "c"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font><i><font style="vertical-align: inherit;">"d"</font></i><font style="vertical-align: inherit;"> zuweisen.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Codes, die die Präfixregel erfüllen.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Verwendung dieser Codierung wird die Zeichenfolge </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"aabacdab"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">00100100011010 (0 | 0 | 10 | 0 | 100 | 011 | 0 | 10)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> codiert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und hier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">00100100011010 können</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir eindeutig dekodieren und zu unserer ursprünglichen Zeile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„aabacdab“ zurückkehren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman-Codierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir die Codierung mit variabler Länge und eine Präfixregel herausgefunden haben, sprechen wir über die Huffman-Codierung. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Methode basiert auf der Erstellung von Binärbäumen. Darin kann ein Knoten entweder endlich oder intern sein. Anfangs werden alle Knoten als Blätter (Blätter) betrachtet, die das Symbol selbst und sein Gewicht (dh die Häufigkeit des Auftretens) darstellen. Interne Knoten enthalten die Gewichtung des Zeichens und beziehen sich auf zwei untergeordnete Knoten. Nach allgemeiner Vereinbarung steht das Bit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"0"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für eine Verfolgung im linken Zweig und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"1"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für die rechte. In einem vollständigen Baum gibt es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blätter und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interne Knoten. Es wird empfohlen, beim Erstellen eines Huffman-Baums nicht verwendete Zeichen zu verwerfen, um Codes mit optimaler Länge zu erhalten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden die Prioritätswarteschlange verwenden, um den Huffman-Baum zu erstellen, wobei dem Knoten mit der niedrigsten Frequenz die höchste Priorität zugewiesen wird. </font><font style="vertical-align: inherit;">Die Konstruktionsschritte werden nachfolgend beschrieben:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie für jedes Zeichen einen Blattknoten und fügen Sie ihn der Prioritätswarteschlange hinzu.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen Sie wie folgt vor, während Sie für mehr als ein Blatt in der Schlange stehen:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernen Sie die beiden Knoten mit der höchsten Priorität (mit der niedrigsten Frequenz) aus der Warteschlange.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie einen neuen internen Knoten, in dem diese beiden Knoten Erben sind und die Häufigkeit des Auftretens der Summe der Häufigkeiten dieser beiden Knoten entspricht.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der Prioritätswarteschlange einen neuen Knoten hinzu.</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einzige verbleibende Knoten ist die Wurzel. Dadurch wird die Baumkonstruktion abgeschlossen.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich vor, wir haben einen Text, der nur aus den Zeichen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"a", "b", "c", "d"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"e" besteht,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die Häufigkeit ihres Auftretens beträgt 15, 7, 6, 6 bzw. 5. Unten finden Sie Abbildungen, die die Schritte des Algorithmus widerspiegeln. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/08/nz/g9/08nzg9y-qguo05argcfhzg7dfbo.png"><br>
<br>
<img src="https://habrastorage.org/webt/1t/fb/5l/1tfb5lnkadshv9ckwwbq2w8jm0k.png"><br>
<br>
<img src="https://habrastorage.org/webt/dh/uo/be/dhuobemww5m4uoxswnpndawrfok.png"><br>
<br>
<img src="https://habrastorage.org/webt/i-/9a/we/i-9awedtfaylpuh834b3xwby0pu.png"><br>
<br>
<img src="https://habrastorage.org/webt/vu/1z/us/vu1zusm2bv_1z0qunv7okiv8s5k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Pfad von der Wurzel zu einem beliebigen Endknoten speichert den optimalen Präfixcode (auch als Huffman-Code bezeichnet), der dem diesem Endknoten zugeordneten Zeichen entspricht. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/cc/vy/qm/ccvyqm21nyslsu41zf-f-ppl9go.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman-Baum</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nachfolgend finden Sie die Implementierung des Huffman-Komprimierungsalgorithmus in C ++ und Java:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<font></font>
<font></font>
<span class="hljs-comment">// A Tree node</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
	<span class="hljs-keyword">char</span> ch;
	<span class="hljs-keyword">int</span> freq;<font></font>
	Node *left, *right;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Function to allocate a new tree node</span>
<span class="hljs-function">Node* <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> freq, Node* left, Node* right)</span>
</span>{<font></font>
	Node* node = <span class="hljs-keyword">new</span> Node();<font></font>
<font></font>
	node-&gt;ch = ch;<font></font>
	node-&gt;freq = freq;<font></font>
	node-&gt;left = left;<font></font>
	node-&gt;right = right;<font></font>
<font></font>
	<span class="hljs-keyword">return</span> node;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Comparison object to be used to order the heap</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">comp</span>
{</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Node* l, Node* r)</span>
	</span>{
		<span class="hljs-comment">// highest priority item has lowest frequency</span>
		<span class="hljs-keyword">return</span> l-&gt;freq &gt; r-&gt;freq;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// traverse the Huffman Tree and store Huffman Codes</span>
<span class="hljs-comment">// in a map.</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Node* root, <span class="hljs-built_in">string</span> str,
			<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">string</span>&gt; &amp;huffmanCode)</span>
</span>{
	<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)
		<span class="hljs-keyword">return</span>;<font></font>
<font></font>
	<span class="hljs-comment">// found a leaf node</span>
	<span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) {<font></font>
		huffmanCode[root-&gt;ch] = str;<font></font>
	}<font></font>
<font></font>
	encode(root-&gt;left, str + <span class="hljs-string">"0"</span>, huffmanCode);<font></font>
	encode(root-&gt;right, str + <span class="hljs-string">"1"</span>, huffmanCode);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// traverse the Huffman Tree and decode the encoded string</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(Node* root, <span class="hljs-keyword">int</span> &amp;index, <span class="hljs-built_in">string</span> str)</span>
</span>{
	<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) {
		<span class="hljs-keyword">return</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// found a leaf node</span>
	<span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)<font></font>
	{<font></font>
		<span class="hljs-built_in">cout</span> &lt;&lt; root-&gt;ch;
		<span class="hljs-keyword">return</span>;<font></font>
	}<font></font>
<font></font>
	index++;<font></font>
<font></font>
	<span class="hljs-keyword">if</span> (str[index] ==<span class="hljs-string">'0'</span>)<font></font>
		decode(root-&gt;left, index, str);<font></font>
	<span class="hljs-keyword">else</span><font></font>
		decode(root-&gt;right, index, str);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Builds Huffman Tree and decode given input text</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildHuffmanTree</span><span class="hljs-params">(<span class="hljs-built_in">string</span> text)</span>
</span>{
	<span class="hljs-comment">// count frequency of appearance of each character</span>
	<span class="hljs-comment">// and store it in a map</span>
	<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; freq;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch: text) {<font></font>
		freq[ch]++;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Create a priority queue to store live nodes of</span>
	<span class="hljs-comment">// Huffman tree;</span>
	priority_queue&lt;Node*, <span class="hljs-built_in">vector</span>&lt;Node*&gt;, comp&gt; pq;<font></font>
<font></font>
	<span class="hljs-comment">// Create a leaf node for each character&nbsp;and add it</span>
	<span class="hljs-comment">// to the priority queue.</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pair: freq) {<font></font>
		pq.push(getNode(pair.first, pair.second, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// do till there is more than one node in the queue</span>
	<span class="hljs-keyword">while</span> (pq.size() != <span class="hljs-number">1</span>)<font></font>
	{<font></font>
		<span class="hljs-comment">// Remove the two nodes of highest priority</span>
		<span class="hljs-comment">// (lowest frequency) from the queue</span><font></font>
		Node *left = pq.top(); pq.pop();<font></font>
		Node *right = pq.top();	pq.pop();<font></font>
<font></font>
		<span class="hljs-comment">// Create a new internal node with these two nodes</span>
		<span class="hljs-comment">// as children and with frequency equal to the sum</span>
		<span class="hljs-comment">// of the two nodes' frequencies. Add the new node</span>
		<span class="hljs-comment">// to the priority queue.</span>
		<span class="hljs-keyword">int</span> sum = left-&gt;freq + right-&gt;freq;<font></font>
		pq.push(getNode(<span class="hljs-string">'\0'</span>, sum, left, right));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// root stores pointer to root of Huffman Tree</span><font></font>
	Node* root = pq.top();<font></font>
<font></font>
	<span class="hljs-comment">// traverse the Huffman Tree and store Huffman Codes</span>
	<span class="hljs-comment">// in a map. Also prints them</span>
	<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">string</span>&gt; huffmanCode;<font></font>
	encode(root, <span class="hljs-string">""</span>, huffmanCode);<font></font>
<font></font>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Huffman Codes are :\n"</span> &lt;&lt; <span class="hljs-string">'\n'</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pair: huffmanCode) {
		<span class="hljs-built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; pair.second &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nOriginal string was :\n"</span> &lt;&lt; text &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
<font></font>
	<span class="hljs-comment">// print encoded string</span>
	<span class="hljs-built_in">string</span> str = <span class="hljs-string">""</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch: text) {<font></font>
		str += huffmanCode[ch];<font></font>
	}<font></font>
<font></font>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nEncoded string is :\n"</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
<font></font>
	<span class="hljs-comment">// traverse the Huffman Tree again and this time</span>
	<span class="hljs-comment">// decode the encoded string</span>
	<span class="hljs-keyword">int</span> index = <span class="hljs-number">-1</span>;
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nDecoded string is: \n"</span>;
	<span class="hljs-keyword">while</span> (index &lt; (<span class="hljs-keyword">int</span>)str.size() - <span class="hljs-number">2</span>) {<font></font>
		decode(root, index, str);<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Huffman coding algorithm</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-built_in">string</span> text = <span class="hljs-string">"Huffman coding is a data compression algorithm."</span>;<font></font>
<font></font>
	buildHuffmanTree(text);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br>
<pre><code class="java hljs"><span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.PriorityQueue;<font></font>
<font></font>
<span class="hljs-comment">// A Tree node</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>
</span>{
	<span class="hljs-keyword">char</span> ch;
	<span class="hljs-keyword">int</span> freq;<font></font>
	Node left = <span class="hljs-keyword">null</span>, right = <span class="hljs-keyword">null</span>;<font></font>
<font></font>
	Node(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> freq)<font></font>
	{<font></font>
		<span class="hljs-keyword">this</span>.ch = ch;
		<span class="hljs-keyword">this</span>.freq = freq;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> freq, Node left, Node right)</span> </span>{
		<span class="hljs-keyword">this</span>.ch = ch;
		<span class="hljs-keyword">this</span>.freq = freq;
		<span class="hljs-keyword">this</span>.left = left;
		<span class="hljs-keyword">this</span>.right = right;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Huffman</span>
</span>{
	<span class="hljs-comment">// traverse the Huffman Tree and store Huffman Codes</span>
	<span class="hljs-comment">// in a map.</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Node root, String str,
							  Map&lt;Character, String&gt; huffmanCode)</span>
	</span>{
		<span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)
			<span class="hljs-keyword">return</span>;<font></font>
<font></font>
		<span class="hljs-comment">// found a leaf node</span>
		<span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) {<font></font>
			huffmanCode.put(root.ch, str);<font></font>
		}<font></font>
<font></font>
<font></font>
		encode(root.left, str + <span class="hljs-string">"0"</span>, huffmanCode);<font></font>
		encode(root.right, str + <span class="hljs-string">"1"</span>, huffmanCode);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// traverse the Huffman Tree and decode the encoded string</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">decode</span><span class="hljs-params">(Node root, <span class="hljs-keyword">int</span> index, StringBuilder sb)</span>
	</span>{
		<span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)
			<span class="hljs-keyword">return</span> index;<font></font>
<font></font>
		<span class="hljs-comment">// found a leaf node</span>
		<span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)<font></font>
		{<font></font>
			System.out.print(root.ch);<font></font>
			<span class="hljs-keyword">return</span> index;<font></font>
		}<font></font>
<font></font>
		index++;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (sb.charAt(index) == <span class="hljs-string">'0'</span>)<font></font>
			index = decode(root.left, index, sb);<font></font>
		<span class="hljs-keyword">else</span><font></font>
			index = decode(root.right, index, sb);<font></font>
<font></font>
		<span class="hljs-keyword">return</span> index;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Builds Huffman Tree and huffmanCode and decode given input text</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHuffmanTree</span><span class="hljs-params">(String text)</span>
	</span>{
		<span class="hljs-comment">// count frequency of appearance of each character</span>
		<span class="hljs-comment">// and store it in a map</span>
		Map&lt;Character, Integer&gt; freq = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; text.length(); i++) {
			<span class="hljs-keyword">if</span> (!freq.containsKey(text.charAt(i))) {<font></font>
				freq.put(text.charAt(i), <span class="hljs-number">0</span>);<font></font>
			}<font></font>
			freq.put(text.charAt(i), freq.get(text.charAt(i)) + <span class="hljs-number">1</span>);<font></font>
		}<font></font>
<font></font>
		<span class="hljs-comment">// Create a priority queue to store live nodes of Huffman tree</span>
		<span class="hljs-comment">// Notice that highest priority item has lowest frequency</span>
		PriorityQueue&lt;Node&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<font></font>
										(l, r) -&gt; l.freq - r.freq);<font></font>
<font></font>
		<span class="hljs-comment">// Create a leaf node for each character&nbsp;and add it</span>
		<span class="hljs-comment">// to the priority queue.</span>
		<span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : freq.entrySet()) {<font></font>
			pq.add(<span class="hljs-keyword">new</span> Node(entry.getKey(), entry.getValue()));<font></font>
		}<font></font>
<font></font>
		<span class="hljs-comment">// do till there is more than one node in the queue</span>
		<span class="hljs-keyword">while</span> (pq.size() != <span class="hljs-number">1</span>)<font></font>
		{<font></font>
			<span class="hljs-comment">// Remove the two nodes of highest priority</span>
			<span class="hljs-comment">// (lowest frequency) from the queue</span><font></font>
			Node left = pq.poll();<font></font>
			Node right = pq.poll();<font></font>
<font></font>
			<span class="hljs-comment">// Create a new internal node with these two nodes as children </span>
			<span class="hljs-comment">// and with frequency equal to the sum of the two nodes</span>
			<span class="hljs-comment">// frequencies. Add the new node to the priority queue.</span>
			<span class="hljs-keyword">int</span> sum = left.freq + right.freq;<font></font>
			pq.add(<span class="hljs-keyword">new</span> Node(<span class="hljs-string">'\0'</span>, sum, left, right));<font></font>
		}<font></font>
<font></font>
		<span class="hljs-comment">// root stores pointer to root of Huffman Tree</span><font></font>
		Node root = pq.peek();<font></font>
<font></font>
		<span class="hljs-comment">// traverse the Huffman tree and store the Huffman codes in a map</span>
		Map&lt;Character, String&gt; huffmanCode = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<font></font>
		encode(root, <span class="hljs-string">""</span>, huffmanCode);<font></font>
<font></font>
		<span class="hljs-comment">// print the Huffman codes</span>
		System.out.println(<span class="hljs-string">"Huffman Codes are :\n"</span>);
		<span class="hljs-keyword">for</span> (Map.Entry&lt;Character, String&gt; entry : huffmanCode.entrySet()) {<font></font>
			System.out.println(entry.getKey() + <span class="hljs-string">" "</span> + entry.getValue());<font></font>
		}<font></font>
<font></font>
		System.out.println(<span class="hljs-string">"\nOriginal string was :\n"</span> + text);<font></font>
<font></font>
		<span class="hljs-comment">// print encoded string</span>
		StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; text.length(); i++) {<font></font>
			sb.append(huffmanCode.get(text.charAt(i)));<font></font>
		}<font></font>
<font></font>
		System.out.println(<span class="hljs-string">"\nEncoded string is :\n"</span> + sb);<font></font>
<font></font>
		<span class="hljs-comment">// traverse the Huffman Tree again and this time</span>
		<span class="hljs-comment">// decode the encoded string</span>
		<span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>;<font></font>
		System.out.println(<span class="hljs-string">"\nDecoded string is: \n"</span>);
		<span class="hljs-keyword">while</span> (index &lt; sb.length() - <span class="hljs-number">2</span>) {<font></font>
			index = decode(root, index, sb);<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>
	</span>{<font></font>
		String text = <span class="hljs-string">"Huffman coding is a data compression algorithm."</span>;<font></font>
<font></font>
		buildHuffmanTree(text);<font></font>
	}<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Der</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von der Eingabezeichenfolge verwendete Speicher beträgt 47 * 8 = 376 Bit, und die codierte Zeichenfolge benötigt nur 194 Bit, d. H. </font><font style="vertical-align: inherit;">Daten werden um ca. 48% komprimiert. </font><font style="vertical-align: inherit;">Im obigen C ++ - Programm verwenden wir die Zeichenfolgenklasse, um die codierte Zeichenfolge zu speichern und das Programm lesbar zu machen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da effektive Datenstrukturen der Prioritätswarteschlange </font><font style="vertical-align: inherit;">das Einfügen von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log (N))</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeit </font><font style="vertical-align: inherit;">erfordern </font><font style="vertical-align: inherit;">und in einem vollständigen Binärbaum mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blättern </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2N-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Knoten vorhanden sind und der Huffman-Baum ein vollständiger Binärbaum ist, arbeitet der Algorithmus für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (Nlog (N) ))</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeit, wobei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Anzahl der Zeichen ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellen:</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">en.wikipedia.org/wiki/Huffman_coding</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">en.wikipedia.org/wiki/Variable-length_code</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.youtube.com/watch?v=5wRPin4oxCo</a> <br>
<br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   .<br>
</a><br>
<hr></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de497554/index.html">IntelliJ IDEA 2020.1: Java 14, Analyse des Datenflusses im Debugger, der neue LightEdit-Modus und vieles mehr</a></li>
<li><a href="../de497558/index.html">Wir unterrichten selbst Physik mit einem Kind, damit sich alle dafür interessieren</a></li>
<li><a href="../de497560/index.html">Wie sich Quarantäne auf den Arbeitsmarkt in der IT auswirkt</a></li>
<li><a href="../de497562/index.html">Mitap: Bleib zu Hause und GOnline</a></li>
<li><a href="../de497564/index.html">Lokaler Hack Day - Online Hackathon</a></li>
<li><a href="../de497568/index.html">Wie LANIT-Mitarbeiter an entfernten Standorten in Italien und Weißrussland arbeiten</a></li>
<li><a href="../de497570/index.html">Datenbanken auf der IIoT-Plattform: Funktionsweise von Mail.ru Cloud Solutions mit Petabyte an Daten von mehreren Geräten</a></li>
<li><a href="../de497572/index.html">Serviceorientiertes Zustandsmanagement mit Lampe-Luwak</a></li>
<li><a href="../de497574/index.html">Onkologie im Kontext der COVID-19-Pandemie: Wie man maximale Leben rettet</a></li>
<li><a href="../de497578/index.html">AMD ist bestrebt, einen bedeutenden Marktanteil für Rechenzentren zu erlangen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>