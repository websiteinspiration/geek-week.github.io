<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐏 💋 💑 Memprogram lapisan video dalam Raspberry Pi menggunakan API DispmanX 🧗🏽 💆🏽 👩‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, saya ingin menunjukkan penggunaan API DispmanX dari Raspberry Single Board Computers. API DispmanX menyediakan kemampuan untuk membu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Memprogram lapisan video dalam Raspberry Pi menggunakan API DispmanX</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/493610/"><iframe width="560" height="315" src="https://www.youtube.com/embed/05cqFhJtHaA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada artikel ini, saya ingin menunjukkan penggunaan API DispmanX dari Raspberry Single Board Computers. API DispmanX menyediakan kemampuan untuk membuat lapisan yang baru dirender di desktop Raspberry. Lapisan menggantung di atas lapisan. Mereka dapat dibuat secara dinamis, dihapus, dipindahkan, mereka dapat diskalakan. Pada saat yang sama, pengontrol video itu sendiri akan menggabungkan mereka dan menampilkannya di layar monitor. Menariknya, layer-layer tersebut dapat memiliki saluran alpha, dan kemudian, gambar dari semua layer akan bercampur dengan sendirinya. Selain itu, selain 32 lapisan ARGB dua bit, Anda dapat membuat, misalnya, lapisan YUV420, atau lapisan jenis lain. Raspberry sudah memiliki dua lapisan secara default. Yang terendah berisi gambar desktop. Semua output melalui X masuk ke lapisan ini. Dan ada lapisan kedua paling atas di mana gambar kursor mouse hidup.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan menunjukkan cara membuat layer baru, menulis gambar ke dalamnya dan bagaimana memindahkannya di sekitar layar. Sebenarnya, video demo di atas menunjukkan pengoperasian program semacam itu. Empat layer ARGB 32-bit baru dibuat di sini. Di setiap lapisan saya menulis piksel dari bitmap yang sudah disiapkan sebelumnya. Bitmap saya adalah gambar awan, matahari dan balon. Lapisan bergerak di sekitar layar dengan kecepatan yang berbeda, tergantung di atas lapisan X terendah.</font></font><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, API DispmanX. Ini adalah hal tingkat rendah yang khusus untuk Raspberry dan pengontrol videonya. Dan ini adalah hal yang "tidak standar". Secara umum, kernel Linux dan subsistem grafis Linux memiliki tempat untuk memprogram lapisan video melalui DRM, Direct Rendering Manager, tetapi untuk beberapa alasan pencipta Raspberry memutuskan untuk membuat sepeda mereka sendiri. Meskipun, di sisi lain, ini bukan sepeda yang rumit, yang sangat mungkin untuk dikendarai. DispmanX beroperasi pada Pi-Zero, pada Raspberry Pi / Pi2 / Pi3 dan Pi4. Secara umum, pada semua raspberry. Meskipun, sebenarnya, Pi4 sudah memiliki OpenGLESv3 normal. Di sini rebana seperti itu mungkin tidak lagi dibutuhkan. Tetapi di sisi lain, DispmanX jauh lebih sederhana (walaupun lebih sedikit fitur) daripada OpenGLES.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menulis program menggunakan API DispmanX ini, Anda harus menyertakan file header /opt/vc/include/bcm_host.h. </font><font style="vertical-align: inherit;">Selain itu, Anda juga perlu menautkan program ke pustaka libbcm_host.so, yang terletak di folder / opt / vc / lib. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua fungsi API yang perlu kita mulai dengan vc_dispmanx_ * ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal pertama yang harus dilakukan untuk membuat layer baru adalah mengakses layar menggunakan pasangan fungsi berikut:</font></font><br>
<br>
<pre><code class="cpp hljs">bcm_host_init();<font></font>
DISPMANX_DISPLAY_HANDLE_T display = vc_dispmanx_display_open( <span class="hljs-number">0</span> );
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang Anda dapat membuat "sumber daya" yang akan berisi gambar lapisan:</font></font><br>
<br>
<pre><code class="cpp hljs">VC_IMAGE_TYPE_T type = VC_IMAGE_ARGB8888;
<span class="hljs-keyword">uint32_t</span> UnusedImagePtr;
<span class="hljs-keyword">int</span> SrcImageWidth = <span class="hljs-number">512</span>; <span class="hljs-comment">//image must be 32 bytes aligned size</span>
<span class="hljs-keyword">int</span> SrcImageWidth = <span class="hljs-number">196</span>;<font></font>
DISPMANX_RESOURCE_HANDLE_T resource = vc_dispmanx_resource_create( type, SrcImageWidth, SrcImageHeight,  &amp;UnusedImagePtr );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini, jenis lapisan adalah 32-bit dengan saluran alpha. </font><font style="vertical-align: inherit;">Tapi mungkin ada jenis lain, seperti yang sudah saya tulis, bahkan YUV. </font><font style="vertical-align: inherit;">Menggunakan lapisan YUV masuk akal untuk lapisan dinamis, seperti saat memutar video. </font><font style="vertical-align: inherit;">Kemudian jumlah data yang ditulis ke layar berkurang secara signifikan, dan Anda tidak perlu transcode YUV ke RGB, yang menghemat siklus jam prosesor yang berharga. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah membuat sumber daya baru, pengendali tampilan yang diperoleh sebelumnya dapat digunakan untuk menambahkan lapisan elemen baru ke tampilan:</font></font><br>
<br>
<pre><code class="cpp hljs">VC_DISPMANX_ALPHA_T alpha;<font></font>
	alpha.flags =<font></font>
		(DISPMANX_FLAGS_ALPHA_T)(DISPMANX_FLAGS_ALPHA_FROM_SOURCE | DISPMANX_FLAGS_ALPHA_MIX);<font></font>
	alpha.opacity = <span class="hljs-number">255</span>;<font></font>
	alpha.mask = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> OutLayer = <span class="hljs-number">200</span>;<font></font>
DISPMANX_ELEMENT_HANDLE_T vc_element = vc_dispmanx_element_add(<font></font>
		update,<font></font>
		display,<font></font>
		OutLayer,<font></font>
		&amp;dst_rect, resource, &amp;src_rect, DISPMANX_PROTECTION_NONE, &amp;alpha, <span class="hljs-literal">NULL</span>, DISPMANX_NO_ROTATE );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada parameter pembaruan lain yang sangat penting. </font><font style="vertical-align: inherit;">Setiap kali Anda perlu memodifikasi konten tampilan, menambah atau menghapus layer, atau memindahkannya, atau menulis gambar baru ke layer, Anda harus menandai awal dari perubahan dan akhir dari perubahan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mulai mengubah elemen pada tampilan yang perlu Anda lakukan:</font></font><br>
<br>
<pre><code class="cpp hljs">DISPMANX_UPDATE_HANDLE_T update =  vc_dispmanx_update_start( Priority );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian ubah semua yang Anda butuhkan, buat layer atau pindahkan, tulis piksel baru ke layer dan kemudian tutup perubahan menggunakan fungsi:</font></font><br>
<br>
<pre><code class="cpp hljs">vc_dispmanx_update_submit_sync( update );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang dapat Anda pahami dari nama fungsi, perubahan akan berlaku setelah denyut bingkai berikutnya dari pemindaian video. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menulis piksel ke layer dilakukan oleh fungsi</font></font><br>
<br>
<pre><code class="cpp hljs">vc_dispmanx_resource_write_data(<font></font>
		resource,<font></font>
		type,<font></font>
		pitch,<font></font>
		Pixels, <span class="hljs-comment">//pointer to ARGB pixels</span>
		&amp;rect );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, meskipun ada parameter rect, tidak mungkin untuk memperbarui fragmen sewenang-wenang di dalam gambar. </font><font style="vertical-align: inherit;">Hanya "strip" yang dapat diperbarui, yaitu, bagian atas dan bawah dari persegi panjang dapat ditentukan, tetapi kiri akan selalu 0 dan kanan akan selalu menjadi lebar gambar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anehnya, ini mungkin seluruh pengetahuan minimum yang diperlukan untuk memanipulasi lapisan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam program saya, saya menulis pembungkus kecil di atas API DispmanX. </font><font style="vertical-align: inherit;">Ini memungkinkan saya untuk menggambarkan setiap lapisan dalam struktur terpisah:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DISPMANX_ELEMENT</span> {</span><font></font>
    DISPMANX_RESOURCE_HANDLE_T  res_;<font></font>
    DISPMANX_ELEMENT_HANDLE_T   vc_element_;<font></font>
    VC_IMAGE_TYPE_T type_;<font></font>
    <span class="hljs-keyword">uint32_t</span> src_width_;
    <span class="hljs-keyword">uint32_t</span> src_height_;
    <span class="hljs-keyword">uint32_t</span> dst_layer_;
    <span class="hljs-keyword">uint32_t</span> dst_width_;
    <span class="hljs-keyword">uint32_t</span> dst_height_;
    <span class="hljs-keyword">int32_t</span>  dst_x_;
    <span class="hljs-keyword">int32_t</span>  dst_y_;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nah, banyak fungsi pembungkus saya mengambil pointer ke struktur seperti itu sebagai parameter: </font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispmanx_init</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispmanx_element_init</span><span class="hljs-params">(struct DISPMANX_ELEMENT* Element)</span></span>;
<span class="hljs-function">struct DISPMANX_ELEMENT <span class="hljs-title">dispmanx_element_create</span><span class="hljs-params">( VC_IMAGE_TYPE_T type, <span class="hljs-keyword">int</span> SrcW, <span class="hljs-keyword">int</span> SrcH, <span class="hljs-keyword">int</span> OutX, <span class="hljs-keyword">int</span> OutY, <span class="hljs-keyword">int</span> OutW, <span class="hljs-keyword">int</span> OutH, <span class="hljs-keyword">int</span> OutLayer )</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispmanx_element_delete</span><span class="hljs-params">(struct DISPMANX_ELEMENT* Element)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispmanx_element_write</span><span class="hljs-params">(struct DISPMANX_ELEMENT* Element, <span class="hljs-keyword">char</span>* Pixels)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispmanx_element_move</span><span class="hljs-params">( DISPMANX_UPDATE_HANDLE_T update, struct DISPMANX_ELEMENT* Element, <span class="hljs-keyword">int32_t</span> NewX, <span class="hljs-keyword">int32_t</span> NewY )</span></span>;
<span class="hljs-function">DISPMANX_UPDATE_HANDLE_T <span class="hljs-title">dispmanx_start_update</span><span class="hljs-params">( <span class="hljs-keyword">int</span> Priority )</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispmanx_sync</span><span class="hljs-params">( DISPMANX_UPDATE_HANDLE_T Update )</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan cara ini saya dapat membuat beberapa layer dan dengan mudah memanipulasi mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya juga menulis fungsi untuk membaca bitmap. </font><font style="vertical-align: inherit;">Selain itu, fungsinya rumit - jika piksel hijau murni 0x00FF00 ditemukan dalam bitmap, maka saya menganggapnya sebagai piksel transparan di gambar saya dan karenanya mengatur byte Alpha dari piksel ini ke nol. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam cat, saya melukis tiga gambar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Awan: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d2/67/bj/d267bjptz5o4trqey6sl_npz2fm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Matahari: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/ni/e6/hxnie6k12u7n5jep_sae5e_z-qu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Balon: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pw/6h/d1/pw6hd11k8jwwojd2ti_mkgfdzaw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Program ini menciptakan empat lapisan. </font><font style="vertical-align: inherit;">Dua lapisan pertama dibuat dari bitmap cloud yang sama, tetapi saya membuat ukuran layer berbeda, saya menggunakan penskalaan, awan kedua lebih besar dari yang pertama. </font><font style="vertical-align: inherit;">Lapisan ketiga adalah balon dan di lapisan keempat saya memuat matahari:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OBJ</span>{</span>
	<span class="hljs-keyword">int</span> width_;
	<span class="hljs-keyword">int</span> height_;
	<span class="hljs-keyword">int</span> x_;
	<span class="hljs-keyword">int</span> y_;
	<span class="hljs-keyword">int</span> layer_;
	<span class="hljs-keyword">int</span> speed_;
	<span class="hljs-keyword">char</span>* pixels_;<font></font>
} OBJ_;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc , <span class="hljs-keyword">char</span> *argv[])</span>
</span>{
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello Raspberry DispmanX API!\n"</span>;<font></font>
	dispmanx_init();<font></font>
<font></font>
	OBJ_ cloud1;<font></font>
	cloud1.pixels_ = LoadBitmap( (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"clouds.bmp"</span>, &amp;cloud1.width_, &amp;cloud1.height_ );<font></font>
	cloud1.layer_ = <span class="hljs-number">100</span>;<font></font>
	cloud1.x_ = <span class="hljs-number">100</span>;<font></font>
	cloud1.y_ = <span class="hljs-number">120</span>;<font></font>
	cloud1.speed_ = <span class="hljs-number">3</span>;<font></font>
<font></font>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DISPMANX_ELEMENT</span> <span class="hljs-title">cloud1_element</span> = <span class="hljs-title">dispmanx_element_create</span>(
		<span class="hljs-title">VC_IMAGE_ARGB8888</span>, <span class="hljs-title">cloud1</span>.<span class="hljs-title">width_</span>, <span class="hljs-title">cloud1</span>.<span class="hljs-title">height_</span>, <span class="hljs-title">cloud1</span>.<span class="hljs-title">x_</span>, <span class="hljs-title">cloud1</span>.<span class="hljs-title">y_</span>, <span class="hljs-title">cloud1</span>.<span class="hljs-title">width_</span>, <span class="hljs-title">cloud1</span>.<span class="hljs-title">height_</span>, <span class="hljs-title">cloud1</span>.<span class="hljs-title">layer_</span> );</span><font></font>
	dispmanx_element_write( &amp;cloud1_element, cloud1.pixels_ );<font></font>
<font></font>
	OBJ_ cloud2;<font></font>
	cloud2.pixels_ = LoadBitmap( (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"clouds.bmp"</span>, &amp;cloud2.width_, &amp;cloud2.height_ );<font></font>
	cloud2.layer_ = <span class="hljs-number">101</span>;<font></font>
	cloud2.x_ = <span class="hljs-number">10</span>;<font></font>
	cloud2.y_ = <span class="hljs-number">230</span>;<font></font>
	cloud2.speed_ = <span class="hljs-number">2</span>;<font></font>
<font></font>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DISPMANX_ELEMENT</span> <span class="hljs-title">cloud2_element</span> = <span class="hljs-title">dispmanx_element_create</span>(
		<span class="hljs-title">VC_IMAGE_ARGB8888</span>, <span class="hljs-title">cloud2</span>.<span class="hljs-title">width_</span>, <span class="hljs-title">cloud2</span>.<span class="hljs-title">height_</span>, <span class="hljs-title">cloud2</span>.<span class="hljs-title">x_</span>, <span class="hljs-title">cloud2</span>.<span class="hljs-title">y_</span>, <span class="hljs-title">cloud2</span>.<span class="hljs-title">width_</span>*1.3, <span class="hljs-title">cloud2</span>.<span class="hljs-title">height_</span>*1.4, <span class="hljs-title">cloud2</span>.<span class="hljs-title">layer_</span> );</span><font></font>
	dispmanx_element_write( &amp;cloud2_element, cloud2.pixels_ );<font></font>
<font></font>
	OBJ_ balls;<font></font>
	balls.pixels_ = LoadBitmap( (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"balls.bmp"</span>, &amp;balls.width_, &amp;balls.height_ );<font></font>
	balls.layer_ = <span class="hljs-number">102</span>;<font></font>
	balls.x_ = <span class="hljs-number">-100</span>;<font></font>
	balls.y_ = <span class="hljs-number">351</span>;<font></font>
	balls.speed_ = <span class="hljs-number">5</span>;<font></font>
<font></font>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DISPMANX_ELEMENT</span> <span class="hljs-title">balls_element</span> = <span class="hljs-title">dispmanx_element_create</span>(
		<span class="hljs-title">VC_IMAGE_ARGB8888</span>, <span class="hljs-title">balls</span>.<span class="hljs-title">width_</span>, <span class="hljs-title">balls</span>.<span class="hljs-title">height_</span>, <span class="hljs-title">balls</span>.<span class="hljs-title">x_</span>, <span class="hljs-title">balls</span>.<span class="hljs-title">y_</span>, <span class="hljs-title">balls</span>.<span class="hljs-title">width_</span>, <span class="hljs-title">balls</span>.<span class="hljs-title">height_</span>, <span class="hljs-title">balls</span>.<span class="hljs-title">layer_</span> );</span><font></font>
	dispmanx_element_write( &amp;balls_element, balls.pixels_ );<font></font>
<font></font>
	OBJ_ sun;<font></font>
	sun.pixels_ = LoadBitmap( (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"sun.bmp"</span>, &amp;sun.width_, &amp;sun.height_ );<font></font>
	sun.layer_ = <span class="hljs-number">99</span>;<font></font>
	sun.x_ = <span class="hljs-number">-250</span>;<font></font>
	sun.y_ = <span class="hljs-number">10</span>;<font></font>
	sun.speed_ = <span class="hljs-number">1</span>;<font></font>
<font></font>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DISPMANX_ELEMENT</span> <span class="hljs-title">sun_element</span> = <span class="hljs-title">dispmanx_element_create</span>(
		<span class="hljs-title">VC_IMAGE_ARGB8888</span>, <span class="hljs-title">sun</span>.<span class="hljs-title">width_</span>, <span class="hljs-title">sun</span>.<span class="hljs-title">height_</span>, <span class="hljs-title">sun</span>.<span class="hljs-title">x_</span>, <span class="hljs-title">sun</span>.<span class="hljs-title">y_</span>, <span class="hljs-title">sun</span>.<span class="hljs-title">width_</span>, <span class="hljs-title">sun</span>.<span class="hljs-title">height_</span>, <span class="hljs-title">sun</span>.<span class="hljs-title">layer_</span> );</span><font></font>
	dispmanx_element_write( &amp;sun_element, sun.pixels_ );<font></font>
.......................<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam siklus abadi, saya memindahkan lapisan di sekitar layar dengan kecepatan yang berbeda:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<font></font>
	{<font></font>
		this_thread::sleep_for( chrono::milliseconds(<span class="hljs-number">20</span>) );<font></font>
		cloud1.x_ += cloud1.speed_;<font></font>
		<span class="hljs-keyword">if</span>( cloud1.x_&gt;= <span class="hljs-number">1920</span> )<font></font>
			cloud1.x_ = <span class="hljs-number">10</span> - cloud1.width_;<font></font>
<font></font>
		cloud2.x_ += cloud2.speed_;<font></font>
		<span class="hljs-keyword">if</span>( cloud2.x_&gt;= <span class="hljs-number">1920</span> )<font></font>
			cloud2.x_ = <span class="hljs-number">133</span> - cloud2.width_;<font></font>
<font></font>
		balls.x_ += balls.speed_;<font></font>
		<span class="hljs-keyword">if</span>( balls.x_&gt;= <span class="hljs-number">1920</span> )<font></font>
			balls.x_ = <span class="hljs-number">200</span> - balls.width_;<font></font>
<font></font>
		sun.x_ += sun.speed_;<font></font>
		<span class="hljs-keyword">if</span>( sun.x_&gt;= <span class="hljs-number">1920</span> )<font></font>
			sun.x_ = <span class="hljs-number">250</span> - sun.width_;<font></font>
<font></font>
		DISPMANX_UPDATE_HANDLE_T update = dispmanx_start_update(<span class="hljs-number">10</span>);<font></font>
		dispmanx_element_move( update, &amp;cloud1_element, cloud1.x_, cloud1.y_ );<font></font>
		dispmanx_element_move( update, &amp;cloud2_element, cloud2.x_, cloud2.y_ );<font></font>
		dispmanx_element_move( update, &amp;balls_element, balls.x_, balls.y_ );<font></font>
		dispmanx_element_move( update, &amp;sun_element,   sun.x_,   sun.y_ );<font></font>
		dispmanx_sync( update );<font></font>
	}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu saja. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua kode program saya dapat diambil di github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompilasi program di raspberry - dengan perintah make. </font><font style="vertical-align: inherit;">Kemudian jalankan dari baris perintah: ./demo dan Anda mendapatkan apa yang Anda lihat di atas dalam demonstrasi video. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Omong-omong, pada Raspberry Anda dapat melihat daftar semua lapisan video dengan perintah vcgencmd dengan parameter dispmanx_list. </font><font style="vertical-align: inherit;">Ini adalah output dari perintah ini pada Pi4 sebelum meluncurkan demo saya: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/33/mz/0d/33mz0dtr_honwwqorlt-wori6ie.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang saya tulis, sudah ada dua layer: layer untuk Xorg dan layer untuk mouse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan inilah daftar lapisan setelah memulai demo saya:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1i/ln/zy/1ilnzyta7p3l5jcrznrcp8owsjk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dapat dilihat bahwa empat layer baru ditambahkan. </font><font style="vertical-align: inherit;">Saya mengambil tangkapan layar di tim scrot. </font><font style="vertical-align: inherit;">Sangat menarik bahwa ia hanya menangkap lapisan-x yang lebih rendah, oleh karena itu, dalam tangkapan layar, awan maupun balon yang berada di lapisan lain tidak terlihat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tahu bahwa mikrokomputer Raspberry kadang-kadang digunakan untuk membuat berbagai kios. </font><font style="vertical-align: inherit;">Dan untuk kios, kadang-kadang Anda perlu melakukan OSD, On Screen Display - yaitu, overlay satu gambar di atas yang lain. </font><font style="vertical-align: inherit;">Menurut saya, API DispmanX sangat cocok untuk aplikasi ini. </font><font style="vertical-align: inherit;">Mungkin seseorang akan menyukai solusi ini.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id493594/index.html">PHP Digest No. 176 (11-23 Maret 2020)</a></li>
<li><a href="../id493596/index.html">Pria yang tidak terburu-buru</a></li>
<li><a href="../id493598/index.html">Sembunyikan bagian dari nomor telepon</a></li>
<li><a href="../id493604/index.html">Acara digital di Moskow dari tanggal 23 hingga 29 Maret</a></li>
<li><a href="../id493606/index.html">Sejarah menciptakan layanan cloud yang dibumbui dengan cyberpunk</a></li>
<li><a href="../id493614/index.html">Deteksi COVID-19 dalam sinar-X dengan Pembelajaran Keras, TensorFlow dan Deep</a></li>
<li><a href="../id493616/index.html">Gambar seperti kotak - apa yang ada di dalamnya? Laporkan dalam Yandex</a></li>
<li><a href="../id493618/index.html">(Tidak) OSINT jelas di Twitter</a></li>
<li><a href="../id493620/index.html">Kurva logistik. Kapan epidemi akan berakhir?</a></li>
<li><a href="../id493622/index.html">Menuliskan Microwave ke Angular</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>