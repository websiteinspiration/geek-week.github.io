<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üâë üêÉ üíå Async programming in .NET: best practices üì≤ ü¶Ä üßóüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The advent of async / await in C # has led to a redefinition of how to write simple and correct parallel code. Often, using asynchronous programming, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Async programming in .NET: best practices</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491236/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The advent of async / await in C # has led to a redefinition of how to write simple and correct parallel code. Often, using asynchronous programming, programmers not only do not solve the problems that were with the threads, but also introduce new ones. Deadlocks and flights don't go anywhere - they just become harder to diagnose. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/uz/8g/buuz8gok2hqubwnj1773hwimncq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dmitry Ivanov - Software Analysis TeamLead at Huawei, a former JetBrains Rider techlide and developer of the ReSharper core: data structures, caches, multithreading, and a regular speaker at the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conference </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Under the cutscene - video recording and text transcript of Dmitry's report from the DotNext 2019 Piter conference.</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wM-h6P1BJRk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further narration on behalf of the speaker.</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In multi-threaded or asynchronous code, something often breaks. The reason could be both deadlock and race. As a rule, a race crashes once out of a thousand, often not locally, but only on a build server, and it takes several days to catch it. I am sure for many this is a familiar situation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, looking at asynchronous code even by experienced developers, I find myself thinking that some things can be written down three times shorter and more correctly.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This suggests that the problem is not in people, but in the instrument. </font><font style="vertical-align: inherit;">People just use the tool and want it to solve their problem. </font><font style="vertical-align: inherit;">The tool itself has a very large number of capabilities (sometimes even superfluous), settings, an implicit context, which leads to the fact that it is very easy to use incorrectly. </font><font style="vertical-align: inherit;">Let's try to figure out how to use async / await and work with a class </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in .NET.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plan</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problems with approaches that are solved with async / await.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examples of controversial design.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A task from real life that we will solve asynchronously.</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async / await and issues to be resolved</font></font></h2><br>
<img src="https://habrastorage.org/webt/v1/ym/30/v1ym304jgxmwh_4kymlyqr4wddi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why do we need async / await? Let's say we have code that works with shared shared memory. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the beginning of work, we read the request, in this case, the file from the blocking queue (for example, from the Internet or from the disk), using the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dequeue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> blocking request </font><font style="vertical-align: inherit;">(blocking requests will be marked in red in the pictures with examples). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This approach requires a lot of threads, and each thread requires resources, creates a load on </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scheduler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. But this is not the main problem. Suppose people could rewrite operating systems so that these systems support both a hundred thousand and a million threads. But the main problem is that some threads simply cannot be taken. For example, you have a user interface thread. There are no normal adequate UI frameworks where access to data would be not only from one thread, yet. UI thread cannot be blocked. And in order not to block it, we need asynchronous code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's talk about the second task. After we read the file, it needs to be processed somehow. We will do it in parallel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Many of you have heard that parallelism is not the same as asynchrony. In this case, the question arises: can asynchrony help write parallel code more compact, beautiful and faster?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last task is to work with shared memory. </font><font style="vertical-align: inherit;">Do we need to drag this mechanism with locks, synchronization to asynchronous code, or can this be somehow avoided? </font><font style="vertical-align: inherit;">Can </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> help with this?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Path to async / await</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at the evolution of asynchronous programming in general in the world and in .NET.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Callback</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Void <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {‚Ä¶}<font></font>
 <font></font>
<font></font>
<span class="hljs-function">Void <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ‚Ä¶<span class="hljs-comment">//synchronous code</span><font></font>
 <font></font>
    Foo(<span class="hljs-keyword">params</span>,() =&gt;{<font></font>
       ‚Ä¶<span class="hljs-comment">//asynchronous code;continuation</span><font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Asynchronous programming began with callbacks. </font><font style="vertical-align: inherit;">That is, first you need to call some part of the code synchronously, and the second part - asynchronously. </font><font style="vertical-align: inherit;">For example, you read from a file, and when the data is ready, it will be delivered to you somehow. </font><font style="vertical-align: inherit;">This asynchronous part is passed as a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">callback</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More callbacks</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {...} 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">Action callback</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">Action callback</span>)</span> {...}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
    <font></font>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; { <font></font>
      ... <span class="hljs-comment">//continuation 1 </span><font></font>
      Bar(() =&gt; {<font></font>
        <span class="hljs-comment">//continuation 2</span><font></font>
        Baz(() =&gt; {<font></font>
          <span class="hljs-comment">//continuation 3</span><font></font>
        }); <font></font>
      });<font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, from one callback you can register another </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">callback</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , from which you can register a third callback, and in the end it all turns into a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Callback Hell</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/vq/8g/bfvq8gknishmtrdwaiixz6mzuvs.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Callback: exceptions</font></font></h3><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action onSuccess, Action onFailure</span>)</span> {...}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code </span>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; {<font></font>
      ... <span class="hljs-comment">//asynchronous code on success </span><font></font>
    },<font></font>
    () =&gt; {<font></font>
        ... <span class="hljs-comment">//asynchronous code on failure</span><font></font>
    }); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How to work with exceptions? For example, ReSharper, when separately responding to exceptions and to good execution, does not demonstrate the most beautiful pieces of code - there are separate callbacks for an exceptional situation and for a successful continuation. The result is just such a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">callback hell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but not linear, but tree-like, which can be completely confusing. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/hs/y3/lghsy31j9pke1do-8rpmcyuovfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In .NET, the first callback approach is called the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous Programming Model</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (APM). The method will be called </font></font><code>AsyncCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is essentially the same as </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but the approach has some features. First of all, methods should begin with the word ‚ÄúBegin‚Äù (reading from a file is BeginRead), which returns some </font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Himself</font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- This is a handler that knows that the operation has completed and that has a mechanism </font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. You </font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can hang on, waiting for the operation to complete asynchronously. On the other hand, you can call </font></font><code>EndOperation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, make </font></font><code>EndRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and hang synchronously (which is very similar to a property </font></font><code>Task.Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This approach has a number of problems. Firstly, it does not protect us from </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">callback hell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Secondly, it remains completely unclear what to do with exceptions. Thirdly, it is not clear on which thread this callback will be called - we have no control over the call. Fourth, the question arises, how to combine pieces of code with callbacks? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mr/5z/xr/mr5zxr01ztmadod_fuetd3loqew.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second model is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event-Based Asynchronous Pattern</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is a reactive callback approach. The idea of ‚Äã‚Äãthe method is that we pass to the method </font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">some object that has event Completed and subscribe to this event. As you noticed, </font></font><code>BeginOperationName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changes to </font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Confusion can occur when you go into the Socket class, where two patterns are mixed: </font></font><code>ConnectAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>BeginConnect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Please note that you must call to cancel </font></font><code>OperationNameAsyncCancel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Since in .NET this is not found anywhere else, usually everyone sends </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Thus, if you accidentally encounter a method in the library that ends with </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you need to understand that it does not necessarily return </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but can return a similar construction. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/w4/4u/6sw44uh3ljw5kwdkowtxylfz5xc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider a model that is known in Java as</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Futures</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in JavaScript, as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promises</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and in .NET, as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task Asynchronous Patterns</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in other words, ‚Äútasks.‚Äù This method assumes that you have some calculation object, and you can see the status of this object (running or finished). In .NET, there is a so-called </font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, convenient separation of two statuses: the start of the task and the completion of the task. A common error occurs when a method is called on a task </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that returns not successful continuation, but </font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>Faulted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Thus, the result of clicking on ‚ÄúCancel‚Äù in the UI application should differ from the return of exceptions (executions). In .NET, a distinction has been made: if execution is your mistake that you want to secure, then </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- forced operation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In .NET, a concept was also introduced </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- it is a kind of abstraction on top of threads that tells where to run task. In this case, the cancellation support was designed at the design level. Almost all the operations in the library in .NET have </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that can be passed. This does not work for all languages: for example, in Kotlin you can undo task, but in .NET you cannot. The solution may be the division of responsibility between those who cancel the task, and the task itself. When you receive a task, you cannot cancel it otherwise than explicitly ‚Äî you must pass it on </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A special object </font></font><code>TaskCompletionSoure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows you to easily adapt old APIs that are associated with the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event-Based Asynchronous Pattern</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous Programming Model</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">There is a document that you must read if you program in tasks. </font><font style="vertical-align: inherit;">It describes all agreements regarding tasas. </font><font style="vertical-align: inherit;">For example, any method, returning the task, should return it in a running state, which means that it cannot be </font></font><code>Created</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, while all such operations must end in </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combining continuations</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Task <span class="hljs-title">ourMethod</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">return</span> Task.RunSynchronously(() =&gt;{<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Foo(); <span class="hljs-comment">//continuation 1</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Bar(); <span class="hljs-comment">//continuation 2</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Baz(); <span class="hljs-comment">//continuation 3</span><font></font>
  })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As for the combination, taking into account the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">callback hell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it can appear in a more linear form, despite the presence of pieces of repeating code with minimal changes. </font><font style="vertical-align: inherit;">It seems that the code is improving this way, but there are pitfalls here too.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start &amp; continue tasks</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
  TaskCreationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)<font></font>
Task.ContinueWith(Action&lt;Task&gt;, <font></font>
  TaskContinuationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let us turn to three parameters during the standard task launch: the first are the options for starting the task, the second is the </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one on which the task is launched, and the third - </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/w_/a4/fw/w_a4fwuiwflisfw-ifxqwtgnpxu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TaskScheduler tells where the task starts and is an object that you can independently override. For example, you can override a method </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If you do </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the method </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">takes a thread from </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and sends your task there. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you take </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">over the main thread, it puts everything in one queue, and tasks are executed sequentially on the main thread. However, the problem is that in .NET you can execute task without passing </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The question arises: how then does .NET calculate what task was passed to it? When the task starts through </font></font><code>StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inside</font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exhibited in the one </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that we gave her. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This design seems rather controversial due to the implicit context. There were cases when it </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contained asynchronous code that inherited somewhere very deeply </font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and overlapped with another scheduler, which led to deadlocks. In this case, you can use the option </font></font><code>TaskCreationOption.HideScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is an alarm bell that says that we have some option that overrides the </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setting. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything is the same with continuations. The question arises: where does it come from </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for continuations? First of all, it is taken in the method in which you started </font></font><code>Continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It is also </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">taken from ThreadStatic. It is important that for </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> continuations work very differently.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bt/-f/ne/bt-fnekfbdnfmn4n-u3zrvp7bdc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We turn to the parameters </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>TaskContinuationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Their main problem is that there are a lot of them. Some of these parameters cancel each other, some are mutually exclusive. All these parameters can be used in all possible combinations, so it‚Äôs difficult to keep in mind everything that can happen with longing. Some of these options work completely incomprehensibly. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/us/wh/aguswhpfaos0qjqvfopo_rr8aeo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, the parameters </font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">represent two possible application options, but whether continuation will be launched synchronously or asynchronously depends on so many things that you will not know about. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/-c/zv/jm-czv9x4lhhmibfgxqxwjcvxqe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another example: we launched task, launched continuation and simultaneously gave two parameters</font></font><code>TaskContinuations.ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, after which they started the continuation asynchronously. </font><font style="vertical-align: inherit;">Will it be executed in the same stack where the previous task ends, or will it be transferred to </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">In this case, there will be a third option: it depends.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/j6/8z/vvj68zu1keb_n50viyk4iqbydae.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When you create task, you set its result through </font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to adapt the previous asynchronous patterns to the task world. You </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can request </font></font><code>tcs.Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and this task will go into a state </font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when you call </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. However, if you run this on the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thread pool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , you will get </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deadlock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The question is, why if we did not write anything even synchronously? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v5/g1/2b/v5g12bn0tycbshdrascqvi-hkug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We create </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, start a new task, and we have a second thread that starts something in this task. It goes over and falls into expectation for a hundred milliseconds. Then our main thread - green - goes to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and that‚Äôs it. He releases the stack, the stack hangs, waiting to be called in a continuation on</font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exposed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the blue thread we get to </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and then the most interesting. </font><font style="vertical-align: inherit;">Based on internal considerations of .NET, he </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">believes that the continuation of this </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be performed synchronously, that is, directly on the same stack, then this </font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is performed synchronously on the same stack. </font><font style="vertical-align: inherit;">This is very strange, despite the fact that we have not even written anywhere </font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is probably the problem with mixing synchronous and asynchronous code. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uv/7z/go/uv7zgosoif24okbeyq7fffwdz8o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another problem with this </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is that when we call </font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">under the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , you cannot call arbitrary code, since under the lock you can do only some small granular activity. </font><font style="vertical-align: inherit;">Run underneath some </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">action-s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it‚Äôs impossible to come from where they came from. </font><font style="vertical-align: inherit;">How to solve this problem?</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span>  tcs  =  <span class="hljs-keyword">new</span>   TaskCompletionSource&lt;<span class="hljs-keyword">int</span>&gt;(<font></font>
       TaskContinuationsOptions.RunContinuationsAsynchronously  <font></font>
) ;<font></font>
<span class="hljs-keyword">lock</span>(mylock)<font></font>
{  <font></font>
    tcs.SetResult(O); <font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">worth </font><font style="vertical-align: inherit;">using </font><font style="vertical-align: inherit;">only for adaptation of not </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> code in libraries. </font><font style="vertical-align: inherit;">Almost everything else can be solved through await. </font><font style="vertical-align: inherit;">In this case, it is always strongly recommended to prescribe the parameter </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"TaskCompletionSource.RunContinuationsAsynchronously"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">You almost always need to run a continuation asynchronously. </font><font style="vertical-align: inherit;">In this case, you </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">have something under which nothing will be launched. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ap/_-/ab/ap_-abu8wjhwxr0edsvayrcc-6w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why should continuation be performed synchronously? </font><font style="vertical-align: inherit;">Because it </font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">refers to the following </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and not to ours. </font><font style="vertical-align: inherit;">In order for him to relate to ours, you need to write the following: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/zj/6q/qbzj6q1fjhhqozii8yec5ok3pcy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This example shows how parameters are not intuitive, how they intersect with each other, how they introduce cognitive complexity - it is so difficult to write.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parent-child hierarchy</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   })<font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// don‚Äôt wait for child</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are other options for using parameters. For example, a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parent-child</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hierarchy </font><font style="vertical-align: inherit;">arises </font><font style="vertical-align: inherit;">when you launch one task and run another under it. In this case, if you write </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will not wait for the task launched inside. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gw/se/28/gwse28nxykd4vfwt_chfw0qjt_w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you write </font></font><code>TaskCreationOptions.AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will wait. You can use this property in your products. I think everyone can come up with an example in which there is a hierarchy of tasks, with the task waiting for the subtask, and the subtask for its subtasks. No need to write anywhere </font></font><code>WaitForChildren</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, this wait happens asynchronously. That is, the body of the parent task ends, and after that the parent task is not considered complete, does not start its continuations until the child tasks work.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// still wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... parent task to attach is in ThreadStatic</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There may be a problem in which the task is transferred somewhere in </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then everything that you started with </font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be added to this parent task, which is an alarm bell.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo();<font></font>
}, TaskCreationOptions.DenyChildAttach)<font></font>
.ContinueWith(...) <span class="hljs-comment">// don‚Äôt wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the other hand, there is an option that cancels the previous option </font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Such an application occurs quite often.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Run(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">//don‚Äôt wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
    }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is worth remembering that </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is the standard way to start, which by default implies </font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The implicit context that you put in </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adds complexity to you. You do not understand how the task works, because you need to know the context. Another issue that may arise is related to the idle state of async / await. That's because in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you do not have tasks, but actions. Continuation is not honest task, but action. When you write async / await code, you don‚Äôt need to use </font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it because you explicitly tie the tasks to wait through await, and this is the right approach. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/k7/q5/vg/k7q5vgi8h9qwvvo3akgzow8vu_q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You have six options on how to start a continuation. You launched task, launched</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Question: What status will this continuation have? </font><font style="vertical-align: inherit;">There are five possible answers:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">general continuation will be completed successfully; RunToCompletion will occur;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the task will be in error;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cancellation will occur;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the task will not reach completion at all, it will be in some kind of limbo;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">option - ‚Äúdepends‚Äù.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/5u/x5/1k/5ux51kwpr4aixg_2io3xroerxam.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, the task will be in the ‚Äúcanceled‚Äù state, although nowhere is the word ‚Äúcanceled‚Äù anywhere. </font><font style="vertical-align: inherit;">Here we throw the reception and do nothing. </font><font style="vertical-align: inherit;">The problem is that when you read someone else's code with a lot of options - even if you knew about these options 10 minutes ago - you still forget what happens here. </font><font style="vertical-align: inherit;">So do not write.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancellation</font></font></h3><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(); <font></font>
});<font></font>
<font></font>
                                                      Failed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The third parameter at the start of the task is kancellation. </font><font style="vertical-align: inherit;">You write </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, a special action that puts task in the ‚ÄúCanceled‚Äù state. </font><font style="vertical-align: inherit;">In this case, the task will be in the ‚ÄúFailed‚Äù state, because not all </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are equal.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(cancellationToken); <font></font>
}, cancellationToken);<font></font>
<font></font>
                                                      Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For task to be able to </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you need to throw it </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">along with its CancellationToken. </font><font style="vertical-align: inherit;">In reality, you never explicitly do this, but do it this way:</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    cancellationToken.ThrowIfCancellationRequested(); <font></font>
}, cancellationToken);<font></font>
                                                       Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Is it necessary to distinguish cancellationToken? </font><font style="vertical-align: inherit;">Somewhere inside the task, you check that someone deleted you: throw throw cancellation, then the task goes into state </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Or someone clicked ‚ÄúCancel‚Äù at run time and canceled the task. </font><font style="vertical-align: inherit;">Our practice at JetBrains suggests that you do not need to distinguish between these tokens. </font><font style="vertical-align: inherit;">If you get an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a special kind that occurs when some cancellation has occurred, you can distinguish it. </font><font style="vertical-align: inherit;">In this case, you just need to complete the task normally, do not log in, and when you receive the execution - log in.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deep stack</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    Foo();<font></font>
}, cancellationToken);<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
     Bar() {<font></font>
       ...<font></font>
          Baz() {<font></font>
             <span class="hljs-comment">//how to get cancellation token?</span><font></font>
          } <font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's say you have a deep stack. This </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the only explicit parameter that we discussed. It must be transmitted everywhere through absolutely all hierarchies. What should I do if, in the presence of a deep hierarchy, you need to cancel your task somewhere, at the very lowest level, to throw out the reception? There is such a special trick that we use. He is called </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">static</span> AsyncLocal&lt;Cancelation&gt; asyncLocalCancellation;<font></font>
<font></font>
Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
     asyncLocalCancellation.Set(cancellationToken) <font></font>
    Foo();<font></font>
}, cancellationToken); <span class="hljs-comment">// use AsyncLocal to put cancellation int</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { 
     <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span> {<font></font>
      ...<font></font>
         Baz() {<font></font>
             asyncLocalCancellation.Value.CheckForInterrupt(); <font></font>
         }<font></font>
   } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is the same as, </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only the special </font></font><code>ThreadLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one that survives async / await code trips. </font><font style="vertical-align: inherit;">Since your code is asynchronous, and you have this kancellation, you put it in </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and somewhere at a deep level you can say " </font></font><code>CheckForInterrupt Throw If Cancellation Requested</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". </font><font style="vertical-align: inherit;">Again, this is the only parameter </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that needs to completely smear the entire code, but, in my opinion, for most tasks you just need to know what happened </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and from this draw a conclusion which state: Canceled or Failed.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cognitive complexity</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
    TaskCreationOptions, <font></font>
    TaskScheduler, <font></font>
    CancellationToken<font></font>
)<font></font>
                                                   JetBrains.Lifetimes<font></font>
<font></font>
lifetime.Start(TaskScheduler, Action) <span class="hljs-comment">//puts lifetime in AsyncLocal</span><font></font>
<font></font>
lifetime.StartMainRead(Action) <font></font>
lifetime.StartMainWrite(TaskScheduler, Action) <font></font>
lifetime.StartBackgroundRead(TaskScheduler, Action)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The more difficult the code is to read when starting the task, the higher the risk of error. Looking at the code after a year, you will forget what it does, because there are a large number of parameters. But we have the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JetBrains.Lifetimes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">, which offers modern lifetimes, well-optimized CancellationToken, with which the Start method was rewritten and the problem with repeating pieces of code was solved, as with </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are a small number of schedulers that allow you to schedule a task on the main thread with read lock. That is, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">read lock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is not something that you choose explicitly, it is a special scheduler that schedules your code on the main thread with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">read lock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as well as the main thread with write lock, background thread - and now the methods become very simple to start the shuffle. At the same time, lifetimes automatically cancel through </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, significantly simplifying the code. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_h/1n/gu/_h1ngucdl-vvbpyyalkk_gwvapu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see how </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solve these problems, and what problems they introduce. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this example, part of the code is executed synchronously, then </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and asynchronous code. Firstly, it‚Äôs good that there are much fewer repeating pieces of code ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boiler-plate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Secondly, it‚Äôs good that asynchronous code is very similar to synchronous code, this is exactly what </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await is for</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . You can write asynchronously in the same way as you wrote synchronously, without taking up threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What in this case will the compiler deploy? The synchronous code will execute synchronously, after which the task </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will </font><font style="vertical-align: inherit;">execute synchronously </font><font style="vertical-align: inherit;">, where does the special GetAwaiter object come from. In this case, we are interested </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. You can write your awaiter for absolutely any object. As a result, we wait for the task to complete </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and synchronously execute it </font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If the task did not complete, then </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuationCode</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is scheduled on the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Context scheduler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It may be that, even though you wrote </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , absolutely everything will be called synchronously.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
   <span class="hljs-keyword">await</span> InnerAsync();
   <span class="hljs-keyword">await</span> Task.Yield(); <span class="hljs-comment">//guaranteed !IsCompleted </span><font></font>
   continuationCode();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is one trick </font></font><code>Task.Yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- this is a special task that ensures that its awaiter will not always return to you </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Accordingly, </font></font><code>continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it will not be called synchronously in this place. For a UI thread, this can be important because you do not take this thread for a large amount of time. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jg/jy/7d/jgjy7dh0cnbslfcyk4jpyapc9du.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How to choose a thread for continuation? The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> philosophy is </font><font style="vertical-align: inherit;">this: you write asynchronous code the same as synchronous. If you have a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thread pool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">it makes </font><font style="vertical-align: inherit;">no difference to you - continuationCode will be executed on another thread. Regardless of whether it was </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">completed when you said </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or not, you need everything to execute on the UI thread. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The mechanism for task await is as follows: it is taken </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it is called</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and from it is created </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a thing with the Post method, which is very similar to the method </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In fact </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which was earlier, it simply takes </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and through Post performs its task on it.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
    continuationCode(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a way to change this behavior using a parameter </font></font><code>ContinueOnCapturedContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The most disgusting API that is in .NET is called </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In this case, the API creates a special awaiter that is different from </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that that shifts the continuation, it runs on the same thread, in the same context in which the method ended </font></font><code>InnerAsync </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and where the task ended.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//code must be absolutely context-agnostic</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is an insane amount of advice on the Internet: if you have a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deadlock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , please smear all your ConfigureAwait code and everything will be fine. </font><font style="vertical-align: inherit;">This is the wrong way. </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be used in cases where you want to slightly improve performance, or at the end of the method, in some library methods.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deadlocks</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode();<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a classic </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deadlock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">On the UI thread, they waited ten seconds and did </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Due to what you have done </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it </font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will never be launched, </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">therefore </font><font style="vertical-align: inherit;">, it </font><font style="vertical-align: inherit;">will never return. </font><font style="vertical-align: inherit;">All of it takes place at the very beginning.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">OnBluttionClick</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span>
  <span class="hljs-keyword">int</span> v = Button.Text.ParseInt();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
  Button.Text.Set((v+<span class="hljs-number">1</span>).ToString());<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine that this is some real activity. We clicked on the button, took it </font></font><code>Button.ParseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, made </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wrote </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We say: "Please do not close our UI stream, perform the continuation." The problem is that we want the second part after </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also to be executed on the UI thread, because this is the philosophy of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . That is, your asynchronous code looks the same as synchronous code, and runs in the same context. In this case, of course, there will be an error. And besides </font></font><code>Button.Text.Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there can be any number of method calls that also assume their context. What to do in this situation? You can do this:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//The same UI context</span><font></font>
}<font></font>
PumpUntil(() =&gt; task.IsCompleted);<font></font>
<span class="hljs-comment">//VS synchronization contexts always pump on any Wait</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With a UI thread, you must prohibit doing it </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on threads that have a common message queue. Instead of doing </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or writing </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you can pump this queue of messages, and at the same time, the continuum will also be pumped. If you can not mix synchronous and asynchronous code, then you should not mix them. But sometimes this can not be avoided. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, you have old code, and you have to mix them, then you pump the UI stream. Visual Studio pumps the UI thread on expectations, it even </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changed a little. If you go into WaitHandle on any </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then when you hang, your UI stream is pumped. Thus, they choose between </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deadlocks</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and races in favor of race s. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pumpuntil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- This is a non-ideal API, that is, when you perform random continuity in an arbitrary place, there may be nuances. </font><font style="vertical-align: inherit;">There is no other way, unfortunately. </font><font style="vertical-align: inherit;">Mix synchronous and asynchronous codes. </font><font style="vertical-align: inherit;">If anything, the whole Rider is so arranged in the old places, so sometimes there are nuances too.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Change context</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> myTaskScheduler;<font></font>
    continuationCode(); <span class="hljs-comment">//on scheduler context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is another interesting way to use </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">You can write </font></font><code>Awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and jump on threads. </font><font style="vertical-align: inherit;">I read posts in Visual Studio, they wrote for a very long time that it‚Äôs not good to jump back and forth in the middle of the method, but now they do it themselves. </font><font style="vertical-align: inherit;">Visual Studio has an API that jumps on threads through schedulers. </font><font style="vertical-align: inherit;">For normal use, doing this is not good.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structured concurrency</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Factory.StartNew(() =&gt; {...}, myTaskScheduler);<font></font>
    continuationCode(); <span class="hljs-comment">//on initial context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For convenient immersion in the new context and return to the old, some structural competition, or structural parallelism, should be built. </font><font style="vertical-align: inherit;">For example, in the sixties, the GoTo operator was considered harmful because it violated structurality. </font><font style="vertical-align: inherit;">So it is here. </font><font style="vertical-align: inherit;">Jumping on threads violates the structural. </font><font style="vertical-align: inherit;">Surprisingly, using a async state machine seems like a good way out. </font><font style="vertical-align: inherit;">That is, where your usual structure is violated, you jump on GoTo, you can violate thread structure: do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">mix </font><font style="vertical-align: inherit;">it with tags. </font><font style="vertical-align: inherit;">This is an extremely strange and rare situation when you need to do this. </font><font style="vertical-align: inherit;">Still, it is better when </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> returns to the same context. </font><font style="vertical-align: inherit;">Thus, the thread pool will not have the same thread, but the same context as it was originally.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sequential behavior</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> not the same as parallel execution? </font><font style="vertical-align: inherit;">Await execution is sequential execution. </font><font style="vertical-align: inherit;">In this case, we start the first task, wait for it, start the second task - we wait. </font><font style="vertical-align: inherit;">We have no parallelism. </font><font style="vertical-align: inherit;">For most uses, parallelism is not needed. </font><font style="vertical-align: inherit;">Parallelism itself is more complex than sequence. </font><font style="vertical-align: inherit;">Serial code is simpler than parallel, it is an axiom. </font><font style="vertical-align: inherit;">But sometimes you need to run something in parallel code, and you do it like this:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">await</span> task1;<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concurrent behavior</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();<font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here the tasks start in parallel. </font><font style="vertical-align: inherit;">It is clear that methods can return task immediately in a running state, then there will be no parallelism. </font><font style="vertical-align: inherit;">Let's say that both tasky throw an execution. </font><font style="vertical-align: inherit;">And you waited for the first task, then on the first await took off. </font><font style="vertical-align: inherit;">That is, as soon as you wrote </font></font><code>await task1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you took off and did not process </font></font><code>exception task2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Interestingly, this is absolutely valid code. </font><font style="vertical-align: inherit;">And it is this code that led .NET to the fact that in version 4.5 the behavior of working with executions has changed.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exception handling</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async(); <font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2;<font></font>
<font></font>
  <span class="hljs-comment">// if task1 throws exception and task2 throws exception we only throw and</span>
  <span class="hljs-comment">// handle task1‚Äôs exception</span><font></font>
<font></font>
  <span class="hljs-comment">//4.0 -&gt; 4.5 framework: unhandled exceptions now don‚Äôt crush process</span>
  <span class="hljs-comment">//still visible in UnobservedExceptionHandler</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Previously, unhandled executions simply threw the process, and if you didn‚Äôt catch some execution in </font></font><code>UnobservedExceptionHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(this is also some </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that you can attach to schedulers), then this process did not execute. Now this is absolutely valid code. Although .NET changed its behavior, it retained the setting to return the behavior in the opposite direction.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span>  Task  <span class="hljs-title">MyAsync</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)</span>  {  <font></font>
<font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">SomeTask1  <span class="hljs-title">Async</span>(<span class="hljs-params">cancellationToken</span>)</span>; <font></font>
 <font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">Some <span class="hljs-title">Task2Async</span>(<span class="hljs-params"> cancellation  Token</span>)</span>; 
  <span class="hljs-comment">//you should always pass use async API with cancelationToken  if possible </span><font></font>
} <font></font>
  <font></font>
<span class="hljs-keyword">try</span> { 
    <span class="hljs-keyword">await</span>  MyAsync( cancellation  Token); <font></font>
} <span class="hljs-keyword">catch</span> (OperationException e) { <span class="hljs-comment">// do nothing: OCE happened</span>
} <span class="hljs-keyword">catch</span> (Exception e) { <font></font>
    log.Error(e);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
See how the processing of the execution goes. </font><font style="vertical-align: inherit;">CancellationToken-s must be transmitted, it is necessary to "smear" CancellationToken-s all the code. </font><font style="vertical-align: inherit;">The normal behavior of async is that you do not check anywhere </font></font><code>Task.Status ancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you work with asynchronous code in the same way as with synchronous. </font><font style="vertical-align: inherit;">That is, in the case of a cancellation, you get an execution, and in this case, you do nothing when you receive it </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The difference between the status of Canceled and Faulted is that you did not receive </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but the usual execution. </font><font style="vertical-align: inherit;">And in this case, we can pledge it, you just need to get an execution and draw conclusions based on this. </font><font style="vertical-align: inherit;">If you started the task explicitly, through Task, you would have flown </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And in async, in the case they </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">always throw the very first execution that was in it (in this case - </font></font><code>OperationCanceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In practice</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronous method</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SynchronousWorker</span>(<span class="hljs-params">...</span>)</span> {<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, a demon works in ReSharper - an editor that tints the file for you. </font><font style="vertical-align: inherit;">If the file is opened in the editor, then there is some activity that puts it in a blocking queue. </font><font style="vertical-align: inherit;">Our process </font></font><code>worker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reads from there, after which it performs a bunch of different tasks with this file, tints it, parses, builds, after which these files are added to </font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">With a </font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lock, other mechanisms are already working with it.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous method</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When rewriting code to asynchronous, we will first of all replace it </font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with </font></font><code>async Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Be sure to write the word ‚ÄúAsync‚Äù at the end. </font><font style="vertical-align: inherit;">All asynchronous methods must end in Async - this is a convention.</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
<font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After that, you need to do something with ours </font></font><code>blockingQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Obviously, if there is some synchronous primitive, then there must be some asynchronous primitive. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-6/zk/8i/-6zk8ilnmdsonzd6zkafkcloqyi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This primitive is called channel: the channels that live in the package </font></font><code>System.Threading.Channels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. You can create channels and queues, limited and unlimited, which you can wait asynchronously. Moreover, you can create a channel with a value of "zero", that is, it will not have a buffer at all. Such channels are called rendezvous channels and are actively promoted in Go and Kotlin. And in principle, if it is possible to use channels in asynchronous code, this is a very good pattern. That is, we change the queue to the channel where there are methods </font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>WriteAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessInParallel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a bunch of parallel code that does the processing of a file and turns it into</font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Can async help us write not asynchronous, but parallel code more compactly?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplify Parallel Code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The code can be rewritten in this way:</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e0/zt/8u/e0zt8ud_8b4_wsiqsrd9_baalwy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What do they look like </font></font><code>ProcessInParallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? For example, we have a file. First, we break it into lexemes, and we can have two tasks in parallel: building search caches and building a syntax tree. After that comes the task of ‚Äúsearching for semantic errors.‚Äù It is important here that all these tasks form a directed acyclic graph. That is, you can run some parts in parallel threads, some cannot, and there are obviously dependencies which task should wait for other tasks. You get a graph of such tasks, you want to somehow scatter them along the threads. Is it possible to write it beautifully, without errors? In our code, this problem was solved several times, each time in a different way. It rarely happens when this code is written without errors.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xh/-h/3j/xh-h3jav69twzsqei3rrjbe2ymy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We define this task graph as follows: let's say that each task has other tasks on which it depends, then using the ExecuteBefore dictionary we write the skeleton of our method.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skeleton solutions</font></font></h3> <br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore; <span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">// lots of work with toposort, locks, etc.</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> res; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you solve this problem head-on, then you need to do a topological sorting of this graph. </font><font style="vertical-align: inherit;">Then take a task that has no dependent tasks, execute it, analyze the structure under a lock, see which tasks have no dependent ones. </font><font style="vertical-align: inherit;">Run, scatter them somehow through </font></font><code>Task Runner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We write it a little more compactly: topological sorting of the graph + execution of such tasks on different threads.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async lazy</font></font></h3><br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore;
<span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();
  <span class="hljs-keyword">var</span> lazy = <span class="hljs-keyword">new</span> Dictionary&lt;Action&lt;ProcessedFile&gt;, Lazy&lt;Task&gt;&gt;(); 
  <span class="hljs-keyword">foreach</span> ((action, beforeList) <span class="hljs-keyword">in</span> ExecuteBefore)<font></font>
    lazy[action] = <span class="hljs-keyword">new</span> Lazy&lt;Task&gt;(<span class="hljs-keyword">async</span> () =&gt; <font></font>
    {<font></font>
      <span class="hljs-keyword">await</span> Task.WhenAll(beforeList.Select(b =&gt; lazy[b].Value)) 
      <span class="hljs-keyword">await</span> Task.Yield();<font></font>
      action(res);<font></font>
}<font></font>
  <span class="hljs-keyword">await</span> Task.WhenAll(lazy.Values.Select(l =&gt; l.Value)) 
  <span class="hljs-keyword">return</span> res;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a pattern called </font></font><code>Async Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. We create ours </font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on which different actions should be executed. Let's create a dictionary: we will format each of our stage (Action ProcessedFile) into some Task, or rather, into Lazy from Task and run along the original graph. The variable </font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will have the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">action</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> itself </font><font style="vertical-align: inherit;">, and in beforeList - those actions that must be performed before ours. Then create </font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from </font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. We write in Task </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Thus, we are waiting for all the tasks that must be completed before it. In beforeList, select the one </font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is in this dictionary. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Please note that here nothing will be executed synchronously, so this code will not fall on </font></font><code>ItemNotFoundException in Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. We carry out all the tasks that were before ours, performing a search by action</font></font><code>Lazy Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Then we execute our action. </font><font style="vertical-align: inherit;">In the end, you just need to ask each task to start, otherwise you never know if something did not start. </font><font style="vertical-align: inherit;">In this case, nothing started. </font><font style="vertical-align: inherit;">This is the solution. </font><font style="vertical-align: inherit;">This method is written in 10 minutes, it is absolutely obvious. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, asynchronous code made our decision, initially it occupied a couple of screens with complex competitive code. </font><font style="vertical-align: inherit;">Here he is absolutely consistent. </font><font style="vertical-align: inherit;">I don‚Äôt even use it </font></font><code>ConcurrentDictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, I use the usual one </font></font><code>Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because we do not write anything to it competitively. </font><font style="vertical-align: inherit;">There is a consistent, consistent code. </font><font style="vertical-align: inherit;">We solve the problem of writing parallel code using </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async-s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beautifully, which means - without bugs.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get rid of locks</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
    <span class="hljs-keyword">lock</span> (_lock) {<font></font>
      sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
   }<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Is it worth pulling in async and these locks? Now there are all kinds of async locks, async semaphores, that is, an attempt to use the primitives that are in synchronous and asynchronous code. This concept seems to be wrong, because with the lock you protect something from parallel execution. Our task is to translate parallel execution into sequential, because it is easier. And if it‚Äôs easier, there are fewer errors.</font></font><br>
<br>
<pre><code class="cs hljs">Channel&lt;Pair&lt;File, ProcessedFile&gt;&gt; output;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
  <font></font>
  <span class="hljs-keyword">await</span> output.WriteAsync(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can create some channel and put there a couple of File and ProcessedFile, and </font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">some other procedure will </font><font style="vertical-align: inherit;">process this channel </font><font style="vertical-align: inherit;">, and it will do it sequentially. Lock itself, in addition to protecting the structure, essentially linearizes access, a place where all threads from consecutive ones become parallel. And we are replacing this explicitly with the channel. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q_/qe/mf/q_qemfc4mssz9shitqlekzee6nc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The architecture is as follows: workers receive files from </font></font><code>input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and send them somewhere to the processor, which also processes everything sequentially, there is no parallelism. The code looks much simpler. I understand that not everything can be done in this way. Such an architecture, when you can build data pipes, does not always work.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7k/9j/sv/7k9jsvdwqbqrzgbejoozsk5lj_s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It may be that you have a second channel that comes into your processor and not acyclic directed graph is formed from the channels, but a graph with cycles. </font><font style="vertical-align: inherit;">This is an example that Roman Elizarov told KotlinConf in 2018. </font><font style="vertical-align: inherit;">He wrote an example on Kotlin with these channels, and there were cycles there, and this example was shut down. </font><font style="vertical-align: inherit;">The problem was that if you have such cycles in a graph, then everything becomes more complicated in the asynchronous world. </font><font style="vertical-align: inherit;">Asynchronous deadlocks are bad in that they are much more difficult to solve than synchronous when you have a stack of threads, and it‚Äôs clear what hung on. </font><font style="vertical-align: inherit;">Therefore, it is a tool that must be used correctly.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summary</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avoid synchronization in asynchronous code.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serial code is simpler than parallel.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous code can be simple and use a minimum of parameters and an implicit context that change its behavior.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you have developed the habit of writing synchronous code, and even if the asynchronous code is very similar to the synchronous one, you don‚Äôt need to drag primitives there, which you are used to in synchronous code like </font></font><code>async mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Use feeds, if possible, and other </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Message passing</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> primitives </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Serial code is simpler than parallel. If you can write your architecture so that it looks sequentially, without running parallel code and locking, then write the architecture sequentially.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the last thing that we saw from a large number of examples with tasks. </font><font style="vertical-align: inherit;">When you design your system, try to rely less on implicit context. </font><font style="vertical-align: inherit;">Implicit context leads to a misunderstanding of what is happening in the code, and you can forget about implicit problems in a year. </font><font style="vertical-align: inherit;">And if another person works on this code and redo something in it, this can lead to difficulties that you once knew about, and the new programmer does not know because of the implicit context. </font><font style="vertical-align: inherit;">As a result, poor design is characterized by a large number of parameters, their combination and implicit context.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What to read</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TAP document</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asyncs guidance</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lifetimes</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">medium.com/@elizarov/deadlocks-in-non-hierarchical-csp-e5910d137cc</font></font></a></li>
</ul><br>
<blockquote>     -10     .     DotNext   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="> </a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en491218/index.html">Integration of PVS-Studio in PlatformIO</a></li>
<li><a href="../en491224/index.html">Automation of a dispatch service, or How a service company can reduce transportation costs by 30%</a></li>
<li><a href="../en491230/index.html">How I went to school 21 and the disclosure of secrets</a></li>
<li><a href="../en491232/index.html">RPA + Machine Learning = Intelligent Automation</a></li>
<li><a href="../en491234/index.html">Three Tricks for Working with SOLIDWORKS for Modeling Parts for 3D Printing</a></li>
<li><a href="../en491238/index.html">Genetic Code Analysis II</a></li>
<li><a href="../en491240/index.html">The road to the clouds: yesterday and today Adobe</a></li>
<li><a href="../en491244/index.html">Ableton is not needed: connect Ableton Push 2 to VCV Rack</a></li>
<li><a href="../en491246/index.html">DEFCON Conference 27. Your car is my car. Part 2</a></li>
<li><a href="../en491250/index.html">LED lamps Gauss Basic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>