<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏼 💸 👩🏻‍🤝‍👨🏼 PyDERASN：随着我添加了大数据支持 📗 💃🏾 ⬆️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我继续上一篇有关PyDERASN的文章-Python中免费的ASN.1 DER / CER / BER编解码器。在过去的一年中，从编写之时起，除了所有微小的事情，小的更正，甚至是更加严格的数据验证（尽管在我所熟知的免费编解码器之前，它已经是最严格的），用于处理大量数据的功能已出现在此库中-潜入RAM...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PyDERASN：随着我添加了大数据支持</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498014/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我继续上一篇有关</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PyDERASN的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">-Python</font></a><font style="vertical-align: inherit;">中免费的ASN.1 DER / CER / BER编解码器。</font><font style="vertical-align: inherit;">在过去的一年中，从编写之时起，除了所有微小的事情，小的更正，甚至是更加严格的数据验证（尽管在我所熟知的免费编解码器之前，它已经是最严格的），用于处理大量数据的功能已出现在此库中-潜入RAM。</font><font style="vertical-align: inherit;">我想在本文中谈论这一点。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/241/bae/4fc/241bae4fcfb5d7f0c3a605bf5f3211cb.png" alt="ASN.1浏览器"></div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题/任务</font></font></h2><br>
<ul>
<li><strong> CRL</strong>:<br>
,      (CA)         X.509 .    ,    CRL (certificate revocation list). CRL  CACert.org,  8.72 MiB,   PyDERASN-  Python 3.6      (    <em>asn1crypto</em>  <em>pyasn1</em>   ).      416 .  .    ,           .  .<br>
</li>
<li><strong> CMS</strong>:<br>
CMS (Cryptographic Message Syntax)    <br>
// . ,<br>
<em>SignedData</em>     ,   ,<br>
  ,   - <em>EnvelopedData</em> <br>
 .<br>
<br>
                 CMS. , CMS   detached data,     - ,         .  10 GiB    20 GiB   :       10 GiB      . .<br>
</li>
</ul><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，哪些ASN.1对象会占用大量资源，占用大量内存空间？仅</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEQUENCE OF</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET OF</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含许多对象（在CACert.org中为成千上万个）和所有</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* STRING</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（在第二种有问题的情况下）。由于程序员的优点之一是懒惰（根据Larry Wall），所以我们将尝试通过对库代码进行最少的更改来克服资源消耗的问题。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从编解码器的角度来看，</font><em><font style="vertical-align: inherit;">STRING</font></em><font style="vertical-align: inherit;">对象几乎彼此没有区别，并由一个公共类在库中实现。</font><font style="vertical-align: inherit;">DER的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OCTET STRING</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中的</font><font style="vertical-align: inherit;">编码是什么</font><font style="vertical-align: inherit;">？</font></font><br>
<br>
<pre><code class="plaintext hljs">return tag + len_encode(len(value)) + value
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
显然，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不必一直都在RAM中。</font><font style="vertical-align: inherit;">它必须是类似字节的对象，从中可以找到长度。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memoryview</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">满足这些条件。</font><font style="vertical-align: inherit;">但是，</font><font style="vertical-align: inherit;">可以通过</font><em><font style="vertical-align: inherit;">mmap</font></em><font style="vertical-align: inherit;">来完成</font><font style="vertical-align: inherit;">对已在内存中减少的任何临时文件的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memoryview的</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作。</font><font style="vertical-align: inherit;">对于CMS数据库副本，该临时文件的一半需要20 GiB 10 GiB的一半：只需将</font><em><font style="vertical-align: inherit;">OCTET STRING</font></em><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">（或任何其他</font><em><font style="vertical-align: inherit;">* STRING</font></em><font style="vertical-align: inherit;">的值）</font><font style="vertical-align: inherit;">指定为</font><font style="vertical-align: inherit;">类似于</font><em><font style="vertical-align: inherit;">memoryview</font></em><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">要创建它，PyDERASN具有帮助功能：</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="plaintext hljs">from pyderasn import file_mmaped<font></font>
with open("dump.sql.zst", "rb") as fd:<font></font>
    ... = OctetString(file_mmaped(fd))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们要解码大量数据，那么</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memoryview也</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以用于解码：</font></font><br>
<br>
<pre><code class="plaintext hljs">from pyderasn import file_mmaped<font></font>
with open("dump.sql.zst", "rb") as fd:<font></font>
    obj = Schema.decode(file_mmaped(fd))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们认为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* STRING</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的问题</font><font style="vertical-align: inherit;">已部分解决。</font><font style="vertical-align: inherit;">返回创建巨大的CRL。</font><font style="vertical-align: inherit;">它的结构是什么样的？</font></font><br>
<br>
<pre><code class="plaintext hljs">CertificateList SEQUENCE<font></font>
. tbsCertList: TBSCertList SEQUENCE<font></font>
. . version: Version INTEGER v2 (01) OPTIONAL<font></font>
. . signature: AlgorithmIdentifier SEQUENCE<font></font>
. . issuer: Name CHOICE rdnSequence<font></font>
. . thisUpdate: Time CHOICE utcTime<font></font>
. . nextUpdate: Time CHOICE utcTime OPTIONAL<font></font>
. . revokedCertificates: RevokedCertificates SEQUENCE OF OPTIONAL<font></font>
. . . 0: RevokedCertificate SEQUENCE<font></font>
. . . . userCertificate: CertificateSerialNumber INTEGER 17 (11)<font></font>
. . . . revocationDate: Time CHOICE utcTime UTCTime 2003-04-01T14:25:08<font></font>
. . . 1: RevokedCertificate SEQUENCE<font></font>
. . . . userCertificate: CertificateSerialNumber INTEGER 20 (14)<font></font>
. . . . revocationDate: Time CHOICE utcTime UTCTime 2002-10-01T02:18:01<font></font>
<font></font>
                                 [...]<font></font>
<font></font>
. . . 415753: RevokedCertificate SEQUENCE<font></font>
. . . . userCertificate: CertificateSerialNumber INTEGER 1341859 (14:79:A3)<font></font>
. . . . revocationDate: Time CHOICE utcTime UTCTime 2020-02-08T06:51:56<font></font>
. . . 415754: RevokedCertificate SEQUENCE<font></font>
. . . . userCertificate: CertificateSerialNumber INTEGER 1341860 (14:79:A4)<font></font>
. . . . revocationDate: Time CHOICE utcTime UTCTime 2020-02-08T06:53:01<font></font>
. . . 415755: RevokedCertificate SEQUENCE<font></font>
. . . . userCertificate: CertificateSerialNumber INTEGER 1341861 (14:79:A5)<font></font>
. . . . revocationDate: Time CHOICE utcTime UTCTime 2020-02-08T07:25:06<font></font>
. signatureAlgorithm: AlgorithmIdentifier SEQUENCE<font></font>
. signatureValue: BIT STRING 4096 bits<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小型</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RevokedCertificate</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构的</font><font style="vertical-align: inherit;">一长串清单</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这种情况下，仅包含证书的序列号及其撤销时间。</font><font style="vertical-align: inherit;">它的DER编码是什么？</font></font><br>
<br>
<pre><code class="plaintext hljs">value = b"".join(revCert.encode() for revCert in revCerts)<font></font>
return tag + len_encode(len(value)) + value<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
只是此列表中每个元素的DER表示的串联。</font><font style="vertical-align: inherit;">在仅被序列化为DER表示形式的15个字节的过程中，我们是否需要预先拥有所有成千上万个对象？</font><font style="vertical-align: inherit;">明显不是。</font><font style="vertical-align: inherit;">因此，我们用迭代器/生成器替换对象列表。</font><font style="vertical-align: inherit;">最有可能的是，CRL的创建将基于来自DBMS的数据：</font></font><br>
<br>
<pre><code class="plaintext hljs">def revCertsGenerator(...):<font></font>
    for row in db.cursor:<font></font>
        yield RevokedCertificate((<font></font>
            ("userCertificate", CertificateSerialNumber(row.serial)),<font></font>
            ("revocationDate", Time(("utcTime", UTCTime(row.revdate)))),<font></font>
        ))<font></font>
<font></font>
crl["tbsCertList"]["revokedCertificates"] = revCertsGenerator()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，在创建这样的CRL时我们几乎不消耗内存-我们只需要一个使用其DER表示形式的地方即可：在这种情况下，我们正在谈论的是几十兆字节（而不是一个半千兆字节的RevokedCertificate对象列表）。</font><font style="vertical-align: inherit;">但是行为上存在差异：大小检查的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEQUENCE OF</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET OF</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅在迭代器用尽之后才发生，而不是在分配值时发生。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DER流编码</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是不可能的。毕竟，这就是DER-必须预先知道所有TLV（标签+长度+值）元素的长度！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是我非常想要！毕竟，我们仍然需要10 GiB的内存来存储数据库副本的DER表示形式：</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raw = cms.encode（）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！理想情况下，我想传达一位特定的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作者</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在其中编写序列化表示。也许传输文件描述符，将占位符留在文件中的长度位置，然后通过查找来填充它们？不幸的是，长度长度（分别和占位符）也不是事先知道的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PyDERASN已经接受了两次通过DER编码的可能性。在第一遍中，收集有关对象长度的知识，从而创建一个临时状态。第二个是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流媒体</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DER编码成一定的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作家</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，已经有可能由于长度的知识。实现起来很简单，只需向每个ASN.1基本类型添加一点两次通过方法。由于对象的遍历是严格确定的（D-区分！），因此，为了存储必要的长度，将维护一个简单的列表，随着遍历对象的整个树，添加一个长度值。对于某些类型，长度是固定的。对于某些文件，仅需要向上游容器报告（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEQUENCE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEQUENCE OF</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET OF</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPLICIT TAG</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。例如，两个已撤销证书的列表的长度状态如下所示：</font></font><br>
<br>
<pre><code class="plaintext hljs">revCert = RevokedCertificate((<font></font>
    ("userCertificate", CertificateSerialNumber(123)),<font></font>
    ("revocationDate", Time(("utcTime", UTCTime(datetime.utcnow())))),<font></font>
))<font></font>
revs = RevokedCertificates([revCert, revCert])<font></font>
<font></font>
(42, [40, 18, 18])<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，我们仅需要了解每个</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RevokedCertificate</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和整个列表</font><font style="vertical-align: inherit;">的值长度</font><font style="vertical-align: inherit;">。状态中的整数长度和编码时间（在DER中为固定长度）不会被不必要地存储。结果，对于我们的CACert.org CRL，这样的列表占用的内存比3.5 MiB略多一点；对于巨型CMS，其中几乎所有的权重都落在一个具有数据库副本的单个字段上，大约需要0.5 KiB。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过两次调用执行两次通过编码：</font></font><br>
<br>
<pre><code class="plaintext hljs">fulllen, state = obj.encode1st()<font></font>
with open("result", "wb") as fd:<font></font>
    obj.encode2nd(fd.write, iter(state))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一遍还报告数据的完整长度，可用于检查可用空间或通过某些</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posix_fallocate</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用</font><font style="vertical-align: inherit;">分配可用空间</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用辅助函数</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encode2pass（obj），</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以对内存执行两次遍历编码。做什么的？它可以显着降低内存消耗的经济性，因为对于CACert.org CRL，它不会存储由</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b“”。Join（）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用</font><font style="vertical-align: inherit;">连接的416k +小二进制行</font><font style="vertical-align: inherit;">。但是，这需要更多的处理器时间，因为所有对象都必须走两次。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们可以在DER中编码任意大的CMS，几乎不需要消耗内存。</font><font style="vertical-align: inherit;">但是对于CRL，我们使用了证书吊销生成器，该证书吊销生成器将在第一遍结束后用完。</font><font style="vertical-align: inherit;">该怎么办？</font><font style="vertical-align: inherit;">只需重新初始化即可！</font></font><br>
<br>
<pre><code class="plaintext hljs">_, state = crl.encode1st()<font></font>
crl["tbsCertList"]["revokedCertificates"] = revCertsGenerator()<font></font>
crl.encode2nd(writer, iter(state))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，我们</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有义务</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确保迭代器的结果将完全相同，否则我们将获得损坏的DER。</font><font style="vertical-align: inherit;">如果数据是从DBMS游标中获取的，那么不要忘记</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">REPEATABLE READ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事务隔离级别和排序。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实时流编码：CER</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所知，DER（杰出的编码规则）是BER（基本编码规则）的子集，它以一种且仅一种方式严格地调节编码规则。这使得它可以用于加密任务。但是，还有另一个值得注意的BER子集：CER（规范编码规则）。像DER一样，它只有一种可能的数据表示形式。 CER在某些细节上与DER不同，但是它们使您可以执行真正的数据流编码。不幸的是，CER没有像DER那样受欢迎。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
忽略了不太明显的差异（例如SET中的排序标签），CER与DER有两个基本差异：</font></font><br>
<br>
<ul>
<li>    (constructed,  )  indefinite  (<em>LENINDEF</em>   PyDERASN).  ,  <em>SEQUENCE</em>/<em>SET</em>, <em>SEQUENCE OF</em>/<em>SET OF</em>, <em>EXPLICIT TAG</em>-  :<br>
<br>
<pre><code class="plaintext hljs">TAG_CONSTRUCTED || LEN(VALUE) || VALUE
</code></pre><br>
 <em>LENINDEF</em> (0x80)  EOC ( ,  )   :<br>
<br>
<pre><code class="plaintext hljs">TAG_CONSTRUCTED || 80 || VALUE || 00 00
</code></pre><br>
</li>
<li><em>*STRING</em>-,    1000-,  chunk-  1000-. ,      ,   DER. , 512          DER:<br>
<br>
<pre><code class="plaintext hljs">TAG_PRIMITIVE || LEN(512) || 512B
</code></pre><br>
 2048  :<br>
<br>
<pre><code class="plaintext hljs">TAG_CONSTRUCTED || 80 ||<font></font>
    TAG_PRIMITIVE || LEN(1000) || 1000B ||<font></font>
    TAG_PRIMITIVE || LEN(1000) || 1000B ||<font></font>
    TAG_PRIMITIVE || LEN(48) || 48B || 00 00<font></font>
</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这些（加上一些小东西）允许流（字符串缓冲区有1000字节）来编码任何对象。同样，您可以使用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和迭代器。只需调用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.encode_cer（writer）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">即可完成CER编码</font><font style="vertical-align: inherit;">。不幸的是，PyDERASN尚无法在解码期间验证CER的有效性，因此我们被迫将数据解码为BER。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说一下，CMS标准要求使用BER（DER和CER都是自动的，都是BER）编码。因此，我们可以将庞大的数据库副本编码为CER CMS，而无需进行两次通过的DER。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">要求</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SignedData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有</font><font style="vertical-align: inherit;">以DER编码</font><font style="vertical-align: inherit;">的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SignedAttributes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素，如X.509 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">证书一样。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">证书。</font><font style="vertical-align: inherit;">PyDERASN允许您通过简单地添加</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der_forced = True</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font><font style="vertical-align: inherit;">来强制在给定结构中使用DER </font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流解码：evgen模式</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们学会了编码，但是只有</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以帮助解码</font><font style="vertical-align: inherit;">。一个“真实”流解码器，具有“给我更多数据”，“您在这里”等某种状态的控制旋钮，将需要对PyDERASN进行彻底更改。而且，就我个人而言，我认为这不会比当前解决方案更方便。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当前的解决方案非常简单。在解码的过程中，我们手中有各种已解码的原始对象，它们是由它们组装而成的高级组件（已构造的），其中包括其他组件，等等。...我们累积对象以使它们组合并到达最顶端给我们一个大对象。为什么不立即“放弃”各种</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解码</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象，只要它们出现在我们手上？</font><font style="vertical-align: inherit;">也就是说，不是返回最终对象，而是返回生成许多解码对象的生成器。</font><font style="vertical-align: inherit;">实际上，在PyDERASN中，现在所有的解码方法都已成为此类“事件”的生成器（事件生成，evgen）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果启用巨大的CACert.org CRL的evgen解码模式，我们将看到以下图片：</font></font><br>
<br>
<pre><code class="plaintext hljs">$ python -m pyderasn --schema tests.test_crl:CertificateList --evgen revoke.crl<font></font>
[][T,L,  V len]<font></font>
     10   [1,1,      1]   . . version: Version INTEGER v2 (01) OPTIONAL<font></font>
     15   [1,1,      9]   . . . algorithm: OBJECT IDENTIFIER 1.2.840.113549.1.1.13<font></font>
     26   [0,0,      2]   . . . parameters: [UNIV 5] ANY OPTIONAL<font></font>
     13   [1,1,     13]   . . signature: AlgorithmIdentifier SEQUENCE<font></font>
     34   [1,1,      3]   . . . . . . type: AttributeType OBJECT IDENTIFIER 2.5.4.10<font></font>
     39   [0,0,      9]   . . . . . . value: [UNIV 19] AttributeValue ANY<font></font>
     32   [1,1,     14]   . . . . . 0: AttributeTypeAndValue SEQUENCE<font></font>
     30   [1,1,     16]   . . . . 0: RelativeDistinguishedName SET OF<font></font>
<font></font>
                                 [...]<font></font>
<font></font>
    188   [1,1,      1]   . . . . userCertificate: CertificateSerialNumber INTEGER 17 (11)<font></font>
    191   [1,1,     13]   . . . . . utcTime: UTCTime UTCTime 2003-04-01T14:25:08<font></font>
    191   [0,0,     15]   . . . . revocationDate: Time CHOICE utcTime<font></font>
    191   [1,1,     13]   . . . . . utcTime: UTCTime UTCTime 2003-04-01T14:25:08<font></font>
    186   [1,1,     18]   . . . 0: RevokedCertificate SEQUENCE<font></font>
    208   [1,1,      1]   . . . . userCertificate: CertificateSerialNumber INTEGER 20 (14)<font></font>
    211   [1,1,     13]   . . . . . utcTime: UTCTime UTCTime 2002-10-01T02:18:01<font></font>
    211   [0,0,     15]   . . . . revocationDate: Time CHOICE utcTime<font></font>
    206   [1,1,     18]   . . . 1: RevokedCertificate SEQUENCE<font></font>
<font></font>
                                 [...]<font></font>
<font></font>
9144992   [0,0,     15]   . . . . revocationDate: Time CHOICE utcTime<font></font>
9144985   [1,1,     20]   . . . 415755: RevokedCertificate SEQUENCE<font></font>
    181   [1,4,9144821]   . . revokedCertificates: RevokedCertificates SEQUENCE OF OPTIONAL<font></font>
      5   [1,4,9144997]   . tbsCertList: TBSCertList SEQUENCE<font></font>
9145009   [1,1,      9]   . . algorithm: OBJECT IDENTIFIER 1.2.840.113549.1.1.13<font></font>
9145020   [0,0,      2]   . . parameters: [UNIV 5] ANY OPTIONAL<font></font>
9145007   [1,1,     13]   . signatureAlgorithm: AlgorithmIdentifier SEQUENCE<font></font>
9145022   [1,3,    513]   . signatureValue: BIT STRING 4096 bits<font></font>
      0   [1,4,9145534]  CertificateList SEQUENCE<font></font>
</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在解码开始时，我们看到了</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CertificateList </font></font></em> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEQUENCE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标签，即数据长度，但是尚不清楚对象是否可以解码到结尾。</font><font style="vertical-align: inherit;">到目前为止，我们只是在努力中。</font></font></li>
<li>    <em>SEQUENCE</em>:  <em>version</em>,     <em>INTEGER</em>.   .   ,      . ( <strong>10</strong>)</li>
<li>   <em>signature</em>,  <em>SEQUENCE</em>-   : <em>algorithm</em>  <em>parameters</em>.   <em>OBJECT IDENTIFIER</em>  <em>ANY</em>     . ( <strong>15</strong>, <strong>26</strong>)</li>
<li>   ,  ,   <em>signature</em> <em>SEQUENCE</em>    ,    ,    :  . ( <strong>13</strong>)</li>
<li>,   <em>RevokedCertificate</em>        . ( <strong>186</strong>, <strong>206</strong>,  ..)</li>
<li> <em>tbsCertList</em>       . ( <strong>5</strong>)</li>
<li> <em>CertificateList</em>,   <em>SEQUENCE</em>,  ,        ,         . ( <strong>0</strong>)</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，所有</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* STRING</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和列表（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* OF</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）都不具有实际含义。</font><font style="vertical-align: inherit;">对于DER，如果知道</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.offset</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.vlen，则</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以从文件（一块内存？）中读取一行的值。</font><font style="vertical-align: inherit;">可以在接收所有事件的同时根据需要收集和汇总序列对象。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解码路径和evgen_mode_upto</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何理解</font><font style="vertical-align: inherit;">手头上的</font><font style="vertical-align: inherit;">什么样的对象，什么</font><font style="vertical-align: inherit;">样的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整数</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font><font style="vertical-align: inherit;">每个对象都有其自己的所谓解码路径，该路径唯一地标识结构中的特定对象。</font><font style="vertical-align: inherit;">例如，对于CACert.org CRL解码路径事件：</font></font><br>
<br>
<pre><code class="plaintext hljs">tbsCertList:version<font></font>
tbsCertList:signature:algorithm<font></font>
tbsCertList:signature:parameters<font></font>
tbsCertList:signature<font></font>
tbsCertList:issuer:rdnSequence:0:0:type<font></font>
                                 [...]<font></font>
tbsCertList:issuer:rdnSequence<font></font>
tbsCertList:issuer<font></font>
                                 [...]<font></font>
tbsCertList:revokedCertificates:0:userCertificate<font></font>
tbsCertList:revokedCertificates:0:revocationDate:utcTime<font></font>
tbsCertList:revokedCertificates:0:revocationDate<font></font>
tbsCertList:revokedCertificates:0<font></font>
tbsCertList:revokedCertificates:1:userCertificate<font></font>
tbsCertList:revokedCertificates:1:revocationDate:utcTime<font></font>
tbsCertList:revokedCertificates:1:revocationDate<font></font>
tbsCertList:revokedCertificates:1<font></font>
                                 [...]<font></font>
tbsCertList:revokedCertificates:415755:userCertificate<font></font>
tbsCertList:revokedCertificates:415755:revocationDate:utcTime<font></font>
tbsCertList:revokedCertificates:415755:revocationDate<font></font>
tbsCertList:revokedCertificates:415755<font></font>
tbsCertList:revokedCertificates<font></font>
tbsCertList<font></font>
signatureAlgorithm:algorithm<font></font>
signatureAlgorithm:parameters<font></font>
signatureAlgorithm<font></font>
signatureValue<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是我们可以从此CRL打印证书吊销序列号列表的方式：</font></font><br>
<br>
<pre><code class="plaintext hljs">raw = file_mmaped(open("....crl", "rb"))<font></font>
for decode_path, obj, tail in CertificateList().decode_evgen(raw):<font></font>
    if (len(decode_path) == 5) and (decode_path[-1] == "userCertificate"):<font></font>
        print(int(obj))<font></font>
</code></pre><br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RevokedCertificate</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
结构</font><font style="vertical-align: inherit;">可以包含很多信息，包括各种扩展名。</font><font style="vertical-align: inherit;">纯粹从技术上讲，我们在evgen模式下获取有关已吊销证书的所有数据，但是汇总与一个</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吊销证书元素相关的事件</font><font style="vertical-align: inherit;">不是很方便。</font><font style="vertical-align: inherit;">由于</font><font style="vertical-align: inherit;">实际上</font><font style="vertical-align: inherit;">每个最终的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RevokedCertificate</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都不会占用太多空间，所以拥有相同的状态将是一件很棒的事情，并非所有对象都被如此彻底地“分类”为事件。</font><font style="vertical-align: inherit;">PyDERASN允许列表指定禁用evgen模式的解码路径。</font><font style="vertical-align: inherit;">因此，我们可以设置</font><font style="vertical-align: inherit;">要获取完整</font><em><font style="vertical-align: inherit;">RevokedCertificate</font></em><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">的解码路径（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（“（tbsCertList”，“ revokedCertificates”）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列表中的</font><font style="vertical-align: inherit;">任何元素</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">：</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="plaintext hljs">for decode_path, obj, _ in CertificateList().decode_evgen(raw, ctx={<font></font>
    "evgen_mode_upto": (<font></font>
        (("tbsCertList", "revokedCertificates", any), True),<font></font>
    ),<font></font>
}):<font></font>
    if (len(decode_path) == 3) and (decode_path[1] == "revokedCertificates"):<font></font>
        print(int(obj["userCertificate"]))<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汇总字符串：agg_octet_string</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们可以轻松解码任何大小的对象。使用数据库副本对DER编码的CMS进行解码也没有问题：我们正在等待事件，该事件的解码路径指向CMS中的已签名/加密数据，并使用offset + vlen处理文件中的数据。但是，如果CMS为CER格式怎么办？然后，偏移量+ vlen将无济于事，因为我们所有的10个GiB都被分为1000字节，在这两个字节之间是DER标头。但是，如果我们有一个BER，其中</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* STRING</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的嵌套</font><font style="vertical-align: inherit;">可以是任何东西呢？</font></font><br>
<br>
<pre><code class="plaintext hljs">SOME STRING[CONSTRUCTED]<font></font>
    OCTET STRING[CONSTRUCTED]<font></font>
        OCTET STRING[PRIMITIVE]<font></font>
            DATA CHUNK<font></font>
        OCTET STRING[PRIMITIVE]<font></font>
            DATA CHUNK<font></font>
        OCTET STRING[PRIMITIVE]<font></font>
            DATA CHUNK<font></font>
    OCTET STRING[PRIMITIVE]<font></font>
        DATA CHUNK<font></font>
    OCTET STRING[CONSTRUCTED]<font></font>
        OCTET STRING[PRIMITIVE]<font></font>
            DATA CHUNK<font></font>
        OCTET STRING[PRIMITIVE]<font></font>
            DATA CHUNK<font></font>
    OCTET STRING[CONSTRUCTED]<font></font>
        OCTET STRING[CONSTRUCTED]<font></font>
            OCTET STRING[PRIMITIVE]<font></font>
                DATA CHUNK<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在evgen模式下解码时，对于每个片段，我们都会获得相应的事件，并且仅收集原始（未构造）</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* STRING</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件</font><font style="vertical-align: inherit;">就足够了</font><font style="vertical-align: inherit;">，其中offset + vlen包含真实数据。 PyDERASN具有方便的辅助</font><font style="vertical-align: inherit;">函数</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agg_octet_string</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来执行此操作。她通过一个事件生成器就足够了，该事件生成器的“解码路径”在其“下方”必须聚合一个字符串，二进制数据（或</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memoryview</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">writer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">－每个接收到的数据都调用一个函数。我们要计算SHA512哈希值，同时保存</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encapContentInfo.eContent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CMS </font><font style="vertical-align: inherit;">的内容</font><font style="vertical-align: inherit;">？找到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段</font><font style="vertical-align: inherit;">的位置</font><font style="vertical-align: inherit;">（</font><em><font style="vertical-align: inherit;">SignedData</font></em><font style="vertical-align: inherit;">将位于其中）</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），然后解码其CER内容，同时写入FS和哈希：</font></font><br>
<br>
<pre><code class="plaintext hljs">fdIn = open("data.p7m", "rb")<font></font>
raw = file_mmaped(fdIn)<font></font>
for decode_path, obj, _ in ContentInfo().decode_evgen(raw, ctx={"bered": True}):<font></font>
    if decode_path == ("content",):<font></font>
        content = obj<font></font>
        break<font></font>
hasher_state = sha512()<font></font>
fdOut = open("dump.sql.zst", "wb")<font></font>
def hash_n_save(data):<font></font>
    write_full(fdOut, data)<font></font>
    hasher_state.update(data)<font></font>
    return len(data)<font></font>
evgens = SignedData().decode_evgen(<font></font>
    raw[content.offset:],<font></font>
    offset=content.offset,<font></font>
    ctx={"bered": True},<font></font>
)<font></font>
agg_octet_string(evgens, ("encapContentInfo", "eContent"), raw, hash_n_save)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，使用了另一个</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">write_full</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实用程序</font><font style="vertical-align: inherit;">，它会调用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">writer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直到写入所有数据为止，因为通常在写入文件时，不需要OS处理所有传输的数据，并且您需要继续执行该过程直到将其完全写入为止。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于SET OF的一些深情</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
纯粹从技术上讲，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET OF</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能使用DER和CER编码即时编码，因为必须对所有元素的编码表示形式进行排序。</font><font style="vertical-align: inherit;">CER或两次通过的DER都不会对这里有所帮助。</font><font style="vertical-align: inherit;">因此，现代ASN.1标准不建议同时使用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（要求在DER中进行类似的排序）和</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET OF</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章开头的图片是什么？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正是在PyDERASN中，出现了一个互动的，朴实的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASN.1浏览器</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它亲自帮助我多次编写了复杂结构的处理程序。</font><font style="vertical-align: inherit;">使您可以遍历整个解码的结构，显示有关每个对象的完整详细信息，其在二进制数据中的位置以及解码路径。</font><font style="vertical-align: inherit;">此外，任何项目都可以保存在单独的文件中，例如CMS中包含的证书或CRL。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Matveev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cipherpunk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，Python / Go-developer，FSUE“科学技术中心” Atlas的首席专家。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN498000/index.html">在开发自己的游戏之前我想知道的事情</a></li>
<li><a href="../zh-CN498002/index.html">Z3袖珍指南</a></li>
<li><a href="../zh-CN498004/index.html">Docker容器中的工作站</a></li>
<li><a href="../zh-CN498006/index.html">选择专利律师</a></li>
<li><a href="../zh-CN498012/index.html">带有Qemu的Docker中的Mikrotik RouterOS</a></li>
<li><a href="../zh-CN498018/index.html">微服务架构中的运营分析：帮助和提示Postgres FDW来帮助开发人员</a></li>
<li><a href="../zh-CN498020/index.html">关于适用于快速评估功能的视觉评估的一项指标</a></li>
<li><a href="../zh-CN498022/index.html">＃341移动开发人员的有趣材料摘要（4月13日至19日）</a></li>
<li><a href="../zh-CN498024/index.html">使用Houdini和Python单击鼠标即可构建城市</a></li>
<li><a href="../zh-CN498026/index.html">FOSS新闻第12号-2020年4月13日至19日免费和开源新闻的回顾</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>