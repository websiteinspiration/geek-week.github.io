<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👄 👨‍👩‍👧‍👧 🏴󠁧󠁢󠁷󠁬󠁳󠁿 PostgreSQL Antipatterns: Wie tief ist das Kaninchenloch? gehe durch die Hierarchie 👨🏽‍🏭 😸 👨🏼‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In komplexen ERP-Systemen haben viele Entitäten einen hierarchischen Charakter , wenn homogene Objekte in einem Beziehungsbaum zwischen Vorfahren und ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL Antipatterns: Wie tief ist das Kaninchenloch? gehe durch die Hierarchie</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/501614/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In komplexen ERP-Systemen haben </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viele Entitäten einen hierarchischen Charakter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wenn homogene Objekte in einem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beziehungsbaum zwischen Vorfahren und Nachkommen angeordnet sind.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist die Organisationsstruktur des Unternehmens (all diese Zweige, Abteilungen und Arbeitsgruppen) sowie der Produktkatalog, die Arbeitsbereiche und die Geografie Verkaufsstellen, ... </font><font style="vertical-align: inherit;">
Tatsächlich gibt es keinen einzigen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Bereich der Geschäftsautomatisierung,</font></a><font style="vertical-align: inherit;"> in dem zumindest eine gewisse Hierarchie nicht das Ergebnis wäre. Aber selbst wenn Sie nicht „geschäftlich“ arbeiten, können Sie leicht auf hierarchische Beziehungen stoßen. Selbst Ihr Stammbaum oder Grundriss der Räumlichkeiten im Einkaufszentrum hat dieselbe Struktur. </font><font style="vertical-align: inherit;">
Es gibt viele Möglichkeiten, einen solchen Baum in einem DBMS zu speichern, aber heute konzentrieren wir uns nur auf eine Option:</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/tq/ad/-otqadbymksleulmgjdpxf6e2bo.png"></a><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> hier(
  <span class="hljs-keyword">id</span>
    <span class="hljs-built_in">integer</span>
      PRIMARY <span class="hljs-keyword">KEY</span><font></font>
, pid<font></font>
    <span class="hljs-built_in">integer</span>
      <span class="hljs-keyword">REFERENCES</span> hier<font></font>
, <span class="hljs-keyword">data</span>
    <span class="hljs-keyword">json</span><font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> hier(pid); <span class="hljs-comment">--  ,  FK    ,    PK</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und während Sie in die Tiefen der Hierarchie blicken, wartet sie geduldig darauf, wie [nicht] effektiv Ihre "naiven" Arbeitsweisen mit einer solchen Struktur ausfallen werden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/na/_z/nxna_zsl1hv506-owlmrxybpute.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns die typischen neuen Aufgaben und ihre Implementierung in SQL analysieren und versuchen, ihre Leistung zu verbessern.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 1. </font><font style="vertical-align: inherit;">Wie tief ist das Kaninchenloch?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, dass diese Struktur die Unterordnung der Abteilungen in die Struktur der Organisation widerspiegelt: Abteilungen, Abteilungen, Sektoren, Zweige, Arbeitsgruppen ... wie auch immer Sie sie nennen.</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/kl/yg/ck/klygckuyurttjnrskva_a6clwfy.png"></div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst generieren wir unseren 'Baum' aus 10K-Elementen</font></font></b>
                        <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> hier
<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-number">1</span>::<span class="hljs-built_in">integer</span> <span class="hljs-keyword">id</span>
  , <span class="hljs-string">'{1}'</span>::<span class="hljs-built_in">integer</span>[] pids
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-keyword">id</span> + <span class="hljs-number">1</span>
  , pids[<span class="hljs-number">1</span>:(random() * array_length(pids, <span class="hljs-number">1</span>))::<span class="hljs-built_in">integer</span>] || (<span class="hljs-keyword">id</span> + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> &lt; <span class="hljs-number">10000</span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span>
  pids[array_length(pids, <span class="hljs-number">1</span>)] <span class="hljs-keyword">id</span>
, pids[array_length(pids, <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>] pid
<span class="hljs-keyword">FROM</span>
  T;</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit der einfachsten Aufgabe - alle Mitarbeiter zu finden, die in einem bestimmten Sektor oder in einer Hierarchie arbeiten -, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um alle Nachkommen eines Knotens zu finden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es wäre auch schön, die „Tiefe“ des Nachkommen zu ermitteln ... All dies kann beispielsweise erforderlich sein, um eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komplexe Auswahl aus der Liste der IDs dieser Mitarbeiter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu erstellen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles wäre in Ordnung, wenn es nur ein paar Ebenen dieser Nachkommen gibt und quantitativ innerhalb eines Dutzend, aber wenn es mehr als 5 Ebenen gibt und es bereits Dutzende von Nachkommen gibt, kann es Probleme geben. </font><font style="vertical-align: inherit;">Mal sehen, wie die traditionellen Suchoptionen "down the tree" geschrieben sind (und funktionieren). </font><font style="vertical-align: inherit;">Aber zuerst bestimmen wir, welcher der Knoten für unsere Forschung am interessantesten ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"tiefsten"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teilbäume:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-keyword">id</span><font></font>
  , pid<font></font>
  , <span class="hljs-built_in">ARRAY</span>[<span class="hljs-keyword">id</span>] <span class="hljs-keyword">path</span>
  <span class="hljs-keyword">FROM</span><font></font>
    hier<font></font>
  <span class="hljs-keyword">WHERE</span>
    pid <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span><font></font>
    hier.id<font></font>
  , hier.pid<font></font>
  , T.path || hier.id<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    hier<font></font>
      <span class="hljs-keyword">ON</span> hier.pid = T.id<font></font>
)<font></font>
<span class="hljs-keyword">TABLE</span> T <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> array_length(<span class="hljs-keyword">path</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">DESC</span>;</code></pre><br>
<pre><code class="plaintext hljs"> id  | pid  | path<font></font>
---------------------------------------------<font></font>
7624 | 7623 | {7615,7620,7621,7622,7623,7624}<font></font>
4995 | 4994 | {4983,4985,4988,4993,4994,4995}<font></font>
4991 | 4990 | {4983,4985,4988,4989,4990,4991}<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"breitesten"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teilbäume:</font></font><br>
<br>
<pre><code class="sql hljs">...
<span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">path</span>[<span class="hljs-number">1</span>] <span class="hljs-keyword">id</span>
, <span class="hljs-keyword">count</span>(*)
<span class="hljs-keyword">FROM</span><font></font>
  T<font></font>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">1</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">2</span> <span class="hljs-keyword">DESC</span>;</code></pre><br>
<pre><code class="plaintext hljs">id   | count<font></font>
------------<font></font>
5300 |   30<font></font>
 450 |   28<font></font>
1239 |   27<font></font>
1573 |   25<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für diese Abfragen haben wir ein typisches </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rekursives JOIN verwendet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<img src="https://habrastorage.org/webt/lx/cx/3n/lxcx3n6k4cttix3mbrcoj8hyap8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei diesem Abfragemodell </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stimmt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die </font><b><font style="vertical-align: inherit;">Anzahl der Iterationen</font></b><font style="vertical-align: inherit;"> natürlich </font><b><font style="vertical-align: inherit;">mit der Gesamtzahl der Nachkommen überein</font></b><font style="vertical-align: inherit;"> (und es gibt mehrere Dutzend davon). Dies kann erhebliche Ressourcen und damit Zeit in Anspruch nehmen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns den "breitesten" Teilbaum an:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-keyword">id</span>
  <span class="hljs-keyword">FROM</span><font></font>
    hier<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-number">5300</span>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span><font></font>
    hier.id<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    hier<font></font>
      <span class="hljs-keyword">ON</span> hier.pid = T.id<font></font>
)<font></font>
<span class="hljs-keyword">TABLE</span> T;</code></pre><br>
<img src="https://habrastorage.org/webt/gx/xg/q6/gxxgq6p6c0eynpmffoohetg2iye.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[siehe EXPLAIN.tensor.ru]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wie erwartet haben wir alle 30 Einträge gefunden. </font><font style="vertical-align: inherit;">Aber sie haben 60% der gesamten Zeit damit verbracht - weil sie 30 Suchanfragen im Index durchgeführt haben. </font><font style="vertical-align: inherit;">Und weniger - ist es möglich?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Massendes Korrekturlesen nach Index</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und müssen wir für jeden Knoten eine separate Indexanforderung stellen? Es stellt sich heraus, dass nein - wir können </font><font style="vertical-align: inherit;">mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einem Aufruf mehrere Schlüssel gleichzeitig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus dem Index lesen </font></font><code>= ANY(array)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und in jeder solchen Gruppe von Bezeichnern können wir alle im vorherigen Schritt gefundenen IDs von "Knoten" übernehmen. Das heißt, bei jedem nächsten Schritt werden wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sofort nach allen Nachkommen eines bestimmten Levels gleichzeitig suchen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist jedoch ein Pech, dass Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einer rekursiven Auswahl nicht in einer Unterabfrage auf sich selbst verweisen können</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sondern nur irgendwie genau auswählen müssen, was auf der vorherigen Ebene gefunden wurde. Es stellt sich heraus, dass Sie keine Unterabfrage für die gesamte Stichprobe, sondern für das jeweilige Feld durchführen können. kann. Und dieses Feld kann auch ein Array sein - was wir verwenden müssen</font></font><code>ANY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es klingt ein bisschen wild, aber auf dem Diagramm - alles ist einfach.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fm/_t/qz/fm_tqzx1c9ri4-mbrgtxqvjizri.png"><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-built_in">ARRAY</span>[<span class="hljs-keyword">id</span>] <span class="hljs-keyword">id</span>$
  <span class="hljs-keyword">FROM</span><font></font>
    hier<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-number">5300</span>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span>
        <span class="hljs-keyword">id</span>
      <span class="hljs-keyword">FROM</span><font></font>
        hier<font></font>
      <span class="hljs-keyword">WHERE</span>
        pid = <span class="hljs-keyword">ANY</span>(T.id$)<font></font>
    ) <span class="hljs-keyword">id</span>$
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">coalesce</span>(<span class="hljs-keyword">id</span>$, <span class="hljs-string">'{}'</span>) &lt;&gt; <span class="hljs-string">'{}'</span> <span class="hljs-comment">--     -  </span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">unnest</span>(<span class="hljs-keyword">id</span>$) <span class="hljs-keyword">id</span>
<span class="hljs-keyword">FROM</span>
  T;</code></pre><br>
<img src="https://habrastorage.org/webt/i0/a-/sk/i0a-sk-ytooivrkxwyxsq-ipnoi.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[siehe EXPLAIN.tensor.ru]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Und hier ist das Wichtigste, nicht einmal </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,5 Mal in der Zeit zu gewinnen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sondern dass wir weniger Puffer abgezogen haben, da wir nur 5 Aufrufe des Index anstelle von 30 haben! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein zusätzlicher Bonus ist die Tatsache, dass nach den letzten unnest Identifiers nach "Levels" geordnet bleiben.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knoten-Tag</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die nächste Überlegung, die zur Verbesserung der Produktivität beiträgt, ist, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dass „Blätter“ keine Kinder haben können</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das heißt, sie müssen nicht nach etwas suchen. Bei der Formulierung unserer Aufgabe bedeutet dies, dass wir nicht weiter in dieser Branche suchen müssen, wenn wir entlang der Abteilungskette gegangen sind und den Mitarbeiter erreicht haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zusätzliches </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feld</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in unsere Tabelle einfügen </font><font style="vertical-align: inherit;">, das uns sofort sagt, ob dieser bestimmte Eintrag in unserem Baum ein „Knoten“ ist </font><b><font style="vertical-align: inherit;">- das heißt</font></b><font style="vertical-align: inherit;"> , wenn er überhaupt Kinder haben kann.</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> hier
  <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> branch <span class="hljs-built_in">boolean</span>;<font></font>
<font></font>
<span class="hljs-keyword">UPDATE</span><font></font>
  hier T<font></font>
<span class="hljs-keyword">SET</span>
  branch = <span class="hljs-literal">TRUE</span>
<span class="hljs-keyword">WHERE</span>
  <span class="hljs-keyword">EXISTS</span>(
    <span class="hljs-keyword">SELECT</span>
      <span class="hljs-literal">NULL</span>
    <span class="hljs-keyword">FROM</span><font></font>
      hier<font></font>
    <span class="hljs-keyword">WHERE</span><font></font>
      pid = T.id<font></font>
    <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span><font></font>
);<font></font>
<span class="hljs-comment">--   : 3033    42 .</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fein! </font><font style="vertical-align: inherit;">Es stellt sich heraus, dass nur etwas mehr als 30% aller Baumelemente Nachkommen haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt wenden </font></font><code>LATERAL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">eine etwas andere Mechanik an - die Verbindung zum rekursiven Teil durch </font><font style="vertical-align: inherit;">, die es uns ermöglicht, sofort auf die Felder der rekursiven "Tabelle" zuzugreifen und die Aggregatfunktion mit der Filterbedingung basierend auf dem Knoten zu verwenden, um den Schlüsselsatz zu reduzieren:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f1/3x/vb/f13xvb2zblngijramviz8kpidks.png"><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    array_agg(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">id</span>$<font></font>
  , array_agg(<span class="hljs-keyword">id</span>) FILTER(<span class="hljs-keyword">WHERE</span> branch) ns$
  <span class="hljs-keyword">FROM</span><font></font>
    hier<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-number">5300</span>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span><font></font>
    X.*<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">LATERAL</span> (
    <span class="hljs-keyword">SELECT</span>
      array_agg(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">id</span>$<font></font>
    , array_agg(<span class="hljs-keyword">id</span>) FILTER(<span class="hljs-keyword">WHERE</span> branch) ns$
    <span class="hljs-keyword">FROM</span><font></font>
      hier<font></font>
    <span class="hljs-keyword">WHERE</span>
      pid = <span class="hljs-keyword">ANY</span>(T.ns$)<font></font>
  ) X<font></font>
    <span class="hljs-keyword">ON</span> <span class="hljs-keyword">coalesce</span>(T.ns$, <span class="hljs-string">'{}'</span>) &lt;&gt; <span class="hljs-string">'{}'</span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">unnest</span>(<span class="hljs-keyword">id</span>$) <span class="hljs-keyword">id</span>
<span class="hljs-keyword">FROM</span>
  T;</code></pre><br>
<img src="https://habrastorage.org/webt/jc/6r/fa/jc6rfaqvbbvy6avqifoi1bf5chk.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[siehe EXPLAIN.tensor.ru]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wir konnten eine weitere Attraktivität des Index reduzieren und haben </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mehr als zweimal in Bezug auf den</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abgezogenen </font><b><font style="vertical-align: inherit;">Betrag gewonnen</font></b><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 2 </font><font style="vertical-align: inherit;">Zurück zu den Wurzeln</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Algorithmus ist nützlich, wenn Sie Datensätze für alle Elemente „im Baum“ sammeln müssen, während Sie Informationen darüber beibehalten, welches Quellblatt (und mit welchen Indikatoren) dazu geführt hat, dass es in die Stichprobe fällt - beispielsweise um einen zusammenfassenden Bericht mit Aggregation zu Knoten zu erstellen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ah/xs/xb/ahxsxbntkmfs884ggqqqvoeyqbc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das weitere sollte ausschließlich als Proof-of-Concept angesehen werden, da die Anfrage sehr umständlich ist. </font><font style="vertical-align: inherit;">Wenn es jedoch Ihre Datenbank dominiert, sollten Sie die Verwendung solcher Techniken in Betracht ziehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit ein paar einfachen Aussagen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besser,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> denselben Datensatz </font><b><font style="vertical-align: inherit;">nur einmal</font></b><font style="vertical-align: inherit;"> aus der Datenbank </font><b><font style="vertical-align: inherit;">zu lesen</font></b><font style="vertical-align: inherit;"> .</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einträge aus der Datenbank werden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einem "Bundle" effizienter gelesen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als einzeln.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir nun, die Abfrage zu entwerfen, die wir benötigen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 1</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich müssen wir bei der Initialisierung der Rekursion (wo ohne sie!) Die Aufzeichnungen der Blätter selbst von der Menge der Quellkennungen subtrahieren:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> tree <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    rec <span class="hljs-comment">--    </span>
  , <span class="hljs-keyword">id</span>::<span class="hljs-built_in">text</span> chld <span class="hljs-comment">--  ""    </span>
  <span class="hljs-keyword">FROM</span><font></font>
    hier rec<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-keyword">ANY</span>(<span class="hljs-string">'{1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192}'</span>::<span class="hljs-built_in">integer</span>[])
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn es jemandem seltsam erschien, dass das „Set“ in einer Zeichenfolge und nicht in einem Array gespeichert ist, gibt es eine einfache Erklärung. </font><font style="vertical-align: inherit;">Für Strings gibt es eine eingebaute aggregierende "Klebe" -Funktion </font></font><code>string_agg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, für Arrays jedoch nein. </font><font style="vertical-align: inherit;">Obwohl es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht schwierig ist, es selbst zu implementieren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 2</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt würden wir eine Reihe von Abschnitts-IDs erhalten, die weiter subtrahiert werden müssen. </font><font style="vertical-align: inherit;">Fast immer werden sie in verschiedenen Datensätzen des Quellensatzes dupliziert - daher würden wir sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gruppieren</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und gleichzeitig Informationen über die Quellblätter beibehalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber hier erwarten uns drei Probleme:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der „sub-rekursive“ Teil einer Abfrage kann keine Aggregatfunktionen c enthalten </font></font><code>GROUP BY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Aufruf einer rekursiven "Tabelle" kann nicht in einer verschachtelten Unterabfrage erfolgen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Abfrage im rekursiven Teil darf keinen CTE enthalten.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Glücklicherweise lassen sich all diese Probleme leicht umgehen. </font><font style="vertical-align: inherit;">Beginnen wir am Ende.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CTE im rekursiven Teil</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So funktioniert </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es nicht</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> tree <span class="hljs-keyword">AS</span> (<font></font>
  ...<font></font>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">WITH</span> T (...)
  <span class="hljs-keyword">SELECT</span> ...<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so funktioniert es, Klammern entscheiden!</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> tree <span class="hljs-keyword">AS</span> (<font></font>
  ...<font></font>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><font></font>
  (<font></font>
    <span class="hljs-keyword">WITH</span> T (...)
    <span class="hljs-keyword">SELECT</span> ...<font></font>
  )<font></font>
)</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschachtelte Abfrage für rekursive "Tabelle"</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hmm ... Ein Aufruf eines rekursiven CTE kann nicht in einer Unterabfrage erfolgen. </font><font style="vertical-align: inherit;">Aber es kann innerhalb des CTE sein! </font><font style="vertical-align: inherit;">Eine Unteranfrage kann bereits auf diesen CTE verweisen!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GROUP BY innerhalb der Rekursion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist unangenehm, aber ... Wir haben auch eine einfache Möglichkeit, GROUP BY mithilfe von </font></font><code>DISTINCT ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fensterfunktionen </font><font style="vertical-align: inherit;">zu simulieren </font><font style="vertical-align: inherit;">!</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span>
  (rec).pid <span class="hljs-keyword">id</span>
, string_agg(chld::<span class="hljs-built_in">text</span>, <span class="hljs-string">','</span>) chld
<span class="hljs-keyword">FROM</span><font></font>
  tree<font></font>
<span class="hljs-keyword">WHERE</span>
  (rec).pid <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">1</span> <span class="hljs-comment">--  !</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so funktioniert es!</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">ON</span>((rec).pid)<font></font>
  (rec).pid <span class="hljs-keyword">id</span>
, string_agg(chld::<span class="hljs-built_in">text</span>, <span class="hljs-string">','</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> (rec).pid) chld
<span class="hljs-keyword">FROM</span><font></font>
  tree<font></font>
<span class="hljs-keyword">WHERE</span>
  (rec).pid <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt sehen wir, warum die numerische ID in Text umgewandelt wurde - damit sie mit einem Komma zusammengeklebt werden können!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 3</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für das Finale haben wir nichts mehr übrig:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir lesen Aufzeichnungen von "Abschnitten" auf einer Reihe von gruppierten IDs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordnen Sie die subtrahierten Abschnitte den „Sätzen“ der Quellblätter zu</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweitern Sie die festgelegte Zeichenfolge mit </font></font><code>unnest(string_to_array(chld, ',')::integer[])</code></li>
</ul><br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> tree <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    rec<font></font>
  , <span class="hljs-keyword">id</span>::<span class="hljs-built_in">text</span> chld
  <span class="hljs-keyword">FROM</span><font></font>
    hier rec<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-keyword">ANY</span>(<span class="hljs-string">'{1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192}'</span>::<span class="hljs-built_in">integer</span>[])
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><font></font>
  (<font></font>
    <span class="hljs-keyword">WITH</span> prnt <span class="hljs-keyword">AS</span> (
      <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">ON</span>((rec).pid)<font></font>
        (rec).pid <span class="hljs-keyword">id</span>
      , string_agg(chld::<span class="hljs-built_in">text</span>, <span class="hljs-string">','</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> (rec).pid) chld
      <span class="hljs-keyword">FROM</span><font></font>
        tree<font></font>
      <span class="hljs-keyword">WHERE</span>
        (rec).pid <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span><font></font>
    )<font></font>
    , nodes <span class="hljs-keyword">AS</span> (
      <span class="hljs-keyword">SELECT</span><font></font>
        rec<font></font>
      <span class="hljs-keyword">FROM</span><font></font>
        hier rec<font></font>
      <span class="hljs-keyword">WHERE</span>
        <span class="hljs-keyword">id</span> = <span class="hljs-keyword">ANY</span>(<span class="hljs-built_in">ARRAY</span>(
          <span class="hljs-keyword">SELECT</span>
            <span class="hljs-keyword">id</span>
          <span class="hljs-keyword">FROM</span><font></font>
            prnt<font></font>
        ))<font></font>
    )<font></font>
    <span class="hljs-keyword">SELECT</span><font></font>
      nodes.rec<font></font>
    , prnt.chld<font></font>
    <span class="hljs-keyword">FROM</span><font></font>
      prnt<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      nodes<font></font>
        <span class="hljs-keyword">ON</span> (nodes.rec).id = prnt.id<font></font>
  )<font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">unnest</span>(string_to_array(chld, <span class="hljs-string">','</span>)::<span class="hljs-built_in">integer</span>[]) leaf<font></font>
, (rec).*<font></font>
<span class="hljs-keyword">FROM</span>
  tree;</code></pre><br>
<img src="https://habrastorage.org/webt/hl/e5/jn/hle5jn8eolot086fr-ecmutxlye.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[  explain.tensor.ru]</a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de501598/index.html">Eine bescheidene Anleitung zu Datenbankschemata</a></li>
<li><a href="../de501600/index.html">Spielekonsole stm32</a></li>
<li><a href="../de501604/index.html">Übersetzung von Andrew Un's Buch Passion for Machine Learning. Kapitel 51 und 52</a></li>
<li><a href="../de501610/index.html">Benutzerdefinierte Bildlaufleiste in Angular</a></li>
<li><a href="../de501612/index.html">Welche Grafikkarte Sie 2020 für Ihren Computer auswählen sollten</a></li>
<li><a href="../de501616/index.html">Kundenporträt: komponieren und zählen</a></li>
<li><a href="../de501622/index.html">Fallbeispiel: Erstellen eines Inhaltsplans für ein B2B-Blog basierend auf der Informationssemantik</a></li>
<li><a href="../de501624/index.html">Aktuelle Modelle der sprachlichen Lokalisierung im Bereich IT und digitale Kommunikation. Teil 2</a></li>
<li><a href="../de501628/index.html">Interview mit Alexander Filippov, Lead Game Designer World of Tanks Blitz</a></li>
<li><a href="../de501630/index.html">Fünf Sicherheitsrisiken bei Remote-Arbeiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>