<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕸️ 👩🏿‍🤝‍👨🏾 👨🏾‍⚕️ なぜフラッターが勝っているのですか？ 👩🏽‍🤝‍👨🏻 🤽 🥥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="昨年、私はとにかくiOSとAndroid向けのFlutterアプリを書いてきました。それ以前は、Xamarinで5年の経験があります。素晴らしい5年になります。Xamarinとこのフレームワークに対する私の愛のおかげで、基本的に開発者の陣営に移動しました。このツールは、たくさんのお金と知識を獲得し、...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>なぜフラッターが勝っているのですか？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501340/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">昨年、私はとにかくiOSとAndroid向けのFlutterアプリを書いてきました。</font><font style="vertical-align: inherit;">それ以前は、Xamarinで5年の経験があります。</font><font style="vertical-align: inherit;">素晴らしい5年になります。</font><font style="vertical-align: inherit;">Xamarinとこのフレームワークに対する私の愛のおかげで、基本的に開発者の陣営に移動しました。このツールは、たくさんのお金と知識を獲得し、素晴らしい同僚を見つけるのに役立ちました。</font><font style="vertical-align: inherit;">では、なぜ今Flutterで書いているのですか？</font><font style="vertical-align: inherit;">Flutterはクロスプラットフォーム開発のすべてのニーズをカバーするためです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qo/ua/rw/qouarwd80cvkhylqpiukpop86n8.jpeg"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ちょっとした歴史</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が間違っている場合は修正してください。しかし、2009年は多くの点でモバイル開発全般、特にクロスプラットフォーム開発の鍵となりました。 2009年にiPhone 3gsがリリースされ、AppStoreからサードパーティのアプリケーションを実行できるようになりました。この機会は1年前のiPhone 3gで初めて登場しましたが、3gsは本当に大規模な「人気の」iPhoneになりました。ここでも、1年前の2008年9月にAndroidが一般に公開され、2009年に多くの電話メーカーが新しい電話モデルにAndroidを試用し始めました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2009年春</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、NitobiはPhoneGapを導入しました。PhoneGapは、HTML5、CSS、JSに基づいたクロスプラットフォームアプリケーションを作成するための新しいフレームワークです。同年、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9月</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XimianはMonoTouchをリリースしました。これにより、MonoとC＃を使用してiOSアプリケーションを作成できます。同じ2009年の12月に、Rovio EntertainmentはiOS向けのゲームをリリースしました。一瞬、Maemoがモバイルゲーム業界の始まりであるAngry Birdsの始まりを示しました。ここでの最後の例は偶然ではありません。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「人々のための」最初のクロスプラットフォームフレームワークはPhoneGap（Qt開発者、石を投げないでください）と見なすことができます。モバイル開発の世界にWebを取り入れることは、すばらしい非常に明白なアイデアでした。 2009年までに、Webの機能はブラウザー（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hello</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> node.js）</font><font style="vertical-align: inherit;">を超えて拡張され始めましたが</font><font style="vertical-align: inherit;">、JSでのWebアプリケーションの作成は非常に簡単でした。 2つ目は、UIのレンダリングです。レンダリングが行われる方法はブラウザエンジンにあり、これらのすべてのエンジンは、HTML、CSS、およびDOMのW3C標準にほぼ準拠しています。サイトを作成したすべてのWeb開発者は、自分のサイトが</font><s><font style="vertical-align: inherit;">ほとんど</font></s><font style="vertical-align: inherit;">見えることを期待しています</font></font><s><font style="vertical-align: inherit;"></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのブラウザのどのプラットフォームでも同じです。私の意見では、これはオープンプラットフォームとしてのWebの最も重要な側面です。長い間、さまざまなブラウザーのUIをモデリングするための標準がある場合、プラットフォームごとにUIを描画するための新しい言語/フレームワークを学ぶ必要があるのはなぜですか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、CordovaはPhoneGapから、Ionicはそれから出芽しました。これは理想的なフレームワークのようですが、パフォーマンスとOSの統合という2つのポイントがありました。主な目標の1つ、または必要に応じてクロスプラットフォームソリューションで記述されたアプリケーションベンチマークは、その「ネイティブさ」でした。それら。理想的には、ユーザーの100％がクロスプラットフォームアプリケーションがネイティブであると考える必要があります。これは、ネイティブのように見え、ネイティブのように機能し、OSとのすべての統合が可能なことを意味します。当初、PhoneGapのこれらすべてのポイントは達成できませんでした。10年前のスマートフォンの容量は60 fpsのUIレンダリングには不十分であり、OSとの統合は最小限でした。現在、Ionicには、ネイティブアプリケーションと区別するのが難しいアプリケーションがかなりありますが、ネイティブアプリケーションを模倣することは依然として課題です。そのように与えられていません。少しまとめましょう。 Webアプリケーション、つまりiOSとAndroidのハイブリッドアプリケーションを作成することは可能で便利です。 UIレンダリングメカニズムは完全にWebViewプラットフォーム上にあり、Webに精通しているプログラマの層がすでにトレーニングされているため、これは便利です。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただし、ハイブリッドアプリケーションでは、パフォーマンスとOSの統合が不十分な場合があります。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
PhoneGapと同時に、MonoTouchは2009年に発売され、後にXamarin.iOSに改名されました。また、同じ年にTitaniumがリリースされ、JavaScriptでiOSアプリケーションを作成することも可能になりました。当初、TitaniumはPhoneGapとまったく同じパラダイムで動作しました-WebViewに依存しています。しかし、彼らはXamarinアプローチを採用しました。このアプローチは何ですか？真ん中の何かと見ることができます。 Xamarin / Titanium / React.Nativeのアプローチは、/既存のUIレンダーを作成/移行しようとする代わりに、フレームワークが単に既存のネイティブと統合することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Xamarinは、フォームをHTMLで描画する代わりに、ネイティブUI要素（UITextField、TextEditなど）を呼び出します。実際、なぜ車輪を再発明するのですか？必要なUI要素はすべてネイティブSDKとランタイムに存在します。VMからそれらと通信する方法を学ぶ必要があります（mono、v8など）。同時に、すでにお気づきのように、お気に入りのC＃、JS、TS、F＃、Kotlinなどを使用できます。同時に、UIと直接対話しないコードは100％クロスプラットフォームです。さらに先に進むことができます。同じUITextFieldのテキストエディットとは概念的に同じ実体である、彼らはかなりの数の同様の特性との相互作用のインターフェースを持ち、そのため、あなたは（まれなため、それだけで抽象エントリ（ハローXamarin.Forms）と仕事を作成することができ</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ない非常に</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）プラットフォームのUI要素に行く例外。 VMがUIをネイティブで使用できる場合、ほとんどの場合、VMは任意のプラットフォームAPIを呼び出すことができることは触れません。これは完璧なオプションのようです。ネイティブUI、ネイティブパフォーマンス（hi Bridges in React.Native）、100％OS統合。これは本当に完璧ですか？ほとんどの場合-いいえ、問題は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、実際にはこれらのソリューションはクロスプラットフォーム開発の問題、つまり単一のUIを解決しないことです。彼らは彼女を偽装します</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。一度書いてどこでも走りたい。これは、すべてのタイプのプログラムと問題に最適なモットーとはほど遠いですが、UIに適しています。プラットフォームに関係なく、誰にとっても同じUIを書きたいと思います。 Web開発者がHTMLとCSSを使用して、iOSのSafariとAndroidのChromeで同じように表示されるが、ネイティブの開発者ではないWebサイトの作成を許可できるのはなぜですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、プログラマーは長い間、iOSとAndroidに共通のコードベースを備えた高性能UIを作成してきました。これらのプログラマーはゲーム開発者と呼ばれます。 Angry BirdsはCocos2d-xエンジン、CupheadはUnity、FortniteはUnreal Engineで作成されました。ゲームエンジンが携帯電話で息をのむようなシーンを表示できる場合、スムーズなアニメーションのボタンとリストは間違いなく表示できます。それで、なぜ誰もこの脈でそれらを使わないのですか答えは単純で平凡で、これは意図されていません。ゲームを開くと、UIがネイティブのUIのように見えるかどうかは、完全に懐中電灯次第です。ジオロケーション、プッシュボタン、ビデオカメラなどを操作する必要はほとんどありません。遊んでいる間、UIViewController / ActivityのCanvasを介してレンダリングされる小さな世界の別の生活を送っています。したがって</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームエンジンはOSとの統合が比較的不十分</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であるため、ネイティブUIのトップエンジンを模倣したものはありません（または見たことがない）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小計</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的なクロスプラットフォームフレームワークには、以下が必要です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネイティブUIマッピング </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネイティブUIパフォーマンス </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネイティブアプリケーションであるかのように、あらゆるOS APIを呼び出す100％の機能 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは私がFlutterで失敗し始めると思っていますが、すでに怒りのコメントを聞いています。</font><font style="vertical-align: inherit;">彼はすべてこれを行うことができます！」</font><font style="vertical-align: inherit;">実際、Qtはある程度、これらの基準に適合しています。</font><font style="vertical-align: inherit;">私はそれらの最初のものを強く疑いますが。</font><font style="vertical-align: inherit;">しかし、Qtの主な問題はネイティブUIの作成の難しさではなく、主な問題はC ++です。</font><font style="vertical-align: inherit;">次に、すでにプラスの労働者エンコーダーの唾から顔を拭いています。</font><font style="vertical-align: inherit;">プロはアナボリックステロイドのスイスナイフであり、プロではすべてを行うことができます。</font><font style="vertical-align: inherit;">しかし、私はフロントエンド開発者として、これをすべて必要とするわけではありません。</font><font style="vertical-align: inherit;">UIとI / Oで機能するシンプルで理解可能な言語が必要です。</font><font style="vertical-align: inherit;">したがって、上記の3つのポイントに追加されました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学びやすく、表現力豊かな言語 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロントエンド開発パラダイムによく適合するランタイム </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、モバイルアプリケーションを開発するための優れたクロスプラットフォームツールのいくつかのメトリックを強調表示したので、それらのそれぞれを確認し、Flutterでどのように実装されるかを確認できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネイティブUIマッピング</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ir/oi/wf/iroiwftbrxuuh_35cjdasl7sgkc.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前に発見したように、クロスプラットフォームフレームワークでUIを操作するには、2つの反対のアプローチがあります。</font><font style="vertical-align: inherit;">これは、各プラットフォームでのWebViewまたはネイティブUI要素呼び出しを使用したUIレンダリングです。</font><font style="vertical-align: inherit;">それぞれのアプローチには長所と短所があります。</font><font style="vertical-align: inherit;">ただし、開発者のニーズのすべてをカバーしているわけではありません。ネイティブUI +ネイティブパフォーマンスと区別がつかないように見えます。</font><font style="vertical-align: inherit;">Flutterはこれらすべてのニーズを頭でカバーします。</font><font style="vertical-align: inherit;">Flutterチームは、フレームワーク自体に「ネイティブ」要素を作成するために一定のリソースを費やしました。</font><font style="vertical-align: inherit;">Flutterのすべてのウィジェットは、3つの大きなカテゴリに分類されます。</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クパチーノウィジェット</font></font></a> </li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マテリアルウィジェット</font></font></a> </li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その他の一般的なウィジェット</font></font></a> </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クパチーノのセクションに移動すると、これらのウィジェットがネイティブiOS要素と区別がつかないことがわかります。</font><font style="vertical-align: inherit;">Flutterをしばらく使用してきた開発者として、私はそれらが区別できないことを確認できます。</font><font style="vertical-align: inherit;">たとえば、CupertinoDatePickerを使用すると、スクロールするときに、iPhoneのTaptic / Hapticエンジンからのフィードバックがネイティブアプリケーションのネイティブ要素であるかのように正確に感じられます。</font><font style="vertical-align: inherit;">もっと言うと、定期的にサイトrealtor.comのアプリケーションをiPhoneで開いて、最近まで、それがFlutter（またはネイティブではないもの）で記述されていることを知りませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutterを使用すると、2つのプラットフォーム用の「ネイティブ」ウィジェットを使用できるだけでなく、独自のウィジェットを作成することもでき、非常に簡単です。全体のパラダイムは、すべてがウィジェットの動作であることです。驚くほど複雑なUI要素とアニメーションを短時間で作成できます。 FlutterでUIを操作するアプローチの魅力と知恵は、</font><font style="vertical-align: inherit;">Habrに関する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事で</font><font style="vertical-align: inherit;">最近説明され</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">てい</font></a><font style="vertical-align: inherit;">ます。なぜならこれはすべて、プラットフォームごとにこのすべてを直接レンダリングする単一のグラフィックスエンジンで機能します（後で説明します）。計画どおりにすべてが表示されることを確認できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のかなり驚くべき点。</font><font style="vertical-align: inherit;">Flutterは、iOS 8およびAndroid API v16以降のプラットフォームをサポートしています。</font><font style="vertical-align: inherit;">UIレンダリングの観点からは、Flutterは特定のプラットフォームでどのAPIを使用できるかは関係ありません。</font><font style="vertical-align: inherit;">彼はCanvasで作業する機会があり、グラフィックスサブシステムと何らかのやり取りをしました。</font><font style="vertical-align: inherit;">つまり、AndroidXから最新のUI要素を、たとえば8歳の携帯電話で描画できるということです。</font><font style="vertical-align: inherit;">サポートされている最も古いプラットフォームでのこのアプローチのパフォーマンスの問題は確かにありますが、これは別の問題です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネイティブUIパフォーマンス</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/bs/as/ld/bsasld-hwweszsjqmucvaavtkyu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、UIレンダリングに対するFlutterのアプローチは、Ionicのようなハイブリッドアプリのアプローチに近いものです。</font><font style="vertical-align: inherit;">すべてのプラットフォームでUIをレンダリングするための単一のエンジンがあります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Graphics Libraryです。</font><font style="vertical-align: inherit;">Googleは2005年に製品としてSkiaを購入し、それをオープンソースプロジェクトに変えました。</font><font style="vertical-align: inherit;">これは少なくとも、これがかなり成熟した製品であることを示唆しています。</font><font style="vertical-align: inherit;">いくつかのSkiaパフォーマンス機能：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラフィック要素およびその他のデータ型の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">コピーオンライト</font></a></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能な限りスタックメモリを使用して断片化を減らす </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より良い並列化のためのスレッドセーフ</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
類似のライブラリ（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cairoを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">と比較して説得力のあるSkiaパフォーマンステストは見つかりませんでした</font><font style="vertical-align: inherit;">が、一部のテストでは、特定の状況を除いて、平均で50％のパフォーマンス向上が示されています。はい、これは特に重要ではありません。これらのテストはデスクトップでのOpenGLの使用に基づいているためです</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。Skiaは多くのGPUバックエンドとやり取りできます。以来</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、最近の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iOSでは、バージョン11以降、FlutterはデフォルトでバックエンドGPUとしてMetalを使用します。 Androidの場合、API 24以降-Vulkan。以下のバージョンの場合-OpenGL。これにより、生産性が明らかに向上します。他の「ハードウェア」プラットフォームでは、私が理解しているように、Skia / FlutterはOpenGLを使用しています。これにより、原則として、十分なグラフィックスパフォーマンスを備えたアプリケーションを作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webは際立っています。現時点では、UIレンダー全体がCanvas / HTMLバンドル上にあります。したがって、スキアはこのプロセスに一切関与していません。さらに、Dart VMはDOMと直接対話しません。最初にjsへの変換が行われます。これらすべてが生産性に最良の影響を与えるわけではなく、肉眼で直接目立つようになります。ただし、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">CanvasKit</font></a><font style="vertical-align: inherit;">を実装する作業</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">進行中</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flutterでは、SkiaをWebGL経由でブラウザーで使用できるようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、C＃プログラマは比較的長い間、SkiaSharpを使用してきました-Mono / .Net xのSkiaのラッパー。</font><font style="vertical-align: inherit;">そして、Xamarinコミュニティはこのlibを使用してカスタムUI要素を描画します。これは非常に人気のあるライブラリです。</font><font style="vertical-align: inherit;">これが勝利でなければ、私はそれが何であるかわかりません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API OSを呼び出す100％の機能</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutterには、「外の」世界との相互作用の2つの原則があります。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラットフォームチャネル</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外部関数インターフェース</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラットフォームチャネルを使用すると、メッセージングシステムを介してネイティブランタイム/ APIと対話できます。建築の観点から、これは次のように見ることができます。視覚的には、Flutterは単なるキャンバスであり、ネイティブアプリケーションの唯一のActivity / UIViewControllerで全画面表示されます。これは、ゲーム開発者（ゲームエンジン）を使用するアプローチとまったく同じです。それら。アプリケーションのiOS / Androidプロジェクトを開いて、他の機能をSwift / Kotlin /などに追加できます。問題は、ネイティブランタイムとDart VMがお互いについて何も認識しないことです（ネイティブランタイムは、アプリケーションにCanvasがあり、そこに何かが表示されることを知っているという事実に加えて）。さらに、たとえば、AndroidプロジェクトのMainActivity.ktファイルを開くと、次のように表示されます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span>: <span class="hljs-type">FlutterActivity</span></span>() {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<font></font>
    GeneratedPluginRegistrant.registerWith(<span class="hljs-keyword">this</span>)<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたのアクティビティがFlutterActivityから継承していることに気づきましたか？これにより、メッセージをFlutter / DartVMに直接送信するメカニズムを構成する機会が得られます。これを行うには、</font><i><font style="vertical-align: inherit;">configureFlutterEngine</font></i><font style="vertical-align: inherit;">メソッドをオーバーライドする必要があります。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、呼び出されたメソッドの名前と非同期メッセージを送信するためのチャネルの名前を決定します。すべて。これにより、ネイティブコードを記述してネイティブAPIを呼び出すことができます。同時に、ネイティブコードを作成する手間を省くプラグイン（パッケージ）がすでに多数あり、Dartのみを使用できます。これは素晴らしいです！ UIを個別に記述し、プラットフォームごとに1回、DartVMを使用してUI、I / Oを操作し、コンピューティングコンポーネントとして、ネイティブ機能を実装し、すべての機能の99％をカバーするプラグインを使用します。これで十分でない場合は、ネイティブで記述し、メッセージメカニズムを介して通信します。物語。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のメカニズムは、外部関数インターフェースまたはFFIです。これは、他の言語、主にCでのiteropeメカニズムのかなり一般的な用語です。 .Netの世界では、このメカニズムはP / Invokeと呼ばれ、JVMではJNIです。要するに、これはC / C ++ /などで書かれたライブラリと対話する機能です。たとえば、.Net Frameworkの時点では、C＃で記述されたソフトウェアはなく、ソフトウェアの大部分はC / C ++で記述されていたため、これらのライブラリを操作するためのメカニズムが必要でした。同じことがJVM、Pythonにも当てはまります。 FFIは、すべてのクロスプラットフォームモバイルフレームワークで使用されている方法です。さらに最近では、DartVMはCおよびJavaScriptとの相互運用のためにFFIのサポートも開始しました！この機能はベータ版のブランチにありますが、（ご自身の危険とリスクで）すでに使用可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のように、FlutterとDartVMは、ネイティブプラットフォームの可能性を100％以上カバーしています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">習得が容易で表現力豊かな言語</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は正直に認めますが、私にとってのダートは依然として世界で最高の言語ではありません。厳密な型システムはなく、パターンマッチングや不変性機能（まもなく提供される予定など）などの機能的なバンもありません。型システムについて、DartはもともとJSとして「典型的でない」言語として考えられていましたが、AOTコンパイルを通常にサポートするには、型システムをより厳密にする必要がありましたが、完全ではありません。それでも、メソッドのシグニチャー、つまり引数を操作するのは面倒です。これらの括弧はすべて</font></font><code>@required</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、何らかの理由</font><font style="vertical-align: inherit;">で怒ってい</font><font style="vertical-align: inherit;">ます。しかし、ダーツは非常に学びやすい言語です。構文上、これは私にとってJavaとJSのクロスです。ダーツはJSのように多くのことを許します。一般的に、これはかなり簡単に言語を学ぶことができ、私は大きな問題を経験していません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロントエンド開発パラダイムによく適合するランタイム</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Dart VMについて説明します。</font><font style="vertical-align: inherit;">一般的に、Dart VMには、GCからプロファイラー、天文台まで、多くのものが含まれています。</font><font style="vertical-align: inherit;">ここでは、GCと条件付きランタイムについてのみ説明します。</font><font style="vertical-align: inherit;">ランタイムがどのように機能するか、また</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何が構成されるかを理解することができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私はこの分野の専門家ではありませんが、私自身、Dart VMの利点のいくつかに触れました。</font><font style="vertical-align: inherit;">これに先立ち、私はDartと対応するVMが最初はJSの代わりとして開発されたことに注目します。これは、いわば、フロントエンド開発に焦点を当てていることを示唆しています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分離する</font></font></b><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_s/_n/kl/_s_nklwnaygqk8dey70z0yerdco.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dart VMには分離の概念があります。分離は、Dartコードから直接実行される1つのメインスレッドと、Dartコードからのオブジェクトが実際に割り当てられる分離されたヒープの組み合わせです。これは単純化された構造です。 Isolateには補助/システムスレッドもあります。Isolateに出入りできるOSスレッドなどがあります。スタックはIsolateにも存在しますが、ユーザーはそれを操作しません。ここで強調する必要がある主なことは、1つの分離を見ると、これはシングルスレッド環境であることです。デフォルトでは、Flutterは1つのデフォルトの分離を使用します。似ていませんか？はい、これはJS環境です。 JSと同様に、Dartプログラマーはマルチスレッドで作業できません。これは、本当の開発者の権利の混乱、単純化、および侵害であると誰かが思うかもしれませんが、UIを操作する場合、条件付きDOMで操作する場合（および画面上にポリゴンを描画しない場合）、その必要はありません。複数のスレッドで操作するのは危険です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではもちろん、私は狡猾でした。本当に望めば、個別に起動したIsolateを使用して並列タスクを実行</font><font style="vertical-align: inherit;">できます</font><font style="vertical-align: inherit;">（hello WebWorkers）。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、Flutterで追加のIsolateを使用する方法の詳細を確認できます。一般に、Isolatesは、その名前が示すように、お互いについて何も知りません。お互いへのリンクを保持せず、メッセージシステムを介して通信しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルスレッドアプローチに加えて、このスレッドのスタックを操作する機能なしに各分離に個別のヒープが割り当てられるという事実は、私の意見では非常に良いアプローチです。たとえば、膨大な数の行を操作するサーバーアプリケーションを作成していて、これらの行がヒープに格納されている場合、メモリが断片化され、GCジョブが追加されている間、これらの行は非常に高速で表示および非表示になり、これらの行または少なくとも一部を転送する方法スタック上のヒープはリソースを節約し、パフォーマンスを向上させます。例はまあまあですが、あなたは私を理解しています。ただし、UIを操作する場合、ライフタイムが短い可能性がある十分な数のUI要素（アニメーションなど）がある可能性がありますが、サーバーアプリケーションと比較すると、クライアントは1つだけで、処理されるデータの量はごくわずかです。スタックを直接操作する機能は単に不要です。私はボクシング/アンボクシングについて話しているのではありません。また、Dart VMのオブジェクトはかなり頻繁に割り当てられることに注意してください。 Dartメソッドから2倍の量を出力する場合でも、VMは個別にヒープにピースを割り当てます。 GCはこの負荷をどのように処理しますか？見てみましょう。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Young Space Scavenger（およびParallel Mark Sweep）</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
まず、すべてのGCと同様に、Dart VMのGCには世代があります。また、Dart VMのGCは、作業の原理に従って2つのコンポーネントに分割できます：Young Space ScavengerとParallel Mark Sweepです。最後の原則については詳しく説明しません。これはメモリクリーニングのかなり一般的な原則であり、ほとんどどこにでも実装されており、Flutterに特別な利点はありません。最初に興味があります。 Young Space Scavengerの動作原理は、次の図によく示されています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d3/yq/ik/d3yqikji__3j3f9zehdkrm4-t0a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの利点を明確に示しています。ヤングスペーススカベンジャーは、メモリ内の最新のオブジェクトに対して機能します。オブジェクトの最初/ 0世代については、多くの場合、これはFlutter / Dart VMの特徴であり、ほとんどの新しいオブジェクトの寿命は短くなっています。長く存続しない多くのオブジェクトを割り当てる状況では、メモリが非常に断片化する可能性があります。この場合、問題を解決するためにメモリまたはプロセッサ時間を支払う必要があります（このような方法では問題を解決すべきではありません）。 Young Space Scavengerはこの問題を解決します。上の画像を見ると、実際には6つのステップはありません。最初のメモリチャンクをクリアする必要はありません。デフォルトでは、2番目のオブジェクトにオブジェクトをコピーした後、このチャンクは空であると思います。まあ、生き残ったオブジェクトを2番目のチャンクにコピーするとき、フラグメント化を作成せずに、自然に1つずつ設定します。これにより、VMは多くの新しいオブジェクトを比較的低価格で割り当てることができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイドル時間GC</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ご存知のように、FlutterとDart VMのチームは密接に連携しており、この協力の結果はアイドル時間GCと見なすことができます。名前が示すとおり、これは何も起こらない瞬間のガベージコレクションです。 Flutterのコンテキストでは、アプリケーションが視覚的に何も変更しない現時点で。アニメーション、スクロール、ユーザー操作はありません。これらの瞬間に、FlutterはメッセージをDart VMに送信します。DartVMは現在、原則として、ガベージコレクションを開始する良いタイミングです。次に、ガベージコレクターは、作業を開始するかどうかを決定します。もちろん、この点でのガベージコレクションは、Parallel Mark Sweepを介して管理される古いオブジェクトに対して発生します。これは、それ自体がかなりコストのかかるプロセスであり、Idle Time GCは、この点で非常に便利なメカニズムです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のようなものがあります</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライド圧縮</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">圧縮ポインター</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">1つ目は、Parallel Mark Sweepを実行した後のメモリの最適化メカニズムです。</font><font style="vertical-align: inherit;">これもコストのかかるプロセスであり、アイドル時間がある場合にのみ機能します。</font><font style="vertical-align: inherit;">2番目のアプローチであるCompressed Pointersは、64ビットポインターを32ビットに圧縮し、メモリを節約します（これは、モバイル環境よりもサーバー環境の方がはるかに便利だと思います）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この行までお読みになった場合、おめでとうございます。次に記事を執筆した経験がないため、私は何とか記事をまとめたかどうかわかりません。そしてアイデアは単純です。Flutterでモバイルアプリケーションを作成すると、ネイティブであることがわかります。そしてボーナスの形で、あなたは非常にまともなアプリケーション開発速度を手に入れます。ホットリロード/再起動は、フロントエンドの開発に不可欠なものです。たとえば、ボタンの色を変更するたびに、ブラウザごとにプロジェクト全体をビルド/コンパイルする必要があるタイプセッターを想像できますか？もちろん違います。一般に、ホットリロード/再起動は別の記事に値します。しかし、私は気を取られました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutterでの私の経験から、このフレームワークは近い将来主流になると思います。</font><font style="vertical-align: inherit;">定期的に、私はFlutter開発者のポジションの面接を行い、半分のケースでは、Flutter開発者を探している企業には、実際にはモバイルネイティブ開発者のスタッフがいます。</font><font style="vertical-align: inherit;">彼らはインテリア/サイドプロジェクトでFlutterを試してみて、満足/喜び、ゆっくりFlutterに移行していました。</font><font style="vertical-align: inherit;">これは本当の勝利です。</font><font style="vertical-align: inherit;">Xamarinについて言えないことは、残念です。</font><font style="vertical-align: inherit;">多くの場合、Xamarinを選択するかどうかの決定は、スタックの残りの部分が.Netで記述されているためであり、これは滑りやすい勾配です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要約すると、新しいモバイルアプリケーションを開発するときにどちらにアプローチするかを考えている場合は、Flutterを見てください。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja501328/index.html">Visual Studioコードスペースの紹介：どこにいてもクラウド開発</a></li>
<li><a href="../ja501330/index.html">C ++のマイクロサービス。フィクションか現実か？</a></li>
<li><a href="../ja501332/index.html">会議は簡単です。毎日の練習の3つのヒント</a></li>
<li><a href="../ja501336/index.html">FOSSニュースNo. 15-2020年5月4〜10日の無料およびオープンソースニュースのレビュー</a></li>
<li><a href="../ja501338/index.html">Python仮想マシンの内部。パート1</a></li>
<li><a href="../ja501342/index.html">マイクロソフトオンライン認定-フィールドノート</a></li>
<li><a href="../ja501344/index.html">ダクト空調と組み合わせた給気換気（パート1-電気）</a></li>
<li><a href="../ja501346/index.html">メカニカルキーボードの概要Vortex Core RGB</a></li>
<li><a href="../ja501352/index.html">カフカが反撃</a></li>
<li><a href="../ja501354/index.html">コードスタイルの新しい見方</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>