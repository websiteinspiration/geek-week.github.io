<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤶🏽 📺 😶 Arend-HoTTベースの依存型言語（パート1） 💆🏾 📜 🕞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この投稿では、新しくリリースされたJetBrains言語とArend依存型について説明します（言語はGating Rentにちなんで名付けられました）。この言語は、過去数年にわたってJetBrains Researchによって開発されました。また、1年前のリポジトリはgithub.com/JetBr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Arend-HoTTベースの依存型言語（パート1）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/469569/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この投稿では、新しくリリースされたJetBrains言語とArend依存型について説明します（言語は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gating Rentに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ちなんで名付けられました</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">この言語は</font><font style="vertical-align: inherit;">、過去数年にわたって</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JetBrains Research</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって開発され</font><font style="vertical-align: inherit;">ました。</font><font style="vertical-align: inherit;">また、1年前のリポジトリは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/JetBrains</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">公開されてい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ましたが</font></a><font style="vertical-align: inherit;">、Arendの完全リリースは今年の7月にのみ行われました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arendが依存型に基づいた形式化された数学の既存のシステムとどのように異なり、ユーザーが現在どのような機能を利用できるかを説明します。この記事の読者は、一般的に依存型に精通しており、依存型に基づく言語の少なくとも1つ、Agda、Idris、Coq、またはLeanを聞いたことがあると想定しています。ただし、読者が高度なレベルで依存型を所有することは期待していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純さと具体性のために、Arendとホモトピーのタイプに関するストーリーには、リストをソートするための最も単純なアルゴリズムのArendの実装が伴います-この例でも、ArendとAgdaおよびCoqの違いを感じることができます。依存型に特化したハブレに関する記事はすでにいくつかあります。 Agdaでのリストのクイックソートソートの実装について考えてみましょう</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんな記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。より簡単な挿入ソートアルゴリズムを実装します。この場合、並べ替えアルゴリズム自体ではなく、Arend言語の構成に焦点を当てます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、アーレンドと依存型を持つ他の言語の主な違いは、それが基づいている論理理論です。 Arendは、最近発見された</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V. Voevodsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ホモトピー型理論（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HoTT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">そのまま使用してい</font><font style="vertical-align: inherit;">ます。より具体的には、Arendは、「型の区間理論」と呼ばれるHoTTのバリエーションに基づいています。 Coqはいわゆる帰納的構造の微積分（帰納的構造の微積分）に基づいているのに対し、AgdaとIdrisは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Martin-Löf型の型理論に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基づいていることを思い出してください</font><font style="vertical-align: inherit;">。 ArendがHoTTに基づいているという事実は、その構文構成と型チェックアルゴリズム（typcheker）の動作に大きな影響を与えます。この記事では、これらの機能について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語インフラストラクチャの状態を簡単に説明してみましょう。 Arendの場合、IDEAプラグインのリポジトリから直接インストールできるIntelliJ IDEAのプラグインがあります。原則として、プラグインをインストールするだけで、Arendを完全に使用できます。それでも、何もダウンロードしてインストールする必要はありません。型チェックに加えて、ArendプラグインはIDEAユーザーに馴染みのある機能を提供します。コードの強調表示と配置、さまざまなリファクタリングとヒントがあります。 Arendのコンソールバージョンを使用するオプションもあります。インストールプロセスの詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらを参照してください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事のコード例は、Arend標準ライブラリに基づいているため、ソースコードを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">リポジトリ</font></a><font style="vertical-align: inherit;">からダウンロードすることをお勧めし</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ダウンロード後、[プロジェクトのインポート]コマンドを使用して、ソースディレクトリをIDEAプロジェクトとしてインポートする必要があります。</font><font style="vertical-align: inherit;">アーレンドはすでにホモトピー型理論と環理論のいくつかのセクションを公式化することに成功しました。</font><font style="vertical-align: inherit;">たとえば、標準ライブラリには、必要なすべての環理論特性の証明とともに、有理数Qの環の実装が含まれています。</font><font style="vertical-align: inherit;">この記事で説明するポイントの多くがより詳細に説明されている詳細</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語ドキュメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もパブリックドメインにあります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電報チャネル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でArend開発者に直接質問でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. HoTT / Arendの概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ホモトピー型理論（または、略してHoTT）は、古典的なマルティン・ロフ型理論（MLTT、Agdaのベース）および帰納的構造計算（CIC、Coqのベース）とは異なるタイプの内包型理論であり、それとともに、ステートメントとセットには、より高いホモトピーレベルのいわゆるタイプが含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、HoTTの基礎を詳細に説明するという目標は設定していません。この理論を詳しく説明するには、本全体をもう一度説明する必要があります（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">この投稿を</font></a><font style="vertical-align: inherit;">参照）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">） HoTTの公理に基づく理論は、ある意味で、古典的なMartin-Löf型理論よりもはるかにエレガントで興味深いことに注意してください。したがって、以前に追加で仮定する必要があったいくつかの公理（たとえば、機能拡張性）が定理としてHoTTで証明されています。さらに、HoTTでは、内部で多次元ホモトピー球を定義し、その</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ホモトピー群の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数を数えることもでき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、HoTTのこれらの側面は主に数学者にとって興味深いものであり、この記事の目的は、プログラマーエンティティにこのような単純で親しみのあるものを順序付きリストとして表す例によって、HoTT ArendベースがAgda / MLTTおよびCoq / CICとどのように比較されるかを説明することです。</font><font style="vertical-align: inherit;">この記事を読むときは、HoTTを一種の内包型理論として発展させた公理学で扱うだけで十分です。これにより、ユニバースと平等を扱うときに便利になります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1依存型、カレー-ハワード対応、ユニバース</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
依存型を持つ言語は、リストや自然数などの通常のデータ型に加えて、パラメーター値に依存する型があるという点で、通常の関数型プログラミング言語とは異なります。そのようなタイプの最も単純な例は、指定された長さnのベクトル、または指定された深さdのバランスツリーです。これらのタイプのさらにいくつかの例を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで説明します。</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">カレー-ハワード通信を</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
思い出してください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロジックのステートメントを依存型として解釈できます。</font><font style="vertical-align: inherit;">この対応の主な考え方は、空の型は偽のステートメントに対応し、入力された型は真のステートメントに対応するということです。</font><font style="vertical-align: inherit;">タイプ要素は、対応する論理ステートメントの証拠と考えることができます。</font><font style="vertical-align: inherit;">たとえば、整数型の任意の要素は、整数が存在する（つまり、整数型が設定されている）ことの証拠と考えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプに対するさまざまな自然な構造は、さまざまな論理接続詞に対応します。</font></font><br>
<br>
<ul>
<li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプA×Bの積は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ペアA Bのペアのタイプと呼ばれることがあります。このタイプは、タイプAとBの両方が入力された場合にのみ入力されるため、この構造は論理的な「and」に対応します。</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプA + Bの合計</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。Haskellでは、このタイプはEither A Bと呼ばれます。このタイプは、タイプAまたはBのいずれかが入力された場合にのみ入力されるため、この構造は論理的な「or」に対応します。</font></font><br>
</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能タイプA→B。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このタイプの関数はすべて、Aの要素をBの要素に変換します。したがって、このような関数は、タイプAの要素の存在がタイプBの要素の存在を示唆する場合に正確に存在します。したがって、この構造は含意に対応します。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、タイプAと、タイプAの要素aによってパラメーター化されたタイプBのファミリーが与えられたと仮定します。依存タイプよりも複雑な構成の例を示します。</font></font><br>
<br>
<ul>
<li> <i>  </i> <b>Π</b>(a: A) (B a).        A → B  ,  B    A.   <b>Π</b>(a: A) (B a)    a  A    B a.  ,       ,  <i>  a </i>: A   B a. ,      ∀.      Arend   <code><b>\Pi</b> (x : A) -&gt; B a</code>,          - <code><b>\lam</b> (a : A) =&gt; f a.</code></li>
<li><i>   <b>Σ</b>(a: A) (B a).</i>        A×B,  B    A.  <b>Σ</b>(a: A) (B a)     <i></i>   a: A    B a.  ,      <code>∃</code>.     Arend  <code>\Sigma (a : A) (B a)</code>,         <i>()</i>  <code>(a, b)</code>.<br>
 </li>
<li><i> </i> a = a’,  a  a’ —     A.   ,  a  a’ ,   . ,        . </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点で、カリーとハワードの対応がより詳細に検討されている情報源を読者に紹介します（たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">講義</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や記事の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">コースを</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで参照してください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
型理論で考慮されるすべての式には、何らかの型が必要です。この理論の枠組みではタイプを表す式も考慮されるため、特定のタイプを割り当てる必要もあります。問題は、これはどのようなタイプであるべきかということです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頭に浮かぶ最初の素朴な決定は、すべてのタイプ</font></font><code>\Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><i><font style="vertical-align: inherit;">宇宙</font></i><font style="vertical-align: inherit;">と呼ばれる</font><font style="vertical-align: inherit;">正式なタイプを割り当てることです</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（一般にすべてのタイプが含まれているため、それと呼ばれます）。このユニバースを利用すると、上記のタイプの合計と積の構造は署名を受け取り、</font></font><code>\Type → \Type → \Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存積と依存合計のより複雑な構造は署名</font><font style="vertical-align: inherit;">を受け取り</font><font style="vertical-align: inherit;">ます</font></font><code><b>Π</b> (A : \Type) → ((A → \Type) → \Type)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点で、宇宙自体にどのようなタイプがあるべきかという疑問が生じ</font></font><code>\Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。宇宙の種類は、</font></font><code>\Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義により、それ自体</font></font><code>\Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジラールのパラドックスに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つながる</font><font style="vertical-align: inherit;">と言う素朴な試み</font><font style="vertical-align: inherit;">です。したがって、1つの宇宙</font></font><code>\Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ではなく</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、宇宙の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無限の</font><i><font style="vertical-align: inherit;">階層が考慮されます</font></i><font style="vertical-align: inherit;">。</font></font><code>\Type 1 &lt; \Type 2 &lt; …</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベルが自然数で番号付けされた</font><font style="vertical-align: inherit;">ユニバースのネストされたチェーン。ユニバース</font><font style="vertical-align: inherit;">のタイプは、</font></font><code>\Type i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義により、ユニバースです。</font></font><code>\Type (i+1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">上記のタイプの構成では、より</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複雑なシグネチャ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も導入する必要があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、任意の式が特定のタイプを持つように、タイプ理論のユニバースが必要です。</font><font style="vertical-align: inherit;">型理論のいくつかの種類では、ユニバースは別の目的で使用されます。種類の種類を区別するためです。</font><font style="vertical-align: inherit;">セットとステートメントはタイプの特殊なケースであることはすでに見てきました。</font><font style="vertical-align: inherit;">これは、ステートメントに個別のPropユニバースを、セットに個別のSet </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニバースの階層を導入することが理にかなっていることを示してい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これはまさに、誘導構造の計算で使用されるアプローチであり、Coqシステムの基礎となっている理論です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2最も単純な帰納型と再帰関数の例</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arendの最も単純な帰納的データ型の定義を考慮してください：ブール型、自然数型、および多態性リスト。 Arendはキーワードを使用して、新しい帰納型を導入します</font></font><code>\data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
上記の例からわかるように、キーワードの後</font><font style="vertical-align: inherit;">に、帰納型の名前とそのコンストラクターのリストを指定</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">必要</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">あります。同時に、データ型とコンストラクターにはいくつかのパラメーターがある場合があります。たとえば、上の例では、型</font><font style="vertical-align: inherit;">に1つのパラメータがあります</font><font style="vertical-align: inherit;">。リストコンストラクターに</font><font style="vertical-align: inherit;">はパラメーターがなく、コンストラクター：-：には2つのパラメーターがあります（1つは型</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">もう1つは</font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">）。ユニバース</font><font style="vertical-align: inherit;">は、セットであるタイプで構成されています（セットの定義は次のセクションで説明します）。キーワード</font></font><br>
<br>
<code>\data Empty --  ,   <br>
<br>
\data Bool <br>
 | true <br>
 | false<br>
<br>
\data Nat<br>
 | zero<br>
 | suc Nat<br>
<br>
\data List (A : \Set)<br>
 | nil<br>
 | \infixr 5 :-: A (List A)</code><br>
<br><font style="vertical-align: inherit;"></font><code>\data</code><font style="vertical-align: inherit;"></font><code> List</code><font style="vertical-align: inherit;"></font><code>A</code><font style="vertical-align: inherit;"></font><code>nil</code><font style="vertical-align: inherit;"></font><code>A</code><font style="vertical-align: inherit;"></font><code>List A</code><font style="vertical-align: inherit;"></font><code>\Set</code><font style="vertical-align: inherit;"></font><code>\infixr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたは、コンストラクタのための中置記法を使用することができます： - ：と、加えて、その演算子をアレンドパーサーを伝えます： - ：優先順位5と右結合操作で</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのキーワードは、バックスラッシュ文字（「\」）で始まり、ではアレンド、この実装は触発されラテックス。ただ、アレンドにおける字句のルールは非常にリベラルであることに注意してください：</font></font><code>Circle_HSpace, contrFibers=&gt;Equiv, suc/=0, zro_*-left</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でもと</font></font><code>n:Nat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これらすべてのリテラルはアレンドにおける有効な識別子の例です。最後の例は、Arendユーザー</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が識別子とコロン文字の間にスペースを置くことを覚えておく</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことの重要性を示しています</font><font style="vertical-align: inherit;">。 Arend識別子では、Unicode文字の使用は許可されていないことに注意してください（特に、キリル文字は使用できません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arendはキーワードを使用して関数を定義します。</font></font><code>\func</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この構文の構文は次のとおりです。キーワードの後</font></font><code>\func</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、関数の名前、パラメーター、戻り値の型を指定する必要があります。関数を定義する最後の要素はその本体です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の関数を計算する式を明示的に指定できる場合、token =&gt;を使用して関数の本体を示します。たとえば、型否定関数の定義を考えてみましょう。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func Not (A : \Type) : \Type =&gt; A -&gt; Empty</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の戻り値の型は、常に明示的に指定する必要はありません。上記の例では、Arendはタイプを個別に推論できるため</font><font style="vertical-align: inherit;">、括弧の後の</font></font><code>Not</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式「：</font></font><code>\Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」を</font><font style="vertical-align: inherit;">省略でき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの形式化された数学システムと同様に、ユーザーがuniverse </font></font><code>\Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">明示的な予測レベルを指定する必要はありません。予測レベル</font><font style="vertical-align: inherit;">を明示的に指定せずにユニバースが使用される定義は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポリモーフィック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と見なされます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、リストの長さを計算する関数を定義してみましょう。このような関数は、パターンマッチングによって簡単に決定できます。 Arendはこれにキーワードを使用します。</font></font><code>\elim</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。その後、比較を実行する変数を指定する必要があります（そのような変数が複数ある場合は、コンマで記述する必要があります）。すべての明示的なパラメーターに従って比較を実行する場合は</font></font><code>\elim</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、変数と一緒に省略できます。その後に、縦棒「|」で区切られた比較ポイントのブロックが続きます。このブロックの各項目は、フォームの表現です</font></font><code>«,    » =&gt; «»</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func length {A : \Set} (l : List A) : Nat<font></font>
 | nil =&gt; 0<font></font>
 | :-: x xs =&gt; suc (length xs)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例では、関数のパラメーターAが</font></font><code>length</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中括弧で囲まれています。 Arendのこれらの括弧は、暗黙の引数を示すために使用されます。関数の呼び出し時または型の使用時にユーザーが省略できる引数。アーレンドでは、パターンと一致するときにコンストラクターを指定するのにインフィックス表記法を使用できないため、サンプルの例ではプレフィックス表記法を使用しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Coq / Agdaと同様に、Arendではすべての機能が完了することが保証されている必要があります（つまり、Arendには終了チェックが存在します）。長さ関数の定義では、再帰呼び出しにより最初の明示的な引数が厳密に削減されるため、このチェックは成功します。このような削減が行われなかった場合、Arendはエラーメッセージを発行します。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func bad : Nat =&gt; bad<font></font>
<font></font>
[ERROR] Termination check failed for function 'bad'<font></font>
  In: bad</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arendは循環依存関係と、完了チェックも実行される相互再帰関数を許可します。</font><font style="vertical-align: inherit;">このチェックのアルゴリズムは、A。Abelの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基づいて実装されてい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">その中に、相互再帰関数が満たす必要のある条件のより詳細な説明があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3セットはステートメントとどのように異なりますか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプの例はセットとステートメントであると以前に書きました。</font><font style="vertical-align: inherit;">また、当社は、キーワードを使用</font></font><code>\Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、</font></font><code>\Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宇宙がアレンド参照します。</font><font style="vertical-align: inherit;">このセクションでは、アサーションは内包型理論の品種（MLTT、CIC、HOTT）の面でセットとは異なり以上説明しよう、と同時に、キー言葉の意味が何であるかを説明すること</font></font><code>\Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>\Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">及び</font></font><code>\Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アレンドでは。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古典的なマーティン・ロフ理論では、型をセットとステートメントに分離することはありません。特に、理論的には、累積ユニバースは1つしかありません（これは、AgdaではSet、IdrisではType、またはLeanではSortのいずれかで表されます）。このアプローチは最も単純ですが、欠点が明らかになる状況もあります。 「順序付きリスト」タイプを、リストとその順序付けの証明で構成される依存ペアとして実装しようとしているとします。その結果、「純粋な」MLTTのフレームワークでは、順序付けの証明の点で同時に同じ要素からなる順序付けられたリストの同等性を証明することができないことがわかります。このような平等性を持つことは非常に自然で望ましいことなので、それを証明することは不可能であることはMLTTの理論上の欠陥と見なすことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agdaでは、この問題はいわゆる非重要性の注釈を使用して部分的に解決されています（</font><font style="vertical-align: inherit;">リストの例が詳細に説明されて</font><font style="vertical-align: inherit;">いる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照してください</font><font style="vertical-align: inherit;">）。ただし、これらの注釈はMLTT理論からの構造ではなく、型に関する本格的な構造でもありません（関数の引数で使用されていない型注釈でマークすることは不可能です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CICでは、CICに基づいて</font></font><code>Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><font style="vertical-align: inherit;">ステートメントのユニバース）と</font><font style="vertical-align: inherit;">（セットのユニバース</font><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">2つの異なるユニバースが相互にネストされて</font><font style="vertical-align: inherit;">おり、エンベロープユニバースの階層に埋め込まれています</font></font><code>Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。主な違い</font></font><code>Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とは</font></font><code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、型の変数に属するということです</font></font><code>Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Coqにはいくつかの制限があります。たとえば、それらは計算に使用できず、それらのサンプルとの比較は他のステートメントの証拠の中でのみ可能です。一方、宇宙に属するタイプのすべての要素は、</font></font><code>Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取るに足らない証拠の公理で等しいです</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。Coq.Logic.ProofIrrelevance</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のステートメントを参照してください</font><font style="vertical-align: inherit;">。この公理を使用して、上記の順序付きリストの同等性を簡単に証明できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、Arend / HoTTのステートメントとユニバースへのアプローチを検討してください。主な違いは、HoTTが重要でない証拠の公理を省略していることです。つまり、HoTTには、ステートメントのすべての要素が等しいと仮定する特別な公理はありません。しかしHoTTでは、タイプ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">により、定義により</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、そのすべての要素が互いに等しいことが証明できる場合のステートメントです。タイプがステートメントである場合にtrueとなるタイプの述語を定義できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func isProp (A : \Type) =&gt; \Pi (a a' : A) -&gt; a = a'</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題が発生します。どの型がこの述語を満たしますか、つまり、ステートメントですか？これが空のタイプとシングルトンタイプに当てはまることを確認するのは簡単です。少なくとも2つの異なる要素がある型の場合、これは当てはまりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、必要なすべての論理接続詞をステートメントに対して定義する必要があります。セクション1.1で、型理論構築を使用してそれらをどのように決定できるかについてはすでに説明しました。ただし、次の問題があります</font></font><code>isProp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">入力したすべての操作でプロパティが保持されるわけではありません</font><font style="vertical-align: inherit;">。型の積と（依存する）関数型の構造はこのプロパティを保持しますが、型と依存ペアの合計の構造は保持しません。したがって、存在の分離と数量詞を使用することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題はHottに追加された新しい設計、いわゆる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命題切り捨て</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propositional truncation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">で解決できます</font><font style="vertical-align: inherit;">。この設計により、任意のタイプをステートメントに変換できます。これは正式な操作と見なすことができ、このタイプに属するすべての条件を等しくします。この操作は、Agdaからの無意味な注釈に多少似ていますが、それとは対照的に、署名付きの型に対する本格的な操作</font></font><code>\Type -&gt; \Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステートメントの最後の重要な例は、あるタイプの2つの要素の等価性です。一般的なケースでは、平等のタイプは</font></font><code>a = a'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステートメントである必要はないことがわかります。それが1つのタイプはセットと呼ばれます。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func isSet (A : \Type) =&gt; \Pi (a a' : A) -&gt; isProp (a = a')</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のプログラミング言語で見つかるすべての型は、この述語を満たします。つまり、それらの等価性はステートメントです。たとえば、これは、自然数、整数、集合の積、集合の和、集合に対する関数、集合のリスト、および集合から構成される他の帰納的データ型に当てはまります。つまり、このような使い慣れた構造だけに関心がある場合、この述部を満たさない任意の型について考えることはできません。 Coqにあるすべてのタイプは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セット</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ホモトピー型理論を扱いたい場合、集合ではない型が役立ちます。今のところ、</font><font style="vertical-align: inherit;">定義を含む標準ライブラリ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">読者に紹介するだけ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">です。</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n次元球</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -セットではないタイプの例</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アーレンドには特別なユニバースが</font></font><code>\Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり</font></font><code>\Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それぞれステートメントとセットで構成されています。タイプAがユニバース</font></font><code>\Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（または</font></font><code>\Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）に</font><font style="vertical-align: inherit;">含まれていることがわかっている場合</font><font style="vertical-align: inherit;">、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">プレリュードに</font></a><font style="vertical-align: inherit;">組み込まれた</font><font style="vertical-align: inherit;">公理</font><font style="vertical-align: inherit;">を使用して、Arendの</font><font style="vertical-align: inherit;">対応するプロパティ</font></font><code>isProp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（または</font></font><code>isSet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">の証明を</font><font style="vertical-align: inherit;">取得できます</font><font style="vertical-align: inherit;">（セクション2.3でこの公理の使用例を示します）。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>Path.inProp</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="plaintext hljs">\func inProp {A : \Prop} : \Pi (a a' : A) -&gt; a = a'</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプに関するすべての自然な構造がプロパティを保持するわけではないことはすでに述べました</font></font><code>isProp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえば、2つ以上のコンストラクターを持つ帰納的データ型は、それを満足させることはありません。</font><font style="vertical-align: inherit;">上記のように、</font><font style="vertical-align: inherit;">任意の型をステートメントに変換する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命題切り捨て</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用できます</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arendライブラリーでは、命題切り捨ての標準実装が呼び出され</font></font><code>Logic.TruncP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">Arendでは、タイプの合計を切り捨てるように、論理的な「or」のタイプを定義できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">\data \fixr 2 Or (A B : \Type) -- Sum of types; analogue of Coq's type "sum"<font></font>
 | inl A<font></font>
 | inr B<font></font>
<font></font>
\func \infixr 2 || (A B : \Type) =&gt; TruncP (sum A B) -- Logical “or”, analogue of Coq's type "\/"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アーレンドには、命題的に切り捨てられた帰納型を定義するためのもう1つのより簡単で便利な方法があります。</font><font style="vertical-align: inherit;">これを行うには</font></font><code>\truncated</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、データ型を定義する前</font><font style="vertical-align: inherit;">にキーワードを追加するだけ</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">たとえば、Arend標準ライブラリの論理「or」の定義は次のように与えられます。</font></font><br>
<br>
<pre><code class="plaintext hljs">\truncated \data \infixr 2 || (A B : \Type) : \Prop -- Logical “or”, analogue of Coq's type "\/"<font></font>
 | byLeft A<font></font>
 | byRight B</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命題的に切り捨てられた型を使用したその後の作業は</font></font><code>Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Coq </font><font style="vertical-align: inherit;">のユニバース</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">割り当てられた型のそれに似てい</font><font style="vertical-align: inherit;">ます。たとえば、タイプがステートメントである変数のパターンマッチングは、定義されている式のタイプ自体がステートメントである状況でのみ許可されます。したがって、</font></font><code>Or-to-||</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターンと照合</font><font style="vertical-align: inherit;">すること</font><font style="vertical-align: inherit;">によって</font><font style="vertical-align: inherit;">関数を定義することは常に簡単ですが、それと</font><font style="vertical-align: inherit;">逆の関数は、タイプA </font></font><code>`Or`</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bがステートメントである</font><font style="vertical-align: inherit;">場合のみです</font><font style="vertical-align: inherit;">（たとえば、タイプ</font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方がステートメントであり、相互に排他的</font><font style="vertical-align: inherit;">である場合、これは十分にまれ</font><font style="vertical-align: inherit;">です）。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func Or-to-|| {A B : \Prop} (a-or-b : A `Or` B) : A || B<font></font>
 | inl a =&gt; byLeft a<font></font>
 | inr b =&gt; byRight </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Coqにおけるユニバースのメカニズムの特殊性は、ある定義がuniverseに割り当てられている場合</font></font><code>Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、計算でそれを使用することは決して不可能であること</font><font style="vertical-align: inherit;">も思い出してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このため、Coq開発者自身</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命題構造</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">の</font></a><font style="vertical-align: inherit;">使用を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">推奨</font></a><font style="vertical-align: inherit;">して</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">いません</font></a><font style="vertical-align: inherit;">が、可能であれば、それらを集合の世界の類似体で置き換えることを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">お勧めし</font></a><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">Arendユニバースのメカニズムにはこの欠点はありません。つまり、特定の状況では、計算でステートメントを使用できます。</font><font style="vertical-align: inherit;">リストソートアルゴリズムの実装について説明するときに、このような状況の例を示します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4アーレンドのクラス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの目標は、最も単純なソートアルゴリズムを実装することなので、その前に、Arend標準ライブラリで利用可能な順序付けされたセットの実装を理解しておくと便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arendでは、クラスを使用して、数学的構造を定義する演算と公理をカプセル化し、継承を使用してこれらの構造間の関係を強調表示します。クラスは名前空間でもあり、その中に意味のある構成や理論を配置すると便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arendのすべての注文クラスが継承される基本クラス</font><font style="vertical-align: inherit;">は、ホストセットの</font></font><code>BaseSet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表記</font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（つまり、子孫クラスが含まれるセット）</font><font style="vertical-align: inherit;">以外のメンバーを含まない</font><font style="vertical-align: inherit;">クラスです。</font></font><code>BaseSet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまな操作がすでに導入されています）。</font><font style="vertical-align: inherit;">Arend標準ライブラリのこのクラスの定義を検討してください。</font></font><br>
<br>
<pre><code class="plaintext hljs">\class BaseSet (E : \Set) -- ,    </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の定義では、メディアは</font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスパラメータとして宣言されています。</font><font style="vertical-align: inherit;">上の質問に、</font></font><code>BaseSet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャリアEがクラスフィールドとして定義されている次の定義</font><font style="vertical-align: inherit;">との違いはあり</font><font style="vertical-align: inherit;">ますか？</font></font><br>
<br>
<pre><code class="plaintext hljs">\class BaseSet’  --     <font></font>
  | E : \Set</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少し意外な答えは、アーレンドの</font><font style="vertical-align: inherit;">パラメータークラス（暗黙的であっても）は実際に</font><i><font style="vertical-align: inherit;">は</font></i><font style="vertical-align: inherit;">彼のフィールド</font><font style="vertical-align: inherit;">であるという意味で、</font><font style="vertical-align: inherit;">アーレンド</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義された2つのオプションの間に</font><i><font style="vertical-align: inherit;">違いがない</font></i><font style="vertical-align: inherit;">ということ</font><font style="vertical-align: inherit;">です。したがって、どちらの実装</font><font style="vertical-align: inherit;">でも、式</font><font style="vertical-align: inherit;">を使用してフィールドEにアクセスできます。上記の定義</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">まだ</font><font style="vertical-align: inherit;">違いがありますが</font><font style="vertical-align: inherit;">、より微妙です。クラスインスタンスについて説明するときに、次のセクションで詳しく説明します。 。</font><font style="vertical-align: inherit;">
リストの並べ替えの動作が線形順序は、リスト内のオブジェクトの種類に指定されている場合にのみ意味がありますので、我々は最初の定義を考える</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">厳格半順序集合を</font></a><font style="vertical-align: inherit;">し、</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><code>BaseSet</code><font style="vertical-align: inherit;"></font><code>x.E</code><font style="vertical-align: inherit;"></font><code>BaseSet</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形順序セット。</font></font></a><br>
<br>
<pre><code class="plaintext hljs">\class StrictPoset \extends BaseSet {<font></font>
 | \infix 4 &lt; : E -&gt; E -&gt; \Prop<font></font>
 | &lt;-irreflexive (x : E) : Not (x &lt; x)<font></font>
 | &lt;-transitive (x y z : E) : x &lt; y -&gt; y &lt; z -&gt; x &lt; z<font></font>
}<font></font>
<font></font>
\class LinearOrder \extends StrictPoset {<font></font>
 | &lt;-comparison (x y z : E) : x &lt; z -&gt; x &lt; y || y &lt; z<font></font>
 | &lt;-connectedness (x y : E) : Not (x &lt; y) -&gt; Not (y &lt; x) -&gt; x = y<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
型理論の観点から見ると、Arendのクラスは、射影とコンストラクターの構文がより便利なシグマ型の類似体と考えることができます。</font><font style="vertical-align: inherit;">より正確には、任意のArendクラスはシグマタイプと見なすことができ、そのコンポーネントはすべてクラスの未実現フィールドです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィールドタイプがステートメントの場合、そのようなフィールドは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">プロパティはフィールドとは異なり、その実装は評価されません。</font><font style="vertical-align: inherit;">たとえば、StrictPosetフィールド</font></font><code>&lt;-irreflexive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font><code>&lt;-transitive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、プロパティとフィールド</font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、および</font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-はありません。</font><font style="vertical-align: inherit;">プロパティは、その実装（実際、これらのプロパティの証明）が大きいことが多いため、生産性が著しく向上しますが、通常、それらを計算しても意味がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並べ替えアルゴリズムを実装するには、順序付きセットを用意するだけでは不十分であり、この順序が決定可能であることも知っておく必要があります。</font><font style="vertical-align: inherit;">実際には、アーレンドは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建設的な数学を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用し</font><font style="vertical-align: inherit;">ています。つまり、その中のすべての述語が決定可能であるとは限りません。</font><font style="vertical-align: inherit;">特に、要素の等価性はどのタイプでも解決できません。</font><font style="vertical-align: inherit;">たとえば、これは整数には当てはまりますが、2つの関数が等しいかどうかをアルゴリズムで決定することが不可能であるため、整数に対する多くの関数には当てはまりません。</font><font style="vertical-align: inherit;">次のように</font><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定可能な同等性</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">持つセットのクラスを定義できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">\class DecSet \extends BaseSet<font></font>
 | decideEq (x y : E) : Dec (x = y)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
述語は</font><font style="vertical-align: inherit;">、決定可能である場合、</font><font style="vertical-align: inherit;">つまり</font><font style="vertical-align: inherit;">どちらか</font><font style="vertical-align: inherit;">または否定</font><font style="vertical-align: inherit;">がtrueで</font><font style="vertical-align: inherit;">ある場合にのみtrue </font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">になるように、ステートメントに対して定義され</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font><code>Dec E</code><font style="vertical-align: inherit;"></font><code>E</code><font style="vertical-align: inherit;"></font><code>E</code><font style="vertical-align: inherit;"></font><code>E</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="plaintext hljs">\data Dec (E : \Prop)<font></font>
  | yes E<font></font>
  | no (Not E)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、</font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュールの（単語decidableからの）</font><font style="vertical-align: inherit;">クラスを考え</font><font style="vertical-align: inherit;">ます</font></font><code>Order.LinearOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Decクラスは、解決可能な線形次数を実装し、特に、必要な公理を含みます</font></font><code>trichotomy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。つまり、型の2つの要素は、</font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次数&lt;に関して比較可能です。したがって、</font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaのComparableインターフェースの類似物と考えることができます。</font></font><br>
<br>
<pre><code class="plaintext hljs">\class Dec \extends LinearOrder, DecSet {<font></font>
 | trichotomy (x y : E) : (x = y) || (x &lt; y) || (y &lt; x)<font></font>
<font></font>
 | &lt;-comparison x y z x&lt;z =&gt; {?} --  <font></font>
 | &lt;-connectedness x y x/&lt;y y/&lt;x =&gt; {?}<font></font>
 | decideEq x y =&gt; {?}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラス名</font><font style="vertical-align: inherit;">は、</font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記</font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">すでに紹介したデータ型の</font><font style="vertical-align: inherit;">名前</font><font style="vertical-align: inherit;">と一致し</font><font style="vertical-align: inherit;">ますが、標準ライブラリのこのクラスは別の名前空間に含まれているため、指定の競合が実際に発生することはありません。</font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じ名前のデータ型ではなく、クラスを指定</font><font style="vertical-align: inherit;">するために使用</font><font style="vertical-align: inherit;">します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
線形次数の公理は、トリコトミーの公理に従います。したがって、クラス内のこれらの公理をすぐにチェックすることが論理的です</font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（上のリストでは、簡潔にするためにこの証拠を省略しています）。この例</font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、Arendで複数の継承が許可されていることを示しています（これは</font><font style="vertical-align: inherit;">andの</font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子孫でも</font></font><code>LinearOrder,</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あります</font></font><code>DecSet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。さらに、ダイヤモンドの継承も許可されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
菱形継承については、次の自然な制限があります。同じフィールドを2つの異なる祖先に実装できるのは、これらの実装が一致する場合（またはフィールドがプロパティである場合、この場合、実装は無視されるため）です。</font><font style="vertical-align: inherit;">モジュールで</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスを選択し、</font><font style="vertical-align: inherit;">IDEAにクラス階層を表示するように依頼すると（通常、これは[Ctrl] + [H]を押すことで行われます）、次の図のようなツリーが表示されます。</font><font style="vertical-align: inherit;">
この時点で、Arend標準ライブラリの完全なクラス階層を個別に調査することをお勧めします（このためには、IDEAにすべてのサブタイプを表示するよう依頼してください</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">ご覧のとおり、この階層は非常に広範です。</font></font><code>Dec</code><font style="vertical-align: inherit;"></font><code>Order.LinearOrder</code><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/webt/zu/sd/p3/zusdp3ojbuxbuhs11ffqppfjm04.png"><br>
<br><font style="vertical-align: inherit;"></font><code>BaseSet</code><font style="vertical-align: inherit;"></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.5クラスインスタンス、型キャスト、分類子フィールド、および演算子のオーバーロード。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、自然数の型Natの</font><font style="vertical-align: inherit;">厳密な順序クラスのインスタンスを作成してみましょう</font><font style="vertical-align: inherit;">。 Arendでは、すべてのフィールドが実装されているクラスに対してのみ、クラスのインスタンスを作成できます。クラスとシグマ型の間の類似性に従うと、すべてのフィールドが実装されるクラスは空のシグマ型（つまり、シングルトン型）に対応し、クラスのインスタンスの作成は、このシングルトン型の唯一の値を取得することに対応します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、その最も単純な特性である反反射性と推移性の順序と証拠を定義することから始めます。これらの特性は両方とも、サンプルと比較することにより、誘導によって容易に証明されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">data \infix 4 &lt; (a b : Nat) \with<font></font>
   | zero, suc _ =&gt; zero&lt;suc_<font></font>
   | suc a, suc b =&gt; suc&lt;suc (a &lt; b)<font></font>
<font></font>
 \lemma irreflexivity (x : Nat) (p : x &lt; x) : Empty<font></font>
   | suc a, suc&lt;suc a&lt;a =&gt; irreflexivity a a&lt;a<font></font>
<font></font>
 \lemma transitivity (x y z : Nat) (p : x &lt; y) (q : y &lt; z) : x &lt; z<font></font>
   | zero, suc y', suc z', zero&lt;suc_, suc&lt;suc y'&lt;z'  =&gt; zero&lt;suc_<font></font>
   | suc x', suc y', suc z', suc&lt;suc x'&lt;y', suc&lt;suc y'&lt;z' =&gt; suc&lt;suc (transitivity x' y' z' x'&lt;y' y'&lt;z')</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例では、キーワードの代わりに</font></font><code>\func</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用しました</font></font><code>\lemma</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。補題は、クラスプロパティがクラスフィールドに関連するのと同じ方法で関数に関連します。つまり、それらの式は評価されないため、パフォーマンスが向上します。クラスプロパティと同様に、キーワード</font></font><code>\lemma</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、関数の結果のタイプがuniverseに属している場合にのみ使用できます</font></font><code>\Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例</font></font><code>x'&lt;y'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-サンプル変数の明確な名前</font></font><code>x' &lt; y'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、不平等の証明です</font><font style="vertical-align: inherit;">。サンプル変数には同様の名前を引き続き使用します（つまり、ステートメントのスペースなしでレコードと一致する名前、これらの変数の証明）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、クラスのインスタンスを作成できます</font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Arendには、このためのいくつかの異なる構文オプションがあります。クラスをインスタンス化する最初の方法は、</font></font><code>\new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意の式内で</font><font style="vertical-align: inherit;">キーワードを使用する</font><font style="vertical-align: inherit;">ことです。この場合、「匿名クラスインスタンス」が作成されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func NatOrder =&gt; \new StrictPoset {<font></font>
 | E =&gt; Nat<font></font>
 | &lt; =&gt; &lt;<font></font>
 | &lt;-irreflexive =&gt; irreflexivity<font></font>
 | &lt;-transitive =&gt; transitivity<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
式</font></font><code>StrictPoset { … }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はキーワードなしでも意味があります</font></font><code>\new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この場合、それは匿名拡張クラスを示し</font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。匿名の拡張クラスにすべてのフィールドを実装する必要はありませんが、前述のとおり、不完全に実装されたクラスには操作</font></font><code>\new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">適用</font><font style="vertical-align: inherit;">できません。ビュー式</font></font><code>\new C { … }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にはタイプがあり</font></font><code>C { … }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。このタイプはCの子孫であるため、タイプCも持っています。したがって、上記の例では、それ</font></font><code>NatOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がクラスのインスタンスである</font><font style="vertical-align: inherit;">ことは事実です</font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスフィールドはクラスパラメータと同じです。特に、内部表現の観点からは、expression </font></font><code>StrictPoset Nat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">expression </font><font style="vertical-align: inherit;">と同じ</font></font><code>StrictPoset { | E =&gt; Nat }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。私たちは、関数の型を示すことができることを注記</font></font><code>NatOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として</font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そしてこれは通常のサブタイプの規則のため、間違いとは見なされません（親の代わりにクラスの子孫を使用できます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスのインスタンスを定義する別の方法</font><font style="vertical-align: inherit;">は、関数ヘッダーで</font></font><code>NatOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーワードを使用することです</font></font><code>\cowith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（この場合、関数のタイプを指定し、何らかのクラスにする必要があります）。</font></font><br>
<br>
<pre><code class="plaintext hljs">\func NatOrder : StrictPoset \cowith {<font></font>
 | E =&gt; Nat<font></font>
 | &lt; =&gt; &lt;<font></font>
 | &lt;-irreflexive =&gt; irreflexivity<font></font>
 | &lt;-transitive =&gt; transitivity<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、キーワードを使用してクラスのインスタンスを定義する別の方法を見てみましょう。 </font></font><code>\instance.</code> <br>
<br>
<pre><code class="plaintext hljs">\instance NatOrder : StrictPoset {<font></font>
 | E =&gt; Nat<font></font>
 | &lt; =&gt; &lt;<font></font>
 | &lt;-irreflexive =&gt; irreflexivity<font></font>
 | &lt;-transitive =&gt; transitivity<font></font>
}</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arendは、Haskell言語の場合と同様に、クラスインスタンスを見つけるためのアルゴリズムを実装しています。</font></font><code>NatOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーワードによる</font><font style="vertical-align: inherit;">関数の実装は、</font><font style="vertical-align: inherit;">による</font><font style="vertical-align: inherit;">実装</font><font style="vertical-align: inherit;">と</font></font><code>\instance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">似ており</font></font><code>\cowith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、クラスのインスタンスの検索中にこの関数が使用されるという点でのみ異なります</font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（以下でインスタンスについて説明します）。</font><font style="vertical-align: inherit;">標準ライブラリの</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装</font></font><code>BaseSet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、キャリアセットEはクラスパラメータとして（フィールドとしてではなく）定義されている</font><font style="vertical-align: inherit;">ことを思い出してください。</font><font style="vertical-align: inherit;">最後のセクションでは、そのような実装には、クラスフィールドとしてのEの実装とは多少の違いがあると述べました。次に、この違いについて詳しく説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arendの内部実装の観点から見たクラスパラメータは、クラスフィールドと同じです。</font><font style="vertical-align: inherit;">ただし、アーレンドは、最初の明示的なクラス引数がデフォルトでいわゆるクラスフィールドに変換されず、いわゆる分類子フィールドに変換されることに同意しています（この規則は、「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分類子フィールド</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」がキーワード</font></font><code>\classifying \field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">ユーザーによって明示的に選択されていない場合に機能し、</font><font style="vertical-align: inherit;">Arendのクラスは1つの分類子フィールドのみ）。</font><font style="vertical-align: inherit;">分類クラスフィールドには、次のプロパティがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arendは、対応するプロジェクターを参照することにより、クラスのインスタンスをその分類子のタイプに暗黙的にキャストできます。</font><font style="vertical-align: inherit;">たとえば</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、型</font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がある場合、式は</font></font><code>List X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全に正しく、式の値と一致します</font></font><code>List X.E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
</li>
<li>Arend          .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、インスタンスがまったく必要な理由を説明しましょう。</font><font style="vertical-align: inherit;">たとえば、自然数</font><font style="vertical-align: inherit;">や整数</font><font style="vertical-align: inherit;">など、さまざまなデータ型の</font></font><code>\instance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスのいくつかのインスタンスの</font><font style="vertical-align: inherit;">キーワードを使用して、構築を通じて実装した</font><font style="vertical-align: inherit;">とします</font><font style="vertical-align: inherit;">（構築されたインスタンス</font><font style="vertical-align: inherit;">および</font><font style="vertical-align: inherit;">を呼び出します</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">x、yが自然数の場合とx、yが整数の場合の両方で、</font><font style="vertical-align: inherit;">
表記法を使用</font><font style="vertical-align: inherit;">して順序を示す</font><font style="vertical-align: inherit;">ことができるように</font><font style="vertical-align: inherit;">なりました。前者の場合、Arendは自動的に意味を判断し、後者の場合は</font><font style="vertical-align: inherit;">-を</font><font style="vertical-align: inherit;">判断し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">
ここで、インスタンス検索アルゴリズムのしくみについて詳しく説明します。アーレンドは、&lt;フィールドがクラスに入力されていると判断します</font></font><code>StrictPoset</code><font style="vertical-align: inherit;"></font><code>Nat</code><font style="vertical-align: inherit;"></font><code>Int</code><font style="vertical-align: inherit;"></font><code>NatOrder</code><font style="vertical-align: inherit;"></font><code>IntOrder</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>x &lt; y</code><font style="vertical-align: inherit;"></font><code>NatOrder.&lt;</code><font style="vertical-align: inherit;"></font><code>IntOrder.&lt;</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、フィールドEは分類フィールドとして宣言されています。次に、Arendは式の引数のタイプを計算し</font><font style="vertical-align: inherit;">、分類フィールドEが目的のタイプ</font></font><code>x&lt;y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であるクラス</font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（またはその子孫）</font><font style="vertical-align: inherit;">のインスタンスを現在のスコープで見つけようとします</font><font style="vertical-align: inherit;">。そのようなインスタンスが見つかった場合、フィールドの実装は</font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このインスタンスから取得されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスからその分類フィールドの型への自動変換は、Arendのより一般的な型変換メカニズムの特殊なケースにすぎないことに注意してください。あるタイプを別のタイプに暗黙的にキャストできるようにするには、</font><font style="vertical-align: inherit;">この定義の</font><i><font style="vertical-align: inherit;">関連モジュール</font></i></font><code>\use \coerce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内で</font><font style="vertical-align: inherit;">特別な設計を使用する必要があり</font><font style="vertical-align: inherit;">ます。 Arendでは、各定義にいわゆる</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">関連モジュールがあります。</font></a></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-さまざまな補助構造を配置するために使用される名前空間。関連する定義モジュールに他の定義を追加するには、キーワードを使用し</font></font><code>\where</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
型変換メカニズムを使用する最も単純な例を考えてみましょう。この関数</font></font><code>fromNat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、自然数を暗黙的に整数に変換するために使用されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">\data Int<font></font>
 | pos Nat<font></font>
 | neg Nat \with { zero =&gt; pos zero }<font></font>
 \where {<font></font>
   \use \coerce fromNat (n : Nat) =&gt; pos n<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
宣言の構文は</font></font><code>\use \coerce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">似</font></font><code>\func</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ていますが、この関数は明示的な引数を1つだけ持つ必要があるという違いがあります。</font><font style="vertical-align: inherit;">この場合、結果の型または関数の単一の引数の型のいずれかが、特定のモジュールが関連付けられている定義と一致している必要があります（もちろん、これは、クラスまたは帰納的データ型の定義に関連付けられているモジュールでのみ可能です）。</font><font style="vertical-align: inherit;">JetBrains Researchの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">HoTT GroupおよびDependent Typesの</font></a><font style="vertical-align: inherit;">上級研究員</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">である</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Sergey Sinchuk</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
による投稿</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja469551/index.html">ビデオカードを備えたVDS-私たちは倒錯についてよく知っています</a></li>
<li><a href="../ja469555/index.html">ブロードキャスト：モスクワKubernetesミートアップ＃6</a></li>
<li><a href="../ja469557/index.html">Generic Recycler Viewまたは定型コードを作成しない方法</a></li>
<li><a href="../ja469561/index.html">整数平方根の計算</a></li>
<li><a href="../ja469567/index.html">背景：2週間のテスト後のiPhone 11、11 Pro、および新しいApple Watchの詳細</a></li>
<li><a href="../ja469573/index.html">Linux Piter 2019：大規模なLinuxカンファレンスのゲストを待っているものと、見逃してはならない理由</a></li>
<li><a href="../ja469575/index.html">スリープモードを再プログラムする方法：毎朝30日間、目で明るい緑色のライトを照らしました</a></li>
<li><a href="../ja469577/index.html">ディスクフォレンジック、メモリフォレンジック、ログフォレンジック。ボラティリティフレームワークと剖検。r0ot-miによる問題解決。パート1</a></li>
<li><a href="../ja469581/index.html">ピカブ効果分析</a></li>
<li><a href="../ja469583/index.html">OpenVPNおよびActive Directory（ユーザー証明書なしのKerberos）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>