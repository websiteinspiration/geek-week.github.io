<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👥 👦🏻 🦂 通过类似于梯度的下降来选择k近邻（井或其他超参数）的特征重要性 👩🏿‍🚀 ❗️ 😚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="通过对最简单的机器学习任务进行实验，我发现在相当宽的范围内同时选择18个超参数会很有趣。就我而言，一切是如此简单，以至于可以用蛮横的计算机功能来完成任务。
 
 学习一些东西时，发明某种自行车会非常有趣。有时事实证明确实提出了一些新建议。有时候，事实证明一切都是在我之前发明的。但是，即使我只是重复走...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>通过类似于梯度的下降来选择k近邻（井或其他超参数）的特征重要性</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496484/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/eg/qm/x6/egqmx63h8mgrbxfytg9nmuaby-g.gif" alt="真正的废话不仅可以解决不可能的事情，而且可以作为警告的例子"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过对最简单的机器学习任务进行实验，我发现在相当宽的范围内同时选择18个超参数会很有趣。就我而言，一切是如此简单，以至于可以用蛮横的计算机功能来完成任务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
学习一些东西时，发明某种自行车会非常有趣。有时事实证明确实提出了一些新建议。有时候，事实证明一切都是在我之前发明的。但是，即使我只是重复走在我之前的那条路，作为奖励，我也常常了解它们的功能和内部局限性的算法的基本机制。我邀请你到。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
坦率地说，在Python和DS中，我是一个初学者，我根据我的旧编程习惯做了很多可以在一个团队中实现的事情，而Python则通过降低速度（不是有时而是按数量级）来惩罚。</font><font style="vertical-align: inherit;">因此，我将所有代码上传到存储库。</font><font style="vertical-align: inherit;">如果您知道如何更有效地实施它-请勿害羞，在此处进行编辑或在评论中写下。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/kraidiky/GDforHyperparameters</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
我相信，那些已经很酷的数据学家并且已经尝试了这一辈子的一切，对于学习过程的可视化很有趣，这不仅适用于此任务。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题的提法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ODS.ai提供了如此出色的DS课程，还有第三堂课《</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分类，决策树和最近邻居的方法》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在那里，它在极其简单且可能是合成数据上显示出，最简单的决策树如何实现94.5％的准确度，而k个最近邻居的相同极其简单的方法无需任何预处理即可提供89％的准确性。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">导入和加载数据</font></font></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<font></font>
%matplotlib inline<font></font>
<span class="hljs-keyword">import</span> warnings<font></font>
warnings.filterwarnings(<span class="hljs-string">'ignore'</span>)<font></font>
<font></font>
df = pd.read_csv(<span class="hljs-string">'data/telecom_churn.csv'</span>)<font></font>
df[<span class="hljs-string">'Voice mail plan'</span>] = pd.factorize(df[<span class="hljs-string">'Voice mail plan'</span>])[<span class="hljs-number">0</span>]<font></font>
df[<span class="hljs-string">'International plan'</span>] = pd.factorize(df[<span class="hljs-string">'International plan'</span>])[<span class="hljs-number">0</span>]<font></font>
df[<span class="hljs-string">'Churn'</span>] = df[<span class="hljs-string">'Churn'</span>].astype(<span class="hljs-string">'int32'</span>)<font></font>
states = df[<span class="hljs-string">'State'</span>]<font></font>
y = df[<span class="hljs-string">'Churn'</span>]<font></font>
df.drop([<span class="hljs-string">'State'</span>,<span class="hljs-string">'Churn'</span>], axis = <span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)<font></font>
df.head()<font></font>
</code></pre></div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比较木材与knn</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split, StratifiedKFold
<span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier
<span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV, cross_val_score
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<font></font>
<font></font>
X_train, X_holdout, y_train, y_holdout = train_test_split(df.values, y, test_size=<span class="hljs-number">0.3</span>,<font></font>
random_state=<span class="hljs-number">17</span>)<font></font>
<font></font>
tree = DecisionTreeClassifier(random_state=<span class="hljs-number">17</span>, max_depth=<span class="hljs-number">5</span>)<font></font>
knn = KNeighborsClassifier(n_neighbors=<span class="hljs-number">10</span>)<font></font>
<font></font>
tree_params = {<span class="hljs-string">'max_depth'</span>: range(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>), <span class="hljs-string">'max_features'</span>: range(<span class="hljs-number">4</span>,<span class="hljs-number">19</span>)}<font></font>
tree_grid = GridSearchCV(tree, tree_params, cv=<span class="hljs-number">10</span>, n_jobs=<span class="hljs-number">-1</span>, verbose=<span class="hljs-literal">False</span>)<font></font>
tree_grid.fit(X_train, y_train)<font></font>
tree_grid.best_params_, tree_grid.best_score_, accuracy_score(y_holdout, tree_grid.predict(X_holdout))<font></font>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（{'max_depth'：6，6，'max_features'：16}，0.944706386626661，0.945）</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于knn一样</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time
<span class="hljs-keyword">from</span> sklearn.pipeline <span class="hljs-keyword">import</span> Pipeline
<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<font></font>
<font></font>
knn_pipe = Pipeline([(<span class="hljs-string">'scaler'</span>, StandardScaler()), (<span class="hljs-string">'knn'</span>, KNeighborsClassifier(n_jobs=<span class="hljs-number">-1</span>))])<font></font>
knn_params = {<span class="hljs-string">'knn__n_neighbors'</span>: range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)}<font></font>
knn_grid = GridSearchCV(knn_pipe, knn_params, cv=<span class="hljs-number">10</span>, n_jobs=<span class="hljs-number">-1</span>, verbose=<span class="hljs-literal">False</span>)<font></font>
<font></font>
knn_grid.fit(X_train, y_train)<font></font>
knn_grid.best_params_, knn_grid.best_score_, accuracy_score(y_holdout, knn_grid.predict(X_holdout))<font></font>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（{'knn__n_neighbors'：9}，0.8868409772824689，0.891）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这一点上，我为显然不诚实的knn感到遗憾，因为我们没有使用该指标。</font><font style="vertical-align: inherit;">我没有想到，我从树中取出了feature_importances_并将其输入标准化。</font><font style="vertical-align: inherit;">因此，特征越重要，点之间的距离就越大。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将数据归一化为功能的重要性</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time<font></font>
feature_importances = pd.DataFrame({<span class="hljs-string">'features'</span>: df.columns, <span class="hljs-string">'importance'</span>:tree_grid.best_estimator_.feature_importances_})<font></font>
print(feature_importances.sort_values(by=[<span class="hljs-string">'importance'</span>], inplace=<span class="hljs-literal">False</span>, ascending=<span class="hljs-literal">False</span>))<font></font>
<font></font>
scaler = StandardScaler().fit(X_train)<font></font>
X_train_transformed = scaler.transform(X_train)<font></font>
X_train_transformed = X_train_transformed * np.array(feature_importances[<span class="hljs-string">'importance'</span>])<font></font>
<font></font>
X_holdout_transformed = scaler.transform(X_holdout)<font></font>
X_holdout_transformed = X_holdout_transformed * np.array(feature_importances[<span class="hljs-string">'importance'</span>])<font></font>
<font></font>
knn_grid = GridSearchCV(KNeighborsClassifier(n_jobs=<span class="hljs-number">-1</span>), {<span class="hljs-string">'n_neighbors'</span>: range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>)}, cv=<span class="hljs-number">5</span>, n_jobs=<span class="hljs-number">-1</span>, verbose=<span class="hljs-literal">False</span>)<font></font>
knn_grid.fit(X_train_transformed, y_train)<font></font>
<span class="hljs-keyword">print</span> (knn_grid.best_params_, knn_grid.best_score_, accuracy_score(y_holdout, knn_grid.predict(X_holdout_transformed)))
</code></pre></div></div><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总分钟</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.270386</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户服务电话</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.147185</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前夜总分钟</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.135475</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">国际计划</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.097249</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十六</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总国际费用</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.091671</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十五</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">国际通话总数</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">09.090008</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vmail消息数量</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.050646</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平安夜总费用</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.038593</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全天收费</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.026422</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语音邮件计划</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.017068</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十一</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">晚上总时间</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.014185</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十三</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每晚总费用</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.005742</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">夜间通话总数</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.005502</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前夜总通话次数</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.003614</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">日间通话总数</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.002246</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总国际分钟</font></font></td>
<td>0.002009</td>
</tr>
<tr>
<td>0</td>
<td>Account length</td>
<td>0.001998</td>
</tr>
<tr>
<td>1</td>
<td>Area code</td>
<td>0.000000</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{'n_neighbors'：5} 0.909129875696528 0.913 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这棵树与knn共享了一点知识，现在我们看到了91％，与香草树的94.5％相差不远。然后我想到一个主意。但是，实际上，我们如何需要对输入进行标准化以使knn显示最佳结果？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们将在脑海中估计现在多少将被视为“前额”。我们为每个参数设定18个参数，例如，对数刻度中的因子可能要进行10个步骤。我们得到10e18选项。一个具有所有可能的奇数个邻居的选项小于10，而交叉验证也为10，我认为约为1.5秒。事实证明，这是420亿年。也许不得不放弃晚上计算的想法。 :)在这里附近的某个地方，我想：“嘿！所以我会做一辆会飞的自行车！”</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">梯度搜索</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，此任务很可能只有一个可用的最大值。</font><font style="vertical-align: inherit;">好吧，这当然不是一个取得好成绩的整个领域，但是它们几乎是相似的。</font><font style="vertical-align: inherit;">因此，我们可以沿着梯度走，找到最合适的点。</font><font style="vertical-align: inherit;">首先想到的是推广遗传算法，但是在这里自适应地形似乎并不太紧密，这会有点过大。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将尝试手动开始。</font><font style="vertical-align: inherit;">要将因素推为超参数，我需要处理定标器。</font><font style="vertical-align: inherit;">在上一个示例中，如本课程中一样，我使用了StandartScaler，它使训练样本平均居中，并使sigma =1。为了在管道中很好地缩放它，必须使超参数更加复杂。</font><font style="vertical-align: inherit;">我开始在sklearn.preprocessing中的转换器中搜索适合我的情况的东西，但没有找到任何东西。</font><font style="vertical-align: inherit;">因此，我试图通过在其上悬挂其他捆绑因素来继承StandartScaler。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于标称化的类，然后按比例乘以与sklearn流水线稍微兼容</font></font></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn.base <span class="hljs-keyword">import</span> TransformerMixin
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardAndPoorScaler</span>(<span class="hljs-params">StandardScaler, TransformerMixin</span>):</span>
    <span class="hljs-comment">#normalization = None</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, copy=True, with_mean=True, with_std=True, normalization = None</span>):</span>
        <span class="hljs-comment">#print("new StandardAndPoorScaler(normalization=", normalization.shape if normalization is not None else normalization, ") // ", type(self))</span><font></font>
        self.normalization = normalization<font></font>
        super().__init__(copy, with_mean, with_std)<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span>(<span class="hljs-params">self, X, y=None</span>):</span>
        <span class="hljs-comment">#print(type(self),".fit(",X.shape, ",", y.shape if y is not None else "&lt;null&gt;",")")</span><font></font>
        super().fit(X, y)<font></font>
        <span class="hljs-keyword">return</span> self
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partial_fit</span>(<span class="hljs-params">self, X, y=None</span>):</span>
        <span class="hljs-comment">#print(type(self),".partial_fit(",X.shape, ",", y.shape if y is not None else "&lt;null&gt;)")</span><font></font>
        super().partial_fit(X, y)<font></font>
        <span class="hljs-keyword">if</span> self.normalization <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
            self.normalization = np.ones((X.shape[<span class="hljs-number">1</span>]))
        <span class="hljs-keyword">elif</span> type(self.normalization) != np.ndarray:<font></font>
            self.normalization = np.array(self.normalization)<font></font>
        <span class="hljs-keyword">if</span> X.shape[<span class="hljs-number">1</span>] != self.normalization.shape[<span class="hljs-number">0</span>]:
            <span class="hljs-keyword">raise</span> <span class="hljs-string">"X.shape[1]="</span>+X.shape[<span class="hljs-number">1</span>]+<span class="hljs-string">" in equal self.scale.shape[0]="</span>+self.normalization.shape[<span class="hljs-number">0</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform</span>(<span class="hljs-params">self, X, copy=None</span>):</span>
        <span class="hljs-comment">#print(type(self),".transform(",X.shape,",",copy,").self.normalization", self.normalization)</span><font></font>
        Xresult = super().transform(X, copy)<font></font>
        Xresult *= self.normalization<font></font>
        <span class="hljs-keyword">return</span> Xresult
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_reset</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-comment">#print(type(self),"._reset()")</span><font></font>
        super()._reset()<font></font>
    <font></font>
scaler = StandardAndPoorScaler(normalization = feature_importances[<span class="hljs-string">'importance'</span>])<font></font>
scaler.fit(X = X_train, y = <span class="hljs-literal">None</span>)<font></font>
print(scaler.normalization)<font></font>
</code></pre></div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尝试申请该课程</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time<font></font>
knn_pipe = Pipeline([(<span class="hljs-string">'scaler'</span>, StandardAndPoorScaler()), (<span class="hljs-string">'knn'</span>, KNeighborsClassifier(n_jobs=<span class="hljs-number">-1</span>))])<font></font>
<font></font>
knn_params = {<span class="hljs-string">'knn__n_neighbors'</span>: range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>), <span class="hljs-string">'scaler__normalization'</span>: [feature_importances[<span class="hljs-string">'importance'</span>]]}<font></font>
knn_grid = GridSearchCV(knn_pipe, knn_params, cv=<span class="hljs-number">5</span>, n_jobs=<span class="hljs-number">-1</span>, verbose=<span class="hljs-literal">False</span>)<font></font>
<font></font>
knn_grid.fit(X_train, y_train)<font></font>
knn_grid.best_params_, knn_grid.best_score_, accuracy_score(y_holdout, knn_grid.predict(X_holdout))<font></font>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（{'knn__n_neighbors'：5，'scaler__normalization'：名称：重要性，dtype：float64}，0.909558508358337，0.913）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果与我的预期略有不同。好吧，也就是说，原则上一切正常。为了了解这一点，我不得不在三个小时内从头开始重制所有此类内容，然后才意识到打印不打印并不是因为sklearn制作错误，而是因为GridSearchCV在主流中创建了克隆，但在其他线程中进行配置和训练。您在其他流中打印的所有内容都将消失。但是，如果将n_jobs = 1，则所有对覆盖函数的调用都显示为可爱。知识的产生非常昂贵，现在您也拥有了，并且您通过阅读乏味的文章来为之付出了代价。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，继续前进。</font><font style="vertical-align: inherit;">现在，我想为它们的每个参数提供一些方差，然后在最佳值附近给它少一些，依此类推，直到得到与实际相似的结果。</font><font style="vertical-align: inherit;">这将是最终实现我的梦想算法的第一个粗鲁的基准。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我将形成几个用于加权的选项，不同的是几个参数</font></font></b><div class="spoiler_text"><pre><code class="python hljs">feature_base = feature_importances[<span class="hljs-string">'importance'</span>]<font></font>
searchArea = np.array([feature_base - <span class="hljs-number">.05</span>, feature_base, feature_base + <span class="hljs-number">.05</span>])<font></font>
searchArea[searchArea &lt; <span class="hljs-number">0</span>] = <span class="hljs-number">0</span>
searchArea[searchArea &gt; <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>
print(searchArea[<span class="hljs-number">2</span>,:] - searchArea[<span class="hljs-number">0</span>,:])<font></font>
<font></font>
<span class="hljs-keyword">import</span> itertools<font></font>
<font></font>
affected_props = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<font></font>
parametrs_ranges = np.concatenate([<font></font>
    np.linspace(searchArea[<span class="hljs-number">0</span>,affected_props], searchArea[<span class="hljs-number">1</span>,affected_props], <span class="hljs-number">2</span>, endpoint=<span class="hljs-literal">False</span>),<font></font>
    np.linspace(searchArea[<span class="hljs-number">1</span>,affected_props], searchArea[<span class="hljs-number">2</span>,affected_props], <span class="hljs-number">3</span>, endpoint=<span class="hljs-literal">True</span>)]).transpose()<font></font>
<font></font>
print(parametrs_ranges) <span class="hljs-comment">#      .  125 </span>
recombinations = itertools.product(parametrs_ranges[<span class="hljs-number">0</span>],parametrs_ranges[<span class="hljs-number">1</span>],parametrs_ranges[<span class="hljs-number">1</span>])<font></font>
<font></font>
variances = []<font></font>
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> recombinations: <span class="hljs-comment">#          ,       Python .</span><font></font>
    varince = feature_base.copy()<font></font>
    varince[affected_props] = item<font></font>
    variances.append(varince)<font></font>
print(variances[<span class="hljs-number">0</span>])<font></font>
print(len(variances))<font></font>
<span class="hljs-comment">#  knn   ,               .</span>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好了，第一个实验的数据集已经准备好了。</font><font style="vertical-align: inherit;">现在，我将尝试对数据进行实验，首先对结果15个选项进行详尽搜索。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们像本文中那样尝试选择参数</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time
<span class="hljs-comment">#scale = np.ones([18])</span>
knn_pipe = Pipeline([(<span class="hljs-string">'scaler'</span>, StandardAndPoorScaler()), (<span class="hljs-string">'knn'</span>, KNeighborsClassifier(n_neighbors = <span class="hljs-number">7</span> , n_jobs=<span class="hljs-number">-1</span>))])<font></font>
<font></font>
knn_params = {<span class="hljs-string">'scaler__normalization'</span>: variances} <span class="hljs-comment"># 'knn__n_neighbors': range(3, 9, 2), </span>
knn_grid = GridSearchCV(knn_pipe, knn_params, cv=<span class="hljs-number">10</span>, n_jobs=<span class="hljs-number">-1</span>, verbose=<span class="hljs-literal">False</span>)<font></font>
<font></font>
knn_grid.fit(X_train, y_train)<font></font>
knn_grid.best_params_, knn_grid.best_score_, accuracy_score(y_holdout, knn_grid.predict(X_holdout))</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，一切都不好，时间花在了突破上，结果非常不稳定。</font><font style="vertical-align: inherit;">从X_holdout检查中也可以看出，结果像在万花筒中那样跳舞，对输入数据的更改很小。</font><font style="vertical-align: inherit;">我将尝试另一种方法。</font><font style="vertical-align: inherit;">我一次只更改一个参数，但离散化要大得多。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我改变一个第四属性</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time<font></font>
affected_property = <span class="hljs-number">4</span><font></font>
parametrs_range = np.concatenate([<font></font>
    np.linspace(searchArea[<span class="hljs-number">0</span>,affected_property], searchArea[<span class="hljs-number">1</span>,affected_property], <span class="hljs-number">29</span>, endpoint=<span class="hljs-literal">False</span>),<font></font>
    np.linspace(searchArea[<span class="hljs-number">1</span>,affected_property], searchArea[<span class="hljs-number">2</span>,affected_property], <span class="hljs-number">30</span>, endpoint=<span class="hljs-literal">True</span>)]).transpose()<font></font>
<font></font>
print(searchArea[<span class="hljs-number">1</span>,affected_property])<font></font>
print(parametrs_range) <span class="hljs-comment"># C   ,  .</span><font></font>
<font></font>
<font></font>
variances = []<font></font>
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> parametrs_range: <span class="hljs-comment">#          ,       Python .</span><font></font>
    varince = feature_base.copy()<font></font>
    varince[affected_property] = item<font></font>
    variances.append(varince)<font></font>
print(variances[<span class="hljs-number">0</span>])<font></font>
print(len(variances))<font></font>
<span class="hljs-comment">#  knn   ,               .</span><font></font>
<font></font>
knn_pipe = Pipeline([(<span class="hljs-string">'scaler'</span>, StandardAndPoorScaler()), (<span class="hljs-string">'knn'</span>, KNeighborsClassifier(n_neighbors = <span class="hljs-number">7</span> , n_jobs=<span class="hljs-number">-1</span>))])<font></font>
<font></font>
knn_params = {<span class="hljs-string">'scaler__normalization'</span>: variances} <span class="hljs-comment"># 'knn__n_neighbors': range(3, 9, 2), </span>
knn_grid = GridSearchCV(knn_pipe, knn_params, cv=<span class="hljs-number">10</span>, n_jobs=<span class="hljs-number">-1</span>, verbose=<span class="hljs-literal">False</span>)<font></font>
<font></font>
knn_grid.fit(X_train, y_train)<font></font>
knn_grid.best_params_, knn_grid.best_score_, accuracy_score(y_holdout, knn_grid.predict(X_holdout))</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（{'scaler__normalization'：4 0.079957名称：重要性，dtype：float64}，0.9099871410201458，0.913）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那么，鹅有什么呢？</font><font style="vertical-align: inherit;">交叉验证时，百分之一到十分之二的偏移量，如果您查看不同的受影响的属性，则X_holdout的偏移量为半个百分点。</font><font style="vertical-align: inherit;">显然，如果您从树为我们提供这样的数据这一事实开始，改善这种情况是必不可少且廉价的。</font><font style="vertical-align: inherit;">但是，假设我们没有一个初始的，已知的权重分布，并尝试以微小的步长在循环中的任意点进行相同的操作。</font><font style="vertical-align: inherit;">我们将会很有趣。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始填充</font></font></b><div class="spoiler_text"><pre><code class="python hljs">searchArea = np.array([np.zeros((<span class="hljs-number">18</span>,)), np.ones((<span class="hljs-number">18</span>,)) /<span class="hljs-number">18</span>, np.ones((<span class="hljs-number">18</span>,))])<font></font>
print(searchArea[:,<span class="hljs-number">0</span>])<font></font>
<font></font>
history_parametrs = [searchArea[<span class="hljs-number">1</span>,:].copy()]<font></font>
scaler = StandardAndPoorScaler(normalization=searchArea[<span class="hljs-number">1</span>,:])<font></font>
scaler.fit(X_train)<font></font>
knn = KNeighborsClassifier(n_neighbors = <span class="hljs-number">7</span> , n_jobs=<span class="hljs-number">-1</span>)<font></font>
knn.fit(scaler.transform(X_train), y_train)<font></font>
history_holdout_score = [accuracy_score(y_holdout, knn.predict(scaler.transform(X_holdout)))]</code></pre></div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">略微更改一个参数的功能（带有调试日志）</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">changePropertyNormalization</span>(<span class="hljs-params">affected_property, points_count = <span class="hljs-number">15</span></span>):</span><font></font>
    test_range = np.concatenate([<font></font>
        np.linspace(searchArea[<span class="hljs-number">0</span>,affected_property], searchArea[<span class="hljs-number">1</span>,affected_property], points_count//<span class="hljs-number">2</span>, endpoint=<span class="hljs-literal">False</span>),<font></font>
        np.linspace(searchArea[<span class="hljs-number">1</span>,affected_property], searchArea[<span class="hljs-number">2</span>,affected_property], points_count//<span class="hljs-number">2</span> + <span class="hljs-number">1</span>, endpoint=<span class="hljs-literal">True</span>)]).transpose()<font></font>
    variances = [searchArea[<span class="hljs-number">1</span>,:].copy() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(test_range.shape[<span class="hljs-number">0</span>])]
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(len(variances)):<font></font>
        variances[row][affected_property] = test_range[row]<font></font>
    <font></font>
    knn_pipe = Pipeline([(<span class="hljs-string">'scaler'</span>, StandardAndPoorScaler()), (<span class="hljs-string">'knn'</span>, KNeighborsClassifier(n_neighbors = <span class="hljs-number">7</span> , n_jobs=<span class="hljs-number">-1</span>))])<font></font>
    knn_params = {<span class="hljs-string">'scaler__normalization'</span>: variances} <span class="hljs-comment"># 'knn__n_neighbors': range(3, 9, 2), </span>
    knn_grid = GridSearchCV(knn_pipe, knn_params, cv=<span class="hljs-number">10</span>, n_jobs=<span class="hljs-number">-1</span>, verbose=<span class="hljs-literal">False</span>)<font></font>
<font></font>
    knn_grid.fit(X_train, y_train)<font></font>
    holdout_score = accuracy_score(y_holdout, knn_grid.predict(X_holdout))<font></font>
    best_param = knn_grid.best_params_[<span class="hljs-string">'scaler__normalization'</span>][affected_property]<font></font>
    print(affected_property,<font></font>
          <span class="hljs-string">'property:'</span>, searchArea[<span class="hljs-number">1</span>, affected_property], <span class="hljs-string">"=&gt;"</span>, best_param,
          <span class="hljs-string">'holdout:'</span>, history_holdout_score[<span class="hljs-number">-1</span>], <span class="hljs-string">"=&gt;"</span>, holdout_score, <span class="hljs-string">'('</span>, knn_grid.best_score_, <span class="hljs-string">')'</span>)
    <span class="hljs-comment">#             .</span><font></font>
    before = searchArea[:, affected_property]<font></font>
    propertySearchArea = searchArea[:, affected_property].copy()<font></font>
    <span class="hljs-keyword">if</span> best_param == propertySearchArea[<span class="hljs-number">0</span>]:<font></font>
        print(<span class="hljs-string">'|&lt;&lt;'</span>)<font></font>
        searchArea[<span class="hljs-number">0</span>, affected_property] = best_param/<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> best_param &gt; <span class="hljs-number">0.01</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        searchArea[<span class="hljs-number">2</span>, affected_property] = (best_param + searchArea[<span class="hljs-number">2</span>, affected_property])/<span class="hljs-number">2</span>
        searchArea[<span class="hljs-number">1</span>, affected_property] = best_param
    <span class="hljs-keyword">elif</span> best_param == propertySearchArea[<span class="hljs-number">2</span>]:<font></font>
        print(<span class="hljs-string">'&gt;&gt;|'</span>)<font></font>
        searchArea[<span class="hljs-number">2</span>, affected_property] = (best_param + <span class="hljs-number">1</span>)/<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> best_param &lt; <span class="hljs-number">0.99</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>
        searchArea[<span class="hljs-number">0</span>, affected_property] = (best_param + searchArea[<span class="hljs-number">0</span>, affected_property])/<span class="hljs-number">2</span>
        searchArea[<span class="hljs-number">1</span>, affected_property] = best_param
    <span class="hljs-keyword">elif</span> best_param &lt; (propertySearchArea[<span class="hljs-number">0</span>] + propertySearchArea[<span class="hljs-number">1</span>])/<span class="hljs-number">2</span>:<font></font>
        print(<span class="hljs-string">'&lt;&lt;'</span>)<font></font>
        searchArea[<span class="hljs-number">0</span>, affected_property] = max(propertySearchArea[<span class="hljs-number">0</span>]*<span class="hljs-number">1.1</span> - <span class="hljs-number">.1</span>*propertySearchArea[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>)<font></font>
        searchArea[<span class="hljs-number">2</span>, affected_property] = (best_param + propertySearchArea[<span class="hljs-number">2</span>])/<span class="hljs-number">2</span>
        searchArea[<span class="hljs-number">1</span>, affected_property] = best_param
    <span class="hljs-keyword">elif</span> best_param &gt; (propertySearchArea[<span class="hljs-number">1</span>] + propertySearchArea[<span class="hljs-number">2</span>])/<span class="hljs-number">2</span>:<font></font>
        print(<span class="hljs-string">'&gt;&gt;'</span>)<font></font>
        searchArea[<span class="hljs-number">0</span>, affected_property] = (best_param + propertySearchArea[<span class="hljs-number">0</span>])/<span class="hljs-number">2</span>
        searchArea[<span class="hljs-number">2</span>, affected_property] = min(propertySearchArea[<span class="hljs-number">2</span>]*<span class="hljs-number">1.1</span> - <span class="hljs-number">.1</span>*propertySearchArea[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>)<font></font>
        searchArea[<span class="hljs-number">1</span>, affected_property] = best_param
    <span class="hljs-keyword">elif</span> best_param &lt; propertySearchArea[<span class="hljs-number">1</span>]:<font></font>
        print(<span class="hljs-string">'&lt;'</span>)<font></font>
        searchArea[<span class="hljs-number">2</span>, affected_property] = searchArea[<span class="hljs-number">1</span>, affected_property]*<span class="hljs-number">.25</span> + <span class="hljs-number">.75</span>*searchArea[<span class="hljs-number">2</span>, affected_property]<font></font>
        searchArea[<span class="hljs-number">1</span>, affected_property] = best_param
    <span class="hljs-keyword">elif</span> best_param &gt; propertySearchArea[<span class="hljs-number">1</span>]:<font></font>
        print(<span class="hljs-string">'&gt;'</span>)<font></font>
        searchArea[<span class="hljs-number">0</span>, affected_property] = searchArea[<span class="hljs-number">1</span>, affected_property]*<span class="hljs-number">.25</span> + <span class="hljs-number">.75</span>*searchArea[<span class="hljs-number">0</span>, affected_property]<font></font>
        searchArea[<span class="hljs-number">1</span>, affected_property] = best_param
    <span class="hljs-keyword">else</span>:<font></font>
        print(<span class="hljs-string">'='</span>)<font></font>
        searchArea[<span class="hljs-number">0</span>, affected_property] = searchArea[<span class="hljs-number">1</span>, affected_property]*<span class="hljs-number">.25</span> + <span class="hljs-number">.75</span>*searchArea[<span class="hljs-number">0</span>, affected_property]<font></font>
        searchArea[<span class="hljs-number">2</span>, affected_property] = searchArea[<span class="hljs-number">1</span>, affected_property]*<span class="hljs-number">.25</span> + <span class="hljs-number">.75</span>*searchArea[<span class="hljs-number">2</span>, affected_property]<font></font>
    normalization = searchArea[<span class="hljs-number">1</span>,:].sum() <span class="hljs-comment">#,      .</span><font></font>
    searchArea[:,:] /= normalization<font></font>
    print(before, <span class="hljs-string">"=&gt;"</span>,searchArea[:, affected_property])<font></font>
    history_parametrs.append(searchArea[<span class="hljs-number">1</span>,:].copy())<font></font>
    history_holdout_score.append(holdout_score)<font></font>
    <font></font>
changePropertyNormalization(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>)<font></font>
changePropertyNormalization(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>)
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我没有在任何地方进行任何优化，结果，我进行了将近半小时的决定性步骤：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隐藏文字</font></font></b><div class="spoiler_text">       40 .<pre><code class="python hljs">%%time
<span class="hljs-comment">#   </span>
searchArea = np.array([np.zeros((<span class="hljs-number">18</span>,)), np.ones((<span class="hljs-number">18</span>,)) /<span class="hljs-number">18</span>, np.ones((<span class="hljs-number">18</span>,))])<font></font>
print(searchArea[:,<span class="hljs-number">0</span>])<font></font>
<font></font>
history_parametrs = [searchArea[<span class="hljs-number">1</span>,:].copy()]<font></font>
scaler = StandardAndPoorScaler(normalization=searchArea[<span class="hljs-number">1</span>,:])<font></font>
scaler.fit(X_train)<font></font>
knn = KNeighborsClassifier(n_neighbors = <span class="hljs-number">7</span> , n_jobs=<span class="hljs-number">-1</span>)<font></font>
knn.fit(scaler.transform(X_train), y_train)<font></font>
history_holdout_score = [accuracy_score(y_holdout, knn.predict(scaler.transform(X_holdout)))]<font></font>
<font></font>
<span class="hljs-keyword">for</span> tick <span class="hljs-keyword">in</span> range(<span class="hljs-number">40</span>):
    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> range(searchArea.shape[<span class="hljs-number">1</span>]):<font></font>
        changePropertyNormalization(p, <span class="hljs-number">7</span>)<font></font>
    <font></font>
print(searchArea[<span class="hljs-number">1</span>,:])<font></font>
print(history_holdout_score)</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
knn的最终精度为：91.9％，比我们从树中删除数据时要好。</font><font style="vertical-align: inherit;">而且比原始版本要好得多。</font><font style="vertical-align: inherit;">根据决策树比较我们对功能的重要性：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据knn可视化功能的重要性</font></font></b><div class="spoiler_text"><pre><code class="python hljs">feature_importances[<span class="hljs-string">'knn_importance'</span>] = history_parametrs[<span class="hljs-number">-1</span>]<font></font>
diagramma = feature_importances.copy()<font></font>
indexes = diagramma.index<font></font>
diagramma.index = diagramma[<span class="hljs-string">'features'</span>]<font></font>
diagramma.drop(<span class="hljs-string">'features'</span>, <span class="hljs-number">1</span>, inplace = <span class="hljs-literal">True</span>)<font></font>
diagramma.plot(kind=<span class="hljs-string">'bar'</span>);<font></font>
plt.savefig(<span class="hljs-string">"images/pic1.png"</span>, format = <span class="hljs-string">'png'</span>)<font></font>
plt.show()<font></font>
feature_importances</code></pre></div></div><br>
<img src="https://habrastorage.org/webt/kk/pe/nf/kkpenftrnyfl6dpu4p1qh2dnwqq.gif"><br>
<br>
<img src="https://habrastorage.org/webt/ui/o2/rp/uio2rplq9j2p5cxppq7jb7h_mpk.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
似乎是？</font><font style="vertical-align: inherit;">是的，看来。</font><font style="vertical-align: inherit;">但是远非相同。</font><font style="vertical-align: inherit;">有趣的观察。</font><font style="vertical-align: inherit;">数据集中有几个功能可以完全重复，例如“总夜间时间”和“总夜间费用”。</font><font style="vertical-align: inherit;">因此请注意，knn本身发现了此类重复功能的重要部分。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们会将结果保存到文件中，否则恢复工作有点不便...。</font></font></b><div class="spoiler_text"><pre><code class="python hljs">parametrs_df = pd.DataFrame(history_parametrs)<font></font>
parametrs_df[<span class="hljs-string">'scores'</span>] = history_holdout_score<font></font>
parametrs_df.index.name = <span class="hljs-string">'index'</span>
parametrs_df.to_csv(<span class="hljs-string">'parametrs_and_scores.csv'</span>)
</code></pre></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，结果.919本身对knn来说还不错，错误率比普通版本少了一半半，比使用feature_importance树驱动时少了7％。</font><font style="vertical-align: inherit;">但是最有趣的是，根据knn本身，现在我们有了feature_importance。</font><font style="vertical-align: inherit;">它和树告诉我们的有些不同。</font><font style="vertical-align: inherit;">例如，tree和knn对于哪个符号对我们根本不重要有不同的看法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，最后。</font><font style="vertical-align: inherit;">我们有了一些相对较新的和不寻常的东西，对三门讲座mlcourse.ai </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ods和Google </font><font style="vertical-align: inherit;">都有一定的了解，</font><font style="vertical-align: inherit;">可以回答有关python的简单问题。</font><font style="vertical-align: inherit;">我认为还不错。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在幻灯片</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
算法工作的副产品是它所经过的路径。但是，该路径是18维的，这有点妨碍了他的意识，无法实时跟踪算法在此处执行的操作，学习或使用垃圾并不那么方便。根据错误时间表，这实际上并不总是可见的。该错误可能不会在很长一段时间内发生明显变化，但是该算法非常繁忙，会沿着自适应空间中的狭长山谷爬行。因此，对于初学者来说，我将使用第一种最简单但非常有用的方法-我将18维空间随机投影到二维空间上，以便所有参数的贡献（无论其重要性如何）都是单一的。实际上，在我们的文章《</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">窥视神经网络》中</font></a><font style="vertical-align: inherit;">，18维路径很小。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我同样钦佩神经网络具有的所有突触的音阶空间，它很好并且提供了很多信息。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我已通过培训阶段，如果我恢复工作，则从文件中读取数据</font></font></b><div class="spoiler_text"><pre><code class="python hljs">parametrs_df = pd.read_csv(<span class="hljs-string">'parametrs_and_scores.csv'</span>, index_col = <span class="hljs-string">'index'</span>)<font></font>
history_holdout_score = np.array(parametrs_df[<span class="hljs-string">'scores'</span>])<font></font>
parametrs_df.drop(<span class="hljs-string">'scores'</span>,axis=<span class="hljs-number">1</span>)<font></font>
history_parametrs = np.array(parametrs_df.drop(<span class="hljs-string">'scores'</span>,axis=<span class="hljs-number">1</span>))</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
验证错误从某点开始不再改变。</font><font style="vertical-align: inherit;">在这里，有可能在我的余生中自动停止学习并使用接收到的功能，但是我已经有一点时间了。</font><font style="vertical-align: inherit;">:(</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们决定学习多少。</font></font></b><div class="spoiler_text"><pre><code class="python hljs">last = history_holdout_score[<span class="hljs-number">-1</span>]<font></font>
steps = np.arange(<span class="hljs-number">0</span>, history_holdout_score.shape[<span class="hljs-number">0</span>])[history_holdout_score != last].max()<font></font>
print(steps/<span class="hljs-number">18</span>)</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
35.5555555555555556 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们一次更改了一个参数，因此一个优化周期</font><font style="vertical-align: inherit;">包括</font><font style="vertical-align: inherit;">18个步骤。</font><font style="vertical-align: inherit;">事实证明，我们有36个有意义的步骤或类似的步骤。</font><font style="vertical-align: inherit;">现在，让我们尝试可视化训练该方法的轨迹。</font></font><br>
<br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隐藏文字</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time
<span class="hljs-comment">#    :</span>
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<font></font>
%matplotlib inline<font></font>
<span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> math<font></font>
random.seed(<span class="hljs-number">17</span>)<font></font>
property_projection = np.array([[math.sin(a), math.cos(a)] <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> [random.uniform(-math.pi, math.pi) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(history_parametrs[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>])]]).transpose()<font></font>
history = np.array(history_parametrs[::<span class="hljs-number">18</span>]) <span class="hljs-comment">#   - 18 .</span>
<span class="hljs-comment">#           . :(</span>
points = np.array([(history[i] * property_projection).sum(axis=<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(history.shape[<span class="hljs-number">0</span>])])<font></font>
plt.plot(points[:<span class="hljs-number">36</span>,<span class="hljs-number">0</span>],points[<span class="hljs-number">0</span>:<span class="hljs-number">36</span>,<span class="hljs-number">1</span>]);<font></font>
plt.savefig(<span class="hljs-string">"images/pic2.png"</span>, format = <span class="hljs-string">'png'</span>)<font></font>
plt.show()</code></pre></div></div><br>
<img src="https://habrastorage.org/webt/jt/zs/rc/jtzsrcgk60i_aeqhcvxjq9atvee.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以看出，旅程的很大一部分是在前四个步骤中完成的。</font><font style="vertical-align: inherit;">让我们看看其他的增加方式</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有前4分</font></font></b><div class="spoiler_text"><pre><code class="python hljs">plt.plot(points[<span class="hljs-number">4</span>:<span class="hljs-number">36</span>,<span class="hljs-number">0</span>],points[<span class="hljs-number">4</span>:<span class="hljs-number">36</span>,<span class="hljs-number">1</span>]);<font></font>
plt.savefig(<span class="hljs-string">"images/pic3.png"</span>, format = <span class="hljs-string">'png'</span>)</code></pre></div></div><br>
<img src="https://habrastorage.org/webt/gq/xh/wa/gqxhwawt9nnsmypgk3tkry9vbpw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们仔细研究一下路径的最后部分，看看老师到达目的地后做了什么。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">越来越近</font></font></b><div class="spoiler_text"><pre><code class="python hljs">plt.plot(points[<span class="hljs-number">14</span>:<span class="hljs-number">36</span>,<span class="hljs-number">0</span>],points[<span class="hljs-number">14</span>:<span class="hljs-number">36</span>,<span class="hljs-number">1</span>]);<font></font>
plt.savefig(<span class="hljs-string">"images/pic4.png"</span>, format = <span class="hljs-string">'png'</span>)<font></font>
plt.show()<font></font>
plt.plot(points[<span class="hljs-number">24</span>:<span class="hljs-number">36</span>,<span class="hljs-number">0</span>],points[<span class="hljs-number">24</span>:<span class="hljs-number">36</span>,<span class="hljs-number">1</span>]);<font></font>
plt.plot(points[<span class="hljs-number">35</span>:,<span class="hljs-number">0</span>],points[<span class="hljs-number">35</span>:,<span class="hljs-number">1</span>], color = <span class="hljs-string">'red'</span>);<font></font>
plt.savefig(<span class="hljs-string">"images/pic5.png"</span>, format = <span class="hljs-string">'png'</span>)<font></font>
plt.show()</code></pre></div></div><br>
<img src="https://habrastorage.org/webt/a5/kq/6m/a5kq6mq5yxl3roojyjfzdw8wq8a.png"><br>
<br>
<img src="https://habrastorage.org/webt/g5/lo/gs/g5logsa_jmna5lveoc-w0679koy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以看出，该算法正在专心训练。直到他找到目的地。当然，具体点取决于交叉验证中的随机性。但是，无论具体点如何，都可以理解所发生事情的总体情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说一句，我曾经使用这样的时间表来演示学习过程。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并未显示整个轨迹，而是显示了比例尺滑动平滑的最后几步。在我的另一篇文章“我们窥探神经网络”中可以找到一个例子。是的，当然，遇到这种可视化的每个人都会立即问为什么所有因素都具有相同的权重，重要性，而后又有所不同。上一次，我试图重新衡量突触的重要性，结果却没有那么多信息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这次，借助新知识，我将尝试使用t-SNE将多维空间部署到投影中，使一切都可以变得更好。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吨位</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time
<span class="hljs-keyword">import</span> sklearn.manifold <span class="hljs-keyword">as</span> manifold<font></font>
tsne = manifold.TSNE(random_state=<span class="hljs-number">19</span>)<font></font>
tsne_representation = tsne.fit_transform(history)<font></font>
plt.plot(tsne_representation[:, <span class="hljs-number">0</span>], tsne_representation[:, <span class="hljs-number">1</span>])<font></font>
plt.savefig(<span class="hljs-string">"images/pic6.png"</span>, format = <span class="hljs-string">'png'</span>)<font></font>
plt.show();</code></pre></div></div><br>
<img src="https://habrastorage.org/webt/qe/bp/nn/qebpnnz71ywbxgqvhzj3fpv8vzc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
t-Sne似乎已经扩展了空间，因此对于那些迅速停止变化的功能，它完全可以控制变化的范围，从而使图像完全无用。</font><font style="vertical-align: inherit;">结论-不要试图将算法放到不适合他们使用的地方。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您无法进一步阅读</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我还尝试将tsne注入内部以可视化中间优化状态，以期能产生美感。但是事实证明，这不是美丽，是一些垃圾。如果有兴趣，请参阅操作方法。互联网上充斥着此类注入代码的示例，但仅复制它们就不会</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">造成</font></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">麻烦</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">因为</font><b><font style="vertical-align: inherit;">sklearn.manifold.t_sne</font></b><font style="vertical-align: inherit;">内部函数</font><b><font style="vertical-align: inherit;">_gradient_descent中</font></b><font style="vertical-align: inherit;">包含替代</font><b><font style="vertical-align: inherit;">项</font></b><font style="vertical-align: inherit;">，并且取决于版本，其签名和内部变量的处理可能会非常不同。因此，只需找到自己的源代码，然后从那里选择函数的版本，然后在其中插入一行，即可在您</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自己</font><font style="vertical-align: inherit;">的变量中添加中间转储：</font><font style="vertical-align: inherit;">position.append（p.copy（））＃我们保存当前位置。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，例如，我们可以精美地可视化所得到的结果：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注射代码</font></font></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> linalg
<span class="hljs-comment"># This list will contain the positions of the map points at every iteration.</span><font></font>
positions = []<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_gradient_descent</span>(<span class="hljs-params">objective, p0, it, n_iter,
                      n_iter_check=<span class="hljs-number">1</span>, n_iter_without_progress=<span class="hljs-number">300</span>,
                      momentum=<span class="hljs-number">0.8</span>, learning_rate=<span class="hljs-number">200.0</span>, min_gain=<span class="hljs-number">0.01</span>,
                      min_grad_norm=<span class="hljs-number">1e-7</span>, verbose=<span class="hljs-number">0</span>, args=None, kwargs=None</span>):</span>
    <span class="hljs-comment"># The documentation of this function can be found in scikit-learn's code.</span>
    <span class="hljs-keyword">if</span> args <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
        args = []<font></font>
    <span class="hljs-keyword">if</span> kwargs <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
        kwargs = {}<font></font>
<font></font>
    p = p0.copy().ravel()<font></font>
    update = np.zeros_like(p)<font></font>
    gains = np.ones_like(p)<font></font>
    error = np.finfo(np.float).max<font></font>
    best_error = np.finfo(np.float).max<font></font>
    best_iter = i = it<font></font>
<font></font>
    tic = time()<font></font>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(it, n_iter):<font></font>
        positions.append(p.copy()) <span class="hljs-comment"># We save the current position.</span><font></font>
        <font></font>
        check_convergence = (i + <span class="hljs-number">1</span>) % n_iter_check == <span class="hljs-number">0</span>
        <span class="hljs-comment"># only compute the error when needed</span>
        kwargs[<span class="hljs-string">'compute_error'</span>] = check_convergence <span class="hljs-keyword">or</span> i == n_iter - <span class="hljs-number">1</span><font></font>
<font></font>
        error, grad = objective(p, *args, **kwargs)<font></font>
        grad_norm = linalg.norm(grad)<font></font>
<font></font>
        inc = update * grad &lt; <span class="hljs-number">0.0</span><font></font>
        dec = np.invert(inc)<font></font>
        gains[inc] += <span class="hljs-number">0.2</span>
        gains[dec] *= <span class="hljs-number">0.8</span><font></font>
        np.clip(gains, min_gain, np.inf, out=gains)<font></font>
        grad *= gains<font></font>
        update = momentum * update - learning_rate * grad<font></font>
        p += update<font></font>
<font></font>
        <span class="hljs-keyword">if</span> check_convergence:<font></font>
            toc = time()<font></font>
            duration = toc - tic<font></font>
            tic = toc<font></font>
<font></font>
            <span class="hljs-keyword">if</span> verbose &gt;= <span class="hljs-number">2</span>:<font></font>
                print(<span class="hljs-string">"[t-SNE] Iteration %d: error = %.7f,"</span>
                      <span class="hljs-string">" gradient norm = %.7f"</span>
                      <span class="hljs-string">" (%s iterations in %0.3fs)"</span>
                      % (i + <span class="hljs-number">1</span>, error, grad_norm, n_iter_check, duration))<font></font>
<font></font>
            <span class="hljs-keyword">if</span> error &lt; best_error:<font></font>
                best_error = error<font></font>
                best_iter = i<font></font>
            <span class="hljs-keyword">elif</span> i - best_iter &gt; n_iter_without_progress:
                <span class="hljs-keyword">if</span> verbose &gt;= <span class="hljs-number">2</span>:<font></font>
                    print(<span class="hljs-string">"[t-SNE] Iteration %d: did not make any progress "</span>
                          <span class="hljs-string">"during the last %d episodes. Finished."</span>
                          % (i + <span class="hljs-number">1</span>, n_iter_without_progress))
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">if</span> grad_norm &lt;= min_grad_norm:
                <span class="hljs-keyword">if</span> verbose &gt;= <span class="hljs-number">2</span>:<font></font>
                    print(<span class="hljs-string">"[t-SNE] Iteration %d: gradient norm %f. Finished."</span>
                          % (i + <span class="hljs-number">1</span>, grad_norm))
                <span class="hljs-keyword">break</span><font></font>
<font></font>
    <span class="hljs-keyword">return</span> p, error, i<font></font>
<font></font>
manifold.t_sne._gradient_descent = _gradient_descent</code></pre></div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用``固定''t-SNE</font></font></b><div class="spoiler_text"><pre><code class="python hljs">tsne_representation = manifold.TSNE(random_state=<span class="hljs-number">17</span>).fit_transform(history)<font></font>
X_iter = np.dstack(position.reshape(<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> position <span class="hljs-keyword">in</span> positions)<font></font>
position_reshape = [position.reshape(<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> position <span class="hljs-keyword">in</span> positions]<font></font>
print(position_reshape[<span class="hljs-number">0</span>].shape)<font></font>
print(<span class="hljs-string">'[0] min'</span>, position_reshape[<span class="hljs-number">0</span>][:,<span class="hljs-number">0</span>].min(),<span class="hljs-string">'max'</span>, position_reshape[<span class="hljs-number">0</span>][:,<span class="hljs-number">0</span>].max())<font></font>
print(<span class="hljs-string">'[1] min'</span>, position_reshape[<span class="hljs-number">1</span>][:,<span class="hljs-number">0</span>].min(),<span class="hljs-string">'max'</span>, position_reshape[<span class="hljs-number">1</span>][:,<span class="hljs-number">0</span>].max())<font></font>
print(<span class="hljs-string">'[2] min'</span>, position_reshape[<span class="hljs-number">2</span>][:,<span class="hljs-number">0</span>].min(),<span class="hljs-string">'max'</span>, position_reshape[<span class="hljs-number">2</span>][:,<span class="hljs-number">0</span>].max())
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
41，2 </font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">[0]最小值-0.00018188123最大值0.00027207955 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[1]最小值-0.05136269最大值0.032607622 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[2]最小值-4.392309最大值7.9074526 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该值在非常宽的范围内变化，因此在绘制它们之前将对其进行缩放。</font><font style="vertical-align: inherit;">在循环中，所有这些都是缓慢完成的。</font><font style="vertical-align: inherit;">:(</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我缩放</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time
<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> MinMaxScaler<font></font>
minMaxScaler = MinMaxScaler()<font></font>
minMaxScaler.fit_transform(position_reshape[<span class="hljs-number">0</span>])<font></font>
position_reshape = [minMaxScaler.fit_transform(frame) <span class="hljs-keyword">for</span> frame <span class="hljs-keyword">in</span> position_reshape]<font></font>
position_reshape[<span class="hljs-number">0</span>].min(), position_reshape[<span class="hljs-number">0</span>].max()</code></pre></div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动画化</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time<font></font>
<font></font>
<span class="hljs-keyword">from</span> matplotlib.animation <span class="hljs-keyword">import</span> FuncAnimation, PillowWriter
<span class="hljs-comment">#plt.style.use('seaborn-pastel')</span><font></font>
<font></font>
fig = plt.figure()<font></font>
<font></font>
ax = plt.axes(xlim=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), ylim=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<font></font>
line, = ax.plot([], [], lw=<span class="hljs-number">3</span>)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init</span>():</span><font></font>
    line.set_data([], [])<font></font>
    <span class="hljs-keyword">return</span> line,
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">animate</span>(<span class="hljs-params">i</span>):</span>
    x = position_reshape[i][:,<span class="hljs-number">0</span>]<font></font>
    y = position_reshape[i][:,<span class="hljs-number">1</span>]<font></font>
    line.set_data(x, y)<font></font>
    <span class="hljs-keyword">return</span> line,<font></font>
<font></font>
anim = FuncAnimation(fig, animate, init_func=init, frames=<span class="hljs-number">36</span>, interval=<span class="hljs-number">20</span>, blit=<span class="hljs-literal">True</span>, repeat_delay = <span class="hljs-number">1000</span>)<font></font>
anim.save(<span class="hljs-string">'images/animate_tsne_learning.gif'</span>, writer=PillowWriter(fps=<span class="hljs-number">5</span>))
</code></pre></div></div><br>
<img src="https://habrastorage.org/webt/lh/dq/g6/lhdqg6khzhplw6jtkei6y0s3pdu.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它在技巧上很有启发性，但在这项任务和丑陋中绝对没有用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，我向你告别。</font><font style="vertical-align: inherit;">我希望即使在knn的帮助下，您也可以得到一些新颖有趣的东西以及一些代码，这一想法也将帮助您如何在这场瘟疫中的智力大餐中玩转数据。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN496466/index.html">任何足够快的光源都具有红色多普勒频移</a></li>
<li><a href="../zh-CN496472/index.html">GitHub上的10个有趣的存储库，对任何开发人员都有用</a></li>
<li><a href="../zh-CN496476/index.html">使用Windows Server Core将Windows Server推入低功耗VPS</a></li>
<li><a href="../zh-CN496480/index.html">未来的寂静之声</a></li>
<li><a href="../zh-CN496482/index.html">团队管理中知情领导的发展</a></li>
<li><a href="../zh-CN496486/index.html">意见：Spamhaus-在线审查还是清洁网络战斗人员？</a></li>
<li><a href="../zh-CN496488/index.html">IaaS提供商抗击BGP协议的攻击</a></li>
<li><a href="../zh-CN496490/index.html">我们研究了Mediastreamer2 VoIP引擎。第7部分</a></li>
<li><a href="../zh-CN496492/index.html">LXD基本功能-Linux容器系统</a></li>
<li><a href="../zh-CN496494/index.html">我们在系统扬声器上播放Mario的音乐</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>