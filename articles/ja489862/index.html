<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤓 🙎 🐾 Goの計画：パートII-Goスケジューラ 👩🏿‍🚒 👋🏿 ⛈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！これは、Goでのスケジューラーの作業のメカニズムとセマンティクスについてのアイデアを提供する3部構成のシリーズの2番目の投稿です。この投稿は囲碁プランナーについてです。最初の部分このシリーズ、私は私の意見では、囲碁スケジューラのセマンティクスを理解し、評価するために重要である、こ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Goの計画：パートII-Goスケジューラ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489862/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font><font style="vertical-align: inherit;">これは、Goでのスケジューラーの作業のメカニズムとセマンティクスについてのアイデアを提供する3部構成のシリーズの2番目の投稿です。</font><font style="vertical-align: inherit;">この投稿は囲碁プランナーについてです。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">最初の部分</font></a><font style="vertical-align: inherit;">このシリーズ、私は私の意見では、囲碁スケジューラのセマンティクスを理解し、評価するために重要である、ことをオペレーティングシステムスケジューラの側面を説明しました。</font><font style="vertical-align: inherit;">この投稿では、Goスケジューラのしくみをセマンティックレベルで説明します。</font><font style="vertical-align: inherit;">Goスケジューラは複雑なシステムであり、小さな機械的な詳細は重要ではありません。</font><font style="vertical-align: inherit;">すべてがどのように機能し、どのように動作するかについての良いモデルを持つことが重要です。</font><font style="vertical-align: inherit;">これにより、最良のエンジニアリング決定を行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムが始まります</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goプログラムが起動すると、ホストマシンで定義された各仮想コアに論理プロセッサ（P）が割り当てられます。物理コアごとに複数のハードウェアスレッド（ハイパースレッディング）を備えたプロセッサがある場合、各ハードウェアスレッドは仮想コアとしてプログラムに提示されます。これをよりよく理解するには、私のMacBook Proのシステムレポートを見てください。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b6e/2de/4a8/b6e2de4a805c6a87c95aa0afcef436ac.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4つの物理コアを備えた1つのプロセッサがあることがわかります。このレポートでは、物理コアあたりのハードウェアスレッドの数は開示されていません。 Intel Core i7プロセッサにはハイパースレッディングテクノロジーが搭載されています。つまり、物理コアには2つのハードウェアスレッドがあります。これは、OSスレッドを並行して実行するために8つの仮想コアが使用可能であることをGoに伝えます。これを確認するには、次のプログラムを検討してください。</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"runtime"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
<font></font>
    <span class="hljs-comment">// NumCPU returns the number of logical</span>
    <span class="hljs-comment">// CPUs usable by the current process.</span><font></font>
    fmt.Println(runtime.NumCPU())<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプログラムをコンピューターで実行すると、NumCPU（）関数を呼び出した結果は8になります。コンピューターで実行するGoプログラムはすべて8（P）になります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pに</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はOSストリーム（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">が割り当てられています</font><font style="vertical-align: inherit;">。このスレッドは依然としてOSによって管理されており、OSは引き続きスレッドをカーネルに配置して実行します。つまり、自分のコンピューターでGoを実行すると、8つのスレッドを使用して作業を行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それぞれ</font><font style="vertical-align: inherit;">個別にPにリンクされています。</font><font style="vertical-align: inherit;">各Goプログラムには、最初のGoroutine（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">） Goroutineは基本的にCoroutineですが、Goなので、Cという文字をGに置き換えてGoroutineという単語を取得します。 Goroutinesはアプリケーションレベルのスレッドと考えることができ、OSスレッドによく似ています。カーネルによってOSスレッドがオン/オフされるのと同じように、コンテキストプログラムはコンテキストによってオン/オフされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のパズルは実行キューです。</font><font style="vertical-align: inherit;">Goスケジューラには、グローバル実行キュー（GRQ）とローカル実行キュー（LRQ）の2つの異なる実行キューがあります。</font><font style="vertical-align: inherit;">各Pには、Pのコンテキストで実行するために割り当てられたゴルーチンを制御するLRQが割り当てられています。これらのゴルーチンは、このPに割り当てられたコンテキストMからオン/オフになります。GRQは、Pに割り当てられなかったゴルーチン用です。ゴルーチンを移動するプロセスがあります後で説明するGRQからLRQへ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像は、これらすべてのコンポーネントをまとめて示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/114/13e/494/11413e494428c2540e349637f34bbec3.png" alt="画像"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">協力プランナー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の投稿で述べたように、OSスケジューラはプリエンプティブスケジューラです。基本的に、これは、計画者がいつ何をするかを予測できないことを意味します。カーネルが決定を下し、すべてが非決定的です。オペレーティングシステム上で実行されているアプリケーションは、アトミック命令やミューテックス呼び出しなどの同期プリミティブを使用しない限り、スケジューリングによってカーネル内部で発生することを制御しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GoスケジューラはGoランタイムの一部であり、Goランタイムはアプリケーションに組み込まれています。これは、Goスケジューラがカーネルのユーザー空間で機能することを意味します。現在のGoスケジューラーの実装はプリエンプティブではなく、インタラクティブなスケジューラーです。協調プランナーであることは、プランナーが計画の決定を行うために、コードの安全なポイントで発生するユーザー空間で明確に定義されたイベントを必要とすることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goのコラボレーティブプランナーの良い点は、プロアクティブな外観と感触があることです。</font><font style="vertical-align: inherit;">Goスケジューラが何をするかは予測できません。</font><font style="vertical-align: inherit;">これは、このスケジューラーの意思決定が開発者に依存するのではなく、Goの実行時間に依存するためです。</font><font style="vertical-align: inherit;">Goスケジューラーはプロアクティブスケジューラーと考えることが重要です。スケジューラーは非決定的であるため、それほど難しくありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゴルティン州</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリームと同じように、ゴルーチンにも同じ3つの高レベル状態があります。 Goプランナーがどのgoroutineで果たす役割を決定します。 Goroutinは、Waiting、Ready、Fulfillingの3つの状態のいずれかになります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待機中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：これは、goroutineが停止し、何かが継続するのを待機していることを意味します。これは、オペレーティングシステムの待機（システムコール）または呼び出しの同期（アトミックおよびミューテックス操作）などの理由で発生する可能性があります。これらのタイプの遅延は、パフォーマンスの低下の主な原因です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準備</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：これは、goroutineが割り当てられた指示に従う時間を必要とすることを意味します。</font><font style="vertical-align: inherit;">時間を必要とするゴルーチンがたくさんある場合、ゴルーチンは時間を稼ぐためにより長く待たなければなりません。</font><font style="vertical-align: inherit;">さらに、より多くのゴ​​ルーチンが時間を競うため、ゴルーチンが受け取る個々の時間は短縮されます。</font><font style="vertical-align: inherit;">このタイプのスケジューリング遅延も、パフォーマンスの低下を引き起こす可能性があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">履行</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：これは、ゴルーチンがMに配置され、その指示に従っていることを意味します。</font><font style="vertical-align: inherit;">アプリケーションに関連する作業が完了しました。</font><font style="vertical-align: inherit;">これは誰もが望んでいることです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキストスイッチ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goスケジューラでは、コンテキストを切り替えるために、コード内の安全なポイントで発生する明確に定義されたユーザー空間イベントが必要です。</font><font style="vertical-align: inherit;">これらのイベントと安全なポイントは、関数呼び出しに表示されます。</font><font style="vertical-align: inherit;">Goスケジューラーのパフォーマンスには、関数呼び出しが重要です。</font><font style="vertical-align: inherit;">関数呼び出しを行わない狭いループを実行すると、スケジューラとガベージコレクションで遅延が発生します。</font><font style="vertical-align: inherit;">関数呼び出しが妥当な時間内に発生することが不可欠です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goプログラムで発生するイベントには4つのクラスがあり、プランナーが計画を決定できます。</font><font style="vertical-align: inherit;">これは、これらのイベントのいずれかで常に発生するという意味ではありません。</font><font style="vertical-align: inherit;">これは、スケジューラが機会を取得することを意味します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">goキーワードの使用</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガベージコレクター</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムコール</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期</font></font></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">go</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
キーワードの</font><i><font style="vertical-align: inherit;">使用go</font></i><font style="vertical-align: inherit;">キーワードは、goroutineを作成する方法です。</font><font style="vertical-align: inherit;">新しいgoroutineが作成されるとすぐに、プランナーは計画を決定する機会を得ます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガベージコレクター（GC）</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
GCは独自の一連のゴルーチンで動作するため、これらのゴルチンを実行するにはMの時間が必要です。</font><font style="vertical-align: inherit;">これにより、GCは計画時に多くの混乱を引き起こします。</font><font style="vertical-align: inherit;">ただし、計画担当者はgoroutineが何をするかについて非常に賢く、彼は決定を行うためにそれを使用します。</font><font style="vertical-align: inherit;">合理的な解決策の1つは、システムリソースにアクセスしたいgoroutineにコンテキストを切り替えることです。ガベージコレクション中には、それ以外の誰もそれを使用しません。</font><font style="vertical-align: inherit;">GCが機能する場合、多くの計画決定が行われます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムコール</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゴルーチンが、それはMをブロックするようになりますシステムコールを行う場合は、スケジューラは同じMに、別のゴルーチンにコンテキストを切り替えることができ</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、同期</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アトミック操作の呼び出し、ミューテックスまたはチャネルはゴルーチンがブロックされる場合は、スケジューラは新しいゴルーチンを開始するためのコンテキストを切り替えることができます。</font><font style="vertical-align: inherit;">goroutineが再び機能するようになると、キューに入れられ、最終的にはMに戻ります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期システムコール</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業中のオペレーティングシステムがシステムコールを非同期で処理できる場合、いわゆるネットワークポーラーを使用して、システムコールをより効率的に処理できます。</font><font style="vertical-align: inherit;">これは、これらのそれぞれのOSでkqueue（MacOS）、epoll（Linux）またはiocp（Windows）を使用して実現されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークシステムコールは、現在使用している多くのオペレーティングシステムで非同期に処理できます。ネットワークポーラーの主な目的はネットワーク操作を処理することなので、これがネットワークポーラー自体を示しています。スケジューラは、ネットワークシステムコールにネットワークポーラーを使用して、これらのシステムコール中にゴルーチンがMをブロックするのを防ぐことができます。これにより、新しいMを作成する必要なく、LRQ Pで他のゴルーチンを実行するためにMを使用できる状態に保つことができます。これにより、OSの計画の負担を軽減できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがどのように機能するかを確認する最良の方法は、例を見ることです。図は、基本的な計画スキームを示しています。 Gorutin-1はMで実行され、さらに3つのGorutinがLRQでMでの時間を取得するために待機しています。ネットワークポーラーは非アクティブで、何もしません。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d76/7cd/b0f/d767cdb0fd640db3a84e3c87d14f38e3.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の図では、Gorutin-1（G1）がネットワークシステムコールを作成しようとしているため、G1はネットワークポーラーに移動し、非同期ネットワークシステムコールとして扱われます。</font><font style="vertical-align: inherit;">G1がネットワークポーラーに移動すると、MはLRQから別のgoroutineを実行できるようになります。</font><font style="vertical-align: inherit;">この場合、Gorutin-2はMに切り替わります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/764/93f/af0/76493faf0f599eefae69938878e4ceb1.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の図では、システムネットワークコールは非同期ネットワークコールで終了し、G1はPのLRQに戻り</font><font style="vertical-align: inherit;">ます。G1 </font><font style="vertical-align: inherit;">をMに戻すと、Goに関連付けられたコードが彼は答えをもう一度実行できます。</font><font style="vertical-align: inherit;">大きな利点は、ネットワークシステムコールを行うために追加のMs.が必要ないことです。</font><font style="vertical-align: inherit;">ネットワークポーラーにはOSスレッドがあり、イベントループを通じて処理されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期システムコール</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
goroutineが非同期で実行できないシステムコールを実行しようとするとどうなりますか？</font><font style="vertical-align: inherit;">この場合、ネットワークポーラーは使用できず、システムコールを作成するゴルーチンがMをブロックします。これは悪いことですが、これを防ぐ方法はありません。</font><font style="vertical-align: inherit;">非同期で実行できないシステムコールの1つの例は、ファイルベースのシステムコールです。</font><font style="vertical-align: inherit;">CGOを使用する場合、C関数の呼び出しもMをブロックする他の状況がある可能性があります。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windowsオペレーティングシステムは、ファイルベースの非同期システムコールを実行できます。</font><font style="vertical-align: inherit;">技術的には、Windowsで作業する場合、ネットワークポーラーを使用できます。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mをブロックする同期システムコール（ファイルI / Oなど）で何が起こるかを見てみましょう。図は基本的な計画図を示していますが、今回はG1がM1をブロックする同期システムコールを作成します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/747/549/a28/747549a28a7a627a3cbd98fffe728fad.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の図では、スケジューラはG1がMロックを引き起こしたと判断できます。この時点で、スケジューラは、ブロッキングG1が接続されたまま、M1をPから切断します。次に、スケジューラはPを提供する新しいM2を導入します。この時点で、G2をLRQから選択し、M2コンテキストに含めることができます。以前の交換によりMがすでに存在する場合、この移行は新しいMを作成する必要性よりも高速です。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/966/30c/3dd/96630c3dd34a06fbc5ed5f8b4c8bdfbc.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップは、G1によって行われたロックシステムコールを完了します。</font><font style="vertical-align: inherit;">この時点で、G1はLRQに戻り、Pによって再びサービスを受けることができます。このシナリオを繰り返す必要がある場合、M1は将来の使用のために脇に置きます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/553/0ed/f8c/5530edf8c481aee13a40ff0b55e8e1ed.png" alt="画像"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">盗む仕事</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スケジューラーのもう1つの側面は、それがgoroutine盗難プランナーであることです。これは、いくつかの領域で効果的な計画をサポートするのに役立ちます。まず、Mがスタンバイ状態になるのは最後に必要です。これが発生するとすぐに、OSはコンテキストを使用してMをカーネルから切り替えます。これは、Mがカーネルに戻るまで、正常な状態のGoroutineがあったとしても、Pは何も実行できないことを意味します。 Gorutin Theftは、すべてのP間の時間間隔のバランスをとるのにも役立ち、作業がより効率的に分散され、実行されるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この図では、2つのPがそれぞれ4つのGと1つのGをGRQで提供するマルチスレッドのGoプログラムがあります。 Pの1つがGのすべてをすばやく処理するとどうなりますか？</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e1a/745/eaa/e1a745eaaeab4e91bf35e80d8f16ae34.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、P1には実行するゴルーチンがありません。しかし、P2のLRQとGRQの両方で、動作状態にはゴルーチンがあります。これは、P1がゴルーチンを盗む必要がある瞬間です。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6f6/190/ccc/6f6190cccec8213c27cadfbb03b67767.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゴルーチンを盗むためのルールは次のとおりです。すべてのコードは、ランタイムソースで表示できます。</font></font><br>
<br>
<pre><code class="go hljs">runtime.schedule() {
    <span class="hljs-comment">// only 1/61 of the time, check the global runnable queue for a G.</span>
    <span class="hljs-comment">// if not found, check the local queue.</span>
    <span class="hljs-comment">// if not found,</span>
    <span class="hljs-comment">//     try to steal from other Ps.</span>
    <span class="hljs-comment">//     if not, check the global runnable queue.</span>
    <span class="hljs-comment">//     if not found, poll network.</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、これらのルールに基づいて、P1はLRQにゴルーチンが存在するかどうかP2をチェックし、見つかったものの半分を取る必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/af2/b9b/ec2/af2b9bec21571656e051799fb3213020.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2がすべてのプログラムの提供を終了し、LRQにP1が残っていない場合はどうなりますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2はすべての作業を完了しており、今ではゴルーチンを盗む必要があります。</font><font style="vertical-align: inherit;">まず、LRQ P1を確認しますが、ゴルーチンは見つかりません。</font><font style="vertical-align: inherit;">次に、GRQについて説明します。</font><font style="vertical-align: inherit;">そこで彼はG9を見つけるでしょう。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4f8/2db/b86/4f82dbb86b9005e458097587792dd462.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2はGRQからG9を盗み、仕事を始めます。</font><font style="vertical-align: inherit;">このすべての盗難の良い点は、Mが忙しくなり、非アクティブにならないようにすることです。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e12/221/a4a/e12221a4ad60695c5c5c97837e30cfbb.png" alt="画像"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実例</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メカニズムとセマンティクスを使用して、Goスケジューラーが時間をかけてより多くの作業を行えるように、これらすべてがどのように組み合わされるかをお見せしたいと思います。 Cで作成されたマルチスレッドアプリケーションを想像してください。アプリケーションは、互いにメッセージを送信する2つのOSスレッドを管理します。画像内にメッセージを送受信する2つのスレッドがあります。スレッド1はコンテキスト切り替えコア1を受け取り、現在実行中です。これにより、スレッド1はメッセージをスレッド2に送信できます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bb3/6fb/00d/bb36fb00db345441ca295dd01d153b2b.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、スレッド1がメッセージの送信を終了すると、応答を待つ必要があります。これにより、スレッド1がカーネル1のコンテキストから切断され、待機状態になります。スレッド2がメッセージ通知を受信するとすぐに、正常な状態になります。これで、OSはコンテキスト切り替えを実行し、カーネルでスレッド2を実行できます。これにより、カーネル2になります。次に、スレッド2がメッセージを処理し、新しいメッセージをスレッド1に送り返します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4af/66e/0fe/4af66e0fe8440f757063603b6bc161a2.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ストリーム2からのメッセージがストリーム1によって受信されると、ストリームはコンテキストに戻ります。これで、ストリーム2は実行状態からスタンバイ状態に切り替わり、ストリーム1はスタンバイ状態から準備完了状態に切り替わり、最後に実行状態に戻って処理できるようになります。新しいメッセージを送り返します。これらのコンテキストスイッチと状態変更はすべて完了するまでに時間がかかるため、作業の速度が制限されます。各コンテキストスイッチには約1000ナノ秒の遅延が伴い、ハードウェアがナノ秒あたり12の命令を実行することを期待しているため、これらのコンテキストスイッチ中に実行されない多かれ少なかれ12,000の命令を見てください。これらの流れは異なる核の間でも交差するため、追加のキャッシュラインミス遅延の可能性も高くなります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a45/b47/127/a45b47127d054f2b56b6c2534c9150bf.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この図では、互いに調和してメッセージをやり取りする2つのゴルティンが存在します。 G1は、Core 1で実行されるコンテキストスイッチM1を取得します。これにより、G1がその仕事を実行できます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/977/b59/78c/977b5978ca8daa9bfc186c77c901565a.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、G1がメッセージの送信を終了すると、G1は応答を待つ必要があります。これにより、G1がM1コンテキストから切断され、アイドル状態になります。 G2にメッセージが通知されるとすぐに、メッセージは正常な状態になります。これで、Goスケジューラはコンテキスト切り替えを実行し、M1でG2を実行できます。M1は引き続きCore 1で実行されます。次にG2がメッセージを処理し、新しいメッセージをG1に送信します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3e8/86c/003/3e886c003a64536731234abde2746ca2.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップでは、G2によって送信されたメッセージがG1によって受信されると、すべてが再び切り替わります。これで、コンテキストG2が実行状態から待機状態に切り替わり、コンテキストG1が待機状態から実行状態に切り替わり、最後に実行状態に戻ります。これにより、新しいメッセージを処理して送信できるようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4db/97b/a31/4db97ba314fa8b14bf6497dcaf15135a.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表面的なものは違っていないようです。 Streamsを使用するかGoroutinesを使用するかに関係なく、すべて同じコンテキストの変更と状態の変更が発生します。ただし、StreamsとGorutinの使用には大きな違いがあり、一見すると明らかではない場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
goroutineを使用する場合、すべての処理に同じOSスレッドとカーネルが使用されます。これは、OSの観点からは、OSフローが待機状態になることは決してないことを意味します。決して。その結果、ストリームの使用時にコンテキストを切り替えるときに失われたこれらの命令は、goroutinを使用しても失われません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的に、GoはOSレベルでIO /ブロッキング作業をプロセッサーに依存したジョブに変えました。すべてのコンテキスト切り替えはアプリケーションレベルで行われるため、ストリームの使用時に失われたものと同じ〜12,000命令（平均）がコンテキスト切り替えで失われることはありません。 Goでは、同じコンテキストスイッチにかかるコストは200ナノ秒または2.4千コマンドです。スケジューラは、キャッシュ文字列と</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">NUMAの</font></a><font style="vertical-align: inherit;">パフォーマンスの向上にも役立ちます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これが、仮想コアよりも多くのスレッドを必要としない理由です。</font><font style="vertical-align: inherit;">Goスケジューラはより少ないスレッドを使用し、各スレッドでより多くのことを実行しようとするため、Goは時間とともにより多くの作業を実行できます。これにより、OSとハードウェアの負荷が軽減されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go Schedulerは、オペレーティングシステムとハードウェアの複雑さを考慮に入れている点で本当に素晴らしいものです。 I / O /ロック操作をオペレーティングシステムレベルでプロセッサバウンド操作に変換する機能は、時間の経過とともにより多くのプロセッサ能力を使用することで大きな利益を得るところです。これが、仮想カーネルよりも多くのOSスレッドを必要としない理由です。すべての作業が仮想カーネルごとに1つのOSスレッドで（CPUバインディングとI / O /ロックを使用して）完了すると合理的に期待できます。これは、OSスレッドをブロックするシステムコールを必要としないネットワークアプリケーションやその他のアプリケーションで可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者として、あなたはまだあなたのアプリケーションが仕事のタイプの面で何をするかを理解するべきです。</font><font style="vertical-align: inherit;">無制限のゴルーチンを作成して驚くべきパフォーマンスを期待することはできません。</font><font style="vertical-align: inherit;">少ない方が常に多いですが、Goスケジューラーのこのセマンティクスを理解することで、より適切なエンジニアリング上の決定を行うことができます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja489852/index.html">Linux上のASP.Net Coreにおける透過的な認証</a></li>
<li><a href="../ja489854/index.html">混乱なしのRedux vs MobX</a></li>
<li><a href="../ja489856/index.html">Banach-Tarski逆パラドックス、または保存されたデータ量を5分の1に削減する方法</a></li>
<li><a href="../ja489858/index.html">国際化：すべての人がWebにアクセスできるようにする</a></li>
<li><a href="../ja489860/index.html">テレフンケンの歴史：ヴィルヘルム2世とゲッベルスからビートルズまで、そして今日のドイツのエレクトロニクスのフェニックス</a></li>
<li><a href="../ja489868/index.html">Mozilla WebThingsのフリーズ</a></li>
<li><a href="../ja489870/index.html">ニジニノヴゴロドのNode.jsによる無料のオフライン集中</a></li>
<li><a href="../ja489872/index.html">DLPシステムとOCRモジュールが従業員によるパスポートスキャンの改ざんを防止した方法</a></li>
<li><a href="../ja489874/index.html">LinuxからRust for Windows実行可能ファイルをクロスコンパイルする</a></li>
<li><a href="../ja489876/index.html">3つのモノリスの問題をどのように解決したか</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>