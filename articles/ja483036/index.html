<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛅 💆🏿 🙃 n-クイーンの完了問題-線形解法アルゴリズム 🐚 💪 🍖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ericgrig
 

 
 序文 
 研究の最初の段階で、私の結果の独立した検証のために、2人の素晴らしいオデッサプログラマー、Andrei Kiper（Lohica）とTimur Giorgadze（Luxoft）への感謝の言葉から序文を始めたいと思います。
 
 

1. 記事「ソリューション...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>n-クイーンの完了問題-線形解法アルゴリズム</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483036/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ericgrig</font></font><br>
<p> <br>
</p><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序文 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
研究の最初の段階で、私の結果の独立した検証のために、2人の素晴らしいオデッサプログラマー、Andrei Kiper（Lohica）とTimur Giorgadze（Luxoft）への感謝の言葉から序文を始めたいと思います。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事「ソリューションnクイーンの完了問題の線形アルゴリズム」が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（arXiv.org）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で2020年の初日の初め</font><font style="vertical-align: inherit;">に公開されました</font><font style="vertical-align: inherit;">。当初、記事はロシア語で書かれていたため、基本的なプレゼンテーションがここに表示され、翻訳があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このタスク、および他の多くのNP完全セット（ブール式（3-SAT）を満たすタスク、最大クリーク、または指定されたサイズのクリークを見つけるタスク...）は、さまざまなタイミングで、私の興味のある領域にありました。さまざまな計算実験に基づくアルゴリズムによる解決策を探していましたが、具体的な成功はありませんでした。それは、片方の腕の横棒にフィットする方法を学ぼうとしている人のようなものでした。結果はありませんが、すぐにすべてがうまくいくという希望があります。最後に、nクイーンの完了タスク（家族の一員として）に長く留まり、何かをしようと決心しました。ここでは、素晴らしいオデッサのジョークを思い出すのが適切です。「夕方にでこぼこの道に沿って郊外に戻る混雑したバスでは、女性の声が聞こえます-男性、あなたが完全に私に横になった場合は、少なくとも何かをしてください。」</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査は十分に長く続きました-ほぼ1年半。</font><font style="vertical-align: inherit;">一方で、これは研究プロセスで他のタスクが考慮されたという事実によるものであり、もう一方では、途中で困難な質問があり、それがなければ前進できませんでした。</font><font style="vertical-align: inherit;">それらのいくつかをリストします：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定行列にはn行あります。そのような選択の可能性の数がnの場合、行インデックスはどの順序で選択する必要がありますか。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラインが作成されると、このラインの残りのフリーポジションのどれを選択する必要があります。そのような選択の可能性の数は非常に大きいため、無限大の「近い親戚」と見なすことができます（たとえば、サイズ100のチェス盤のすべてのラインでフリーポジションを選択する方法の数） x 100は約10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">124です</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></li>
<li>,       ( ).  ,  ,    .        ,    –       . ,        .  ,    «».  « »,   ,     , «»,        ,    ,     ,          .    : «  ,   ».</li>
<li>      ,      ,  -    (Back Tracking),          .   «»   .    ,       .     ,      ,       .</li>
<li>,   ,     .   ,         .        ,           .    .    -,   .      ,  ,  – ,  ,  .      «  ».</li>
</ul> </li>
<li>,      ,    - .     ,       .      .     ,   –   .   ,         . ,       ,       -O(n).      ,  «  » —      Back Tracking (BT )     .   «»      ,    (  ).     ,    , ,       n = (320, ..., 22500),  ,   BT     –  50%. ,   50%   ,  «»  ,    «». (    ,       …)</li>
<li> ,        ,    ,   ,             , . .    ,     .      « ».  ,      NP-Complete           .      ,  –     ,     .          . (       NP-Complete        ,  ,        ).</li>
<li>  ()    –  ,  !        -,          .         <i>n-Queens Completion Problem</i>.     5-10 .   ,     :<br>
<br>
<ul>
<li>    <i>k</i>      .</li>
<li>          .     ,      .</li>
<li>  ,    .</li>
</ul><br>
<br>
         .   ,        :<br>
<br>
1. <i>Generarion_k_Queens_Composition</i> –     <i>k</i>      <i>n x n</i><br>
<br>
2.<i>Completion_k_Queens_Composition.m</i> –      ,   ,       (<b> </b>).<br>
<br>
3.<i>Validation_n_Queens_Solution.m</i> –    <i>n-Queens Problem</i>,     <i>k</i> .<br>
<br>
   . ,   ,    <i>1000  1000</i> ,  ,         (0.0015 .),    (0.0622 .),      (0.0003 .)   0.1 . ( ,     ,    ) <br>
 <br>
  (ericgrig@gmail.com),        ,       .     ,      ,       .</li>
<li>    ,   , , ,       . ,  ,        <i>NP-Complete</i>,    - . </li>
<li>       ,     . ,   (),     <i>France Fold Group</i>,          -   . ,   ,     ,   , ,          ,      <i></i>  <i>Deep Mind</i> (      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">(habr.com_Folding)</a>.  –   ,      .     – .                 .  - (, , , ),   «»--( ).  ,    ,    e-mail.        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の序文は記事自体と同じくらい長いことがわかりました。 Habréの家族向けプレゼンテーション形式を使用すると、自分の考えをより自由に表現できますが、サイズから判断すると、これをかなり自由に使用しました。簡単に書きたかったのですが、「いつものようになりました」。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS私は、Habrコミュニティのメンバーは、研究の結果を公表しようとしたときに私が遭遇した困難を知るのに興味があると思いました。記事が準備されたとき、私はJournal of Artificial Intelligence Research（JAIR）の要件に従って.tex形式に再フォーマットして送信しました。以前は同様のトピックに関する出版物がありました。特に注目すべきは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、C。Gent、I.-P.</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の記事です</font><i><font style="vertical-align: inherit;">。ジェファーソンとPナイチンゲール（2017）</font></i></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（n-クイーンの複雑さの完了）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで、問題の問題がNP-Completeセットに属していることを著者が証明し、この問題を解決しようとするときに遭遇する困難について話しました。結論として、著者は「チェスのルールを理解している人にとって、n-クイーンの完了は、すべての最も自然なNP-完了問題の1つである可能性があります」（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェスのルールを理解しているすべての人にとって、n-クイーンの完了タスクは、最も自然なNP完了タスク</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10日後、JAIRから「記事はジャーナルのフォーマットに対応していません」という文言で拒否されました。検討のために記事を取らなかった。そんな答えは期待していませんでした。ジャーナルが、ある問題を解決することが非常に困難であり、具体的な解決策を提供していないと著者が結論付けた記事を発表した場合、効果的な解決アルゴリズムを提供する記事は、検討のために確かに受け入れられると思いました。しかし、編集者たちはこの問題について自分の意見を持っていました。 （有能なスペシャリストがそこで働いていると思います。おそらく、「厚かましい」記事のタイトルとそこに記載されているすべてに疑問を投げかけられました。彼らは、「ある種の間違いがあり、フォーマットを参考に優しく送ってくれた"）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関連するトピックについて、査読済みの別の定期的な科学出版物を選択する必要がありました。ここで私は厳しい現実に直面しています。事実は、すべての雑誌の約80％が支払われているということです。すべての読者が記事を自由に利用できるように、雑誌に適切な金額を支払う必要があります。または、記事を「お辞儀」としてプレゼントする必要があります。この研究について知りたい。そして、最初と2番目のオプションは私には基本的に受け入れられません。いくつかの出版物に慣れるように努めたとき、私はこの出版社のラケットの方法に満足しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
情報への無料アクセスの原則を公言する次の雑誌は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、SMAI Journal of Computational Mathematicsでした。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。彼らはまた、同じ言葉遣いで断ったが、はるかに速く-2日で。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ジャーナルが選択されました：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">離散数学＆理論コンピューターサイエンス</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ここでの要件は単純です。まず、記事をarXiv.orgに公開する必要があります。その後、検討のために記事を登録します。さて、私たちはルールに従います</font><i><font style="vertical-align: inherit;">-arXiv.orgに</font></i><font style="vertical-align: inherit;">記事を提出しました</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">彼らは私に彼らが8時間で記事を発表するだろうと書いた。</font><font style="vertical-align: inherit;">ただし、これは8日後ではなく、8時間後には発生しませんでした。</font><font style="vertical-align: inherit;">記事はメンターによって「保持」され、9日後にのみ公開されました。</font><font style="vertical-align: inherit;">記事の形式と本質に不満はありませんでした。</font><font style="vertical-align: inherit;">私は、JAIRの場合と同様に、メンターは「これを実行してそれについて書く」ことの可能性について疑問を抱いていたと思います。</font><font style="vertical-align: inherit;">しばらくして、技術的なエラーを修正した後、記事が更新され、最終的な形で正月の夜にリリースされました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
研究成果の発表の段階では、論理的に説明できない問題があるかもしれないことを示すために、私はこれについて詳しく説明しなければなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、英語への翻訳が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（arXiv.org）で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公開された記事です</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.はじめに</font></font></h3><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-クイーン問題</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を定式化するためのさまざまなオプションの中で、検討中の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-クイーン完了</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク</font><font style="vertical-align: inherit;">は、その複雑さのために特別な立場にあります。彼らの研究において</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（全てでゲント（2017））</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことが示された</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-クイーンズ完了問題が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セットに属する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NP完全</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-クイーンズ完了NP完全と＃P-完全の両方であることを示しました</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。この問題の解決策は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NP-Completeの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セットから他の問題を解決するための道を開くかもしれないと想定されています</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は次のように定式化されます。</font><font style="vertical-align: inherit;">サイズのチェス盤に一貫して分布している</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クイーンの</font><font style="vertical-align: inherit;">構成があります</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この構成が完全な解に完成できることを証明し、少なくとも1つの解を与えるか、そのような解が存在しないことを証明する必要があります。ここでは、一貫して、</font><font style="vertical-align: inherit;">問題の3つの条件が満たされる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クイーンの</font><font style="vertical-align: inherit;">構成を意味</font><font style="vertical-align: inherit;">します。各行、各列、およびクイーンが配置されているセルを通過する左右の対角線で、クイーンが1つだけ配置されます。この形式の問題は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nauk（1850）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって最初に定式化されました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">１．１定義</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
以下、市松模様の辺の大きさを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ｎ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と表記する</font><font style="vertical-align: inherit;">。すべての</font><i><font style="vertical-align: inherit;">nの</font></i><font style="vertical-align: inherit;">場合、ソリューションは完了と呼ばれます</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クイーンは一貫してチェス盤に置かれます。他のすべての解決策、</font><font style="vertical-align: inherit;">正しく配置されたクイーンの</font><font style="vertical-align: inherit;">数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kが</font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より小さい場合</font><font style="vertical-align: inherit;">-コンポジションと呼びます。</font><font style="vertical-align: inherit;">完全なソリューションの前に完了することができる場合</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クイーンの</font><font style="vertical-align: inherit;">構成を</font><font style="vertical-align: inherit;">ポジティブ</font><font style="vertical-align: inherit;">と呼び</font><font style="vertical-align: inherit;">ます。したがって、完全なソリューションになるまで完了できない構成はネガティブと呼ばれます。サイズの「チェス盤」のアナログとして</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n×nの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、我々はまた、サイズの「解行列」を検討する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n×nのを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。例として、問題を解決するために開発されたすべてのアルゴリズムは、Matlab言語で提示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
研究は、コンピュータシミュレーション（計算シミュレーション）に基づいて行われました。これまたはその仮説をテストするために、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =（10、20、30、40、50、60、70、80、90、100、200、300、500、800、1000、3000、 5000、10000、30,000 50,000 80,000、10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、3×10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、5×10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、3×10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、5×10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、3×10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、5×10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、8 * 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）と、の値に応じて</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、十分に大きなサンプルを分析のために生成されました。このリストを「</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算実験を行うため</font><i><font style="vertical-align: inherit;">のn</font></i><font style="vertical-align: inherit;"> ” </font><i><font style="vertical-align: inherit;">値の基本的なリスト</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">すべての計算は通常のコンピュータで実行されました。</font><font style="vertical-align: inherit;">組み立て時（2013年初頭）、それはかなり成功した構成でした：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU-Intel Core i7-3820、3.60 GH、RAM-32.0 GB、GPU- NVIDIA Ge Forse GTX 550 Ti、ディスクデバイス-ATA Intel SSD、SCSI、OS- 64ビットオペレーティングシステムWindows 7 Professional</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このキットを単に「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desktop-13</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」と呼び</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.データの準備</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k個の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クイーンの</font><font style="vertical-align: inherit;">任意の構成の分布に関するデータの1次元配列を含むファイルを読み取ることから始まります</font><font style="vertical-align: inherit;">。データは以下のように作成されているものとします。ゼロ化された配列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q（i）= 0、i =（1、...、n）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があるとします。この配列のセルのインデックスは、解行列の行インデックスに対応します。</font><font style="vertical-align: inherit;">解行列の</font><font style="vertical-align: inherit;">任意の行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に位置</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">女王がいる</font><font style="vertical-align: inherit;">場合、割り当て</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q（i）= j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が実行され</font><font style="vertical-align: inherit;">ます。したがって、サイズ構成</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、非ゼロのセル配列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数に等しくなり</font><font style="vertical-align: inherit;">ます。 （たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q =（0、0、5、0、4、0、0、3、0、0）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マトリックス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 10</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上の</font><i><font style="vertical-align: inherit;">k = 3</font></i><font style="vertical-align: inherit;">クイーン</font><font style="vertical-align: inherit;">。クイーンはそれぞれ3、5、8行目に位置します：5、4、3）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.解n-クイーン問題の正しさを検証するためのアルゴリズム</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
研究には、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-クイーンズ問題の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解の正しさを短時間で判断できるアルゴリズムが必要</font><font style="vertical-align: inherit;">です。各行と各列のクイーンの位置の制御は簡単です。問題は対角制約についてです。問題のセルに対する対角線制限の影響を一意に特徴付ける特定の制御ベクトルの特定のセルに解行列の各セルをマッピングできれば、このような計算のための効果的なアルゴリズムを構築できます。次に、制御ベクトルのセルが空いているかビジーであるかに基づいて、決定行列の対応するセルが空いているか閉じているかを判断できます。このアイデアは</font><i><font style="vertical-align: inherit;">Sosic＆Gu（1990）</font></i><font style="vertical-align: inherit;">によって最初に使用され</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">女王の異なる立場間の対立状況の数を説明し、蓄積する。以下に示すアルゴリズムでも同様の考え方を使用していますが、ソリューションマトリックスのセルが空いているかビジーであるかを考慮するだけです。図1は、例として</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 x 8の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェス盤を示し、その</font><font style="vertical-align: inherit;">上に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルの</font><font style="vertical-align: inherit;">シーケンスが上に配置されています</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sx/0f/ws/sx0fwsydzdsy954rtlqpdwwigqg.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。 1.マトリックスセルの対角投影と制御配列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の対応するセルの対応のデモ例</font><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 8）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 最初の15個のセルを制御ベクトル</font><i><font style="vertical-align: inherit;">D1の</font></i><font style="vertical-align: inherit;">要素として考えます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。解行列の任意のセルからのすべての左対角線の投影は、制御ベクトル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルの1つに分類され</font><font style="vertical-align: inherit;">ます。実際、そのようなすべての投影は2つの平行線分内にあります。1つはマトリックスセル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（8.1）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をベクトル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のセルに</font><font style="vertical-align: inherit;">接続し</font><font style="vertical-align: inherit;">、2つ目</font><font style="vertical-align: inherit;">はマトリックス</font><font style="vertical-align: inherit;">セル（1.8）を制御ベクトル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15番目のセルに</font><font style="vertical-align: inherit;">接続し</font><font style="vertical-align: inherit;">ます。右対角投影についても同様の定義を行います。これを行うには、原点をセル1からセル9まで右に移動し、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">個のセルの</font><font style="vertical-align: inherit;">シーケンスを</font><font style="vertical-align: inherit;">制御ベクトル</font><i><font style="vertical-align: inherit;">D2の</font></i><font style="vertical-align: inherit;">要素</font><font style="vertical-align: inherit;">と見なします。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（図では、これらは9番目から24番目までのセルです。）解行列の任意のセルからのすべての右対角の投影は、2番目のセルから16番目まで（図では、10から）、この制御ベクトルのセルの1つに分類されます。 24日）。ここで、そのようなすべての投影は、平行線の2つのセグメントの間に配置されます。解行列のセル（8,8）をベクトル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セル16 </font><font style="vertical-align: inherit;">（図のセル24）に接続するセグメントと、解行列のセル（1,1）をセルに接続するセグメント2つの制御ベクトル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（図のセル10）。同じ左対角線上にある解行列のすべてのセルの投影は、左制御ベクトル</font><i><font style="vertical-align: inherit;">D1の</font></i><font style="vertical-align: inherit;">同じセルに分類されます</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それぞれ、同じ右対角線上にある解行列のすべてのセルの投影は、右制御ベクトル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じセルに分類され</font><font style="vertical-align: inherit;">ます。したがって、これらの2つの制御ベクトル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、決定行列の任意のセルのすべての対角抑制を完全に制御できるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
座標</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i、j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を持つ解行列のセル</font><i><font style="vertical-align: inherit;">が</font></i><font style="vertical-align: inherit;">空いているかビジーであるかを決定するために制御ベクトルのセルへの対角投影を使用するという考えは</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;">後に</font><i><font style="vertical-align: inherit;">Richards（1997）</font></i><font style="vertical-align: inherit;">でも実装された</font><font style="vertical-align: inherit;">ことに注意することが重要</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、ビットマスクを使用した操作に基づいて、すべてのソリューションに対して最速の再帰検索アルゴリズムの1つを提供します。重要な違いは、このアルゴリズムは、ソリューションマトリックスの最初の行（下）から、またはマトリックスの最後の行（上）から始まる、すべてのソリューションの順次検索用に設計されていることです。私たちが提案したアルゴリズムは、女王の位置の各線の数の選択は任意でなければならないという条件に基づいています。考えられるアルゴリズムにとって、これは基本的に重要です。上記の図1は、このホワイトペーパーで公開されているものと同様に作成したことに注意してください。</font><i><font style="vertical-align: inherit;">n-クイーンズ問題の</font></i></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
与えられた解</font><font style="vertical-align: inherit;">が正しいかどうか、または</font><i><font style="vertical-align: inherit;">k</font></i><font style="vertical-align: inherit;">からの与えられた構成が真である</font><font style="vertical-align: inherit;">かどうかをチェックするプログラム</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クイーンは以下の通りです。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.対角禁止を制御するには、2つの配列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1（1：n2）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2（1：n2）を作成します</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ここで、n2 = 2 * nと配列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B（1：n）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作成して、ソリューションマトリックスの列の占有率を制御します。これら3つの配列をゼロにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.正しくインストールされたクイーンの数のカウンターを導入します（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totPos = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。一貫して、最初の行から始まるサイクルで、提供されたすべてのクイーンの位置を考慮します。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q（i）&gt; 0の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のインデックスとこの行のクイーンの位置のインデックス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j = Q（i）に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基づいて</font><font style="vertical-align: inherit;">、制御配列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1（r）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2（t）に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対応するインデックスを作成します</font><font style="vertical-align: inherit;">。</font></font><br>
 <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j-i </font></font></i> <br>
 <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t = j + i</font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
3.すべての条件（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1（r）= 0、D2（t）= 0、B（j）= 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">が満たされている場合</font><font style="vertical-align: inherit;">、これはセル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ i、j）は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無料で、以前に確立されたクイーンによって形成された対角線制限の投影ゾーンに分類されません。この位置での女王の位置は正しいです。これらの条件の少なくとも1つが満たされない場合、そのような位置の選択はそれぞれ誤ったものになり、決定は誤ったものになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.ソリューションが正しい場合は、正しくインストールされたクイーンの数のカウンターをインクリメントし（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totPos = totPos + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、コントロール配列の対応するセルを閉じます：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（D1（r）= 1、D2（t）= 1、B（j）= 1）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。列のすべてのセルを閉じます</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、セル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i、j）で</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交差する左右の対角線に沿って配置されている解行列のセル</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5.残りのすべての位置について確認手順を繰り返します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらくこれは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-クイーン問題の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解の正しさを評価するための最も速いアルゴリズムの1つです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">溶液10のマトリックスのための百万位置の検証時間</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デスクトップ13は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">略「Enter」キーを押すの時間に相当する0.175秒です。</font><font style="vertical-align: inherit;">明らかに、このアルゴリズムは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関してカウント時間において線形</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.問題を解決するためのアルゴリズムの説明</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的な</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-クイーンの完了問題</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、古典的な非決定論的問題です。ソリューションの主な難しさは、状態空間が巨大な状況で、この行の行インデックスと位置インデックスを選択するという問題に関連しています。考えられるすべてのソリューションを検索する場合、このような問題は発生しません。状態空間内のすべての有効な検索ブランチを考慮する必要があり、それらが考慮される順序は重要ではありません。ただし、</font><i><font style="vertical-align: inherit;">kの</font></i><font style="vertical-align: inherit;">任意の構成</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クイーンは完全なソリューションになるまで完了する必要があります。この場合、既存の構成を適切に認識し、他のソリューションよりも速くソリューションを導く、行と列のインデックスを選択するアルゴリズムが必要です。このプロジェクトでは、次の一般的な位置に基づいて選択の質問を決定しました。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行またはこの行の任意の位置を他より優先する条件を定式化できない場合</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、以下に</font><i><font style="vertical-align: inherit;">基づくランダム選択アルゴリズムを使用します均等に分布した乱数</font></i><font style="vertical-align: inherit;">。状態空間が巨大である問題を解くための同様のランダム選択方法は非常に自然です。シリーズのエディションの1つ</font><i><font style="vertical-align: inherit;">DIMACSワークショップの</font></i><font style="vertical-align: inherit;">議事録</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1999）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複雑な問題を解決するためのアルゴリズムの開発におけるランダム選択の使用に完全に専念しました。ランダム選択アルゴリズムの正しい実装は、かなり生産的な解決策になる可能性がありますが、これは解決策を完了するために必要ですが、十分な条件ではありません。 Publication </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sosic and Gu（1990）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-クイーン問題</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を解くためにランダム選択アルゴリズムが使用された、最も初期の研究の1つです</font><font style="vertical-align: inherit;">。彼らが検討したアルゴリズムは、かなりシンプルで簡潔なアイデアに基づいています。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;">までの数字のシーケンスがあるとします</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらはランダムに再配置されます。このような数値のセットには重要な特性があります。これは、これらの数値がソリューションマトリックスの異なる行にクイーンポジション（1行あたり1つの数値）としてどのように分布されていても、最初の2つのルールは常に問題のステートメントで満たされるということです。各行と各列には複数の女王。ただし、このようにして得られた位置の一部のみが対角線の制約を受けなくなります。もう1つの部分は、以前に確立されたクイーンと「競合」する状態になります。この状況を回避するために、著者は完全なソリューションを取得するために、競合する位置を比較および交換する方法を使用しました。私たちが提案したアルゴリズムでは、問題を解決する各ステップで、クイーンが問題の行のセルに設定されるのは、セルが空いている場合のみです。</font></font><br>
<br>
<b>4.1      Back Tracking (BT)</b><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題の解決策を見つける過程で、解決策の連続した連鎖が行き止まりにつながる状況が発生する可能性があります。これは、非決定的問題の「遺伝的」特性です。この場合、前のステップのいずれかに戻り、このレベルに従ってタスクの状態を復元し、この位置からソリューションの検索を再開する必要があります。問題は、前のレベルのどれを返すか、そのようなレベルをいくつにするかです（レベルごとに、指定された数の正しくインストールされたクイーンで問題を解決する特定のステップを意味します）。明らかに、前に戻る決定レベルの選択は、その行の行インデックスまたは位置インデックスを選択するのと同じくらい重要です。したがって、この問題を解決するためのアプローチに関係なく、最初に、戻る基本レベルの数、およびこれらのレベルの1つに戻るためのメカニズムと条件を決定する必要があります。提案されたアルゴリズムでは、解行列を3つの基本レベルに分割します。これらは戻りポイントです。ソリューションの結果としてデッドロックが発生した場合、タスクのパラメーターに応じて、これら3つの基本レベルのいずれかに戻ります。最初の基本レベル（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は、問題の構成のデータ検証が完了したときの状態に対応します。これがプログラムの始まりです。次の2つの基本レベル（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">の値は</font><font style="vertical-align: inherit;">、行列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズによって異なります</font><font style="vertical-align: inherit;">。ソリューションマトリックスのサイズに対するこれらの基本値の経験的依存性は、多数の計算実験に基づいて確立されました。この依存関係をより正確に表すために、7から10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">までの考慮された間隔全体</font><font style="vertical-align: inherit;">を2つの部分に分割しました。してみましょう</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uはログ（n）を=</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その後、もし</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N &lt;3万</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その後、</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel2 = N -ラウンド（12.749568 * U3 - 46.535838 * U2 + 120.011829 * U - 89.600272）</font></font></i> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel3 = n-ラウンド（9.717958 * u3-46.144187 * u2 + 101.296409 * u-50.669273）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
それ以外の場合、</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel2 = n-ラウンド（-0.886344 * u3 + 56.136743 * u2 + 146.486415 * u + 227.967782）</font></font></i><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel3 = n-ラウンド（14 u3-253.661725 * u2 + 1584.713376 * u-3060.691342）</font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2ブロック構造</font></font></b><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アルゴリズムは、一連の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5つのイベントブロック</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の形式で構築され、</font><font style="vertical-align: inherit;">各イベントは問題の解決策の特定の部分の実行に関連付けられます。各ブロックの処理アルゴリズムは互いに異なります。 5つのブロックのうち3つだけがソリューションの順次チェーンを形成するのに役立ち、残りの2つのブロックは準備です。計算を開始するブロック番号の選択は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の値</font><font style="vertical-align: inherit;">と、構成のサイズを比較した結果</font><font style="vertical-align: inherit;">によって異なります。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLeve2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel3を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持つ</font><i><font style="vertical-align: inherit;">k</font></i><font style="vertical-align: inherit;">。例外は、値の間隔</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n =（7、...、99）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。これは、このセクションのアルゴリズムの動作の特殊性のため、「乱流ゾーン」と呼ぶことができます。値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n =（7、...、49）の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、コンポジションのサイズに関係なく、データを入力して監視した後、計算は4番目のブロックから始まります。値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n =（50、...、99）の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、コンポジションのサイズに応じて、2番目のブロックまたは4番目のブロックから計算が開始されます。上記のように、問題を解決する各ステップで、以前に確立されたクイーンによって作成された制限のゾーンに該当しないラインの位置のみが考慮されます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フリーと呼ばれるの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はこれらのポジションです</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムのこれら5つのブロックのそれぞれで実行される計算について簡単に説明しましょう。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3アルゴリズムの開始</font></font></b><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
データが入力され、構成が正しいかどうかがチェックされます。各検証ステップで、コントロールアレイのセルが変更されます。正しくインストールされたクイーンの数のカウントが保持されます。構成にエラーがない場合は、解決策が続行されます。それ以外の場合は、エラーメッセージが表示されます。検証が完了すると、メインアレイのコピーが作成され、このレベルで再利用できます。その後、制御は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Block-1に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4ブロック1</font></font></b><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
検索ブランチの形成の開始。考慮された</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開始位置としてチェス盤にあるクイーン。このコンポジションを完成させ、クイーンの総数が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel2になる</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まで、クイーンをチェス盤に</font><i><font style="vertical-align: inherit;">置く必要があり</font></i><font style="vertical-align: inherit;">ます。ここで使用されるアルゴリズムは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれます</font><font style="vertical-align: inherit;">。これは、対応する対角制限のないペアを求めて、ここで2つのランダムなインデックスリストを常に比較しているためです。これを行うには、次のアクションを実行し</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。a）2つのリストが形成されます。空き行インデックスのリストと空き列インデックスのリスト。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b）これらのリストのそれぞれでランダムに番号を並べ替えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c）ループ内で、値</font><i><font style="vertical-align: inherit;">（i、j）の</font></i><font style="vertical-align: inherit;">連続する各ペア</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、インデックス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が空き行インデックスのリストから選択され、インデックス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が空き列インデックスのリスト</font><font style="vertical-align: inherit;">から選択されて</font><font style="vertical-align: inherit;">いる場合、これは潜在的なクイーンポジションと見なされ、このポジションが対角例外の投影ゾーンに該当するかどうかがチェックされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対角線の例外のルールに違反していない場合、位置は正しいと見なされ、女王はこの位置に配置されます。その後、正しくインストールされたクイーンの数のカウンターがインクリメントされ、コントロールアレイの対応するセルが変更されます。位置</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i、j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が先に確立されたクイーンによって形成された対角線制限のゾーンに入る</font><font style="vertical-align: inherit;">場合、</font><font style="vertical-align: inherit;">何も変化せず、次の値のペアの考慮への移行が行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストのすべてのペアの比較サイクルが完了すると、斜めの除外ゾーンにある残りのインデックスに基づいて、残りの空き行と空き列のインデックスのリストが再び形成され、正しく配置されたクイーンの総数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（totPos）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">までこの手順が繰り返され</font><i><font style="vertical-align: inherit;">ます）</font></i><font style="vertical-align: inherit;">は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel2の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制限値以上にはなりません</font><font style="vertical-align: inherit;">。この条件が満たされると、制御は</font><i><font style="vertical-align: inherit;">ブロック2に</font></i><font style="vertical-align: inherit;">移され</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。解決策を検索した結果、残りの空き行と空き列のインデックスのリスト全体から、クイーンの場所に適したペアがないことが判明した場合、この場合、以前に生成されたコピーに基づいてコントロール配列の元の値が復元されます、制御は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロック1の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先頭に移され、</font><font style="vertical-align: inherit;">再カウントされます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5ブロック2</font></font></b><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このブロックは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロック3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">への移行の準備段階として機能します</font><font style="vertical-align: inherit;">。このレベルでは、残りの空き行（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freeRows</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">の数は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よりかなり少ないです</font><font style="vertical-align: inherit;">。これは、サイズの元の行列からイベントを転送することを可能にする</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n×nの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より小さいサイズのマトリクスに</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（：freeRows、1：freeRows 1）L</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。さらに、元の解行列の残りの空き行と空き列に関する情報に基づいて、配列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対応するセルにゼロが書き込まれ、</font><font style="vertical-align: inherit;">これらのセルが空いていることが示されます。このような</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「投影」</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遷移では、新しい行列の行と列のインデックスと、元の行列の対応するインデックスとの対応が維持されます。この問題を解決するプロセスでは、すべてのイベントがサイズ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxnの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期行列で展開されますが</font><font style="vertical-align: inherit;">、そのような行列はアクションの主要領域ですが、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際にはそのような行列は作成されず</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、行インデックス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A（1：n）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><font style="vertical-align: inherit;">この行列の</font><font style="vertical-align: inherit;">列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B（1：n）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L配列に加えて、2つの作業用配列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rAr（1：freeRows）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><i><font style="vertical-align: inherit;">tAr </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1：freeRows）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もこのブロック</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">形成され</font><font style="vertical-align: inherit;">、制御配列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対応するインデックスを保存します</font><font style="vertical-align: inherit;">。これは</font><font style="vertical-align: inherit;">、サイズ</font><i><font style="vertical-align: inherit;">nxnの</font></i><font style="vertical-align: inherit;">初期行列の</font><font style="vertical-align: inherit;">セル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i、j）に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のクイーンをインストールするとき</font><font style="vertical-align: inherit;">、その後</font><font style="vertical-align: inherit;">、元の「大きな」配列の対角例外の投影ゾーンに該当する</font><font style="vertical-align: inherit;">配列</font><i><font style="vertical-align: inherit;">Lの</font></i><font style="vertical-align: inherit;">セルを除外する必要</font><font style="vertical-align: inherit;">があるためです。斜めの制約は、サイズの初期のマトリックス内で制御されるため</font><i><font style="vertical-align: inherit;">のn×n </font></i><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">作業配列の存在</font><i><font style="vertical-align: inherit;">RAR</font></i><font style="vertical-align: inherit;">と</font><i><font style="vertical-align: inherit;">TAR</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンプライアンスを維持し、配列L内の禁止されたセルを変換できます。これにより、除外された位置の計算が大幅に簡素化されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このブロックで準備作業が完了すると、メインアレイのコピーが作成され、このレベルで再利用できるようになり、制御が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロック3に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移り</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.6ブロック-3</font></font></b><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このブロックでは、前のブロックで準備されたデータに基づくソリューション検索ブランチの形成が続行されます。クイーンが正しく設定されている行の数は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel-2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以上です</font><font style="vertical-align: inherit;">。インストールされたクイーンの数が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel-3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と等しくなるまで、ピッキングを続ける必要があり</font><font style="vertical-align: inherit;">ます。ここでは</font><i><font style="vertical-align: inherit;">Rand＆Rand</font></i><font style="vertical-align: inherit;">ソリューション検索アルゴリズムが使用されます</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、つまりクイーンの位置を形成するために、空きインデックスのリストの代わりに、2つのインデックスのみが使用されます。つまり、空き行のランダムインデックス値とこの行の空き位置のランダムインデックス値です。この手順は、配置されたクイーンの総数が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel-3の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値と等しくなるまで周期的に繰り返され</font><font style="vertical-align: inherit;">ます。この条件が満たされるとすぐに、制御は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Block-4に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移され</font><font style="vertical-align: inherit;">ます。計算の結果、検索ブランチが行き止まりであることが判明した場合、検索ブランチ構成のこのセクションは閉じられ、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロック3の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先頭に戻り</font><font style="vertical-align: inherit;">、そこから計算が再度繰り返されます。このため、すべての制御配列の初期値が復元されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.7ブロック4</font></font></b><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このブロックでは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロック5</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に制御を移すためのデータが準備され</font><font style="vertical-align: inherit;">ます。このステップでは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロック3の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手順を完了した後</font><font style="vertical-align: inherit;">、空き行の数（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nRow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）さらに小さくなっています。したがって、大きなアレイから小さなアレイにイベントを転送することも有益です。このアプローチにより、この段階で必要な残りのラインに必要な特性をすばやく決定する機会が得られます。特に重要なのは、そのような配列に基づいて、計算を完了する必要なく、多くのステップで検索ブランチの見込みを予測できることです。状態は非常に単純です。残りの空き線の中に空き位置がない線があることが判明した場合、検討中の検索分岐は閉じられ、制御は下位レベルのブロックの1つに移されます。ここで実行される準備アクションは、多くの点で</font><i><font style="vertical-align: inherit;">ブロック2で</font></i><font style="vertical-align: inherit;">行われたものと同様です。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。自由な行と自由な列の元のインデックスに基づいて、新しい2次元配列が形成され、そのゼロ値は元の解行列の自由な位置に対応します。さらに、特別な配列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E（1：nRow、1：nRow）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がこのブロック</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">作成されます。これ</font><font style="vertical-align: inherit;">に基づいて</font><font style="vertical-align: inherit;">、クイーンを設定する</font><font style="vertical-align: inherit;">位置</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i、j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">選択した場合に閉じられる残りのフリーラインのフリーポジションの数を決定できます。</font><font style="vertical-align: inherit;">ソース行列。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロック5に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制御を移す前</font><font style="vertical-align: inherit;">に、次のアクションが実行されます。a </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
）残りのすべての行の空の位置の合計が決定されます</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。b）問題の行の空の位置の合計の配列が昇順でソートされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c）残りのすべてのフリーラインにフリーポジションがある場合（つまり、このランクリストの最小値が0と異なる場合）、制御はブロック5に移されます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残りの行のいずれかに空き位置がないことが判明した場合、必要な配列は保存されたコピーに基づいて復元され、タスクのパラメーターに応じて、制御がいずれかの基本レベルに移されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
d）この第4レベルのすべてのコントロールアレイのバックアップコピーが作成されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.8ブロック5</font></font></b><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階が最終段階であり、ここでは、検索分岐の形成がより「バランスの取れた」「合理的な」方法で実行されます。これは「ラストマイル」であり、残っているフリーラインはごくわずかです。しかし同時に、これは最も難しい部分です。ソリューションの検索の分岐の形成の前の段階で潜在的に発生した可能性のあるすべてのエラーが、集計でここに表示されます-行に空の位置がないという形で。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このブロックのアルゴリズムは、2つのネストされたループに基づいて実行され、その中で3番目のループが実行されます。 3番目のサイクルの特徴は、2つの外部サイクルのパラメーターを変更せずに繰り返すことができることです。これは、生成された検索ブランチがデッドロックされている場合に発生します。そのような繰り返しの数は、制限値</font><i><font style="vertical-align: inherit;">repeatBoundを</font></i><font style="vertical-align: inherit;">超えません。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その最適値は計算実験に基づいて確立されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外側のループインデックスは、3番目のベースレベルでの計算後にフリーのままであった行インデックスの順次選択に関連付けられています。これは、以前にランク付けされたラインのリストに基づいて行われ、ライン内のフリーポジションの量によって行われます。選択は、最小数のフリーポジションを持つ線で始まり、その後のステップで昇順で行われます。このサイクル内で、2番目のサイクルが形成され、そのインデックスは、問題の行のすべてのフリーポジションのインデックスを反復します。最初のサイクルの目的は、このレベルの空き回線の1つのインデックスを選択することだけです。したがって、2番目のサイクルの目的は、対象のライン内の1つの空いている位置を選択することだけです。これらのアクションは、第3基本レベルでのみ発生します。そのような選択の後、確立されたクイーンの数が増加し、すべてのコントロールアレイの対応するセルが変更されます。さらに、制御は入れ子になった（3番目の）サイクルの内側に移され、その活動ゾーンはすでに残りのすべての空き回線です。このサイクル内で、行インデックスの選択とこの行の空き位置の選択は、次のルールに基づいて実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
a）</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フリーラインを選択し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。残りのすべてのフリーラインが考慮され、フリーポジションの数は各ラインで決定されます。空きポジションの数が最小の行が選択されます。これにより、空きポジションの数に関する状態が最小かつクリティカルである残りの行の一部の最後の空ポジションを除外する可能性に関連するリスクが最小限に抑えられます（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小リスクルール</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）ちなみに、このルールでは、この5番目のブロックの最初のサイクルのインデックスは、行内の空き位置の数の最小値を持つ行の順次選択で始まります。あるステップで、2つのラインに同じ最小数の空きポジションがあることが判明した場合、ランク付けされたリストの最初にリストされている2つのポジションの1つのインデックスがランダムに選択されます。同じ最小数の空き位置を持つ行の数が2を超える場合、ランク付けされたリストの最初にリストされている3つの位置の1つのインデックスがランダムに選択されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b）</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行の自由な位置の選択</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。問題のラインのすべてのフリーポジションのリストから、残りのすべてのラインのフリーポジションへのダメージを最小限に抑えるものを選択します。これは、以前に生成された配列Eに基づいて行われます。「最小の損傷」とは、残りのすべてのラインで</font><b><font style="vertical-align: inherit;">最小</font></b><font style="vertical-align: inherit;">の空き位置を除外する、特定のラインでのそのような位置の選択を意味します（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小の損傷ルール</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）行の2つ以上の空き位置が損傷基準に従って同じ最小値を持っていることが判明した場合、リストの最初にリストされている2つの位置の1つのインデックスがランダムに選択されます。残りの行の最小数のフリーポジションを除外するポジションを選択すると、このポジションでのクイーンのポジションに関連する「ダメージ」が最小限に抑えられます。これらのルールの両方を使用すると、検索ブランチを形成する各ステップでリソースをより合理的に使用できます。これにより、リスクが大幅に減少し、問題の構成に解決策がある場合、完全な解決策に任意の構成を選択する可能性が高くなります。ソリューションのいくつかのステップで、検討対象の残りの行の1つに空の位置がないことが判明した場合、この検索ブランチは閉じられます。この場合、バックアップに基づいて、すべてのコントロールアレイが復元され、繰り返し数のカウンターが境界値を超えていない場合</font></font><i>repeatBound</i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その後、1番目と2番目の外部サイクルのインデックスを変更せずに、3番目のネストされたサイクルの作業が再び繰り返されます。これは、関連する基準の最小値が一致した場合にランダムに選択したという事実によるものです。基本レベルと同じ条件で検索ブランチを再形成すると、このレベルで提供される「開始リソース」をより効率的に使用できます。入れ子になった3番目のサイクルの繰り返し開始回数には制限があり、制限値を超えると、このサイクルの動作が中断されます。その後、コントロール配列の値が復元され、制御は3番目のベースレベルのサイクルに移され、次のインデックス値に移動します。この手順は、完全な解が得られるまで周期的に繰り返されます。この基本レベルで、すべてのフリーラインとこれらのラインのすべてのフリーポジションを使用したことに注意してください。この場合、さまざまな基本レベルで繰り返される計算の総数に応じて、決定行列のサイズとコンポジションのサイズを考慮して、計算を再実行するために下位レベルの1つに戻るか、問題のコンポジションが不可能であると判断されます完全なソリューションを備えています。プログラムでは、アカウントの合計時間を制限するために、手続きが受け入れられますまたは、問題の構成が完全な決定まで完了することができないという判断が下される。プログラムでは、アカウントの合計時間を制限するために、手続きが受け入れられますまたは、問題の構成が完全な決定まで完了することができないという判断が下される。プログラムでは、アカウントの合計時間を制限するために、手続きが受け入れられます</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のどのレベルに戻されても、</font><i><font style="vertical-align: inherit;">バックトラッキング</font></i><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totSimBound回し</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か実行できません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この境界値は、nのさまざまな値の計算実験に基づいて選択されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.選択アルゴリズムの有効性の分析 </font></font></h3><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSetアルゴリズム</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の有効性</font><font style="vertical-align: inherit;">。このアルゴリズムの機能を分析するために、</font><font style="vertical-align: inherit;">この可能性が存在する限り</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSetおよびrandSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルに基づく</font><font style="vertical-align: inherit;">決定行列にクイーン</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">配置</font><font style="vertical-align: inherit;">するという計算実験が行われました</font><font style="vertical-align: inherit;">。検索ブランチが行き止まりに到達するか、完全なソリューションが得られるとすぐに、構成サイズ、ソリューション時間は固定され、テストが再度繰り返されました。計算実験は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値のベースリスト全体に対して実行されました</font><font style="vertical-align: inherit;">。値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n =（30、40、...、90、100、200、300、500、800、1000）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の繰り返しテストの数は</font><i><font style="vertical-align: inherit;">100 </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">万</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に等しく</font><font style="vertical-align: inherit;">、残りの値はテストの数、</font><i><font style="vertical-align: inherit;">nの</font></i><font style="vertical-align: inherit;">増加に伴い</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、徐々に100000から100に減少しました。計算実験の結果を分析すると、次の結論を導き出すことができます</font><i><font style="vertical-align: inherit;">。a）randSet＆randSetプロシージャ</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の最初のサイクルのみの結果として、</font><font style="vertical-align: inherit;">平均してすべてのクイーンの約60％が正しく配置されます。以下のために</font><i><font style="vertical-align: inherit;">、N</font></i><font style="vertical-align: inherit;"> = 100、正しく配置されたクイーンの数は60.05パーセントです。 nの値が増加すると、この値は徐々に減少し、n = 10 </font><sup><font style="vertical-align: inherit;">7の</font></sup><font style="vertical-align: inherit;">場合、59.97％になります。</font><font style="vertical-align: inherit;">
b）得られた構成の長さの値の分布のヒストグラムは、決定行列</font><i><font style="vertical-align: inherit;">nの</font></i><font style="vertical-align: inherit;">サイズに関係なく、同じ形式です</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"></font><br>
 <br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。さらに、それらはすべて特徴的な特徴を持っています-分布の左側（モード値に対して）は右側とは異なります。図2では、例として、図1の対応するヒストグラムを示し</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fu/h3/xy/fuh3xyqsx5ro7zx8ru7b66fliy8.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。 2. randSetおよびrandSetモデルのさまざまな長さのソリューションの分布のヒストグラム（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100、サンプルサイズ= 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100。ヒストグラムは、2つの異なるイベントの頻度分布から収集されたようです。これは、分布の左側と右側の部分でのイベントの発生頻度が異なるためです。この分布を説明するには、正規分布の密度の2つの関数を使用するのが最も適切です。1つはモーダル値までの区間をカバーし、もう1つはモーダル値の後の区間をカバーします。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c）</font><font style="vertical-align: inherit;">このアルゴリズムに基づいて決定行列で設定できる</font><font style="vertical-align: inherit;">クイーンの平均数（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とともに増加し</font><font style="vertical-align: inherit;">ます。図3からわかるように、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean / n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比</font><font style="vertical-align: inherit;">のマトリックスサイズ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">への依存性のグラフが示されていますが</font><font style="vertical-align: inherit;">、この比</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">マトリックスサイズの</font><font style="vertical-align: inherit;">増加とともに増加します。たとえば、</font></font><br>
<img src="https://habrastorage.org/webt/wi/5b/kr/wi5bkrcaftlplvllyxfmek0lycg.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図3.比率</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean / </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、さまざまなサイズの解行列に対する</font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;">の値</font><font style="vertical-align: inherit;">への依存性</font><font style="vertical-align: inherit;">。モデルは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSetであり</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は解の長さの平均値です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 サイズの行列のための場合は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100×100、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位置を選択するためのアルゴリズムである</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「停止せずに」クイーンを平均で89行に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">できるよう</font><font style="vertical-align: inherit;">になり</font><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">1000x1000</font></i><font style="vertical-align: inherit;">マトリックスの場合</font><font style="vertical-align: inherit;">、そのような行の数は平均で967に増加します</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。d）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSetアルゴリズムに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基づいて、</font><font style="vertical-align: inherit;">完全なソリューションを得ることができますが、このアプローチの「生産性」は非常に低いです。図4から分かるように</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7w/gt/jg/7wgtjgp2ria3lxqff4ouw9zqzpw.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。 4. </font><i><font style="vertical-align: inherit;">nの</font></i><font style="vertical-align: inherit;">増加に伴う</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSetおよびrandSetモデル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">完全な解を得る確率の減少</font><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;"> = 7の</font><font style="vertical-align: inherit;">
値で</font><font style="vertical-align: inherit;">は、完全な解を得る確率は</font><i><font style="vertical-align: inherit;">0.057</font></i><font style="vertical-align: inherit;">です。さらに、</font><i><font style="vertical-align: inherit;">nの</font></i><font style="vertical-align: inherit;">増加に伴い</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全な解を得る確率は急速に減少し、漸近的にゼロに近づきます。値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 48 </font><font style="vertical-align: inherit;">から始めて、</font><font style="vertical-align: inherit;">完全な解を得る確率は10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-6の</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーダーです</font><font style="vertical-align: inherit;">。閾値の後に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 70の後続の値に対して</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ない単一の完全な解決策は、（テストの数に等しいで得た</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">百万</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
e）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSetモデル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は非常に高速で検索ブランチを生成します。以下のために</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1000、組成物を得るための平均時間は0.0015秒です。構成の平均長は967です。したがって、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平均時間は2.6754秒で、平均の曲の長さは999793です</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。f）</font><font style="vertical-align: inherit;">非常にまれなケースで</font><i><font style="vertical-align: inherit;">randSetおよびrandSetモデル</font></i><font style="vertical-align: inherit;">が完全な解を導くことができる</font><font style="vertical-align: inherit;">短い間隔</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;= 70を</font><font style="vertical-align: inherit;">除いて、</font><font style="vertical-align: inherit;">他のすべての場合、決定分岐は否定的な構成の形成で終了します。完全なソリューションになるまで完了できません。したがって、</font><i><font style="vertical-align: inherit;">randSet＆randSetアルゴリズム</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これには重要な利点があります-検索ブランチの形成が高速であり、重大な欠点は、コンポジションのサイズが特定のしきい値を超える場合、このアルゴリズムは、完全なソリューションまで完了することができないコンポジションの形成につながることです。この欠点を克服するために、しきい値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel-2に達した</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ときに検索ブランチの形成を停止し</font><font style="vertical-align: inherit;">ます。</font><i><font style="vertical-align: inherit;">rand＆rand</font></i></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アルゴリズムの効率</font><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">rand＆rand</font></i><font style="vertical-align: inherit;">アルゴリズムの機能を決定</font><font style="vertical-align: inherit;">するために、</font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;">値の基本リストに対してかなり詳細なコンピューターシミュレーションが実行されました</font><font style="vertical-align: inherit;">。同様に</font><i><font style="vertical-align: inherit;">randSet＆randSetモデル</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどの場合、再テストの回数は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100万回に相当しました</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。他の値では、テストの数は100,000から100に徐々に減少しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どちらのアルゴリズムもランダム選択の原理に基づいています。したがって、ここで導き出される結論は、基本的に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSetとrandSetモデル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用に定式化された結論と同じになると予想されます</font><font style="vertical-align: inherit;">。ただし、これらには基本的な違いがあり、次の点で構成されています</font><i><font style="vertical-align: inherit;">。a</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデル</font><font style="vertical-align: inherit;">は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSetモデル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほど「ハード」に機能しません</font><font style="vertical-align: inherit;">。 「提供された機会の合理的な使用の指標」について話す場合、</font><i><font style="vertical-align: inherit;">rand＆rand</font></i><font style="vertical-align: inherit;">モデル</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのステップで、リソースをより合理的に使用します。これにより、たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 30の場合、このモデルで0.00170の完全な解が得られる確率は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSetおよびrandSetモデル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の同様の値</font><i><font style="vertical-align: inherit;">0.00011の</font></i><font style="vertical-align: inherit;"> 15倍になり</font><font style="vertical-align: inherit;">ます。さらに、ここでは、しきい値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 370までは、100万回のテスト中に少なくとも1つの完全な解を得る確率が残っています。このしきい値の後</font><font style="vertical-align: inherit;">、テスト数が100万に等しい</font><font style="vertical-align: inherit;">後続の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">について、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルに基づいて</font><font style="vertical-align: inherit;">1つの完全な解が得られませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b）このアルゴリズムは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSetアルゴリズム</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よりもはるかに低速</font><i><font style="vertical-align: inherit;">です</font></i><font style="vertical-align: inherit;">。の場合</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1000でサイズ967のコンポジションを生成すると、1つのコンポジションを取得する平均時間は0.0497秒になります。これは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSetモデル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の対応する値0.0015より33長くなり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランダム選択の2つの基本的に類似した方法の違いの理由は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSetモデル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、計算を高速化するために、残りのリストからのランダム選択が各ステップで実行されないためです。代わりに、要素のペアがランダムに再配置された2つのリストからインデックスのペアが順次選択されます。このような選択は完全にランダムではありませんが、問題のロジックにうまく適合し、すばやくカウントすることができます。</font><i><font style="vertical-align: inherit;">rand＆rand</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アルゴリズムの動作を視覚的に示すため</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次の実験が行われました：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
a）サイズ</font><i><font style="vertical-align: inherit;">100x100の</font></i><font style="vertical-align: inherit;">チェス盤の場合</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、任意のラインでのクイーンの位置の各ステップの後、残りの各フリーラインのフリーポジションの数が決定されました。したがって、問題を解決する各ステップの後に、フリーラインのリストと、これらのラインのフリーポジションの数の対応するリストを受け取りました。これにより、問題のマトリックスの列のインデックスが横軸に沿ってプロットされ、残りの自由な位置の数が縦軸に沿ってプロットされたグラフを作成することが可能になりました。比較のために、位置の順次選択のモデルについても計算を行いました。順次選択とは、以下を意味します。最初の行が考慮され、リストの最初の空いている位置が選択されます。次に、2行目が考慮されます。このリストでは、リストの最初の空いている位置も選択されます。図5および6</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y1/b5/vc/y1b5vcf2es-tsqteleekwvp5dly.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。 5.クイーンの配置後、残りのフリーラインのフリーポジションの数を減らす。順番に定期的にポジションを選択します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検討中のモデルに対応する結果が表示されます。わかりやすくするために、グラフはステップ（10、40、60）の後の結果のみを示しています。位置を順次選択するモデルでは、63番目の行に空き位置がないために検索ブランチが壊れるため、最後のモデルは62番目のステップの後のグラフです。一方、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデル</font><font style="vertical-align: inherit;">では、クイーンを配置する70番目のステップの後に最後のグラフが表示されますが、ここでは、正しく配置されるクイーンの平均数が89に達し、シーケンシャルモデルよりも26ステップ多くなっています。</font><i><font style="vertical-align: inherit;">rand＆rand</font></i><font style="vertical-align: inherit;">モデルのグラフの奇妙なビュー</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行インデックスは残りの空き行からランダムに選択されるため、ソリューションマトリックス全体にランダムに分散されます。これら2つの図を比較すると、位置選択の順次モデルでは、自由な位置の数の変動範囲が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルよりも高いことが</font><i><font style="vertical-align: inherit;">わかり</font></i><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。これは、通常の選択では、対角制約により残りの行の空き位置が不均一に除外されるためです。これにより、一部の行では、空の位置の数の減少率が他の行よりも高くなります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9y/mn/m6/9ymnm6wo_jsazg8_u474pjngke8.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。 6.クイーンの配置後、残りのフリーラインのフリーポジションの数を減らす。位置決めモデルは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対照的に、空き行インデックスと空き列インデックスをランダムに選択すると、クイーンの位置が決定行列の「領域」に均等に分散され、残りの行の空き位置の数の「平均」削減率が低下します。したがって、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムの機能を考慮</font><font style="vertical-align: inherit;">して、プログラムでそれを使用して、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel-3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベルに</font><i><font style="vertical-align: inherit;">到達する</font></i><font style="vertical-align: inherit;">までソリューション検索ブランチの形成を継続し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
選択アルゴリズム（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSet、rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）がそれほど効率的でなかったとしても、アルゴリズムを開発するときに他のランダム選択方法を使用する</font><font style="vertical-align: inherit;">必要があることに注意してください</font><font style="vertical-align: inherit;">。これは問題の説明によるものです。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-クイーンの完了問題</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。問題を解決する特定の最適なアルゴリズムがあると想像すると、そのようなアルゴリズムは入力で常に特定のランダムな行と列のインデックスのセットを受け取ります。毎回、非常に多様な可能性から、行と列のインデックスの新しいランダムなセットになります。このようなさまざまなランダム構成でアルゴリズムを「取り込む」ことができるようにするには、アルゴリズム自体をランダム選択に基づいて構築する必要があります。マッチングは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロックの鍵のようなもので</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なければなりません</font><font style="vertical-align: inherit;">。この原則に基づいてアルゴリズムを構築する場合、</font><i><font style="vertical-align: inherit;">k</font></i><font style="vertical-align: inherit;">からの一貫した構成</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">女王は、意思決定サイクルの初期（開始）位置と見なされます。</font><font style="vertical-align: inherit;">さらに、目的は、特定の組成の解が見つかるか、そのような解が存在しないことが証明されるまで、解の検索の分岐の形成を継続することだけです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.最小リスクルールの使用例（n = 100）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソリューションの検索の初期段階で、行の空き位置の数が重要でない場合、空き行のインデックスまたはこの行の位置のインデックスの選択は致命的ではありません。ただし、最後の段階で、一部の行の空き位置の数が1または2の場合、この場合は、別の選択アルゴリズムを選択する必要があります。このレベルでは、ランダム選択アルゴリズム</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は機能しなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランダム選択アルゴリズムが機能しない理由は、次の簡単な例で説明できます。問題を解決するいくつかのステップで、残りの行</font><i><font style="vertical-align: inherit;">i </font></i><i><sub><font style="vertical-align: inherit;">1</font></sub></i><i><font style="vertical-align: inherit;">、i </font></i><i><sub><font style="vertical-align: inherit;">2</font></sub></i><i><font style="vertical-align: inherit;">、...、i </font></i><i><sub><font style="vertical-align: inherit;">k</font></sub></i><font style="vertical-align: inherit;">のnの任意の値について考えます</font><i><font style="vertical-align: inherit;">。</font></i></font><i><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">括弧内に示されている空きポジションの数は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1）、i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2）、i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（4）、i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（5）、i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（3）、i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（4）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などです。ランダムに任意の行を選択し、行i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1を</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選択しない場合、</font><font style="vertical-align: inherit;">フリーポジションは1つだけです。これは、選択したラインでのクイーンの位置に関連する斜めの禁止が、ラインで唯一のフリーポジションのクローズにつながる可能性がある場合に、リスク状況につながる可能性があります。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1。</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これにより、ソリューションが停止します。すべての行のうち、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、...、i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行インデックスの選択に対して最も脆弱で敏感なのは、行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。このような状況では、最初にステータスが最も重要であり、問​​題を解決するためのリスクをもたらす行を選択する必要があります。したがって、問題を解決する最後の段階では、各ステップで、最小限のリスクの単純なアルゴリズムに基づいて線の位置を選択する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
わかりやすくするために、例として、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100 x 100</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マトリックスについて考えてみましょう</font><font style="vertical-align: inherit;">。これは、88番目のステップの後の、実際のソリューションを形成する最後の段階です。タスクが完了するまで、12個のフリーラインが残っていました。それぞれにフリーポジションの数が見つかりました（ラインはフリーポジションの数の昇順でランク付けされています）。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステップ-89-25（1）、12（2）、22（2）、82（2）、88（2）、7（3）、64（3）、3（4）、76（4）、91 （4）、4（5）、96（5）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -空き行のインデックスを示し、括弧内に-この行の空き位置の数を示します。最小リスクルールに従って、問題を解決する89番目のステップで、行25が選択され、その中にある1つの空き位置が選択されます。再集計の結果、11本の空きラインが残っています：</font><i><font style="vertical-align: inherit;">ステップ</font></i><font style="vertical-align: inherit;"> -90-7 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2）、12（2）、22（2）、82（2）、88（2）、3（3）、64（3）、 76（3）、4（4）、91（4）、96（4）。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ご覧のように、最初の5行の空き位置の数は同じで2です。したがって、最初の3行の1つのインデックスがランダムに選択されます。</font><font style="vertical-align: inherit;">この場合、12番目の行が選択され、この行に残っている2つの行の位置は、最小の損傷につながります。</font><font style="vertical-align: inherit;">したがって、ソリューションを形成する91番目のステップでは、10本のフリーラインがあります。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステップ-91-22（1）、3（2）、7（2）、82（2）、88（2）、64（3） 76（3）、91（3）、4（4）、96（4）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このステップでは、ライン22が選択され、その中にある1つの自由な位置が選択されます。</font><font style="vertical-align: inherit;">同様に続けて、次の一連の決定が形成されました（表1）。</font><font style="vertical-align: inherit;">選択した行のインデックスは太字で表示されます。</font></font><br>
<div class="scrollable-table"><table>
<caption><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表1.最小リスクルールの使用例（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100）。</font></font></b><br>
</caption>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステップ</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">89</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25（1）</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12（2）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22（2）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">82（2）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7（3）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64（3）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3（4）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">76（4）</font></font></td>
<td>91(4)</td>
<td>4(5)</td>
<td>96(5)</td>
</tr>
<tr>
<td>90</td>
<td>7(2)</td>
<td><b>12(2)</b></td>
<td>22(2)</td>
<td>82(2)</td>
<td>3(3)</td>
<td>64(3)</td>
<td>76(3)</td>
<td>4(4)</td>
<td>91(4)</td>
<td>96(4)</td>
<td></td>
</tr>
<tr>
<td>91</td>
<td><b>22(1)</b></td>
<td>3(2)</td>
<td>7(2)</td>
<td>82(2)</td>
<td>64(3)</td>
<td>76(3)</td>
<td>91(3)</td>
<td>4(4)</td>
<td>96(4)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>92</td>
<td><b>88(1)</b></td>
<td>3(2)</td>
<td>7(2)</td>
<td>82(2)</td>
<td>91(2)</td>
<td>64(3)</td>
<td>76(3)</td>
<td>4(4)</td>
<td>96(4)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>93</td>
<td><b>3(1)</b></td>
<td>7(2)</td>
<td>76(2)</td>
<td>82(2)</td>
<td>91(2)</td>
<td>4(3)</td>
<td>64(3)</td>
<td>96(4)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>94</td>
<td><b>76(1)</b></td>
<td>4(2)</td>
<td>7(2)</td>
<td>82(2)</td>
<td>91(2)</td>
<td>64(3) </td>
<td>96(4)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>95</td>
<td><b>91(1)</b></td>
<td>7(2)</td>
<td>82(2)</td>
<td>64(3)</td>
<td>96(3)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>96</td>
<td><b>4(1)</b></td>
<td>82(1)</td>
<td>7(2)</td>
<td>64(3)</td>
<td>96(3)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>97</td>
<td><b>7(1)</b></td>
<td>82(1)</td>
<td>64(2)</td>
<td>96(3)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>98</td>
<td><b>82(1)</b></td>
<td>64(2)</td>
<td>96(2)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>99</td>
<td>64(1)</td>
<td><b>96(1)</b></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>100</td>
<td><b>64(1)</b></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この特定の例では、12中11のケースで、残りのフリーラインのリストに少なくとも1つのラインがあり、フリーポジションが1つだけ残っているという状況がありました。最小リスクルールを使用しないと、最後まで到達できません。フリーラインのインデックスを選択する際に1つの「間違った動き」があるため、残りのフリーラインの1つに存在していた唯一のフリーポジションが破壊される可能性が最も高くなります。これが、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet x randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand x rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムのみ</font><font style="vertical-align: inherit;">を使用して完全なソリューションを取得する場合、最終段階でソリューションが行き止まりに</font><font style="vertical-align: inherit;">なる理由です</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最小リスクアルゴリズムは単純な日常的な意味を持ち、意思決定によく使用されることに注意してください。</font><font style="vertical-align: inherit;">たとえば、医師はまず生命の状態が最も重要な患者を操作します。同様に、農家は深刻な干ばつで作物を救おうとします。まず、最も危険な状態にある地域に水をやります...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.アルゴリズムの効率の分析 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nのさまざまな値に対するアルゴリズムの効率を評価するために、（合計時間に関して）かなり長い計算実験が行われました。最初は、nの任意の値に対するnQueens問題の解の配列を生成するために、かなり高速なアルゴリズムが開発されました。次に、このプログラムに基づいて、n個の値の基本的なリストのソリューションの大規模なサンプルが作成されました。ソリューションの取得されたサンプルのサイズnQueens Problemは、nのさまざまな値に対してそれぞれ等しくなりました：（10）-1000、（20、30、...、90、100、200、300、500、800、1000、3000、5000、10,000）- -10000、（30000、50000、80000）-5000、（105、3 * 105）-3000、（5 * 105、8 * 105、106）-1000、（3 * 106）-300、（ 5 * 106）-200、（10 * 106）-100、（30 * 106）-50、（50 * 106）-30、（80 * 106、100 * 106）-20。ここでは、括弧内にn個の値のリストが示され、2つのダッシュは取得されたソリューションのサンプルサイズを示します。その後、溶液の各サンプルに基づいて、任意のサイズのランダムな組成が形成されました。たとえば、n = 1000の10,000解のそれぞれに対して、任意のサイズの100個のランダムな組成が形成されました。その結果、100万曲のサンプルが得られた。既存のソリューションに基づいて形成された任意のサイズの構成は、少なくとも1回は完全なソリューションまで完了することができるため、タスクは、n-Queens Completion Problemソリューションアルゴリズムに基づいて、生成されたサンプルから完全なソリューションまで各構成を完了することでした。 。各ステップで検討中のアルゴリズムでは、チェス盤上のクイーンの正しい配置がチェックされるため、ここでは原則として、溶液の各サンプルに基づいて、任意のサイズのランダムな組成が形成されました。たとえば、n = 1000の10,000解のそれぞれに対して、任意のサイズの100個のランダムな組成が形成されました。その結果、100万曲のサンプルが得られた。既存のソリューションに基づいて形成された任意のサイズの構成は、完全なソリューションになるまで少なくとも1回完了することができるため、タスクは、生成されたサンプルからn-Queens Completion Problemソリューションアルゴリズムに基づいて完全なソリューションまで各構成を完了することでした。 。各ステップで検討中のアルゴリズムでは、チェス盤上のクイーンの正しい配置がチェックされるため、ここでは原則として、溶液の各サンプルに基づいて、任意のサイズのランダムな組成が形成されました。たとえば、n = 1000の10,000解のそれぞれに対して、任意のサイズの100個のランダムな組成が形成されました。その結果、100万曲のサンプルが得られた。既存のソリューションに基づいて形成された任意のサイズの構成は、少なくとも1回は完全なソリューションまで完了することができるため、タスクは、n-Queens Completion Problemソリューションアルゴリズムに基づいて、生成されたサンプルから完全なソリューションまで各構成を完了することでした。 。各ステップで検討中のアルゴリズムでは、チェス盤上のクイーンの正しい配置がチェックされるため、ここでは原則として、任意のサイズの100のランダムな構成が形成されました。その結果、100万曲のサンプルが得られた。既存のソリューションに基づいて形成された任意のサイズの構成は、少なくとも1回は完全なソリューションまで完了することができるため、タスクは、n-Queens Completion Problemソリューションアルゴリズムに基づいて、生成されたサンプルから完全なソリューションまで各構成を完了することでした。 。各ステップで検討中のアルゴリズムでは、チェス盤上のクイーンの正しい配置がチェックされるため、ここでは原則として、任意のサイズの100のランダムな構成が形成されました。その結果、100万曲のサンプルが得られた。既存のソリューションに基づいて形成された任意のサイズの構成は、少なくとも1回は完全なソリューションまで完了することができるため、タスクは、n-Queens Completion Problemソリューションアルゴリズムに基づいて、生成されたサンプルから完全なソリューションまで各構成を完了することでした。 。各ステップで検討中のアルゴリズムでは、チェス盤上のクイーンの正しい配置がチェックされるため、ここでは原則として、次に、生成されたサンプルからn-Queens Completion Problemソリューションアルゴリズムに基づいた完全なソリューションまで、各構成を完了する必要がありました。各ステップで検討中のアルゴリズムでは、チェス盤上のクイーンの正しい配置がチェックされるため、ここでは原則として、次に、生成されたサンプルからn-Queens Completion Problemソリューションアルゴリズムに基づいて完全なソリューションまで各構成を完了することがタスクでした。各ステップで検討中のアルゴリズムでは、チェス盤上のクイーンの正しい配置がチェックされるため、ここでは原則として、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偽陽性の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定（つまり、誤って正しいと見なす誤った決定）。ただし、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォールスネガティブ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューション</font><font style="vertical-align: inherit;">が存在する可能性があります。</font><font style="vertical-align: inherit;">既存のソリューションに基づいて形成されたコンポジションが、ソリューションが完了するまでプログラムによって完了しない場合（すべてのコンポジションにソリューションがあることがわかっています）。このような広い範囲のn値で計算実験を実行する場合、次の目標を設定します：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
a）アルゴリズムの時間の複雑さを決定する、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b）nのさまざまな値のFalse Negativeソリューションの確率を決定する、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c）バックトラッキング手順が使用される頻度を決定するnの異なる値。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような計算実験の結果を表2に示します。</font></font><br>
<div class="scrollable-table"><table>
<caption><b> 2.         n.</b><br>
<i>n</i> –   ; <i>m</i> –   ; t<sub>mean</sub>, t<sub>min</sub>, t<sub>max</sub> – ,     ; t90<sub>mean</sub> –   ,    10%    ; FalseNeg( FalseNegative) –  ,      ; <i>t<sub>row</sub> = t<sub>mean</sub>*10<sup>6</sup>/ n</i>,   10<sup>6</sup>   ,            <i>n x n</i>.<br>
</caption>
<tbody><tr>
<th>n</th>
<th>m</th>
<th>t<sub>mean</sub></th>
<th>t90<sub>mean</sub></th>
<th>t<sub>min</sub></th>
<th>t<sub>max</sub></th>
<th>FalseNeg</th>
<th>t<sub>row</sub></th>
</tr>
<tr>
<td>10</td>
<td>5000</td>
<td><b>0.001010</b></td>
<td>0.000532</td>
<td>0.000168</td>
<td>0.080673</td>
<td>2</td>
<td>1.0102</td>
</tr>
<tr>
<td>20</td>
<td>10<sup>5</sup></td>
<td><b>0.003589</b></td>
<td>0.001809</td>
<td>0.000197</td>
<td>0.363096</td>
<td>5</td>
<td>1.7945</td>
</tr>
<tr>
<td>30</td>
<td>10<sup>5</sup></td>
<td><b>0.008025</b></td>
<td>0.003793</td>
<td>0.000244</td>
<td>0.495716</td>
<td>10</td>
<td>2.6752</td>
</tr>
<tr>
<td>40</td>
<td>10<sup>5</sup></td>
<td><b>0.014323</b></td>
<td>0.009127</td>
<td>0.000252</td>
<td>0.965817</td>
<td>7</td>
<td>3.5807</td>
</tr>
<tr>
<td>50</td>
<td>10<sup>5</sup></td>
<td><b>0.005357</b></td>
<td>0.003589</td>
<td>0.000313</td>
<td>0.441711</td>
<td>9</td>
<td>10.7146</td>
</tr>
<tr>
<td>60</td>
<td>10<sup>5</sup></td>
<td><b>0.005991</b></td>
<td>0.004103</td>
<td>0.000340</td>
<td>0.013738</td>
<td>10</td>
<td>9.9852</td>
</tr>
<tr>
<td>70</td>
<td>10<sup>5</sup></td>
<td><b>0.006533</b></td>
<td>0.004566</td>
<td>0.000368</td>
<td>0.583897</td>
<td>8</td>
<td>9.3328</td>
</tr>
<tr>
<td>80</td>
<td>10<sup>5</sup></td>
<td><b>0.006975</b></td>
<td>0.004987</td>
<td>0.000394</td>
<td>0.635676</td>
<td>7</td>
<td>8.7187</td>
</tr>
<tr>
<td>90</td>
<td>10<sup>5</sup></td>
<td><b>0.006912</b></td>
<td>0.004763</td>
<td>0.000393</td>
<td>1.012710</td>
<td>4</td>
<td>7.6840</td>
</tr>
<tr>
<td>100</td>
<td>10<sup>5</sup></td>
<td><b>0.007264</b></td>
<td>0.005107</td>
<td>0.000419</td>
<td>0.692387</td>
<td>4</td>
<td>7.2641</td>
</tr>
<tr>
<td>300</td>
<td>10<sup>5</sup></td>
<td><b>0.013518</b></td>
<td>0.009496</td>
<td>0.000986</td>
<td>3.349766</td>
<td>3</td>
<td>4.5060</td>
</tr>
<tr>
<td>500</td>
<td>10<sup>5</sup></td>
<td><b>0.028194</b></td>
<td>0.014554</td>
<td>0.001541</td>
<td>4.558749</td>
<td>2</td>
<td>5.6388</td>
</tr>
<tr>
<td>800</td>
<td>10<sup>5</sup></td>
<td><b>0.049385</b></td>
<td>0.022735</td>
<td>0.002367</td>
<td>6.192782</td>
<td>1</td>
<td>6.1731</td>
</tr>
<tr>
<td>1000</td>
<td><b>10<sup>6</sup></b></td>
<td><b>0.062157</b></td>
<td>0.027727</td>
<td>0.002943</td>
<td>8.015123</td>
<td>0</td>
<td>6.2156</td>
</tr>
<tr>
<td>3000</td>
<td>10<sup>5</sup></td>
<td><b>0.177290</b></td>
<td>0.088507</td>
<td>0.008537</td>
<td>16.713140</td>
<td>0</td>
<td>5.9097</td>
</tr>
<tr>
<td>5000</td>
<td>10<sup>5</sup></td>
<td><b>0.159239</b></td>
<td>0.136047</td>
<td>0.014224</td>
<td>42.181080</td>
<td>0</td>
<td>3.1849</td>
</tr>
<tr>
<td>10<sup>4</sup></td>
<td>10<sup>5</sup></td>
<td><b>0.321003</b></td>
<td>0.270927</td>
<td>0.028594</td>
<td>79.321174</td>
<td>0</td>
<td>3.2100</td>
</tr>
<tr>
<td>3*10<sup>4</sup></td>
<td>10<sup>4</sup></td>
<td><b>0.968795</b></td>
<td>0.651618</td>
<td>0.084936</td>
<td>139.28827</td>
<td>0</td>
<td>3.2293</td>
</tr>
<tr>
<td>5*10<sup>4</sup></td>
<td>5000</td>
<td><b>1.147196</b></td>
<td>0.864045</td>
<td>0.143005</td>
<td>154.38225</td>
<td>0</td>
<td>2.2944</td>
</tr>
<tr>
<td>8*10<sup>4</sup></td>
<td>4000</td>
<td><b>2.112079</b></td>
<td>1.215612</td>
<td>0.229532</td>
<td>204.27321</td>
<td>0</td>
<td>2.6401</td>
</tr>
<tr>
<td>10<sup>5</sup></td>
<td>2000</td>
<td><b>2.253118</b></td>
<td>1.433197</td>
<td>0.290566</td>
<td>224.34623</td>
<td>0</td>
<td>2.2531</td>
</tr>
<tr>
<td>3*10<sup>5</sup></td>
<td>2000</td>
<td><b>4.330649</b></td>
<td>3.181905</td>
<td>0.990932</td>
<td>340.29584</td>
<td>0</td>
<td>1.4435</td>
</tr>
<tr>
<td>5*10<sup>5</sup></td>
<td>2000</td>
<td><b>5.985339</b></td>
<td>4.532205</td>
<td>1.488209</td>
<td>382.20016</td>
<td>0</td>
<td>1.1971</td>
</tr>
<tr>
<td>8*10<sup>5</sup></td>
<td>2000</td>
<td><b>8.297512</b></td>
<td>6.554302</td>
<td>2.902425</td>
<td>75.87513</td>
<td>0</td>
<td>1.0372</td>
</tr>
<tr>
<td>10<sup>6</sup></td>
<td>1000</td>
<td><b>11.376632</b></td>
<td>7.932194</td>
<td>2.954968</td>
<td>510.6265</td>
<td>0</td>
<td>1.1377</td>
</tr>
<tr>
<td>3*10<sup>6</sup></td>
<td>400</td>
<td><b>23.138609</b></td>
<td>18.521503</td>
<td>10.433580</td>
<td>122.7597</td>
<td>0</td>
<td>0.7713</td>
</tr>
<tr>
<td>5*10<sup>6</sup></td>
<td>300</td>
<td><b>33.103386</b></td>
<td>28.057816</td>
<td>14.937556</td>
<td>155.0890</td>
<td>0</td>
<td>0.6621</td>
</tr>
<tr>
<td>10*10<sup>6</sup></td>
<td>200</td>
<td><b>61.444001</b></td>
<td>52.269241</td>
<td>31.624475</td>
<td>228.3087</td>
<td>0</td>
<td>0.6144</td>
</tr>
<tr>
<td>30*10<sup>6</sup></td>
<td>50</td>
<td><b>149.71717</b></td>
<td>136.66441</td>
<td>84.556686</td>
<td>352.0534</td>
<td>0</td>
<td>0.4991</td>
</tr>
<tr>
<td>50*10<sup>6</sup></td>
<td>40</td>
<td><b>253.86220</b></td>
<td>228.93732</td>
<td>105.37934</td>
<td>558.4629</td>
<td>0</td>
<td>0.5077</td>
</tr>
<tr>
<td>80*10<sup>6</sup></td>
<td>30</td>
<td><b>372.29294</b></td>
<td>341.56397</td>
<td>250.80182</td>
<td>728.4806</td>
<td>0</td>
<td>0.4654</td>
</tr>
<tr>
<td>100*10<sup>6</sup></td>
<td>20</td>
<td><b>508.43573</b></td>
<td>474.04890</td>
<td>354.80864</td>
<td>831.3753</td>
<td>0</td>
<td>0.5084</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
得られた結果に基づいて導き出すことができる一般的な結論は次のとおりです</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。a）アルゴリズムは十分に速く機能します。たとえば、</font><b><font style="vertical-align: inherit;">100万回の</font></b><font style="vertical-align: inherit;">計算実験に</font><font style="vertical-align: inherit;">基づいて得られた、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 x 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズのチェス盤の任意のコンポジションの平均コンパイル時間</font><font style="vertical-align: inherit;">は0.062157秒です。つまり、コンポジションにソリューションがある場合、</font><i><font style="vertical-align: inherit;">「Enter」</font></i><font style="vertical-align: inherit;">キーを押すとすぐにソリューションが見つかります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">7から30,000の範囲の</font><i><font style="vertical-align: inherit;">nの</font></i><font style="vertical-align: inherit;">すべての値について、任意のコンポジションの平均コンパイル時間は</font><font style="vertical-align: inherit;">1秒を超えません。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b）各サンプルには、約10％の組成物が含まれており、完了するまでにさらに多くの時間が必要です。このような構成は、分布ヒストグラムで長い右テールを形成します。これらの10％の組成を除外し、残りの90％の解について計算を実行すると、計算時間（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t90 </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平均</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）ははるかに短くなります。たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 x 1000の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェス盤の</font><font style="vertical-align: inherit;">場合、平均カウント時間は0.027727秒で、サンプル全体から取得される平均時間の2.24倍になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c）値が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n≤800の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、組成のサンプルには、完全なソリューションになるまで完了できないものがあります。これは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偽陰性です</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューション。プログラムで指定された制限内で、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックトラッキング</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手順を</font><font style="vertical-align: inherit;">最大1000回</font><font style="vertical-align: inherit;">実行できるようにする</font><font style="vertical-align: inherit;">と、アルゴリズムはこれらの構成を完了できませんでした。それらは誤って否定的な構成として分類されました。解決策がないもの。そのような</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偽陰性の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解</font><font style="vertical-align: inherit;">の数</font><font style="vertical-align: inherit;">はわずかであり、サンプルにおけるそれらのシェアは0.0001未満です。さらに、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が増加する</font><font style="vertical-align: inherit;">と、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偽陰性の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解の</font><font style="vertical-align: inherit;">比率が</font><font style="vertical-align: inherit;">減少します。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; 800の</font><font style="vertical-align: inherit;">すべての値について</font><font style="vertical-align: inherit;">、この一連の計算実験では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">False Negative</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューションの</font><font style="vertical-align: inherit;">単一のケースはありませんでした</font><font style="vertical-align: inherit;">。ただし、サンプルサイズが何度も増加すると、</font><i><font style="vertical-align: inherit;">False Negativeの</font></i><font style="vertical-align: inherit;">可能性があることは明らかです。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このようなイベントの可能性は非常に少ないですが、ソリューション。</font></font><br>
 <br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムの時間の複雑さ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。図7は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまな値に対するランダム構成の平均ピッキング時間の変化のグラフを示しています</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fe/lj/zy/feljzywqkqijg-0pftjholzx3es.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。 7. </font><font style="vertical-align: inherit;">ランダムな構成</font><font style="vertical-align: inherit;">の平均ピッキング時間（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の、決定マトリックスの</font><font style="vertical-align: inherit;">サイズ（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">への依存性</font><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">n</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の値の10進数の対数が横軸</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">沿ってプロットされ</font><font style="vertical-align: inherit;">、平均カウント時間の1000倍の対数が縦軸に沿ってプロットされます。明確にするために、この図ではこの象限の対角線の点線も示しています。ピッキング時間は、nの増加とともに直線的に増加することがわかります。 50から10 </font><sup><font style="vertical-align: inherit;">8</font></sup><font style="vertical-align: inherit;">までのn値の全範囲にわたって</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カウント時間の実験値は直線を形成し、これはかなり高い相関（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = 0.9998</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は線形回帰方程式</font></font><br>
 <br>
 <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">log（1000 * t）=-0.628927 + 0.781568 * log（n）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって記述され</font><i><font style="vertical-align: inherit;">ます。</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
一般的な傾向からのわずかな逸脱は、値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n =（ 10、... 49）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この範囲では計算の5番目のブロックのみが問題を解決するために使用されるため、そのアルゴリズムは1番目と3番目のブロックのアルゴリズムの動作と大幅に異なります。結果の依存関係では、線形係数（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.781568</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は1未満です。これは、nの増加に伴い、回帰直線と象限の対角線が発散するという事実につながります。最初の時間ではなく、この不一致の理由を明確に説明するために、1つの線上の1つのクイーンの位置に必要な平均時間を考慮します。平均カウント時間を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nで</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割り</font><font style="vertical-align: inherit;">ます。このような指標を</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">短縮時間</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼びます</font><font style="vertical-align: inherit;">。明らかに、短縮された時間が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">増加に伴って変化しない</font><i><font style="vertical-align: inherit;">場合</font></i><font style="vertical-align: inherit;">、そのような解は線形になります（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（n）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。図8は、所定の時間の対数のプロットに見られるように</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rm/zo/i5/rmzoi5vzkips2kreyaltswbzivm.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。 8平均時間依存性（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、これは、クイーン</font><font style="vertical-align: inherit;">が解行列の</font><font style="vertical-align: inherit;">サイズ（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">から任意の1行に配置されるために必要です</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 （</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tRow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">は、解行列のサイズの対数から</font><font style="vertical-align: inherit;">10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">倍に</font><font style="vertical-align: inherit;">増加し</font><font style="vertical-align: inherit;">、nの範囲は50から10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">までで、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">増加に伴って短縮された時間は減少し</font><font style="vertical-align: inherit;">ます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 50</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の短縮時間</font><font style="vertical-align: inherit;">が10.7146 * 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">秒である場合、n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8の</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対応する時間</font><sup><font style="vertical-align: inherit;">は</font></sup><font style="vertical-align: inherit;"> 21倍短縮され、0.5084 * 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-6になります。</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">秒。アルゴリズムがnの小さい値の方が大きい値よりも遅いと見なす客観的な理由がないため、一見すると、このようなアルゴリズムの動作は誤っているように見えます。ただし、エラーはなく、これはこのアルゴリズムの客観的な特性です。これは、このアルゴリズムが異なる速度で動作する3つのアルゴリズムを組み合わせたものであるためです。さらに、これらのアルゴリズムのそれぞれによって処理される行の数は、nの値の増加に伴って変化します。この小さな領域のすべての計算は非常に効率的に機能する5番目の手順のブロックに基づいてのみ実行されるため、カウント時間は値の初期間隔で増加するのはこのためです（5、10、20、30、40）。手順の最初のブロック。したがって、女王を1行に配置するのに必要なカウント時間を考えると、チェス盤のサイズが大きくなると減少しますが、このアルゴリズムの時間の複雑さは減少と呼ばれます-線形。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックトラッキング（BT）が使用された</font></font></i></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">回数</font></b><font style="vertical-align: inherit;">。計算実験のすべてのケースで、各問題の解決にBT手順を使用してケースの数を追跡しました。ソリューションの検索中にどの基本レベルに戻されたかに関係なく、BTを使用するすべてのケースの累積合計が行われました。これにより、BTサンプルを使用したことがないソリューションの割合をサンプルごとに決定する機会が得られました。図9に図9を示します</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_l/5t/h5/_l5th5fsxg_u7aw_dei4o3b5h2w.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。 9. </font><i><font style="vertical-align: inherit;">nの</font></i><font style="vertical-align: inherit;">増加に伴って</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 BT（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゼロバックトラッキング</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">プロシージャ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用せずにソリューションのケースの割合がどのように変化するかを示すグラフ</font><font style="vertical-align: inherit;">で、バックトラッキングプロシージャが使用されなかったサンプルの決定の割合</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n =（7、...、100000）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の範囲では</font><font style="vertical-align: inherit;">、BT手順が使用されたことのないソリューションの数が35％を超えていることがわかります。さらに、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n =（320、...、22500）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の値の範囲では</font><font style="vertical-align: inherit;">、そのようなケースの数は50％を超えています。最も効果的な結果は、サイズのチェス盤について得られた</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5000 X 5000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のサンプル中、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">万の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で組成物</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の61.92パーセント</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の場合</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、「決定論的」</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の溶液</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非決定</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題をし</font><font style="vertical-align: inherit;">行っ</font><font style="vertical-align: inherit;">ているため、 BTの手順は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61.92％</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ケースは使用されていません。残りのソリューションでは、ケースの21.87％でBT手順が1回、ケースの9.07％-2回、ケースの3.77％-3回使用されました。合計すると、これはケースの96.63％を占めます。値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 5000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以降、</font><font style="vertical-align: inherit;">BT手順を使用せずに構成問題を解決するケースの数が徐々に減少するという</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事実</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font><i><font style="vertical-align: inherit;">baseLevel2</font></i><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel3の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">境界値を選択するために選択されたモデルに関連付けられています</font><font style="vertical-align: inherit;">。これらのパラメータを変更して、BT手順を使用せずにソリューションの数を増やすことができます。ただし、アルゴリズムの操作における5番目のブロックの参加が増えるため、これはカウント時間の増加につながります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピッキング時間の分布のヒストグラム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。図10では、</font><i><font style="vertical-align: inherit;">n = 1000の</font></i><font style="vertical-align: inherit;">値の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100万個のソリューションのピッキング時間の分布のヒストグラムが表示されます。 （高層ビルの夜のシルエットに最も類似している可能性が高い）分布ヒストグラムのごく普通のビューは、間隔の長さまたは数の選択におけるエラーに関連付けられていません。これは、このアルゴリズムの自然な特性です。理解するために、</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cm/ii/z9/cmiiz94kbp7hxfss1aqzkejd09o.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図10.任意のサイズの構成のコンパイル時間のヒストグラム。 （</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプルサイズ= 1,000,000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒストグラムがこのような形をしている理由は、同じサイズのコンポジションのピッキング時間の分布を考慮してください。このため、例として、最初のサンプルから、サイズが800であるすべての構成を選択します。100万のサンプルには、998の構成が含まれています。図11は、このサンプルのカウント時間の分布のヒストグラムを示しています。図から、分布はサイズが減少する6つの個別のヒストグラムで構成されていることがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ku/70/xa/ku70xadamrocfeimg3zpvyvurgu.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。 11.同じサイズのコンポジションのコンパイル時間のヒストグラム（k = 800）。 （</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプルサイズ= 998</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
800のクイーンがランダムに分散される998のコンポジションのコンパイル時間が6つのグループに「クラスター化」される理由</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックトラッキング</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。図の最初のヒストグラムは、最大サンプルサイズで、BT手順が使用されたことがないピッキングソリューションです。これは最速のソリューションのグループです。最初のヒストグラムよりサイズが大幅に小さい2番目のヒストグラムは、BT手順が1回だけ使用されたソリューションです。したがって、このグループの決定時間は最初のグループよりわずかに長くなります。したがって、3番目のグループでは、BTの手順が2回、4番目の手順では3回、というように使用されました。 BTの手順が繰り返し使用された決定は、長期間にわたって実行されました。そのような解決策は、望ましい分布の長い右テールを形成します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偽陰性ソリューション</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">nの</font></i><font style="vertical-align: inherit;">任意の値に対して可能なすべての構成を分割する場合</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポジティブとネガティブを比較すると、ポジティブコンポジションには、このアルゴリズムがネガティブとして分類できるものがあります。これは、検索パラメーターによって設定された制限内で、アルゴリズムがそのような構成を完了する正しい方法を見つけることができないという事実によるものです。実験結果（表2）が示すように、そのようなケースの数はサンプルサイズの0.0001を超えず、このエラーの値は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">増加とともに減少し</font><font style="vertical-align: inherit;">ます。さらに、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n&gt; 800の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての値について</font><font style="vertical-align: inherit;">、単一のケースの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">False Negative</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューション</font><font style="vertical-align: inherit;">はありませんでした</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000で</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプルサイズを100万に増やしても</font><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">偽陰性</font></i><font style="vertical-align: inherit;">は発生しませんでした。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定。</font><font style="vertical-align: inherit;">結果は、私たちはこの問題を解決するために、次のルールを策定することができます：「の任意のランダムな構図</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k個の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一貫サイズの任意のチェス盤の上に分布している女王</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のn×nの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全な解決策が行われる、またはこの組成物が負であると判断されるまでに完了し、できないことができます完成する。</font><font style="vertical-align: inherit;">このような決定を行う際のエラーの確率は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.0001</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の値を超えません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">チェス盤のサイズが大きくなると、誤った判断を下す可能性が低くなります。</font><font style="vertical-align: inherit;">アルゴリズムの時間の複雑さは線形です。」</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.結論 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 1. </font><font style="vertical-align: inherit;">任意のサイズ</font><i><font style="vertical-align: inherit;">nxnの</font></i><font style="vertical-align: inherit;">チェス盤上に一貫して分布する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クイーンの</font><font style="vertical-align: inherit;">ランダムな構成の完全な解が得られるまで、線形時間で完全なセットの問題を解くアルゴリズムを提示します</font><font style="vertical-align: inherit;">。さらに、</font><i><font style="vertical-align: inherit;">k個の</font></i><font style="vertical-align: inherit;">クイーンの</font><font style="vertical-align: inherit;">構成</font><font style="vertical-align: inherit;">（</font><i><font style="vertical-align: inherit;">1≤k &lt;n</font></i><font style="vertical-align: inherit;">）の場合、解決策があれば提供されます。または、この構成を完了できないと判断されます。このような決定を行う際のエラーの確率は0.0001を超えず、この値はチェス盤のサイズが大きくなるにつれて減少します。</font><font style="vertical-align: inherit;">
2.このアルゴリズムの操作は、2つの重要なルールの使用に基づいています。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
a）問題を解決する最終段階で、残りのすべてのフリーラインから、フリーポジションの数が最小である1つが選択され</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><i><font style="vertical-align: inherit;">最小リスクルール</font></i><font style="vertical-align: inherit;">）。これにより、残りの行の一部で最後の空のポジションを除外する可能性に関連するリスクが最小限に抑えられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b）問題のラインのすべての空いているポジションから、残りのフリーラインのフリーポジションへのダメージが最小になるポジションが選択されます（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小ダメージルール</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。 「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小の損傷</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」とは、残りのすべてのフリーラインで最小量のフリーポジションを除外するライン内のそのようなポジションの選択を意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.このアルゴリズムの操作の結果として、女王が1行に配置されるのに必要な平均時間は、nの値が増加するにつれて減少することが確立されています。 nが10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8の</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合にクイーンを1行に配置するのに必要な平均時間</font><font style="vertical-align: inherit;">は、n = 50の場合の対応する時間より21倍短くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.値の範囲</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n =（7、...、100000）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、バックトラッキング手順が使用されたことのないソリューション</font><i><font style="vertical-align: inherit;">の</font></i><font style="vertical-align: inherit;">数が35％を超えることが確認されました。さらに、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n =（320、...、22500）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の値の範囲では</font><font style="vertical-align: inherit;">、そのようなケースの数が50％を超えており、このアルゴリズムの効率が高いことを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5. </font><i><font style="vertical-align: inherit;">バックトラッキング</font></i><font style="vertical-align: inherit;">手順を整理するためのモデルが提案されます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、基本レベルでの決定の一連のステップの分離に基づいています。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベルとは、所定の数の正しく配置されたクイーンがいる特定の決定ステップを意味し</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">応じて2番目と3番目の基本レベルの値を計算するための回帰式が与えられます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand＆rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">呼ばれる2つのランダム選択方法の比較分析の結果が</font><i><font style="vertical-align: inherit;">表示され</font></i><font style="vertical-align: inherit;">ます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSetアルゴリズムは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速いが、失礼であることが判明しています。したがって、2番目の基本レベルに到達すると、その使用は制限されます。その後、</font><i><font style="vertical-align: inherit;">rand＆rand</font></i><font style="vertical-align: inherit;">アルゴリズムが使用されます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それほど速くは実行されませんが、より効果的にクイーンをチェス盤に配置します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-クイーン問題の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解の正しさを検証するための効果的なアルゴリズムが与えられ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">このプログラムはまた、任意のサイズのランダムな構成の正しさを検証するように設計されています。</font><font style="vertical-align: inherit;">プログラムは十分に速く動作します。</font><font style="vertical-align: inherit;">たとえば、500万の位置で構成されるソリューションの検証に必要な時間は0.85秒です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9.コメント </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 1.記事の最初に示したように、研究は</font><font style="vertical-align: inherit;">7から1億まで</font><font style="vertical-align: inherit;">の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値の範囲で実施されました</font><font style="vertical-align: inherit;">。ただし、プログラムは</font><font style="vertical-align: inherit;">10億までの</font><font style="vertical-align: inherit;">より広い範囲の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">テストされました</font><font style="vertical-align: inherit;">。確かに、後者の場合、配列のサイズが大きいため、プログラムを少し調整する必要がありました。したがって、RAMのサイズが許せば、nの大きな値の計算を実行することが可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.基本的なレベルインジケーターの値と、さまざまなレベルでの繰り返し数の境界値は、調査範囲全体で問題を解決するために最適化されました。それらはより小さい範囲内で変更でき、カウント時間を短縮できます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偽陰性の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解決策の</font><font style="vertical-align: inherit;">割合を増加させないことが重要</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.この記事では</font><font style="vertical-align: inherit;">、アルゴリズムの動作速度を評価するための時間の尺度として</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーを押した時間を使用しました</font><font style="vertical-align: inherit;">。キーを押した直後に結果が表示される場合、ユーザーの認識レベルでは、プログラムは「非常に」高速に動作しているようです。アルゴリズムがどれほど速く動作しても、キーが完了するまで結果は画面に表示されません。したがって、このような時間の条件付き測定値は、さまざまなアルゴリズムの速度を厳密に比較しないためのしきい値レベルとして機能するように思えました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.哲学...調査中、非決定的問題の解決に関連する多数の出版物が検討されました。ほとんどの場合、これらは、与えられた制限の条件下で、広い範囲の状態で選択を行う必要があるタスクでした。それらを比較すると、標準的な数学的アプローチを使用してそのような問題をどの程度まで解決できるかを知ることは興味深いことでした。そのような問題は、定義、補題の記述、定理の証明だけでは解決できないという印象を受けました。このような問題を解決するには、コンピュータシミュレーションを使用したアルゴリズム数学の方法を使用する必要があるように思えます。この結論の妥当性を示すために、簡単な例として、サイズが10のチェス盤を用意しました</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 999,999,482クイーンからなる同じサイズの2つのコンポジション。これらは、記事の冒頭で説明したように準備され、.mat形式の2つのファイルとして表示されます。これらは、このリンク</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2つのテストファイル）から</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダウンロードでき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。ファイルは非常に「重い」ため、各ファイルのサイズは約3.97 GBです。 999 997 976行（99.9998％の場合）では、両方の構成での女王の位置が一致し、任意の1506行でのみ、女王の位置が異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全なソリューションの構成データを完成させるには、残りの518の空きラインにクイーンを正しく配置する必要があります。残りのフリーラインに518のクイーンを配置する可能な方法の数（選択したラインでフリーポジションを選択する方法の数のみを考慮）は、約10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1466です。</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これら2つの構成の違いは、一方がポジティブで完全なソリューションになるまで完了することができ、もう一方の構成がネガティブであるという事実のみにあります-完全なソリューションまで完了することができません。質問：「厳密な数学的アプローチに基づいて（つまり、アルゴリズムによる計算操作を実行せずに）、これら2つの構成のどちらがポジティブかを判断することは可能ですか？」これが解けない場合は、反対の方法で述べられた判断が証明されたとみなすことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題の厳密な数学的解法へのアプローチがどうであれ、ステータス518 * 10 </font><sup><font style="vertical-align: inherit;">9</font></sup><font style="vertical-align: inherit;">を決定する必要があることに注意したい</font></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残りの空き行のセル。これを行うには、以前に確立された女王の各ポジションを考慮する必要があり、残りの518行のフリーポジションに課せられた各女王が課す制限を確立するには、それらの約10億があります。アルゴリズム的な計算をせずに、厳密に数学的なアプローチに基づいてのみこの作業を実行できる「支点」を見つけられませんでした。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、2つの構成のみからなる最小限の例を示しました。必要であれば、そのような組成物の数を増やすことができる。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提案された線形アルゴリズムに基づいて、大きなコンポジションでの作業にわずかに適合し、</font><i><font style="vertical-align: inherit;">デスクトップ13で</font></i><font style="vertical-align: inherit;">完全なソリューションが実行されるまで、2つのテストコンポジションのタスクを完了できることに注意してください。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、約4.5分（入力データの読み込み時間を除く）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.追加</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有能な学生に開発と研究のための有能なタスクを推奨する教授の行動は尊敬に値します。</font><font style="vertical-align: inherit;">これにはかなりの労力が必要ですが、困難を克服するために、研究者は他の複雑なタスクを異なって見ています。</font><font style="vertical-align: inherit;">このような目的のために、n-クイーン問題をステージングするためのオプションを拡張することは有用だと思いました。</font><font style="vertical-align: inherit;">同じタスクを異なる視点から見ると、異なることがわかります。</font><font style="vertical-align: inherit;">以下はその一部です。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. </font><font style="vertical-align: inherit;">サイズ</font><i><font style="vertical-align: inherit;">nxmの</font></i><b><font style="vertical-align: inherit;">長方形の「チェス」ボード</font></b><font style="vertical-align: inherit;">に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n個の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クイーン</font><font style="vertical-align: inherit;">を配置する問題を考えます</font><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">k = m-nを</font></i><font style="vertical-align: inherit;">表し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">いくつかの解が得られ、それぞれの</font><i><font style="vertical-align: inherit;">nで</font></i></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各列に1つの女王がいました。クイーンが配置されている位置は、さらに考慮されません。これで、各行に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フリーポジションがあります。残りのフリーポジション内で、もう一度1つの解決策を見つけます。前と同じように、2番目のソリューションのクイーンが配置されている位置をさらに考慮から除外します。これで、各行に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m-2の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空きポジションがあります。明らかに、1番目と2番目のソリューションは、どの行の位置でも交差していません-直交しています。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまな値について、相互に直交する解の最大数を決定する必要があります</font><font style="vertical-align: inherit;">。場合</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">互いに直交するソリューションは、値のために発見された</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後、ロイヤルラテンスクエアが建設されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">備考</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。論文</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grigoryan E.（2018）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens Problemの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解には、それを妨げない補足的な解があることを示しています。これは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意の値</font><i><font style="vertical-align: inherit;">に対して</font></i><font style="vertical-align: inherit;">、すべての</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-クイーン問題の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解のセットが</font><font style="vertical-align: inherit;">2つの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等しいサイズの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブセットに</font><font style="vertical-align: inherit;">分割される</font><font style="vertical-align: inherit;">ことを意味し</font><font style="vertical-align: inherit;">ます。 2番目のサブセットのソリューションは、1番目のサブセットの対応するソリューションを補完するソリューションです。ルールは非常に単純で、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q1（i）が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のセットの解である場合、対応する補完的な解</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q2（i）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目のサブセットからの式は、式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q2（i）= n + 1-Q1（i）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって決定され</font><font style="vertical-align: inherit;">ます。</font><i><font style="vertical-align: inherit;">ここで、i =（1、...、n）</font></i><font style="vertical-align: inherit;">です。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の任意の値に対する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n- </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">クイーン問題</font></i><font style="vertical-align: inherit;">のすべての解の</font><font style="vertical-align: inherit;">数は常に偶数で</font><font style="vertical-align: inherit;">あることを説明するのはこのルールです</font><font style="vertical-align: inherit;">。 （このルールにより</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェス盤の</font><font style="vertical-align: inherit;">任意のサイズ</font><i><font style="vertical-align: inherit;">nの</font></i><font style="vertical-align: inherit;">すべての完全なソリューションを計算する時間を半分にすることができます</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。2* k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですべてのソリューションの総数</font><font style="vertical-align: inherit;">を表す場合</font><font style="vertical-align: inherit;">、値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q（k）+ Q（ k + 1）= n + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.問題の元のステートメント</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Qeens Problem</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、女王が</font><i><font style="vertical-align: inherit;">（i、j）の</font></i><font style="vertical-align: inherit;">位置に配置された後</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次のアクションが実行</font><font style="vertical-align: inherit;">
されます。a）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jの</font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのセルが除外されます。b）セル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i、j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を通過する左右の対角線の線上にあるすべてのセルが除外され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題の説明で条件b）を変更します。セルを削除する代わりに、セルスイッチングを使用します。左または右の対角線上にあるセルが空いている場合はセルを閉じ、閉じている場合は開きます。これにより、解決策を見つけやすくなります。ただし、正方行列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxnの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わりに、</font><font style="vertical-align: inherit;">サイズ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nx（n-k）の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長方形行列を考え</font><font style="vertical-align: inherit;">ます。与えられた</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値に対して、</font><i><font style="vertical-align: inherit;">kの</font></i><font style="vertical-align: inherit;">最大値を見つける</font><font style="vertical-align: inherit;">ことが必要です</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少なくとも3つの直交解を得ることができます。</font><i><font style="vertical-align: inherit;">nの</font></i><font style="vertical-align: inherit;">値の増加に</font><font style="vertical-align: inherit;">伴い、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の値はどのように変化</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">ますか？</font><font style="vertical-align: inherit;">
3. </font><i><font style="vertical-align: inherit;">n-クイーン問題の</font></i><font style="vertical-align: inherit;">最初の定式化でいくつかの条件を変更します</font><font style="vertical-align: inherit;">。クイーンが</font><i><font style="vertical-align: inherit;">nxn</font></i><font style="vertical-align: inherit;">サイズのチェス盤の</font><font style="vertical-align: inherit;">位置</font><i><font style="vertical-align: inherit;">（i、j）</font></i><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">配置されている場合</font><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">
a）行</font><i><font style="vertical-align: inherit;">iの</font></i><font style="vertical-align: inherit;">すべてのセルを除外し</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">
b）インデックス</font><i><font style="vertical-align: inherit;">jが</font></i><font style="vertical-align: inherit;">偶数の場合：</font><font style="vertical-align: inherit;">
b1）列jの偶数行の</font><font style="vertical-align: inherit;">
セルを除外するb2）セルを除外するセルを通過する左右の対角線と交差する偶数ライン</font><i><font style="vertical-align: inherit;">（i、j）は</font></i><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">
もしC）をインデックス</font><i><font style="vertical-align: inherit;">J</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">奇数の場合、アイテムb1）およびb2）は、奇数行にあるセルで満たされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.1知られている</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（スローン-2016）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のすべての解の値のリストその</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nQueens問題</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、のための</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N =（8、9、10、11、12、13、14、15、16）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それぞれである、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（92、352、724、2680、 14200、73712、365596、2279184、14772512）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。問題の説明において、対角線の例外の標準条件が段落b）または段落c）に変更された場合、すべてのソリューションの数はどのように変化しますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.2すべての解のリストの形成における決定行列の異なるセルの参加の頻度を決定した場合、対応する頻度の垂直および水平の対称性の形ですべてのセル間に調和のとれた関係があることがわかりますグリゴリアン（2018）によって知られています。我々は仮定した場合には、この手段</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kは&lt;N / 2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その後の細胞の周波数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k番目の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行は、行のセルの周波数と同一となり</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、N-k + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。同様に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k番目の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列のセルの頻度は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-k + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列のセルの頻度と同じになります</font><font style="vertical-align: inherit;">。質問：「これらの調和のとれた関係は、タスクのコンテキストでどのように変化しますか？」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.チェス盤のすべてのセルは、その色によって2つのクラスに分類されます。一方の色は白、もう一方の色は黒と考えられています。 2つのチェス盤を検討し、端が完全に一致するように一方を他方の上に置きます。その結果、白と黒のセルの配置が一致する2つのチェス盤の「サンドイッチ」が得られます。タスクは、次の条件を守って、2つのボードで同時に解を見つけることです。a </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
）ボードの1つでクイーンがインデックス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i、j）の</font></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 黒いセルにある場合</font><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">-両方のボードで発生するすべての黒いセル行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -両方のボードで、セル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i、j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を通過する左右の対角線に沿って配置されているすべての黒いセルが除外され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b）ボードの1つでクイーンがインデックス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i、j）を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持つ白いセル</font><font style="vertical-align: inherit;">にある場合、段落a）のすべてのアクションは白いセルに対してのみ実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5.サイズ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxnの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューションマトリックスで</font><font style="vertical-align: inherit;">、行が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルの</font><font style="vertical-align: inherit;">増分で互いに対して右または左にスライドできることを</font><font style="vertical-align: inherit;">想像してください</font><font style="vertical-align: inherit;">。さらに、前の行が左にシフトされた場合、次の行は右にシフトされます。次の各行は、前の行とは反対方向にシフトされます。この構成の結果として、サイズの長方形の行列を取得します</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nx（n + k）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。各行のk個のセルは、行の最初または最後からの考慮から除外されます。タスクは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n- </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">クイーンズ問題の</font></i><font style="vertical-align: inherit;">解が少なくとも1つ</font><font style="vertical-align: inherit;">ある任意の</font><i><font style="vertical-align: inherit;">nの</font></i><font style="vertical-align: inherit;">値に対する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の最大値</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">見つけること</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">
あるラインの別のラインに対するオフセットが</font><i><font style="vertical-align: inherit;">k1</font></i><font style="vertical-align: inherit;">から</font><i><font style="vertical-align: inherit;">k2の</font></i><font style="vertical-align: inherit;">範囲の乱数である問題の変形を考えてみましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
6. </font><b><i><font style="vertical-align: inherit;">nQueens問題</font></i></b><font style="vertical-align: inherit;">の1 </font><b><font style="vertical-align: inherit;">次元定式化</font></b><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">1からn</font></i><font style="vertical-align: inherit;">までの番号が付けられた、任意の長さの</font><i><font style="vertical-align: inherit;">n個の</font></i><font style="vertical-align: inherit;">セグメントを</font><font style="vertical-align: inherit;">半軸上に配置します</font><font style="vertical-align: inherit;">。各セグメントを</font><i><font style="vertical-align: inherit;">nで</font></i><font style="vertical-align: inherit;">割ります</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意のサイズのセル、および各セグメント内で、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1からn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">までのセルに番号を</font><i><font style="vertical-align: inherit;">付け</font></i><font style="vertical-align: inherit;">ます。私たちはそのような細胞を開いたと呼びます。次の制限を考慮して、各セグメントで1つのセルを閉じる必要があります。a </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
）</font><font style="vertical-align: inherit;">次の</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">i</font></i><font style="vertical-align: inherit;">番目のセグメントの</font><font style="vertical-align: inherit;">インデックス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開いたセルを選択できます</font><font style="vertical-align: inherit;">
。</font><font style="vertical-align: inherit;">
D2（t）= 0; </font><font style="vertical-align: inherit;">
ここで、</font><i><font style="vertical-align: inherit;">r = n + j-i、t = j + i、D1およびD2</font></i><font style="vertical-align: inherit;">は</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;">以前にゼロ化された</font><i><font style="vertical-align: inherit;">2n個の</font></i><font style="vertical-align: inherit;">セルで</font><font style="vertical-align: inherit;">構成される1次元の制御配列</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">
b）この選択の後、セグメント</font><i><font style="vertical-align: inherit;">i</font></i><font style="vertical-align: inherit;">と番号</font><i><font style="vertical-align: inherit;">jの</font></i><font style="vertical-align: inherit;">セル</font><font style="vertical-align: inherit;">が閉じられます</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残りのすべての空きセグメント。また、コントロールアレイの対応するセルを閉じる必要があります</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。D1（r）= 1; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D2（t）= 1; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この設定では、タスクは元のタスクとまったく同じです。興味深いのは、この問題を他の制約条件で定式化することです。たとえば、数式の代わりに：</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j-i、t = j + i、は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の比率と見なされ、機能的に関連付けられたインデックス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i、j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で行列を作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボール付きの骨壷に基づくタスクの表現</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（前の表現と同じ）。</font><i><font style="vertical-align: inherit;">1からn</font></i><font style="vertical-align: inherit;">までの番号が付けられた</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n個の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> urn </font><font style="vertical-align: inherit;">があるとします。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そして各骨壷には</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n個の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボールがあり、これも</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1からn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まで番号が付けられてい</font><font style="vertical-align: inherit;">ます。次の制限を考慮すると、離れてそれぞれ1個のボールからURN必要です</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
）我々は、番号でバルーンを選択することができ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目URN場合：</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1（R）= 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2（T）= 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">R = N + J -i、t = j + i、D1とD2</font></i><font style="vertical-align: inherit;">は</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;">以前にゼロ化された</font><i><font style="vertical-align: inherit;">2n個の</font></i><font style="vertical-align: inherit;">セルで</font><font style="vertical-align: inherit;">構成される1次元の制御配列</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">
b）この選択後、投票箱</font><i><font style="vertical-align: inherit;">i</font></i><font style="vertical-align: inherit;">と番号</font><i><font style="vertical-align: inherit;">jの</font></i><font style="vertical-align: inherit;">ボール</font><font style="vertical-align: inherit;">は、残りのすべての無料の投票箱</font><font style="vertical-align: inherit;">で閉じ</font><font style="vertical-align: inherit;">られます。コントロールアレイの対応するセルを閉じることも必要です。</font></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1（r）= 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2（t）= 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この設定では、タスクは元のタスクとまったく同じです。前のケースと同様に、インデックス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">決定行列</font><font style="vertical-align: inherit;">のインデックス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i、j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">機能的に接続する他の条件でのこの問題のステートメントに関心があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。サイズ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxnの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェス盤を考えてみましょう</font><font style="vertical-align: inherit;">。クイーンに色を戻します。一部のクイーンは白色、その他は黒色にします。また、インデックス</font><i><font style="vertical-align: inherit;">（1、n）の</font></i><font style="vertical-align: inherit;">セルがあるという事実に基づいて、白と黒の交互の色をチェス盤のセルに返します。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">白でなければなりません。ゲーム開始時のすべてのセルは無料と見なされます。白い女王が最初の動きをします。プレーヤーは、クイーンをインデックス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i、j）を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持つ任意のフリーセルに配置します</font><font style="vertical-align: inherit;">。それを白セルにしましょう。この選択の結果、それらは閉じられます：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
a）行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての白セル</font><font style="vertical-align: inherit;">、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b）列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jの</font></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
すべての白セル</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">c）セル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i、j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を通過する左右の対角線上にあるすべての白セル</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（i、j）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が黒であることが判明した場合、すべてのポイント</font><i><font style="vertical-align: inherit;">（a、b、c）</font></i><font style="vertical-align: inherit;">が満たされます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、したがって、黒色のすべてのセルが閉じられます。さらに、ブラックは移動を実行し、残りの空きセルのいずれかにクイーンを配置します。その後、同様に、上記のようにセルが閉じます。次の動きを考える時間は固定されており、当事者の合意によって選択されます。指定された時間内に、プレーヤーの1人が移動を完了しなかった場合、ゲームは他のプレーヤーに移されます。両方のプレイヤーが1人ずつ、指定された時間内にターンを完了できなかった場合、ゲームは終了します。より多くのクイーンをボードに置くことができる人が勝ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9.ランダム選択の安定性について。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet＆randSetモデルを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考えてみましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">行と列のインデックスの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n個の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランダムなペア</font><font style="vertical-align: inherit;">を比較した結果</font><font style="vertical-align: inherit;">、サイクルの最初の段階で、平均でクイーンを確立することが可能です。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k * n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の値は</font><font style="vertical-align: inherit;">、0.6に等しい定数値と見なすことができます。その値は0.605701からで変化する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、N = 10</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、及び0.599777に、N = 10で</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">増大とともに、そして</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この値の分散が減少します。そのような「恒常性」の理由は何ですか？行インデックスとこの行の女王の位置インデックスをランダムに選択すると、1からnまでの数のランダムな順列に基づいて取得された2つの数のリストに基づいて、ラインの60％に女王を（平均して）一貫して配置できるのはなぜですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10.チェス盤のサイズを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxnにし</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><i><font style="vertical-align: inherit;">randSet＆randSetプロシージャに</font></i><font style="vertical-align: inherit;">基づく</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">探索ブランチが行き止まりに到達するまで、クイーンをチェス盤に置きます。このようにして得られた合成の長さを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kで表し</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定の値について</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;">この手順を何度も繰り返し、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の値の分布のヒストグラムを作成する</font><font style="vertical-align: inherit;">と、分布モードの値に対するイベントの発生頻度の変化が、この値の後のイベントの発生頻度の変化とは異なることがわかります。モード値に基づいて、ヒストグラムが2つの部分に分割される場合、左側の部分は右側の部分と一致しません。このパターンは、</font><i><font style="vertical-align: inherit;">nの</font></i><font style="vertical-align: inherit;">任意の値に特徴的です</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">コンポジションの長さがモーダル値に移行した後、イベントの頻度が異なる形になるのはなぜですか？</font><font style="vertical-align: inherit;">イベントとは、デッドロック状態に達するまでの、指定されたサイズのコンポジションの受信を意味します。</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 文献</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Nauck、F.（1850）。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefwechsel mit allen fur alle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Illustrierte Zeitung、15、182。2 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gent、IP、Jefferson、C。 ＆Nightingale、P.（2017）。</font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens完了の複雑さ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Journal of Artificial Intelligence Research。、59、815-848。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. Sosic、R.、＆Gu、J.（1990）。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-クイーン問題の多項式時間アルゴリズム</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 SIGART Bulletin、1（3）、7–11。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richards、M.（1997）。</font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビットパターンと再帰を使用したMCPLのバックトラッキングアルゴリズム</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テック。ケンブリッジ大学コンピューター研究所。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズム設計におけるランダム化手法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、DIMACSワークショップの議事録、米国ニュージャージー州プリンストン、1997年12月12〜14日。離散数学および理論計算機科学におけるDIMACSシリーズ43、DIMACS / AMS 1999、ISBN 978-0-8218-0916-7 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grigoryan E（2018）。</font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解の形成における規則性の調査n-クイーン問題</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">人工知能のモデリング、5（1）、3-21 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sloane N.-JA（2016）。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整数シーケンスのオンライン百科事典。</font></font><br>
<br>
<br></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja483018/index.html">初心者からプロまでのMask-R CNN</a></li>
<li><a href="../ja483024/index.html">「企業はあなたのプライバシーをどのように扱いましたか？」、Arthur Khachuyan（Tazeros Global）</a></li>
<li><a href="../ja483026/index.html">Java / Spring：Speedmentを使用してCRUD REST APIを完全に生成する方法</a></li>
<li><a href="../ja483030/index.html">泣かせるAPI</a></li>
<li><a href="../ja483032/index.html">CISからチェコ共和国への移行、自分の経験（パート2）</a></li>
<li><a href="../ja483038/index.html">適切にゲームの世界を再開する</a></li>
<li><a href="../ja483040/index.html">極東アセンブリExcel 97用のマジックドライバー</a></li>
<li><a href="../ja483042/index.html">9 Vueパフォーマンスのヒント</a></li>
<li><a href="../ja483048/index.html">ターミナルの楽しみ：10の古典的なコンソールジョーク</a></li>
<li><a href="../ja483052/index.html">球の代わりにピラミッド：金原子の非標準のクラスタリング</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>