<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌑 📆 🧑🏾‍🤝‍🧑🏾 そして、ソートについての詳細 🛋️ 😐 📺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="そして、ソートについての詳細
 私は再びこのトピックを提起するつもりです。まず、Mikhail Opanasenko（oms7）による記事へのリンクから始めます。これは、行われた作業量と引用されたリンクの数の点で非常に印象的です。彼はこの出版物について知らずに資料を準備し始め、その後、慣れ親しんだ後...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>そして、ソートについての詳細</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467473/"><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、ソートについての詳細</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は再びこのトピックを提起するつもりです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Mikhail Opanasenko（oms7）</font></a><font style="vertical-align: inherit;">による記事へのリンクから始めます。</font><font style="vertical-align: inherit;">これは、行われた作業量と引用されたリンクの数の点で非常に印象的です。彼はこの出版物について知らずに資料を準備し始め、その後、慣れ親しんだ後、その実質的な処理の必要性につながりました。この記事を既に読んだ人のために、私の資料では、より多様なタイプのデータが研究されていることをお知らせします。特に、文字列と実数、boostおよびbsdライブラリが使用されており、記事から欠落しているその他のトピックがいくつか言及されています。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ項目を順番に配置するには、さまざまな方法があります。その中で、高速に動作するものは区別されます。たとえば、コンピューターのRAMにある任意のデータ配列を最大数分で並べ替えることができます。より具体的には、高速ソートは、100秒未満で10億の整数を最新のパーソナルコンピュータに整理すると言えます。多数の要素をソートするために、バブルソートや選択ソートなどのプリミティブな非迅速な方法を使用する場合、そのようなデータ処理に費やされる時間は予想を超える可能性があります。この大きな違いは、迅速な方法によるソーティング時間がほぼ比例するという事実が原因です</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、およびプリミティブ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-N </font></font></i><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。増加すると</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nを、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2つの値の差は、非常に顕著になります。したがって、たとえば最近のコンピューターで数千要素までの小さなデータを扱う場合にのみ、プリミティブメソッドを使用するのが妥当です。プログラミングや論理的思考の基礎を教えるためにそれらを使用するのも自然なことです。高速な方法よりもはるかに簡単だからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在の標準ライブラリに存在する並べ替え方法を理解したいと思います。それらの主な特性、作業速度、およびそれらの特性の観点から、それらの違いがどれほど大きいかを確認してください。さらに、比較と心の練習のために、実装するのが難しくないいくつかの方法を検討します。また、GCCコンパイラーのオプティマイザーおよびおそらく他の優れたコンパイラーはソートで非常にうまく機能し、コードを数倍（場合によっては5倍以上）高速化することにも注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まずは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">バブルメソッド</font></a><font style="vertical-align: inherit;">から始めましょう</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（バブルソート）最も単純で最も遅いものとして。この方法では、データ配列を何度も調べて、隣接する要素を比較し、それらの間の順序が壊れている場合は場所を変更する必要があります。各パスの後、少なくとも1つの要素（最大または最小-選択した順序によって異なります）がその場所にあります。単純化に加えて、この方法にはもう1つの利点があり、追加のメモリを必要としません。バブルメソッドのもう1つの機能に注目してください。すでに注文されたデータを非常に迅速に処理し、場合によっては最速の方法の1つにしています。データが部分的にしか順序付けられていない場合、この方法はデータを高速に処理しますが、ほとんどの場合、ごくわずかです。テストでは、次の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の遅い方法-ソート</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選択</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（選択ソート）。ここでは、各パスで、最初にデータの最大要素と最小要素が検出され、次にこれらの要素が選択した順序に対応する極端な位置に配置されます。次のパスでは、これらの極端な要素なしでデータを並べ替えます。この方法はバブルソートと同じくらい簡単で、追加のメモリも必要ありませんが、著しく高速です。さらに、このメソッドによるソートは、データ要素の順列の最小数のレコードを実行します。したがって、置換が比較よりもはるかに遅い場合、データ要素の数が少ないと、選択方法による順序付けは許容できる場合があります。これが私の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装です</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。多くの場合、このソートは実現され、パスごとに1つのエレメントのみを配置します。</font><font style="vertical-align: inherit;">後で説明する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒープの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並べ替え</font><font style="vertical-align: inherit;">（ピラミッド型）は、問題の並べ替えの中で最も高度なバージョンです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題の最後の遅いメソッドのコード、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">挿入ソート</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（挿入ソート）は、ソートを実装するすべてのコードの中でおそらく最も短いため、このメソッドは、ソートされる項目の数が少ない（数十）場合に、複雑なクイックソートで使用されることがあります。あちこちで隣接する要素が逐次比較されるので、それはバブルによるソートにいくぶん似ています。ただし、挿入ソートは、データのすでにソートされた部分で次の要素の次の位置を探し、極端な要素を極端な位置にプッシュするだけではありません。このアプローチでは、追加のメモリも必要ありません。バブルソートと同様に、挿入ソートは順序付けられたデータでは非常に高速で、部分的に順序付けされたデータでは高速です。後者の場合、バブルよりもはるかに高速です。通常、挿入によるソートは、選択によるソートよりもいくらか高速です。後者とは異なり、バブルソーティングのように、-安定しています。最悪の場合、挿入ソートはデータを逆の順序で処理するため、データが最も遅くなることがあります。テストには、以下を使用しました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。たとえば、std :: bsearch関数を使用して、線形ではなくバイナリ検索を使用すると、少し高速化できます。要素の挿入が非常に速いリストタイプの構造を使用することで、大幅な高速化を実現できます。また、これが最も自然な並べ替えであることに気づくでしょう。たとえば、通常、カードを再生するときに直感的に使用されます。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">シェル</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ソート</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（シェルソート）は高速メソッドの中で最も単純で、プログラミングを学び始めたばかりの学生による実装に非常に適しています。バブルソーティングの一部の変更のみです。それらの唯一の違いは、シェルの並べ替えでは、比較される要素間の距離が通路から通路へと変化し、最初のパスの大きい方から最後の1まで変化するため、シェルメソッドは、これらの最後のパスのプリミティブバブルソートに縮退します。ドナルドシェルは1959年に彼の名前を得た基本的なソートアルゴリズムを公開しました。したがって、これは高速に動作する最初のユニバーサルソーティングの1つです。比較のために、クイックソートアルゴリズムは2年後に公開され、ティムの人気のあるソートまたは内省的なソートは90年代にのみ知られるようになりました。いくつかの興味深い未解決の数学的問題がシェルの並べ替えに関連付けられています。その主な問題は、比較された要素間の変位を最適に選択する方法です。たとえば、いくつかのレコードシーケンスを見つけることができました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A102549</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このようなシーケンスは、巨大な計算によって検出されるため、非常に短い長さA102549を持ちます。これは、わずか8要素であり、約3000要素までのデータに対してのみ十分です。ビッグデータの場合、続編をほぼランダムに見る必要があります。 2の累乗に近い使用値、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、2.25、および3。2の累乗に近い素数は、最悪の結果を示し、最高よりも著しく劣っています。しかし、他の3つのオプションは、パフォーマンスへの影響の点ではほぼ同じで、おそらく最適に非常に近いことがわかりました。さらに、これら3つのケースでは、素数を使用しても明確な利点はありませんでした。対応する作品への参照に基づいて（ベースが2.25である）ウィキペディアで提案されたバイアスが、最良の結果との差が非常に小さい（5-10％以下）ものの、テストで最良の結果を示さなかったことは奇妙です。 A102549を開始点として使用しても、顕著な結果は得られませんでした。ミハイル・オパナセンコはまた、シェルのソートを解明しようとし、式</font><i><font style="vertical-align: inherit;">s </font></i><i><sub><font style="vertical-align: inherit;">n + 1</font></sub></i><i><font style="vertical-align: inherit;"> = 10s </font></i><i><sub><font style="vertical-align: inherit;">n</font></sub></i><font style="vertical-align: inherit;">によって選択された変位が興味深い結果を得ました</font></font><i><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ 3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、非常に良い効果を与え、おそらくそれは理想に近いものです。私の結果はこれを確認します。多くの場合、最良の結果が得られたのはそのようなバイアスでしたが、常にそうであるとは限らず、最も近い結果からのギャップは非常に小さかった（約5％）。</font><font style="vertical-align: inherit;">シェルの並べ替えを実装するための</font><font style="vertical-align: inherit;">私の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、オフセット付きの小さなテーブルを使用しますが、素数を使用しない場合、この並べ替えの特定のバリアントのいずれかの実装で行われたように、テーブルのこれらのオフセットはほぼ瞬時に計算できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深いことに、わずかに異なる方法でトリプルの累乗に近いオフセットを取り、わずかに異なるアルゴリズムを使用する場合（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">実装を</font></a><font style="vertical-align: inherit;">参照）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、32ビットの数値では最高に近い速度が得られますが、より長い数値および回線では、大幅なスローダウンが発生し、場合によっては100％以上になります。 oms7で使用されている最適なアルゴリズムの結果も以下の表にありますが、順調な結果を示していますが、絶対値ではリーダーより大幅に遅れています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最高のオフセットを見つける方法はありますか？おそらく、しかし私はそれがすぐではないことを敢えて示唆する。シェルソートはLinuxカーネルで使用され、少なくとも1つのCライブラリでは、そのコードが標準のqsort（）関数に使用されます。シェルの最適なソート速度は、「実際の」高速対数方式よりもわずかに遅いだけであることが理論的に証明されています。実際、最適なシェルのためのそれらのサイズに処理時間の平均データの依存性は、式∽によって記載されてソーティング</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（対数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> /ログログ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であっても非常に大きいため、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nであり、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に近い式に∽ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ログ</font><i><font style="vertical-align: inherit;">N</font></i><font style="vertical-align: inherit;">他の高速の方法のための典型的な</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。通常、シェルの並べ替えは、理論的に高速なメソッドよりもはるかに高速であり、かなり大きな配列（1,000万要素程度）を処理する場合にのみ、少し劣ります。このソートは、追加のメモリを絶対に必要とせず、データを入力するためのさまざまなオプションに対して安定して動作し、クイックソートと比べて有利です。 Shellメソッドは安定性プロパティを備えていません。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速い</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クイックソートはシェルアルゴリズムよりもわずかに複雑であり、ランダムに散在するデータを整理する最速の方法の1つです。ただし、この並べ替えにはいくつかの欠点があります。二次依存性によれば、彼女は追加のメモリを必要とし、非常にまれなケースでは、それが非常にゆっくりと動作します。この方法の主な考え方は、データを2つの部分に分割することです。1つの部分のデータは、他の部分よりも多かれ少なかれ（選択した順序に依存）する必要があります。この分離にはいくつかの方法があります。理想的には、各分割で、両方のパーツのサイズはほぼ同じで、すべての中で最悪の場合、分割中に1つのパーツが1つの要素のみで構成されていることがわかります。クイックソートアルゴリズムのいくつかの実装、特に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Hoarメソッド</font></a><font style="vertical-align: inherit;">について考えてみましょう</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、データを2つの部分に分割する参照要素が、ソートされたデータの中央から選択されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非常にコンパクトな</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Lomutoアルゴリズム</font></a><font style="vertical-align: inherit;">も考慮してください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Hoare法よりもわずかに（約1％）速い場合があります。ただし、通常の特殊なケース、たとえば、順序付けされたデータ、逆データ、またはマロバリアントデータでは、Lomutoメソッドは極端に遅いことを示します。さらに、迅速な並べ替えについて検討されたオプションの中で、これは実際の実行中のスタックサイズに対して最も貪欲であることがわかりました。比較的小さな配列を並べ替える場合、この並べ替えだけでスタックに十分な8メガバイトがなかったため、ulimitを介してこのサイズを設定する必要がありました。スタックに対するこのような貪欲さは、大規模なデータ（数千万行）の処理を大幅に遅くし、その性質を呼び出すのに苦労しています。このようなデータでは、次の段落からのこの並べ替えを使用しない方がよいとしか言​​えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lomutoメソッドは最後の要素を参照要素として選択しますが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サポート要素</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をまったく使用せずにクイックソートを実装できます</font><font style="vertical-align: inherit;">。より正確には、このような要素の選択は、すでに実行されたデータの二分法の結果として行われます。この速度特性によるソートは、通常は少し高速ですが、Lomutoメソッドに近いことがわかりました。極端な場合、Lomutoよりも著しく高速ですが、Hoarよりも低速です。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">アルゴリズム</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
は2009年に公開されました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java言語の標準となった2つのアンカーポイントによるクイックソート。このアルゴリズムは、最も典型的なものと比較して順列の数を20％減らしますが、比較の数は変わりません。著者はウラジミール・ヤロスラフスキーです。原則として、他のクイックソートよりも高速に動作します。 x86アーキテクチャーでは、スワップは通常割り当てよりも速く機能し、C ++文字列の場合ははるかに高速であるという古くからの事実を使用して、少し最適化しました。これまでに検討されたすべてのクイックソートには、安定性プロパティがありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再帰呼び出しを整理するには、迅速なソートのための追加メモリが必要です。ただし、このような2番目の呼び出しは、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">末尾再帰の</font></a><font style="vertical-align: inherit;">最適化を実行することでループに置き換えることができます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速度は向上しませんが、使用される追加データのサイズが大幅に減少します。この種の最適化でHoarソートオプションを実装しました。さらに、システムプログラムでは、スタックポインターを確認し、それが重要な値に近づいた場合は、すべての再帰呼び出しをリセットして再度並べ替えを開始できます。この場合、ほぼ順序付けられたデータを遅くしないクイックソートオプションを使用する必要があることは明らかです。 、上記で提案されたHoarのバージョン。追加のメモリを使用して戦うことは、GCCの標準C言語ライブラリからの迅速なソートの主なアイデアと考えることができます。それは一般的に再帰を放棄しました。代わりに、彼らは彼女のシミュレーションを使用します。コードはかなり大きく、約150行でした。この並べ替えについては、以下に少し資料があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソート</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ハッシュ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ハッシュソートすることは）近い∽に、非常に高速にすることができ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ただし、2次依存で動作する場合もあります。このソート方法の速度は、入力に大きく依存します。データがハッシュ関数によって補助配列に均等に分散されている場合、最も速い線形関係が得られます。そして、すべてのデータは、遠く離れて、いくつかの「質量中心」の近くにグループ化されている場合か、である多くの同一のデータ要素があるとき、ハッシュ衝突の多くが発生したとき、我々は最悪のタイプ∽取得</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N </font></font></i><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存性を</font><font style="vertical-align: inherit;">。ツリーのソートに関しては、ハッシュをソートするには、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">以下</font></a><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">リストにあるように</font></a><font style="vertical-align: inherit;">、かなり多くの追加データが必要です</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、コードには、並べ替え可能な整数（int32、x86-64）ごとに12バイトの追加バイトが必要です。ハッシュソートの興味深い特性は、データ要素間の比較演算がないことです。これにより、このソートは、上記のすべてのソートと区別されます。より正確には、これらの操作は衝突に対してのみ必要です。データを並べ替えるときに、キーがデータ要素全体と一致する場合、同一の要素の数に追加のカウンターを使用できますが、これはかなり疑わしい最適化です。リストの代わりにバイナリツリーを使用してハッシュ衝突データを格納することもできます。これにより、衝突が多い個々の特定のケースでの作業が大幅に高速化されますが、一般に、バイナリツリーを使用すると、多くの場合、速度が低下します。データは、ほぼ100バイトの追加情報を格納する必要があります。実装した</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリツリーを使用したハッシュソートの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">3つのオプション</font></a><font style="vertical-align: inherit;">：1つは順序なしツリーを使用し、他の2つはstdおよびboostライブラリの標準ツリーを使用します。ハッシュの並べ替えは、非常に短い文字列を除いて、テキスト文字列の並べ替えには実際には適していません。そのようなデータに対して適切なハッシュ関数を作成することは不可能だからです。標準のC ++ハッシュ（unordered_multiset）をソートに適合させることができませんでした。等値ではなく単調なハッシュ関数と順序関係を使用しようとしましたが、これは機能しませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列のソートは前のものと非常に似ています。補助配列も使用され、値はハッシュ関数によって入力されます。衝突が発生した場合は、占有されている要素の連続したフラグメントを左または右の位置にシフトし、ハッシュ関数で示された位置を新しい要素に解放する必要があります。良好な速度を得るには、補助配列が元の配列の数倍（2〜3）である必要があります。補助配列のサイズが大きくなると、ソートされたデータとそれに関連付けられたハッシュ関数に応じて、動作速度が特定の制限まで増加し、その後（通常は4〜5）減少します。操作の速度はハッシュの速度とほぼ同じですが、良いデータでは少し速く、悪いデータでは著しく遅くなります。このソートには、さらに多くのメモリが必要です。ソートされた配列の要素数を40億強に制限すると、トリプルの補助配列にはハッシュでのソートと同じ量の追加データが必要になり、トリプルの配列では28バイトが必要になります。これは、ツリーによるソートよりはるかに少ないか、ハッシュよりはるかに少ないです。木と。この並べ替えは、文字列の操作にもほとんど適していません。ウィキペディアにはそのようなアルゴリズムに関する記事はありませんが、私のものです</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深いことに、ウィキペディアの優れた概要</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、要素の比較に基づくメソッドと要素の絶対値に基づくメソッドの間に自然に配置できる配列の並べ替えやハッシュなどの中間メソッドについての言及はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較をまったく使用しない最速のソートの1つは、19世紀以来知られている</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ビット単位のソート</font></a><font style="vertical-align: inherit;">です。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（基数ソート）。彼女のアイデアは非常に単純です。データ表現のビットのグループを操作する必要があります（テストでは、8、11、16ビットのグループを使用しました）。テーブルはグループごとに作成され、結果は比較的単純な方法で結合されます。ビット単位の並べ替えを使用するには、主に2つの方法があります。数字を右から左にソートする（これはLSD-最下位桁オプションです）ため、および文字列を左から右にソートする（これはMSD-最上位桁オプションです）ために、数字を取る方が便利です。多くの場合、ビット単位の並べ替えは、他のデータの並べ替え方法よりも大幅に高速です。驚いたことに、ビット単位の並べ替えのサポートはまだそれほど重要ではありません。ブーストにも標準のC ++ライブラリにもありません。C++の数値または文字列を操作するためのよく知られたライブラリのバージョンも知りません。この種のもちろん、そして欠点。これは、並べ替え用のデータの種類に非常に敏感です。たとえば、各サイズのデータ​​に対して独自のバージョンの並べ替えを用意する必要があり、符号なし整数と符号付き整数に対して特別なオプションを作成する必要があります。また、実数の操作のサポートには、かなりの労力が必要になる場合があります。最下位バイトから最上位バイトまでの順序を使用する場合、そのバリアントは通常、元のデータよりも少し大きい追加のメモリを必要とします（これは、ハッシュまたは配列によるソートの場合よりもはるかに少なく、さらにツリーによるソートの場合よりもはるかに少なくなります）。さらに、このオプションは長い文字列のソートにはほとんど役に立ちません。この種の私のコード符号なし整数と符号付き整数の特別なオプションを作成する必要があり、実数の処理をサポートするにはかなりの労力が必要になる場合があります。最下位バイトから最上位バイトまでの順序を使用する場合、そのバリアントは通常、元のデータよりも少し大きい追加のメモリを必要とします（これは、ハッシュまたは配列によるソートの場合よりもはるかに少なく、さらにツリーによるソートの場合よりもはるかに少なくなります）。さらに、このオプションは長い文字列のソートにはほとんど役に立ちません。この種の私のコード符号なし整数と符号付き整数の特別なオプションを作成する必要があり、実数の処理をサポートするにはかなりの労力が必要になる場合があります。最下位バイトから最上位バイトまでの順序を使用する場合、そのバリアントは通常、元のデータよりも少し大きい追加のメモリを必要とします（これは、ハッシュまたは配列によるソートの場合よりもはるかに少なく、さらにツリーによるソートの場合よりもはるかに少なくなります）。さらに、このオプションは長い文字列のソートにはほとんど役に立ちません。この種の私のコードこのオプションは、長い文字列のソートには適していません。この種の私のコードこのオプションは、長い文字列のソートには適していません。この種の私のコード</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、言及されたoms7記事のコードに基づいています。逆バイト順オプションはより用途が広く、文字列のソートに非常に適しています。このオプションは、bsdライブラリのradixsort（）関数で行われるように、追加のメモリを使用せずに実装できます（その代償として、安定性プロパティが失われます）。私の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このオプションの場合もoms7コードに基づいており、追加のメモリを使用し、ソースデータが少し大きく、安定性プロパティがありますが、文字列用に最適化されていないため、前述のbsdライブラリの同様の関数sradixsort（）よりも著しく悪いパフォーマンス特性を示します。この並べ替えは、小さな数値配列を処理する場合、バブルよりも数桁遅く動作する場合、驚くほど悪い結果を示す可能性がありますが、数ミリ秒以下の非常に小さな値について話しているため、この違いは簡単にはわかりません。これは、小さいサイズの補助配列を使用するためですが、小さいサイズのデータ​​をソートすると、これらの小さいサイズは、ソートされたデータ自体よりも大きくなる可能性があります。速度低下を回避するために、このような場合、「左から右」オプションは、メインのソートではなく挿入ソートを使用します。結論として、これが常に確実に∽の速度で機能する、私が知っている唯一の比較的人気のある並べ替えであることは注目に値します</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですが、ここでの比例係数はデータ要素のサイズに依存し、文字列や長い数値の場合は非常に顕著になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビット単位のMSD並べ替えのオプションは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビーム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並べ替え</font><font style="vertical-align: inherit;">です。これは、連想配列のキーを効率的に配置できるデータ構造です。私の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、メモリの使用を最適化したにもかかわらず、それでも非常に貪欲であることが判明しました。速度によって、長い行をソートするときに最良の結果が得られました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、標準ライブラリで見つけることができるいくつかの並べ替えを検討します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準Cライブラリ（GCCのバリアントであるqsort）の簡単なものから始めましょう。これについてはすでに書いています。ここで追加できるのは、この並べ替えと他のC並べ替え（たとえば、BSDライブラリからの次の並べ替え）がオブジェクトデータ（特にC ++文字列）の操作に適していないことです。そのようなデータは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">PODで</font></a><font style="vertical-align: inherit;">はないためです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ソースがあれば、memcpy操作を通常の割り当てに置き換えることで問題を簡単に解決できます。また、一部の標準Cライブラリでは、この並べ替えは必ずしも高速であるとは限らず、他のライブラリと置き換えることができる場合もあります。 GCCの現在のバージョンでは、このソートには安定性のプロパティさえ含まれています。データを収集するときに言及されたsiソートに時々驚きがありました。たとえば、機能オブジェクトを介してstd ::ベクトルタイプを操作すると、問題が発生する可能性があります。オブジェクトデータで注意して使用することをお勧めします。実行によると、この並べ替えは比較的遅い場合があります。数値を操作する場合、他の高速並べ替えの実装よりも明らかに速度が劣りますが、si-stringを操作する場合は、2つの制御点での並べ替えのみが優先される場合があります。しかし長い行では、標準のqsortがほとんど常に追い越します。最も興味深いことは、10億の整数をその助けを借りてソートしようとしたときに発見されました。タイプ7を入力すると、時間依存性が2次の法則に近づく、つまり、「処理」が数年続く可能性があることがわかりました（終わりを待たずに停止しました） 21時間の実行時）。少ないデータでは、この並べ替えは通常、すばやく動作するアンカーポイントを選択できます。少ないデータでは、この並べ替えは通常、すばやく動作するアンカーポイントを選択できます。少ないデータでは、この並べ替えは通常、すばやく動作するアンカーポイントを選択できます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++標準ライブラリでは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">内省的な</font></a><font style="vertical-align: inherit;">並べ替えが使用されますが、std :: sortで使用される正確なメソッドは実装に依存し、GCCに関する情報のみが提供されます。実行によると、これは数値を操作する場合のスプレッドソートの次に2番目に高速で、スプレッドソートの利点は小さい（ほぼ0〜30％）が、文字列ソートではすべてがはるかに悪い-リーダーよりも3〜4倍低くなる可能性がある。これは実際にはクイックソートであり、2つの特殊なケースが考慮されます。1）再帰の数が大きくなりすぎた場合、ヒープによるソートへの切り替えが発生します。 2）ソートするアイテムの数が少ない場合、挿入によるソートに切り替わります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++標準ライブラリからの安定したソート（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: stable_sort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、その名前が示すように、安定性の特性があります-同じキーを持つ要素間の相対的な順序を保持します。このプロパティが必要になることはめったにありませんが、自分の経験に基づいて、根拠のないことについて書いています。追加のメモリを使用できるため、処理速度が向上します。驚くことに、このソートはstd :: sortよりも高速であることがよくあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
超人気言語のpythonでは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Timの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並べ替えが標準として使用されます</font><font style="vertical-align: inherit;">。テストでは、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">githubリポジトリの</font></a><font style="vertical-align: inherit;">バージョンを使用しました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、部分的に順序付けられたデータで記録を破る優れた結果を示していますが、平均すると、リーダーよりも著しく低速です。通常、その速度は高速ソートとシェルソートの平均ですが、ライン上ではリーダーに近い場合があります。安定性があります。これは比較的複雑なアルゴリズムを実装しており、標準の実装では2015年にエラーが発見されましたが、その表現にはかなり非現実的な状況が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BSD Cライブラリにはビット単位のソート（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">radixsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）とその安定バージョン（sradixsort）。残念ながら、これらの種類はどちらもC文字列にのみ使用できます。テストデータからわかるように、今日は文字列を並べ替える最速の方法であるため、C ++文字列に標準オプションがないことは驚くべきことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BSD Cライブラリには、より多くのソート</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マージ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mergesort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）この並べ替えは、シーケンシャルアクセスデータ（ファイル、リスト）の中で最も高速なものの1つとして知られており、リストを並べ替えるためのC ++標準ライブラリ（std :: listおよびstd :: forward_list）でおそらく使用されます。ちなみに、彼女は1948年から知られ、その開発者の1人は非常に有名な数学者であり、最初のコンピューターシステムフォンノイマンの専門家でした。クイックメソッドの中で、このソートは最良の特性によって区別されていませんが、原則として、シェルメソッドよりもいくらか高速です。追加のメモリが必要で、通常は持続的に実装されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">束</font></a><font style="vertical-align: inherit;">による仕分けはまだあり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ヒープソート）。ヒープは通常、キューイングを優先度で最適化するために使用されますが、ソートにも使用できます。ソートヒープには追加のメモリは必要ありませんが、安定性プロパティはありません。数値の速度は、シェルメソッドよりも大幅に（最大3〜6倍）遅くなりますが、ラインのラインがあまり短くない場合は、非常に良い結果が得られ、追い越しになります（ラインの長さが長くなると、利点が大きくなります）シェルメソッド。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒープの並べ替えは、C ++標準ライブラリでも利用できます。このようなソートは2つの操作で行われます。ヒープの構築（std :: make_heap）と実際のソート（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: sort_heap）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）ここでは、bsdライブラリとは異なり、ソートはヒープの操作の1つにすぎません。通常、この並べ替えオプションは、以前のオプションよりも少し高速です（bsdオプションは、短い数値と長いs行でのみより良い結果を示します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準のC ++ライブラリを使用すると、バイナリバランスツリー（std :: multiset）を並べ替えることができます。このメソッドは、非再帰的なクイックソートと見なすことができます。標準のメモリアロケータは低速であることは注目に値します。そのため、最良の結果を得るには、独自のアロケータを使用する必要があります。これにより、速度が約10〜30％向上します。また、この方法では、各データ要素にg ++を使用して大量のメモリを追加する必要があることにも注意してください。それに加えて、x86-64アーキテクチャでは32バイトを格納する必要があります。そのようなツリーをヒープとして、つまり追加せずに格納するのは興味深いことです。バイト。 boost :: container :: multisetを使用する場合、必要なメモリは少なくなります。データ要素ごとに24バイトが追加されるだけです。しかし、ブーストのように、そして、標準ライブラリは1つの不愉快な驚きを示しました-その過程で、彼らは時々必要以上のメモリを必要としました。おそらく、これはバイナリツリーのバランスが原因です。コード-</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
boostライブラリには</font><font style="vertical-align: inherit;">、21世紀に発明されたアルゴリズムである</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spreadsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります。これは、有名なライブラリで現在利用できる最も高速な方法です。この並べ替えはビットごとのアイデアを使用しており、それと同様に、引数のタイプについてかなり不機嫌になる可能性があります。通常、この並べ替えは記録的な結果を示しますが、最も近い競合他社の結果よりも大幅に優れている場合があります。唯一の例外は、C行の並べ替えです。この場合、bsdライブラリのビット単位のメソッドよりも大幅に劣ります。長いC行をソートする場合、スピンソートや2つのアンカーポイントを使用したクイックソートなどの他の方法よりも劣ることがあります。スプレッドソーティング（boost v1.62）は非常に厄介な</font><em><font style="vertical-align: inherit;">問題を</font></em><font style="vertical-align: inherit;">示しました</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-小さい（最大1000要素）C文字列配列をソートすると、エラーが発生します。</font><font style="vertical-align: inherit;">著者が述べたように、内省的なソートを改善</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
する新しい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pdqsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムもあり</font><font style="vertical-align: inherit;">ます。ウィキペディアではまだ説明されていないこの新しいアルゴリズム。その結果は、悪くはありませんが、それほど印象的ではありません。 std ::よりも遅いですが、短い整数でソートしますが、文字列や長い整数では速くなります。どちらの場合も、違いはわずかです。この並べ替えの最良の結果は、長いC ++文字列で得られました。ここでは、目立ちますが、リーダーのスプレッド並べ替えに比べて劣っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブーストでは、まだ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">スピンソートを</font></a><font style="vertical-align: inherit;">見つけることができます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは新しいアルゴリズムでもあり、前のアルゴリズムとは異なり、安定性プロパティがあり、ウィキペディアにはまだ記載されていません。通常、彼はリーダーの近くにいますが、彼の背後に顕著な遅れがあります。それほど多くはないが、追加のメモリが必要です。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">レッツ・エンド</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flat_stable_sort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じブーストライブラリから。これは、ウィキペディアでまだ説明されていない別の新しい堅牢なアルゴリズムです。これは断然最速の方法ですが、他のほとんどの高速ライブラリーの方法よりわずかに劣ります。追加のメモリをほとんど使用しません（ただし、常に8 KBの固定サイズのテーブルが必要です）。多くの場合、Shellメソッドよりも著しく高速です。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">テーブルを</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
検討して</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD Phenom™II X4 955 @ 3.214 MHzプロセッサーを搭載した8 GBのRAMを搭載したコンピューターでのこれらのアルゴリズムの動作時間（ミリ秒）。コンピューターは合計で数か月間動作し、テーブルが読み込まれた2つのjsonファイルに収集されたデータの合計サイズは約400 KBです。タイミングは実行回数の平均で示されます。サイズが小さいほど、実行回数は多くなります。かなり複雑な方法でキャッシュを操作すると、計算の速度が変わるため、得られる結果はせいぜい概算にすぎません（タイミングの不正確さが最大20％に達すると想定できます）。 PC向けの最新の最高のプロセッサでは、結果が2〜3倍速く得られると思いますが、より多くの最新のプロセッサは、異なる周波数とそれらで得られる結果を切り替えることで機能することを覚えておいてください。さらにおおよそになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これと次の表はインタラクティブです。タイミングの絶対値に加えて、平均値、中央値、最小値、最大値に対する相対値も確認できます。文字の精度を変更できます。さまざまなタイプの充填とデータタイプのタイミング関係を取得することもできます。たとえば、後者は、C文字列のソートがC ++文字列よりも著しく速いことを示している場合があります。ソート方法から、さまざまなサブセットを選択してアセンブルすることもできます。もちろん、任意の列でソートを設定できます。残念ながら、ハブの記事ではJavascriptの使用方法がわかりません。そのため、これらのテーブルは参照によってのみ利用できます。 github.ioが過負荷であることが判明した場合に備えて、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テーブル</font><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テーブル</font><font style="vertical-align: inherit;">へのバックアップリンクも提供します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間はミリ秒単位で測定されますが、時間依存の法則では、小さすぎる係数を回避するために、マイクロ秒の式が与えられています。</font><font style="vertical-align: inherit;">したがって、式の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の値を代入する場合</font><font style="vertical-align: inherit;">、結果を1000で割って、テーブルから対応する数値に近い数値を取得する必要があります。</font><font style="vertical-align: inherit;">時間依存の法則は、2つの結果の比較から得られたタイミングに基づいて導出されます（通常、極端なものが取られます）。</font><font style="vertical-align: inherit;">出力からの実際の値の相対偏差のオプションを使用して、派生した法則の品質を確認できます。</font></font><br>
<br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この表の結果からのいくつかの一般的な結論：</font></font><br>
</p><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000万要素までのデータでの最良のシェルソートは、timsortやいくつかのクイックソートさえも追い抜くことができます。</font></font></li>
<li>timsort     qsort (clib),   ,    ;</li>
<li>heapsort   treesort   ,        ,   -  . ,          –    .  ,   heapsort  treesort      ,     <i>N</i>log <i>N</i>,    –    ,         ,  heapsort  treesort,  ,    ,  <i>N</i>log <i>N</i>.  ,           ;</li>
<li>    ,           –     -   ,  . ,   ,     ,           ;</li>
<li>,             –   ,     x86        ;</li>
<li>hash_sort    ,   - ,  -         .     (   )      (quick) .   ,    - ,       , , 10<sup>5</sup>, 10<sup>6</sup>  10<sup>7</sup> 32-      (partially ordered)         ! -   . :) ,   ,       .</li>
</ul><br>
<p>       :<br>
</p><ul>
<li>        .                .            .      qsort (clib).           ,       –     2<sup><i>N</i>-3</sup>/<i>N</i><sup><i>N</i></sup>,      .    ,        ,     ,     , , ,        -  ,        .      ,        ,   ,   .                  ;</li>
<li>   ,   «»    ,     , quick-,   ;</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハッシュソーティングは、タイプ8および9のフィリングで非常に悪い結果を示しました。これは、単調なシーケンスが小さい値から始まる連続する値から取得され、1％の乱数が低い値から最大値までの範囲から取得されるため、データのすべての連続する99％に対応します。 1つのハッシュ要素に。</font><font style="vertical-align: inherit;">このケースは、このソートまたは不明なデータを持つ配列でのソートを使用するときに発生する可能性がある問題を非常によく示しています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選択による並べ替えは、すべての種類の塗りつぶしで非常に安定して動作します。ヒープとツリーの並べ替えも、明確なピークとディップがなく、非常に安定しています。</font><font style="vertical-align: inherit;">もちろん、これはシェルの並べ替えや、標準ライブラリのその他のほとんどのクイックメソッドにも当てはまります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、並べ替えアルゴリズムで使用されるデータの種類について説明します。</font></font><br>
<br>
<ol>
<li> , 32-  (int32_t),    .        –      ,         ;</li>
<li> , 64-  (int64_t);</li>
<li> , 128-  (__int128 – ,  , GCC);</li>
<li>     (int32_t),       (INT1P4).             ,         ;</li>
<li>    , double (float numbers);</li>
<li>  C++  .     1  16 (strings short  c-strings short);</li>
<li>   ++  ,    1  256 (strings  c-strings);</li>
<li>    ++,    1  2<sup>20</sup> (   ),    ,       512, –       ,         1  512 (strings long  c-strings long).</li>
</ol><br>
<p>        :<br>
<br>
</p><ol>
<li>;</li>
<li>   (, ordered);</li>
<li>   ( , reversed);</li>
<li>     0  99 ( , low variation 100);</li>
<li>   0  1 ( , low variation 2);</li>
<li> 0 ( , low variation 1);</li>
<li>,    qsort (Hoare)    . ,     2<sup><i>N</i>-3</sup>     <i>N</i>;</li>
<li>  ,   1%   (partially ordered);</li>
<li>  ,   1%   (partially reversed).</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランダムデータは配列を埋める最も一般的なケースであり、他のすべての方法は非常にまれであり、特定の通常の操作中にはほとんど不可能であることを強調する必要があります。</font><font style="vertical-align: inherit;">ソートがすべての可能なデータシーケンスで機能</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">する</font></a><font style="vertical-align: inherit;">テスト結果を</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
見てみましょう</font><font style="vertical-align: inherit;">。そのようなシーケンスの数は、その長さの階乗に等しいので、長さ12のシーケンスの場合、479'001'600のバリアントがあります。最新の優れたPCは、1分未満でその数を計算します。長さ14のシーケンスを取る場合、数時間のコンピューター操作で87'178'291'200バリアントが既に取得されています。したがって、次の表は、平均時間を示しています（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">RDTSC</font></a><font style="vertical-align: inherit;">命令によって取得されたプロセッサーサイクル）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）長さが12までのすべての順列を並べ替える場合の1つの並べ替え。以前の数値型と短い文字列はデータとして扱われます。もちろん、繰り返し要素を持つシーケンスは考慮されないことに気づくでしょう。しかし、私はあえて彼らの存在が結果を質的に変えることはないが、彼らの受け取りを著しく遅くするかもしれないことを示唆するように勇気づけます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような小さなデータの結果はあまり代表的ではありませんが、特に複雑なソート方法の場合はそうですが、それらは依然としてソート動作のアイデアに追加されます。私の知る限り、いくつかのソートは、小さな配列を処理するときにメインアルゴリズムを別のソートに置き換えます。これらは、2つのアンカーポイントとradix_msd（最後の2つは挿入を使用）で高速なスプレッドソートです。また、一部の並べ替え（flat_stableおよびradix）は小さなテーブルを使用しますが、データサイズが小さいと、これらのテーブルはデータ自体よりもはるかに大きくなるため、他のメソッドと比べてこれらのメソッドの速度が大幅に低下し、奇妙な結果が生じます。奇妙な結果は、他のビット単位の並べ替えや、ハッシュや配列の並べ替えでも得られます。そのような異常な結果は簡単に説明されます小さいデータに対するこれらのメソッドのソート前のデータ準備時間は、ソート時間自体よりも長いこと。もちろん、このような短い時間間隔（ナノ秒）を測定する場合、表示される法則に対するさまざまなエラーの影響は、前の表よりもはるかに大きくなります。したがって、法則は非常に近似的であることがわかり、多くの場合、誇張された値に「ドリフトして」います。後者は、小さなデータを処理する場合、並べ替え時間自体が、並べ替え関数を呼び出す時間と、時間を測定するために必要ないくつかの補助操作に匹敵するという事実によって部分的に説明されます。プログラムは名前付きのオーバーヘッドを出力から差し引こうとしますが、それはかなりおおよそ行われることがわかります。これらすべてを踏まえて、私はあえて仮定しますさまざまなタイプのデータの結果を比較し、加えられたコメントを考慮に入れると、正確からほど遠くない仮定を立てることができる場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論として、追加のメモリをソートするためのさまざまなテスト方法でどれだけ必要かを示す別の表。明らかに、この値はシステムに依存します。私のテストでは、すでに書いたように、これはx86-64、GCCです。その中の文字Tは、バイトでのタイプのサイズを意味します（文字列の長さはこのサイズに含まれません：C行の場合、これはポインターのサイズです。C++行の場合、これは記述子のサイズです。x86-64GCCの場合は32バイトです）、文字Lは中央ですバイト単位の型の長さ（数値の場合はT、文字列の場合は文字列の平均の長さ）、文字Aの値は1または0になります。これは64ビット境界への配置であり、文字Mは標準のメモリアロケータからの配置です（想定されています）。 32バイト境界に揃えます）。アイコン</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> このタイプのソートに関するデータは、/ proc / PID / statusからVmRSSフィールドを読み取る分析に基づいてのみ取得されたことを意味します（上記のフィールドはプロセスプログラムのサイズです）。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加メモリテーブル</font></font></b><div class="spoiler_text"><div class="scrollable-table"><table>
<tbody><tr>
<th></th>
<th></th>
</tr>
<tr>
<td>array*1</td>
<td align="center">(T + 1/8)<i>N</i></td>
</tr>
<tr>
<td>array*k, k&gt;1</td>
<td align="center">(T + 4k)<i>N</i></td>
</tr>
<tr>
<td>bubble</td>
<td align="center">0</td>
</tr>
<tr>
<td>clib_qsort</td>
<td align="center"> ≈T<i>N</i>/2  ≈T<i>N</i><sup>*</sup></td>
</tr>
<tr>
<td>flat_stable</td>
<td align="center">≈T<i>N</i>/256</td>
</tr>
<tr>
<td>hash</td>
<td align="center">(T + 8 + 4A)<i>N</i></td>
</tr>
<tr>
<td>hashbt</td>
<td align="center">(T + 12)<i>N</i></td>
</tr>
<tr>
<td>hashbt_boost</td>
<td align="center">(56 + T + 4A + M)<i>N</i></td>
</tr>
<tr>
<td>hashbt_std</td>
<td align="center">(80 + T + 4A + M)<i>N</i></td>
</tr>
<tr>
<td>heapsort</td>
<td align="center">0</td>
</tr>
<tr>
<td>insertion</td>
<td align="center">0</td>
</tr>
<tr>
<td>mergesort_bsd</td>
<td align="center"> ≈Tlog<sub>2</sub><i>N</i>  T<i>N</i><sup>*</sup></td>
</tr>
<tr>
<td>pdq</td>
<td align="center">Tlog<i>N</i></td>
</tr>
<tr>
<td>quicksort</td>
<td align="center"> ≈16log<sub>2</sub><i>N</i>  16<i>N</i></td>
</tr>
<tr>
<td>quicksort_tco</td>
<td align="center"> 0  <i>N</i></td>
</tr>
<tr>
<td>radix</td>
<td align="center">≈T<i>N</i></td>
</tr>
<tr>
<td>radix8_trie</td>
<td align="center"> ≈T<i>N</i> + 24L  ≈(T + 24L + 12)<i>N</i></td>
</tr>
<tr>
<td>radix_bsd</td>
<td align="center">0</td>
</tr>
<tr>
<td>radix_msd</td>
<td align="center">≈T<i>N</i></td>
</tr>
<tr>
<td>selection</td>
<td align="center">0</td>
</tr>
<tr>
<td>shell</td>
<td align="center">0</td>
</tr>
<tr>
<td>spin</td>
<td align="center">T<i>N</i>/2</td>
</tr>
<tr>
<td>spread</td>
<td align="center">≈0</td>
</tr>
<tr>
<td>sradix_bsd</td>
<td align="center">≈T<i>N</i><sup>*</sup></td>
</tr>
<tr>
<td>stlsort</td>
<td align="center"> 0   ≈Tlog<sub>2</sub><i>N</i><sup>*</sup></td>
</tr>
<tr>
<td>stlstable</td>
<td align="center"> 0  ≈T<i>N</i>/2<sup>*</sup></td>
</tr>
<tr>
<td>timsort</td>
<td align="center"> 0  ≈T<i>N</i><sup>*</sup></td>
</tr>
<tr>
<td>tree_boost</td>
<td align="center">(T + 24)<i>N</i></td>
</tr>
<tr>
<td>tree_stl</td>
<td align="center">(T + 32)<i>N</i></td>
</tr>
</tbody></table></div><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、プリミティブと高速の両方の他のソート方法があります。</font><font style="vertical-align: inherit;">ブーストライブラリには、システムに追加のプロセッサコアが存在することを利用できる並列アルゴリズムがあります。</font><font style="vertical-align: inherit;">std :: multisetの代わりに自己組織化コンテナーboost :: container :: flat_multisetを使用することもできますが、動作が非常に遅くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機会に、一般的なboostライブラリに関するコメントをいくつかお伝えします。通り過ぎないことをお勧めします。原則として、boostの標準ライブラリにある機能でさえ、より適切に実装されており、場合によっては（正規表現など）はるかに優れています。コンテナーについて話すと、ブーストでは顕著に多くなり、標準のものと一致するものは、時々やや速くなり、小さいながらも楽しい改善が見られることがあります。 Boostはタイプをより徹底的にチェックします。これにより、通常は発生しないほとんどとらえどころのないエラーの検出に役立つことがありますが、状況によっては突然アクティブになることがあります。ブーストの不利な点には、このライブラリの多くの構成でのコンパイルエラーに関する無条件に完全に読み取り不能で大量のメッセージが含まれます-これは、程度は低いですが、標準ライブラリに適用されます。 C ++開発者がこれについて何かをする時がきました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストやその他の関連資料を含むすべてのファイルは、私の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リポジトリ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から取得でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">生のソースデータに興味がある場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらから</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入手でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">（1.4 MB）。</font><font style="vertical-align: inherit;">コメント、批判、追加があれば嬉しく思います。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja467457/index.html">手術からゲーム開発への道、またはUnityでのモバイル開発の最初の体験</a></li>
<li><a href="../ja467459/index.html">マイクロコントローラーが1.6 Gbpsでデータを読み取る方法</a></li>
<li><a href="../ja467463/index.html">ただの除算、または数学理論を作成し、それに40万ドルを稼ぐ方法。シリーズ3、最終</a></li>
<li><a href="../ja467465/index.html">クラウドは超低予算のスマートフォンを節約しますか</a></li>
<li><a href="../ja467471/index.html">Soulless ILVおよび同じプロバイダーに対するSoul Mikrotik</a></li>
<li><a href="../ja467475/index.html">Thread.Abort（）を.NET Coreに返します。CoreCLRおよびCoreFXのバージョンをアプリケーションに提供する</a></li>
<li><a href="../ja467477/index.html">Kubernetes 1.16：ハイライトの概要</a></li>
<li><a href="../ja467479/index.html">Kir Shatrov：ShopifyはRailsで始まり、ここではこのフレームワークを心から愛しています。</a></li>
<li><a href="../ja467485/index.html">pwnable.kr 23による問題解決-md5計算機。Stack Canaryを扱います。PythonでのCライブラリの接続</a></li>
<li><a href="../ja467487/index.html">ブロックチェーンと暗号通貨の支払いの将来について</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>