<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüéì üéÄ ‚ôÄÔ∏è Wie wir Mikrofonsysteme auf STM32 testen: die Erfahrung von Yandex-Ger√§teentwicklern üìÇ ‚óΩÔ∏è ü§≤üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, ich bin Gennady "Crail" Kruglov vom Yandex-Team f√ºr Hardwarel√∂sungen. 
 
 Die Auswahl der Mikrofone f√ºr die Mikrofonmatrix ist ein komplexer un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wie wir Mikrofonsysteme auf STM32 testen: die Erfahrung von Yandex-Ger√§teentwicklern</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/503920/"><img src="https://habrastorage.org/webt/dg/ni/vr/dgnivrsbkyzydcn6d-uvht3oygc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hallo, ich bin Gennady "Crail" Kruglov vom Yandex-Team f√ºr Hardwarel√∂sungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Auswahl der Mikrofone f√ºr die Mikrofonmatrix ist ein komplexer und interessanter Teil unserer Arbeit: Wir testen Modelle mit verschiedenen Parametern, experimentieren mit verschiedenen Matrixkonfigurationen und verbessern die Klangverarbeitungsalgorithmen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entwickler, die Echo- und Rauschunterdr√ºckungsalgorithmen erstellen, k√∂nnen nicht nur Rohdaten verarbeiten, die zuvor von einem Ger√§t im Labor entnommen wurden, sondern auch in Echtzeit mit einer neuen Mikrofonmatrix interagieren, indem sie diese an ihren Laptop anschlie√üen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint nur auf den ersten Blick einfach. </font><font style="vertical-align: inherit;">In diesem Artikel werde ich erkl√§ren, wie wir das Problem der √úbertragung von Ton von sieben Mikrofonen mit einer PDM-Schnittstelle auf einen Computer √ºber USB gel√∂st haben, auf welche Hardware- und Software-Nuancen wir gesto√üen sind und wie diese √ºberwunden werden k√∂nnen (Spoiler: Dieser Ansatz kann f√ºr Matrizen mit einer Anzahl von Mikrofonen ‚â§ 8 angepasst werden ) </font><font style="vertical-align: inherit;">Am Ende des Beitrags werde ich einen Link zum Stream freigeben, in dem ich den Entwicklungsprozess auf dem STM32-Mikrocontroller zeige und √ºber die n√§chste Serie spreche.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formulierung des Problems</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein kleiner Hintergrund: Um einen kontrollierten Empfindlichkeitsstrahl zu erzeugen, wurde f√ºr die erste Yandex.Station eine Schaltung mit sieben Mikrofonen (analog) f√ºr die Mini-Version ausgew√§hlt - mit vier (bereits digital). F√ºr andere Produkte werden verschiedene Konfigurationen in Betracht gezogen, aber die Sieben-Mikrofon-Matrix ist f√ºr uns immer noch einfach und klassisch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also gegeben: sieben digitale Mikrofone, die Notwendigkeit, sie zu testen. Finden: nicht zu schwierig zu implementieren und flexible Art der Interaktion mit ihnen. Es ist logisch, die Aufgabe in zwei Teile zu unterteilen: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Daten von Mikrofonen abrufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Senden Sie sie an einen Computer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Benutzer im fertigen Ger√§t Alice kontaktiert, werden die Signale von digitalen Mikrofonen direkt an den Zentralprozessor gesendet (es ist richtiger, es als SoC - System-on-Chip zu bezeichnen, aber der ‚ÄûProzessor‚Äú ist vertrauter und bequemer). Er verf√ºgt √ºber ausreichende Leistung, um sie zu verarbeiten. F√ºr Debugging-Algorithmen ist es jedoch viel bequemer, diese Daten direkt auf den Computer des Entwicklers zu √ºbertragen. Der einfachste Weg ist die Verbindung √ºber USB: Daher muss die Karte √ºber einen Mikrocontroller mit der entsprechenden Einheit verf√ºgen. Wir lieben den STM32-Controller, aber es ist unm√∂glich, den Schallstrom von den Mikrofonen direkt an ihn zu senden: Es gibt keine PDM-Signalempfangseinheit (Pulsdichtemodulation) - die Ausgangsschnittstelle digitaler Mikrofone.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine andere M√∂glichkeit besteht darin, die Mikrofonplatine mit der Debug-Platine des Herstellers des verwendeten SoC zu verbinden. </font><font style="vertical-align: inherit;">Diese Entscheidung ist jedoch an Linux alsamixer gebunden, und ihre Parameter wirken sich stark auf das Ergebnis der Konvertierung von PDM in PCM aus. </font><font style="vertical-align: inherit;">Diese Bl√∂cke k√∂nnen sich nicht nur f√ºr Prozessoren verschiedener Hersteller unterscheiden, sondern auch f√ºr zwei Modelle desselben Herstellers. </font><font style="vertical-align: inherit;">Ich erinnere Sie daran, dass wir eine einfache L√∂sung brauchten, die transparent und vorhersehbar ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hardwarel√∂sung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akzeptieren Sie die Unf√§higkeit des STM32, Mehrkanal-PDM zu akzeptieren. Man k√∂nnte den SPI-Block verwenden, um ein PDM-Signal zu empfangen, aber nur ein Mikrofon kann an einen SPI-Bus angeschlossen werden. Wir arbeiten mit dem STM32L476RC-Controller, bei dem es nur drei solcher Busse gibt. Zus√§tzliche Komplexit√§t: Das PDM-Signal ist ziemlich hochfrequent, es muss dezimiert, gemittelt, verarbeitet und gefiltert werden - f√ºr sieben Mikrofone ist diese Aufgabe ziemlich kompliziert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da es sich um ein Debugboard und nicht um einen Prototyp f√ºr die Massenproduktion handelt, konzentrieren wir uns auf einen speziellen Chip TSDP18xx. Es macht alles Notwendige: Es erzeugt die notwendigen Frequenzen und Signale f√ºr PDM, mittelt und verarbeitet das PDM-Signal, wandelt alles in ein I2S-Signal um. Genauer gesagt, TDM (Time Division Multiplexing), da der I2S-Bus zwei Kan√§le annimmt und wenn Sie mehr √ºber dieselben Kabel fahren, ist es nicht mehr ganz richtig, ihn I2S zu nennen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Vorteil dieses Ansatzes besteht darin, dass alle Arbeiten zur Vorbereitung und Mittelwertbildung von TSDP durchgef√ºhrt werden. Minus - alle Algorithmen sind in diesem Mikrokreis fest verdrahtet und k√∂nnen nicht ge√§ndert werden. Insbesondere k√∂nnen Sie die Lautst√§rke nicht anpassen, indem Sie die Mittelungsparameter √§ndern. F√ºr das Debuggen ist dies jedoch nicht kritisch.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Achten Sie auf Ihre H√§nde: Auf dem Mikrokreis befinden sich sieben Mikrofone und acht Kan√§le. Der Ausgang, der nicht verwendet wird, ist immer noch vorhanden. In Zukunft werde ich der Einfachheit halber √ºber den Acht-Kanal-Audiostream sprechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir also das 8-Kanal-TDM auf STM32 erh√∂hen, erhalten wir einen 8-Kanal-Audiostream. So verschieben sich Daten: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/w1/pe/40/w1pe40wix4cok_xc_xmaslgas3a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SAI - STM32-Hardwareeinheit f√ºr die Arbeit mit I2S / TDM. Es ist sehr flexibel und erm√∂glicht die Implementierung vieler Protokolloptionen. Aus diesem Grund kann es leicht zu Verwechslungen bei den Anforderungen an Frequenzen kommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Uhrenbaum verdient einen genaueren Blick. Ein 12-MHz-Quarzresonator ist an den Mikrocontroller angeschlossen. Wir teilen diese Frequenz, bevor wir sie auf die PLL-Bl√∂cke anwenden, durch 3 und erhalten 4 MHz. Dann funktioniert es so:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Es w√§re sch√∂n, die Kernfrequenz h√∂her zu machen, um mit allem Schritt zu halten: Das Maximum f√ºr diesen Controller betr√§gt beispielsweise 80 MHz. Wir verwenden den ersten PLL-Block: Wir multiplizieren 4 MHz mit 40 und dividieren durch 2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. USB ben√∂tigt 48 MHz. Verwenden Sie dazu den zweiten PLL-Block: Multiplizieren Sie 4 MHz mit 24 und dividieren Sie durch 2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. Informationen zu Mikrofonen. Unsere Testkarten verwenden eine Abtastfrequenz von Fs = 16 kHz, ein Standard, der im Bereich der Spracherkennung angewendet wird. Ab der Anfangsfrequenz von 4 MHz ben√∂tigen Sie etwas, das in 16-kHz-TDM-Busrahmenfrequenzen umgewandelt werden kann (auch bekannt als LRCK, auch bekannt als FCK, auch bekannt als FrameSync). In diesem Fall: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[H√§ufigkeit der Bitsynchronisation (BCLK, BitClk, Sync, SCK)] = Fs ‚àô [Anzahl der Kan√§le] ‚àô [Anzahl der Bits pro Kanal] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt: SCK = 16 kHz ‚àô 8 ‚àô 16 = 2048 kHz.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. Das Datenblatt zeigt, dass das Verh√§ltnis zwischen Haupttakt und Abtastrate Fs wie folgt ist: MasterClock = 16 kHz ‚àô Teiler MCLK ‚àô 256. Hier ist 256 eine Konstante, und der Teiler kann im Register eingestellt werden. </font><font style="vertical-align: inherit;">Lassen Sie uns das Schema √ºberpr√ºfen - f√ºr die erforderliche Funktionalit√§t gibt es Koeffizienten zum Teilen der PLL-Frequenz durch 7 oder 17: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qk/9n/zo/qk9nzo9zysl0dsggr-la2lux9-m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Problem zusammenzufassen: Sie m√ºssen einen solchen Satz von PLL- und SAI-Faktoren und -Teilern ausw√§hlen, um eine Abtastfrequenz von 16 kHz und eine Bitfrequenz von 128-mal mehr zu erhalten. </font><font style="vertical-align: inherit;">Da das Set einen obligatorischen Teiler von 7 (oder 17) hatte, funktionierte es nicht, um genau das gew√ºnschte Ergebnis zu erzielen. </font><font style="vertical-align: inherit;">Ich musste eine Tabelle mit Multiplikatoren und Teilern erstellen, um 24,571 MHz zu erhalten. </font><font style="vertical-align: inherit;">Wenn wir diese Frequenz durch 6 (MCLK-Teiler) und dann durch 256 (Konstante) teilen, erhalten wir schlie√ülich eine Zahl nahe genug an 16 kHz. </font><font style="vertical-align: inherit;">Jetzt werde ich erkl√§ren, warum dies so wichtig ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USB-Betrieb</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USB verwendet eine isochrone √úbertragungsart, um mit Multimediadaten zu arbeiten: In diesem Fall ist eine bestimmte Bandbreite und ein bestimmter Verz√∂gerungswert auf dem USB-Bus garantiert. Die Datenlieferung kann nicht garantiert werden: Wenn ein Paket mit einem Fehler eintrifft, gilt es als verloren. Dies liegt an strengen Fristen: Es gibt keine M√∂glichkeit, erneut zu fragen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der isochronen Art der √úbertragung mit USB-FullSpeed-Geschwindigkeit (12 Mbit / s; bei dieser Geschwindigkeit kann der STM32-USB-Block arbeiten) kommt der Computer jede Millisekunde zum Ger√§t, um Daten zu erhalten. Nach dieser Zeit sollten die gesammelten Daten erfasst werden. Ich m√∂chte Sie an die einleitenden erinnern: Die Abtastfrequenz betr√§gt 16 kHz, 8 Kan√§le, jeder Kanal ben√∂tigt zwei Bytes, da der Ton 16 Bit ist. Insgesamt 16000 ‚àô 2 ‚àô 8/1000 = 256 Bytes pro Millisekunde. Die Gr√∂√üe eines Pakets f√ºr eine isochrone √úbertragungsart kann 1023 Byte erreichen, sodass an dieser Stelle keine Probleme auftreten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Paketgr√∂√üe betr√§gt also 256 Bytes. Es scheint, dass alles in Ordnung ist. Sechzehn Mal empfangene Daten auf TDM, in den Puffer gelegt, USB kam, wir geben ihm ein Paket, wir wiederholen ... Aber das passiert nur in einer idealen Welt. Das Problem ist, dass wir einerseits unvollst√§ndige 16 kHz (etwas weniger) haben und die Daten daher etwas weniger als einmal pro Millisekunde eingehen. Andererseits schwebt auch die Millisekunde des Computers, da er besch√§ftigt ist: Wenn es k√∂nnte, dann kam es. Das hei√üt, die Mikrofonabruffrequenz unterscheidet sich von 16 kHz (aber immer gleich), und die USB-Millisekunde unterscheidet sich auch in der L√§nge (der Unterschied ist h√∂chstwahrscheinlich schwebend: Er stellt sich als etwas mehr heraus, dann als etwas weniger als eine ideale Millisekunde).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ist das ein Problem? Sie k√∂nnen das Paket verlieren. Es ist wahrscheinlich nicht notwendig zu erkl√§ren, dass vollst√§ndige Daten f√ºr das korrekte Debuggen der Algorithmen erforderlich sind. Wie das Paket verloren geht: Sie haben 256 Bytes an Ergebnissen gesammelt, sie in den Puffer gelegt und die Messung fortgesetzt. Ein Computer kam, nahm die ersten 256, wir messen noch weiter. Der Computer kam wieder, aber die Messung ist noch nicht abgeschlossen - der Computer hat ein leeres Paket zur√ºckgelassen. Dann f√ºllen wir den Puffer vollst√§ndig aus und f√ºllen einen weiteren aus, den n√§chsten, bis der Computer wieder eintrifft. Der Computer nimmt nur das letzte Paket entgegen, wodurch ein Paket verloren geht. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/of/o0/ol/ofo0olk2bqjbjtm5keb0upd58xo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem ist in der Tat bekannt. Es gibt drei Ans√§tze, um damit umzugehen:</font></font><br>
<br>
<ul>
<li><b></b>.            USB.    ‚Äî    .   ¬´¬ª ‚Äî   .   USB          .       ,     ,   (  ,  16 ),       .        ,          .</li>
<li><b></b>.             .</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchron</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist das Beste f√ºr diese Aufgabe. </font><font style="vertical-align: inherit;">Das Ger√§t verf√ºgt √ºber einen stabilen Frequenzgenerator. </font><font style="vertical-align: inherit;">Die Abtastrate bleibt ohne Bezug auf USB exakt gleich. </font><font style="vertical-align: inherit;">In diesem Fall m√ºssen Sie Daten auf das Ger√§t √ºbertragen, damit keine wesentlichen Abweichungen auftreten.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All dies wurde mehr als einmal im Internet f√ºr den Fall der Wiedergabe von einem Computer zum Lautsprecher √ºber ein Ger√§t mit einem Digital-Analog-Codierer diskutiert, wobei das Ger√§t als R√ºckmeldung angibt, wie viele Abtastperioden seit dem Empfang des letzten Pakets vergangen sind. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/4m/xx/ng/4mxxngiif53s98nf0v08vuuyds0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Aufgabe ist jedoch das Gegenteil: Beim Debuggen m√ºssen Daten von Mikrofonen an einen Computer empfangen werden, und die Frage der Aufzeichnung eines Signals von Mikrofonen an einen Computer wird bestenfalls erw√§hnt. </font><font style="vertical-align: inherit;">Warum nicht dasselbe tun: Feedback vom Computer einf√ºhren? </font><font style="vertical-align: inherit;">Es gibt eine einfachere Option.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da ist er</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir verwenden das h√§ufige Hinzuf√ºgen von Samples und zwei Puffern, um Daten zum Senden zu speichern. 16 Mal pro Millisekunde f√ºgen wir dem ausgew√§hlten Puffer die n√§chste Probe hinzu. Irgendwann tritt eine Unterbrechung auf: USB hat das vorherige Paket genommen. Wenn Puffer Nr. 1 voll ist, wird auf Puffer Nr. 2 umgeschaltet. Wenn USB f√ºr das n√§chste Paket ankommt, ist es bereits vorbereitet. Senden Sie Puffer Nummer 2 und wechseln Sie zur√ºck zu Nummer 1.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ob/td/0m/obtd0mcd2tzmv8iut7w7-5_vpzc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USB kommt f√ºr Daten zu unterschiedlichen Zeitpunkten, das Paket enth√§lt eine unterschiedliche Anzahl von Proben. Es kann sich herausstellen, dass es mehr und weniger als 16 sind. Daher besteht die M√∂glichkeit, dass ein Paket mit einer Gr√∂√üe von 256 Byte √ºberschritten wird. Es ist besser, Platz f√ºr Man√∂ver zu lassen. Es sei 384 = 256 + 128: Dies ergibt einen Spielraum von einer halben Millisekunde, dh es wird die Schwimmphase des USB-Signals um 50% vergeben - ein solcher Spielraum sollte mehr als ausreichend sein. Gesamt: Manchmal werden mehr oder weniger 256 Bytes gesendet, aber niemals ein leeres Paket, wodurch Datenverlust vermieden wird. Das hei√üt, das Problem der Unebenheit wurde gel√∂st, indem das Paket auf Kosten einer Erh√∂hung eines Teils der f√ºr unser Ger√§t zugewiesenen Busbandbreite und einer Verringerung dieses Teils f√ºr andere Ger√§te erh√∂ht wurde.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit endete die √úbermittlung von Daten an den Computer. </font><font style="vertical-align: inherit;">Entwickler k√∂nnen debuggt werden, und Sie k√∂nnen in den Kommentaren Fragen stellen, wenn eine Art Datenpaket f√ºr ein vollst√§ndiges Verst√§ndnis nicht ausreicht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meine Streams und die n√§chste Folge</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In letzter Zeit habe ich zweimal aus meinem L√∂tlabor gestreamt. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst habe ich</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nur den L√∂tprozess gezeigt und gesagt, welche Ger√§te ich benutze. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite Serie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> war nur der Entwicklung des STM32 gewidmet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streams werden fortgesetzt. </font><font style="vertical-align: inherit;">Diesen Freitag um 19:00 Uhr wird mein Kollege vom Entwicklungsteam f√ºr Hardwarel√∂sungen, Andrey Laptev, eine Online-Analyse von Yandex.Stations Mini arrangieren - zeigen Sie die Innenseiten und teilen Sie die Produktionshistorien. </font><font style="vertical-align: inherit;">F√ºr mehr Spa√ü wird Andrey die Batterie an die S√§ule schrauben - nicht egal, arbeiten Sie vom Draht. </font><font style="vertical-align: inherit;">Im Finale erhalten Sie einen Leitfaden, mit dem Sie diese Erfahrung selbst wiederholen oder ein interessanteres Design entwickeln k√∂nnen. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anmelden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Stream zu sehen. </font><font style="vertical-align: inherit;">Sie erhalten einen Brief mit einer Datei f√ºr den Kalender und einer Erinnerung am Sendetag. </font><font style="vertical-align: inherit;">Danke f√ºrs Lesen!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de503906/index.html">LabVIEW NXG - Einfache Datentypen und Typenzwang</a></li>
<li><a href="../de503908/index.html">Rufen Sie gemeinsam genutzte Bibliotheken von Similink aus auf</a></li>
<li><a href="../de503910/index.html">Experimente an Menschen, die nach "udalenka" gegangen sind</a></li>
<li><a href="../de503916/index.html">Lernen, an der B√∂rse zu handeln. Teil eins: Einrichten einer Testumgebung</a></li>
<li><a href="../de503918/index.html">Verwalten von Paketen mit Go-Modulen: Ein pragmatischer Leitfaden</a></li>
<li><a href="../de503922/index.html">Warum beseitigt die EU Keksw√§nde?</a></li>
<li><a href="../de503924/index.html">√úbersicht √ºber den Intraoralen 3D-Scanner Medit i500</a></li>
<li><a href="../de503926/index.html">Wer ist wer im Zahlungsverkehr 2020. Teil 2</a></li>
<li><a href="../de503928/index.html">Aerosol VS-Bew√§sserung: Was ist besser und gibt es einen Unterschied?</a></li>
<li><a href="../de503932/index.html">Ich bin es leid, dass gew√∂hnliche Verk√§ufer sich als Entwickler ausgeben und die Branche entehren. Sie machen die Welt schlimmer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>