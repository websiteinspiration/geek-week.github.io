<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🚒 ☠️ 🤲🏿 A engenharia reversa da renderização de The Witcher 3: vários efeitos do céu 🔔 🔰 👩‍👩‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Partes anteriores da análise: primeira e segunda e terceira .]
 
 Parte 1. Nuvens Cirrus
 Quando o jogo acontece em espaços abertos, um dos fatores q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>A engenharia reversa da renderização de The Witcher 3: vários efeitos do céu</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489118/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f2/033/d27/8f2033d27bc9d8a498716c85be1be1c0.png" alt="imagem"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Partes anteriores da análise: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeira</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segunda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terceira</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .]</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 1. Nuvens Cirrus</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando o jogo acontece em espaços abertos, um dos fatores que determinam a credibilidade do mundo é o céu. Pense nisso - na maioria das vezes o céu literalmente ocupa cerca de 40-50% da tela inteira. O céu é muito mais do que um belo gradiente. Tem estrelas, o sol, a lua e, finalmente, nuvens. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embora as tendências atuais pareçam consistir na renderização volumétrica de nuvens usando raymarching (consulte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), as nuvens em The Witcher 3 são completamente baseadas em textura. Eu já os examinei antes, mas acabou que com eles tudo é mais complicado do que eu esperava inicialmente. Se você seguiu minha série de artigos, sabe que há uma diferença entre os DLCs Blood e Wine e o resto do jogo. E, como você pode imaginar, há algumas mudanças no trabalho com nuvens no DLC.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Witcher 3 tem várias camadas de nuvens. Dependendo do clima, podem ser apenas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuvens cirros</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">nuvens </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cumulus altas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , possivelmente algumas nuvens da família de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuvens em camadas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (por exemplo, durante uma tempestade). No final, pode não haver nuvens.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algumas camadas diferem em termos de texturas e shaders usados ​​para renderizá-las. Obviamente, isso afeta a complexidade e o comprimento do código do assembler para o pixel shader. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apesar de toda essa diversidade, existem alguns padrões comuns que podem ser observados ao renderizar nuvens no Witcher 3. Primeiro, todos são renderizados de forma proativa, e essa é a escolha perfeita. Todos eles usam mixagem (veja abaixo). Isso facilita muito o controle de como uma camada separada cobre o céu - isso é afetado pelo valor alfa do sombreador de pixels.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/aec/b8a/263aecb8afa21e2b79b0333bcde55011.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais interessante, algumas camadas são renderizadas duas vezes com os mesmos parâmetros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de analisar o código, escolhi o shader mais curto para (1) provavelmente executar sua engenharia reversa completa, (2) descobrir todos os seus aspectos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Olhei mais de perto as nuvens cirros de Witcher 3: Blood and Wine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está um quadro de exemplo:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f81/eb8/a49/f81eb8a49dc315ef04d72b582fba869b.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de renderizar</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/885/b27/206/885b2720624e7a455987bb6239d0e371.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Após o primeiro passe de renderização</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f2/033/d27/8f2033d27bc9d8a498716c85be1be1c0.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Após a segunda passagem de renderização</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nesse quadro em particular, as nuvens cirros são a primeira camada na renderização. </font><font style="vertical-align: inherit;">Como você pode ver, é renderizado duas vezes, o que aumenta seu brilho.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sombra geométrica e de vértice</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes do pixel shader, falaremos brevemente sobre os shaders geométricos e de vértice usados. </font><font style="vertical-align: inherit;">A malha para exibir nuvens é um pouco como uma cúpula de céu comum:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4c/774/8de/b4c7748de95ad07f2dddfc090e62e0d2.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos os vértices estão no intervalo [0-1], para centralizar a malha no ponto (0,0,0), a escala e o desvio são usados ​​antes da conversão para o worldViewProj (já conhecemos esse padrão nas partes anteriores da série). </font><font style="vertical-align: inherit;">No caso das nuvens, a malha se estende fortemente ao longo do plano XY (o eixo Z aponta para cima) para cobrir mais espaço do que a pirâmide de visibilidade. </font><font style="vertical-align: inherit;">O resultado é o seguinte:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/341/0ca/95e/3410ca95ea9f0b3ef1fafe62cb5dba13.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, a malha possui vetores normais e tangentes. </font><font style="vertical-align: inherit;">O sombreador de vértice também calcula o vetor bi-tangente pelo produto vetorial - todos os três são exibidos na forma normalizada. </font><font style="vertical-align: inherit;">Há também um cálculo superior do nevoeiro (sua cor e brilho).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixel shader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O código de montagem do pixel shader se parece com o seguinte:</font></font><br>
<br>
<pre><code class="cpp hljs"> ps_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb0[<span class="hljs-number">10</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb1[<span class="hljs-number">9</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb12[<span class="hljs-number">238</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb4[<span class="hljs-number">13</span>], immediateIndexed  <font></font>
    dcl_sampler s0, <span class="hljs-function">mode_default  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t0  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t1  
    dcl_input_ps linear v0.xyzw  
    dcl_input_ps linear v1.xyzw  
    dcl_input_ps linear v2.w  
    dcl_input_ps linear v3.xyzw  
    dcl_input_ps linear v4.xyz  
    dcl_input_ps linear v5.xyz  
    dcl_output o0.xyzw  
    dcl_temps 4  
   0: mul r0.xyz, cb0[9].xyzx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">-1.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
   1: dp3 r0.w, r0.xyzx, r0.xyzx  
   2: rsq r0.w, r0.w  
   3: mul r0.xyz, r0.wwww, r0.xyzx  
   4: mul r1.xy, cb0[0].xxxx, cb4[5].xyxx  
   5: mad r1.xy, v1.xyxx, cb4[4].xyxx, r1.xyxx  
   6: <span class="hljs-title">sample_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r1.xyzw, r1.xyxx, t0.xyzw, s0  
   7: add r1.xyz, r1.xyzx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">0.000000</span>)</span>  
   8: add r1.xyz, r1.xyzx, r1.xyzx  
   9: dp3 r0.w, r1.xyzx, r1.xyzx  
  10: rsq r0.w, r0.w  
  11: mul r1.xyz, r0.wwww, r1.xyzx  
  12: mul r2.xyz, r1.yyyy, v3.xyzx  
  13: mad r2.xyz, v5.xyzx, r1.xxxx, r2.xyzx  
  14: mov r3.xy, v1.zwzz  
  15: mov r3.z, v3.w  
  16: mad r1.xyz, r3.xyzx, r1.zzzz, r2.xyzx  
  17: dp3_sat r0.x, r0.xyzx, r1.xyzx  
  18: add r0.y, -cb4[2].x, cb4[3].x  
  19: mad r0.x, r0.x, r0.y, cb4[2].x  
  20: dp2 r0.y, -cb0[9].xyxx, -cb0[9].xyxx  
  21: rsq r0.y, r0.y  
  22: mul r0.yz, r0.yyyy, -cb0[9].xxyx  
  23: add r1.xyz, -v4.xyzx, cb1[8].xyzx  
  24: dp3 r0.w, r1.xyzx, r1.xyzx  
  25: rsq r1.z, r0.w  
  26: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  27: add r0.w, r0.w, -cb4[7].x  
  28: mul r1.xy, r1.zzzz, r1.xyxx  
  29: dp2_sat r0.y, r0.yzyy, r1.xyxx  
  30: add r0.y, r0.y, r0.y  
  31: min r0.y, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  32: add r0.z, -cb4[0].x, cb4[1].x  
  33: mad r0.z, r0.y, r0.z, cb4[0].x  
  34: mul r0.x, r0.x, r0.z  
  35: <span class="hljs-built_in">log</span> r0.x, r0.x  
  36: mul r0.x, r0.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">2.200000</span>)</span>  
  37: <span class="hljs-built_in">exp</span> r0.x, r0.x  
  38: add r1.xyz, cb12[236].xyzx, -cb12[237].xyzx  
  39: mad r1.xyz, r0.yyyy, r1.xyzx, cb12[237].xyzx  
  40: mul r2.xyz, r0.xxxx, r1.xyzx  
  41: mad r0.xyz, -r1.xyzx, r0.xxxx, v0.xyzx  
  42: mad r0.xyz, v0.wwww, r0.xyzx, r2.xyzx  
  43: add r1.x, -cb4[7].x, cb4[8].x  
  44: div_sat r0.w, r0.w, r1.x  
  45: mul r1.x, r1.w, cb4[9].x  
  46: mad r1.y, -cb4[9].x, r1.w, r1.w  
  47: mad r0.w, r0.w, r1.y, r1.x  
  48: mul r1.xy, cb0[0].xxxx, cb4[11].xyxx  
  49: mad r1.xy, v1.xyxx, cb4[10].xyxx, r1.xyxx  
  50: <span class="hljs-title">sample_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r1.x, r1.xyxx, t1.xyzw, s0  
  51: mad r1.x, r1.x, cb4[12].x, -cb4[12].x  
  52: mad_sat r1.x, cb4[12].x, v2.w, r1.x  
  53: mul r0.w, r0.w, r1.x  
  54: mul_sat r0.w, r0.w, cb4[6].x  
  55: mul o0.xyz, r0.wwww, r0.xyzx  
  56: mov o0.w, r0.w  
  57: ret </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Duas texturas sem costura são inseridas. </font><font style="vertical-align: inherit;">Um deles contém um mapa normal (canais </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xyz</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) e uma forma de nuvem (canal </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">O segundo é o ruído para distorcer a forma.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f3/c27/a5e/1f3c27a5eea1412d5fa1fa632861a342.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa normal, propriedade vermelha do CD Projekt</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/37b/a53/d41/37ba53d412d20f476ddf71e81892b62a.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud Shape, Property CD Projeto vermelho</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05e/1bb/edd/05e1bbedded7c16acefc1f67d5b3fd49.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textura de ruído, propriedade do CD Projekt Red</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
O buffer principal de constantes com parâmetros de nuvem é cb4. </font><font style="vertical-align: inherit;">Para esse quadro, ele tem os seguintes significados:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/229/4de/9422294de7d9ead5e2bec154eb897c7a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, outros valores de outros amortecedores são usados. </font><font style="vertical-align: inherit;">Não se preocupe, nós os consideraremos também.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luz solar invertida na direção Z</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira coisa que acontece no shader é o cálculo da direção normalizada da luz solar invertida ao longo do eixo Z:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">0</span>: mul r0.xyz, cb0[<span class="hljs-number">9</span>].xyzx, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">-1.000000</span>, <span class="hljs-number">0.000000</span>)  
   <span class="hljs-number">1</span>: dp3 r0.w, r0.xyzx, r0.xyzx  
   <span class="hljs-number">2</span>: rsq r0.w, r0.w  
   <span class="hljs-number">3</span>: mul r0.xyz, r0.wwww, r0.xyzx  <font></font>
<font></font>
   float3 invertedSunlightDir = normalize(lightDir * float3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>) );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como mencionado anteriormente, o eixo Z é direcionado para cima e cb0 [9] é a direção da luz solar. </font><font style="vertical-align: inherit;">Esse vetor é voltado </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sol - é importante! </font><font style="vertical-align: inherit;">Você pode verificar isso escrevendo um shader computacional simples que executa um NdotL simples e inserindo-o na passagem adiada do shader.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Amostragem de textura de nuvem</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O próximo passo é calcular os cabos de texto para provar a textura da nuvem, descompactar o vetor normal e normalizá-lo.</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">4</span>: mul r1.xy, cb0[<span class="hljs-number">0</span>].xxxx, cb4[<span class="hljs-number">5</span>].xyxx   
   <span class="hljs-number">5</span>: mad r1.xy, v1.xyxx, cb4[<span class="hljs-number">4</span>].xyxx, r1.xyxx   
   <span class="hljs-number">6</span>: sample_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r1.xyzw, r1.xyxx, t0.xyzw, s0   
   <span class="hljs-number">7</span>: add r1.xyz, r1.xyzx, l(<span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">0.000000</span>)   
   <span class="hljs-number">8</span>: add r1.xyz, r1.xyzx, r1.xyzx   
   <span class="hljs-number">9</span>: dp3 r0.w, r1.xyzx, r1.xyzx   
  <span class="hljs-number">10</span>: rsq r0.w, r0.w   <font></font>
   <font></font>
   <font></font>
   <span class="hljs-comment">// Calc sampling coords  </span><font></font>
   float2 cloudTextureUV = Texcoords * textureScale + elapsedTime * speedFactors;  <font></font>
   <font></font>
   <span class="hljs-comment">// Sample texture and get data from it  </span><font></font>
   float4 cloudTextureValue = texture0.Sample( sampler0, cloudTextureUV ).rgba;  <font></font>
   float3 normalMap = cloudTextureValue.xyz;  <font></font>
   <span class="hljs-keyword">float</span> cloudShape = cloudTextureValue.a;  <font></font>
   <font></font>
   <span class="hljs-comment">// Unpack normal and normalize it  </span>
   float3 unpackedNormal = (normalMap - <span class="hljs-number">0.5</span>) * <span class="hljs-number">2.0</span>;  <font></font>
   unpackedNormal = normalize(unpackedNormal);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos lidar com isso gradualmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para obter o movimento das nuvens, precisamos de um tempo decorrido em segundos ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb [0] .x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) multiplicado pelo coeficiente de velocidade, que afeta a rapidez com que as nuvens se movem pelo céu ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb4 [5] .xy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como eu disse anteriormente, os UVs são esticados ao longo da geometria da cúpula do céu, e também precisamos de fatores de escala de textura que afetam o tamanho das nuvens ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb4 [4] .xy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A fórmula final é:</font></font><br>
<br>
<pre><code class="cpp hljs">samplingUV = Input.TextureUV * textureScale + time * speedMultiplier;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de amostrar todos os 4 canais, temos um mapa normal (canais rgb) e uma forma de nuvem (canal a). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para descompactar o mapa normal do intervalo [0; </font><font style="vertical-align: inherit;">1] no intervalo [-1; </font><font style="vertical-align: inherit;">1] usamos a seguinte fórmula:</font></font><br>
<br>
<pre><code class="cpp hljs">unpackedNormal = (packedNormal - <span class="hljs-number">0.5</span>) * <span class="hljs-number">2.0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você também pode usar isso:</font></font><br>
<br>
<pre><code class="cpp hljs">unpackedNormal = packedNormal * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, normalizamos o vetor normal descompactado.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Overlay normals</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tendo os vetores normais, os vetores tangente e bi-tangente do sombreador de vértice e o vetor normal do mapa normal, normalmente mapeamos os normais.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">11</span>: mul r1.xyz, r0.wwww, r1.xyzx  
  <span class="hljs-number">12</span>: mul r2.xyz, r1.yyyy, v3.xyzx  
  <span class="hljs-number">13</span>: mad r2.xyz, v5.xyzx, r1.xxxx, r2.xyzx  
  <span class="hljs-number">14</span>: mov r3.xy, v1.zwzz  
  <span class="hljs-number">15</span>: mov r3.z, v3.w  
  <span class="hljs-number">16</span>: mad r1.xyz, r3.xyzx, r1.zzzz, r2.xyzx  <font></font>
    <font></font>
   <span class="hljs-comment">// Perform bump mapping  </span><font></font>
   float3 SkyTangent = Input.Tangent;  <font></font>
   float3 SkyNormal = (float3( Input.Texcoords.zw, Input.param3.w ));  <font></font>
   float3 SkyBitangent = Input.param3.xyz;  <font></font>
        <font></font>
   float3x3 TBN = float3x3(SkyTangent, SkyBitangent, SkyNormal);  <font></font>
   float3 finalNormal = (float3)mul( unpackedNormal, (TBN) );</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brilho (1)</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na próxima etapa, o cálculo de NdotL é aplicado e isso afeta a quantidade de iluminação de um pixel específico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere o seguinte código do assembler:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">17</span>: dp3_sat r0.x, r0.xyzx, r1.xyzx  
  <span class="hljs-number">18</span>: add r0.y, -cb4[<span class="hljs-number">2</span>].x, cb4[<span class="hljs-number">3</span>].x  
  <span class="hljs-number">19</span>: mad r0.x, r0.x, r0.y, cb4[<span class="hljs-number">2</span>].x  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está a visualização do NdotL no quadro em questão:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/f29/1a1/283f291a18105785a51af59dbbe8905a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este produto escalar (com saturação) é usado para interpolar entre minIntensity e maxIntensity. </font><font style="vertical-align: inherit;">Graças a isso, partes das nuvens iluminadas pela luz solar ficarão mais brilhantes.</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Calculate cosine between normal and up-inv lightdir  </span>
   <span class="hljs-keyword">float</span> NdotL = saturate( dot(invertedSunlightDir, finalNormal) );  <font></font>
   <font></font>
   <span class="hljs-comment">// Param 1, line 19, r0.x  </span>
   <span class="hljs-keyword">float</span> intensity1 = lerp( param1Min, param1Max, NdotL );</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brilho (2)</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há outro fator que afeta o brilho das nuvens. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As nuvens localizadas naquela parte do céu onde o sol está devem ser mais destacadas. </font><font style="vertical-align: inherit;">Para fazer isso, calculamos o gradiente com base no plano XY. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse gradiente é usado para calcular a interpolação linear entre os valores min / max, semelhante ao que acontece na parte (1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isto é, teoricamente, podemos pedir para escurecer as nuvens localizadas no lado oposto do sol, mas isso não acontece neste quadro particular, porque </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param2Min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param2Max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CB4 [0] .x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CB4 [1] .x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) estão marcadas para 1.0f.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">20</span>: dp2 r0.y, -cb0[<span class="hljs-number">9</span>].xyxx, -cb0[<span class="hljs-number">9</span>].xyxx  
  <span class="hljs-number">21</span>: rsq r0.y, r0.y  
  <span class="hljs-number">22</span>: mul r0.yz, r0.yyyy, -cb0[<span class="hljs-number">9</span>].xxyx  
  <span class="hljs-number">23</span>: add r1.xyz, -v4.xyzx, cb1[<span class="hljs-number">8</span>].xyzx  
  <span class="hljs-number">24</span>: dp3 r0.w, r1.xyzx, r1.xyzx  
  <span class="hljs-number">25</span>: rsq r1.z, r0.w  
  <span class="hljs-number">26</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  <span class="hljs-number">27</span>: add r0.w, r0.w, -cb4[<span class="hljs-number">7</span>].x  
  <span class="hljs-number">28</span>: mul r1.xy, r1.zzzz, r1.xyxx  
  <span class="hljs-number">29</span>: dp2_sat r0.y, r0.yzyy, r1.xyxx  
  <span class="hljs-number">30</span>: add r0.y, r0.y, r0.y  
  <span class="hljs-number">31</span>: min r0.y, r0.y, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">32</span>: add r0.z, -cb4[<span class="hljs-number">0</span>].x, cb4[<span class="hljs-number">1</span>].x  
  <span class="hljs-number">33</span>: mad r0.z, r0.y, r0.z, cb4[<span class="hljs-number">0</span>].x  
  <span class="hljs-number">34</span>: mul r0.x, r0.x, r0.z  
  <span class="hljs-number">35</span>: <span class="hljs-built_in">log</span> r0.x, r0.x  
  <span class="hljs-number">36</span>: mul r0.x, r0.x, l(<span class="hljs-number">2.200000</span>)  
  <span class="hljs-number">37</span>: <span class="hljs-built_in">exp</span> r0.x, r0.x   <font></font>
   <font></font>
   <font></font>
   <span class="hljs-comment">// Calculate normalized -lightDir.xy (20-22)  </span><font></font>
   float2 lightDirXY = normalize( -lightDir.xy );  <font></font>
   <font></font>
   <span class="hljs-comment">// Calculate world to camera  </span><font></font>
   float3 vWorldToCamera = ( CameraPos - WorldPos );  <font></font>
   <span class="hljs-keyword">float</span> worldToCamera_distance = length(vWorldToCamera);  <font></font>
        <font></font>
   <span class="hljs-comment">// normalize vector  </span><font></font>
   vWorldToCamera = normalize( vWorldToCamera );  <font></font>
        <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> LdotV = saturate( dot(lightDirXY, vWorldToCamera.xy) );  
   <span class="hljs-keyword">float</span> highlightedSkySection = saturate( <span class="hljs-number">2</span>*LdotV );  
   <span class="hljs-keyword">float</span> intensity2 = lerp( param2Min, param2Max, highlightedSkySection );  <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> finalIntensity = <span class="hljs-built_in">pow</span>( intensity2 *intensity1, <span class="hljs-number">2.2</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No final, multiplicamos os dois brilhos e aumentamos o resultado para uma potência de 2,2.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cor da nuvem</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O cálculo da cor das nuvens começa com a obtenção, a partir das constantes do buffer, de dois valores indicando a cor das nuvens próximas ao sol e as nuvens do lado oposto do céu. </font><font style="vertical-align: inherit;">Entre eles, a interpolação linear é realizada com base </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emSkySection</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, o resultado é multiplicado por </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finalIntensity</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E, no final, o resultado é misturado ao nevoeiro (por razões de desempenho, foi calculado pelo sombreador de vértice).</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">38</span>: add r1.xyz, cb12[<span class="hljs-number">236</span>].xyzx, -cb12[<span class="hljs-number">237</span>].xyzx  
  <span class="hljs-number">39</span>: mad r1.xyz, r0.yyyy, r1.xyzx, cb12[<span class="hljs-number">237</span>].xyzx  
  <span class="hljs-number">40</span>: mul r2.xyz, r0.xxxx, r1.xyzx  
  <span class="hljs-number">41</span>: mad r0.xyz, -r1.xyzx, r0.xxxx, v0.xyzx  
  <span class="hljs-number">42</span>: mad r0.xyz, v0.wwww, r0.xyzx, r2.xyzx  <font></font>
   <font></font>
  float3 cloudsColor = lerp( cloudsColorBack, cloudsColorFront, highlightedSunSection );  <font></font>
  cloudsColor *= finalIntensity;  <font></font>
  cloudsColor = lerp( cloudsColor, FogColor, FogAmount );</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tornar as nuvens de cirros mais visíveis no horizonte</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso não é muito perceptível no quadro, mas na verdade essa camada é mais visível perto do horizonte do que acima da cabeça de Geralt. </font><font style="vertical-align: inherit;">Aqui está como fazê-lo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode notar que, ao calcular o segundo brilho, calculamos o comprimento do vetor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">worldToCamera</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">23</span>: add r1.xyz, -v4.xyzx, cb1[<span class="hljs-number">8</span>].xyzx  
  <span class="hljs-number">24</span>: dp3 r0.w, r1.xyzx, r1.xyzx  
  <span class="hljs-number">25</span>: rsq r1.z, r0.w  
  <span class="hljs-number">26</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos encontrar as seguintes ocorrências desse tamanho no código:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">26</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  <span class="hljs-number">27</span>: add r0.w, r0.w, -cb4[<span class="hljs-number">7</span>].x  <font></font>
  ...  <font></font>
  <span class="hljs-number">43</span>: add r1.x, -cb4[<span class="hljs-number">7</span>].x, cb4[<span class="hljs-number">8</span>].x  
  <span class="hljs-number">44</span>: div_sat r0.w, r0.w, r1.x</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uau, o que há com a gente? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cb [7] .xe cb [8] .x têm os valores 2000.0 e 7000.0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acontece que esse é o resultado do uso da função </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linstep</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ela recebe três parâmetros: </font><font style="vertical-align: inherit;">intervalo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mínimo / máximo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font><font style="vertical-align: inherit;">valor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso funciona da seguinte maneira: se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estiver no intervalo [ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ], a função retornará interpolação linear no intervalo [0,0 - 1,0]. </font><font style="vertical-align: inherit;">Por outro lado, se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estiver fora da faixa, o linstep retornará 0,0 ou 1,0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um exemplo simples:</font></font><br>
<br>
<pre><code class="cpp hljs">linstep( <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">999.0</span>) = <span class="hljs-number">0.0</span>
linstep( <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">1500.0</span>) = <span class="hljs-number">0.5</span>
linstep( <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">2000.0</span>) = <span class="hljs-number">1.0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, é bastante semelhante ao </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passo suave</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do HLSL, exceto que, neste caso, em vez da interpolação hermitiana, o linear é executado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Linstep não é um recurso do HLSL, mas é muito útil. </font><font style="vertical-align: inherit;">Vale a pena tê-lo em seu kit de ferramentas.</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-comment">// linstep:  </span>
 <span class="hljs-comment">//  </span>
 <span class="hljs-comment">// Returns a linear interpolation between 0 and 1 if t is in the range [min, max]   </span>
 <span class="hljs-comment">// if "v" is &lt;= min, the output is 0  </span>
 <span class="hljs-comment">// if "v" i &gt;= max, the output is 1  </span><font></font>
   <font></font>
 <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">linstep</span><span class="hljs-params">( <span class="hljs-keyword">float</span> min, <span class="hljs-keyword">float</span> max, <span class="hljs-keyword">float</span> v )</span>  
 </span>{  
   <span class="hljs-keyword">return</span> saturate( (v - min) / (max - min) );  <font></font>
 } </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos voltar ao Witcher 3: depois de calcular este indicador, que relata a que distância uma parte específica do céu está de Geralt, nós o usamos para enfraquecer o brilho das nuvens:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">45</span>: mul r1.x, r1.w, cb4[<span class="hljs-number">9</span>].x  
  <span class="hljs-number">46</span>: mad r1.y, -cb4[<span class="hljs-number">9</span>].x, r1.w, r1.w  
  <span class="hljs-number">47</span>: mad r0.w, r0.w, r1.y, r1.x  <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> distanceAttenuation = linstep( fadeDistanceStart, fadeDistanceEnd, worldToCamera_distance );  <font></font>
    <font></font>
   <span class="hljs-keyword">float</span> fadedCloudShape = closeCloudsHidingFactor * cloudShape;  <font></font>
   cloudShape = lerp( fadedCloudShape, cloudShape, distanceAttenuation );</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloudShape</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é o canal .a da primeira textura e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">closeCloudsHidingFactor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é um valor de buffer constante que controla a visibilidade das nuvens acima da cabeça de Geralt. </font><font style="vertical-align: inherit;">Em todos os quadros que testei, foi igual a 0,0, o que equivale à ausência de nuvens. </font><font style="vertical-align: inherit;">À medida que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distanceAttenuation se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aproxima de 1,0 (a distância da câmera até a cúpula do céu aumenta), as nuvens se tornam mais visíveis.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Amostragem de textura de ruído</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O cálculo das coordenadas da amostragem do ruído da textura calcula cálculos semelhantes para a textura das nuvens, exceto pelo uso de um conjunto diferente de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">textureScale</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speedMultiplier</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Claro, um sampler com o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">envoltório</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> modo de endereçamento habilitado é usado para provar todas essas texturas </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">48</span>: mul r1.xy, cb0[<span class="hljs-number">0</span>].xxxx, cb4[<span class="hljs-number">11</span>].xyxx  
  <span class="hljs-number">49</span>: mad r1.xy, v1.xyxx, cb4[<span class="hljs-number">10</span>].xyxx, r1.xyxx  
  <span class="hljs-number">50</span>: sample_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r1.x, r1.xyxx, t1.xyzw, s0  <font></font>
   <font></font>
   <span class="hljs-comment">// Calc sampling coords for noise  </span><font></font>
   float2 noiseTextureUV = Texcoords * textureScaleNoise + elapsedTime * speedFactorsNoise;  <font></font>
   <font></font>
   <span class="hljs-comment">// Sample texture and get data from it  </span>
   <span class="hljs-keyword">float</span> noiseTextureValue = texture1.Sample( sampler0, noiseTextureUV ).x;</code></pre> <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juntando tudo</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de receber o valor do ruído, devemos combiná-lo com o cloudShape. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu tive alguns problemas para entender essas linhas, onde há param2.w (que é sempre 1.0) e noiseMult (tem um valor de 5.0, retirado do buffer constante). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seja como for, o mais importante aqui é o valor final de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generalCloudsVisibility</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que afeta a visibilidade das nuvens. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veja também o valor final do ruído. </font><font style="vertical-align: inherit;">A cor de saída do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloudsColor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é multiplicada pelo ruído final, que também é enviado para o canal alfa.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">51</span>: mad r1.x, r1.x, cb4[<span class="hljs-number">12</span>].x, -cb4[<span class="hljs-number">12</span>].x
  <span class="hljs-number">52</span>: mad_sat r1.x, cb4[<span class="hljs-number">12</span>].x, v2.w, r1.x
  <span class="hljs-number">53</span>: mul r0.w, r0.w, r1.x
  <span class="hljs-number">54</span>: mul_sat r0.w, r0.w, cb4[<span class="hljs-number">6</span>].x
  <span class="hljs-number">55</span>: mul o0.xyz, r0.wwww, r0.xyzx
  <span class="hljs-number">56</span>: mov o0.w, r0.w
  <span class="hljs-number">57</span>: ret   <font></font>
<font></font>
   <span class="hljs-comment">// Sample noise texture and get data from it  </span>
   <span class="hljs-keyword">float</span> noiseTextureValue = texture1.Sample( sampler0, noiseTextureUV ).x;  <font></font>
   noiseTextureValue = noiseTextureValue * noiseMult - noiseMult;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> noiseValue = saturate( noiseMult * Input.param2.w + noiseTextureValue);  <font></font>
   noiseValue *= cloudShape;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> finalNoise = saturate( noiseValue * generalCloudsVisibility);  <font></font>
   <font></font>
   <span class="hljs-keyword">return</span> float4( cloudsColor*finalNoise, finalNoise ); </code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O resultado final parece muito crível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode comparar. </font><font style="vertical-align: inherit;">A primeira foto é o meu shader, a segunda é o jogo shader:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4cc/331/897/4cc3318976e9c1c54178683a2fee44c0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você estiver curioso, o shader está disponível </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 2. Nevoeiro</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O nevoeiro pode ser implementado de várias maneiras. No entanto, os momentos em que poderíamos aplicar um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nevoeiro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simples </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">, dependente da distância,</font></a><font style="vertical-align: inherit;"> e eliminá-lo, estavam para sempre no passado (provavelmente). Viver no mundo dos shaders programáveis ​​abriu as portas para novas soluções malucas, mas mais importante, fisicamente precisas e visualmente realistas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As tendências atuais na renderização de nevoeiro são baseadas em shaders computacionais (para detalhes, consulte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> apresentação de Bart Wronsky). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apesar do fato de esta apresentação ter aparecido em 2014 e de The Witcher 3 ter sido lançado em 2015/2016, o nevoeiro na última parte das aventuras de Geralt depende completamente da tela e é implementado como um pós-processamento típico.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de começarmos a próxima sessão de engenharia reversa, devo dizer que, no ano passado, tentei descobrir o nevoeiro do Witcher 3 pelo menos cinco vezes, e cada vez falhava. O código do assembler, como você verá em breve, é bastante complicado, e isso torna quase impossível o processo de criação de um shader de neblina legível no HLSL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, consegui encontrar um shader de neblina na Internet que imediatamente chamou minha atenção devido à sua semelhança com o nevoeiro The Witcher 3 em termos de nomes de variáveis ​​e ordem geral de instruções. Esse shader não era exatamente o mesmo que no jogo, então tive que refazer um pouco. Quero dizer que a parte principal do código HLSL que você vê aqui foi, com duas exceções, não criada / analisada por mim. Lembre-se disso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está o código do assembler para o pixel fog shader - vale a pena notar que é o mesmo para todo o jogo (a parte principal de 2015 e os dois DLCs):</font></font><br>
<br>
<pre><code class="cpp hljs"> ps_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb3[<span class="hljs-number">2</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb12[<span class="hljs-number">214</span>], <span class="hljs-function">immediateIndexed  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t0  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t1  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t2  
    dcl_input_ps_siv v0.xy, position  
    dcl_output o0.xyzw  
    dcl_temps 7  
   0: ftou r0.xy, v0.xyxx  
   1: mov r0.zw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
   2: <span class="hljs-title">ld_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r1.x, r0.xyww, t0.xyzw  
   3: mad r1.y, r1.x, cb12[22].x, cb12[22].y  
   4: lt r1.y, r1.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
   5: if_nz r1.y  
   6:  utof r1.yz, r0.xxyx  
   7:  mul r2.xyzw, r1.zzzz, cb12[211].xyzw  
   8:  mad r2.xyzw, cb12[210].xyzw, r1.yyyy, r2.xyzw  
   9:  mad r1.xyzw, cb12[212].xyzw, r1.xxxx, r2.xyzw  
  10:  add r1.xyzw, r1.xyzw, cb12[213].xyzw  
  11:  div r1.xyz, r1.xyzx, r1.wwww  
  12:  <span class="hljs-title">ld_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r2.xyz, r0.xyww, t1.xyzw  
  13:  <span class="hljs-title">ld_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r0.x, r0.xyzw, t2.xyzw  
  14:  max r0.x, r0.x, cb3[1].x  
  15:  add r0.yzw, r1.xxyz, -cb12[0].xxyz  
  16:  dp3 r1.x, r0.yzwy, r0.yzwy  
  17:  <span class="hljs-built_in">sqrt</span> r1.x, r1.x  
  18:  add r1.y, r1.x, -cb3[0].x  
  19:  add r1.zw, -cb3[0].xxxz, cb3[0].yyyw  
  20:  div_sat r1.y, r1.y, r1.z  
  21:  mad r1.y, r1.y, r1.w, cb3[0].z  
  22:  add r0.x, r0.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-1.000000</span>)</span>  
  23:  mad r0.x, r1.y, r0.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  24:  div r0.yzw, r0.yyzw, r1.xxxx  
  25:  mad r1.y, r0.w, cb12[22].z, cb12[0].z  
  26:  add r1.x, r1.x, -cb12[22].z  
  27:  max r1.x, r1.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>  
  28:  min r1.x, r1.x, cb12[42].z  
  29:  mul r1.z, r0.w, r1.x  
  30:  mul r1.w, r1.x, cb12[43].x  
  31:  mul r1.zw, r1.zzzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.062500</span>, <span class="hljs-number">0.062500</span>)</span>  
  32:  dp3 r0.y, cb12[38].xyzx, r0.yzwy  
  33:  add r0.z, r0.y, cb12[42].x  
  34:  add r0.w, cb12[42].x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  35:  div_sat r0.z, r0.z, r0.w  
  36:  add r0.w, -cb12[43].z, cb12[43].y  
  37:  mad r0.z, r0.z, r0.w, cb12[43].z  
  38:  mul r0.w, <span class="hljs-title">abs</span><span class="hljs-params">(r0.y)</span>, <span class="hljs-title">abs</span><span class="hljs-params">(r0.y)</span>  
  39:  mad_sat r2.w, r1.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.002000</span>)</span>, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-0.300000</span>)</span>  
  40:  mul r0.w, r0.w, r2.w  
  41:  lt r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, r0.y  
  42:  movc r3.xyz, r0.yyyy, cb12[39].xyzx, cb12[41].xyzx  
  43:  add r3.xyz, r3.xyzx, -cb12[40].xyzx  
  44:  mad r3.xyz, r0.wwww, r3.xyzx, cb12[40].xyzx  
  45:  movc r4.xyz, r0.yyyy, cb12[45].xyzx, cb12[47].xyzx  
  46:  add r4.xyz, r4.xyzx, -cb12[46].xyzx  
  47:  mad r4.xyz, r0.wwww, r4.xyzx, cb12[46].xyzx  
  48:  ge r0.y, r1.x, cb12[48].y  
  49:  if_nz r0.y  
  50:   add r0.y, r1.y, cb12[42].y  
  51:   mul r0.w, r0.z, r0.y  
  52:   mul r1.y, r0.z, r1.z  
  53:   mad r5.xyzw, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">16.000000</span>, <span class="hljs-number">15.000000</span>, <span class="hljs-number">14.000000</span>, <span class="hljs-number">13.000000</span>)</span>, r0.wwww  
  54:   max r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  55:   add r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  56:   div_sat r5.xyzw, r1.wwww, r5.xyzw  
  57:   add r5.xyzw, -r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  58:   mul r1.z, r5.y, r5.x  
  59:   mul r1.z, r5.z, r1.z  
  60:   mul r1.z, r5.w, r1.z  
  61:   mad r5.xyzw, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">12.000000</span>, <span class="hljs-number">11.000000</span>, <span class="hljs-number">10.000000</span>, <span class="hljs-number">9.000000</span>)</span>, r0.wwww  
  62:   max r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  63:   add r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  64:   div_sat r5.xyzw, r1.wwww, r5.xyzw  
  65:   add r5.xyzw, -r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  66:   mul r1.z, r1.z, r5.x  
  67:   mul r1.z, r5.y, r1.z  
  68:   mul r1.z, r5.z, r1.z  
  69:   mul r1.z, r5.w, r1.z  
  70:   mad r5.xyzw, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">8.000000</span>, <span class="hljs-number">7.000000</span>, <span class="hljs-number">6.000000</span>, <span class="hljs-number">5.000000</span>)</span>, r0.wwww  
  71:   max r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  72:   add r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  73:   div_sat r5.xyzw, r1.wwww, r5.xyzw  
  74:   add r5.xyzw, -r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  75:   mul r1.z, r1.z, r5.x  
  76:   mul r1.z, r5.y, r1.z  
  77:   mul r1.z, r5.z, r1.z  
  78:   mul r1.z, r5.w, r1.z  
  79:   mad r5.xy, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">4.000000</span>, <span class="hljs-number">3.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>, r0.wwww  
  80:   max r5.xy, r5.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  81:   add r5.xy, r5.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  82:   div_sat r5.xy, r1.wwww, r5.xyxx  
  83:   add r5.xy, -r5.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  84:   mul r1.z, r1.z, r5.x  
  85:   mul r1.z, r5.y, r1.z  
  86:   mad r0.w, r1.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">2.000000</span>)</span>, r0.w  
  87:   max r0.w, r0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>  
  88:   add r0.w, r0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  89:   div_sat r0.w, r1.w, r0.w  
  90:   add r0.w, -r0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  91:   mul r0.w, r0.w, r1.z  
  92:   mad r0.y, r0.y, r0.z, r1.y  
  93:   max r0.y, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>  
  94:   add r0.y, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  95:   div_sat r0.y, r1.w, r0.y  
  96:   add r0.y, -r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  97:   mad r0.y, -r0.w, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  98:   add r0.z, r1.x, -cb12[48].y  
  99:   mul_sat r0.z, r0.z, cb12[48].z  
  100:  <span class="hljs-keyword">else</span>  
  101:   mov r0.yz, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  102:  endif  
  103:  <span class="hljs-built_in">log</span> r0.y, r0.y  
  104:  mul r0.w, r0.y, cb12[42].w  
  105:  <span class="hljs-built_in">exp</span> r0.w, r0.w  
  106:  mul r0.y, r0.y, cb12[48].x  
  107:  <span class="hljs-built_in">exp</span> r0.y, r0.y  
  108:  mul r0.yw, r0.yyyw, r0.zzzz  
  109:  mad_sat r1.xy, r0.wwww, cb12[189].xzxx, cb12[189].ywyy  
  110:  add r5.xyz, -r3.xyzx, cb12[188].xyzx  
  111:  mad r5.xyz, r1.xxxx, r5.xyzx, r3.xyzx  
  112:  add r0.z, cb12[188].w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-1.000000</span>)</span>  
  113:  mad r0.z, r1.y, r0.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  114:  mul_sat r5.w, r0.z, r0.w  
  115:  lt r0.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, cb12[192].x  
  116:  if_nz r0.z  
  117:   mad_sat r1.xy, r0.wwww, cb12[191].xzxx, cb12[191].ywyy  
  118:   add r6.xyz, -r3.xyzx, cb12[190].xyzx  
  119:   mad r3.xyz, r1.xxxx, r6.xyzx, r3.xyzx  
  120:   add r0.z, cb12[190].w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-1.000000</span>)</span>  
  121:   mad r0.z, r1.y, r0.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  122:   mul_sat r3.w, r0.z, r0.w  
  123:   add r1.xyzw, -r5.xyzw, r3.xyzw  
  124:   mad r5.xyzw, cb12[192].xxxx, r1.xyzw, r5.xyzw  
  125:  endif  
  126:  mul r0.z, r0.x, r5.w  
  127:  mul r0.x, r0.x, r0.y  
  128:  dp3 r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.333000</span>, <span class="hljs-number">0.555000</span>, <span class="hljs-number">0.222000</span>, <span class="hljs-number">0.000000</span>)</span>, r2.xyzx  
  129:  mad r1.xyz, r0.yyyy, r4.xyzx, -r2.xyzx  
  130:  mad r0.xyw, r0.xxxx, r1.xyxz, r2.xyxz  
  131:  add r1.xyz, -r0.xywx, r5.xyzx  
  132:  mad r0.xyz, r0.zzzz, r1.xyzx, r0.xywx  
  133: <span class="hljs-keyword">else</span>  
  134:  mov r0.xyz, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  135: endif  
  136: mov o0.xyz, r0.xyzx  
  137: mov o0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  138: ret </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Honestamente, o shader é bastante longo. </font><font style="vertical-align: inherit;">Provavelmente muito tempo para um processo eficaz de engenharia reversa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está um exemplo de uma cena do pôr do sol com neblina:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/d59/f51/375d59f5199e791efd99c218a0ea6f53.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos dar uma olhada na entrada: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quanto às texturas, temos um buffer de profundidade, Oclusão ambiental e um buffer de cores HDR.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ea/24d/ff0/9ea24dff07dad409a78834272d553b29.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buffer de profundidade de entrada</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/c8f/e3e/3e7c8fe3ee0dc58e3007f9a1bad7f877.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oclusão ambiental de entrada</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/748/51f/f3c/74851ff3ce8d38b77d9319329a334d4f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O buffer de cores HDR de entrada</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
... e o resultado da aplicação do shader de neblina nesta cena têm a seguinte aparência:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ee/2f8/5ad/1ee2f85adc2cc870769985308b6dcc48.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textura HDR após a aplicação de neblina O</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
buffer de profundidade é usado para recriar a posição no mundo. Esse é o padrão padrão para os shaders do Witcher 3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ter dados de oclusão do ambiente (se ativado) permite obscurecer a névoa. Uma ideia muito inteligente, talvez óbvia, mas nunca pensei nisso dessa maneira. Voltarei a esse aspecto mais tarde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um sombreador começa determinando se um pixel está no céu. Caso o pixel fique no céu (profundidade == 1,0), o sombreador retornará preto. Se o pixel estiver na cena (profundidade &lt;1,0), recriaremos a posição no mundo usando o buffer de profundidade (linhas 7 a 11) e continuaremos a calcular o nevoeiro.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A passagem do nevoeiro ocorre logo após o processo de sombreamento atrasado. </font><font style="vertical-align: inherit;">Você pode perceber que alguns elementos relacionados à execução futura ainda não estão disponíveis. </font><font style="vertical-align: inherit;">Nesta cena em particular, os volumes de iluminação diferidos foram aplicados e, depois disso, renderizamos o cabelo / rosto / olhos de Geralt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira coisa que você precisa saber sobre o nevoeiro em "The Witcher 3": consiste em duas partes - "cor do nevoeiro" e "cor da atmosfera".</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FogResult</span>  
 {</span>  
    float4 paramsFog;     <span class="hljs-comment">// RGB: color, A: influence  </span>
    float4 paramsAerial;  <span class="hljs-comment">// RGB: color, A: influence  </span>
 };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para cada parte, existem três cores: frontal, central e traseira. </font><font style="vertical-align: inherit;">Ou seja, no buffer constante existem dados como "FogColorFront", "FogColorMiddle", "AerialColorBack", etc. ... Vamos ver os dados recebidos:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b2/cd0/55d/0b2cd055d9f6876c57527b9934b3b6ad.png"></div><br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// *** Inputs *** //  </span><font></font>
   float3 FogSunDir = cb12_v38.xyz;  <font></font>
   float3 FogColorFront = cb12_v39.xyz;  <font></font>
   float3 FogColorMiddle = cb12_v40.xyz;  <font></font>
   float3 FogColorBack = cb12_v41.xyz;  <font></font>
     <font></font>
   float4 FogBaseParams = cb12_v42;  <font></font>
   float4 FogDensityParamsScene = cb12_v43;  <font></font>
   float4 FogDensityParamsSky = cb12_v44;  <font></font>
     <font></font>
   float3 AerialColorFront = cb12_v45.xyz;  <font></font>
   float3 AerialColorMiddle = cb12_v46.xyz;  <font></font>
   float3 AerialColorBack = cb12_v47.xyz;  <font></font>
   float4 AerialParams = cb12_v48;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de calcular as cores finais, precisamos calcular os vetores e produtos escalares. </font><font style="vertical-align: inherit;">O sombreador tem acesso à posição do pixel no mundo, à posição da câmera (cb12 [0] .xyz) e à direção da névoa / iluminação (cb12 [38] .xyz). </font><font style="vertical-align: inherit;">Isso nos permite calcular o produto escalar do vetor da forma e direção do nevoeiro.</font></font><br>
<br>
<pre><code class="cpp hljs">   float3 frag_vec = fragPosWorldSpace.xyz - customCameraPos.xyz;  
   <span class="hljs-keyword">float</span> frag_dist = length(frag_vec);  <font></font>
     <font></font>
   float3 frag_dir = frag_vec / frag_dist;  <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> dot_fragDirSunDir = dot(GlobalLightDirection.xyz, frag_dir);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para calcular o gradiente de mistura, você precisa usar o quadrado do produto escalar absoluto e multiplicar novamente o resultado por algum parâmetro que depende da distância:</font></font><br>
<br>
<pre><code class="cpp hljs">   float3 curr_col_fog;  <font></font>
   float3 curr_col_aerial;  <font></font>
   {  <font></font>
     <span class="hljs-keyword">float</span> _dot = dot_fragDirSunDir;  <font></font>
   <font></font>
     <span class="hljs-keyword">float</span> _dd = _dot;  <font></font>
     {  <font></font>
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _distOffset = <span class="hljs-number">-150</span>;  
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _distRange = <span class="hljs-number">500</span>;  
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _mul = <span class="hljs-number">1.0</span> / _distRange;  
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _bias = _distOffset * _mul;  <font></font>
   <font></font>
       _dd = <span class="hljs-built_in">abs</span>(_dd);  <font></font>
       _dd *= _dd;  <font></font>
       _dd *= saturate( frag_dist * _mul + _bias );  <font></font>
     }  <font></font>
   <font></font>
     curr_col_fog = lerp( FogColorMiddle.xyz, (_dot&gt;<span class="hljs-number">0.0f</span> ? FogColorFront.xyz : FogColorBack.xyz), _dd );  <font></font>
     curr_col_aerial = lerp( AerialColorMiddle.xyz, (_dot&gt;<span class="hljs-number">0.0f</span> ? AerialColorFront.xyz : AerialColorBack.xyz), _dd );  <font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse bloco de código nos deixa claro de onde esses 0,002 e -0,300 vieram. </font><font style="vertical-align: inherit;">Como podemos ver, o produto escalar entre os vetores de visão e iluminação é responsável pela escolha entre as cores "frontal" e "traseira". </font><font style="vertical-align: inherit;">Inteligente! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está uma visualização do gradiente final resultante (_dd).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d43/f03/ca0/d43f03ca005d504abd5cd236007f34f4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, calcular o efeito da atmosfera / névoa é muito mais complicado. Como você pode ver, temos muito mais opções do que apenas cores rgb. Eles incluem, por exemplo, densidade de cena. Usamos o raymarching (16 etapas, e é por isso que o ciclo pode ser expandido) para determinar o tamanho do nevoeiro e o fator de escala: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tendo um vetor [camera ---&gt; world], podemos dividir todos os seus componentes em 16 - esse será um passo do raymarching. Como podemos ver abaixo, apenas o componente .z (height) ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curr_pos_z_step</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) está </font><font style="vertical-align: inherit;">envolvido nos cálculos </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leia mais sobre o nevoeiro implementado pelo raymarching, por exemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">float</span> fog_amount = <span class="hljs-number">1</span>;  
   <span class="hljs-keyword">float</span> fog_amount_scale = <span class="hljs-number">0</span>;  <font></font>
   [branch]  <font></font>
   <span class="hljs-keyword">if</span> ( frag_dist &gt;= AerialParams.y )  <font></font>
   {  <font></font>
     <span class="hljs-keyword">float</span> curr_pos_z_base = (customCameraPos.z + FogBaseParams.y) * density_factor;  
     <span class="hljs-keyword">float</span> curr_pos_z_step = frag_step.z * density_factor;  <font></font>
   <font></font>
     [unroll]  <font></font>
     <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i=<span class="hljs-number">16</span>; i&gt;<span class="hljs-number">0</span>; --i )  <font></font>
     {  <font></font>
       fog_amount *= <span class="hljs-number">1</span> - saturate( density_sample_scale / (<span class="hljs-number">1</span> + max( <span class="hljs-number">0.0</span>, curr_pos_z_base + (i) * curr_pos_z_step ) ) );  <font></font>
     }  <font></font>
   <font></font>
     fog_amount = <span class="hljs-number">1</span> - fog_amount;  <font></font>
     fog_amount_scale = saturate( (frag_dist - AerialParams.y) * AerialParams.z );  <font></font>
   }  <font></font>
   <font></font>
   FogResult ret;  <font></font>
   <font></font>
   ret.paramsFog = float4 ( curr_col_fog, fog_amount_scale * <span class="hljs-built_in">pow</span>( <span class="hljs-built_in">abs</span>(fog_amount), final_exp_fog ) );  <font></font>
   ret.paramsAerial = float4 ( curr_col_aerial, fog_amount_scale * <span class="hljs-built_in">pow</span>( <span class="hljs-built_in">abs</span>(fog_amount), final_exp_aerial ) );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, a quantidade de neblina depende da altura (componentes .z); no final, a quantidade de neblina é elevada ao grau de neblina / atmosfera. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final_exp_fog</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final_exp_aerial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> são obtidos do buffer constante; </font><font style="vertical-align: inherit;">eles permitem que você controle como as cores do nevoeiro e da atmosfera afetam o mundo com o aumento da altitude.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Substituição de nevoeiro</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O shader que encontrei não tinha o seguinte fragmento de código do assembly:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">109</span>:  mad_sat r1.xy, r0.wwww, cb12[<span class="hljs-number">189</span>].xzxx, cb12[<span class="hljs-number">189</span>].ywyy  
  <span class="hljs-number">110</span>:  add r5.xyz, -r3.xyzx, cb12[<span class="hljs-number">188</span>].xyzx  
  <span class="hljs-number">111</span>:  mad r5.xyz, r1.xxxx, r5.xyzx, r3.xyzx  
  <span class="hljs-number">112</span>:  add r0.z, l(<span class="hljs-number">-1.000000</span>), cb12[<span class="hljs-number">188</span>].w  
  <span class="hljs-number">113</span>:  mad r0.z, r1.y, r0.z, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">114</span>:  mul_sat r5.w, r0.w, r0.z  
  <span class="hljs-number">115</span>:  lt r0.z, l(<span class="hljs-number">0.000000</span>), cb12[<span class="hljs-number">192</span>].x  
  <span class="hljs-number">116</span>:  if_nz r0.z  
  <span class="hljs-number">117</span>:   mad_sat r1.xy, r0.wwww, cb12[<span class="hljs-number">191</span>].xzxx, cb12[<span class="hljs-number">191</span>].ywyy  
  <span class="hljs-number">118</span>:   add r6.xyz, -r3.xyzx, cb12[<span class="hljs-number">190</span>].xyzx  
  <span class="hljs-number">119</span>:   mad r3.xyz, r1.xxxx, r6.xyzx, r3.xyzx  
  <span class="hljs-number">120</span>:   add r0.z, l(<span class="hljs-number">-1.000000</span>), cb12[<span class="hljs-number">190</span>].w  
  <span class="hljs-number">121</span>:   mad r0.z, r1.y, r0.z, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">122</span>:   mul_sat r3.w, r0.w, r0.z  
  <span class="hljs-number">123</span>:   add r1.xyzw, -r5.xyzw, r3.xyzw  
  <span class="hljs-number">124</span>:   mad r5.xyzw, cb12[<span class="hljs-number">192</span>].xxxx, r1.xyzw, r5.xyzw  
  <span class="hljs-number">125</span>:  endif</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A julgar pelo que pude entender, é como redefinir a cor e o efeito do nevoeiro: na </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
maioria das vezes, apenas uma redefinição é executada (cb12_v192.x é 0,0), mas nesse caso em particular, seu valor é ~ 0,22, então fazemos a segunda substituição.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc7/2bd/1b8/cc72bd1b8cff0742cf4aad51a7e6ab3f.png"></div><br>
<pre><code class="cpp hljs"> <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> OVERRIDE_FOG  </span><font></font>
     <font></font>
   <span class="hljs-comment">// Override  </span>
   <span class="hljs-keyword">float</span> fog_influence = ret.paramsFog.w; <span class="hljs-comment">// r0.w  </span><font></font>
   <font></font>
   <span class="hljs-keyword">float</span> override1ColorScale = cb12_v189.x;  
   <span class="hljs-keyword">float</span> override1ColorBias = cb12_v189.y;  <font></font>
   float3 override1Color = cb12_v188.rgb;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> override1InfluenceScale = cb12_v189.z;  
   <span class="hljs-keyword">float</span> override1InfluenceBias = cb12_v189.w;  
   <span class="hljs-keyword">float</span> override1Influence = cb12_v188.w;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> override1ColorAmount = saturate(fog_influence * override1ColorScale + override1ColorBias);  
   <span class="hljs-keyword">float</span> override1InfluenceAmount = saturate(fog_influence * override1InfluenceScale + override1InfluenceBias);    <font></font>
     <font></font>
<font></font>
   float4 paramsFogOverride;  <font></font>
   paramsFogOverride.rgb = lerp(curr_col_fog, override1Color, override1ColorAmount ); <span class="hljs-comment">// ***r5.xyz   </span><font></font>
     <font></font>
   <span class="hljs-keyword">float</span> param1 = lerp(<span class="hljs-number">1.0</span>, override1Influence, override1InfluenceAmount); <span class="hljs-comment">// r0.x  </span>
   paramsFogOverride.w = saturate(param1 * fog_influence ); <span class="hljs-comment">// ** r5.w  </span><font></font>
   <font></font>
     <font></font>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> extraFogOverride = cb12_v192.x;  <font></font>
     <font></font>
   [branch]   <font></font>
   <span class="hljs-keyword">if</span> (extraFogOverride &gt; <span class="hljs-number">0.0</span>)  <font></font>
   {  <font></font>
     <span class="hljs-keyword">float</span> override2ColorScale = cb12_v191.x;  
     <span class="hljs-keyword">float</span> override2ColorBias = cb12_v191.y;  <font></font>
     float3 override2Color = cb12_v190.rgb;  <font></font>
     <font></font>
     <span class="hljs-keyword">float</span> override2InfluenceScale = cb12_v191.z;  
     <span class="hljs-keyword">float</span> override2InfluenceBias = cb12_v191.w;  
     <span class="hljs-keyword">float</span> override2Influence = cb12_v190.w;  <font></font>
       <font></font>
     <span class="hljs-keyword">float</span> override2ColorAmount = saturate(fog_influence * override2ColorScale + override2ColorBias);  
     <span class="hljs-keyword">float</span> override2InfluenceAmount = saturate(fog_influence * override2InfluenceScale + override2InfluenceBias);  <font></font>
      <font></font>
<font></font>
     float4 paramsFogOverride2;  <font></font>
     paramsFogOverride2.rgb = lerp(curr_col_fog, override2Color, override2ColorAmount); <span class="hljs-comment">// r3.xyz   </span><font></font>
           <font></font>
     <span class="hljs-keyword">float</span> ov_param1 = lerp(<span class="hljs-number">1.0</span>, override2Influence, override2InfluenceAmount); <span class="hljs-comment">// r0.z  </span>
     paramsFogOverride2.w = saturate(ov_param1 * fog_influence); <span class="hljs-comment">// r3.w  </span><font></font>
   <font></font>
     paramsFogOverride = lerp(paramsFogOverride, paramsFogOverride2, extraFogOverride);  <font></font>
   <font></font>
   }  <font></font>
   ret.paramsFog = paramsFogOverride;  <font></font>
     <font></font>
 <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está o preço final sem redefinir a névoa (primeira imagem), com uma redefinição (segunda imagem) e dupla redefinição (terceira imagem, resultado final):</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b9/011/3c8/3b90113c8ad27f287cdb29a25a37470d.jpg"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03a/791/d39/03a791d39e2082b80e86ea8daa488a64.jpg"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/d59/f51/375d59f5199e791efd99c218a0ea6f53.jpg"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regulação da oclusão ambiental</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O shader que encontrei também não usava oclusão ambiental. </font><font style="vertical-align: inherit;">Vamos dar uma olhada na textura do AO novamente e no código que nos interessa:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/c8f/e3e/3e7c8fe3ee0dc58e3007f9a1bad7f877.jpg"></div><br>
<pre><code class="cpp hljs">  <span class="hljs-number">13</span>:  ld_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r0.x, r0.xyzw, t2.xyzw  
  <span class="hljs-number">14</span>:  max r0.x, r0.x, cb3[<span class="hljs-number">1</span>].x  
  <span class="hljs-number">15</span>:  add r0.yzw, r1.xxyz, -cb12[<span class="hljs-number">0</span>].xxyz  
  <span class="hljs-number">16</span>:  dp3 r1.x, r0.yzwy, r0.yzwy  
  <span class="hljs-number">17</span>:  <span class="hljs-built_in">sqrt</span> r1.x, r1.x  
  <span class="hljs-number">18</span>:  add r1.y, r1.x, -cb3[<span class="hljs-number">0</span>].x  
  <span class="hljs-number">19</span>:  add r1.zw, -cb3[<span class="hljs-number">0</span>].xxxz, cb3[<span class="hljs-number">0</span>].yyyw  
  <span class="hljs-number">20</span>:  div_sat r1.y, r1.y, r1.z  
  <span class="hljs-number">21</span>:  mad r1.y, r1.y, r1.w, cb3[<span class="hljs-number">0</span>].z  
  <span class="hljs-number">22</span>:  add r0.x, r0.x, l(<span class="hljs-number">-1.000000</span>)  
  <span class="hljs-number">23</span>:  mad r0.x, r1.y, r0.x, l(<span class="hljs-number">1.000000</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Talvez essa cena não seja o melhor exemplo, porque não vemos os detalhes em uma ilha distante. </font><font style="vertical-align: inherit;">No entanto, vamos dar uma olhada no buffer constante, que é usado para definir o valor da oclusão do ambiente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/343/c52/af4/343c52af44338628770912801bc3b32c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Começamos carregando AO da textura e depois executamos a instrução max. Nesta cena, cb3_v1.x é muito alto (0,96888), o que torna a AO muito fraca. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A próxima parte do código calcula a distância entre as posições da câmera e os pixels no mundo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu acredito que o código às vezes fala por si, então vamos ver o HLSL, que faz a maior parte dessa instalação:</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">AdjustAmbientOcclusion</span><span class="hljs-params">(in <span class="hljs-keyword">float</span> inputAO, in <span class="hljs-keyword">float</span> worldToCameraDistance)</span>  
 </span>{  
   <span class="hljs-comment">// *** Inputs *** //  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoDistanceStart = cb3_v0.x;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoDistanceEnd = cb3_v0.y;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoStrengthStart = cb3_v0.z;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoStrengthEnd = cb3_v0.w;  <font></font>
      <font></font>
   <span class="hljs-comment">// * Adjust AO  </span>
   <span class="hljs-keyword">float</span> aoDistanceIntensity = linstep( aoDistanceStart, aoDistanceEnd, worldToCameraDistance );  
   <span class="hljs-keyword">float</span> aoStrength = lerp(aoStrengthStart, aoStrengthEnd, aoDistanceIntensity);   
   <span class="hljs-keyword">float</span> adjustedAO = lerp(<span class="hljs-number">1.0</span>, inputAO, aoStrength);  <font></font>
     <font></font>
   <span class="hljs-keyword">return</span> adjustedAO;   <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A distância calculada entre a câmera e o mundo é usada para a função linstep. </font><font style="vertical-align: inherit;">Já conhecemos essa função, que apareceu no sombreador da nuvem de cirros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você pode ver, no buffer constante, temos os valores da distância inicial / final da AO. </font><font style="vertical-align: inherit;">A saída do linstep afeta a força do AO (assim como do cbuffer), e a força afeta a saída do AO. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um breve exemplo: o pixel está longe, por exemplo, a distância é 500. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
linstep retorna 1.0; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aoStrength é igual a aoStrengthEnd; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso resulta em um retorno AO, que é aproximadamente 77% (força final) do valor de entrada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O AO de entrada para esta função foi previamente submetido à operação máxima.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juntando tudo</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tendo recebido a cor e o efeito da cor do nevoeiro e da cor da atmosfera, você pode finalmente combiná-los. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Começamos atenuando o efeito com a AO resultante:</font></font><br>
<br>
<pre><code class="cpp hljs">   ...<font></font>
   FogResult fog = CalculateFog( worldPos, CameraPosition, fogStart, ao, <span class="hljs-literal">false</span> );  <font></font>
      <font></font>
   <span class="hljs-comment">// Apply AO to influence  </span><font></font>
   fog.paramsFog.w *= ao;  <font></font>
   fog.paramsAerial.w *= ao; <font></font>
      <font></font>
   <span class="hljs-comment">// Mix fog with scene color  </span>
   outColor = ApplyFog(fog, colorHDR);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toda a mágica </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acontece</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na função </font><b><font style="vertical-align: inherit;">ApplyFog</font></b><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function">float3 <span class="hljs-title">ApplyFog</span><span class="hljs-params">(FogResult fog, float3 color)</span>  
 </span>{  
   <span class="hljs-keyword">const</span> float3 LuminanceFactors = float3(<span class="hljs-number">0.333f</span>, <span class="hljs-number">0.555f</span>, <span class="hljs-number">0.222f</span>);  <font></font>
   <font></font>
   float3 aerialColor = dot(LuminanceFactors, color) * fog.paramsAerial.xyz;  <font></font>
   color = lerp(color, aerialColor, fog.paramsAerial.w);  <font></font>
   color = lerp(color, fog.paramsFog.xyz, fog.paramsFog.w);  <font></font>
    <font></font>
   <span class="hljs-keyword">return</span> color.xyz;  <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, calculamos a luminosidade dos pixels:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6bd/b00/570/6bdb005708a11953aeb8ce711a942f0d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então multiplicamos pela cor da atmosfera:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7d/f89/f04/e7df89f04524c4e547a91a645317a387.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, combinamos a cor HDR com a cor da atmosfera:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cae/40a/912/cae40a9124b33e97aa38ac5b72b9a5ae.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O último passo é combinar o resultado intermediário com a cor do nevoeiro:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ee/2f8/5ad/1ee2f85adc2cc870769985308b6dcc48.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é tudo!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algumas capturas de tela de depuração</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/b08/e69/012b08e69615702c9267f24f167dfa98.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Efeito atmosférico</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/c3a/f2c/b1bc3af2c5d59db606570a54e861659b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cor da atmosfera</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/b17/0ab/d10b170ab255b3ff9b4d6fad60e1c1e3.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Efeito nevoeiro</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d76/9ae/dde/d769aedde1917ab6024e524d9c99625d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cor de nevoeiro</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/b15/0dd/7adb150dddf4df73c8dc75e51aa9e138.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cena finalizada sem nevoeiro</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/fdc/507/f53fdc5076e000acb24a775ba7558e8a.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cena pronta com apenas nevoeiro</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad1/223/e4a/ad1223e4aabc3dc3f07a77125b54211f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A cena final é apenas o nevoeiro principal</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/d59/f51/375d59f5199e791efd99c218a0ea6f53.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cena pronta novamente com todo o nevoeiro para facilitar a comparação</font></font></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu acho que você pode entender muitas coisas acima, se você olhar para o shader, está </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Posso dizer com prazer que esse shader </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é exatamente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o mesmo que o original - isso me deixa muito feliz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, o resultado final é altamente dependente dos valores transmitidos ao shader. Esta não é uma solução "mágica" que fornece cores perfeitas na saída; requer muitas iterações e artistas para fazer com que o resultado final pareça decente. Acho que pode ser um processo longo, mas depois que você o concluir, o resultado será muito convincente, assim como esta cena do pôr do sol.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Witcher 3 Sky Shader também usa cálculos de nevoeiro para criar uma transição suave de cores perto do horizonte. </font><font style="vertical-align: inherit;">No entanto, um conjunto diferente de coeficientes de densidade é passado para o sombreador do céu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deixe-me lembrá-lo - a maior parte desse shader não foi criada / analisada por mim. </font><font style="vertical-align: inherit;">Todos os agradecimentos devem ser enviados para o CD PROJEKT RED. </font><font style="vertical-align: inherit;">Apoie-os, eles fazem um excelente trabalho.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 3. Estrelas cadentes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em The Witcher 3, há um pequeno mas curioso detalhe - estrelas cadentes. </font><font style="vertical-align: inherit;">Curiosamente, eles não parecem estar no DLC Blood and Wine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No vídeo, você pode ver como elas se parecem:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/IWtutrr6ilE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver como conseguimos esse efeito. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você pode ver, o corpo de uma estrela cadente é muito mais brilhante que a cauda. </font><font style="vertical-align: inherit;">Essa é uma propriedade importante que usaremos posteriormente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nossa agenda é bastante familiar: primeiro descreverei as propriedades gerais, depois falarei sobre tópicos relacionados à geometria e, no final, passaremos para o pixel shader, onde as coisas mais interessantes estão acontecendo.</font></font><br>
<cut></cut><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Visão geral</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Descreva brevemente o que está acontecendo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estrelas cadentes são desenhadas em uma passagem proativa, imediatamente após a cúpula do céu, céu e lua:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c5/a71/7db/1c5a717dbd047aeaa183ce2a25e394d9.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (720) - a cúpula do céu, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (2160) - a esfera do céu / lua, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (36) - é irrelevante, parece um paralelepípedo da oclusão do sol (?) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (12) - a estrela cadente </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexedInstanced (1116, 1) - nuvens cirros </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as nuvens cirros</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cada estrela cadente é desenhada duas vezes seguidas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baa/27d/e4c/baa27de4ced017770e9c89a01e136abd.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes da primeira chamada de empate</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc8/78b/cef/cc878bcef6dcc4b58e85f3a62f90be31.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado da primeira chamada de empate</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ee/33f/f6c/0ee33ff6cef3d11ca7cd460f21dc2b3f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado da segunda chamada de empate</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Além disso, como em muitos elementos do passe preventivo deste jogo, o seguinte estado de mistura é usado:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/aec/b8a/263aecb8afa21e2b79b0333bcde55011.jpg"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Geometria</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Do ponto de vista da geometria, a primeira coisa a mencionar é que cada estrela cadente é representada por um fino quadrilátero com cabos de texto: 4 vértices, 6 índices. </font><font style="vertical-align: inherit;">Este é o quad mais simples possível.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82c/fbf/96b/82cfbf96bbc652ea5ac32a5e568434a3.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quadrilátero aproximado de uma estrela cadente </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/83c/59e/3f7/83c59e3f7e685d6e7f2080e88ff5be25.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainda mais próximo é o quadrilátero aproximado de uma estrela cadente. </font><font style="vertical-align: inherit;">Você pode ver a exibição em estrutura de arame de uma linha que indica dois triângulos. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espere um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minuto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas há </font><i><font style="vertical-align: inherit;">DrawIndexed (12)</font></i><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Isso significa que desenhamos duas estrelas cadentes ao mesmo tempo? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sim.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d55/b39/bb2/d55b39bb2d2ea5908f4576d6396455fa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse quadro, uma das estrelas cadentes está completamente fora da pirâmide de visibilidade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos o código do assembler para o vertex shader:</font></font><br>
<br>
<pre><code class="cpp hljs"> vs_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb1[<span class="hljs-number">9</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb2[<span class="hljs-number">3</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb12[<span class="hljs-number">193</span>], immediateIndexed  <font></font>
    dcl_input v0.xyz  <font></font>
    dcl_input v1.xyzw  <font></font>
    dcl_input v2.xy  <font></font>
    dcl_input v3.xy  <font></font>
    dcl_input v4.xy  <font></font>
    dcl_input v5.xyz  <font></font>
    dcl_input v6.x  <font></font>
    dcl_input v7.x  <font></font>
    dcl_output o0.xyzw  <font></font>
    dcl_output o1.xyzw  <font></font>
    dcl_output o2.xy  <font></font>
    dcl_output o3.xyzw  <font></font>
    dcl_output_siv o4.xyzw, position  <font></font>
    dcl_temps <span class="hljs-number">5</span>  
   <span class="hljs-number">0</span>: mov r0.xyz, v0.xyzx  
   <span class="hljs-number">1</span>: mov r0.w, l(<span class="hljs-number">1.000000</span>)  
   <span class="hljs-number">2</span>: dp4 r1.x, r0.xyzw, cb2[<span class="hljs-number">0</span>].xyzw  
   <span class="hljs-number">3</span>: dp4 r1.y, r0.xyzw, cb2[<span class="hljs-number">1</span>].xyzw  
   <span class="hljs-number">4</span>: dp4 r1.z, r0.xyzw, cb2[<span class="hljs-number">2</span>].xyzw  
   <span class="hljs-number">5</span>: add r0.x, v2.x, v2.y  
   <span class="hljs-number">6</span>: add r0.y, -v2.y, v2.x  
   <span class="hljs-number">7</span>: add r2.xyz, -r1.zxyz, cb1[<span class="hljs-number">8</span>].zxyz  
   <span class="hljs-number">8</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
   <span class="hljs-number">9</span>: rsq r0.z, r0.z  
  <span class="hljs-number">10</span>: mul r2.xyz, r0.zzzz, r2.xyzx  
  <span class="hljs-number">11</span>: dp3 r0.z, v5.xyzx, v5.xyzx  
  <span class="hljs-number">12</span>: rsq r0.z, r0.z  
  <span class="hljs-number">13</span>: mul r3.xyz, r0.zzzz, v5.xyzx  
  <span class="hljs-number">14</span>: mul r4.xyz, r2.xyzx, r3.yzxy  
  <span class="hljs-number">15</span>: mad r2.xyz, r2.zxyz, r3.zxyz, -r4.xyzx  
  <span class="hljs-number">16</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
  <span class="hljs-number">17</span>: rsq r0.z, r0.z  
  <span class="hljs-number">18</span>: mul r2.xyz, r0.zzzz, r2.xyzx  
  <span class="hljs-number">19</span>: mad r0.z, v7.x, v6.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">20</span>: mul r3.xyz, r0.zzzz, r3.xyzx  
  <span class="hljs-number">21</span>: mul r3.xyz, r3.xyzx, v3.xxxx  
  <span class="hljs-number">22</span>: mul r2.xyz, r2.xyzx, v3.yyyy  
  <span class="hljs-number">23</span>: mad r0.xzw, r3.xxyz, r0.xxxx, r1.xxyz  
  <span class="hljs-number">24</span>: mad r0.xyz, r2.xyzx, r0.yyyy, r0.xzwx  
  <span class="hljs-number">25</span>: mov r0.w, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">26</span>: dp4 o4.x, r0.xyzw, cb1[<span class="hljs-number">0</span>].xyzw  
  <span class="hljs-number">27</span>: dp4 o4.y, r0.xyzw, cb1[<span class="hljs-number">1</span>].xyzw  
  <span class="hljs-number">28</span>: dp4 o4.z, r0.xyzw, cb1[<span class="hljs-number">2</span>].xyzw  
  <span class="hljs-number">29</span>: dp4 o4.w, r0.xyzw, cb1[<span class="hljs-number">3</span>].xyzw  
  <span class="hljs-number">30</span>: add r0.xyz, r0.xyzx, -cb12[<span class="hljs-number">0</span>].xyzx  
  <span class="hljs-number">31</span>: dp3 r0.w, r0.xyzx, r0.xyzx  
  <span class="hljs-number">32</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  <span class="hljs-number">33</span>: div r0.xyz, r0.xyzx, r0.wwww  
  <span class="hljs-number">34</span>: add r0.w, r0.w, -cb12[<span class="hljs-number">22</span>].z  
  <span class="hljs-number">35</span>: max r0.w, r0.w, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">36</span>: min r0.w, r0.w, cb12[<span class="hljs-number">42</span>].z  
  <span class="hljs-number">37</span>: dp3 r0.x, cb12[<span class="hljs-number">38</span>].xyzx, r0.xyzx  
  <span class="hljs-number">38</span>: mul r0.y, <span class="hljs-built_in">abs</span>(r0.x), <span class="hljs-built_in">abs</span>(r0.x)  
  <span class="hljs-number">39</span>: mad_sat r1.x, r0.w, l(<span class="hljs-number">0.002000</span>), l(<span class="hljs-number">-0.300000</span>)  
  <span class="hljs-number">40</span>: mul r0.y, r0.y, r1.x  
  <span class="hljs-number">41</span>: lt r1.x, l(<span class="hljs-number">0</span>), r0.x  
  <span class="hljs-number">42</span>: movc r1.yzw, r1.xxxx, cb12[<span class="hljs-number">39</span>].xxyz, cb12[<span class="hljs-number">41</span>].xxyz  
  <span class="hljs-number">43</span>: add r1.yzw, r1.yyzw, -cb12[<span class="hljs-number">40</span>].xxyz  
  <span class="hljs-number">44</span>: mad r1.yzw, r0.yyyy, r1.yyzw, cb12[<span class="hljs-number">40</span>].xxyz  
  <span class="hljs-number">45</span>: movc r2.xyz, r1.xxxx, cb12[<span class="hljs-number">45</span>].xyzx, cb12[<span class="hljs-number">47</span>].xyzx  
  <span class="hljs-number">46</span>: add r2.xyz, r2.xyzx, -cb12[<span class="hljs-number">46</span>].xyzx  
  <span class="hljs-number">47</span>: mad o0.xyz, r0.yyyy, r2.xyzx, cb12[<span class="hljs-number">46</span>].xyzx  
  <span class="hljs-number">48</span>: ge r0.y, r0.w, cb12[<span class="hljs-number">48</span>].y  
  <span class="hljs-number">49</span>: if_nz r0.y  
  <span class="hljs-number">50</span>:  mad r0.y, r0.z, cb12[<span class="hljs-number">22</span>].z, cb12[<span class="hljs-number">0</span>].z  
  <span class="hljs-number">51</span>:  mul r0.z, r0.w, r0.z  
  <span class="hljs-number">52</span>:  mul r0.z, r0.z, l(<span class="hljs-number">0.062500</span>)  
  <span class="hljs-number">53</span>:  mul r1.x, r0.w, cb12[<span class="hljs-number">43</span>].x  
  <span class="hljs-number">54</span>:  mul r1.x, r1.x, l(<span class="hljs-number">0.062500</span>)  
  <span class="hljs-number">55</span>:  add r0.x, r0.x, cb12[<span class="hljs-number">42</span>].x  
  <span class="hljs-number">56</span>:  add r2.x, cb12[<span class="hljs-number">42</span>].x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">57</span>:  div_sat r0.x, r0.x, r2.x  
  <span class="hljs-number">58</span>:  add r2.x, -cb12[<span class="hljs-number">43</span>].z, cb12[<span class="hljs-number">43</span>].y  
  <span class="hljs-number">59</span>:  mad r0.x, r0.x, r2.x, cb12[<span class="hljs-number">43</span>].z  
  <span class="hljs-number">60</span>:  add r0.y, r0.y, cb12[<span class="hljs-number">42</span>].y  
  <span class="hljs-number">61</span>:  mul r2.x, r0.x, r0.y  
  <span class="hljs-number">62</span>:  mul r0.z, r0.x, r0.z  
  <span class="hljs-number">63</span>:  mad r3.xyzw, r0.zzzz, l(<span class="hljs-number">16.000000</span>, <span class="hljs-number">15.000000</span>, <span class="hljs-number">14.000000</span>, <span class="hljs-number">13.000000</span>), r2.xxxx  
  <span class="hljs-number">64</span>:  max r3.xyzw, r3.xyzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">65</span>:  add r3.xyzw, r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">66</span>:  div_sat r3.xyzw, r1.xxxx, r3.xyzw  
  <span class="hljs-number">67</span>:  add r3.xyzw, -r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">68</span>:  mul r2.y, r3.y, r3.x  
  <span class="hljs-number">69</span>:  mul r2.y, r3.z, r2.y  
  <span class="hljs-number">70</span>:  mul r2.y, r3.w, r2.y  
  <span class="hljs-number">71</span>:  mad r3.xyzw, r0.zzzz, l(<span class="hljs-number">12.000000</span>, <span class="hljs-number">11.000000</span>, <span class="hljs-number">10.000000</span>, <span class="hljs-number">9.000000</span>), r2.xxxx  
  <span class="hljs-number">72</span>:  max r3.xyzw, r3.xyzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">73</span>:  add r3.xyzw, r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">74</span>:  div_sat r3.xyzw, r1.xxxx, r3.xyzw  
  <span class="hljs-number">75</span>:  add r3.xyzw, -r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">76</span>:  mul r2.y, r2.y, r3.x  
  <span class="hljs-number">77</span>:  mul r2.y, r3.y, r2.y  
  <span class="hljs-number">78</span>:  mul r2.y, r3.z, r2.y  
  <span class="hljs-number">79</span>:  mul r2.y, r3.w, r2.y  
  <span class="hljs-number">80</span>:  mad r3.xyzw, r0.zzzz, l(<span class="hljs-number">8.000000</span>, <span class="hljs-number">7.000000</span>, <span class="hljs-number">6.000000</span>, <span class="hljs-number">5.000000</span>), r2.xxxx  
  <span class="hljs-number">81</span>:  max r3.xyzw, r3.xyzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">82</span>:  add r3.xyzw, r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">83</span>:  div_sat r3.xyzw, r1.xxxx, r3.xyzw  
  <span class="hljs-number">84</span>:  add r3.xyzw, -r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">85</span>:  mul r2.y, r2.y, r3.x  
  <span class="hljs-number">86</span>:  mul r2.y, r3.y, r2.y  
  <span class="hljs-number">87</span>:  mul r2.y, r3.z, r2.y  
  <span class="hljs-number">88</span>:  mul r2.y, r3.w, r2.y  
  <span class="hljs-number">89</span>:  mad r2.zw, r0.zzzz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">4.000000</span>, <span class="hljs-number">3.000000</span>), r2.xxxx  
  <span class="hljs-number">90</span>:  max r2.zw, r2.zzzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">91</span>:  add r2.zw, r2.zzzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">92</span>:  div_sat r2.zw, r1.xxxx, r2.zzzw  
  <span class="hljs-number">93</span>:  add r2.zw, -r2.zzzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">94</span>:  mul r2.y, r2.z, r2.y  
  <span class="hljs-number">95</span>:  mul r2.y, r2.w, r2.y  
  <span class="hljs-number">96</span>:  mad r2.x, r0.z, l(<span class="hljs-number">2.000000</span>), r2.x  
  <span class="hljs-number">97</span>:  max r2.x, r2.x, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">98</span>:  add r2.x, r2.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">99</span>:  div_sat r2.x, r1.x, r2.x  
  <span class="hljs-number">100</span>:  add r2.x, -r2.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">101</span>:  mul r2.x, r2.x, r2.y  
  <span class="hljs-number">102</span>:  mad r0.x, r0.y, r0.x, r0.z  
  <span class="hljs-number">103</span>:  max r0.x, r0.x, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">104</span>:  add r0.x, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">105</span>:  div_sat r0.x, r1.x, r0.x  
  <span class="hljs-number">106</span>:  add r0.x, -r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">107</span>:  mad r0.x, -r2.x, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">108</span>:  add r0.y, r0.w, -cb12[<span class="hljs-number">48</span>].y  
  <span class="hljs-number">109</span>:  mul_sat r0.y, r0.y, cb12[<span class="hljs-number">48</span>].z  
  <span class="hljs-number">110</span>: <span class="hljs-keyword">else</span>  
  <span class="hljs-number">111</span>:  mov r0.xy, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">112</span>: endif  
  <span class="hljs-number">113</span>: <span class="hljs-built_in">log</span> r0.x, r0.x  
  <span class="hljs-number">114</span>: mul r0.z, r0.x, cb12[<span class="hljs-number">42</span>].w  
  <span class="hljs-number">115</span>: <span class="hljs-built_in">exp</span> r0.z, r0.z  
  <span class="hljs-number">116</span>: mul r0.z, r0.z, r0.y  
  <span class="hljs-number">117</span>: mul r0.x, r0.x, cb12[<span class="hljs-number">48</span>].x  
  <span class="hljs-number">118</span>: <span class="hljs-built_in">exp</span> r0.x, r0.x  
  <span class="hljs-number">119</span>: mul o0.w, r0.x, r0.y  
  <span class="hljs-number">120</span>: mad_sat r0.xy, r0.zzzz, cb12[<span class="hljs-number">189</span>].xzxx, cb12[<span class="hljs-number">189</span>].ywyy  
  <span class="hljs-number">121</span>: add r2.xyz, -r1.yzwy, cb12[<span class="hljs-number">188</span>].xyzx  
  <span class="hljs-number">122</span>: mad r2.xyz, r0.xxxx, r2.xyzx, r1.yzwy  
  <span class="hljs-number">123</span>: add r0.x, cb12[<span class="hljs-number">188</span>].w, l(<span class="hljs-number">-1.000000</span>)  
  <span class="hljs-number">124</span>: mad r0.x, r0.y, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">125</span>: mul_sat r2.w, r0.x, r0.z  
  <span class="hljs-number">126</span>: lt r0.x, l(<span class="hljs-number">0</span>), cb12[<span class="hljs-number">192</span>].x  
  <span class="hljs-number">127</span>: if_nz r0.x  
  <span class="hljs-number">128</span>:  mad_sat r0.xy, r0.zzzz, cb12[<span class="hljs-number">191</span>].xzxx, cb12[<span class="hljs-number">191</span>].ywyy  
  <span class="hljs-number">129</span>:  add r3.xyz, -r1.yzwy, cb12[<span class="hljs-number">190</span>].xyzx  
  <span class="hljs-number">130</span>:  mad r1.xyz, r0.xxxx, r3.xyzx, r1.yzwy  
  <span class="hljs-number">131</span>:  add r0.x, cb12[<span class="hljs-number">190</span>].w, l(<span class="hljs-number">-1.000000</span>)  
  <span class="hljs-number">132</span>:  mad r0.x, r0.y, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">133</span>:  mul_sat r1.w, r0.x, r0.z  
  <span class="hljs-number">134</span>:  add r0.xyzw, -r2.xyzw, r1.xyzw  
  <span class="hljs-number">135</span>:  mad o1.xyzw, cb12[<span class="hljs-number">192</span>].xxxx, r0.xyzw, r2.xyzw  
  <span class="hljs-number">136</span>: <span class="hljs-keyword">else</span>  
  <span class="hljs-number">137</span>:  mov o1.xyzw, r2.xyzw  
  <span class="hljs-number">138</span>: endif  
  <span class="hljs-number">139</span>: mov o3.xyzw, v1.xyzw  
  <span class="hljs-number">140</span>: mov o2.xy, v4.yxyy  
  <span class="hljs-number">141</span>: ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui, o cálculo da neblina pode atrair imediatamente atenção (linhas 30-138). O cálculo do topo da neblina faz sentido por razões de desempenho. Além disso, não precisamos de tanta precisão de neblina - os meteoróides geralmente voam sobre a cabeça de Geralt e não alcançam o horizonte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os parâmetros atmosféricos (rgb = cor, a = influência) são armazenados em o0.xyzw e os parâmetros de nevoeiro em o1.xyzw. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o2.xy (linha 140) é apenas texcoords. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o3.xyzw (linha 139) é irrelevante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos dizer algumas palavras sobre o cálculo de uma posição no mundo. Os shaders de vértice executam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outdoors</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Primeiro de tudo, os dados recebidos para outdoors vêm do buffer de vértice - vamos dar uma olhada neles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os primeiros dados são Posição:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99a/470/7d5/99a4707d5f914222e7d55e2435f5692f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como mencionado acima, aqui temos 2 quad-a: 8 vértices, 12 índices. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas por que a posição é a mesma para cada quadrante? </font><font style="vertical-align: inherit;">Muito simples - esta é a posição do centro do quad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, cada vértice tem um deslocamento do centro para a borda do quad:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cde/fdf/7e0/cdefdf7e0e5cfe91c4b9d20257b529b4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso significa que toda estrela cadente tem um tamanho de (400, 3) unidades no espaço do mundo. </font><font style="vertical-align: inherit;">(no plano XY, no Witcher 3, o eixo Z é direcionado para cima) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O último elemento que cada vértice possui é um vetor de direção unitária no espaço do mundo que controla o movimento de uma estrela cadente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/416/06d/71a/41606d71a99d2f751f8b1d5a609b6c96.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como os dados vêm da CPU, é difícil entender como são calculados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos para o código de outdoor. </font><font style="vertical-align: inherit;">A idéia é bastante simples - primeiro você obtém um vetor de unidade do centro do quad para a câmera:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">7</span>: add r2.xyz, -r1.zxyz, cb1[<span class="hljs-number">8</span>].zxyz  
   <span class="hljs-number">8</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
   <span class="hljs-number">9</span>: rsq r0.z, r0.z  
  <span class="hljs-number">10</span>: mul r2.xyz, r0.zzzz, r2.xyzx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então temos um único vetor tangente que controla o movimento da estrela cadente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que esse vetor já está normalizado no lado da CPU, essa normalização é redundante.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">11</span>: dp3 r0.z, v5.xyzx, v5.xyzx  
  <span class="hljs-number">12</span>: rsq r0.z, r0.z  
  <span class="hljs-number">13</span>: mul r3.xyz, r0.zzzz, v5.xyzx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se houver dois vetores, um produto vetorial será usado para determinar o vetor bi-tangente perpendicular aos dois vetores recebidos.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">14</span>: mul r4.xyz, r2.xyzx, r3.yzxy  
  <span class="hljs-number">15</span>: mad r2.xyz, r2.zxyz, r3.zxyz, -r4.xyzx  
  <span class="hljs-number">16</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
  <span class="hljs-number">17</span>: rsq r0.z, r0.z  
  <span class="hljs-number">18</span>: mul r2.xyz, r0.zzzz, r2.xyzx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, temos vetores normalizados </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tangente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (r3.xyz) e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bitangente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (r2.xyz). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos introduzir </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xsize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ysize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correspondentes ao elemento recebido TEXCOORD1, por exemplo (-200, 1,50). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O cálculo final da posição no espaço mundial é realizado da seguinte forma:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">19</span>: mad r0.z, v7.x, v6.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">20</span>: mul r3.xyz, r0.zzzz, r3.xyzx  
  <span class="hljs-number">21</span>: mul r3.xyz, r3.xyzx, v3.xxxx  
  <span class="hljs-number">22</span>: mul r2.xyz, r2.xyzx, v3.yyyy  
  <span class="hljs-number">23</span>: mad r0.xzw, r3.xxyz, r0.xxxx, r1.xxyz  
  <span class="hljs-number">24</span>: mad r0.xyz, r2.xyzx, r0.yyyy, r0.xzwx  
  <span class="hljs-number">25</span>: mov r0.w, l(<span class="hljs-number">1.000000</span>) </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que r0.x, r0.y e r0.z são iguais a 1,0, o cálculo final é simplificado: </font></font><br>
<br>
<code>worldSpacePosition = quadCenter + tangent * Xsize + bitangent * Ysize</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A última parte é uma multiplicação simples de uma posição no espaço do mundo por uma matriz de visão de projeção para obter SV_Position:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">26</span>: dp4 o4.x, r0.xyzw, cb1[<span class="hljs-number">0</span>].xyzw  
  <span class="hljs-number">27</span>: dp4 o4.y, r0.xyzw, cb1[<span class="hljs-number">1</span>].xyzw  
  <span class="hljs-number">28</span>: dp4 o4.z, r0.xyzw, cb1[<span class="hljs-number">2</span>].xyzw  
  <span class="hljs-number">29</span>: dp4 o4.w, r0.xyzw, cb1[<span class="hljs-number">3</span>].xyzw  </code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Pixel Shader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conforme declarado na seção Visão geral, o seguinte estado de mesclagem é usado: </font><font style="vertical-align: inherit;">
onde </font><i><font style="vertical-align: inherit;">SrcColor</font></i><font style="vertical-align: inherit;"> e </font><i><font style="vertical-align: inherit;">SrcAlpha</font></i><font style="vertical-align: inherit;"> são os componentes .rgb e .a do pixel shader, </font><i><font style="vertical-align: inherit;">respectivamente</font></i><font style="vertical-align: inherit;"> , e </font><i><font style="vertical-align: inherit;">DestColor é a</font></i><font style="vertical-align: inherit;"> cor </font><i><font style="vertical-align: inherit;">.rgb</font></i><font style="vertical-align: inherit;"> atualmente no rendertarget. </font><font style="vertical-align: inherit;">
O principal indicador que controla a transparência é o </font><i><font style="vertical-align: inherit;">SrcAlpha</font></i><font style="vertical-align: inherit;"> . Muitos shaders proativos de jogos o calculam como opacidade e o aplicam no final da seguinte maneira: O </font><font style="vertical-align: inherit;">
shader de estrela cadente não foi exceção. Seguindo esse padrão, consideramos três casos em que a </font><i><font style="vertical-align: inherit;">opacidade</font></i><font style="vertical-align: inherit;"> é 1,0, 0,1 e 0,0.</font></font><br>
<br>
<code>FinalColor = SrcColor * One + DestColor * (1.0 - SrcAlpha) =<br>
FinalColor = SrcColor + DestColor * (1.0 - SrcAlpha)</code><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<code>return float4( color * opacity, opacity )</code><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<code>a) opacity = 1.0<br>
<br>
FinalColor = color * opacity + DestColor * (1.0 - opacity) =<br>
FinalColor = color = SrcColor</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/934/711/31c/93471131c99ec7b2249cff6edb698859.jpg"></div><br>
<code>b) opacity = 0.1<br>
<br>
FinalColor = color * opacity + DestColor * (1.0 - opacity) =<br>
FinalColor = 0.1 * color + 0.9 * DestColor</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/269/b24/d90/269b24d90592abb5065fba0f2a0aaf9f.jpg"></div><br>
<code>c) opacity = 0.0<br>
<br>
FinalColor = color * opacity + DestColor * (1.0 - opacity) =<br>
FinalColor = DestColor</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/191/75e/b6e/19175eb6e6757c04a0a063e75bad96f2.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A idéia subjacente desse sombreador é modelar e usar a função de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacidade opacidade (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que controla a opacidade de um pixel ao longo de uma estrela cadente. O principal requisito é que a opacidade atinja os valores máximos no final da estrela (seu “corpo”) e desbote suavemente para 0,0 (em sua “cauda”). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando começamos a entender o código do assembler do pixel shader, isso se torna óbvio:</font></font><br>
<br>
<pre><code class="cpp hljs"> ps_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb0[<span class="hljs-number">10</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb2[<span class="hljs-number">3</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb4[<span class="hljs-number">2</span>], immediateIndexed  <font></font>
    dcl_input_ps linear v0.xyzw  <font></font>
    dcl_input_ps linear v1.xyzw  <font></font>
    dcl_input_ps linear v2.y  <font></font>
    dcl_input_ps linear v3.w  <font></font>
    dcl_output o0.xyzw  <font></font>
    dcl_temps <span class="hljs-number">4</span>  
   <span class="hljs-number">0</span>: mov_sat r0.x, v2.y  
   <span class="hljs-number">1</span>: ge r0.y, r0.x, l(<span class="hljs-number">0.052579</span>)  
   <span class="hljs-number">2</span>: ge r0.z, l(<span class="hljs-number">0.965679</span>), r0.x  
   <span class="hljs-number">3</span>: <span class="hljs-keyword">and</span> r0.y, r0.z, r0.y  
   <span class="hljs-number">4</span>: if_nz r0.y  
   <span class="hljs-number">5</span>:  ge r0.y, l(<span class="hljs-number">0.878136</span>), r0.x  
   <span class="hljs-number">6</span>:  add r0.z, r0.x, l(<span class="hljs-number">-0.052579</span>)  
   <span class="hljs-number">7</span>:  mul r1.w, r0.z, l(<span class="hljs-number">1.211303</span>)  
   <span class="hljs-number">8</span>:  mov_sat r0.z, r1.w  
   <span class="hljs-number">9</span>:  mad r0.w, r0.z, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">10</span>:  mul r0.z, r0.z, r0.z  
  <span class="hljs-number">11</span>:  mul r0.z, r0.z, r0.w  
  <span class="hljs-number">12</span>:  mul r2.x, r0.z, l(<span class="hljs-number">0.084642</span>)  
  <span class="hljs-number">13</span>:  mov r1.yz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.084642</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">14</span>:  movc r2.yzw, r0.yyyy, r1.yyzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.500000</span>)  
  <span class="hljs-number">15</span>:  <span class="hljs-keyword">not</span> r0.z, r0.y  
  <span class="hljs-number">16</span>:  if_z r0.y  
  <span class="hljs-number">17</span>:   ge r0.y, l(<span class="hljs-number">0.924339</span>), r0.x  
  <span class="hljs-number">18</span>:   add r0.w, r0.x, l(<span class="hljs-number">-0.878136</span>)  
  <span class="hljs-number">19</span>:   mul r1.w, r0.w, l(<span class="hljs-number">21.643608</span>)  
  <span class="hljs-number">20</span>:   mov_sat r0.w, r1.w  
  <span class="hljs-number">21</span>:   mad r3.x, r0.w, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">22</span>:   mul r0.w, r0.w, r0.w  
  <span class="hljs-number">23</span>:   mul r0.w, r0.w, r3.x  
  <span class="hljs-number">24</span>:   mad r1.x, r0.w, l(<span class="hljs-number">0.889658</span>), l(<span class="hljs-number">0.084642</span>)  
  <span class="hljs-number">25</span>:   mov r1.yz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.084642</span>, <span class="hljs-number">0.974300</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">26</span>:   movc r2.xyzw, r0.yyyy, r1.xyzw, r2.xyzw  
  <span class="hljs-number">27</span>:  <span class="hljs-keyword">else</span>  
  <span class="hljs-number">28</span>:   mov r2.y, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">29</span>:   mov r0.y, l(<span class="hljs-number">-1</span>)  
  <span class="hljs-number">30</span>:  endif  
  <span class="hljs-number">31</span>:  <span class="hljs-keyword">not</span> r0.w, r0.y  
  <span class="hljs-number">32</span>:  <span class="hljs-keyword">and</span> r0.z, r0.w, r0.z  
  <span class="hljs-number">33</span>:  if_nz r0.z  
  <span class="hljs-number">34</span>:   ge r0.y, r0.x, l(<span class="hljs-number">0.924339</span>)  
  <span class="hljs-number">35</span>:   add r0.x, r0.x, l(<span class="hljs-number">-0.924339</span>)  
  <span class="hljs-number">36</span>:   mul r1.w, r0.x, l(<span class="hljs-number">24.189651</span>)  
  <span class="hljs-number">37</span>:   mov_sat r0.x, r1.w  
  <span class="hljs-number">38</span>:   mad r0.z, r0.x, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">39</span>:   mul r0.x, r0.x, r0.x  
  <span class="hljs-number">40</span>:   mul r0.x, r0.x, r0.z  
  <span class="hljs-number">41</span>:   mad r1.x, r0.x, l(<span class="hljs-number">-0.974300</span>), l(<span class="hljs-number">0.974300</span>)  
  <span class="hljs-number">42</span>:   mov r1.yz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.974300</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">43</span>:   movc r2.xyzw, r0.yyyy, r1.xyzw, r2.xyzw  
  <span class="hljs-number">44</span>:  endif  
  <span class="hljs-number">45</span>: <span class="hljs-keyword">else</span>  
  <span class="hljs-number">46</span>:  mov r2.yzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.500000</span>)  
  <span class="hljs-number">47</span>:  mov r0.y, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">48</span>: endif  
  <span class="hljs-number">49</span>: mov_sat r2.w, r2.w  
  <span class="hljs-number">50</span>: mad r0.x, r2.w, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">51</span>: mul r0.z, r2.w, r2.w  
  <span class="hljs-number">52</span>: mul r0.x, r0.z, r0.x  
  <span class="hljs-number">53</span>: add r0.z, -r2.y, r2.z  
  <span class="hljs-number">54</span>: mad r0.x, r0.x, r0.z, r2.y  
  <span class="hljs-number">55</span>: movc r0.x, r0.y, r2.x, r0.x  
  <span class="hljs-number">56</span>: mad r0.y, cb4[<span class="hljs-number">1</span>].x, -cb0[<span class="hljs-number">9</span>].w, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">57</span>: mul_sat r0.y, r0.y, v3.w  
  <span class="hljs-number">58</span>: mul r0.x, r0.y, r0.x  
  <span class="hljs-number">59</span>: mul r0.yzw, cb2[<span class="hljs-number">2</span>].xxyz, cb4[<span class="hljs-number">0</span>].xxxx  
  <span class="hljs-number">60</span>: mul r0.x, r0.x, cb2[<span class="hljs-number">2</span>].w  
  <span class="hljs-number">61</span>: dp3 r1.x, l(<span class="hljs-number">0.333000</span>, <span class="hljs-number">0.555000</span>, <span class="hljs-number">0.222000</span>, <span class="hljs-number">0.000000</span>), r0.yzwy  
  <span class="hljs-number">62</span>: mad r1.xyz, r1.xxxx, v0.xyzx, -r0.yzwy  
  <span class="hljs-number">63</span>: mad r0.yzw, v0.wwww, r1.xxyz, r0.yyzw  
  <span class="hljs-number">64</span>: add r1.xyz, -r0.yzwy, v1.xyzx  
  <span class="hljs-number">65</span>: mad r0.yzw, v1.wwww, r1.xxyz, r0.yyzw  
  <span class="hljs-number">66</span>: mul o0.xyz, r0.xxxx, r0.yzwy  
  <span class="hljs-number">67</span>: mov o0.w, r0.x  
  <span class="hljs-number">68</span>: ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, o shader é um pouco complicado demais e era difícil para mim descobrir o que estava acontecendo nele. </font><font style="vertical-align: inherit;">Por exemplo, de onde vieram todos os valores como 1.211303, 21.643608 e 24.189651? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se estamos falando sobre a função de opacidade, precisamos de um valor de entrada. </font><font style="vertical-align: inherit;">Com isso, é bem simples - o texcoord no intervalo de [0,1] (linha 0) será útil aqui, para que possamos aplicar a função a todo o comprimento do meteoróide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A função opacidade possui três segmentos / intervalos definidos por quatro pontos de controle:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// current status: no idea how these are generated  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint0 = <span class="hljs-number">0.052579</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint1 = <span class="hljs-number">0.878136</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint2 = <span class="hljs-number">0.924339</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint3 = <span class="hljs-number">0.965679</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não faço ideia de como eles foram selecionados / calculados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como podemos ver no código do assembler, a primeira condição é apenas verificar se o valor de entrada está no intervalo [controlPoint0 - controlPoint3]. </font><font style="vertical-align: inherit;">Caso contrário, a opacidade é de apenas 0,0.</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Input for the opacity function</span>
   <span class="hljs-keyword">float</span> y = saturate(Input.Texcoords.y);  <span class="hljs-comment">// r0.x</span><font></font>
     <font></font>
   <span class="hljs-comment">// Value of opacity function.  </span>
   <span class="hljs-comment">// 0 - no change  </span>
   <span class="hljs-comment">// 1 - full color  </span>
   <span class="hljs-keyword">float</span> opacity = <span class="hljs-number">0.0</span>;  <font></font>
     <font></font>
   [branch]   <font></font>
   <span class="hljs-keyword">if</span> (y &gt;= controlPoint0 &amp;&amp; y &lt;= controlPoint3)  <font></font>
   {  <font></font>
      ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A descriptografia do código do assembler abaixo é </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necessária</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se quisermos entender como a função de opacidade funciona:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">6</span>: add r0.z, r0.x, l(<span class="hljs-number">-0.052579</span>)   
   <span class="hljs-number">7</span>: mul r1.w, r0.z, l(<span class="hljs-number">1.211303</span>)   
   <span class="hljs-number">8</span>: mov_sat r0.z, r1.w   
   <span class="hljs-number">9</span>: mad r0.w, r0.z, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)   
  <span class="hljs-number">10</span>: mul r0.z, r0.z, r0.z   
  <span class="hljs-number">11</span>: mul r0.z, r0.z, r0.w   
  <span class="hljs-number">12</span>: mul r2.x, r0.z, l(<span class="hljs-number">0.084642</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A linha 9 possui os coeficientes '-2.0' e '3.0', que sugerem o uso da função </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smoothstep</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sim, este é um bom palpite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A função HLSL smoothstep com o protótipo: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ret smoothstep (min, max, x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sempre limita </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min-max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]. Do ponto de vista do montador, isso subtrai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do valor de entrada (ou seja, de r0.z na linha 9), mas não há nada parecido no código. Para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> isso implica uma multiplicação do valor de entrada, mas não há nada como 'mul_sat' no código. Em vez disso, existe 'mov_sat'. Isso nos diz que as </font><font style="vertical-align: inherit;">funções </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mín</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">máx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do passo suave são 0 e 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora sabemos que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve estar no intervalo [0, 1]. Como mencionado acima, existem três segmentos na função de opacidade. Isso indica claramente que o código está procurando onde estamos no intervalo [segmentStart-segmentEnd]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A resposta é a função Linstep!</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">linstep</span><span class="hljs-params">(<span class="hljs-keyword">float</span> min, <span class="hljs-keyword">float</span> max, <span class="hljs-keyword">float</span> v)</span>  
 </span>{  
   <span class="hljs-keyword">return</span> ( (v-min) / (max-min) );  <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, vamos pegar o primeiro segmento: [0,052579 - 0,878136]. </font><font style="vertical-align: inherit;">A subtração está na linha 6. Se substituirmos a divisão pela multiplicação -&gt; 1,0 / (0,878136 - 0,052579) = 1,0 / 0,825557 = ~ 1,211303. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O resultado do passo suave está no intervalo [0, 1]. </font><font style="vertical-align: inherit;">A multiplicação na linha 12 é o peso do segmento. </font><font style="vertical-align: inherit;">Cada segmento tem seu próprio peso, permitindo controlar a opacidade máxima desse segmento específico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso significa que, para o primeiro segmento [0,052579 - 0,878136], a opacidade está no intervalo [0 - 0,084642]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma função HLSL que calcula a opacidade para um segmento arbitrário pode ser escrita da seguinte maneira:</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">getOpacityFunctionValue</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> cpLeft, <span class="hljs-keyword">float</span> cpRight, <span class="hljs-keyword">float</span> weight)</span>  
 </span>{  
   <span class="hljs-keyword">float</span> val = smoothstep( <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, linstep(cpLeft, cpRight, x) );  
   <span class="hljs-keyword">return</span> val * weight;  <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, o ponto principal é simplesmente chamar essa função para o segmento correspondente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dê uma olhada nos pesos:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> weight0 = <span class="hljs-number">0.084642</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> weight1 = <span class="hljs-number">0.889658</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> weight2 = <span class="hljs-number">0.974300</span>; <span class="hljs-comment">// note: weight0+weight1 = weight2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acordo com o código do assembler, a função </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacidade (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é </font><font style="vertical-align: inherit;">calculada da seguinte maneira:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">float</span> opacity = <span class="hljs-number">0.0</span>;<font></font>
<font></font>
   [branch]   <font></font>
   <span class="hljs-keyword">if</span> (y &gt;= controlPoint0 &amp;&amp; y &lt;= controlPoint3)  <font></font>
   {  <font></font>
     <span class="hljs-comment">// Range of v: [0, weight0]  </span>
     <span class="hljs-keyword">float</span> v = getOpacityFunctionValue(y, controlPoint0, controlPoint1, weight0);  <font></font>
     opacity = v;  <font></font>
     <font></font>
     [branch]  <font></font>
     <span class="hljs-keyword">if</span> ( y &gt;= controlPoint1 )  <font></font>
     {  <font></font>
       <span class="hljs-comment">// Range of v: [0, weight1]  </span>
       <span class="hljs-keyword">float</span> v = getOpacityFunctionValue(y, controlPoint1, controlPoint2, weight1);  <font></font>
       opacity = weight0 + v;  <font></font>
   <font></font>
       [branch]  <font></font>
       <span class="hljs-keyword">if</span> (y &gt;= controlPoint2)  <font></font>
       {  <font></font>
         <span class="hljs-comment">// Range of v: [0, weight2]  </span>
         <span class="hljs-keyword">float</span> v = getOpacityFunctionValue(y, controlPoint2, controlPoint3, weight2);<font></font>
         opacity = weight2 - v;          <font></font>
       }  <font></font>
     }  <font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está um gráfico da função de opacidade. </font><font style="vertical-align: inherit;">Você pode ver facilmente um aumento acentuado da opacidade, indicando o início do corpo de uma estrela cadente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/326/1f0/5da3261f0f88fa41ac963ca84fc79f99.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Função de opacidade do gráfico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Canal vermelho - valor de opacidade </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Canal verde - pontos de controle </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Canal azul - pesos</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Após calcular a opacidade, tudo o resto são apenas os retoques finais. </font><font style="vertical-align: inherit;">Depois, há multiplicações adicionais: a opacidade das estrelas, a cor da estrela cadente e a influência do nevoeiro. </font><font style="vertical-align: inherit;">Como de costume nos shaders TW3, você também pode encontrar multiplicações redundantes por 1,0 aqui:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// cb4_v1.x = 1.0  </span>
   <span class="hljs-keyword">float</span> starsOpacity = <span class="hljs-number">1.0</span> - cb0_v9.w * cb4_v1.x;    <font></font>
   opacity *= starsOpacity;  <font></font>
<font></font>
   <span class="hljs-comment">// Calculate color of a shooting star  </span>
   <span class="hljs-comment">// cb4_v0.x = 10.0</span>
   <span class="hljs-comment">// cb2_v2.rgb = (1.0, 1.0, 1.0)</span><font></font>
   float3 color = cb2_v2.rgb * cb4_v0.x;<font></font>
     <font></font>
   <span class="hljs-comment">// cb2_v2.w = 1  </span><font></font>
   opacity *= cb2_v2.w;<font></font>
     <font></font>
   FogResult fr = { Input.FogParams, Input.AerialParams };  <font></font>
   color = ApplyFog(fr, color);<font></font>
     <font></font>
   <span class="hljs-keyword">return</span> float4( color*opacity, opacity);  <font></font>
 }</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Resumo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A principal dificuldade está na parte com a função de opacidade. Depois de decodificá-lo, tudo o resto é bastante simples de entender. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu disse acima que o pixel shader é um pouco complicado demais. De fato, nos preocupamos apenas com o valor da função </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacidade (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que é armazenada em r2.x (começando na linha 49). No entanto, a função de opacidade no código do assembler cria mais três variáveis ​​adicionais: minRange (r2.y), maxRange (r2.z) e valor (r2.w). Todos eles são parâmetros usados ​​para calcular a opacidade quando a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacidade (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não </font><i><font style="vertical-align: inherit;">é</font></i><font style="vertical-align: inherit;"> usada: </font></font><br>
<br>
<code>lerp( minRange, maxRange, smoothstep(0, 1, value) );</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, o valor final da opacidade é obtido no ramo condicional na linha 55 - se o valor de entrada for </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">está no intervalo [controlPoint0 - controlPoint3], isso significa que a função de opacidade é usada e, portanto, r2.x é selecionado. </font><font style="vertical-align: inherit;">Caso contrário, quando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estiver fora do intervalo, a opacidade é calculada a partir de r0.x, ou seja, de acordo com a equação acima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu depurei alguns pixels fora do intervalo [controlPoint0 - controlPoint3], e a opacidade final sempre era zero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é tudo por hoje. </font><font style="vertical-align: inherit;">E, como sempre, obrigado pela leitura.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt489092/index.html">Como aprendi independentemente um novo idioma em 12 meses: um guia total</a></li>
<li><a href="../pt489100/index.html">Análise de dados de coronavírus SARS-CoV-2 (2019-nCov)</a></li>
<li><a href="../pt489102/index.html">Vida na tela falsa. "Sim, eu pessoalmente conheço Madonna"</a></li>
<li><a href="../pt489106/index.html">Como abandonei o jornalismo e me tornei programador</a></li>
<li><a href="../pt489108/index.html">Adicionando seus campos a um relatório Pytest</a></li>
<li><a href="../pt489122/index.html">Consultas OData digitadas no TypeScript</a></li>
<li><a href="../pt489128/index.html">Internacionalização: como levar o produto ao mercado internacional (e não enlouquecer)</a></li>
<li><a href="../pt489132/index.html">Destaques do Integrated Systems Europe 2020</a></li>
<li><a href="../pt489134/index.html">Pesquisa de equipes de design em empresas de alimentos russas</a></li>
<li><a href="../pt489136/index.html">Ganhando com vinte linhas Haskell: escrevendo seu Wc</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>