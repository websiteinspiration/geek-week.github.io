<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎟️ 👦🏾 👰🏼 La puissance de PWA: un système de vidéosurveillance avec un code JS de réseau neuronal de 300 lignes 🍞 👨🏾 📆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 
 
 Les navigateurs Web implémentent lentement mais sûrement la plupart des fonctionnalités du système d'exploitation, et il y a de moi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>La puissance de PWA: un système de vidéosurveillance avec un code JS de réseau neuronal de 300 lignes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492006/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les navigateurs Web </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implémentent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lentement mais sûrement la </font><font style="vertical-align: inherit;">plupart des fonctionnalités du système d'exploitation, et il y a de moins en moins de raisons de développer une application native si vous pouvez écrire une version Web (PWA). Multiplateforme, API riche, vitesse de développement élevée sur TS / JS et même les performances du moteur V8 - tout cela est un plus. Les navigateurs peuvent depuis longtemps travailler avec un flux vidéo et exécuter des réseaux de neurones, c'est-à-dire que nous avons tous les composants pour créer un système de vidéosurveillance avec reconnaissance d'objets. Inspiré par cet </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , j'ai décidé d'amener la démo au niveau d'application pratique, que je souhaite partager. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'application enregistre la vidéo de la caméra, envoyant périodiquement des images pour reconnaissance dans le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COCO-SSD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et si une personne est détectée, des fragments vidéo en portions de 7 secondes commencent à être envoyés à l'e-mail spécifié via l'API Gmail. Comme dans les systèmes pour adultes, le préenregistrement est effectué, c'est-à-dire que nous enregistrons un fragment jusqu'au moment de la détection, tous les fragments avec détection et un après. Si Internet n'est pas disponible ou qu'une erreur se produit lors de l'envoi, les vidéos sont enregistrées dans le dossier Téléchargements local. L'utilisation de l'e-mail vous permet de vous passer du côté serveur, d'informer instantanément le propriétaire et si un attaquant a pris possession de l'appareil et déchiffré tous les mots de passe, il ne pourra pas supprimer le courrier du destinataire. Parmi les inconvénients: le trafic dépassé en raison de Base64 (bien que cela soit suffisant pour une caméra) et la nécessité de collecter le fichier vidéo final à partir de nombreux e-mails. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La démo de travail est ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les problèmes rencontrés sont les suivants:</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) Le réseau neuronal charge fortement le processeur et si vous l'exécutez dans le thread principal, des décalages apparaissent sur les vidéos. Par conséquent, la reconnaissance est placée dans un fil distinct (travailleur), bien que tout ne soit pas fluide ici. Sur Linux préhistorique dual-core, tout est parfaitement parallèle, mais sur certains téléphones mobiles 4-core assez récents - au moment de la reconnaissance (chez le travailleur), le thread principal commence également à être en retard, ce qui est perceptible dans l'interface utilisateur. Heureusement, cela n'affecte pas la qualité de la vidéo, même si cela réduit la fréquence de reconnaissance (il s'adapte automatiquement à la charge). Ce problème est probablement lié à la façon dont les différentes versions d'Android distribuent les threads par cœur, à la présence de SIMD, aux fonctions de carte vidéo disponibles, etc. Je ne peux pas le découvrir par moi-même, je ne connais pas l'intérieur de TensorFlow, et je serai reconnaissant pour l'information.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) FireFox. </font><font style="vertical-align: inherit;">L'application fonctionne bien sous Chrome / Chrome / Edge, cependant, la reconnaissance dans FireFox est sensiblement plus lente, en outre, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImageCapture</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'est toujours pas implémenté </font><font style="vertical-align: inherit;">(bien sûr, cela peut être contourné en capturant un cadre à partir de &lt;video&gt;, mais c'est une honte pour le renard, car il est standard API). </font><font style="vertical-align: inherit;">En général, il n'y avait pas non plus d'accessibilité complète entre les navigateurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, tout est en ordre.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenir une caméra et un microphone</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.video = <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'video'</span>)
<span class="hljs-keyword">this</span>.canvas = <span class="hljs-keyword">this</span>.querySelectorAll(<span class="hljs-string">'canvas'</span>)[<span class="hljs-number">0</span>]<font></font>
<font></font>
<span class="hljs-keyword">this</span>.stream = <span class="hljs-keyword">await</span> navigator.mediaDevices.getUserMedia(<font></font>
   {<span class="hljs-attr">video</span>: {<span class="hljs-attr">facingMode</span>: {<span class="hljs-attr">ideal</span>: <span class="hljs-string">"environment"</span>}}, <span class="hljs-attr">audio</span>: <span class="hljs-literal">true</span>}<font></font>
)<font></font>
<span class="hljs-keyword">this</span>.video.srcObject = <span class="hljs-keyword">this</span>.stream
<span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
   <span class="hljs-keyword">this</span>.video.onloadedmetadata = <span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> resolve()<font></font>
})<font></font>
<span class="hljs-keyword">this</span>.W = <span class="hljs-keyword">this</span>.bbox.width = <span class="hljs-keyword">this</span>.canvas.width = <span class="hljs-keyword">this</span>.video.videoWidth
<span class="hljs-keyword">this</span>.H = <span class="hljs-keyword">this</span>.bbox.height = <span class="hljs-keyword">this</span>.canvas.height = <span class="hljs-keyword">this</span>.video.videoHeight
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous sélectionnons la caméra principale du téléphone mobile / tablette (ou la première sur l'ordinateur / ordinateur portable), affichons le flux dans un lecteur vidéo standard, après quoi nous attendons le chargement des métadonnées et définissons les dimensions du canevas de service. </font><font style="vertical-align: inherit;">Étant donné que l'application entière est écrite dans le style asynchrone / wait, vous devez convertir les API de rappel (et il y en a beaucoup) en Promise pour l'uniformité.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capture vidéo</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe deux façons de capturer une vidéo. </font><font style="vertical-align: inherit;">La première consiste à lire directement les images du flux entrant, à les afficher sur le canevas, à les modifier (par exemple, ajouter des zones géographiques et des horodatages), puis à prendre les données du canevas - pour l'enregistreur en tant que flux sortant et pour un réseau de neurones en tant qu'images distinctes. </font><font style="vertical-align: inherit;">Dans ce cas, vous pouvez vous passer de l'élément &lt;video&gt;.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.capture = <span class="hljs-keyword">new</span> ImageCapture(<span class="hljs-keyword">this</span>.stream.getVideoTracks()[<span class="hljs-number">0</span>])
<span class="hljs-keyword">this</span>.recorder = <span class="hljs-keyword">new</span> MediaRecorder(<span class="hljs-keyword">this</span>.canvas.captureStream(), {<span class="hljs-attr">mimeType</span> : <span class="hljs-string">"video/webm"</span>})<font></font>
<font></font>
grab_video()<font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grab_video</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">this</span>.canvas.drawImage(<span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.capture.grabFrame(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">const</span> img = <span class="hljs-keyword">this</span>.canvas.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.W, <span class="hljs-keyword">this</span>.H)<font></font>
	... <span class="hljs-comment">//    -   img</span>
	... <span class="hljs-comment">//   -    </span>
        <span class="hljs-built_in">window</span>.requestAnimationFrame(<span class="hljs-keyword">this</span>.grab_video.bind(<span class="hljs-keyword">this</span>))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La deuxième façon (en FF) consiste à utiliser un lecteur vidéo standard pour capturer. </font><font style="vertical-align: inherit;">Soit dit en passant, il consomme moins de temps processeur, contrairement à l'affichage image par image sur toile, mais nous ne pouvons pas ajouter d'inscription.</font></font><br>
<br>
<pre><code class="javascript hljs">...<font></font>
async <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grab_video</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">this</span>.canvas.drawImage(<span class="hljs-keyword">this</span>.video, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
	...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'application utilise la première option, ce qui permet d'éteindre le lecteur vidéo pendant le processus de reconnaissance. </font><font style="vertical-align: inherit;">Afin d'économiser le processeur, l'enregistrement est effectué à partir du flux entrant, et les trames de dessin sur toile sont utilisées uniquement pour obtenir un tableau de pixels pour le réseau neuronal, avec une fréquence dépendant de la vitesse de reconnaissance. </font><font style="vertical-align: inherit;">Nous dessinons le cadre autour de la personne sur une toile séparée placée sur le joueur.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chargement du réseau neuronal et détection humaine</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est indécemment simple. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous démarrons le travailleur</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , après avoir chargé le modèle (assez long), nous envoyons un message vide au thread principal, où dans l'événement onmessage nous montrons le bouton de démarrage, après quoi le travailleur est prêt à recevoir des images. </font><font style="vertical-align: inherit;">Code de travailleur complet:</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-keyword">async</span> () =&gt; {<font></font>
  self.importScripts(<span class="hljs-string">'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js'</span>)<font></font>
  self.importScripts(<span class="hljs-string">'https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd'</span>)<font></font>
<font></font>
  <span class="hljs-keyword">let</span> model = <span class="hljs-keyword">await</span> cocoSsd.load()<font></font>
  self.postMessage({})<font></font>
<font></font>
  self.onmessage = <span class="hljs-keyword">async</span> (ev) =&gt; {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> model.detect(ev.data)
    <span class="hljs-keyword">const</span> person = result.find(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.class === <span class="hljs-string">'person'</span>)
    <span class="hljs-keyword">if</span> (person) <font></font>
      self.postMessage({<span class="hljs-attr">ok</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bbox</span>: person.bbox})
    <span class="hljs-keyword">else</span>
      self.postMessage({<span class="hljs-attr">ok</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">bbox</span>: <span class="hljs-literal">null</span>})<font></font>
  }<font></font>
})()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le thread principal, nous </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">démarrons la fonction grab_video ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uniquement après avoir reçu le résultat précédent du travailleur, c'est-à-dire que la fréquence de détection dépendra de la charge du système.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enregistrement video</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.recorder.rec = <span class="hljs-keyword">new</span> MediaRecorder(<span class="hljs-keyword">this</span>.stream, {<span class="hljs-attr">mimeType</span> : <span class="hljs-string">"video/webm"</span>})
<span class="hljs-keyword">this</span>.recorder.rec.ondataavailable = <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> {
   <span class="hljs-keyword">this</span>.chunk = ev.data
   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.detected) {
      <span class="hljs-keyword">this</span>.send_chunk()<font></font>
   } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.recorder.num &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.send_chunk()
      <span class="hljs-keyword">this</span>.recorder.num--<font></font>
   }<font></font>
}<font></font>
...<font></font>
this.recorder.rec.start()<font></font>
<span class="hljs-keyword">this</span>.recorder.num = <span class="hljs-number">0</span>
<span class="hljs-keyword">this</span>.recorder.interval = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
   <span class="hljs-keyword">this</span>.recorder.rec.stop()
   <span class="hljs-keyword">this</span>.recorder.rec.start()<font></font>
}, CHUNK_DURATION)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À chaque arrêt de l'enregistreur (nous utilisons un intervalle fixe), l'événement ondataavailable est déclenché, où le fragment enregistré au format Blob est transféré, enregistré dans this.chunk et envoyé de manière asynchrone. Oui, this.send_chunk () renvoie une promesse, mais la fonction prend beaucoup de temps (encodage en Base64, envoi d'un e-mail ou enregistrement du fichier localement), et nous n'attendons pas qu'il soit exécuté et ne traitons pas le résultat - il n'y a donc pas d'attente. Même s'il s'avère que les nouveaux clips vidéo apparaissent plus souvent qu'ils ne peuvent être envoyés, le moteur JS organise la ligne de promesses de manière transparente pour le développeur, et tôt ou tard toutes les données seront envoyées / enregistrées. La seule chose à laquelle il faut faire attention est à l'intérieur de la fonction </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">send_chunk ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avant la première attente, vous devez cloner le Blob avec la méthode slice (), car le lien this.chunk est effacé toutes les CHUNK_DURATION secondes.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API Gmail</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilisé pour envoyer des lettres. </font><font style="vertical-align: inherit;">L'API est assez ancienne, en partie sur les promesses, en partie sur les rappels, la documentation et les exemples ne sont pas nombreux, donc je vais donner le code complet. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autorisation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">nous obtenons les clés d'application et de client dans la console développeur de Google. </font><font style="vertical-align: inherit;">Dans une fenêtre d'autorisation contextuelle, Google signale que l'application n'a pas été vérifiée, et vous devrez cliquer sur "paramètres avancés" pour entrer. </font><font style="vertical-align: inherit;">La vérification de l'application dans Google s'est avérée être une tâche non triviale, vous devez confirmer la propriété du domaine (que je n'ai pas), organiser correctement la page principale, j'ai donc décidé de ne pas déranger.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'https://apis.google.com/js/api.js'</span>)<font></font>
gapi.load(<span class="hljs-string">'client:auth2'</span>, <span class="hljs-keyword">async</span> () =&gt; {
   <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> gapi.client.init({
         <span class="hljs-attr">apiKey</span>: API_KEY,
         <span class="hljs-attr">clientId</span>: CLIENT_ID,
         <span class="hljs-attr">discoveryDocs</span>: [<span class="hljs-string">'https://www.googleapis.com/discovery/v1/apis/gmail/v1/rest'</span>],
         <span class="hljs-attr">scope</span>: <span class="hljs-string">'https://www.googleapis.com/auth/gmail.send'</span><font></font>
      }) <font></font>
      <span class="hljs-keyword">if</span> (!gapi.auth2.getAuthInstance().isSignedIn.je) {
         <span class="hljs-keyword">await</span> gapi.auth2.getAuthInstance().signIn()<font></font>
      }<font></font>
      <span class="hljs-keyword">this</span>.msg.innerHTML = <span class="hljs-string">''</span>
      <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'nav'</span>).style.display = <span class="hljs-string">''</span>
   } <span class="hljs-keyword">catch</span>(e) {
      <span class="hljs-keyword">this</span>.msg.innerHTML = <span class="hljs-string">'Gmail authorization error: '</span> + <span class="hljs-built_in">JSON</span>.stringify(e, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>)<font></font>
   }<font></font>
})<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Envoi d'email</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Les chaînes codées en Base64 ne peuvent pas être concaténées, ce qui n'est pas pratique. </font><font style="vertical-align: inherit;">Comment envoyer une vidéo au format binaire, je ne comprenais toujours pas. </font><font style="vertical-align: inherit;">Dans les dernières lignes, nous convertissons le rappel en promesse. </font><font style="vertical-align: inherit;">Malheureusement, cela doit être fait assez souvent.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> send_mail(subject, mime_type, body) {
   <span class="hljs-keyword">const</span> headers = {
      <span class="hljs-string">'From'</span>: <span class="hljs-string">''</span>,
      <span class="hljs-string">'To'</span>: <span class="hljs-keyword">this</span>.email,
      <span class="hljs-string">'Subject'</span>: <span class="hljs-string">'Balajahe CCTV: '</span> + subject,
      <span class="hljs-string">'Content-Type'</span>: mime_type,
      <span class="hljs-string">'Content-transfer-encoding'</span>: <span class="hljs-string">'base64'</span><font></font>
   }<font></font>
   <span class="hljs-keyword">let</span> head = <span class="hljs-string">''</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(headers)) head += k + <span class="hljs-string">': '</span> + v + <span class="hljs-string">'\r\n'</span>
   <span class="hljs-keyword">const</span> request = gapi.client.gmail.users.messages.send({
      <span class="hljs-string">'userId'</span>: <span class="hljs-string">'me'</span>,
      <span class="hljs-string">'resource'</span>: { <span class="hljs-string">'raw'</span>: btoa(head + <span class="hljs-string">'\r\n'</span> + body) }<font></font>
   })<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<font></font>
      request.execute(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
         <span class="hljs-keyword">if</span> (!res.code) <font></font>
            resolve() <font></font>
         <span class="hljs-keyword">else</span> <font></font>
            reject(res)<font></font>
      })<font></font>
   })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enregistrement d'un clip vidéo sur le disque. </font><font style="vertical-align: inherit;">Nous utilisons un hyperlien caché.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'a'</span>)<font></font>
URL.revokeObjectURL(a.href)<font></font>
a.href = URL.createObjectURL(chunk)<font></font>
a.download = name<font></font>
a.click()</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gestion des états dans le monde des composants web</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Poursuivant l'idée présentée dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cet article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , je l'ai amenée à l' </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">absurdité de la</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fin logique (pour le lulz uniquement) et </font><font style="vertical-align: inherit;">j'ai </font><font style="vertical-align: inherit;">bouleversé le contrôle de l'État. </font><font style="vertical-align: inherit;">Si généralement les variables JS sont considérées comme un état et que le DOM n'est que l'affichage actuel, dans mon cas, la source de données est le DOM lui-même (puisque les composants Web sont les nœuds DOM à longue durée de vie), et pour utiliser les données du côté JS, les composants Web fournissent des getters / setters pour chaque champ de formulaire. </font><font style="vertical-align: inherit;">Ainsi, par exemple, au lieu de cases à cocher inconfortables dans le style, de simples &lt;button&gt; sont utilisés, et la "valeur" du bouton (true est pressée, false est pressée) est la valeur de l'attribut class, ce qui vous permet de le styler comme ceci:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.true</span> {<span class="hljs-attribute">background-color</span>: red}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et obtenez la valeur comme ceci:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">get</span> <span class="hljs-title">detecting</span>() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'#detecting'</span>).className === <span class="hljs-string">'true'</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne peux pas conseiller d'utiliser cela en production, car c'est un bon moyen d'abandonner la productivité. </font><font style="vertical-align: inherit;">Bien que ... le DOM virtuel ne soit pas non plus gratuit, et je n'ai pas fait de benchmarks.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mode hors-ligne</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, ajoutez un petit PWA, à savoir, installez un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">service worker</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui mettra en cache toutes les requêtes réseau et permettra à l'application de fonctionner sans accès à Internet. </font><font style="vertical-align: inherit;">Une petite nuance - dans les articles sur les travailleurs des services, ils donnent généralement l'algorithme suivant:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'événement d'installation - créez une nouvelle version du cache et ajoutez toutes les ressources nécessaires au cache.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'événement activate - supprimez toutes les versions du cache à l'exception de la version actuelle.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'événement fetch - nous essayons d'abord de prendre la ressource du cache, et si nous ne l'avons pas trouvée, nous envoyons une requête réseau, dont le résultat est ajouté au cache.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En pratique, un tel schéma n'est pas pratique pour deux raisons. Premièrement, dans le code du travailleur, vous devez avoir une liste à jour de toutes les ressources nécessaires, et dans les grands projets utilisant des bibliothèques tierces, essayez de garder une trace de toutes les importations jointes (y compris les importations dynamiques). Le deuxième problème - lors de la modification d'un fichier, vous devez augmenter la version du service worker, ce qui entraînera l'installation d'un nouveau travailleur et l'invalidation du précédent, et cela se produira UNIQUEMENT lorsque le navigateur est fermé / ouvert. Un simple rafraîchissement de la page n'aidera pas - l'ancien travailleur avec l'ancien cache fonctionnera. Et où est la garantie que mes clients ne garderont pas l'onglet du navigateur pour toujours? Par conséquent, nous faisons d'abord une demande de réseau, nous ajoutons le résultat au cache de manière asynchrone (sans attendre la résolution d'autorisation cache.put (ev.request, resp.clone ())), et si le réseau n'est pas disponible, nous l'obtenons du cache. Mieux vaut perdre un jourpuis volez en 5 minutes ©.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les questions non résolues</font></font></h4><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sur certains téléphones mobiles, le réseau neuronal ralentit, peut-être que dans mon cas, le COCO-SSD n'est pas le meilleur choix, mais je ne suis pas un expert en ML, et j'ai pris le premier qui a été entendu.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je n'ai pas trouvé d'exemple sur la façon d'envoyer de la vidéo via GAPI non pas au format Base64, mais dans le binaire d'origine. </font><font style="vertical-align: inherit;">Cela permettrait d'économiser du temps processeur et du trafic réseau.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je ne comprenais pas la sécurité. </font><font style="vertical-align: inherit;">À des fins de débogage local, j'ai ajouté le domaine localhost à l'application Google, mais si quelqu'un commence à utiliser les clés de l'application pour envoyer du spam - Google bloquera-t-il les clés elles-mêmes ou le compte de l'expéditeur?</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je serais reconnaissant pour la rétroaction. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sources sur github. </font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Merci pour l'attention.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr491994/index.html">Migration de Cocoapods vers Swift Package Manager</a></li>
<li><a href="../fr491996/index.html">En savoir plus sur Coroutines en C ++</a></li>
<li><a href="../fr492000/index.html">Produit très premier. Burnout</a></li>
<li><a href="../fr492002/index.html">Ailes absorbant la lumière: le secret des papillons super noirs</a></li>
<li><a href="../fr492004/index.html">Comment passer d'un programmeur à un manager («Je veux être la maîtresse de la mer»)</a></li>
<li><a href="../fr492008/index.html">Résultats de la recherche sur la motivation informatique: les développeurs sont-ils satisfaits de leur travail?</a></li>
<li><a href="../fr492010/index.html">Le côté obscur du système de conception et ce qu'il faut en faire</a></li>
<li><a href="../fr492012/index.html">Les ustensiles de stabilisation Gyenno compensent jusqu'à 80% des tremblements</a></li>
<li><a href="../fr492016/index.html">ABP et tout, tout, tout: saisie automatique des réserves dans le centre de données</a></li>
<li><a href="../fr492018/index.html">Dépassement de vitesse: risques et vulnérabilités dans le domaine des systèmes de transport intelligents</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>