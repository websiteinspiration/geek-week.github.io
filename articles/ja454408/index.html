<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍫 🎨 🤶🏿 CortexM3 / M4（ARM）ハードウェアビットバンディング、カーネルアーキテクチャ、アセンブラ、C / C ++ 14、および一連のメタプログラミング 🚵 🎓 🐙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前書き
 注意、これは、LEDを点滅させる方法や、STM32で最初の割り込みを取得する方法に関する「Hello world」の記事ではありません。しかし、私は提起されたすべての問題について徹底的に説明しようとしたので、この記事は多くの専門家やそのような開発者になることを夢見ている（私が望むように）だ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>CortexM3 / M4（ARM）ハードウェアビットバンディング、カーネルアーキテクチャ、アセンブラ、C / C ++ 14、および一連のメタプログラミング</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454408/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意、これは、LEDを点滅させる方法や、STM32で最初の割り込みを取得する方法に関する「Hello world」の記事ではありません。</font><font style="vertical-align: inherit;">しかし、私は提起されたすべての問題について徹底的に説明しようとしたので、この記事は多くの専門家やそのような開発者になることを夢見ている（私が望むように）だけでなく、初心者のマイクロコントローラープログラマーにも役立つでしょう。ブログ「MKプログラミング教師」。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/e5/rs/75/e5rs75rpejygxwippglfvpftzci.png" alt="画像"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜこれを書くことにしたのですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は誇張しましたが、Cortex-Mファミリのハードウェアビットバンディングは特殊なリソースでは説明されていないと言っていましたが、この機能がカバーされている場所はまだあります（ここで1つの記事にさえ出会いました）が、このトピックは明らかに補足して最新化する必要があります。</font><font style="vertical-align: inherit;">これは英語のリソースにも当てはまることに注意してください。</font><font style="vertical-align: inherit;">次のセクションでは、このカーネル機能が非常に重要になる理由を説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理論</font></font></h2><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（そしてそれに慣れている人はすぐに実践に移ることができます）</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ハードウェアビットバンディングはコア自体の機能であるため、マイクロコントローラーメーカーのファミリーや会社に依存しません。主なことは、コアが適切であることです。この例では、それをCortex-M3とします。したがって、この問題に関する情報はコア自体の公式ドキュメントで探す必要があります。そのようなドキュメントがあります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。セクション4.2では、このツールの使用方法について詳しく説明しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、STM32やLPCなどの「深刻な」32ビットマイクロコントローラーのプロパガンダ化された複雑さとアセンブラーの役に立たないため、アセンブラーに精通していないプログラマーのために、少し技術的な余談を述べたいと思います。オタク誌でもこの領域でのアセンブラの使用に対する非難 </font><font style="vertical-align: inherit;">このセクションでは、ビットバンディングの利点を明確にするために、MKメモリへの書き込みメカニズムについて簡単に説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのSTM32の具体的な簡単な例を説明します。</font><font style="vertical-align: inherit;">PB0を汎用出力に変換する必要があるとします。</font><font style="vertical-align: inherit;">典型的なソリューションは次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs">GPIOB-&gt;MODER |= GPIO_MODER_MODER0_0;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、レジスタの残りのビットを上書きしないために、ビット単位の「OR」を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーの場合、これは次の4つの命令セットに変換されます。</font></font><br>
<br>
<ol>
<li>     ()  GPIOB-&gt;MODER</li>
<li>       ,     1. </li>
<li>   «»    GPIO_MODER_MODER0_0. </li>
<li>     GPIOB-&gt;MODER. </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、このカーネルがthumb2命令セットを使用していることを忘れないでください。つまり、ボリュームが異なる可能性があります。</font><font style="vertical-align: inherit;">私はまた、どこでも最適化O3のレベルについて話していることに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アセンブリ言語では、次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kt/px/tf/ktpxtfc4bapih79fj96yf7poi64.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の命令はオフセット付きの疑似命令にすぎないことがわかります。PCアドレス（コンベヤを指定）+ 0x58にレジスタのアドレスが見つかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wf/ar/ea/wfareavtgdjjmqckiemg0jfbygs.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
操作ごとに4つのステップ（およびより多くのクロックサイクル）と14バイトの占有メモリがあることがわかります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これについてもっと知りたいのなら、本[2]をお勧めします。ちなみに、ロシア語もあります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit_bandingメソッドに渡します。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
農民によると、本質は、プロセッサに特別に割り当てられたメモリ領域があり、周辺レジスタまたはRAMの他のビットを変更しない値を記録することです。</font><font style="vertical-align: inherit;">つまり、上記の2）と3）の点を満たす必要はありません。そのためには、[1]の式に従って住所を再計算するだけで十分です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t1/fo/yu/t1foyujiyauoiecjczide1myroi.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様の操作、そのアセンブラーを実行しようとしてい</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j_/g-/6d/j_g-6dq9yi1cjt0yxbo7rzqbmrw.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。アドレスを再計算します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/du/1k/qp/du1kqpsrhjinmp6y4i2hkuqeut4.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、書き込み命令＃1をRONに追加しましたが、いずれにしても、結果は14バイトではなく10バイトになり、数クロックサイクル少なくなります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、違いがばかげている場合はどうでしょうか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方では、特にコントローラーがすでに168 MHzにオーバークロックする習慣があるサイクルでは、節約はそれほど重要ではありません。平均的なプロジェクトでは、この方法を適用できる瞬間はそれぞれ40〜80バイトで、アドレスが異なる場合、節約量は250バイトに達する可能性があります。そして、「zashkvarom」がレジスター上で直接システムデバイスプログラミングと</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見なされ</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">任意のキューブ</font><s><font style="vertical-align: inherit;">-rubiki</font></s><font style="vertical-align: inherit;">を使用するのが「かっこいい」と</font><s><font style="vertical-align: inherit;">考える</font></s><font style="vertical-align: inherit;">と、節約量ははるかに多くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、250バイトという数値は、コミュニティで高レベルのライブラリが積極的に使用されているため、ファームウェアが適切なサイズに膨らんでいるために歪んでいます。低レベルのプログラミングは、優れたアーキテクチャとO3最適化を備えた、平均的なプロジェクトのソフトウェアボリュームの少なくとも2〜5％です。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">繰り返しになりますが、これはすべての自尊心のあるMKプログラマーが使用する必要がある、ある種の非常に優れた超クールなツールであるとは言いたくありません。</font><font style="vertical-align: inherit;">でも、ほんのわずかな部分でもコストを削減できたら、どうしてですか？</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAMが必要になる状況に遭遇しなかったので、すべてのオプションは周辺機器を構成するためにのみ与えられます。</font><font style="vertical-align: inherit;">厳密に言うと、RAMの場合も式は似ています。計算のためにベースアドレスを変更するだけです。</font><font style="vertical-align: inherit;">これをどのように実装しますか？</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブラ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の最愛のアセンブラーから、下から行きましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アセンブラープロジェクトでは、通常、プロジェクト全体の＃0と＃1の下に2バイトのRONを（それらで動作する命令に従って）割り当て、マクロでも使用します。これにより、継続的にさらに2バイトが削減されます。</font><font style="vertical-align: inherit;">注：STMのアセンブラーでCMSISを見つけることができませんでした。というのも、マクロにビット番号を入れたのであり、ケースごとの値ではないからです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNUアセンブラーの実装</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">@  .<font></font>
MOVW 	R0, 0x0000<font></font>
MOVW 	R1, 0x0001<font></font>
<font></font>
@  <font></font>
.macro  PeriphBitSet PerReg, BitNum<font></font>
LDR		R3, =(BIT_BAND_ALIAS+(((\PerReg) - BIT_BAND_REGION) * 32) + ((\BitNum) * 4))<font></font>
STR     R1, [R3]<font></font>
.endm<font></font>
<font></font>
@  <font></font>
.macro  PeriphBitReset PerReg, BitNum<font></font>
LDR		R3, =(BIT_BAND_ALIAS+((\PerReg - BIT_BAND_REGION) * 32) + (\BitNum * 4))<font></font>
STR     R0, [R3]<font></font>
.endm</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブラーの例</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PeriphSet TIM2_CCR2, 	0<font></font>
PeriphBitReset USART1_SR, 5<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このオプションの間違いない利点は、私たちが完全に制御できることです。これは、それ以上のオプションについては言えません。</font><font style="vertical-align: inherit;">そして、記事の最後のセクションが示すように、これは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ゼロの終わり頃から、アセンブラーでMKのプロジェクトを誰も必要としないため、SIに切り替える必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレーンc</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正直なところ、私がパスの最初、つまり広大なネットワークのどこかに単純なシシニーオプションを見つけました。</font><font style="vertical-align: inherit;">当時、私は既にアセンブラーにビットバンディングを実装していて、誤ってCファイルに出くわしましたが、すぐに機能し、何も発明しないことにしました。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレーンCの実装</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs">
<span class="hljs-comment">/*!&lt;=================PLAIN C SECTION========================&gt;!*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT31(A)        (A==0x80000000)? 31 : 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT30(A)        (A==0x40000000)? 30 : MASK_TO_BIT31(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT29(A)        (A==0x20000000)? 29 : MASK_TO_BIT30(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT28(A)        (A==0x10000000)? 28 : MASK_TO_BIT29(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT27(A)        (A==0x08000000)? 27 : MASK_TO_BIT28(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT26(A)        (A==0x04000000)? 26 : MASK_TO_BIT27(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT25(A)        (A==0x02000000)? 25 : MASK_TO_BIT26(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT24(A)        (A==0x01000000)? 24 : MASK_TO_BIT25(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT23(A)        (A==0x00800000)? 23 : MASK_TO_BIT24(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT22(A)        (A==0x00400000)? 22 : MASK_TO_BIT23(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT21(A)        (A==0x00200000)? 21 : MASK_TO_BIT22(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT20(A)        (A==0x00100000)? 20 : MASK_TO_BIT21(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT19(A)        (A==0x00080000)? 19 : MASK_TO_BIT20(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT18(A)        (A==0x00040000)? 18 : MASK_TO_BIT19(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT17(A)        (A==0x00020000)? 17 : MASK_TO_BIT18(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT16(A)        (A==0x00010000)? 16 : MASK_TO_BIT17(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT15(A)        (A==0x00008000)? 15 : MASK_TO_BIT16(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT14(A)        (A==0x00004000)? 14 : MASK_TO_BIT15(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT13(A)        (A==0x00002000)? 13 : MASK_TO_BIT14(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT12(A)        (A==0x00001000)? 12 : MASK_TO_BIT13(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT11(A)        (A==0x00000800)? 11 : MASK_TO_BIT12(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT10(A)        (A==0x00000400)? 10 : MASK_TO_BIT11(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT09(A)        (A==0x00000200)? 9  : MASK_TO_BIT10(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT08(A)        (A==0x00000100)? 8  : MASK_TO_BIT09(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT07(A)        (A==0x00000080)? 7  : MASK_TO_BIT08(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT06(A)        (A==0x00000040)? 6  : MASK_TO_BIT07(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT05(A)        (A==0x00000020)? 5  : MASK_TO_BIT06(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT04(A)        (A==0x00000010)? 4  : MASK_TO_BIT05(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT03(A)        (A==0x00000008)? 3  : MASK_TO_BIT04(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT02(A)        (A==0x00000004)? 2  : MASK_TO_BIT03(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT01(A)        (A==0x00000002)? 1  : MASK_TO_BIT02(A)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK_TO_BIT(A)          (A==0x00000001)? 0  : MASK_TO_BIT01(A)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>	BIT_BAND_PER(reg, reg_val)	(*(volatile uint32_t*)(PERIPH_BB_BASE+32*((uint32_t)(&amp;(reg))-PERIPH_BASE)+4*((uint32_t)(MASK_TO_BIT(reg_val)))))</span>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、プロセッサの言語で書かれた非常にシンプルでわかりやすいコードです。</font><font style="vertical-align: inherit;">ここでの主な作業は、CMSIS値をビット番号に変換することです。これは、アセンブラーバージョンの必要性としてはありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ああ、はい、このオプションを次のように使用します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレーンCの例</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs">
BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = <span class="hljs-number">0</span>; <span class="hljs-comment">//</span>
BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = <span class="hljs-number">1</span>; <span class="hljs-comment">// (!0)</span>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、現代的（私の観察によれば、およそ2015年以降）の傾向は、MKであってもCをC ++に置き換えることを支持しています。</font><font style="vertical-align: inherit;">そして、マクロは最も信頼できるツールではないので、次のバージョンが生まれる運命にありました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cpp03</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、非常に興味深い議論が行われていますが、その複雑さの観点からはほとんど使用されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局のところ、変数の値をビット数に変換するタスクは理想的であり（CMSISには既に値が存在します）、この場合はコンパイル時に実用的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テンプレートを使用して次のように実装しました。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 03の実装</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">uint32_t</span> val, <span class="hljs-keyword">uint32_t</span> comp_val, <span class="hljs-keyword">uint32_t</span> cur_bit_num&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bit_num_from_value</span>
{</span>
	<span class="hljs-keyword">enum</span> { bit_num = (val == comp_val) ? cur_bit_num : bit_num_from_value&lt;val, <span class="hljs-number">2</span> * comp_val, cur_bit_num + <span class="hljs-number">1</span>&gt;::bit_num };<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">uint32_t</span> val&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bit_num_from_value</span>&lt;val, static_cast&lt;uint32_t&gt;(0x80000000), static_cast&lt;uint32_t&gt;(31)&gt;
{</span>
	<span class="hljs-keyword">enum</span> { bit_num = <span class="hljs-number">31</span> };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>	BIT_BAND_PER(reg, reg_val)	*(reinterpret_cast<span class="hljs-meta-string">&lt;volatile uint32_t *&gt;(PERIPH_BB_BASE + 32 * (reinterpret_cast&lt;uint32_t&gt;(&amp;(reg)) - PERIPH_BASE) + 4 * (bit_num_from_value&lt;static_cast&lt;uint32_t&gt;(reg_val), static_cast&lt;uint32_t&gt;(0x01), static_cast&lt;uint32_t&gt;(0)&gt;::bit_num)))</span></span>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ方法で使用できます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 03の例</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs">
BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = <span class="hljs-literal">false</span>; <span class="hljs-comment">//</span>
BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = <span class="hljs-literal">true</span>; <span class="hljs-comment">//</span>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、なぜマクロが残ったのですか？</font><font style="vertical-align: inherit;">実際のところ、プログラムコードの別の領域に移動せずにこの操作を挿入することを保証する別の方法を知りません。</font><font style="vertical-align: inherit;">コメントで私を促してくれたらうれしいです。</font><font style="vertical-align: inherit;">テンプレートもインライン関数もそのような保証を提供しません。</font><font style="vertical-align: inherit;">はい、ここでのマクロはそのタスクを完全に処理します</font><font style="vertical-align: inherit;">。</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準拠者</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がこれを「安全でない」と考える</font><font style="vertical-align: inherit;">からといって、マクロを変更しても意味がありません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
驚いたことに、時間はまだ止まらず、コンパイラーはC ++ 14 / C ++ 17をますますサポートしているため、革新を利用してコードをより理解しやすくしてください。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cpp14 / cpp17</font></font></h4><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 14の実装</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs">
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">uint32_t</span> <span class="hljs-title">bit_num_from_value_cpp14</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> val, <span class="hljs-keyword">uint32_t</span> comp_val, <span class="hljs-keyword">uint32_t</span> bit_num)</span>
</span>{
	<span class="hljs-keyword">return</span> bit_num = (val == comp_val) ? bit_num : bit_num_from_value_cpp14(val, <span class="hljs-number">2</span> * comp_val, bit_num + <span class="hljs-number">1</span>);<font></font>
}<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>	BIT_BAND_PER(reg, reg_val)	*(reinterpret_cast<span class="hljs-meta-string">&lt;volatile uint32_t *&gt;(PERIPH_BB_BASE + 32 * (reinterpret_cast&lt;uint32_t&gt;(&amp;(reg)) - PERIPH_BASE) + 4 * (bit_num_from_value_cpp14(static_cast&lt;uint32_t&gt;(reg_val), static_cast&lt;uint32_t&gt;(0x01), static_cast&lt;uint32_t&gt;(0)))))</span></span>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、テンプレートを再帰的なconstexpr関数に置き換えただけです。これは、私の考えでは、人間の目にはより明確です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ方法を使用します。</font><font style="vertical-align: inherit;">ちなみに、C ++ 17では、原則として、再帰的なラムダconstexpr関数を使用できますが、これが少なくともいくつかの簡略化につながるか、アセンブラーの順序が複雑になるかはわかりません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要約すると、理論セクションによると、3つすべてのC / Cpp実装は、等しく正しい命令セットを提供します。</font><font style="vertical-align: inherit;">私は長い間、IAR ARM 8.30とgcc 7.2.0のすべての実装に取り​​組んできました。</font></font></b> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">練習は雌犬です</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それだけです、起こったようです。メモリの節約が計算され、実装が選択され、パフォーマンスを向上させる準備ができています。ここではなく、それは理論と実践の相違の単なる例でした。そしてそれはいつ違いましたか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これをテストしていなければ、これを公開することはなかったでしょうが、実際の量はプロジェクトでどれだけ削減されているのでしょう。具体的には、いくつかの古いプロジェクトで、このマクロをマスクなしの通常の実装に置き換え、その違いを調べました。結果は不愉快に驚いた。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局のところ、音量はほとんど変化していません。私は特にそのような指示が正確に40-50使用されたプロジェクトを選びました。理論によると、100バイト以上200バイト以下を節約できたはずです。実際には、差は24〜32バイトでした。しかし、なぜ？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、周辺機器をセットアップするときは、5〜10個のレジスタをほぼ一列にセットアップします。</font><font style="vertical-align: inherit;">そして、高度な最適化では、コンパイラーはレジスターの順序で命令を正確に配置しませんが、正しいように命令を配置します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのオプションが表示されます（ここでは私の推測です）。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または、コンパイラーが非常に賢いので、命令セットを最適化する方が良い方法を知っている </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または、コンパイラはまだ人よりも賢くなく、そのような構造に遭遇すると混乱します</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、高度な最適化レベルの「高水準」言語でのこのメソッドは、そのような1つの操作の近くに同様の操作がない場合にのみ正しく機能することがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、O0レベルでは理論と実践はいずれにしても収束しますが、このレベルの最適化には興味がありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まとめます</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
否定的な結果も結果です。</font><font style="vertical-align: inherit;">誰もが自分で結論を出すと思います。</font><font style="vertical-align: inherit;">個人的に、私はこのテクニックを使い続けます、それから確かにそれが悪くなることはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
面白かったと思いますし、最後まで読んでいただいた方々に大きな敬意を表したいと思います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文献リスト</font></font></h2><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Cortex-M3テクニカルリファレンスマニュアル」、セクション4.2、ARM 2005。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM Cortex-M3の最も信頼できるガイド、Joseph Yiu。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS組み込み電子機器の開発に関連するトピックを少し手に入れました。</font><font style="vertical-align: inherit;">知らせてください。興味があれば、ゆっくり入手します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PPSどういうわけか、コードのセクションを挿入するのは曲がっていましたが、可能であれば、改善方法を教えてください。</font><font style="vertical-align: inherit;">一般に、関心のあるコードの一部をメモ帳にコピーして、分析で不快な感情を避けることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD：</font></font></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読者の要望に応じて、ビットバンディング操作自体がアトミックであることを示しました。これにより、レジスタを操作するときにセキュリティが確保されます。</font><font style="vertical-align: inherit;">これは、このメソッドの最も重要な機能の1つです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja454398/index.html">批評家からアルゴリズムへ：民主主義とテクノクラシーが音楽業界にどのようにやってきたか</a></li>
<li><a href="../ja454400/index.html">RおよびPowerShellを使用した仮想マシンステータスの日次レポート</a></li>
<li><a href="../ja454402/index.html">ユニットの動作を整理するためのUnityステートマシンアーキテクチャ</a></li>
<li><a href="../ja454404/index.html">Cisco 200-125 CCNA v3.0のトレーニング。6日目：空白を入力します（DHCP、TCP、「ハンドシェイク」、一般的なポート番号）</a></li>
<li><a href="../ja454406/index.html">秋葉原：オタク営巣地</a></li>
<li><a href="../ja454410/index.html">PHP 7.4の新機能</a></li>
<li><a href="../ja454414/index.html">SDL 2レッスン：レッスン2-ゴム以外のメイン</a></li>
<li><a href="../ja454416/index.html">Hadoopディストリビューションのインポート</a></li>
<li><a href="../ja454418/index.html">バックエンドでテンプレートエンジンを使用する明白な3つの例</a></li>
<li><a href="../ja454420/index.html">バックアップ、パート3：重複性の概要とテスト、重複</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>