<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👧‍👧 🧝 🍉 Komputasi rekursif otomatis 🧖🏽 😿 👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Perkenalan
 Dampak subrutin (subrutin bahasa Inggris) pada pemrograman tanpa berlebihan sangat besar. Diperkenalkan pada awal pemrograman, mereka t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Komputasi rekursif otomatis</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492958/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Perkenalan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dampak subrutin (subrutin bahasa Inggris) pada pemrograman tanpa berlebihan sangat besar. Diperkenalkan pada awal pemrograman, mereka tidak kehilangan relevansinya hingga hari ini. Tanpa mereka, pemrograman praktis tidak mungkin dibayangkan. Meskipun dari sudut pandang formal, mereka tidak begitu diperlukan, karena Teori murni lebih tertarik pada sifat-sifat algoritma daripada ukurannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam teori automata, konsep nested automata, yang menjadi dasar praktik subprogram otomat (AMP), jarang dibahas. Suatu organisasi hierata automata automata yang serupa, jika dipertimbangkan, sangat dangkal. Salah satu alasan untuk hubungan ini mungkin karena kompleksitas penerapan hierarki bersarang di tingkat perangkat keras [1, 2].</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pemrograman lebih fleksibel dan menyediakan lebih banyak fitur daripada praktik merancang sirkuit digital. </font><font style="vertical-align: inherit;">Kita harus memastikan ini, mempertimbangkan lebih lanjut implementasi perangkat lunak automata bersarang, dan kemudian konsep algoritma rekursif otomat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk semua masalah khusus dalam membentuk model robot bertingkat, definisi formalnya tidak menyebabkan masalah. </font><font style="vertical-align: inherit;">Namun, di sisi lain, pilihan untuk membangun model hirarki tentu akan berdampak signifikan pada implementasi perangkat lunaknya.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Algoritma rekursif otomatis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam artikel sebelumnya [3], hanya definisi formal dari model kontrol program otomatis (AP) yang diberikan tanpa mempertimbangkan penerapannya dan contoh penggunaan khusus. Kemungkinan menerapkan algoritma rekursif juga disebutkan. Selanjutnya, dengan menggunakan contoh perhitungan faktorial, pertama, kami akan mempertimbangkan implementasi perangkat lunak dari mekanisme untuk membuat rutinitas otomatis dalam kerangka paradigma objek automaton C ++, dan kedua, karena kami akan mempertimbangkan algoritma rekursif, kami pada dasarnya akan menetapkan prinsip umum untuk mengimplementasikan hal tersebut. algoritma dalam kerangka pemrograman otomatis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menggunakan fungsi rekursif dalam API bisa sangat sederhana. </font><font style="vertical-align: inherit;">Ini menunjukkan kode untuk daftar 1 program mesin objek. </font><font style="vertical-align: inherit;">Di sini kelas otomat FSimpleFactorial bukan proses, tetapi rutin otomat, karena </font><font style="vertical-align: inherit;">berisi status akhir "00" (untuk detail lebih lanjut tentang subprogram lihat [3]). </font><font style="vertical-align: inherit;">Pada tingkat perilaku, objek otomat yang dibuat sesuai dengan otomat dengan satu transisi tanpa syarat dari keadaan awal "f0" ke keadaan akhir "00" dan panggilan untuk transisi ini dalam kerangka kerja y1 dari fungsi faktorial faktorial biasa (faktorial (...)).</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar 1. Memanggil fungsi faktorial dari AMS</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSimpleFactorial</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">double</span> dF{<span class="hljs-number">1</span>};		<span class="hljs-comment">//	 </span>
    FSimpleFactorial(<span class="hljs-keyword">int</span> n);
    <span class="hljs-keyword">virtual</span> ~FSimpleFactorial() {};
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> nN{<span class="hljs-number">0</span>};
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSimpleFactorial.h"</span></span><font></font>
<font></font>
LArc TT_SimpleFactorial[] = {<font></font>
    LArc(<span class="hljs-string">"f0"</span>, <span class="hljs-string">"00"</span>, <span class="hljs-string">"--"</span>,	<span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// Construction/Destruction</span>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span>
FSimpleFactorial::FSimpleFactorial(<span class="hljs-keyword">int</span> n)<font></font>
    :LFsaAppl(TT_SimpleFactorial, <span class="hljs-string">"FSimpleFactorial"</span>)<font></font>
{<font></font>
    nN = n;<font></font>
}<font></font>
<span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSimpleFactorial::y1</span><span class="hljs-params">()</span> </span>{ dF = factorial(nN); }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">FSimpleFactorial::factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n*factorial(n<span class="hljs-number">-1</span>);<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena objek FSimpleFactorial adalah automaton bersarang (subroutine), harus ada "pembungkus" untuk itu - proses yang memanggilnya. </font><font style="vertical-align: inherit;">Contohnya adalah proses yang muncul dari objek bernama FTskSimple, yang kodenya ditunjukkan pada Listing 2.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar 2. Proses untuk membuat otomat bersarang</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FTskSimple</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FTskSimple(nameFsa); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FTskSimple(<span class="hljs-built_in">string</span> strNam);
    <span class="hljs-keyword">virtual</span> ~FTskSimple();<font></font>
<font></font>
    CVar    *pVarF;<font></font>
    CVar    *pVarN;<font></font>
    CVar    *pVarStart;<font></font>
<font></font>
    LFsaAppl *pFCall{<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y3</span><span class="hljs-params">()</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FTskSimple.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSimpleFactorial.h"</span></span>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// Construction/Destruction</span>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><font></font>
LArc TT_Task[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>, <span class="hljs-string">"t1"</span>, <span class="hljs-string">"--"</span>,	<span class="hljs-string">"y1"</span>),	<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"t1"</span>, <span class="hljs-string">"t2"</span>, <span class="hljs-string">"x1"</span>,	<span class="hljs-string">"y3"</span>),	<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"t2"</span>, <span class="hljs-string">"t1"</span>, <span class="hljs-string">"--"</span>,	<span class="hljs-string">"y2"</span>),	<span class="hljs-comment">//</span><font></font>
    };<font></font>
<font></font>
FTskSimple::FTskSimple(<span class="hljs-built_in">string</span> strNam)<font></font>
    :LFsaAppl(TT_Task, strNam)<font></font>
{<font></font>
}<font></font>
<font></font>
FTskSimple::~FTskSimple() { <span class="hljs-keyword">if</span> (pFCall) <span class="hljs-keyword">delete</span> pFCall; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FTskSimple::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{<font></font>
    pVarF = CreateLocVar(<span class="hljs-string">"dF"</span>, CLocVar::vtDouble, <span class="hljs-string">"factorial value"</span>);<font></font>
    pVarN = CreateLocVar(<span class="hljs-string">"nN"</span>, CLocVar::vtInteger, <span class="hljs-string">"input value"</span>);<font></font>
    pVarStart = CreateLocVar(<span class="hljs-string">"bStart"</span>, CLocVar::vtBool, <span class="hljs-string">"start?"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FTskSimple::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarStart-&gt;GetDataSrc(); }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTskSimple::y1</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// reset flag start</span>
    pVarStart-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, <span class="hljs-number">0.0</span>);
    <span class="hljs-comment">// creating and calling a subroutine</span>
    pFCall = <span class="hljs-keyword">new</span> FSimpleFactorial(pVarN-&gt;GetDataSrc());<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTskSimple::y2</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// display factorial value</span>
    pVarF-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">static_cast</span>&lt;FSimpleFactorial*&gt;(pFCall)-&gt;dF);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTskSimple::y3</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// reset flag start</span>
    pVarStart-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, <span class="hljs-number">0.0</span>);
    <span class="hljs-keyword">static_cast</span>&lt;FSimpleFactorial*&gt;(pFCall)-&gt;nN = pVarN-&gt;GetDataSrc();
    <span class="hljs-comment">// creating and calling a subroutine</span>
    pFCall-&gt;FCall(<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proses ini pada transisi dari keadaan awal "st" ke keadaan "t1" menciptakan objek bertipe FSimpleFactorial, yang akan menjadi dasar untuk membuat robot bersarang (dalam arti biasa, memanggil subprogram). </font><font style="vertical-align: inherit;">Selanjutnya, berdasarkan pada keadaan saat ini dari variabel lokal dari tipe Boolean bStart (lihat juga kode predikat x1), itu menyebabkan transisi dari keadaan "t1" ke "t2". </font><font style="vertical-align: inherit;">Pada transisi ini, tindakan y1, pertama, me-reset nilai variabel lokal ini (untuk mencegah restart salah) dan, kedua, memanggil prosedur FCall, yang menciptakan automaton bersarang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penerjemah automata dari lingkungan VKPA mengatur transisi ke keadaan awal "f0" dari automaton yang disematkan dan keadaan yang terakhir menjadi keadaan proses saat ini. Transisi automaton bersarang ke kondisi akhir “00” mengembalikan perhitungan ke level sarang sebelumnya, dan dalam kasus kami, hingga penyelesaian transisi otomat tingkat atas ke kondisi t2. Kemudian proses, pada transisi tanpa syarat dari negara "t2" ke negara "t1", melakukan tindakan y2, yang menetapkan hasil perhitungan faktorial variabel lokal dari proses dF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Catatan, dan sangat penting bahwa hasil dari automaton bersarang akan tersedia hanya setelah menyelesaikan pekerjaannya dan transisi ke keadaan berikutnya dari otomat tingkat atas. Dimungkinkan untuk mendapatkannya (hasil) melalui pointer ke objek automaton bersarang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan semuanya akan baik-baik saja jika bukan karena runtime fungsi rekursif. Dibandingkan dengan subrutin biasa, karena bersarang, sebagai aturan, ini jauh lebih besar dan karenanya dapat melanggar atomisitas bersyarat dari tindakan proses otomatis, total waktu eksekusi yang harus sesuai dengan nilai siklus clock diskrit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus kami, perhitungan faktorial cukup kecil dan hingga nilai maksimum hasil ganda untuk n = 170 cocok menjadi 1 mikrodetik. Untuk menghitung nilai besar, seseorang perlu beralih ke aritmatika panjang (lihat, misalnya, [4, 5]). Pada saat yang sama, waktu perhitungan faktorial akan meningkat bahkan lebih dan hampir dijamin akan melampaui siklus clock diskrit, yang mempengaruhi kecepatan mesin jaringan yang tersisa yang beroperasi dalam mode multitasking non-preemptive dan reaktivitas respon aplikasi secara keseluruhan, yang akan memanifestasikan dirinya dalam "rem".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat tetap dalam siklus clock diskrit dan menyingkirkan cacat "rem" dengan memperluas perhitungan menjadi langkah-langkah. Untuk tujuan ini, akan lebih mudah untuk menerjemahkan algoritma faktorial yang biasa ke dalam bentuk otomatis. Benar, karena mode interpretasi automata, waktu perhitungan akan meningkat, tetapi sifat temporal aplikasi akan kembali normal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 3 menunjukkan perhitungan faktorial dalam bentuk yang biasa dan dalam bentuk yang disiapkan untuk konversi selanjutnya ke bentuk otomat. Yang terakhir secara eksplisit mewakili langkah-langkah atom yang disembunyikan dalam kode sumber program. Dalam hal ini, kita berbicara tentang operator dari bentuk y = f (...), di mana f adalah fungsi program biasa atau rekursif. Catatan semacam itu menutupi waktu operasi dari fungsi dan menciptakan kesan yang salah dari penugasan “sesaat” dari nilai variabel y. Pada kenyataannya, tidak ada yang satu atau yang lain.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar 3. Fungsi perangkat lunak untuk menghitung faktorial</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n*factorial(n<span class="hljs-number">-1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">double</span> dF = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> dF;
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">double</span> dPrev = Factorial(n<span class="hljs-number">-1</span>);
        <span class="hljs-keyword">double</span> dF = n*dPrev;
        <span class="hljs-keyword">return</span> dF;<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kerangka konsep pemrograman otomatis, aksi atom (metode) objek otomatis perangkat lunak dianggap bersyarat seketika. </font><font style="vertical-align: inherit;">Dan jika hanya waktu operasi total tindakan yang cocok dengan satu siklus waktu diskrit ruang otomat, maka implementasi perangkat lunak sesuai dengan model formalnya. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keterangan 1. Total waktu nyata dari operasi tindakan pada satu atau lain siklus clock diskrit dapat sangat bervariasi. </font><font style="vertical-align: inherit;">Dalam hal melebihi waktu siklus, lingkungan VKPA mencoba untuk mengkompensasinya pada siklus berikutnya dari operasi ruang otomat, mengurangi, jika mungkin, waktu diskrit dari siklus berikutnya.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam gbr. Gambar 1 menunjukkan diagram blok yang mencakup markup yang mencerminkan keadaan mesin keadaan terbatas yang setara dan nama predikat dan tindakannya. Model otomat itu sendiri dalam bentuk grafik otomat ditunjukkan pada Gambar. 2. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y9/su/vd/y9suvdw86fiu4pz4tokaamqpmai.jpeg" alt="gambar"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar. 1. Blok diagram dari </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">Gambar </font></i><i><font style="vertical-align: inherit;">faktorial algoritma rekursif </font></i></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/vg/qr/bgvgqrab0jdiesuscmbzrsvr9fq.jpeg" alt="gambar"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. 2. Model otomat dari suatu faktorial rekursif algoritma</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode untuk rutin otomatis untuk menghitung faktorial ditunjukkan pada Listing 4. Komentar dalam tabel transisi (TP) mencerminkan waktu menghitung faktorial dalam ms dan jumlah langkah-langkah terpisah yang dihabiskan pada prosedur perhitungan untuk n = 170. Dan jika waktu perhitungan tergantung pada kecepatan platform komputasi dan / atau pada jenis proyek (debug / rilis), maka jumlah langkah diskrit (siklus jam) hanya ditentukan oleh sifat-sifat algoritma dan dapat berfungsi sebagai penilaian obyektif dari kecepatan algoritma, terlepas dari bentuk presentasi dan implementasinya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus model otomat, jumlah kutu diskrit dapat dihitung dengan cukup sederhana dan, setelah mengumpulkan statistik tertentu, dapatkan rumus analitik untuk kecepatan algoritma. </font><font style="vertical-align: inherit;">Sementara itu, perkiraan tersebut sangat perkiraan dan didasarkan pada kesimpulan, seringkali diperoleh sebagai hasil dari alasan yang agak rumit.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar 4. Otomatis faktorial otomatis</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FFactRec</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    FFactRec(<span class="hljs-keyword">int</span> n);
    <span class="hljs-keyword">virtual</span> ~FFactRec() { <span class="hljs-keyword">if</span> (pFFactRec) <span class="hljs-keyword">delete</span> pFFactRec; };
    <span class="hljs-keyword">int</span> nN;		<span class="hljs-comment">//	n</span>
    <span class="hljs-keyword">double</span> dF;	<span class="hljs-comment">//	n!</span>
<span class="hljs-keyword">private</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y3</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CallFactorial</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">double</span>  <span class="hljs-title">PrevFactorial</span><span class="hljs-params">()</span></span>;<font></font>
    FFactRec *pFFactRec{<span class="hljs-literal">nullptr</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FFactRec.h"</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> QT_NO_DEBUG_OUTPUT</span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TT_FactRec[];
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// Construction/Destruction</span>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">//	   </span>
FFactRec::FFactRec(<span class="hljs-keyword">int</span> n)<font></font>
    :LFsaAppl(TT_FactRec, <span class="hljs-string">"FFactRec"</span>)<font></font>
{<font></font>
    nN=n; dF=<span class="hljs-number">1</span>;<font></font>
}<font></font>
<font></font>
LArc TT_FactRec[] = {<font></font>
<span class="hljs-comment">//        Debug    Release     Steps</span>
<span class="hljs-comment">//msec: 120-129   98-101        340</span>
    LArc(<span class="hljs-string">"f1"</span>, <span class="hljs-string">"00"</span>, <span class="hljs-string">"x1"</span>,	<span class="hljs-string">"y3"</span>),	<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"f1"</span>, <span class="hljs-string">"f2"</span>, <span class="hljs-string">"^x1"</span>,	<span class="hljs-string">"y1"</span>),	<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"f2"</span>, <span class="hljs-string">"00"</span>, <span class="hljs-string">"--"</span>,	<span class="hljs-string">"y2"</span>),	<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FFactRec::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> nN==<span class="hljs-number">0</span>; }
<span class="hljs-comment">//   </span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FFactRec::y1</span><span class="hljs-params">()</span> </span>{ CallFactorial(); }
<span class="hljs-comment">//	1.      </span>
<span class="hljs-comment">//	2.    </span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FFactRec::y2</span><span class="hljs-params">()</span> </span>{ dF = PrevFactorial()*nN; }
<span class="hljs-comment">// 0!</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FFactRec::y3</span><span class="hljs-params">()</span> </span>{ dF = <span class="hljs-number">1</span>; }
<span class="hljs-comment">//   (  )</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FFactRec::CallFactorial</span><span class="hljs-params">()</span>	</span>{
    <span class="hljs-comment">//	     </span>
    pFFactRec = <span class="hljs-keyword">new</span> FFactRec(nN<span class="hljs-number">-1</span>);<font></font>
    pFFactRec-&gt;FCall(<span class="hljs-keyword">this</span>);<font></font>
};<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-function"><span class="hljs-keyword">double</span>  <span class="hljs-title">FFactRec::PrevFactorial</span><span class="hljs-params">()</span>	</span>{ <span class="hljs-keyword">return</span> pFFactRec-&gt;dF; };
</code></pre><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Kesimpulan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akui, karena spesifik tugas yang harus diselesaikan, saya sebenarnya tidak harus menggunakan, dan mengembangkan algoritma rekursif dalam proyek nyata, kecuali untuk tujuan pelatihan dan untuk menguji kernel untuk implementasi penyarangan. </font><font style="vertical-align: inherit;">Rutinitas otomatis - hampir secara konstan dan dalam jumlah besar. </font><font style="vertical-align: inherit;">Di antara mereka, subrutin yang disebut inersia sangat menarik (untuk lebih jelasnya, lihat [3]). </font><font style="vertical-align: inherit;">Tapi mereka seharusnya mencurahkan artikel terpisah untuk pertimbangan mereka.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma rekursif adalah bagian penting dari teori program [6]. Tanpa implementasi rutinitas dan rekursi, sulit untuk membayangkan model komputasi yang efisien dan nyaman dari semua sudut pandang. Dan untuk mengimplementasikan rekursi, mengingat kemungkinan pemrograman objek (lihat contoh artikel), setelah membuat model subprogram, tidak begitu sulit. Anda bisa, tentu saja, menggunakan metode tertentu untuk mengubah rekursi menjadi bentuk reguler, melompati menggunakan siklus yang sama. Tetapi lebih disukai untuk tidak membuangnya dengan bodoh, tetapi memiliki mekanisme langsung untuk implementasinya. Tentu saja, akan lebih lambat, tentu saja, lebih mahal dalam hal sumber daya (biaya memori stack yang sama), tetapi dengan kemampuan perangkat keras yang ada ini tidak akan begitu kritis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi algoritma rekursif juga menarik sebagai tes untuk mengevaluasi kemampuan, universalitas, dan efektivitas model algoritmik. Dalam hal ini, model automaton tidak hanya mengimplementasikan rekursi dengan cukup efektif, tetapi juga menambahkan “chip automaton” sebagai bonus - kemampuan untuk mengontrol keadaan internal dari algoritma rekursif, menghitung langkah-langkah untuk mengevaluasi kinerja, mengontrol waktu eksekusi dari algoritma, dll. dll.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertarungan rekursi tidak ada gunanya. Itu harus bisa digunakan. Saya akan mengutip yang sepenuhnya saya setujui: "Sekilas, rekursi mungkin tampak rumit. Tetapi dalam beberapa kasus, metode rekursif sangat efektif jika semuanya dilakukan dengan benar. Namun, terkadang lebih baik menggunakan loop. Memahami kedua metode dan kemampuan untuk menggunakannya secara efektif akan membantu Anda dalam pekerjaan Anda dan akan menjadi keuntungan dalam wawancara ”[7]. Saya hanya dapat menambahkan sendiri bahwa model otomatis dari algoritma rekursif memungkinkan, dengan menggunakan "properti otomatis" dari model komputasi, untuk memahami rekursi, men-debug dan memperbaiki algoritma seperti itu jauh lebih cepat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan yang terakhir. </font><font style="vertical-align: inherit;">Namun demikian, saya ingin mendapatkan jawaban atas pertanyaan - bagaimana keadaan dengan rekursi coroutine? </font><font style="vertical-align: inherit;">Saya sudah menanyakannya, tetapi saya belum menerima jawaban ... Lagi pula, adalah satu hal untuk membuat sejuta coroutine (lihat [8] sebagai contoh) dan yang lainnya untuk mengimplementasikan algoritma rekursif yang memiliki tingkat bersarang yang tidak sama tetapi cukup tinggi. </font><font style="vertical-align: inherit;">Dan, sepertinya, jawaban untuk pertanyaan ini menarik bukan hanya saya saja ... [9]</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">literatur</font></font></b><div class="spoiler_text">1.  ..,  ..       . I, .  ., 1981,  2, 135-144. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">mi.mathnet.ru/at5725</a> . . . (  10.03.2020).<br>
2.  ..,  ..       . II, .  ., 1981,  3, 112-121. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">mi.mathnet.ru/at5743</a> . . . (  10.03.2020).<br>
3.    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/ru/post/484588</a> . . . (  10.03.2020).<br>
4.    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/ru/post/255761</a> . . . (  10.03.2020).<br>
5.     C++. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/ru/post/172285</a> . . . (  10.03.2020).<br>
6.  . .     : .  . – .: , 1983. – 256 .<br>
7.   ,   ?   Python.   Ethan Jarrell. Recursion vs. Looping in Python [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">nuancesprog.ru/p/3325</a> . . . (  15.03.2020).<br>
8. Your first coroutine with Kotlin. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kotlinlang.org/docs/tutorials/coroutines/coroutines-basic-jvm.html</a> . . . (  18.03.2020).<br>
9.  .   CyberForum.ru. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">www.cyberforum.ru/unity/thread2479923.html</a> . . . (  18.03.2020).<br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id492942/index.html">Ontol (= paling berguna) tentang pekerjaan jarak jauh [kompilasi 100+ artikel]</a></li>
<li><a href="../id492946/index.html">Coronavirus: bagaimana kita menipu diri kita sendiri</a></li>
<li><a href="../id492948/index.html">Temui defer</a></li>
<li><a href="../id492952/index.html">Kembali ke Masa Depan dengan Kursus Pengembang Java</a></li>
<li><a href="../id492956/index.html">Gamer tidak pernah mantan. Kenangan indah dan kesenangan terlarang - dalam survei oleh DataArt</a></li>
<li><a href="../id492962/index.html">Kit survival karantina otonom saya</a></li>
<li><a href="../id492964/index.html">Memproses jutaan peristiwa per hari dengan antrian berjenjang</a></li>
<li><a href="../id492966/index.html">Untuk pertama kalinya foton dipindahkan dari satu keping ke keping lainnya</a></li>
<li><a href="../id492968/index.html">Dalam ingatan Freeman Dyson, si jenius matematika, berubah menjadi visioner teknologi</a></li>
<li><a href="../id492970/index.html">Bagaimana TeamViewer menyimpan kata sandi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>