<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìØ üõÄ üî£ C # 8 y validez nula. ¬øC√≥mo vivimos con esto? üë©‚Äçüè´ üë©üèΩ ü•ù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬°Hola colegas! Es hora de mencionar que tenemos planes para lanzar el libro fundamental de Ian Griffiths sobre C # 8:
 
 
 Mientras tanto, en su blog,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C # 8 y validez nula. ¬øC√≥mo vivimos con esto?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/501520/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Hola colegas! </font><font style="vertical-align: inherit;">Es hora de mencionar que tenemos planes para lanzar </font><font style="vertical-align: inherit;">el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fundamental de </font><font style="vertical-align: inherit;">Ian Griffiths sobre C # 8:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/iw/to/l-/iwtol-20o3gyqy1ppgnewp68giw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mientras tanto, en su </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blog, el</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> autor ha publicado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos </font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> relacionados </font><font style="vertical-align: inherit;">en los que considera las complejidades de los nuevos fen√≥menos, como la nulabilidad, el olvido y la conciencia nula. </font><font style="vertical-align: inherit;">Hemos traducido ambos art√≠culos bajo un mismo t√≠tulo y sugerimos discutirlos.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La nueva caracter√≠stica m√°s ambiciosa en C # 8.0 se denomina </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">referencias anulables</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El prop√≥sito de esta nueva caracter√≠stica es suavizar el da√±o de una cosa peligrosa, que el cient√≠fico inform√°tico Tony Hoar llam√≥ una vez su " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">error de mil millones de d√≥lares</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">C # tiene una palabra clave</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(el equivalente se encuentra en muchos otros idiomas), y las ra√≠ces de esta palabra clave se remontan al lenguaje Algol W, en el desarrollo del cual particip√≥ Hoar. En este lenguaje antiguo (apareci√≥ en 1966), las variables que se refieren a instancias de cierto tipo podr√≠an recibir un significado especial que indica que en este momento esta variable no est√° referenciada en ning√∫n lado. Esta oportunidad fue muy prestada, y hoy en d√≠a muchos expertos (incluido el propio Hoar) creen que se ha convertido en la mayor fuente de costosos errores de software de todos los tiempos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© hay de malo en asumir cero? En un mundo donde cualquier enlace puede apuntar a cero, debe considerar esto siempre que se usen enlaces en su c√≥digo, de lo contrario corre el riesgo de ser rechazado en el tiempo de ejecuci√≥n. A veces no es demasiado pesado; si inicializa una variable con una expresi√≥n </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el mismo lugar donde la declara, entonces sabe que esta variable no es igual a cero. Pero incluso un ejemplo tan simple est√° cargado de cierta carga cognitiva: antes del lanzamiento de C # 8, el compilador no pod√≠a decirle si est√° haciendo algo que pueda convertir este valor </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pero, tan pronto como comience a unir diferentes fragmentos de c√≥digo, se vuelve mucho m√°s dif√≠cil juzgar con certeza sobre tales cosas: ¬øqu√© tan probable es que esta propiedad que estoy leyendo ahora pueda volver </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? ¬øEst√° permitido transmitir?</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en ese m√©todo? ¬øEn qu√© situaciones puedo estar seguro de que el m√©todo al que llamo establecer√° este argumento </font></font><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en un valor diferente? Adem√°s, el asunto ni siquiera se limita a recordar revisar tales cosas; no est√° del todo claro qu√© debe hacer si se encuentra con cero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con los tipos num√©ricos en C # no existe tal problema: si escribe una funci√≥n que toma algunos n√∫meros como entrada y devuelve un n√∫mero como resultado, entonces no tiene que preguntarse si los valores transmitidos son realmente n√∫meros y si algo entre ellos puede confundirse. Al llamar a tal funci√≥n, no es necesario pensar si puede devolver algo en lugar de un n√∫mero. A menos que tal desarrollo de eventos le interese como una opci√≥n: en este caso, puede declarar par√°metros o resultados del tipo</font></font><code>int?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que indica que en este caso particular realmente desea permitir la transmisi√≥n o devoluci√≥n de un valor nulo. Entonces, para los tipos num√©ricos y, en un sentido m√°s general, los tipos significativos, la tolerancia cero siempre ha sido una de esas cosas que se hacen voluntariamente, como una opci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cuanto a los tipos de referencia, antes de C # 8.0, la permisibilidad de cero no solo se configuraba de manera predeterminada, sino que tampoco se pod√≠a deshabilitar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, por razones de compatibilidad con versiones anteriores, la validez cero contin√∫a funcionando de manera predeterminada incluso en C # 8.0, porque las nuevas funciones de lenguaje en esta √°rea permanecen deshabilitadas hasta que las solicite expl√≠citamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, tan pronto como habilite esta nueva funci√≥n, todo cambia. La forma m√°s f√°cil de activarlo es agregarlo </font></font><code>&lt;Nullablegt;enable&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro del elemento.</font></font><code>&lt;PropertyGroup&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en su archivo </font></font><code>.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. (Observo que tambi√©n hay disponible m√°s control de filigrana. Si realmente lo necesita, puede configurar el comportamiento para que se permita por </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separado en cada l√≠nea. Pero, cuando recientemente decidimos incluir esta caracter√≠stica en todos nuestros proyectos, result√≥ que se activar√≠a a escala un proyecto a la vez es una tarea factible). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando los enlaces permitidos en C # 8.0 est√°n </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">completamente activados, la situaci√≥n cambia: ahora, por defecto, se supone que los enlaces no permiten nulos solo si usted no especifica lo contrario, exactamente como con los tipos significativos ( incluso la sintaxis es la misma: podr√≠a escribir int ?, si realmente desea que el valor entero sea opcional. ¬øAhora escribe cadena ?, si quiere decir que desea una referencia de cadena o</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es un cambio muy significativo y, en primer lugar, debido a su importancia, esta nueva caracter√≠stica est√° deshabilitada de forma predeterminada. Microsoft podr√≠a haber dise√±ado esta funci√≥n de lenguaje de manera diferente: podr√≠a dejar los enlaces predeterminados anulables e introducir una nueva sintaxis que le permitir√≠a especificar que desea asegurarse de que no est√© permitido </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Quiz√°s esto reducir√≠a la barra al explorar esta posibilidad, pero a la larga tal soluci√≥n ser√≠a incorrecta, ya que en la pr√°ctica la mayor√≠a de los enlaces en la gran masa de c√≥digo C # no est√°n dise√±ados para se√±alar </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Asumir cero es una excepci√≥n, no una regla, y es por eso que, cuando esta nueva funci√≥n de idioma est√° habilitada, evitar que el nulo se convierta en un nuevo valor predeterminado. Esto se refleja incluso en el nombre de la caracter√≠stica original: "referencias anulables". El nombre es curioso, dado que los enlaces podr√≠an apuntar </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a C # 1.0. Pero los desarrolladores decidieron enfatizar que ahora la suposici√≥n nula entra en la categor√≠a de cosas que deben solicitarse expl√≠citamente. </font></font><br>
‚ÄÉ<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C # 8.0 suaviza el proceso de introducci√≥n de enlaces permisivos </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ya que le permite introducir esta funci√≥n gradualmente. Uno no tiene que hacer una elecci√≥n de s√≠ o no. Esto es bastante diferente de la caracter√≠stica </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregada en C # 5.0, que tendi√≥ a extenderse: de hecho, las operaciones asincr√≥nicas obligan a la persona que llama a ser</font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y, por lo tanto, el c√≥digo que llama a esta persona que llama debe estar </font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y as√≠ sucesivamente, en la parte superior de la pila. Afortunadamente, los tipos que permiten </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se construyen de manera diferente: se pueden implementar de forma selectiva y gradual. Puede trabajar los archivos uno por uno, o incluso l√≠nea por l√≠nea, si es necesario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El aspecto m√°s importante de los tipos que permiten</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(gracias a lo cual se simplifica la transici√≥n a ellos), es que por defecto est√°n deshabilitados. De lo contrario, la mayor√≠a de los desarrolladores se negar√≠an a usar C # 8.0, ya que dicha transici√≥n provocar√≠a advertencias en casi cualquier base de c√≥digo. Sin embargo, por las mismas razones, el umbral de entrada para usar esta nueva caracter√≠stica se siente bastante alto: si una nueva caracter√≠stica realiza cambios tan dr√°sticos que est√° deshabilitada de manera predeterminada, entonces probablemente no querr√° meterse con ella, pero hay problemas asociados con cambiarla. siempre parecer√° una molestia innecesaria. Pero esto ser√≠a una pena, porque la caracter√≠stica es muy valiosa. Ayuda a encontrar errores en el c√≥digo antes de que los usuarios lo hagan por usted. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, si est√° considerando introducir tipos que permitan</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aseg√∫rese de tener en cuenta que puede introducir esta funci√≥n paso a paso. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo advertencias</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
El nivel m√°s duro de control sobre todo el proyecto despu√©s de un simple encendido / apagado es la capacidad de activar advertencias independientemente de las anotaciones. Por ejemplo, si </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habilito</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> completamente la suposici√≥n cero para </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Corvus.ContentHandling.Json</font></a><font style="vertical-align: inherit;"> en nuestro repositorio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corvus.ContentHandling</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , agregando </font></font><code>&lt;Nullablegt;enable&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al grupo de propiedades en el archivo del proyecto, aparecer√°n inmediatamente en su estado actual 20 advertencias del compilador. Sin embargo, si lo uso en su lugar, </font></font><code>&lt;Nullablegt;warnings&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo recibir√© una advertencia.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Pero espera! ¬øPor qu√© se me mostrar√°n menos advertencias? Al final, acabo de pedir advertencias. La respuesta a esta pregunta no es del todo obvia: el hecho es que algunas variables y expresiones pueden ser </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulas. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neutralidad nula</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
C # admite dos interpretaciones de validez nula. En primer lugar, cualquier variable de un tipo de referencia puede declararse como admitiendo o no admitiendo </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y en segundo lugar, el compilador </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siempre </font><font style="vertical-align: inherit;">que </font><font style="vertical-align: inherit;">sea </font><font style="vertical-align: inherit;">posible concluir√° l√≥gicamente si esta variable puede o no estar </font><font style="vertical-align: inherit;">en un punto particular del c√≥digo. Este art√≠culo trata solo sobre la primera variedad de admisibilidad</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es decir, sobre el tipo est√°tico de una variable (de hecho, esto se aplica no solo a las variables y par√°metros y campos cercanos a ellos en esp√≠ritu; la admisibilidad est√°tica y l√≥gicamente deducible se </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determina para cada expresi√≥n en C #). De hecho, la admisibilidad </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en su primer sentido , el que estamos considerando es una extensi√≥n del sistema de tipos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, resulta que si nos centramos solo en la admisibilidad nula para un tipo, la situaci√≥n no ser√° tan coherente como se podr√≠a suponer. Esto no es solo un contraste entre "validez nula" e "inv√°lido</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". De hecho, hay dos posibilidades m√°s. Hay una categor√≠a de "desconocido", que es obligatoria debido a la disponibilidad de gen√©ricos; si tiene un par√°metro de tipo ilimitado, entonces no ser√° posible averiguar nada sobre la validez </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: el c√≥digo que utiliza el m√©todo o tipo generalizado apropiado puede sustituir un argumento en ellos, permitiendo o no permitiendo </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Puede agregar restricciones, pero a menudo tales restricciones no son deseables, ya que limitan el alcance del tipo o m√©todo generalizado. Entonces, para variables o expresiones de alg√∫n par√°metro de tipo ilimitado, la </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(no) validez de cero debe ser desconocida; quiz√°s, en cada caso, la cuesti√≥n de la admisibilidad</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se decidir√° por separado para ellos, pero no sabemos qu√© opci√≥n aparecer√° en el c√≥digo gen√©rico, ya que depender√° del argumento de tipo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La √∫ltima categor√≠a se llama "neutral". Seg√∫n el principio de "neutralidad", todo funcion√≥ antes del advenimiento de C # 8.0, y esto funcionar√° si no activa la capacidad de trabajar con enlaces anulables. (B√°sicamente, este es un ejemplo de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retroactividad</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aunque la idea de neutralidad nula se introdujo por primera vez en C # 8.0 como un estado natural de c√≥digo antes de activar la validez nula para las referencias, los dise√±adores de C # insistieron en que esta propiedad nunca fue realmente ajena a C #).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quiz√°s no tenga que explicar qu√© significa "neutralidad" en este caso, ya que fue en este sentido que C # siempre funcion√≥, por lo que usted mismo comprende todo ... aunque, quiz√°s, esto es un poco deshonesto. Entonces escuche: en un mundo donde se sabe acerca de la admisibilidad </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la caracter√≠stica m√°s importante de </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">las expresiones neutrales es que no provocan advertencias sobre la aceptabilidad nula. Puede asignar una expresi√≥n nula-neutral como una </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable </font><font style="vertical-align: inherit;">permitida </font><font style="vertical-align: inherit;">, pero no permitida. </font></font><code>Null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables neutrales (as√≠ como propiedades, campos, etc.), puede asignar expresiones que el compilador considera "posibles </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" o "no </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por eso, si solo activa las advertencias, entonces no hay tantas advertencias nuevas. Todo el c√≥digo permanece en el contexto de las anotaciones de validez deshabilitadas </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que todas las variables, par√°metros, campos y propiedades ser√°n </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutrales, lo que significa que no recibir√° ninguna advertencia si intenta usarlas junto con cualquier entidad que tenga en cuenta </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPor qu√©, entonces, recibo advertencias? Una raz√≥n com√∫n se debe a un intento de hacer amigos de una manera inaceptable dos piezas de c√≥digo que tienen en cuenta </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por ejemplo, supongamos que tengo una biblioteca donde los enlaces permisivos est√°n completamente incluidos </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y esta biblioteca tiene la siguiente clase profundamente ideada:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NullableAwareClass</span><font></font>
	{<font></font>
	    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">string</span>? GetNullable() =&gt; DateTime.Now.Hour &gt; <span class="hljs-number">12</span> ? <span class="hljs-literal">null</span> : <span class="hljs-string">"morning"</span>;<font></font>
	<font></font>
<font></font>
	    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">RequireNonNull</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> s</span>)</span> =&gt; s.Length;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, en otro proyecto, puedo escribir este c√≥digo en el contexto donde se activan las advertencias de validez nula, pero las anotaciones correspondientes est√°n deshabilitadas: </font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">UseString</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> x</span>)</span> =&gt; NullableAwareClass.RequireNonNull(x);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como las anotaciones sobre la validez nula est√°n deshabilitadas, el par√°metro </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠ es </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutral. </font><font style="vertical-align: inherit;">Esto significa que el compilador no puede determinar si este c√≥digo es verdadero o no. </font><font style="vertical-align: inherit;">Si el compilador emiti√≥ advertencias en los casos en que </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">las expresiones neutrales se mezclan con las que se tienen en cuenta </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, una proporci√≥n significativa de estas advertencias podr√≠a considerarse dudosa; por lo tanto, no se emiten advertencias. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con este contenedor, en realidad ocult√© el hecho de que el c√≥digo tiene en cuenta la validez </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto significa que ahora puedo escribir as√≠:</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">int</span> x = UseString(NullableAwareClass.GetNullable());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El compilador sabe lo que </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede devolver </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero como llam√© al m√©todo con un par√°metro neutral nulo, el programa no sabe si esto es correcto o incorrecto. Usando el </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contenedor neutral, desarm√© el compilador, que ahora no ve ning√∫n problema aqu√≠. Sin embargo, si combinara estos dos m√©todos directamente, todo ser√≠a diferente:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> y = NullableAwareClass.RequireNonNull(NullableAwareClass.GetNullable());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ paso el resultado </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directamente a </font></font><code>RequireNonNull</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si intentara hacer esto en un contexto donde las suposiciones nulas est√°n habilitadas, el compilador generar√≠a una advertencia, independientemente de si activ√© o desactiv√© el contexto de las anotaciones correspondientes. En este caso particular, el contexto de las anotaciones no importa, ya que no hay declaraciones con un tipo de referencia. Si habilita las advertencias sobre el supuesto de nulo, pero deshabilita las anotaciones correspondientes, todas las declaraciones se volver√°n </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutrales, lo que, sin embargo, no significa que todas las expresiones se vuelvan tales. Entonces, sabemos que el resultado </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es nulo. Por lo tanto, recibimos una advertencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resumiendo: ya que todas las declaraciones en el contexto de anotaciones deshabilitadas que permiten </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">son</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-neutral, no recibiremos muchas advertencias, ya que la mayor√≠a de las expresiones ser√°n </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-neutral. Pero el compilador a√∫n podr√° detectar errores relacionados con la suposici√≥n </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en aquellos casos en que las expresiones no pasan por alg√∫n intermediario nulo-neutral. Adem√°s, el mayor beneficio en este caso ser√° detectar errores asociados con intentos de desreferenciar valores nulos potenciales utilizando </font></font><code>.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por ejemplo:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> z = NullableAwareClass.GetNullable().Length;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si su c√≥digo est√° bien dise√±ado, entonces no deber√≠a haber una gran cantidad de errores de este tipo. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anotaci√≥n gradual de todo el proyecto</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Despu√©s de dar el primer paso: simplemente active las advertencias, luego puede proceder a la activaci√≥n gradual de las anotaciones, archivo por archivo. Es conveniente incluirlos inmediatamente en todo el proyecto, ver en qu√© archivos aparecen las advertencias y luego seleccionar un archivo en el que haya relativamente pocas advertencias. Nuevamente, ap√°guelos al nivel de todo el proyecto y escriba en la parte superior del archivo que seleccion√≥ </font></font><code>#nullable enable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esto habilitar√° completamente la suposici√≥n </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(tanto para advertencias como para anotaciones) en todo el archivo (a menos que las desactive nuevamente usando otra directiva</font></font><code>#nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Luego puede revisar todo el archivo y asegurarse de que todas las entidades que probablemente sean nulas est√©n anotadas como permitidas </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(es decir, agregar </font></font><code>?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), y luego lidiar con las advertencias en este archivo, si queda alguna. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede resultar que agregar todas las anotaciones necesarias es todo lo que se requiere para eliminar todas las advertencias. Tambi√©n es posible lo contrario: puede notar que cuando anota cuidadosamente un archivo sobre la validez</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, otras advertencias han aparecido en otros archivos que lo usan. Como regla general, no hay muchas advertencias de este tipo, y tiene tiempo para solucionarlas r√°pidamente. Pero, si por alguna raz√≥n despu√©s de este paso simplemente se ahoga en las advertencias, todav√≠a tiene un par de soluciones. En primer lugar, puede simplemente cancelar la selecci√≥n, dejar este archivo y tomar otro. En segundo lugar, puede desactivar selectivamente las anotaciones para aquellos miembros que cree que est√°n causando la mayor√≠a de los problemas. ( </font></font><code>#nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede usar la </font><font style="vertical-align: inherit;">directiva </font><font style="vertical-align: inherit;">tantas veces como lo desee, por lo que puede controlar la configuraci√≥n de validez nula, incluso l√≠nea por l√≠nea, si lo desea). Quiz√°s si regresa a este archivo m√°s tarde cuando ya active la validez nula en la mayor parte del proyecto, ver√° menos advertencias que la primera vez.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay momentos en que los problemas no se pueden resolver de una manera tan directa. </font><font style="vertical-align: inherit;">Entonces, en ciertos escenarios relacionados con la serializaci√≥n (por ejemplo, cuando se usa Json.NET o Entity Framework), el trabajo puede ser m√°s dif√≠cil. </font><font style="vertical-align: inherit;">Creo que este problema merece un art√≠culo separado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los enlaces con el supuesto </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mejoran la expresividad de su c√≥digo y aumentan las posibilidades de que el compilador detecte sus errores antes de que los usuarios se encuentren con ellos. </font><font style="vertical-align: inherit;">Por lo tanto, es mejor incluir esta caracter√≠stica si es posible. </font><font style="vertical-align: inherit;">Y, si lo incluye de forma selectiva, los beneficios comenzar√°n a sentirse m√°s r√°pido.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es501502/index.html">La nueva s√≠ntesis digital de laboratorio contin√∫a con Harris Book y ayuda a hacer un videojuego FPGA</a></li>
<li><a href="../es501506/index.html">Sobre las filtraciones de GDI y la importancia de la suerte</a></li>
<li><a href="../es501508/index.html">Maldito viejo CRM</a></li>
<li><a href="../es501510/index.html">Una nueva mirada al desarrollo de Fullstack con el marco Ruby on Rails</a></li>
<li><a href="../es501516/index.html">¬øVamos a apagar el vac√≠o? Alexey Lesovsky</a></li>
<li><a href="../es501522/index.html">Seminarios web gratuitos de Skillbox: juegos de escritura en PHP, Unity y Unreal Engine</a></li>
<li><a href="../es501524/index.html">Secretos de sincronizaci√≥n de los campos electromagn√©ticos de la Tierra y un organismo vivo.</a></li>
<li><a href="../es501526/index.html">¬øPor qu√© el ingl√©s canadiense se considera "sucio" y qu√© tiene que ver Keanu Reeves con √©l?</a></li>
<li><a href="../es501528/index.html">El libro "Bash y ciberseguridad: ataque, defensa y an√°lisis desde la l√≠nea de comando de Linux"</a></li>
<li><a href="../es501534/index.html">Ahora con COVID-19 tambi√©n hay una erupci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>