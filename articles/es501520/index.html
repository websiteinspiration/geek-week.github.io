<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📯 🛀 🔣 C # 8 y validez nula. ¿Cómo vivimos con esto? 👩‍🏫 👩🏽 🥝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¡Hola colegas! Es hora de mencionar que tenemos planes para lanzar el libro fundamental de Ian Griffiths sobre C # 8:
 
 
 Mientras tanto, en su blog,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C # 8 y validez nula. ¿Cómo vivimos con esto?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/501520/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Hola colegas! </font><font style="vertical-align: inherit;">Es hora de mencionar que tenemos planes para lanzar </font><font style="vertical-align: inherit;">el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fundamental de </font><font style="vertical-align: inherit;">Ian Griffiths sobre C # 8:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/iw/to/l-/iwtol-20o3gyqy1ppgnewp68giw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mientras tanto, en su </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blog, el</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> autor ha publicado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos </font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artículos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> relacionados </font><font style="vertical-align: inherit;">en los que considera las complejidades de los nuevos fenómenos, como la nulabilidad, el olvido y la conciencia nula. </font><font style="vertical-align: inherit;">Hemos traducido ambos artículos bajo un mismo título y sugerimos discutirlos.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La nueva característica más ambiciosa en C # 8.0 se denomina </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">referencias anulables</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El propósito de esta nueva característica es suavizar el daño de una cosa peligrosa, que el científico informático Tony Hoar llamó una vez su " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">error de mil millones de dólares</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">C # tiene una palabra clave</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(el equivalente se encuentra en muchos otros idiomas), y las raíces de esta palabra clave se remontan al lenguaje Algol W, en el desarrollo del cual participó Hoar. En este lenguaje antiguo (apareció en 1966), las variables que se refieren a instancias de cierto tipo podrían recibir un significado especial que indica que en este momento esta variable no está referenciada en ningún lado. Esta oportunidad fue muy prestada, y hoy en día muchos expertos (incluido el propio Hoar) creen que se ha convertido en la mayor fuente de costosos errores de software de todos los tiempos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué hay de malo en asumir cero? En un mundo donde cualquier enlace puede apuntar a cero, debe considerar esto siempre que se usen enlaces en su código, de lo contrario corre el riesgo de ser rechazado en el tiempo de ejecución. A veces no es demasiado pesado; si inicializa una variable con una expresión </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el mismo lugar donde la declara, entonces sabe que esta variable no es igual a cero. Pero incluso un ejemplo tan simple está cargado de cierta carga cognitiva: antes del lanzamiento de C # 8, el compilador no podía decirle si está haciendo algo que pueda convertir este valor </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pero, tan pronto como comience a unir diferentes fragmentos de código, se vuelve mucho más difícil juzgar con certeza sobre tales cosas: ¿qué tan probable es que esta propiedad que estoy leyendo ahora pueda volver </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? ¿Está permitido transmitir?</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en ese método? ¿En qué situaciones puedo estar seguro de que el método al que llamo establecerá este argumento </font></font><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en un valor diferente? Además, el asunto ni siquiera se limita a recordar revisar tales cosas; no está del todo claro qué debe hacer si se encuentra con cero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con los tipos numéricos en C # no existe tal problema: si escribe una función que toma algunos números como entrada y devuelve un número como resultado, entonces no tiene que preguntarse si los valores transmitidos son realmente números y si algo entre ellos puede confundirse. Al llamar a tal función, no es necesario pensar si puede devolver algo en lugar de un número. A menos que tal desarrollo de eventos le interese como una opción: en este caso, puede declarar parámetros o resultados del tipo</font></font><code>int?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que indica que en este caso particular realmente desea permitir la transmisión o devolución de un valor nulo. Entonces, para los tipos numéricos y, en un sentido más general, los tipos significativos, la tolerancia cero siempre ha sido una de esas cosas que se hacen voluntariamente, como una opción. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cuanto a los tipos de referencia, antes de C # 8.0, la permisibilidad de cero no solo se configuraba de manera predeterminada, sino que tampoco se podía deshabilitar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, por razones de compatibilidad con versiones anteriores, la validez cero continúa funcionando de manera predeterminada incluso en C # 8.0, porque las nuevas funciones de lenguaje en esta área permanecen deshabilitadas hasta que las solicite explícitamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, tan pronto como habilite esta nueva función, todo cambia. La forma más fácil de activarlo es agregarlo </font></font><code>&lt;Nullablegt;enable&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro del elemento.</font></font><code>&lt;PropertyGroup&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en su archivo </font></font><code>.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. (Observo que también hay disponible más control de filigrana. Si realmente lo necesita, puede configurar el comportamiento para que se permita por </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separado en cada línea. Pero, cuando recientemente decidimos incluir esta característica en todos nuestros proyectos, resultó que se activaría a escala un proyecto a la vez es una tarea factible). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando los enlaces permitidos en C # 8.0 están </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">completamente activados, la situación cambia: ahora, por defecto, se supone que los enlaces no permiten nulos solo si usted no especifica lo contrario, exactamente como con los tipos significativos ( incluso la sintaxis es la misma: podría escribir int ?, si realmente desea que el valor entero sea opcional. ¿Ahora escribe cadena ?, si quiere decir que desea una referencia de cadena o</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es un cambio muy significativo y, en primer lugar, debido a su importancia, esta nueva característica está deshabilitada de forma predeterminada. Microsoft podría haber diseñado esta función de lenguaje de manera diferente: podría dejar los enlaces predeterminados anulables e introducir una nueva sintaxis que le permitiría especificar que desea asegurarse de que no esté permitido </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Quizás esto reduciría la barra al explorar esta posibilidad, pero a la larga tal solución sería incorrecta, ya que en la práctica la mayoría de los enlaces en la gran masa de código C # no están diseñados para señalar </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Asumir cero es una excepción, no una regla, y es por eso que, cuando esta nueva función de idioma está habilitada, evitar que el nulo se convierta en un nuevo valor predeterminado. Esto se refleja incluso en el nombre de la característica original: "referencias anulables". El nombre es curioso, dado que los enlaces podrían apuntar </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a C # 1.0. Pero los desarrolladores decidieron enfatizar que ahora la suposición nula entra en la categoría de cosas que deben solicitarse explícitamente. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C # 8.0 suaviza el proceso de introducción de enlaces permisivos </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ya que le permite introducir esta función gradualmente. Uno no tiene que hacer una elección de sí o no. Esto es bastante diferente de la característica </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregada en C # 5.0, que tendió a extenderse: de hecho, las operaciones asincrónicas obligan a la persona que llama a ser</font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y, por lo tanto, el código que llama a esta persona que llama debe estar </font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y así sucesivamente, en la parte superior de la pila. Afortunadamente, los tipos que permiten </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se construyen de manera diferente: se pueden implementar de forma selectiva y gradual. Puede trabajar los archivos uno por uno, o incluso línea por línea, si es necesario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El aspecto más importante de los tipos que permiten</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(gracias a lo cual se simplifica la transición a ellos), es que por defecto están deshabilitados. De lo contrario, la mayoría de los desarrolladores se negarían a usar C # 8.0, ya que dicha transición provocaría advertencias en casi cualquier base de código. Sin embargo, por las mismas razones, el umbral de entrada para usar esta nueva característica se siente bastante alto: si una nueva característica realiza cambios tan drásticos que está deshabilitada de manera predeterminada, entonces probablemente no querrá meterse con ella, pero hay problemas asociados con cambiarla. siempre parecerá una molestia innecesaria. Pero esto sería una pena, porque la característica es muy valiosa. Ayuda a encontrar errores en el código antes de que los usuarios lo hagan por usted. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, si está considerando introducir tipos que permitan</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, asegúrese de tener en cuenta que puede introducir esta función paso a paso. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo advertencias</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
El nivel más duro de control sobre todo el proyecto después de un simple encendido / apagado es la capacidad de activar advertencias independientemente de las anotaciones. Por ejemplo, si </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habilito</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> completamente la suposición cero para </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Corvus.ContentHandling.Json</font></a><font style="vertical-align: inherit;"> en nuestro repositorio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corvus.ContentHandling</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , agregando </font></font><code>&lt;Nullablegt;enable&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al grupo de propiedades en el archivo del proyecto, aparecerán inmediatamente en su estado actual 20 advertencias del compilador. Sin embargo, si lo uso en su lugar, </font></font><code>&lt;Nullablegt;warnings&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo recibiré una advertencia.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Pero espera! ¿Por qué se me mostrarán menos advertencias? Al final, acabo de pedir advertencias. La respuesta a esta pregunta no es del todo obvia: el hecho es que algunas variables y expresiones pueden ser </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulas. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neutralidad nula</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
C # admite dos interpretaciones de validez nula. En primer lugar, cualquier variable de un tipo de referencia puede declararse como admitiendo o no admitiendo </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y en segundo lugar, el compilador </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siempre </font><font style="vertical-align: inherit;">que </font><font style="vertical-align: inherit;">sea </font><font style="vertical-align: inherit;">posible concluirá lógicamente si esta variable puede o no estar </font><font style="vertical-align: inherit;">en un punto particular del código. Este artículo trata solo sobre la primera variedad de admisibilidad</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es decir, sobre el tipo estático de una variable (de hecho, esto se aplica no solo a las variables y parámetros y campos cercanos a ellos en espíritu; la admisibilidad estática y lógicamente deducible se </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determina para cada expresión en C #). De hecho, la admisibilidad </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en su primer sentido , el que estamos considerando es una extensión del sistema de tipos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, resulta que si nos centramos solo en la admisibilidad nula para un tipo, la situación no será tan coherente como se podría suponer. Esto no es solo un contraste entre "validez nula" e "inválido</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". De hecho, hay dos posibilidades más. Hay una categoría de "desconocido", que es obligatoria debido a la disponibilidad de genéricos; si tiene un parámetro de tipo ilimitado, entonces no será posible averiguar nada sobre la validez </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: el código que utiliza el método o tipo generalizado apropiado puede sustituir un argumento en ellos, permitiendo o no permitiendo </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Puede agregar restricciones, pero a menudo tales restricciones no son deseables, ya que limitan el alcance del tipo o método generalizado. Entonces, para variables o expresiones de algún parámetro de tipo ilimitado, la </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(no) validez de cero debe ser desconocida; quizás, en cada caso, la cuestión de la admisibilidad</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se decidirá por separado para ellos, pero no sabemos qué opción aparecerá en el código genérico, ya que dependerá del argumento de tipo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La última categoría se llama "neutral". Según el principio de "neutralidad", todo funcionó antes del advenimiento de C # 8.0, y esto funcionará si no activa la capacidad de trabajar con enlaces anulables. (Básicamente, este es un ejemplo de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retroactividad</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aunque la idea de neutralidad nula se introdujo por primera vez en C # 8.0 como un estado natural de código antes de activar la validez nula para las referencias, los diseñadores de C # insistieron en que esta propiedad nunca fue realmente ajena a C #).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quizás no tenga que explicar qué significa "neutralidad" en este caso, ya que fue en este sentido que C # siempre funcionó, por lo que usted mismo comprende todo ... aunque, quizás, esto es un poco deshonesto. Entonces escuche: en un mundo donde se sabe acerca de la admisibilidad </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la característica más importante de </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">las expresiones neutrales es que no provocan advertencias sobre la aceptabilidad nula. Puede asignar una expresión nula-neutral como una </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable </font><font style="vertical-align: inherit;">permitida </font><font style="vertical-align: inherit;">, pero no permitida. </font></font><code>Null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables neutrales (así como propiedades, campos, etc.), puede asignar expresiones que el compilador considera "posibles </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" o "no </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por eso, si solo activa las advertencias, entonces no hay tantas advertencias nuevas. Todo el código permanece en el contexto de las anotaciones de validez deshabilitadas </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que todas las variables, parámetros, campos y propiedades serán </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutrales, lo que significa que no recibirá ninguna advertencia si intenta usarlas junto con cualquier entidad que tenga en cuenta </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Por qué, entonces, recibo advertencias? Una razón común se debe a un intento de hacer amigos de una manera inaceptable dos piezas de código que tienen en cuenta </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por ejemplo, supongamos que tengo una biblioteca donde los enlaces permisivos están completamente incluidos </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y esta biblioteca tiene la siguiente clase profundamente ideada:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NullableAwareClass</span><font></font>
	{<font></font>
	    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">string</span>? GetNullable() =&gt; DateTime.Now.Hour &gt; <span class="hljs-number">12</span> ? <span class="hljs-literal">null</span> : <span class="hljs-string">"morning"</span>;<font></font>
	<font></font>
<font></font>
	    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">RequireNonNull</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> s</span>)</span> =&gt; s.Length;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, en otro proyecto, puedo escribir este código en el contexto donde se activan las advertencias de validez nula, pero las anotaciones correspondientes están deshabilitadas: </font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">UseString</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> x</span>)</span> =&gt; NullableAwareClass.RequireNonNull(x);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como las anotaciones sobre la validez nula están deshabilitadas, el parámetro </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí es </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutral. </font><font style="vertical-align: inherit;">Esto significa que el compilador no puede determinar si este código es verdadero o no. </font><font style="vertical-align: inherit;">Si el compilador emitió advertencias en los casos en que </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">las expresiones neutrales se mezclan con las que se tienen en cuenta </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, una proporción significativa de estas advertencias podría considerarse dudosa; por lo tanto, no se emiten advertencias. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con este contenedor, en realidad oculté el hecho de que el código tiene en cuenta la validez </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto significa que ahora puedo escribir así:</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">int</span> x = UseString(NullableAwareClass.GetNullable());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El compilador sabe lo que </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede devolver </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero como llamé al método con un parámetro neutral nulo, el programa no sabe si esto es correcto o incorrecto. Usando el </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contenedor neutral, desarmé el compilador, que ahora no ve ningún problema aquí. Sin embargo, si combinara estos dos métodos directamente, todo sería diferente:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> y = NullableAwareClass.RequireNonNull(NullableAwareClass.GetNullable());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí paso el resultado </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directamente a </font></font><code>RequireNonNull</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si intentara hacer esto en un contexto donde las suposiciones nulas están habilitadas, el compilador generaría una advertencia, independientemente de si activé o desactivé el contexto de las anotaciones correspondientes. En este caso particular, el contexto de las anotaciones no importa, ya que no hay declaraciones con un tipo de referencia. Si habilita las advertencias sobre el supuesto de nulo, pero deshabilita las anotaciones correspondientes, todas las declaraciones se volverán </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutrales, lo que, sin embargo, no significa que todas las expresiones se vuelvan tales. Entonces, sabemos que el resultado </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es nulo. Por lo tanto, recibimos una advertencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resumiendo: ya que todas las declaraciones en el contexto de anotaciones deshabilitadas que permiten </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">son</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-neutral, no recibiremos muchas advertencias, ya que la mayoría de las expresiones serán </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-neutral. Pero el compilador aún podrá detectar errores relacionados con la suposición </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en aquellos casos en que las expresiones no pasan por algún intermediario nulo-neutral. Además, el mayor beneficio en este caso será detectar errores asociados con intentos de desreferenciar valores nulos potenciales utilizando </font></font><code>.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por ejemplo:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> z = NullableAwareClass.GetNullable().Length;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si su código está bien diseñado, entonces no debería haber una gran cantidad de errores de este tipo. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anotación gradual de todo el proyecto</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Después de dar el primer paso: simplemente active las advertencias, luego puede proceder a la activación gradual de las anotaciones, archivo por archivo. Es conveniente incluirlos inmediatamente en todo el proyecto, ver en qué archivos aparecen las advertencias y luego seleccionar un archivo en el que haya relativamente pocas advertencias. Nuevamente, apáguelos al nivel de todo el proyecto y escriba en la parte superior del archivo que seleccionó </font></font><code>#nullable enable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esto habilitará completamente la suposición </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(tanto para advertencias como para anotaciones) en todo el archivo (a menos que las desactive nuevamente usando otra directiva</font></font><code>#nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Luego puede revisar todo el archivo y asegurarse de que todas las entidades que probablemente sean nulas estén anotadas como permitidas </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(es decir, agregar </font></font><code>?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), y luego lidiar con las advertencias en este archivo, si queda alguna. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede resultar que agregar todas las anotaciones necesarias es todo lo que se requiere para eliminar todas las advertencias. También es posible lo contrario: puede notar que cuando anota cuidadosamente un archivo sobre la validez</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, otras advertencias han aparecido en otros archivos que lo usan. Como regla general, no hay muchas advertencias de este tipo, y tiene tiempo para solucionarlas rápidamente. Pero, si por alguna razón después de este paso simplemente se ahoga en las advertencias, todavía tiene un par de soluciones. En primer lugar, puede simplemente cancelar la selección, dejar este archivo y tomar otro. En segundo lugar, puede desactivar selectivamente las anotaciones para aquellos miembros que cree que están causando la mayoría de los problemas. ( </font></font><code>#nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede usar la </font><font style="vertical-align: inherit;">directiva </font><font style="vertical-align: inherit;">tantas veces como lo desee, por lo que puede controlar la configuración de validez nula, incluso línea por línea, si lo desea). Quizás si regresa a este archivo más tarde cuando ya active la validez nula en la mayor parte del proyecto, verá menos advertencias que la primera vez.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay momentos en que los problemas no se pueden resolver de una manera tan directa. </font><font style="vertical-align: inherit;">Entonces, en ciertos escenarios relacionados con la serialización (por ejemplo, cuando se usa Json.NET o Entity Framework), el trabajo puede ser más difícil. </font><font style="vertical-align: inherit;">Creo que este problema merece un artículo separado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los enlaces con el supuesto </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mejoran la expresividad de su código y aumentan las posibilidades de que el compilador detecte sus errores antes de que los usuarios se encuentren con ellos. </font><font style="vertical-align: inherit;">Por lo tanto, es mejor incluir esta característica si es posible. </font><font style="vertical-align: inherit;">Y, si lo incluye de forma selectiva, los beneficios comenzarán a sentirse más rápido.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es501502/index.html">La nueva síntesis digital de laboratorio continúa con Harris Book y ayuda a hacer un videojuego FPGA</a></li>
<li><a href="../es501506/index.html">Sobre las filtraciones de GDI y la importancia de la suerte</a></li>
<li><a href="../es501508/index.html">Maldito viejo CRM</a></li>
<li><a href="../es501510/index.html">Una nueva mirada al desarrollo de Fullstack con el marco Ruby on Rails</a></li>
<li><a href="../es501516/index.html">¿Vamos a apagar el vacío? Alexey Lesovsky</a></li>
<li><a href="../es501522/index.html">Seminarios web gratuitos de Skillbox: juegos de escritura en PHP, Unity y Unreal Engine</a></li>
<li><a href="../es501524/index.html">Secretos de sincronización de los campos electromagnéticos de la Tierra y un organismo vivo.</a></li>
<li><a href="../es501526/index.html">¿Por qué el inglés canadiense se considera "sucio" y qué tiene que ver Keanu Reeves con él?</a></li>
<li><a href="../es501528/index.html">El libro "Bash y ciberseguridad: ataque, defensa y análisis desde la línea de comando de Linux"</a></li>
<li><a href="../es501534/index.html">Ahora con COVID-19 también hay una erupción</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>