<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏿 🎐 👩🏿‍🍳 GUI in Russisch oder VKS-Terminal selbst machen 💂 🔫 🐬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Erfahrung in der Entwicklung einer C ++ - GUI für das russische Videokonferenzsystem (VKS). Die Synthese moderner Technologie- und Zertifizierungsanfo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GUI in Russisch oder VKS-Terminal selbst machen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/protei/blog/504894/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfahrung in der Entwicklung einer C ++ - GUI für das russische Videokonferenzsystem (VKS). </font><font style="vertical-align: inherit;">Die Synthese moderner Technologie- und Zertifizierungsanforderungen. </font><font style="vertical-align: inherit;">Der Haupt- "Rechen" der Entwicklung und Wege, um sie zu umgehen. </font><font style="vertical-align: inherit;">Was haben die GUI und das russische Ballett gemeinsam? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste, was der Benutzer des Videokonferenzsystems sieht, ist die Schnittstelle. </font><font style="vertical-align: inherit;">In den meisten Fällen beurteilen sie das System anhand seines Erscheinungsbilds und seiner Funktionalität. </font><font style="vertical-align: inherit;">Eine unbequeme oder weitläufige Benutzeroberfläche ermöglicht es nicht, die hohe Systemleistung oder die breite Funktionalität zu bewerten. </font><font style="vertical-align: inherit;">Technisch gesehen sollte ein „schönes“ System in eine attraktive und stabile Arbeitsschale eingewickelt werden. </font><font style="vertical-align: inherit;">Daher wurde zu Beginn der Entwicklung des inländischen VKS-Systems dieser Moment sofort berücksichtigt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mq/zf/vr/mqzfvrwj1mk6anlm3rjpjg44ngw.png" alt="Bild"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wer wird der Benutzer des russischen Videokonferenzsystems sein?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seit dem Frühjahr 2020 ist die Antwort auf die Frage nach der Zweckmäßigkeit der Entwicklung eines vollwertigen VKS-Systems offensichtlich geworden. Beamte, Handelsunternehmen, Krankenhäuser und Schulen benötigen moderne Kommunikationsmittel mit einem gewissen Maß an Produktivität und Sicherheit. Sie können in Zoom sprechen, aber lohnt es sich, es für ernsthafte Handelsverhandlungen oder ein operatives Treffen von Managern zu verwenden?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für verschiedene Aufgaben russischer Unternehmen wurde es notwendig, ein inländisches Videokonferenzsystem zu schaffen. </font><font style="vertical-align: inherit;">Darüber hinaus besteht ein System nicht nur aus einer Softwarekomponente, sondern auch aus einer vollwertigen Hardware. </font><font style="vertical-align: inherit;">Unter den weltberühmten Anbietern bieten mindestens 5 Unternehmen multifunktionale Videokonferenzsysteme an. </font><font style="vertical-align: inherit;">In Russland beginnt das Konzept der Importsubstitution jedoch allmählich zu funktionieren. </font><font style="vertical-align: inherit;">Außerdem sind Sicherheitsprobleme für viele wichtiger geworden als das Herkunftsland des Produkts, und der Preis zu aktuellen Wechselkursen steht nicht an letzter Stelle. </font><font style="vertical-align: inherit;">Und die "Schönheit" der Benutzeroberfläche erwies sich als ziemlich realistisch, um sie von Grund auf neu zu entwickeln.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GUI beim Start</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptanforderungen an moderne Schnittstellen sind die schnelle Implementierung, das aktuelle Erscheinungsbild und die vollständige Benutzerfreundlichkeit. </font><font style="vertical-align: inherit;">Daher war die erste Aufgabe der Entwickler der grafischen Benutzeroberfläche (GUI) eine klare Definition der Softwarefunktionalität für die Videokonferenzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Sicht der GUI wurden folgende Anforderungen formuliert:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausgehende Video- / Audioanrufe tätigen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eingehende Anrufe annehmen / ablehnen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Automatische Beantwortung eines eingehenden Anrufs in einem benutzerdefinierten Zeitintervall;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wechseln Sie während und außerhalb des Anrufs zwischen zwei Audiogeräten (Headset / Freisprecheinrichtung).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schalten Sie das Mikrofon und die Kamera sowohl während als auch außerhalb des Anrufs ein / aus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DTMF-Wahl während eines Anrufs;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konferenztreffen am Terminal;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwaltung von PTZ-Kameras, Speichern von PTZ-Voreinstellungen und deren Anwendung;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Möglichkeit, Videos in verschiedenen Fenstern auszugeben;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Steuermaus, Tastatur, Fernbedienung;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Möglichkeit, das Terminal über die Webschnittstelle fernzusteuern.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Liste von Funktionen können Sie das Problem der Entwicklung einer Schnittstelle auf verschiedene Arten lösen. </font><font style="vertical-align: inherit;">Darüber hinaus wurde die Auswahl eines bestimmten Implementierungstyps durch Einschränkungen der Art der Programmiersprachen (z. B. war Java aus Zertifizierungsgründen, CSS / HTML - je nach Funktionalität - kategorisch nicht geeignet), die Spezialisierung der Entwickler und das Timing beeinflusst. </font><font style="vertical-align: inherit;">Insgesamt wurde die Wahl zugunsten von C ++ und der Verwendung des Qt5-Frameworks getroffen, da beispielsweise die modernere QML-Technologie das Rendern von Videos in einem beliebigen OpenGL-Kontext nicht zulässt, was laut ToR für VKS-Terminals erforderlich war.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f6/gd/lr/f6gdlr-u2n2ncctyiqjss5zloty.png" alt="Bild"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schnell und effizient</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste GUI-Prototyp wurde für das Softphone von Qt erstellt und verwendete viele Open-Source-Bibliotheken. </font><font style="vertical-align: inherit;">Beispielsweise wurden für das SIP-Protokoll eXosip / oSIP-Bibliotheken zum Codieren / Decodieren von Video und Audio - ffmpeg - zum Arbeiten mit Audiogeräten - PortAudio - verwendet. </font><font style="vertical-align: inherit;">Dieses Softphone funktionierte unter Linux, Windows, MacOS und war ein Technologiedemonstrator und kein echtes Gerät. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Später wurde ein abstraktes Softphone in ein echtes Bildtelefonprojekt umgewandelt, und die erste Version der Software dafür sollte 2 Monate nach dem Start erstellt worden sein. </font><font style="vertical-align: inherit;">Um dieses Problem in so kurzer Zeit zu lösen, wurde die Telefonsoftware in Module unterteilt und entsprechend den Kompetenzen auf mehrere Entwicklergruppen verteilt. </font><font style="vertical-align: inherit;">Eine solche Organisation des Prozesses trug dazu bei, das Bildtelefonprojekt schnell und effizient zu entwickeln.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kern und Front</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Vereinheitlichung und zur Möglichkeit, vorhandene GUI-Entwicklungen in anderen Geräten aus einem vorhandenen Projekt zu verwenden, befindet sich die gemeinsame Codebasis in einem separaten Modul - dem GUI-Backend oder dem GUI-Kernmodul. </font><font style="vertical-align: inherit;">Und direkte Darstellungen, die für verschiedene Geräte unterschiedlich sind, werden in separaten GUI-Frontmodulen implementiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Architektur der GUI-Module erwies sich als vorteilhaft und führte zum gewünschten Ergebnis: Die Entwicklung von Schnittstellen für die neuen Komponenten des VKS-Systems selbst ist relativ schnell und qualitativ hochwertig geworden. </font><font style="vertical-align: inherit;">Schließlich mussten die Schnittstellen für VKS-Terminals jetzt nicht mehr von Grund auf neu geschrieben werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qual und Sieg</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf dem Weg zur Erstellung von Software gibt es natürlich Schwierigkeiten und Probleme. </font><font style="vertical-align: inherit;">Das Erstellen einer GUI für die Videokonferenzen war keine Ausnahme. </font><font style="vertical-align: inherit;">Unabhängig vom spezifischen Zweck des Systems können sie in jedem Befehl wiederholt werden. </font><font style="vertical-align: inherit;">Schwierigkeiten und Siege auf dem Entwicklungspfad sind für Kollegen interessant und führen möglicherweise zu effektiven Lösungen ohne unseren „Rechen“.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für immer Konsistenz</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Historisch gesehen war das allererste interessante Problem, das während der Entwicklung der GUI für verschiedene Arten von VKS-Terminals auftrat, das Problem der Konsistenz, dh des koordinierten Zustands aller Module. </font><font style="vertical-align: inherit;">Während des Betriebs interagiert die GUI mit mehreren anderen Modulen: einem Modul für die Interaktion mit Hardware, einem Anrufverwaltungssubsystem, einem Medienverarbeitungsmodul (MCU) und einem Benutzerinteraktionssubsystem.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/xp/5b/csxp5bydmvx6vi9eviyuxg8-d3k.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anfänglich arbeitete die GUI mit all diesen Modulen als unabhängig, dh sie konnte gleichzeitig Anforderungen an zwei verschiedene Module senden. Dies stellte sich als falsch heraus und führte manchmal zu Problemen, da diese Module selbst nicht unabhängig waren und aktiv miteinander interagierten. Die Lösung des Problems war die Erstellung eines speziellen Arbeitsschemas, das eine streng sequentielle Ausführung der Anforderungen in allen Modulen sicherstellte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gab zwei Schwierigkeiten beim Hinzufügen: Erstens erfordern einige (aber nicht alle) Anforderungen eine Antwort, in deren Erwartung sich das Terminal tatsächlich in einem inkonsistenten Zustand befindet, sodass andere Anforderungen nicht ausgeführt werden können. Es ist jedoch auch unerwünscht, die Benutzeroberfläche zu blockieren, während auf Antworten gewartet wird. Zweitens kommen Antworten auf GUI-Anforderungen von Modulen sowie Anforderungen von Modulen an die GUI in ihren eigenen Threads, die sich von der GUI unterscheiden. Die GUI muss jedoch alle Änderungen in ihrem Status in ihrem Thread implementieren (Qt erfordert dies für einige Aktionen, jedoch in In einigen Fällen werden dadurch unnötige Schwierigkeiten bei der Gewährleistung der Thread-Synchronisation vermieden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Lösung wurde gefunden und bestand aus zwei Teilen. Zunächst wurden alle Anforderungen / Antworten von anderen Modulen mithilfe des Qt-Signalschlitzmechanismus in Verbindung mit QueuedConnection, dh mithilfe der globalen QApplication-Ereignisschleife, an den GUI-Stream umgeleitet. Um eine konsistente Verarbeitung aller Anforderungen zu gewährleisten, wurde ein Transitions-System mit einer eigenen Warteschlange und einem eigenen Verarbeitungszyklus (TransitionLoop) entwickelt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Benutzer eine Aktionstaste in der GUI drückt (z. B. die Anruftaste), wird ein entsprechender Übergang erstellt, der in die Übergangswarteschlange gestellt wird. Danach wird ein Signal für den Übergangsverarbeitungszyklus erzeugt. TransitionLoop prüft beim Empfang eines Signals, ob gerade ein Übergang stattfindet. Wenn dies der Fall ist, wird das Warten auf den Abschluss des aktuellen Übergangs fortgesetzt. Wenn nicht, wird der nächste Übergang aus der Übergangswarteschlange abgerufen und gestartet. Wenn eine Antwort von einem anderen TransitionLoop-Modul mit demselben Signal empfangen wird, wird der Abschluss des aktuellen Übergangs benachrichtigt und TransitionLoop kann den nächsten Übergang aus der Warteschlange starten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wichtig hierbei ist, dass die gesamte Übergangsverarbeitung in einem GUI-Thread erfolgt. </font><font style="vertical-align: inherit;">Dies wird durch die Verwendung des Qt-Signalschlitzmechanismus in der QueuedConnection-Variante sichergestellt, bei dem für jedes Signal ein Ereignis generiert und in der Hauptereignisschleife der Anwendung platziert wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL-Rendering auf stromsparender Hardware</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere Schwierigkeit, mit der wir uns befassen mussten, war das Problem beim Rendern von Videos. Qt ermöglicht das OpenGL-Rendern einer speziellen QOpenGLWidget-Klasse und verwandter Hilfsklassen, die ursprünglich zum Rendern von Videos verwendet wurden. Die Daten zum Rendern (decodierte Videobilder) selbst werden vom Medienverarbeitungsmodul (MCU) bereitgestellt, das unter anderem die Hardware-Decodierung des Videostreams (auf der GPU) implementiert. Bei Prozessoren mit geringem Stromverbrauch wurde eine "Verlangsamung" des Renderns von FullHD-Videos festgestellt. Die direkte Lösung bestand darin, den Prozessor auszutauschen. Dies würde jedoch eine ernsthafte Verarbeitung der bereits fertigen Komponenten des Videokonferenzsystems erfordern und die Kosten für die Geräte selbst erhöhen. Daher wurde der gesamte Renderprozess sorgfältig analysiert, um bessere Möglichkeiten zur Lösung des Problems zu finden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Standard-OpenGL-Rendering und der Hardware-Decodierung geschieht Folgendes: Daten mit codiertem Video stammen aus dem Netzwerk, werden im RAM gespeichert, und diese Daten aus dem RAM werden in den Videospeicher der GPU übertragen, wo sie decodiert werden. Dann werden decodierte Daten mit einem wesentlich größeren Volumen als codierte Daten erneut in den RAM übertragen. Als nächstes kommt ein Rendering-Code ins Spiel, der diese Daten vom RAM direkt zum Rendern zurück zur GPU überträgt. Somit werden ziemlich große Datenmengen durch den Speicherbus hin und her gepumpt, und der Bus kann dies einfach nicht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In modernen Versionen von OpenGL gibt es spezielle Erweiterungen, mit denen Sie festlegen können, dass Daten gerendert werden sollen, die sich bereits im GPU-Speicher befinden, und nicht wie üblich Daten im Haupt-RAM. Dieser Mechanismus schloss das Verschieben von Daten von Hardware-decodierten Frames von der GPU in den RAM und dann zurück aus. Damit war das Problem des Renderns auf Prozessoren mit geringem Stromverbrauch nahezu gelöst.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ta/gx/rr/tagxrr-ydgiw9vlbucxyvli2jni.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres großes Problem waren die in Qt unterstützten OpenGL-Kontexte. Sie können die erforderliche OpenGL-Erweiterung nicht verwenden, dh Sie können QOpenGLWidget mit dieser Option nicht verwenden. Die Lösung bestand darin, ein reguläres QWidget zu verwenden, die Qt-Rendering-Pipeline jedoch auszuschalten. Eine solche Möglichkeit besteht in Qt. Hier stellte sich jedoch eine Frage, da bei dieser Option die GUI für das gesamte Rendern im Bereich dieses Widgets voll verantwortlich ist. Qt hilft uns nicht. Dies ist normal für die Anzeige von Videos. Für die Verwendung von Widgets über Videos können jedoch keine regulären Qt-Tools verwendet werden, da beispielsweise über dem Video ein zusätzliches Popup-Menü angezeigt werden muss.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Problem wurde wie folgt gelöst: Aus dem vorhandenen Widget wird das Bild abgerufen (QWidget verfügt hierfür über eine grab () -Methode), das resultierende Bild wird in eine OpenGL-Textur konvertiert und letztere mit OpenGL-Tools über dem Video gerendert. </font><font style="vertical-align: inherit;">Durch Hinzufügen der entsprechenden Umgebung wurde ein universeller Mechanismus implementiert, mit dem alle Standard-Widgets über dem Video auf eine nicht standardmäßige Weise angezeigt werden können.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kioske und Widgets</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verwaltung von Anzeigen und die Verteilung von Fragmenten der Benutzeroberfläche im Kiosk-Modus war nicht einfach. Das VKS-Terminal kann in zwei Modi betrieben werden: Fenstermodus, dh wie jede andere Fensteranwendung in der Desktop-Umgebung des Betriebssystems, und „Kiosk-Modus“ (dh das Betriebssystem führt nur eine Anwendung mit einer grafischen Oberfläche aus - VKST - und es gibt keine Umgebung Desktop).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Fenstermodus ist alles relativ einfach: Das Fenster wird vom Fenstermanager der Desktop-Umgebung gesteuert, die Anwendung erstellt bei Bedarf ein zweites Fenster und der Benutzer verteilt die Fenster auf den Displays nach Bedarf. Im „Kiosk“ -Modus ist jedoch alles viel komplizierter, da das System keinen Fenstermanager hat und es nur ein Fenster geben kann und der Benutzer nicht in der Lage ist, es zu verschieben. Daher erschien die Aufgabe, ein Ereignis automatisch zu erkennen, beispielsweise eine Anzeige zu verbinden / zu trennen. Bei diesem Ereignis mussten die Anzeigen automatisch konfiguriert und Fragmente der Benutzeroberfläche korrekt darauf platziert werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-x/dm/w_/-xdmw_fvqpxs-frj0pl04wszabg.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Antwort kam von der LINUX Xrandr OS-Systembibliothek, die für die Arbeit mit Displays verantwortlich ist. Da es im Internet nur sehr wenige Dokumentationen gibt, wurde die Implementierung anhand von Beispielen aus dem Internet durchgeführt, einschließlich von Habr. Darüber hinaus war es notwendig, einen Algorithmus zum Verteilen von Schnittstellenfragmenten auf Displays zu entwickeln und zwei verschiedene Fenster in ein einziges zu integrieren. Letzteres wurde wie folgt implementiert: Was sind Fenster im Fenstermodus, im "Kiosk" -Modus sind Widgets in einem großen Fenster, das sich über 2 Anzeigen erstreckt (wenn es 2 davon gibt). In diesem Fall müssen Sie die Positionen der Anzeigen so konfigurieren, dass ein kontinuierlicher virtueller Raum erstellt wird (dies erfolgt mithilfe der XRandr-Bibliothek), und dann die Geometrie der internen Widgets in einem einzelnen globalen Fenster festlegendamit jeder auf sein Display kommt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir schaffen Russisch</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die gesamte Art der Erstellung des russischen Videokonferenzsystems bestand aus vielen Phasen, und die grafische Benutzeroberfläche ist nur die Spitze des Eisbergs. </font><font style="vertical-align: inherit;">Das Auffälligste und nicht das Schwierigste. </font><font style="vertical-align: inherit;">Die Komplexität der Lösung, die Kombination von Software und Hardware sowie Softwarekomponenten und der Wunsch, ein technisch und ästhetisch „schönes“ System zu schaffen, verursachten jedoch viele Schwierigkeiten. </font><font style="vertical-align: inherit;">Neue Aufgaben führten zu nicht standardmäßigen Lösungen und trugen dazu bei, ein Produkt zu schaffen, das sich nicht schämt, nicht nur in Russland, sondern auch im Ausland zu zeigen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Russische Entwicklungen haben sich seit langem bewährt, und das in einer schönen Hülle und Wettbewerbsfähigkeit. </font><font style="vertical-align: inherit;">Unsere Life-Hacks werden für alle nützlich sein, die ernsthaft an der Entwicklung von GUI beteiligt sind, und wir hoffen, dass sie anderen Entwicklern helfen werden, den Prozess der Erstellung moderner Shells für neue russische Softwareprodukte zu beschleunigen und zu vereinfachen. </font><font style="vertical-align: inherit;">Wir glauben, dass russische Entscheidungen in der Welt nicht weniger geschätzt werden als russisches Ballett oder schwarzer Kaviar.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de504880/index.html">Entwicklung, Optimierung und Veröffentlichung von Synthety-Spielen auf Unity</a></li>
<li><a href="../de504884/index.html">Gefährliche Peripheriegeräte: Thunderspy verstehen</a></li>
<li><a href="../de504886/index.html">Selenium WebDriver im Dienste des Entwicklers</a></li>
<li><a href="../de504888/index.html">"Ruhig, nur ruhig!" oder weniger Sorgen</a></li>
<li><a href="../de504890/index.html">Rückgabewert vom Powershell-Aufrufbefehl an den SQL Server-Agenten</a></li>
<li><a href="../de504902/index.html">Top 9 Trends im automatisierten Testen im Jahr 2020</a></li>
<li><a href="../de504906/index.html">PHP - Was ist die Nische der Sprache und wird PHP8 helfen, drängende Probleme zu lösen (Spoiler: IMHO nicht)</a></li>
<li><a href="../de504908/index.html">PyTrace - Zeitreise-Debugger für Python</a></li>
<li><a href="../de504912/index.html">HackTheBox-Endspiel. Passage des Labors Professionelle Offensivoperationen. Pentest Active Directory</a></li>
<li><a href="../de504918/index.html">Die effektivsten Online-Unterrichtsdienste für Schüler und Lehrer: die Top 5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>