<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëµüèø üéê üë©üèø‚Äçüç≥ GUI in Russisch oder VKS-Terminal selbst machen üíÇ üî´ üê¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Erfahrung in der Entwicklung einer C ++ - GUI f√ºr das russische Videokonferenzsystem (VKS). Die Synthese moderner Technologie- und Zertifizierungsanfo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GUI in Russisch oder VKS-Terminal selbst machen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/protei/blog/504894/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfahrung in der Entwicklung einer C ++ - GUI f√ºr das russische Videokonferenzsystem (VKS). </font><font style="vertical-align: inherit;">Die Synthese moderner Technologie- und Zertifizierungsanforderungen. </font><font style="vertical-align: inherit;">Der Haupt- "Rechen" der Entwicklung und Wege, um sie zu umgehen. </font><font style="vertical-align: inherit;">Was haben die GUI und das russische Ballett gemeinsam? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste, was der Benutzer des Videokonferenzsystems sieht, ist die Schnittstelle. </font><font style="vertical-align: inherit;">In den meisten F√§llen beurteilen sie das System anhand seines Erscheinungsbilds und seiner Funktionalit√§t. </font><font style="vertical-align: inherit;">Eine unbequeme oder weitl√§ufige Benutzeroberfl√§che erm√∂glicht es nicht, die hohe Systemleistung oder die breite Funktionalit√§t zu bewerten. </font><font style="vertical-align: inherit;">Technisch gesehen sollte ein ‚Äûsch√∂nes‚Äú System in eine attraktive und stabile Arbeitsschale eingewickelt werden. </font><font style="vertical-align: inherit;">Daher wurde zu Beginn der Entwicklung des inl√§ndischen VKS-Systems dieser Moment sofort ber√ºcksichtigt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mq/zf/vr/mqzfvrwj1mk6anlm3rjpjg44ngw.png" alt="Bild"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wer wird der Benutzer des russischen Videokonferenzsystems sein?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seit dem Fr√ºhjahr 2020 ist die Antwort auf die Frage nach der Zweckm√§√üigkeit der Entwicklung eines vollwertigen VKS-Systems offensichtlich geworden. Beamte, Handelsunternehmen, Krankenh√§user und Schulen ben√∂tigen moderne Kommunikationsmittel mit einem gewissen Ma√ü an Produktivit√§t und Sicherheit. Sie k√∂nnen in Zoom sprechen, aber lohnt es sich, es f√ºr ernsthafte Handelsverhandlungen oder ein operatives Treffen von Managern zu verwenden?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr verschiedene Aufgaben russischer Unternehmen wurde es notwendig, ein inl√§ndisches Videokonferenzsystem zu schaffen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus besteht ein System nicht nur aus einer Softwarekomponente, sondern auch aus einer vollwertigen Hardware. </font><font style="vertical-align: inherit;">Unter den weltber√ºhmten Anbietern bieten mindestens 5 Unternehmen multifunktionale Videokonferenzsysteme an. </font><font style="vertical-align: inherit;">In Russland beginnt das Konzept der Importsubstitution jedoch allm√§hlich zu funktionieren. </font><font style="vertical-align: inherit;">Au√üerdem sind Sicherheitsprobleme f√ºr viele wichtiger geworden als das Herkunftsland des Produkts, und der Preis zu aktuellen Wechselkursen steht nicht an letzter Stelle. </font><font style="vertical-align: inherit;">Und die "Sch√∂nheit" der Benutzeroberfl√§che erwies sich als ziemlich realistisch, um sie von Grund auf neu zu entwickeln.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GUI beim Start</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptanforderungen an moderne Schnittstellen sind die schnelle Implementierung, das aktuelle Erscheinungsbild und die vollst√§ndige Benutzerfreundlichkeit. </font><font style="vertical-align: inherit;">Daher war die erste Aufgabe der Entwickler der grafischen Benutzeroberfl√§che (GUI) eine klare Definition der Softwarefunktionalit√§t f√ºr die Videokonferenzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Sicht der GUI wurden folgende Anforderungen formuliert:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausgehende Video- / Audioanrufe t√§tigen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eingehende Anrufe annehmen / ablehnen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Automatische Beantwortung eines eingehenden Anrufs in einem benutzerdefinierten Zeitintervall;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wechseln Sie w√§hrend und au√üerhalb des Anrufs zwischen zwei Audioger√§ten (Headset / Freisprecheinrichtung).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schalten Sie das Mikrofon und die Kamera sowohl w√§hrend als auch au√üerhalb des Anrufs ein / aus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DTMF-Wahl w√§hrend eines Anrufs;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konferenztreffen am Terminal;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwaltung von PTZ-Kameras, Speichern von PTZ-Voreinstellungen und deren Anwendung;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die M√∂glichkeit, Videos in verschiedenen Fenstern auszugeben;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Steuermaus, Tastatur, Fernbedienung;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die M√∂glichkeit, das Terminal √ºber die Webschnittstelle fernzusteuern.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Liste von Funktionen k√∂nnen Sie das Problem der Entwicklung einer Schnittstelle auf verschiedene Arten l√∂sen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus wurde die Auswahl eines bestimmten Implementierungstyps durch Einschr√§nkungen der Art der Programmiersprachen (z. B. war Java aus Zertifizierungsgr√ºnden, CSS / HTML - je nach Funktionalit√§t - kategorisch nicht geeignet), die Spezialisierung der Entwickler und das Timing beeinflusst. </font><font style="vertical-align: inherit;">Insgesamt wurde die Wahl zugunsten von C ++ und der Verwendung des Qt5-Frameworks getroffen, da beispielsweise die modernere QML-Technologie das Rendern von Videos in einem beliebigen OpenGL-Kontext nicht zul√§sst, was laut ToR f√ºr VKS-Terminals erforderlich war.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f6/gd/lr/f6gdlr-u2n2ncctyiqjss5zloty.png" alt="Bild"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schnell und effizient</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste GUI-Prototyp wurde f√ºr das Softphone von Qt erstellt und verwendete viele Open-Source-Bibliotheken. </font><font style="vertical-align: inherit;">Beispielsweise wurden f√ºr das SIP-Protokoll eXosip / oSIP-Bibliotheken zum Codieren / Decodieren von Video und Audio - ffmpeg - zum Arbeiten mit Audioger√§ten - PortAudio - verwendet. </font><font style="vertical-align: inherit;">Dieses Softphone funktionierte unter Linux, Windows, MacOS und war ein Technologiedemonstrator und kein echtes Ger√§t. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sp√§ter wurde ein abstraktes Softphone in ein echtes Bildtelefonprojekt umgewandelt, und die erste Version der Software daf√ºr sollte 2 Monate nach dem Start erstellt worden sein. </font><font style="vertical-align: inherit;">Um dieses Problem in so kurzer Zeit zu l√∂sen, wurde die Telefonsoftware in Module unterteilt und entsprechend den Kompetenzen auf mehrere Entwicklergruppen verteilt. </font><font style="vertical-align: inherit;">Eine solche Organisation des Prozesses trug dazu bei, das Bildtelefonprojekt schnell und effizient zu entwickeln.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kern und Front</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Vereinheitlichung und zur M√∂glichkeit, vorhandene GUI-Entwicklungen in anderen Ger√§ten aus einem vorhandenen Projekt zu verwenden, befindet sich die gemeinsame Codebasis in einem separaten Modul - dem GUI-Backend oder dem GUI-Kernmodul. </font><font style="vertical-align: inherit;">Und direkte Darstellungen, die f√ºr verschiedene Ger√§te unterschiedlich sind, werden in separaten GUI-Frontmodulen implementiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Architektur der GUI-Module erwies sich als vorteilhaft und f√ºhrte zum gew√ºnschten Ergebnis: Die Entwicklung von Schnittstellen f√ºr die neuen Komponenten des VKS-Systems selbst ist relativ schnell und qualitativ hochwertig geworden. </font><font style="vertical-align: inherit;">Schlie√ülich mussten die Schnittstellen f√ºr VKS-Terminals jetzt nicht mehr von Grund auf neu geschrieben werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qual und Sieg</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf dem Weg zur Erstellung von Software gibt es nat√ºrlich Schwierigkeiten und Probleme. </font><font style="vertical-align: inherit;">Das Erstellen einer GUI f√ºr die Videokonferenzen war keine Ausnahme. </font><font style="vertical-align: inherit;">Unabh√§ngig vom spezifischen Zweck des Systems k√∂nnen sie in jedem Befehl wiederholt werden. </font><font style="vertical-align: inherit;">Schwierigkeiten und Siege auf dem Entwicklungspfad sind f√ºr Kollegen interessant und f√ºhren m√∂glicherweise zu effektiven L√∂sungen ohne unseren ‚ÄûRechen‚Äú.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr immer Konsistenz</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Historisch gesehen war das allererste interessante Problem, das w√§hrend der Entwicklung der GUI f√ºr verschiedene Arten von VKS-Terminals auftrat, das Problem der Konsistenz, dh des koordinierten Zustands aller Module. </font><font style="vertical-align: inherit;">W√§hrend des Betriebs interagiert die GUI mit mehreren anderen Modulen: einem Modul f√ºr die Interaktion mit Hardware, einem Anrufverwaltungssubsystem, einem Medienverarbeitungsmodul (MCU) und einem Benutzerinteraktionssubsystem.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/xp/5b/csxp5bydmvx6vi9eviyuxg8-d3k.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anf√§nglich arbeitete die GUI mit all diesen Modulen als unabh√§ngig, dh sie konnte gleichzeitig Anforderungen an zwei verschiedene Module senden. Dies stellte sich als falsch heraus und f√ºhrte manchmal zu Problemen, da diese Module selbst nicht unabh√§ngig waren und aktiv miteinander interagierten. Die L√∂sung des Problems war die Erstellung eines speziellen Arbeitsschemas, das eine streng sequentielle Ausf√ºhrung der Anforderungen in allen Modulen sicherstellte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gab zwei Schwierigkeiten beim Hinzuf√ºgen: Erstens erfordern einige (aber nicht alle) Anforderungen eine Antwort, in deren Erwartung sich das Terminal tats√§chlich in einem inkonsistenten Zustand befindet, sodass andere Anforderungen nicht ausgef√ºhrt werden k√∂nnen. Es ist jedoch auch unerw√ºnscht, die Benutzeroberfl√§che zu blockieren, w√§hrend auf Antworten gewartet wird. Zweitens kommen Antworten auf GUI-Anforderungen von Modulen sowie Anforderungen von Modulen an die GUI in ihren eigenen Threads, die sich von der GUI unterscheiden. Die GUI muss jedoch alle √Ñnderungen in ihrem Status in ihrem Thread implementieren (Qt erfordert dies f√ºr einige Aktionen, jedoch in In einigen F√§llen werden dadurch unn√∂tige Schwierigkeiten bei der Gew√§hrleistung der Thread-Synchronisation vermieden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die L√∂sung wurde gefunden und bestand aus zwei Teilen. Zun√§chst wurden alle Anforderungen / Antworten von anderen Modulen mithilfe des Qt-Signalschlitzmechanismus in Verbindung mit QueuedConnection, dh mithilfe der globalen QApplication-Ereignisschleife, an den GUI-Stream umgeleitet. Um eine konsistente Verarbeitung aller Anforderungen zu gew√§hrleisten, wurde ein Transitions-System mit einer eigenen Warteschlange und einem eigenen Verarbeitungszyklus (TransitionLoop) entwickelt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Benutzer eine Aktionstaste in der GUI dr√ºckt (z. B. die Anruftaste), wird ein entsprechender √úbergang erstellt, der in die √úbergangswarteschlange gestellt wird. Danach wird ein Signal f√ºr den √úbergangsverarbeitungszyklus erzeugt. TransitionLoop pr√ºft beim Empfang eines Signals, ob gerade ein √úbergang stattfindet. Wenn dies der Fall ist, wird das Warten auf den Abschluss des aktuellen √úbergangs fortgesetzt. Wenn nicht, wird der n√§chste √úbergang aus der √úbergangswarteschlange abgerufen und gestartet. Wenn eine Antwort von einem anderen TransitionLoop-Modul mit demselben Signal empfangen wird, wird der Abschluss des aktuellen √úbergangs benachrichtigt und TransitionLoop kann den n√§chsten √úbergang aus der Warteschlange starten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wichtig hierbei ist, dass die gesamte √úbergangsverarbeitung in einem GUI-Thread erfolgt. </font><font style="vertical-align: inherit;">Dies wird durch die Verwendung des Qt-Signalschlitzmechanismus in der QueuedConnection-Variante sichergestellt, bei dem f√ºr jedes Signal ein Ereignis generiert und in der Hauptereignisschleife der Anwendung platziert wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL-Rendering auf stromsparender Hardware</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere Schwierigkeit, mit der wir uns befassen mussten, war das Problem beim Rendern von Videos. Qt erm√∂glicht das OpenGL-Rendern einer speziellen QOpenGLWidget-Klasse und verwandter Hilfsklassen, die urspr√ºnglich zum Rendern von Videos verwendet wurden. Die Daten zum Rendern (decodierte Videobilder) selbst werden vom Medienverarbeitungsmodul (MCU) bereitgestellt, das unter anderem die Hardware-Decodierung des Videostreams (auf der GPU) implementiert. Bei Prozessoren mit geringem Stromverbrauch wurde eine "Verlangsamung" des Renderns von FullHD-Videos festgestellt. Die direkte L√∂sung bestand darin, den Prozessor auszutauschen. Dies w√ºrde jedoch eine ernsthafte Verarbeitung der bereits fertigen Komponenten des Videokonferenzsystems erfordern und die Kosten f√ºr die Ger√§te selbst erh√∂hen. Daher wurde der gesamte Renderprozess sorgf√§ltig analysiert, um bessere M√∂glichkeiten zur L√∂sung des Problems zu finden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Standard-OpenGL-Rendering und der Hardware-Decodierung geschieht Folgendes: Daten mit codiertem Video stammen aus dem Netzwerk, werden im RAM gespeichert, und diese Daten aus dem RAM werden in den Videospeicher der GPU √ºbertragen, wo sie decodiert werden. Dann werden decodierte Daten mit einem wesentlich gr√∂√üeren Volumen als codierte Daten erneut in den RAM √ºbertragen. Als n√§chstes kommt ein Rendering-Code ins Spiel, der diese Daten vom RAM direkt zum Rendern zur√ºck zur GPU √ºbertr√§gt. Somit werden ziemlich gro√üe Datenmengen durch den Speicherbus hin und her gepumpt, und der Bus kann dies einfach nicht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In modernen Versionen von OpenGL gibt es spezielle Erweiterungen, mit denen Sie festlegen k√∂nnen, dass Daten gerendert werden sollen, die sich bereits im GPU-Speicher befinden, und nicht wie √ºblich Daten im Haupt-RAM. Dieser Mechanismus schloss das Verschieben von Daten von Hardware-decodierten Frames von der GPU in den RAM und dann zur√ºck aus. Damit war das Problem des Renderns auf Prozessoren mit geringem Stromverbrauch nahezu gel√∂st.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ta/gx/rr/tagxrr-ydgiw9vlbucxyvli2jni.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres gro√ües Problem waren die in Qt unterst√ºtzten OpenGL-Kontexte. Sie k√∂nnen die erforderliche OpenGL-Erweiterung nicht verwenden, dh Sie k√∂nnen QOpenGLWidget mit dieser Option nicht verwenden. Die L√∂sung bestand darin, ein regul√§res QWidget zu verwenden, die Qt-Rendering-Pipeline jedoch auszuschalten. Eine solche M√∂glichkeit besteht in Qt. Hier stellte sich jedoch eine Frage, da bei dieser Option die GUI f√ºr das gesamte Rendern im Bereich dieses Widgets voll verantwortlich ist. Qt hilft uns nicht. Dies ist normal f√ºr die Anzeige von Videos. F√ºr die Verwendung von Widgets √ºber Videos k√∂nnen jedoch keine regul√§ren Qt-Tools verwendet werden, da beispielsweise √ºber dem Video ein zus√§tzliches Popup-Men√º angezeigt werden muss.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Problem wurde wie folgt gel√∂st: Aus dem vorhandenen Widget wird das Bild abgerufen (QWidget verf√ºgt hierf√ºr √ºber eine grab () -Methode), das resultierende Bild wird in eine OpenGL-Textur konvertiert und letztere mit OpenGL-Tools √ºber dem Video gerendert. </font><font style="vertical-align: inherit;">Durch Hinzuf√ºgen der entsprechenden Umgebung wurde ein universeller Mechanismus implementiert, mit dem alle Standard-Widgets √ºber dem Video auf eine nicht standardm√§√üige Weise angezeigt werden k√∂nnen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kioske und Widgets</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verwaltung von Anzeigen und die Verteilung von Fragmenten der Benutzeroberfl√§che im Kiosk-Modus war nicht einfach. Das VKS-Terminal kann in zwei Modi betrieben werden: Fenstermodus, dh wie jede andere Fensteranwendung in der Desktop-Umgebung des Betriebssystems, und ‚ÄûKiosk-Modus‚Äú (dh das Betriebssystem f√ºhrt nur eine Anwendung mit einer grafischen Oberfl√§che aus - VKST - und es gibt keine Umgebung Desktop).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Fenstermodus ist alles relativ einfach: Das Fenster wird vom Fenstermanager der Desktop-Umgebung gesteuert, die Anwendung erstellt bei Bedarf ein zweites Fenster und der Benutzer verteilt die Fenster auf den Displays nach Bedarf. Im ‚ÄûKiosk‚Äú -Modus ist jedoch alles viel komplizierter, da das System keinen Fenstermanager hat und es nur ein Fenster geben kann und der Benutzer nicht in der Lage ist, es zu verschieben. Daher erschien die Aufgabe, ein Ereignis automatisch zu erkennen, beispielsweise eine Anzeige zu verbinden / zu trennen. Bei diesem Ereignis mussten die Anzeigen automatisch konfiguriert und Fragmente der Benutzeroberfl√§che korrekt darauf platziert werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-x/dm/w_/-xdmw_fvqpxs-frj0pl04wszabg.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Antwort kam von der LINUX Xrandr OS-Systembibliothek, die f√ºr die Arbeit mit Displays verantwortlich ist. Da es im Internet nur sehr wenige Dokumentationen gibt, wurde die Implementierung anhand von Beispielen aus dem Internet durchgef√ºhrt, einschlie√ülich von Habr. Dar√ºber hinaus war es notwendig, einen Algorithmus zum Verteilen von Schnittstellenfragmenten auf Displays zu entwickeln und zwei verschiedene Fenster in ein einziges zu integrieren. Letzteres wurde wie folgt implementiert: Was sind Fenster im Fenstermodus, im "Kiosk" -Modus sind Widgets in einem gro√üen Fenster, das sich √ºber 2 Anzeigen erstreckt (wenn es 2 davon gibt). In diesem Fall m√ºssen Sie die Positionen der Anzeigen so konfigurieren, dass ein kontinuierlicher virtueller Raum erstellt wird (dies erfolgt mithilfe der XRandr-Bibliothek), und dann die Geometrie der internen Widgets in einem einzelnen globalen Fenster festlegendamit jeder auf sein Display kommt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir schaffen Russisch</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die gesamte Art der Erstellung des russischen Videokonferenzsystems bestand aus vielen Phasen, und die grafische Benutzeroberfl√§che ist nur die Spitze des Eisbergs. </font><font style="vertical-align: inherit;">Das Auff√§lligste und nicht das Schwierigste. </font><font style="vertical-align: inherit;">Die Komplexit√§t der L√∂sung, die Kombination von Software und Hardware sowie Softwarekomponenten und der Wunsch, ein technisch und √§sthetisch ‚Äûsch√∂nes‚Äú System zu schaffen, verursachten jedoch viele Schwierigkeiten. </font><font style="vertical-align: inherit;">Neue Aufgaben f√ºhrten zu nicht standardm√§√üigen L√∂sungen und trugen dazu bei, ein Produkt zu schaffen, das sich nicht sch√§mt, nicht nur in Russland, sondern auch im Ausland zu zeigen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Russische Entwicklungen haben sich seit langem bew√§hrt, und das in einer sch√∂nen H√ºlle und Wettbewerbsf√§higkeit. </font><font style="vertical-align: inherit;">Unsere Life-Hacks werden f√ºr alle n√ºtzlich sein, die ernsthaft an der Entwicklung von GUI beteiligt sind, und wir hoffen, dass sie anderen Entwicklern helfen werden, den Prozess der Erstellung moderner Shells f√ºr neue russische Softwareprodukte zu beschleunigen und zu vereinfachen. </font><font style="vertical-align: inherit;">Wir glauben, dass russische Entscheidungen in der Welt nicht weniger gesch√§tzt werden als russisches Ballett oder schwarzer Kaviar.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de504880/index.html">Entwicklung, Optimierung und Ver√∂ffentlichung von Synthety-Spielen auf Unity</a></li>
<li><a href="../de504884/index.html">Gef√§hrliche Peripherieger√§te: Thunderspy verstehen</a></li>
<li><a href="../de504886/index.html">Selenium WebDriver im Dienste des Entwicklers</a></li>
<li><a href="../de504888/index.html">"Ruhig, nur ruhig!" oder weniger Sorgen</a></li>
<li><a href="../de504890/index.html">R√ºckgabewert vom Powershell-Aufrufbefehl an den SQL Server-Agenten</a></li>
<li><a href="../de504902/index.html">Top 9 Trends im automatisierten Testen im Jahr 2020</a></li>
<li><a href="../de504906/index.html">PHP - Was ist die Nische der Sprache und wird PHP8 helfen, dr√§ngende Probleme zu l√∂sen (Spoiler: IMHO nicht)</a></li>
<li><a href="../de504908/index.html">PyTrace - Zeitreise-Debugger f√ºr Python</a></li>
<li><a href="../de504912/index.html">HackTheBox-Endspiel. Passage des Labors Professionelle Offensivoperationen. Pentest Active Directory</a></li>
<li><a href="../de504918/index.html">Die effektivsten Online-Unterrichtsdienste f√ºr Sch√ºler und Lehrer: die Top 5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>