<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüë¶ üç± ‚úãüèæ Programmation GPU en Java üôéüèª ‚ò¶Ô∏è üèáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'acc√®s au GPU depuis Java r√©v√®le une puissance √©norme. Il d√©crit le fonctionnement du GPU et l'acc√®s √† partir de Java. 
 
 La programmation GPU est u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programmation GPU en Java</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500106/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'acc√®s au GPU depuis Java r√©v√®le une puissance √©norme. </font><font style="vertical-align: inherit;">Il d√©crit le fonctionnement du GPU et l'acc√®s √† partir de Java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La programmation GPU est un monde exorbitant pour les programmeurs Java. </font><font style="vertical-align: inherit;">Cela est compr√©hensible car les t√¢ches Java normales ne conviennent pas au GPU. </font><font style="vertical-align: inherit;">Cependant, les GPU ont des t√©raflops de performances, alors explorons leurs capacit√©s. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de rendre le sujet accessible, je vais passer un peu de temps √† expliquer l'architecture du GPU avec un peu d'histoire qui facilitera une immersion dans la programmation de fer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois que l'on m'a montr√© les diff√©rences entre le GPU et le CPU, je montrerai comment utiliser le GPU dans le monde Java. </font><font style="vertical-align: inherit;">Enfin, je d√©crirai les principaux cadres et biblioth√®ques disponibles pour √©crire du code Java et les ex√©cuter sur le GPU, et je donnerai quelques exemples de code.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un peu d'histoire</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le GPU a √©t√© popularis√© pour la premi√®re fois par NVIDIA en 1999. Il s'agit d'un processeur sp√©cial con√ßu pour traiter les donn√©es graphiques avant de les transf√©rer sur l'√©cran. </font><font style="vertical-align: inherit;">Dans de nombreux cas, cela permet √† certains calculs de d√©charger le processeur, lib√©rant ainsi des ressources de processeur qui acc√©l√®rent ces calculs non charg√©s. </font><font style="vertical-align: inherit;">Le r√©sultat est qu'une grande entr√©e peut √™tre trait√©e et pr√©sent√©e avec une r√©solution de sortie plus √©lev√©e, ce qui rend la pr√©sentation visuelle plus attrayante et la fr√©quence d'images plus fluide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'essence du traitement 2D / 3D est principalement dans la manipulation des matrices, ceci peut √™tre contr√¥l√© en utilisant une approche distribu√©e. </font><font style="vertical-align: inherit;">Quelle sera une approche efficace pour le traitement d'images? </font><font style="vertical-align: inherit;">Pour r√©pondre √† cela, comparons l'architecture CPU standard (illustr√©e √† la figure 1.) et le GPU.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d6c/58e/c4c/d6c58ec4ccbec78f237d58a822f9ab92.jpg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. 1. Blocs d'architecture</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
du processeur Dans le processeur, les √©l√©ments de traitement r√©els - registres, unit√© logique arithm√©tique (ALU) et contextes d'ex√©cution - ne sont que de petites parties de l'ensemble du syst√®me. Pour acc√©l√©rer les paiements irr√©guliers dans un ordre impr√©visible, il existe un cache volumineux, rapide et co√ªteux; divers types de collectionneurs; et les pr√©dicteurs de branche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous n'avez pas besoin de tout cela sur le GPU, car les donn√©es sont re√ßues de mani√®re pr√©visible et le GPU effectue un ensemble tr√®s limit√© d'op√©rations sur les donn√©es. Ainsi, il est possible de les rendre tr√®s petits et un processeur peu co√ªteux avec une architecture de bloc similaire √† celle-ci est repr√©sent√© sur la Fig. 2. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/365/425/84c/36542584c2d34d817c48ca2cd0e8d433.jpg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 2. Architecture de bloc pour un noyau GPU simple</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√âtant donn√© que ces processeurs sont moins chers et que les donn√©es trait√©es en eux-m√™mes en morceaux parall√®les, il est simple de faire fonctionner plusieurs d'entre eux en parall√®le. Il est con√ßu en r√©f√©rence √† plusieurs instructions, plusieurs donn√©es ou MIMD (prononc√© "mim-dee"). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La deuxi√®me approche est bas√©e sur le fait que souvent une seule instruction est appliqu√©e √† plusieurs √©l√©ments de donn√©es. C'est ce qu'on appelle une instruction unique, plusieurs donn√©es ou SIMD (prononc√© ¬´sim-dee¬ª). Dans cette conception, un seul GPU contient plusieurs ALU et contextes d'ex√©cution, de petites zones transf√©r√©es vers des donn√©es de contexte partag√©es, comme le montre la figure 3. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/453/4cb/013/4534cb0135c6c5c3075594787c3266c6.jpg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 3. Comparaison de l'architecture de style MIMD des blocs GPU (de gauche) avec la conception SIMD (de droite)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le m√©lange des traitements SIMD et MIMD fournit la bande passante maximale que je contournerai. </font><font style="vertical-align: inherit;">Dans cette conception, vous disposez de plusieurs processeurs SIMD fonctionnant en parall√®le, comme dans la figure </font><font style="vertical-align: inherit;">4. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d81/fc5/f10/d81fc5f10ab5cf27584669ab846b9836.jpg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">4. Travailler plusieurs processeurs SIMD en parall√®le; </font><font style="vertical-align: inherit;">il y a 16 c≈ìurs avec 128 ALU.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Comme vous avez un tas de petits processeurs simples, vous pouvez les programmer pour obtenir un effet sp√©cial en sortie.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ex√©cution de programmes sur le GPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La plupart des premiers effets graphiques dans les jeux √©taient de petits programmes vraiment cod√©s en dur s'ex√©cutant sur le GPU et appliqu√©s aux flux de donn√©es du CPU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela √©tait √©vident, m√™me lorsque les algorithmes cod√©s en dur √©taient insuffisants, en particulier dans la conception de jeux, o√π les effets visuels sont l'une des principales directions magiques. En r√©ponse, les grands vendeurs ont ouvert l'acc√®s au GPU, puis des d√©veloppeurs tiers pouvaient les programmer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une approche typique consistait √† √©crire un petit programme appel√© shaders dans un langage sp√©cial (g√©n√©ralement une sous-esp√®ce de C) et √† les compiler √† l'aide de compilateurs sp√©ciaux pour l'architecture souhait√©e. </font><font style="vertical-align: inherit;">Le terme shaders a √©t√© choisi parce que les shaders sont souvent utilis√©s pour contr√¥ler les effets de lumi√®re et d'ombre, mais cela ne signifie pas qu'ils peuvent contr√¥ler d'autres effets sp√©ciaux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque fournisseur de GPU avait son propre langage de programmation et sa propre infrastructure pour cr√©er des shaders pour leur architecture. </font><font style="vertical-align: inherit;">Sur cette approche, de nombreuses plateformes ont √©t√© cr√©√©es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les principaux sont:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DirectCompute: langage / API de shader priv√© de Microsoft qui fait partie de Direct3D, √† commencer par DirectX 10.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD FireStream: technologies priv√©es ATI / Radeon d√©pass√©es par AMD.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenACC: Multi-Vendor Consortium, Parallel Computing Solution</font></font></li>
<li>++ AMP:   Microsoft     C++</li>
<li>CUDA:   Nvidia,     </li>
<li>OpenL:  ,   Apple,      Khronos Group</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La plupart du temps, travailler avec le GPU est une programmation de bas niveau. </font><font style="vertical-align: inherit;">Afin de rendre cela un peu plus compr√©hensible pour les d√©veloppeurs, pour le codage, plusieurs abstractions ont √©t√© fournies. </font><font style="vertical-align: inherit;">Le plus c√©l√®bre est DirectX, de Microsoft, et OpenGL, du groupe Khronos. </font><font style="vertical-align: inherit;">Ce sont des API pour √©crire du code de haut niveau, qui peuvent ensuite √™tre simplifi√©es pour le GPU, plus s√©mantiquement, pour le programmeur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour autant que je sache, il n'y a pas d'infrastructure Java pour DirectX, mais il existe une bonne solution pour OpenGL. </font><font style="vertical-align: inherit;">JSR 231 a commenc√© en 2002 et s'adresse aux programmeurs GPU, mais il a √©t√© abandonn√© en 2008 et ne prend en charge que OpenGL 2.0.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La prise en charge d'OpenGL se poursuit dans le projet JOCL ind√©pendant (qui prend √©galement en charge OpenCL) et est disponible pour le public. </font><font style="vertical-align: inherit;">Ainsi, le c√©l√®bre jeu Minecraft a √©t√© √©crit en utilisant JOCL.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPGPU √† venir</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusqu'√† pr√©sent, Java et le GPU n'ont eu aucun terrain d'entente, bien qu'ils devraient l'√™tre. </font><font style="vertical-align: inherit;">Java est souvent utilis√© dans les entreprises, dans la science des donn√©es et dans le secteur financier, o√π il y a beaucoup d'informatique et o√π beaucoup de puissance de calcul est n√©cessaire. </font><font style="vertical-align: inherit;">C'est ainsi que l'id√©e du GPU √† usage g√©n√©ral (GPGPU) est. </font><font style="vertical-align: inherit;">L'id√©e d'utiliser le GPU le long de ce chemin a commenc√© lorsque les fabricants d'adaptateurs vid√©o ont commenc√© √† donner acc√®s au tampon de trame du programme, permettant aux d√©veloppeurs de lire le contenu. </font><font style="vertical-align: inherit;">Certains pirates ont d√©termin√© qu'ils pouvaient utiliser toute la puissance du GPU pour l'informatique universelle. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La recette √©tait comme √ßa:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encodez les donn√©es sous forme de tableau raster.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âcrivez des shaders pour les g√©rer.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Envoyez-les tous les deux sur la carte graphique.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenir le r√©sultat du tampon de trame</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©codez les donn√©es d'une matrice raster.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est une explication tr√®s simple. Je ne sais pas si cela fonctionnera en production, mais cela fonctionne vraiment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, de nombreuses √©tudes du Stanford Institute ont commenc√© √† simplifier l'utilisation des GPU. En 2005, ils ont cr√©√© BrookGPU, qui √©tait un petit √©cosyst√®me qui comprenait un langage de programmation, un compilateur et un runtime. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BrookGPU a compil√© des programmes √©crits dans le langage de programmation Brook thread, qui √©tait une variante de ANSI C.Il peut cibler OpenGL v1.3 +, DirectX v9 + ou AMD Close to Metal pour le c√¥t√© serveur, et il fonctionne sur Microsoft Windows et Linux. Pour le d√©bogage, BrookGPU peut √©galement simuler une carte graphique virtuelle sur le CPU.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, cela n'a pas d√©coll√©, en raison de l'√©quipement disponible √† l'√©poque. Dans le monde GPGPU, vous devez copier des donn√©es sur l'appareil (dans ce contexte, l'appareil fait r√©f√©rence au GPU et √† l'appareil sur lequel il se trouve), attendez que le GPU calcule les donn√©es, puis recopiez les donn√©es dans le programme de contr√¥le. Cela cr√©e beaucoup de retards. Et au milieu des ann√©es 2000, lorsque le projet √©tait en d√©veloppement actif, ces retards ont √©galement exclu l'utilisation intensive du GPU pour l'informatique de base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, de nombreuses entreprises ont vu l'avenir de cette technologie. Plusieurs d√©veloppeurs d'adaptateurs vid√©o ont commenc√© √† fournir aux GPGPU leurs technologies propri√©taires, et d'autres alliances form√©es ont fourni des mod√®les de programmation moins basiques et polyvalents qui fonctionnaient sur une grande quantit√© de mat√©riel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que je vous ai tout dit, examinons les deux technologies informatiques GPU les plus r√©ussies - OpenCL et CUDA - voyez √©galement comment Java fonctionne avec elles. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCL et Java</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme les autres packages d'infrastructure, OpenCL fournit une impl√©mentation de base en C. Elle est techniquement disponible √† l'aide de Java Native Interface (JNI) ou Java Native Access (JNA), mais cette approche sera trop difficile pour la plupart des d√©veloppeurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heureusement, ce travail a d√©j√† √©t√© effectu√© par plusieurs biblioth√®ques: JOCL, JogAmp et JavaCL. Malheureusement, JavaCL est devenu un projet mort. Mais le projet JOCL est vivant et tr√®s adapt√©. Je vais l'utiliser pour les exemples suivants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais je dois d'abord expliquer ce qu'est OpenCL. J'ai mentionn√© plus t√¥t qu'OpenCL fournit un mod√®le tr√®s basique adapt√© √† la programmation de toutes sortes de p√©riph√©riques - pas seulement les GPU et les CPU, mais m√™me les processeurs DSP et FPGA.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons l'exemple le plus simple: les vecteurs de pliage sont probablement l'exemple le plus brillant et le plus simple. Vous avez deux tableaux de nombres pour l'addition et un pour le r√©sultat. Vous prenez un √©l√©ment du premier tableau et un √©l√©ment du deuxi√®me tableau, puis vous mettez la somme dans le tableau des r√©sultats, comme le montre la Fig. 5. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fff/896/f1f/fff896f1feb607506f35dc8dcdce973b.jpg" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 5. Ajout des √©l√©ments de deux tableaux et stockage de la somme dans le tableau r√©sultant</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Comme vous pouvez le voir, l'op√©ration est tr√®s coh√©rente et n√©anmoins distribu√©e. Vous pouvez pousser chaque op√©ration d'ajout dans diff√©rents GPU principaux. Cela signifie que si vous avez 2048 c≈ìurs, comme sur le Nvidia 1080, vous pouvez effectuer 2048 op√©rations d'addition en m√™me temps. Cela signifie que les t√©raflops potentiels de puissance informatique vous attendent ici. Ce code pour un tableau de 10 millions de num√©ros est tir√© du site Web de JOCL:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayGPU</span> </span>{
    <span class="hljs-comment">/**
     * The source code of the OpenCL program 
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String programSource =
        <span class="hljs-string">"__kernel void "</span>+
        <span class="hljs-string">"sampleKernel(__global const float *a,"</span>+
        <span class="hljs-string">"             __global const float *b,"</span>+
        <span class="hljs-string">"             __global float *c)"</span>+
        <span class="hljs-string">"{"</span>+
        <span class="hljs-string">"    int gid = get_global_id(0);"</span>+
        <span class="hljs-string">"    c[gid] = a[gid] + b[gid];"</span>+
        <span class="hljs-string">"}"</span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span>
    </span>{
        <span class="hljs-keyword">int</span> n = <span class="hljs-number">10_000_000</span>;
        <span class="hljs-keyword">float</span> srcArrayA[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">float</span> srcArrayB[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">float</span> dstArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<font></font>
        {<font></font>
            srcArrayA[i] = i;<font></font>
            srcArrayB[i] = i;<font></font>
        }<font></font>
        Pointer srcA = Pointer.to(srcArrayA);<font></font>
        Pointer srcB = Pointer.to(srcArrayB);<font></font>
        Pointer dst = Pointer.to(dstArray);<font></font>
<font></font>
<font></font>
        <span class="hljs-comment">// The platform, device type and device number</span>
        <span class="hljs-comment">// that will be used</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> platformIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deviceType = CL.CL_DEVICE_TYPE_ALL;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> deviceIndex = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-comment">// Enable exceptions and subsequently omit error checks in this sample</span>
        CL.setExceptionsEnabled(<span class="hljs-keyword">true</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Obtain the number of platforms</span>
        <span class="hljs-keyword">int</span> numPlatformsArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetPlatformIDs(<span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, numPlatformsArray);
        <span class="hljs-keyword">int</span> numPlatforms = numPlatformsArray[<span class="hljs-number">0</span>];<font></font>
<font></font>
        <span class="hljs-comment">// Obtain a platform ID</span>
        cl_platform_id platforms[] = <span class="hljs-keyword">new</span> cl_platform_id[numPlatforms];<font></font>
        CL.clGetPlatformIDs(platforms.length, platforms, <span class="hljs-keyword">null</span>);<font></font>
        cl_platform_id platform = platforms[platformIndex];<font></font>
<font></font>
        <span class="hljs-comment">// Initialize the context properties</span>
        cl_context_properties contextProperties = <span class="hljs-keyword">new</span> cl_context_properties();<font></font>
        contextProperties.addProperty(CL.CL_CONTEXT_PLATFORM, platform);<font></font>
        <font></font>
        <span class="hljs-comment">// Obtain the number of devices for the platform</span>
        <span class="hljs-keyword">int</span> numDevicesArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetDeviceIDs(platform, deviceType, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, numDevicesArray);
        <span class="hljs-keyword">int</span> numDevices = numDevicesArray[<span class="hljs-number">0</span>];<font></font>
        <font></font>
        <span class="hljs-comment">// Obtain a device ID </span>
        cl_device_id devices[] = <span class="hljs-keyword">new</span> cl_device_id[numDevices];<font></font>
        CL.clGetDeviceIDs(platform, deviceType, numDevices, devices, <span class="hljs-keyword">null</span>);<font></font>
        cl_device_id device = devices[deviceIndex];<font></font>
<font></font>
        <span class="hljs-comment">// Create a context for the selected device</span><font></font>
        cl_context context = CL.clCreateContext(<font></font>
            contextProperties, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> cl_device_id[]{device}, 
            <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create a command-queue for the selected device</span><font></font>
        cl_command_queue commandQueue = <font></font>
            CL.clCreateCommandQueue(context, device, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Allocate the memory objects for the input and output data</span>
        cl_mem memObjects[] = <span class="hljs-keyword">new</span> cl_mem[<span class="hljs-number">3</span>];<font></font>
        memObjects[<span class="hljs-number">0</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_ONLY | CL.CL_MEM_COPY_HOST_PTR,<font></font>
            Sizeof.cl_float * n, srcA, <span class="hljs-keyword">null</span>);<font></font>
        memObjects[<span class="hljs-number">1</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_ONLY | CL.CL_MEM_COPY_HOST_PTR,<font></font>
            Sizeof.cl_float * n, srcB, <span class="hljs-keyword">null</span>);<font></font>
        memObjects[<span class="hljs-number">2</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_WRITE,<font></font>
            Sizeof.cl_float * n, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create the program from the source code</span><font></font>
        cl_program program = CL.clCreateProgramWithSource(context,<font></font>
            <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> String[]{ programSource }, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Build the program</span>
        CL.clBuildProgram(program, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create the kernel</span>
        cl_kernel kernel = CL.clCreateKernel(program, <span class="hljs-string">"sampleKernel"</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Set the arguments for the kernel</span>
        CL.clSetKernelArg(kernel, <span class="hljs-number">0</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">0</span>]));<font></font>
        CL.clSetKernelArg(kernel, <span class="hljs-number">1</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">1</span>]));<font></font>
        CL.clSetKernelArg(kernel, <span class="hljs-number">2</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">2</span>]));<font></font>
        <font></font>
        <span class="hljs-comment">// Set the work-item dimensions</span>
        <span class="hljs-keyword">long</span> global_work_size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[]{n};
        <span class="hljs-keyword">long</span> local_work_size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[]{<span class="hljs-number">1</span>};<font></font>
        <font></font>
        <span class="hljs-comment">// Execute the kernel</span>
        CL.clEnqueueNDRangeKernel(commandQueue, kernel, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>,<font></font>
            global_work_size, local_work_size, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Read the output data</span>
        CL.clEnqueueReadBuffer(commandQueue, memObjects[<span class="hljs-number">2</span>], CL.CL_TRUE, <span class="hljs-number">0</span>,<font></font>
            n * Sizeof.cl_float, dst, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Release kernel, program, and memory objects</span>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">0</span>]);<font></font>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">1</span>]);<font></font>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">2</span>]);<font></font>
        CL.clReleaseKernel(kernel);<font></font>
        CL.clReleaseProgram(program);<font></font>
        CL.clReleaseCommandQueue(commandQueue);<font></font>
        CL.clReleaseContext(context);<font></font>
<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getString</span><span class="hljs-params">(cl_device_id device, <span class="hljs-keyword">int</span> paramName)</span> </span>{
        <span class="hljs-comment">// Obtain the length of the string that will be queried</span>
        <span class="hljs-keyword">long</span> size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetDeviceInfo(device, paramName, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, size);<font></font>
<font></font>
        <span class="hljs-comment">// Create a buffer of the appropriate size and fill it with the info</span>
        <span class="hljs-keyword">byte</span> buffer[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>)size[<span class="hljs-number">0</span>]];<font></font>
        CL.clGetDeviceInfo(device, paramName, buffer.length, Pointer.to(buffer), <span class="hljs-keyword">null</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Create a string from the buffer (excluding the trailing \0 byte)</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buffer, <span class="hljs-number">0</span>, buffer.length-<span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce code n'est pas comme le code Java, mais il l'est. Je vais expliquer le code plus loin; n'y consacrez pas beaucoup de temps maintenant, car je parlerai bri√®vement de solutions complexes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code sera document√©, mais faisons une petite proc√©dure pas √† pas. Comme vous pouvez le voir, le code est tr√®s similaire au code en C. Ceci est normal car JOCL est juste OpenCL. Au d√©but, voici du code dans la ligne, et ce code est la partie la plus importante: il est compil√© en utilisant OpenCL puis envoy√© √† la carte vid√©o, o√π il est ex√©cut√©. Ce code est appel√© noyau. Ne confondez pas ce terme avec OC Kernel; Ceci est le code de l'appareil. Ce code est √©crit dans un sous-ensemble de C. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s le noyau vient le code Java pour installer et configurer le p√©riph√©rique, diviser les donn√©es et cr√©er les tampons de m√©moire appropri√©s pour les donn√©es r√©sultantes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour r√©sumer: voici le ¬´code h√¥te¬ª, qui est g√©n√©ralement une liaison de langage (dans notre cas, en Java), et le ¬´code p√©riph√©rique¬ª. Vous mettez toujours en √©vidence ce qui fonctionnera sur l'h√¥te et ce qui devrait fonctionner sur l'appareil, car l'h√¥te contr√¥le l'appareil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code pr√©c√©dent doit montrer l'√©quivalent GPU de "Hello World!" Comme vous pouvez le voir, la majeure partie est √©norme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N'oublions pas les fonctionnalit√©s SIMD. Si votre appareil prend en charge l'extension SIMD, vous pouvez acc√©l√©rer le code arithm√©tique. Pour un exemple, regardons le code de multiplication de la matrice du noyau. Ce code est dans une simple ligne Java dans l'application.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">__kernel <span class="hljs-keyword">void</span> <span class="hljs-title">MatrixMul_kernel_basic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dim,
                  __global <span class="hljs-keyword">float</span> *A,
                  __global <span class="hljs-keyword">float</span> *B,
                  __global <span class="hljs-keyword">float</span> *C)</span></span>{<font></font>
<font></font>
    <span class="hljs-keyword">int</span> iCol = get_global_id(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">int</span> iRow = get_global_id(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">float</span> result = <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt; dim; ++i)<font></font>
    {<font></font>
          result +=<font></font>
          A[iRow*dim + i]*B[i*dim + iCol];<font></font>
    }<font></font>
    C[iRow*dim + iCol] = result;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Techniquement, ce code fonctionnera sur des √©l√©ments de donn√©es qui ont √©t√© install√©s pour vous par le framework OpenCL, avec les instructions que vous avez appel√©es dans la partie pr√©paratoire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si votre carte vid√©o prend en charge les instructions SIMD et peut traiter un vecteur de quatre nombres √† virgule flottante, de petites optimisations peuvent transformer le code pr√©c√©dent en ce qui suit:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VECTOR_SIZE 4    </span>
<span class="hljs-function">__kernel <span class="hljs-keyword">void</span> <span class="hljs-title">MatrixMul_kernel_basic_vector4</span><span class="hljs-params">(
    <span class="hljs-keyword">size_t</span> dim, <span class="hljs-comment">// dimension is in single floats</span>
    <span class="hljs-keyword">const</span> float4 *A,
    <span class="hljs-keyword">const</span> float4 *B,
    float4 *C)</span>
</span>{
    <span class="hljs-keyword">size_t</span> globalIdx = get_global_id(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">size_t</span> globalIdy = get_global_id(<span class="hljs-number">1</span>);<font></font>
    float4 resultVec = (float4){ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> };
    <span class="hljs-keyword">size_t</span> dimVec = dim / <span class="hljs-number">4</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; dimVec; ++i) {<font></font>
        float4 Avector = A[dimVec * globalIdy + i];<font></font>
        float4 Bvector[<span class="hljs-number">4</span>];<font></font>
        Bvector[<span class="hljs-number">0</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">0</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">1</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">1</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">2</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">2</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">3</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">3</span>) + globalIdx];<font></font>
        resultVec += Avector[<span class="hljs-number">0</span>] * Bvector[<span class="hljs-number">0</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">1</span>] * Bvector[<span class="hljs-number">1</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">2</span>] * Bvector[<span class="hljs-number">2</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">3</span>] * Bvector[<span class="hljs-number">3</span>];<font></font>
    }<font></font>
<font></font>
    C[dimVec * globalIdy + globalIdx] = resultVec;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec ce code, vous pouvez doubler les performances. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cool. </font><font style="vertical-align: inherit;">Vous venez d'ouvrir le GPU pour le monde Java! </font><font style="vertical-align: inherit;">Mais en tant que d√©veloppeur Java, voulez-vous vraiment faire tout ce sale boulot, avec du code C, et travailler avec des d√©tails de si bas niveau? </font><font style="vertical-align: inherit;">Je ne veux pas. </font><font style="vertical-align: inherit;">Mais maintenant que vous avez une certaine connaissance de l'utilisation du GPU, examinons une autre solution diff√©rente du code JOCL que je viens de pr√©senter.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CUDA et Java</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA est la solution de Nvidia √† ce probl√®me de programmation. </font><font style="vertical-align: inherit;">CUDA fournit de nombreuses autres biblioth√®ques pr√™tes √† l'emploi pour les op√©rations GPU standard, telles que les matrices, les histogrammes et m√™me les r√©seaux de neurones profonds. </font><font style="vertical-align: inherit;">Une liste de biblioth√®ques est d√©j√† apparue avec un tas de solutions toutes faites. </font><font style="vertical-align: inherit;">Tout cela provient du projet JCuda:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCublas: tout pour les matrices</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCufft: Transformation de Fourier rapide </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCurand: Tout pour les nombres al√©atoires</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCusparse: matrices rares</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCusolver: factorisation des nombres</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JNvgraph: tout pour les graphiques </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCudpp: biblioth√®que CUDA de donn√©es parall√®les primitives et quelques algorithmes de tri</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JNpp: traitement d'image GPU</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCudnn: biblioth√®que de r√©seaux de neurones profonds</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'envisage d'utiliser JCurand, qui g√©n√®re des nombres al√©atoires. </font><font style="vertical-align: inherit;">Vous pouvez l'utiliser √† partir du code Java sans autre langage sp√©cial du noyau. </font><font style="vertical-align: inherit;">Par exemple:</font></font><br>
<br>
<pre><code class="java hljs">...
<span class="hljs-keyword">int</span> n = <span class="hljs-number">100</span>;<font></font>
curandGenerator generator = <span class="hljs-keyword">new</span> curandGenerator();
<span class="hljs-keyword">float</span> hostData[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];<font></font>
Pointer deviceData = <span class="hljs-keyword">new</span> Pointer();<font></font>
cudaMalloc(deviceData, n * Sizeof.FLOAT);<font></font>
curandCreateGenerator(generator, CURAND_RNG_PSEUDO_DEFAULT); <font></font>
curandSetPseudoRandomGeneratorSeed(generator, <span class="hljs-number">1234</span>);<font></font>
curandGenerateUniform(generator, deviceData, n);<font></font>
cudaMemcpy(Pointer.to(hostData), deviceData, <font></font>
        n * Sizeof.FLOAT, cudaMemcpyDeviceToHost);<font></font>
System.out.println(Arrays.toString(hostData));<font></font>
curandDestroyGenerator(generator);<font></font>
cudaFree(deviceData);<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il utilise un GPU pour cr√©er un grand nombre de nombres al√©atoires de tr√®s haute qualit√©, bas√©s sur des math√©matiques tr√®s solides. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans JCuda, vous pouvez √©galement √©crire du code CUDA g√©n√©rique et l'appeler √† partir de Java en appelant un fichier JAR dans votre chemin de classe. </font><font style="vertical-align: inherit;">Voir la documentation JCuda pour de bons exemples.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Restez au-dessus du code de bas niveau</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout a l'air g√©nial, mais il y a trop de code, trop d'installation, trop de langages diff√©rents pour tout ex√©cuter. Existe-t-il un moyen d'utiliser le GPU au moins partiellement? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et si vous ne voulez pas penser √† tout cela OpenCL, CUDA et √† d'autres choses inutiles? Et si vous voulez seulement programmer en Java et ne pas penser √† tout ce qui n'est pas √©vident? Le projet Aparapi peut vous aider. Aparapi est bas√© sur une ¬´API parall√®le¬ª. Je pense que c'est une partie d'Hibernate pour la programmation GPU qui utilise OpenCL sous le capot. Jetons un coup d'≈ìil √† un exemple d'addition vectorielle.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] _args)</span> </span>{
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">512</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];<font></font>
<font></font>
    <span class="hljs-comment">/* fill the arrays with random values */</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<font></font>
        a[i] = (<span class="hljs-keyword">float</span>) (Math.random() * <span class="hljs-number">100</span>);<font></font>
        b[i] = (<span class="hljs-keyword">float</span>) (Math.random() * <span class="hljs-number">100</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];<font></font>
<font></font>
    Kernel kernel = <span class="hljs-keyword">new</span> Kernel(){
        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<font></font>
I           <span class="hljs-keyword">int</span> gid = getGlobalId();<font></font>
            sum[gid] = a[gid] + b[gid];<font></font>
        }<font></font>
    };<font></font>
<font></font>
    kernel.execute(Range.create(size));<font></font>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<font></font>
        System.out.printf(<span class="hljs-string">"%6.2f + %6.2f = %8.2f\n"</span>, a[i], b[i], sum[i])<font></font>
    }<font></font>
    kernel.dispose();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici du code Java pur (extrait de la documentation d'Aparapi), ici et l√† aussi, vous pouvez voir un certain terme Kernel et getGlobalId. </font><font style="vertical-align: inherit;">Vous devez toujours comprendre comment programmer le GPU, mais vous pouvez utiliser l'approche GPGPU d'une mani√®re plus similaire √† Java. </font><font style="vertical-align: inherit;">De plus, Aparapi fournit un moyen facile d'utiliser le contexte OpenGL √† la couche OpenCL - permettant ainsi aux donn√©es de rester compl√®tement sur la carte graphique - et ainsi d'√©viter les probl√®mes de latence de la m√©moire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous avez besoin de faire beaucoup de calculs ind√©pendants, regardez Aparapi. </font><font style="vertical-align: inherit;">Il existe de nombreux exemples d'utilisation du calcul parall√®le. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, il existe un projet appel√© TornadoVM - il transf√®re automatiquement les calculs appropri√©s du CPU au GPU, offrant ainsi une optimisation de masse pr√™te √† l'emploi.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©sultats</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe de nombreuses applications o√π les GPU peuvent apporter certains avantages, mais on pourrait dire qu'il y a encore des obstacles. </font><font style="vertical-align: inherit;">Cependant, Java et le GPU peuvent faire de grandes choses ensemble. </font><font style="vertical-align: inherit;">Dans cet article, je n'ai abord√© que ce vaste sujet. </font><font style="vertical-align: inherit;">J'avais l'intention de montrer diverses options de haut et de bas niveau pour acc√©der au GPU √† partir de Java. </font><font style="vertical-align: inherit;">L'exploration de ce domaine offrira d'√©normes avantages en termes de performances, en particulier pour les t√¢ches complexes qui n√©cessitent plusieurs calculs pouvant √™tre effectu√©s en parall√®le. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lien source</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr500086/index.html">√âcrire une calculatrice javascript</a></li>
<li><a href="../fr500098/index.html">JavaScript Nehronical</a></li>
<li><a href="../fr500100/index.html">TV first, typographie r√©active ou comment ne pas oublier toutes les tailles d'appareils</a></li>
<li><a href="../fr500102/index.html">Roslyn & EF Core: cr√©ation d'un DbContext en runtime</a></li>
<li><a href="../fr500104/index.html">Mod√©lisation des processus d'affaires, traduction automatique de texte de diagramme et notation CH-1</a></li>
<li><a href="../fr500108/index.html">(Spring) State in the (Spring) Shell: not production single</a></li>
<li><a href="../fr500110/index.html">Un mot sur la livraison des marchandises</a></li>
<li><a href="../fr500114/index.html">Recherche d'emploi en Allemagne en tant que chef de produit et plus encore. Partie 2/5. La structure du march√© du travail. ATS. Tableaux d'emplois</a></li>
<li><a href="../fr500116/index.html">Le travail d'une √©quipe r√©partie dans des conditions d'isolement: comme on n'a presque pas remarqu√© la diff√©rence</a></li>
<li><a href="../fr500118/index.html">Cinq √©tapes pour rendre l'in√©vitable, ou un syst√®me de r√©f√©rence de vente crois√©e</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>