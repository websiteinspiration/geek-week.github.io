<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏾 🧤 🏳️‍🌈 马尔可夫链的蒙特卡洛方法（MCMC）。介绍 👩🏿‍⚕️ 🎥 ✊🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！
 
 我们提醒您，我们早些时候宣布了“ 没有多余单词的机器学习 ”这本书，现在已经开始销售。尽管对于MO的初学者来说，这本书确实可以变成台式机，但其中的某些主题仍然没有被触及。因此，我们为所有感兴趣的人提供了Simon Kerstens撰写的有关MCMC算法本质的文章的翻译，以及该算法在P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>马尔可夫链的蒙特卡洛方法（MCMC）。介绍</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/491268/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈Ha！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们提醒您，我们早些时候宣布了“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有多余单词的机器学习</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”这本书</font><font style="vertical-align: inherit;">，现在已经</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始销售</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。尽管对于MO的初学者来说，这本书确实可以变成</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">台式机</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但其中的某些主题仍然没有被触及。因此，我们为所有感兴趣的人提供了Simon Kerstens撰写的有关</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MCMC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法本质的文章的翻译，</font><font style="vertical-align: inherit;">以及该算法在Python中的实现。</font></font><br>
<a name="habracut"></a> <br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">马尔可夫链的蒙特卡洛方法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（MCMC）是一类功能强大的方法，用于从仅直到某个（未知）归一化常数已知的概率分布中进行采样。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，在研究MCMC之前，让我们讨论为什么您可能甚至需要进行这样的选择。答案是：您可能对样本本身感兴趣（例如，使用贝叶斯推导方法确定未知参数），或对函数相对于概率分布的期望值进行近似估计（例如，根据统计物理学中的状态分布来计算热力学量）。有时我们只对概率分布模式感兴趣。在这种情况下，我们通过数值优化的方法获得它，因此没有必要进行完全选择。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果表明，除了最原始的概率分布之外，从任何概率分布中采样都是一项艰巨的任务。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逆变换方法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一种用于从概率分布中采样的基本技术，但是，这需要使用累积分布函数，而要使用该函数，则需要知道通常不知道的归一化常数。原则上，可以通过数值积分获得归一化常数，但是随着尺寸数量的增加，该方法很快变得不可行。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偏差采样</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它不需要规范化的分布，但是为了有效地实现它，需要花很多时间来了解我们感兴趣的分布。此外，此方法还存在严重的尺寸诅咒问题-这意味着其有效性随着变量数量的增加而迅速降低。这就是为什么您需要智能地组织来自分销的代表性样品的接收-无需知道标准化常数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MCMC算法是专门为此设计的一类方法。他们回到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大都市和其他城市</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">标志性文章</font></a><font style="vertical-align: inherit;"> ; Metropolis开发了第一个以</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">他</font></a><font style="vertical-align: inherit;">命名的MCMC算法</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并用于计算二维硬球系统的平衡状态。实际上，研究人员正在寻找一种通用的方法，该方法可以让我们计算统计物理学中发现的期望值。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文将介绍MCMC采样的基础知识。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">马可夫链</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们了解了为什么需要采样，让我们​​继续进入MCMC的核心：马尔可夫链。什么是马尔可夫链？无需赘述技术细节，我们可以说马尔可夫链是某个状态空间中状态的随机序列，其中选择某个状态的概率仅取决于链的当前状态，而不取决于其过去的历史：该链没有内存。在某些条件下，马尔可夫链具有唯一的稳态分布，会收敛到该状态，从而克服了一定数量的状态。在马尔可夫链中有如此多的状态之后，获得不变分布。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了从分布中采样，</font></font><img src="https://habrastorage.org/webt/wb/sl/yf/wbslyf0r1hu5bjl1gbu7pyr3u48.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MCMC算法创建并模拟了一个马尔可夫链，其静态分布为</font></font><img src="https://habrastorage.org/webt/wb/sl/yf/wbslyf0r1hu5bjl1gbu7pyr3u48.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;这意味着在最初的“种子”阶段之后，这种马尔可夫链的状态将根据原理进行分配</font></font><img src="https://habrastorage.org/webt/wb/sl/yf/wbslyf0r1hu5bjl1gbu7pyr3u48.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，我们仅需保存状态即可从中获取样本</font></font><img src="https://habrastorage.org/webt/wb/sl/yf/wbslyf0r1hu5bjl1gbu7pyr3u48.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出于教育目的，让我们考虑离散的状态空间和离散的“时间”。表征马尔可夫链的密钥数量是过渡操作者</font></font><img src="https://habrastorage.org/webt/5q/fu/fx/5qfufxlugigeusphytdet38q580.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指示的存在的状态下的概率</font></font><img src="https://habrastorage.org/webt/gs/gz/hz/gsgzhzrwlbmvbexpmq21j8u1dbu.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在时间</font></font><img src="https://habrastorage.org/webt/cj/ut/o7/cjuto7hmum9a2ki6gyy23a86jb0.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，只要该链处于这样的状态</font></font><img src="https://habrastorage.org/webt/cj/ut/o7/cjuto7hmum9a2ki6gyy23a86jb0.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在时间</font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在只是为了好玩（并作为演示），让我们快速编织具有唯一固定分布的Markov链。让我们从图表的一些导入和设置开始：</font></font><br>
<br>
<pre><code class="python hljs">%matplotlib notebook<font></font>
%matplotlib inline<font></font>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<font></font>
plt.rcParams[<span class="hljs-string">'figure.figsize'</span>] = [<span class="hljs-number">10</span>, <span class="hljs-number">6</span>]<font></font>
np.random.seed(<span class="hljs-number">42</span>)</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
马尔可夫链将绕过由三种天气情况形成的离散状态空间： </font></font><br>
<br>
<pre><code class="python hljs">state_space = (<span class="hljs-string">"sunny"</span>, <span class="hljs-string">"cloudy"</span>, <span class="hljs-string">"rainy"</span>)</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在离散状态空间中，过渡算子只是一个矩阵。</font><font style="vertical-align: inherit;">在我们的情况下，列和行对应于晴天，多云和多雨的天气。</font><font style="vertical-align: inherit;">让我们为所有过渡的概率选择相对合理的值：</font></font><br>
<br>
<pre><code class="python hljs">transition_matrix = np.array(((<span class="hljs-number">0.6</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.1</span>),<font></font>
                              (<span class="hljs-number">0.3</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.3</span>),<font></font>
                              (<span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.5</span>)))</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行指示电路当前可能位于的状态，而列指示电路可以进入的状态。</font><font style="vertical-align: inherit;">如果我们在一个小时内走完马尔可夫链的“时间”步骤，那么，假设现在天气晴朗，那么下一个小时就有60％的机会继续晴天。</font><font style="vertical-align: inherit;">接下来的一个小时还有30％的可能性会出现多云天气，晴天之后会立即下雨的可能性是10％。</font><font style="vertical-align: inherit;">这也意味着每行中的值加起来为1。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们稍微推动一下我们的马尔可夫链：</font></font><br>
<br>
<pre><code class="python hljs">n_steps = <span class="hljs-number">20000</span>
states = [<span class="hljs-number">0</span>]
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n_steps):<font></font>
    states.append(np.random.choice((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>), p=transition_matrix[states[<span class="hljs-number">-1</span>]]))<font></font>
states = np.array(states)</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以观察马尔可夫链如何收敛到平稳分布，并根据链长来计算每个状态的经验概率：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">despine</span>(<span class="hljs-params">ax, spines=(<span class="hljs-params"><span class="hljs-string">'top'</span>, <span class="hljs-string">'left'</span>, <span class="hljs-string">'right'</span></span>)</span>):</span>
    <span class="hljs-keyword">for</span> spine <span class="hljs-keyword">in</span> spines:<font></font>
        ax.spines[spine].set_visible(<span class="hljs-literal">False</span>)<font></font>
<font></font>
fig, ax = plt.subplots()<font></font>
width = <span class="hljs-number">1000</span>
offsets = range(<span class="hljs-number">1</span>, n_steps, <span class="hljs-number">5</span>)
<span class="hljs-keyword">for</span> i, label <span class="hljs-keyword">in</span> enumerate(state_space):<font></font>
    ax.plot(offsets, [np.sum(states[:offset] == i) / offset <font></font>
            <span class="hljs-keyword">for</span> offset <span class="hljs-keyword">in</span> offsets], label=label)<font></font>
ax.set_xlabel(<span class="hljs-string">"number of steps"</span>)<font></font>
ax.set_ylabel(<span class="hljs-string">"likelihood"</span>)<font></font>
ax.legend(frameon=<span class="hljs-literal">False</span>)<font></font>
despine(ax, (<span class="hljs-string">'top'</span>, <span class="hljs-string">'right'</span>))<font></font>
plt.show()</code></pre><br>
<br>
<img src="https://habrastorage.org/webt/vu/tg/xv/vutgxvc3lq1-sang725fmek1ibm.png"><br>
 <br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有MCMC的荣誉：都市圈算法</font></font></b> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
当然，所有这些都非常有趣，但要回到任意概率分布的采样过程</font></font><img src="https://habrastorage.org/webt/r2/lm/5b/r2lm5bcuhr-rdtxeg90gjnogcza.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它可以是离散的（在这种情况下我们将继续讨论过渡矩阵）</font></font><img src="https://habrastorage.org/webt/sz/nh/au/sznhau4xxghwlc7ma-eixqb9jok.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><img src="https://habrastorage.org/webt/sz/nh/au/sznhau4xxghwlc7ma-eixqb9jok.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也可以是</font><font style="vertical-align: inherit;">连续的（在这种情况下它将</font><font style="vertical-align: inherit;">是过渡核心）。在下文中，我们将讨论连续分布，但是我们在这里考虑的所有概念也适用于离散情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们可以这样设计过渡核心，使得已经从中推导出下一个状态</font></font><img src="https://habrastorage.org/webt/r2/lm/5b/r2lm5bcuhr-rdtxeg90gjnogcza.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么这将是有限的，因为我们的马尔可夫链...将直接从中采样</font></font><img src="https://habrastorage.org/webt/r2/lm/5b/r2lm5bcuhr-rdtxeg90gjnogcza.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。不幸的是，要实现这一目标，我们需要能够从</font></font><img src="https://habrastorage.org/webt/r2/lm/5b/r2lm5bcuhr-rdtxeg90gjnogcza.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们无法做的-否则您不会阅读，对不对？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解决方法是将过渡核心</font></font><img src="https://habrastorage.org/webt/7_/os/ja/7_osja2wwom8x6f29sp5ecxnrwc.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分为两个部分：提议步骤和接受/拒绝步骤。辅助分布出现在采样步骤</font></font><img src="https://habrastorage.org/webt/qf/bl/m0/qfblm0cpxxgzun1zq6i9qv_zmfq.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从中选择链的可能的下一状态。我们不仅可以从该分布中进行选择，而且可以随意选择分布本身。但是，在设计时，应该努力实现一种配置，在这种配置中，将从这种分布中获取的样本与当前状态的关联性降到最低，同时有很好的机会经历接收阶段。上述接收/丢弃步骤是过渡核心的第二部分；在此阶段，将从中选择的试用状态中包含的错误进行更正</font></font><img src="https://habrastorage.org/webt/dq/wo/ba/dqwoba_pfa-ktifmo9zviggtesm.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在此，计算成功接收的概率，</font></font><img src="https://habrastorage.org/webt/hz/f4/rv/hzf4rviqapfrbg3mphv1na6kao0.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并以</font></font><img src="https://habrastorage.org/webt/gs/gz/hz/gsgzhzrwlbmvbexpmq21j8u1dbu.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概率作为链中的下一个状态进行</font><font style="vertical-align: inherit;">采样</font><font style="vertical-align: inherit;">。</font></font><img src="https://habrastorage.org/webt/gs/gz/hz/gsgzhzrwlbmvbexpmq21j8u1dbu.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从中</font><font style="vertical-align: inherit;">获取下一个状态</font></font><img src="https://habrastorage.org/webt/5q/fu/fx/5qfufxlugigeusphytdet38q580.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后执行以下操作：首先，</font></font><img src="https://habrastorage.org/webt/gs/gz/hz/gsgzhzrwlbmvbexpmq21j8u1dbu.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从中获取</font><font style="vertical-align: inherit;">试用状态</font></font><img src="https://habrastorage.org/webt/qf/bl/m0/qfblm0cpxxgzun1zq6i9qv_zmfq.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后将其作为具有概率的下一个状态，</font></font><img src="https://habrastorage.org/webt/hz/f4/rv/hzf4rviqapfrbg3mphv1na6kao0.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font><font style="vertical-align: inherit;">以概率</font><font style="vertical-align: inherit;">丢弃</font></font><img src="https://habrastorage.org/webt/cr/_w/sd/cr_wsdxfgphyie2qbzl977pvfgq.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在后一种情况下，将当前状态复制并用作下一个状态。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/vg/w-/tyvgw-g_ij7vgrpzoxtt7t3enmw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于马尔可夫链</font><font style="vertical-align: inherit;">，我们具有</font><font style="vertical-align: inherit;">充分的条件，</font></font><img src="https://habrastorage.org/webt/r2/lm/5b/r2lm5bcuhr-rdtxeg90gjnogcza.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因为其稳态分布如下：过渡核必须提交</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">详细的平衡，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或者如物理文献中所述，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">微观可逆性</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hf/bg/oy/hfbgoyr944ikp5ce_menl-sg0da.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着处于状态</font></font><img src="https://habrastorage.org/webt/mt/2y/jr/mt2yjrl958wkwmuhsrpm3h-4uko.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并从那里移动到</font></font><img src="https://habrastorage.org/webt/4t/py/hc/4tpyhcj70euwoys5id2rrqxa_ac.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须等于逆过程的概率，即能够</font></font><img src="https://habrastorage.org/webt/4t/py/hc/4tpyhcj70euwoys5id2rrqxa_ac.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进入某种状态</font></font><img src="https://habrastorage.org/webt/mt/2y/jr/mt2yjrl958wkwmuhsrpm3h-4uko.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。大多数MCMC算法的过渡内核都满足此条件。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了使两部分过渡核心服从详细的均衡，必须正确选择</font></font><img src="https://habrastorage.org/webt/oc/hr/x1/ochrx15_pe9awrsow_fygffjego.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即确保它允许您校正从/到</font></font><img src="https://habrastorage.org/webt/4t/py/hc/4tpyhcj70euwoys5id2rrqxa_ac.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font><font style="vertical-align: inherit;">的概率流中的任何不对称性</font></font><img src="https://habrastorage.org/webt/mt/2y/jr/mt2yjrl958wkwmuhsrpm3h-4uko.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。都市黑斯廷斯算法使用受理标准都市报：</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/mh/dm/z2/mhdmz27voos90zkz5_-zexopsdc.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
魔术开始了：</font></font><img src="https://habrastorage.org/webt/r2/lm/5b/r2lm5bcuhr-rdtxeg90gjnogcza.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们只知道一个常数，但这并不重要，因为这个未知常数会使...的表达式无效</font></font><img src="https://habrastorage.org/webt/oc/hr/x1/ochrx15_pe9awrsow_fygffjego.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！正是paccpacc属性确保了基于Metropolis-Hastings算法的算法在非规范分布上的运行。通常使用对称辅助分布c </font></font><img src="https://habrastorage.org/webt/b2/ss/pz/b2sspzujgmdn_uwizxwjjokkg5w.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在这种情况下，Metropolis-Hastings算法简化为1953年开发的原始（较不通用）Metropolis算法。在原始算法中</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hd/3k/vq/hd3kvqg9l2jqltan97_gfmzutsi.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，Metropolis-Hastings的完整过渡核心可以写为</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tl/ic/rd/tlicrdfto9zvzlooid7cdt4ii-m.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在PYTHON实施了都市警戒算法</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好了，既然我们已经弄清楚了Metropolis-Hastings算法是如何工作的，那么让我们继续执行它。首先，我们确定要从中进行选择的分布的对数概率-没有归一化常数；假定我们不认识他们。接下来，我们使用标准正态分布：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log_prob</span>(<span class="hljs-params">x</span>):</span>
     <span class="hljs-keyword">return</span> <span class="hljs-number">-0.5</span> * np.sum(x ** <span class="hljs-number">2</span>)</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我们选择对称辅助分布。</font><font style="vertical-align: inherit;">通常，如果您包含要从中进行选择的已知分布信息，则可以改善Metropolis-Hastings算法的性能。</font><font style="vertical-align: inherit;">一种简化的方法是这样的：我们获取当前状态</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并从中选择一个样本</font></font><img src="https://habrastorage.org/webt/tl/ic/rd/tlicrdfto9zvzlooid7cdt4ii-m.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即设置一个特定的步长，</font></font><code>Δ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并从当前状态向左或向右移动不超过</font></font><img src="https://habrastorage.org/webt/q1/n2/d_/q1n2d_lbzpbqtvbmbgiha503cmo.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proposal</span>(<span class="hljs-params">x, stepsize</span>):</span>
    <span class="hljs-keyword">return</span> np.random.uniform(low=x - <span class="hljs-number">0.5</span> * stepsize, <font></font>
                             high=x + <span class="hljs-number">0.5</span> * stepsize, <font></font>
                             size=x.shape)</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我们计算提案被接受的可能性：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">p_acc_MH</span>(<span class="hljs-params">x_new, x_old, log_prob</span>):</span>
    <span class="hljs-keyword">return</span> min(<span class="hljs-number">1</span>, np.exp(log_prob(x_new) - log_prob(x_old)))</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们将所有这些放到Metropolis-Hastings算法的采样阶段的真正简短实现中：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sample_MH</span>(<span class="hljs-params">x_old, log_prob, stepsize</span>):</span><font></font>
    x_new = proposal(x_old, stepsize)<font></font>
    <span class="hljs-comment">#   ,     :</span>
    <span class="hljs-comment">#       [0,1]  </span>
    <span class="hljs-comment">#     </span><font></font>
    accept = np.random.random() &lt; p_acc(x_new, x_old, log_prob)<font></font>
    <span class="hljs-keyword">if</span> accept:
        <span class="hljs-keyword">return</span> accept, x_new
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> accept, x_old</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了在马尔科夫链中的下一个状态，</font></font><code>x_new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或者</font></font><code>x_old</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们也返回有关MCMC步是否被采纳的信息。</font><font style="vertical-align: inherit;">这将使我们能够跟踪样品收集的动态。</font><font style="vertical-align: inherit;">在此实现的最后，我们编写了一个函数，该函数将迭代调用</font></font><code>sample_MH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并因此构建马尔可夫链：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_MH_chain</span>(<span class="hljs-params">init, stepsize, n_total, log_prob</span>):</span><font></font>
<font></font>
    n_accepted = <span class="hljs-number">0</span><font></font>
    chain = [init]<font></font>
<font></font>
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n_total):<font></font>
        accept, state = sample_MH(chain[<span class="hljs-number">-1</span>], log_prob, stepsize)<font></font>
        chain.append(state)<font></font>
        n_accepted += accept<font></font>
    <font></font>
    acceptance_rate = n_accepted / float(n_total)<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> chain, acceptance_rate</code></pre><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试我们的都市行为算法并研究其行为</font></font></b> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
也许，现在您迫不及待想要看到所有这些都在起作用。</font><font style="vertical-align: inherit;">我们将这样做，我们将对参数</font></font><code>stepsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">做出一些明智的决定</font></font><code>n_total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="python hljs">chain, acceptance_rate = build_MH_chain(np.array([<span class="hljs-number">2.0</span>]), <span class="hljs-number">3.0</span>, <span class="hljs-number">10000</span>, log_prob)<font></font>
chain = [state <span class="hljs-keyword">for</span> state, <span class="hljs-keyword">in</span> chain]<font></font>
print(<span class="hljs-string">"Acceptance rate: {:.3f}"</span>.format(acceptance_rate))<font></font>
last_states = <span class="hljs-string">", "</span>.join(<span class="hljs-string">"{:.5f}"</span>.format(state) 
                        <span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> chain[<span class="hljs-number">-10</span>:])<font></font>
print(<span class="hljs-string">"Last ten states of chain: "</span> + last_states)<font></font>
Acceptance rate: <span class="hljs-number">0.722</span>
Last ten states of chain: <span class="hljs-number">-0.84962</span>, <span class="hljs-number">-0.84962</span>, <span class="hljs-number">-0.84962</span>, <span class="hljs-number">-0.08692</span>, <span class="hljs-number">0.92728</span>, <span class="hljs-number">-0.46215</span>, <span class="hljs-number">0.08655</span>, <span class="hljs-number">-0.33841</span>, <span class="hljs-number">-0.33841</span>, <span class="hljs-number">-0.33841</span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事情很好。那么，行得通吗？在大约71％的案例中，我们成功地进行了抽样，并且拥有一系列的州。链还没有收敛到其静态分布的前几个州应该被丢弃。让我们检查一下我们选择的条件是否实际上具有正态分布：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_samples</span>(<span class="hljs-params">chain, log_prob, ax, orientation=<span class="hljs-string">'vertical'</span>, normalize=True,
                 xlims=(<span class="hljs-params"><span class="hljs-number">-5</span>, <span class="hljs-number">5</span></span>), legend=True</span>):</span>
    <span class="hljs-keyword">from</span> scipy.integrate <span class="hljs-keyword">import</span> quad<font></font>
    <font></font>
    ax.hist(chain, bins=<span class="hljs-number">50</span>, density=<span class="hljs-literal">True</span>, label=<span class="hljs-string">"MCMC samples"</span>,<font></font>
           orientation=orientation)<font></font>
    <span class="hljs-comment">#     PDF</span>
    <span class="hljs-keyword">if</span> normalize:<font></font>
        Z, _ = quad(<span class="hljs-keyword">lambda</span> x: np.exp(log_prob(x)), -np.inf, np.inf)
    <span class="hljs-keyword">else</span>:<font></font>
        Z = <span class="hljs-number">1.0</span>
    xses = np.linspace(xlims[<span class="hljs-number">0</span>], xlims[<span class="hljs-number">1</span>], <span class="hljs-number">1000</span>)<font></font>
    yses = [np.exp(log_prob(x)) / Z <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> xses]
    <span class="hljs-keyword">if</span> orientation == <span class="hljs-string">'horizontal'</span>:<font></font>
        (yses, xses) = (xses, yses)<font></font>
    ax.plot(xses, yses, label=<span class="hljs-string">"true distribution"</span>)
    <span class="hljs-keyword">if</span> legend:<font></font>
        ax.legend(frameon=<span class="hljs-literal">False</span>)<font></font>
    <font></font>
fig, ax = plt.subplots()<font></font>
plot_samples(chain[<span class="hljs-number">500</span>:], log_prob, ax)<font></font>
despine(ax)<font></font>
ax.set_yticks(())<font></font>
plt.show()</code></pre><br>
<br>
<img src="https://habrastorage.org/webt/yo/rx/59/yorx59lirnkyju_dymptouaaokw.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看起来不错！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
参数</font></font><code>stepsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>n_total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呢？我们首先讨论步长：它决定了可以从电路的当前状态中去除试验状态的距离。因此，这是一个辅助分布参数</font></font><code>q</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，用于控制马尔可夫链所采取的随机步长。如果步长太大，则试验状态通常会落在分布的尾部，那里的概率值很低。 Metropolis-Hastings采样机制放弃了这些步骤中的大多数步骤，从而降低了接收速率，并且收敛速度大大降低。你自己看：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sample_and_display</span>(<span class="hljs-params">init_state, stepsize, n_total, n_burnin, log_prob</span>):</span><font></font>
    chain, acceptance_rate = build_MH_chain(init_state, stepsize, n_total, log_prob)<font></font>
    print(<span class="hljs-string">"Acceptance rate: {:.3f}"</span>.format(acceptance_rate))<font></font>
    fig, ax = plt.subplots()<font></font>
    plot_samples([state <span class="hljs-keyword">for</span> state, <span class="hljs-keyword">in</span> chain[n_burnin:]], log_prob, ax)<font></font>
    despine(ax)<font></font>
    ax.set_yticks(())<font></font>
    plt.show()<font></font>
    <font></font>
sample_and_display(np.array([<span class="hljs-number">2.0</span>]), <span class="hljs-number">30</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">500</span>, log_prob)<font></font>
Acceptance rate: <span class="hljs-number">0.116</span></code></pre><br>
<br>
<img src="https://habrastorage.org/webt/0g/4-/-r/0g4--rezypxzaqta-pkugq3gi3w.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不是很酷吧？现在看来，最好设置一个很小的步长。事实证明，这也不是明智的决定，因为马尔可夫链将非常缓慢地研究概率分布，因此也不会像选择好的步长那样快收敛：</font></font><br>
<br>
<pre><code class="python hljs">sample_and_display(np.array([<span class="hljs-number">2.0</span>]), <span class="hljs-number">0.1</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">500</span>, log_prob)<font></font>
Acceptance rate: <span class="hljs-number">0.992</span></code></pre><br>
<br>
<img src="https://habrastorage.org/webt/bf/qh/xi/bfqhxistqravnn7xug43ubowgmu.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无论您如何选择步长参数，马尔可夫链最终都会收敛到平稳分布。但这可能会花费很多时间。我们将模拟马尔可夫链的时间由参数</font></font><code>n_total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">决定-它仅确定我们最终将拥有多少个马尔可夫链状态（并因此选择了样本）。如果链收敛缓慢，则需要增加</font></font><code>n_total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该链，以使马尔可夫链有时间“忘记”初始状态。因此，我们将使步长很小，并通过增加参数来增加样本数量</font></font><code>n_total</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="python hljs">sample_and_display(np.array([<span class="hljs-number">2.0</span>]), <span class="hljs-number">0.1</span>, <span class="hljs-number">500000</span>, <span class="hljs-number">25000</span>, log_prob)<font></font>
Acceptance rate: <span class="hljs-number">0.990</span></code></pre><br>
<br>
<img src="https://habrastorage.org/webt/fs/ba/27/fsba27vppyvfqnwdnnr0ifdp3w4.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meeeedenly我们正朝着目标...... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
考虑到上述所有的，我希望现在你已经直观地掌握都市-黑斯廷斯算法，其参数的本质，明白这是为什么从非标准概率分布的选择，你可以在实践中遇到的一个非常有用的工具。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我强烈建议您尝试使用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">此处</font></a><font style="vertical-align: inherit;">给出的代码</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这样您就可以习惯各种情况下的算法行为并更深入地了解它。</font><font style="vertical-align: inherit;">尝试非对称辅助分配！</font><font style="vertical-align: inherit;">如果您没有正确配置接受标准，将会发生什么？</font><font style="vertical-align: inherit;">如果您尝试从双峰分布中采样，会发生什么？</font><font style="vertical-align: inherit;">您能提出一种自动调整步长的方法吗？</font><font style="vertical-align: inherit;">这里有什么陷阱？</font><font style="vertical-align: inherit;">自己回答这些问题！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN491258/index.html">IT女孩，你来自哪里？建立地图</a></li>
<li><a href="../zh-CN491260/index.html">语音识别任务中的文本规范化</a></li>
<li><a href="../zh-CN491262/index.html">以眼还眼。生物识别问题</a></li>
<li><a href="../zh-CN491264/index.html">SSD简介。第4部分。物理</a></li>
<li><a href="../zh-CN491266/index.html">SurfingAttack：使用声音助手破坏智能手机[+视频]</a></li>
<li><a href="../zh-CN491272/index.html">Pascal中的网站开发（后端）</a></li>
<li><a href="../zh-CN491276/index.html">我如何通过Vkontakte文档规避对Messages API的禁止</a></li>
<li><a href="../zh-CN491278/index.html">CLRium＃7：报告，实践，导师</a></li>
<li><a href="../zh-CN491280/index.html">我如何开发编程语言的故事</a></li>
<li><a href="../zh-CN491282/index.html">如何使用集会提高团队生产力（并减少错误）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>