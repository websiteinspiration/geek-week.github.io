<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöº üîç üó®Ô∏è Functional programming is what you (probably) were told. If you listened üë∑ üêá ü¶ã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I like conversations on the topic "I used to be told at school / institute / parents, but now I found out." If, by a lucky chance, I find myself at le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Functional programming is what you (probably) were told. If you listened</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492460/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I like conversations on the topic "I used to be told at school / institute / parents, but now I found out." If, by a lucky chance, I find myself at least a little competent in the matter under discussion, then such conversations usually come down to one of three options: ‚Äúwhere have you heard such nonsense before?‚Äù (if the interlocutor is right), ‚Äúand where did you get that this is so?‚Äù (if he‚Äôs wrong) and ‚Äúyou‚Äôre right, only this does not contradict what you were told before‚Äù (in the vast majority of cases). I like these conversations for the following reason: usually their initiator is not burdened with excessive preliminary knowledge of the issue, which in some cases allows him to point out some points that were accepted as obvious, but not really such. And one of the topics for such conversations was functional programming.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, so much has been written and said about FP that it seems to be all questions about its applicability, coolness, performance, etc. gnawed to the bone marrow. Nevertheless, such questions are raised again and again, and there will always be someone who wants to talk about what you all misunderstood, but in fact it is like that. Perhaps today I will try on myself this ungrateful role, since several posts on this long-suffering topic have recently caught my eye. The </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">second</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> once again says that AF is rubbish and studying it only spoils your future specialist‚Äôs karma. Others ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">two</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) are much more adequate, in them the author aims to explain that all these your lambdas, combinators, categories are nothing more than dust in the eyes, and the FP itself is a simple, understandable and pleasant thing in life. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How true is this?</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before turning to the essence of the issue, I will make a small digression and put emphasis. The content of the first two of these posts, I think is outright nonsense of an illiterate ... specialist who, with his fingers spread apart, discusses things that he didn‚Äôt even spend a bit of his precious time studying. Good people from among the commentators have already indicated that this is nothing more than banter. The problem is that, as it turned out, I am not able to perceive the theses put forward in these translations as a banter, since I had to hear most of them live. Apparently, you can diagnose the presence of psychological trauma caused by an oversupply of nonsense that has passed through the brain.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second two were more likely to evoke positive emotions, because in them the author applies the practice of FP to the tasks that the OOP developer understands. Despite the disagreement with the basic message of the first publication reflected in the title and doubts about the reasonableness of the implementation of the monad concept in such an explicit form in the OOP-oriented language, the author cannot be reproached for the lack of elaboration of the material. But there is one basic aspect, which I could not ignore. This is a kind of vulgarization of functional programming, an attempt to consider it as a simple set of tools and approaches to program design. Which, in my opinion, is not entirely true.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, in this article, an attempt is made to show that the properties of functional programs that the author is trying to reproduce in his code are not the foundation of functional programming, not laid down by the wise creators of Haskell and his ilk design solutions, but either a direct consequence of those concepts and models that really laid in its foundation, or, oddly enough, an attempt to compensate for the shortcomings that these foundations generate.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So to the point</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In science, quite often you can observe the following metamorphosis. First, as part of the consideration of a certain process / phenomenon / theory, a certain object appears that possesses some important and useful properties. But it usually also turns out to be rather complicated in its structure, which limits its practical usefulness. Therefore, they often act in this way: they take the properties of a given object as a basis and on this basis build a new theory / model / description, within which the desired object becomes simple or even trivial, or the necessary inherent properties appear in much simpler objects. Something like this is related to the "real" functional programming and the "elements of functional programming", which are available in modern high-level languages.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since it is usually useful to familiarize oneself with the history of its origin for understanding a phenomenon, let us recall the moments of the history of the theory of computation and programming that are important for our question. In the late nineteenth and early twentieth centuries there was a significant restructuring of the foundation of mathematical science. This not only solved a number of identified problems and contradictions that crept into the very core of the ideas at that time that there was mathematics and mathematical proof, but also posed a number of new questions. One of them was the following: what is the algorithm? Or, what is the same, what class of problems can be solved purely mechanically. I will not expand on why this question turned out to be important; I‚Äôd better go straight to the answer that Alan Turing, widely known in not very narrow circles, gave him. He formulated the thesis:"Only functions for which a Turing machine can be constructed are computable." This statement is unproven. That is, in fact, Turing simply gave a strict formal definition of what is considered a computable function, consistent with those intuitive representations that are usually embedded in this concept. This definition proved to be able to satisfy the applicants, because they are well aware of what a machine is, even with an infinite ribbon, and how it should function. But for many mathematicians, this definition is not too satisfied.which are usually invested in this concept. This definition proved to be able to satisfy the applicants, because they are well aware of what a machine is, even with an infinite ribbon, and how it should function. But for many mathematicians, this definition is not too satisfied.which are usually invested in this concept. This definition proved to be able to satisfy the applicants, because they are well aware of what a machine is, even with an infinite ribbon, and how it should function. But for many mathematicians, this definition is not too satisfied.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apparently, the concepts that Turing operated on seemed to them insufficiently ... abstract. </font><font style="vertical-align: inherit;">In this regard, they did not abandon attempts to give a different definition, which would cover a larger class of mathematical functions and at the same time still correspond to our intuitive ideas. </font><font style="vertical-align: inherit;">These attempts were fruitless. </font><font style="vertical-align: inherit;">Each alternative definition that was proposed and withstood criticism turned out to be equivalent to Turing's definition in the sense that it described exactly the same class of mathematical functions. </font><font style="vertical-align: inherit;">However, these studies were by no means useless. </font><font style="vertical-align: inherit;">Attempts to look at the object of study from a different point of view are generally rarely useless. </font><font style="vertical-align: inherit;">In our case, this led to the appearance of several theories, one of which was the lambda calculus proposed by Alonzo Church.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laziness is the engine of progress</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is so useful in lambda calculus and why is everyone so fussing with it? Everything is simple. In the model proposed by Turing, the algorithm is a sequence of instructions that is familiar to us, which again must be executed by the usual performer. It is intuitive. But Church‚Äôs definition is different. The main (and essentially the only) building mechanism in the framework of this theory is the so-called lambda terms, which in our current terms can (conditionally) be called anonymous functions. The program (algorithm) in this case is a combination of these terms built according to certain rules, the initial data are the values ‚Äã‚Äãof the free variables of the lambda term, and the calculation process is nothing more than a reduction (simplification) of the lambda term (function), which can be performedas soon as some free variable gets value. The following fact turned out to be unexpected here: as soon as a variable receives a value - that is, as soon as we present a part of the initial data to the program - we can perform the reduction, but not in one, but in two ways. In the first case, the calculation process turns out to be equivalent to that reproduced by typical mechanical calculators like a Turing machine. The rule corresponds to it: the arguments of the function must be calculated before the function itself is calculated. But there is another option - the so-called partial calculation. In this case, if only a part of the arguments is calculated, we can still calculate (reduce) that part of the function that uses only these arguments. This approach is usually called the "lazy" model of computing.In contrast to this, the Turing model of computations is sometimes called ‚Äúenergetic‚Äù or ‚Äúgreedy‚Äù; programming languages ‚Äã‚Äãbuilt on its basis will be called imperative below. An important feature of "lazy" calculations is that if a subroutine is written as a function of, say, three arguments, but in reality uses only two, then there is no need to calculate this third argument in order to calculate the value of the function.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And this gives us interesting practical possibilities. </font><font style="vertical-align: inherit;">For example, the ability to work with infinite sequences. </font><font style="vertical-align: inherit;">It would be easy for anyone who began to get to know functional programming in general and with the Haskell language in particular to understand this way of getting the first </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fibonacci numbers:</font></font><br>
<br>
<pre><code class="haskell">fibonacci2 a b = a : (fibonacci2 b (a+b))<font></font>
fibonacci = fibonacci2 1 1<font></font>
<font></font>
nfibonacci n = take n fibonacci</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explanation for Strangers with Haskell</font></font></b><div class="spoiler_text"><i>fibonacci2</i>      ,       ,         fibonacci2    b   (a+b).  ( !)     :<br>
<pre><code class="python">def fibonacci2(a, b) :<font></font>
    return [a] + fibonacci2(b, a+b)<font></font>
<font></font>
def fibonacci() :<font></font>
    return fibonacci2(1, 1)<font></font>
<font></font>
def nfibonacci(n) :<font></font>
    res = []<font></font>
    data = fibonacci()<font></font>
    for i in range(n) :<font></font>
      res.append( data[i] )<font></font>
    return res<font></font>
</code></pre><br>
   nfibonacci.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">(and this is precisely the function) generates an endless list of numbers. If we used the computational model familiar to us, then nfibonacci could never have ended (which, I recall, is perfectly acceptable and does not contradict the notions of its ‚Äúcomputability‚Äù). But if we use the "lazy" model of calculations, it is easy to notice that as soon as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> takes on a specific value, to get the value of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nfibonacci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><i><font style="vertical-align: inherit;">,</font></i><font style="vertical-align: inherit;"> we need only the first n elements of the list that is the result of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">. In this case, we can act like this: get the list item - perform the reduction, the next element is another reduction step, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-th argument - reduction led to obtaining the value of the function. That is, in this case we get a result for a finite time despite the "loop" of the procedure for constructing a list of Fibonacci numbers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here, a particularly zealous imperative-minded reader exclaims: ‚Äú </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But wait, only a frank idiot will implement the construction of a list of Fibonacci numbers this way! There are obvious solutions that do not lead to a loop</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". And he, of course, will be right. The stupid transfer of a solution involving the implementation of the model of" lazy "calculations into a program for" greedy "calculations is not really an indicator of great intelligence. If you offer this task to a programmer who has kept his entire professional life Loyalty, say, to the C language, then he will most likely offer a variant with one cycle with a counter and two state variables.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But the point is not the Fibonacci numbers themselves. The fact is that the rule for constructing a sequence in this example is separated from the method of processing its elements. And this is a useful property that it is desirable to be able to reproduce in more complex cases, when the elements of the processed sequence are generated in a rather complicated way and a simple transfer of the solution ‚Äúhead-on‚Äù for the Fibonacci sequence in this case is ineffective in time, memory, or simply leads to code, the understanding of which is not accessible to mere mortals. Such an aspiration is natural and can be realized, for example, through the use of iterators or generators. In python, for example, we can do this:</font></font><br>
<br>
<pre><code class="python">def fibonacci() :<font></font>
    a = 1<font></font>
    b = 1<font></font>
    yield a<font></font>
    yield b<font></font>
    while True :<font></font>
      c = a + b<font></font>
      yield c<font></font>
      a = b<font></font>
      b = c<font></font>
     <font></font>
def nfibonacci(n) :<font></font>
    return [e for e in itertools.islice(fibonacci(), n)]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a generator that creates a sequence element by element. And in this case, instead of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci, there</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be a generator function of any complexity. If we bring the code completely, including the engine hood code, we get a very complex and completely imperative software design. But the final version is quite ‚Äúfunctional‚Äù. In C ++, one could do a similar trick by having a special </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fibonachi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">and iterators for it. The decision will vary depending on the features of the programming language and the preferences of the programmer, but the goal will remain the same - to divide at the organization level of the program a way to build a sequence of previously unknown lengths and a way to process its elements.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The difference is that in the framework of the functional approach, such a program organization is natural and is imposed by the very method of its implementation, while in the framework of the imperative program it requires additional creative work, including the creation of additional concepts and design patterns.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cleanliness is the key to health</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another property, in the presence of which they speak of a functional approach to programming, is the ‚Äúpurity‚Äù of functions. </font><font style="vertical-align: inherit;">It is the absence of side effects. </font><font style="vertical-align: inherit;">That is, a function call with the same set of arguments should lead to the same result. </font><font style="vertical-align: inherit;">The author of the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cited</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> post described in sufficient detail why in programs executed in an imperative style, this property is also desirable. </font><font style="vertical-align: inherit;">However, it is nothing more than a consequence of the model of calculations used.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The reason that all functions in a functional program must be clean is simple. Assuming the presence of these very side effects, it turns out that the order in which the function arguments get their value directly affects the result of the function. We can say that this is also true in the framework of the imperative approach, but in the case of ‚Äúlaziness‚Äù of calculations, everything is much worse. Even if we assume that the arguments of the function can be calculated independently of each other in arbitrary order, then ‚Äúlaziness‚Äù still implies that (conditionally) not all the code of the function will be executed in one sitting. It will be executed in parts, depending on two things - in fact, the structure of the function that the conditional compiler will kindly provide us with, and the order in which we will present the function with its arguments.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It‚Äôs natural for us to expect that if we first defined a function </font></font><br>
<br>
<pre><code class="python">def f(x,y) :<font></font>
  ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and after her </font></font><br>
<pre><code class="python">def g(x, y) :<font></font>
  return f(y, x)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
then the result of calling </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g (a, b)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will be equal to the result of calling </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f (b, a)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for any independently computable values ‚Äã‚Äãof </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But if </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has side effects affecting the calculation of argument values, then our expectations can be brutally deceived</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">For example, when calculating </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , reading from the file occurs - and when calculating </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , reading from the same file also occurs. </font><font style="vertical-align: inherit;">In ‚Äúlazy‚Äù calculations, we don‚Äôt know in advance which part of the code (for </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or for </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) will be executed first. That means we don‚Äôt know what result the program will give even if we know the contents of the file that it should read. Such behavior is in principle unacceptable and therefore should be categorically excluded. So, within the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">framework of the model of ‚Äúlazy‚Äù calculations (uncontrolled) side effects of the function should be prohibited</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the greedy order of calculations is applied, the side effects are much more predictable. For this and only for this reason they are allowed in imperative programming. But if you abuse them, then the feature will turn into a bug. So, you should not abuse them. So, again, the concept of ‚Äúpurity‚Äù that is natural in functional programming is in demand in the imperative world. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consequently, the thesis</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Functional program - a program consisting of pure functions </font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incorrect if viewed as a definition. </font><font style="vertical-align: inherit;">Yes, a functional program consists of ‚Äúpure‚Äù functions, but a program consisting of pure functions does not have to be ‚Äúfunctional‚Äù at all. </font><font style="vertical-align: inherit;">This is her property, but not a defining property.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, there is a problem. The ability to save state and even banal input-output are things directly related to side effects. And life without them is full of pain and suffering. The question arises: how to marry side effects and "lazy" calculations? The answer in general is no way. The answer is correct - in each particular case a satisfactory particular solution should be sought. It turned out that many ways of reproducing calculations with side effects without violating the concept of ‚Äúpurity‚Äù of calculations fit into the general concept of the monad, borrowed from category theory. I would not want to try again to explain what it is and what it is eaten with, if only because in any case it will not replace (and in my experience it will not even simplify) an explanation of how state variables can be implemented specifically,exceptions and similar things in ‚Äúpure‚Äù functional languages. The main moral is that imperative programming is a source of inspiration for the functional as well as functional for the imperative. Moreover, sometimes an idea passes through a competing concept as through a filter, returns back in an altered form and leads to the appearance of a new tool.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Are monads needed in an imperative world? I have no established opinion on this issue. The author of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fasting sure that needed. I am inclined to doubt this statement, since the use of the concept of a monad in functional programs is usually connected with the fact that a certain algorithm can be formulated regardless of which specific side effects this monad hides. In other words, if a user-defined (hypothetical, not yet created by mankind) data type satisfies the requirements for a monad, then the written algorithm for it will work correctly. This is convenient primarily in theoretical studies. But there is a couple of nuances. Firstly, it is not very clear why to hide in the wrapper side effects are effective in languages ‚Äã‚Äãfor which they are a natural phenomenon. Secondly,when writing specific programs with specific data types and a specific target architecture, such a generalized algorithm is most often forced to undergo a restructuring in order to increase productivity. Writing generalized algorithms using monads in an imperative style is possible, but the appropriateness of this approach raises my doubts. The fact that some Maybe analog of type std :: optional from C ++ will be declared a monad is unlikely to somehow affect the practice of its use.</font></font><br>
<br>
<h3>   ?</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Higher-order functions are a tool so widely used in functional programs that the fact of supporting something similar in some programming language is enough for some strange individuals to recognize this language as functional. What are "higher order functions"? This is a function that operates on other functions as arguments, or returns a function as a result. It would seem that here can cause debate? It turns out a lot. To begin with, what is generally understood by the term ‚Äúfunction‚Äù. Programmers usually reason simply: if something can be called as a function, then it can be considered as a function. In the framework of the imperative approach, this makes sense, since intuitively a function is that for a given set of arguments it gives a certain result.If we admit the presence of side effects, then in the practical sense there really is no difference between the "normal" function of the language and, say, the object of the class having the overloaded operator ().</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But in functional programming, such a definition of a function is not constructive enough, since it does not make it possible to interpret the concept of a partial calculation of this function itself. In functional programming, a function is not ‚Äúone of‚Äù the structural elements of a program, but in a certain sense the opposite: all program elements are functions. Therefore, in fact, this is ‚Äúfunctional programming‚Äù. And then again, if everything is a function, that is, any argument of any function is a function, then any function with arguments is a higher-order function. Hence, higher-order functions are a natural element of a functional program. So much so that even their allocation in a separate class does not make much sense. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a higher order function, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">map</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font><i><font style="vertical-align: inherit;">fold is</font></i><font style="vertical-align: inherit;"> usually given.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. But we will consider a more trivial - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">any</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - function of the two arguments </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f (x, y)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Within the framework of the model of ‚Äúlazy‚Äù calculations, the arguments of this function will be calculated only when they are really needed. Suppose the first argument is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We calculate this argument, provide its value </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and, in addition, calculate everything that we can calculate without using the value of the argument </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Then the rest of the calculations can be represented as a new function, already </font><font style="vertical-align: inherit;">independent </font><font style="vertical-align: inherit;">of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , for example, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g (y)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . But in this case, nothing prevents us formally presenting </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> not as a function of two arguments, but as a function of one argument</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the result of which is another function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g (y)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In other words, within the framework of the functional approach, any function of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N&gt; 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arguments is a higher order function, since it can be interpreted as a function of one argument, the result of which is the function of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arguments. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Can we implement this behavior as part of an imperative approach? Of course we can. In python, we would write something like the following:</font></font><br>
<br>
<pre><code class="python">def partial(f, x) :<font></font>
	def g(*args) :<font></font>
		return f(x, *args)<font></font>
	return g<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By calling the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">, the first argument of which is the function of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arguments, and the second is the value of its first argument, we get the function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1 of the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> argument. Now we can use the new function wherever we can use the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> argument </font><font style="vertical-align: inherit;">function </font><font style="vertical-align: inherit;">. That is, they got the same thing as in the functional program. So? No not like this. If we were dealing with a truly functional program, then when we called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we would calculate part of what the value of the first argument is for. In some cases, it might even turn out that </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a constant value. What do we have in an imperative analogue? The passed value of the argument </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">just remembered (added to the context of the function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). When we call </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the value of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will be taken out of the bins and simply substituted into </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . That is, there is no difference in form, but in content - significant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using functions from functions is convenient because it allows you to naturally describe many important algorithms. So, they were obliged to appear in imperative programming languages. And they appeared. But since they use a different calculation model, this would have required the development of new concepts. And they were developed. For example, the closure described above. That is, the functions of higher orders in imperative languages ‚Äã‚Äãcorrespond to what can be observed in functional languages, only externally. But the content is completely different. Is this important for the programmer? Probably not, but only if he understands well how those mechanisms work that implement similar features in his favorite programming language. Otherwise, you can, for example, implement "partial application", close when building a new function (well, orwhat in your case will look like a function) link instead of value and get interesting program behavior. And after that, shout about the inferiority of the functional approach.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So who was cheating on whom?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At this stage of the presentation, it is quite possible to put a semicolon and return to the main question. </font><font style="vertical-align: inherit;">Since now we can formulate the following statements:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main difference between functional programming and imperative programming is not the property of purity of functions, the presence of anonymous functions, higher-order functions, monads, parametric polymorphism, or anything else. </font><font style="vertical-align: inherit;">The main difference is the use of a different calculation model. </font><font style="vertical-align: inherit;">Everything else is nothing more than consequences.</font></font></li>
<li>,         ,       .    .     ,      ¬´¬ª  ¬´¬ª .    ,                  .  .</li>
<li>  ,      ,        ,           .        .   ‚Äî .</li>
<li>      ,      .       ,        ¬´¬ª ;   ,       .           ,      -     ,   -      .    .</li>
<li>   ,                 .     ,        . , ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">  </a>    ,                           .          .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Functional programming is what you (probably) were told about. These are beta reduction, fixed point combinators, monads, Hindley-Milner typing, and more. Do not confuse the wrapper with the content. FP is not based on the simplest mathematics; it cannot be mastered for a couple of evenings with a glass of tea; it is unlikely to be directly projected onto your pressing problems and projects; you won‚Äôt get a guaranteed and quick profit from this knowledge. But many elements of what is in the functional approach are borrowed, processed, and ultimately implemented in programming languages ‚Äã‚Äãoriented towards the development of large projects. Yes, they are arranged differently than their functional ancestors, but this does not make them less useful. Only a clinical idiot will broadcast a serious message that Haskell is a bad language,because it‚Äôs hard to write a program for any kind of accounting. A person burdened with the presence of intelligence, even from the standpoint of his professional activity, without a deep immersion in the intricacies of theory is quite capable of understanding exactly which practices from functional programming should be adopted in order to make your code better. For a convincing demonstration of which I express gratitude</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Psyhast</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Learn functional programming. </font><font style="vertical-align: inherit;">In the name of yourself.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en492448/index.html">The digest of fresh materials from the world of the front-end for the last week No. 406 (March 9 - 15, 2020)</a></li>
<li><a href="../en492450/index.html">Updated 03.31. Is coronavirus transmitted through the air? What is known at the moment</a></li>
<li><a href="../en492454/index.html">We sell Architecture Refactoring to a client or what is the problem of developers</a></li>
<li><a href="../en492456/index.html">How to visualize and animate (geophysical) models. Show raw data</a></li>
<li><a href="../en492458/index.html">Simple GUI for M5Stack (Arduino)</a></li>
<li><a href="../en492462/index.html">Source of truth: how an analyst teaches a manager and a developer to work together</a></li>
<li><a href="../en492464/index.html">DBA: competently organize synchronization and imports</a></li>
<li><a href="../en492466/index.html">How to move from any host provider with cPanel to Plesk in Rusonix in just five steps</a></li>
<li><a href="../en492468/index.html">Lenovo Thinkserver SE350: a hero from the periphery</a></li>
<li><a href="../en492474/index.html">We structure the information on Android boxes and analyze what a normal prefix should be able to do.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>