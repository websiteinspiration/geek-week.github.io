<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌦️ 🧔🏽 🕚 《打击与网络安全：Linux命令行中的攻击，防御和分析》一书 🤜 🧗🏻 👩🏼‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您好，habrozhiteli！命令行可以是网络安全的理想工具。如果您具有适当的经验，那么令人难以置信的灵活性和绝对可用性将标准命令行界面（CLI）变为基本解决方案。
 
 Paul Tronkon和Karl Albing的作者讨论了命令行工具和技巧，这些工具和技巧可帮助您通过主动保护来收集数据，分...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>《打击与网络安全：Linux命令行中的攻击，防御和分析》一书</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/501528/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/xx/ml/ir/xxmlirxciwbxahmteiy-9cslfxg.jpeg" align="left" alt="图片"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您好，habrozhiteli！</font><font style="vertical-align: inherit;">命令行可以是网络安全的理想工具。</font><font style="vertical-align: inherit;">如果您具有适当的经验，那么令人难以置信的灵活性和绝对可用性将标准命令行界面（CLI）变为基本解决方案。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paul Tronkon和Karl Albing的作者讨论了命令行工具和技巧，这些工具和技巧可帮助您通过主动保护来收集数据，分析日志并监视网络运行状况。</font><font style="vertical-align: inherit;">渗透测试人员将学习如何使用几乎所有版本的Linux内置的强大功能进行攻击。</font></font><br>
<a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这本书是给谁的？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
《打击与网络安全》一书是为那些想要学习如何在计算机安全性背景下使用命令行的人准备的。</font><font style="vertical-align: inherit;">我们的目标不是用命令行脚本替换现有工具，而是教您如何有效地使用命令行来改善现有功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在整本书中，我们提供了一些安全方法的示例，例如数据收集，分析和渗透测试。</font><font style="vertical-align: inherit;">这些示例的目的是演示命令行功能，并向您介绍高级工具中使用的一些基本方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管第一部分介绍了一些常规概念，但本书并非编程入门。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实时日志监控</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事件发生后分析杂志的能力是一项重要技能。</font><font style="vertical-align: inherit;">但是，同样重要的是，能够实时从日志文件中提取信息，以便在恶意或可疑行为发生时对其进行检测。</font><font style="vertical-align: inherit;">在本章中，我们将研究读取日记条目的方法，这些日记条目的创建和格式设置为显示分析，并基于系统或网络的已知威胁指标（危害指标）生成警报。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文字记录监控</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实时监视日志的最简单方法是使用带–f参数的tail命令-它会连续读取文件，并在添加新行时将其显示在stdout中。与前面的章节一样，例如，我们将使用Apache Web服务器访问日志，但是所描述的方法与任何文本日志都相关。要使用tail命令跟踪Apache访问日志，请输入以下内容：</font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tail命令的输出可以传递到grep命令，因此将仅显示符合特定条件的记录。以下示例跟踪Apache访问日志并显示与特定IP地址相对应的条目：</font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | grep '10.0.0.152'<br>
</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您也可以使用正则表达式。在此示例中，将仅显示返回HTTP 404状态代码“找不到页面”的记录。添加了-i选项以忽略字符的情况：</font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | egrep -i 'HTTP/.*" 404'</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要清除无关的信息，应将输出传递给cut命令。本示例监视访问日志以查找导致状态码404的查询，然后使用cut方法仅显示日期/时间和所请求的页面：</font><font style="vertical-align: inherit;">
接下来，要删除方括号和双引号，可以将输出定向到tr -d' []“'。</font></font><br>
<br>
<code>$ tail -f access.log | egrep --line-buffered 'HTTP/.*" 404' | cut -d' ' -f4-7<br>
[29/Jul/2018:13:10:05 -0400] "GET /test<br>
[29/Jul/2018:13:16:17 -0400] "GET /test.txt<br>
[29/Jul/2018:13:17:37 -0400] "GET /favicon.ico</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：此处使用egrep命令的--line-buffering选项。</font><font style="vertical-align: inherit;">每次换行时，这都会迫使egrep打印到stdout。</font><font style="vertical-align: inherit;">如果没有此参数，将发生缓冲，并且直到缓冲区已满，才将输出发送到cut命令。</font><font style="vertical-align: inherit;">我们不想等待那么久。</font><font style="vertical-align: inherit;">此选项允许egrep命令在找到每一行时将其写入。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
缓冲区在缓冲期间会发生什么？</font><font style="vertical-align: inherit;">想象一下，egrep找到很多与指定模式匹配的字符串。</font><font style="vertical-align: inherit;">在这种情况下，egrep将有很多输出。</font><font style="vertical-align: inherit;">但是输出（实际上是任何输入或输出）比数据处理（文本搜索）要昂贵得多（花费更多时间）。</font><font style="vertical-align: inherit;">因此，I / O调用越少，程序的效率就越高。</font></font><br>
<br>
     grep       ,  ,          .         .  grep       .   ,  grep   50    .   ,     50  ,     ,     .   50  !<br>
<br>
       egrep, ,             .  egrep       ,     ,     .    ,    ,   ,      ,      .      ,     .<br>
<br>
    ,    ,  tail -f        (    ),       . ,       « »,      .     .          .<br>
<br>
   ,        egrep     ,     .        ,   .</blockquote><br>
<h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以使用tail和egrep命令来监视日志并显示与已知的可疑或恶意活动模式（通常称为IOC）相对应的任何条目。您可以创建一个简单的入侵检测系统（IDS）。首先，创建一个包含IOC正则表达式模式的文件，如示例8.1所示。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
示例8.1 ioc.txt </font><b><font style="vertical-align: inherit;">（1）</font></b><font style="vertical-align: inherit;">此模板（../）表示回旋目录攻击：攻击者试图退出当前工作目录并获取他无法访问的文件。</font><b><font style="vertical-align: inherit;">（2）</font></b><font style="vertical-align: inherit;"> Linux etc / passwd和etc / shadow文件用于系统身份验证，并且绝对不能通过Web服务器进行访问。</font><b><font style="vertical-align: inherit;">（3）</font></b></font><br>
<br>
<code>\.\./ <b>(1)</b><br>
etc/passwd <b>(2)</b><br>
etc/shadow<br>
cmd\.exe <b>(3)</b><br>
/bin/sh<br>
/bin/bash<br>
</code><br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供cmd.exe，/ bin / sh或/ bin / bash文件表示Web服务器返回的反向连接。反向连接通常表示操作成功。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，IOC必须采用正则表达式格式，因为稍后它们会被egrep命令使用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ioc.txt文件可以与egrep -f选项一起使用。此参数告诉egrep从指定文件中搜索正则表达式模式。这使您可以使用tail命令监视日志文件，并在添加每条记录时，会将读取的行与IOC文件中的所有模板进行比较，显示任何对应的记录。这是一个例子：</font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | egrep -i -f ioc.txt</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，可以使用tee命令在屏幕上同时显示警告，并将警告保存以供以后在其自己的文件中处理：</font><font style="vertical-align: inherit;">
同样，需要--line-buffered选项以确保不会由于缓冲命令输出而引起问题。</font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | egrep --line-buffered -i -f ioc.txt |<br>
tee -a interesting.txt</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows日志监控</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如前所述，您必须使用wevtutil命令访问Windows事件。</font><font style="vertical-align: inherit;">尽管此命令是通用的，但它没有诸如tail之类的功能，该功能可用于检索新的传入记录。</font><font style="vertical-align: inherit;">但是有一种解决方法-使用可以提供相同功能的简单bash脚本（示例8.2）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
示例8.2 </font><font style="vertical-align: inherit;">wintail.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# wintail.sh<font></font>
#<font></font>
# :<font></font>
#    tail   Windows<font></font>
#<font></font>
# : ./wintail.sh<font></font>
#<font></font>
<font></font>
WINLOG=<span class="hljs-string">"Application"</span> (<span class="hljs-number">1</span>)<font></font>
<font></font>
LASTLOG=$(wevtutil qe <span class="hljs-string">"$WINLOG"</span> <span class="hljs-comment">//c:1 //rd:true //f:text) (2)</span><font></font>
<font></font>
<span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span>
<span class="hljs-keyword">do</span>
      CURRENTLOG=$(wevtutil qe <span class="hljs-string">"$WINLOG"</span> <span class="hljs-comment">//c:1 //rd:true //f:text) (3)</span>
      <span class="hljs-keyword">if</span> [[ <span class="hljs-string">"$CURRENTLOG"</span> != <span class="hljs-string">"$LASTLOG"</span> ]]<font></font>
      then<font></font>
            echo <span class="hljs-string">"$CURRENTLOG"</span>
            echo <span class="hljs-string">"----------------------------------"</span>
            LASTLOG=<span class="hljs-string">"$CURRENTLOG"</span><font></font>
      fi<font></font>
done</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此变量定义要跟踪的Windows日志。有关系统上当前可用日志的列表，可以使用wevtutil el命令。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，执行wevtutil以请求指定的日志文件。 c：1参数仅返回一个日志条目。 rd：true参数允许命令读取最新的日志条目。最后，f：text以纯文本而不是XML格式返回结果，这使得从屏幕上读取结果变得容易。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（3）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来的几行再次运行wevtutil命令，并将新接收到的日志条目与屏幕上显示的最后一个日志条目进行比较。</font><font style="vertical-align: inherit;">如果它们彼此不同，则意味着日志中已有更改。</font><font style="vertical-align: inherit;">在这种情况下，将显示一个新条目。</font><font style="vertical-align: inherit;">如果要比较的记录相同，则什么也不会发生，并且wevtutil命令返回并开始再次搜索和比较。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实时直方图创建</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tail -f命令提供当前数据流。</font><font style="vertical-align: inherit;">但是，如果您要计算在一定时间内添加到文件的行数，该怎么办？</font><font style="vertical-align: inherit;">您可以观察此数据流，启动计时器并在指定的时间段内执行计数；</font><font style="vertical-align: inherit;">然后应停止计数并报告结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这项工作可以分为两个脚本过程：一个脚本将读取行，另一个脚本将观看时间。计时器使用称为信号的标准POSIX进程间通信机制通知线路计数器。信号是软件中断，并且存在各种信号。其中一些是致命的-它们导致流程结束（例如，浮点运算中的异常）。这些信号大多数都可以忽略或捕获。捕获信号时采取措施。这些信号中的许多信号在操作系统中都有预定的用途。我们将使用用户可用的两个信号之一。这是信号SIGUSR1（另一个是SIGUSR2）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Shell脚本可以使用内置的trap命令捕获中断。在它的帮助下，您可以选择一个命令，该命令确定接收到信号后要执行的操作，以及触发该命令调用的信号列表。例如：</font></font><br>
<br>
<code>trap warnmsg SIGINT</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每当外壳程序脚本收到SIGINT信号（例如，按Ctrl + C中断正在运行的进程）时，这都会导致调用warnmsg命令（我们自己的脚本或函数）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例8.3显示了执行计数的脚本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
示例8.3 looper.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# looper.sh<font></font>
#<font></font>
# :<font></font>
#    <font></font>
#<font></font>
# : ./looper.sh [filename]<font></font>
# filename —  ,   ,<font></font>
#  : log.file<font></font>
#<font></font>
<font></font>
<span class="hljs-function">function <span class="hljs-title">interval</span> <span class="hljs-params">()</span>                                           <span class="hljs-params">(<span class="hljs-number">1</span>)</span>
</span>{<font></font>
      echo $(date <span class="hljs-string">'+%y%m%d %H%M%S'</span>) $cnt                       (<span class="hljs-number">2</span>)<font></font>
      cnt=<span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
declare -i cnt=<span class="hljs-number">0</span>
<span class="hljs-function">trap interval <span class="hljs-title">SIGUSR1</span>                                          <span class="hljs-params">(<span class="hljs-number">3</span>)</span>

shopt -s <span class="hljs-title">lastpipe</span>                                              <span class="hljs-params">(<span class="hljs-number">4</span>)</span>

tail -f --pid</span>=$$ ${<span class="hljs-number">1</span>:-log.file} | <span class="hljs-function"><span class="hljs-keyword">while</span> read <span class="hljs-title">aline</span>             <span class="hljs-params">(<span class="hljs-number">5</span>)</span>
<span class="hljs-keyword">do</span>
     let cnt++
done</span></code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间隔函数将在收到每个信号时被调用。当然，必须先定义间隔，然后才能命名并在表达式中使用trap。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用date命令可为我们正在打印的cnt变量的值提供时间戳。显示计数器后，我们将此值重置为0，以开始下一个间隔的倒计时。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（3）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在定义了时间间隔，我们可以表明只要我们的进程接收到信号SIGUSR1就会调用该函数。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（4）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是非常重要的一步。通常，当存在命令管道（例如ls-l | grep rwx | wc）时，部分管道（每个命令）在子网中执行，并且每个进程以其自己的进程标识符结尾。对于这种情况，这可能是一个问题，因为while循环将位于具有不同进程标识符的子外壳中。无论启动什么进程，looper.sh脚本都不知道while循环进程的标识符来向其发送信号。此外，在子外壳中更改cnt变量的值不会更改主进程中的cnt值，因此主进程的信号每次都会将该值设置为0。您可以使用shopt命令解决此问题，该命令将（-s）参数设置为lastpipe。它告诉外壳程序不要为管道中的最后一个命令创建子外壳程序，并以与脚本本身相同的过程运行此命令。在我们的例子中，这意味着tail命令将在子shell中（即在另一个进程中）执行，而while循环将成为主脚本进程的一部分。注意：此shell选项仅在bash 4.x及更高版本中可用，并且仅适用于非交互式shell（即脚本）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（5）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是带有另一个--pid参数的tail -f命令。我们指示该进程的标识符，该标识符在完成该进程后将终止tail命令。我们指定要查看的当前shell脚本$$的进程ID。此操作使您可以清理进程，而不必在后台执行tail命令（例如，如果此脚本在后台运行；示例8.4）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tailcount.sh脚本使用秒表（计时器）启动和停止脚本，并计算时间间隔。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
示例8.4 tailcount.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# tailcount.sh<font></font>
#<font></font>
# :<font></font>
#    n <font></font>
#<font></font>
# : ./tailcount.sh [filename]<font></font>
#     filename:  looper.sh<font></font>
#<font></font>
<font></font>
#  —    <font></font>
<span class="hljs-function">function <span class="hljs-title">cleanup</span> <span class="hljs-params">()</span>
</span>{<font></font>
      [[ -n $LOPID ]] &amp;&amp; kill $LOPID          (<span class="hljs-number">1</span>)<font></font>
}<font></font>
<font></font>
<span class="hljs-function">trap cleanup <span class="hljs-title">EXIT</span>                             <span class="hljs-params">(<span class="hljs-number">2</span>)</span>
bash looper.sh $1 &amp;                           <span class="hljs-params">(<span class="hljs-number">3</span>)</span>
LOPID</span>=$!                                      (<span class="hljs-number">4</span>)<font></font>
#   <font></font>
sleep <span class="hljs-number">3</span><font></font>
<font></font>
<span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span>
<span class="hljs-keyword">do</span><font></font>
      kill -SIGUSR1 $LOPID<font></font>
      sleep <span class="hljs-number">5</span>
done &gt;&amp;<span class="hljs-number">2</span>                                      (<span class="hljs-number">5</span>)</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于此脚本将运行其他脚本，因此应在工作后清除。如果进程标识符存储在LOPID中，则变量将存储该值，因此该函数将使用kill命令向该进程发送信号。如果您在kill命令中未指定特定信号，则默认情况下将发送SIGTERM信号。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EXIT命令不是信号。如果执行该脚本的外壳要关闭时，trap语句告诉外壳程序调用此函数（在这种情况下为清理），则这是一种特殊情况。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（3）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在真正的工作开始了。将启动looper.sh脚本，该脚本将在后台运行：要使该脚本在整个周期中都能正常工作（无需等待命令完成工作），请与键盘断开连接。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（4）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里，存储了我们刚刚在后台启动的脚本过程的标识符。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（5）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此重定向只是预防措施。来自while循环或kill / sleep语句（尽管我们不希望它们）的所有输出都不应与looper.sh函数的任何输出混合，该函数虽然在后台工作，但仍将其发送到stdout。因此，我们将数据从stdout重定向到stderr。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总而言之，我们看到尽管looper.sh函数位于后台，但其进程标识符存储在shell变量中。每五秒钟，tailcount.sh脚本会向该进程发送一个信号SIGUSR1（在looper.sh函数中执行），该信号又调用looper.sh脚本以打印其中固定的当前行数并重新开始计数。退出后，通过向looper.sh函数发送SIGTERM信号以中断它，将清除tailcount.sh脚本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
借助两个脚本-一个执行行计数的脚本和一个带有秒表（计时器）的脚本来控制第一个脚本-您可以获取输出（一定时间段内的行数），下一个脚本将基于该输出构建直方图。它的名称如下：</font></font><br>
<br>
<code>bash tailcount.sh | bash livebar.sh</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
livebar.sh脚本从stdin读取数据，并将输出打印到stdout，每输入一行一行（示例8.5）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
示例8.5 </font><font style="vertical-align: inherit;">livebar.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# livebar.sh<font></font>
#<font></font>
# :<font></font>
#    «» <font></font>
#<font></font>
# :<font></font>
# &lt;output from other script or program&gt; | bash livebar.sh<font></font>
#<font></font>
<font></font>
<span class="hljs-function">function <span class="hljs-title">pr_bar</span> <span class="hljs-params">()</span>                                         <span class="hljs-params">(<span class="hljs-number">1</span>)</span>
</span>{<font></font>
      local raw maxraw scaled<font></font>
      raw=$<span class="hljs-number">1</span>
      maxraw=$<span class="hljs-number">2</span><font></font>
      ((scaled=(maxbar*raw)/maxraw))<font></font>
      ((scaled == <span class="hljs-number">0</span>)) &amp;&amp; scaled=<span class="hljs-number">1</span> #   
      <span class="hljs-keyword">for</span>((i=<span class="hljs-number">0</span>; i&lt;scaled; i++)) ; <span class="hljs-keyword">do</span> printf <span class="hljs-string">'#'</span> ; done<font></font>
      printf <span class="hljs-string">'\n'</span><font></font>
<font></font>
} # pr_bar<font></font>
<font></font>
maxbar=<span class="hljs-number">60</span>     #         (<span class="hljs-number">2</span>)<font></font>
MAX=<span class="hljs-number">60</span>
<span class="hljs-function"><span class="hljs-keyword">while</span> read dayst timst qty
<span class="hljs-keyword">do</span>
      <span class="hljs-title">if</span> <span class="hljs-params">(( qty &gt; MAX )</span>)                                   <span class="hljs-params">(<span class="hljs-number">3</span>)</span>
      then
           let MAX</span>=$qty+$qty/<span class="hljs-number">4</span>    #   <font></font>
           echo <span class="hljs-string">"                      **** rescaling: MAX=$MAX"</span><font></font>
      fi<font></font>
      printf <span class="hljs-string">'%6.6s %6.6s %4d:'</span> $dayst $timst $qty         (<span class="hljs-number">4</span>)<font></font>
      pr_bar $qty $MAX<font></font>
done<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pr_bar函数显示一列主题标签，这些主题标签根据提供的参数缩放到最大大小。</font><font style="vertical-align: inherit;">正如我们之前在histogram.sh脚本中使用的那样，此功能可能看起来很熟悉。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是我们可以允许的最长标签行大小（无需换行）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（3）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要显示的值有多大？在不事先知道这一点的情况下（尽管可以将数据作为参数提供给脚本），脚本将跟踪最大值。如果超过此最大值，则该值将开始“缩放”，并且现在显示的行以及将来的行也将被缩放到新的最大值。该脚本将最大值增加25％，因此如果下一个新值每次仅增加1-2％，则不必缩放该值。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（4）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf定义要打印的前两个字段的最小和最大宽度。</font><font style="vertical-align: inherit;">这些是日期和时间戳记，如果超过了宽度值，它们将被截断。</font><font style="vertical-align: inherit;">要显示整个值，请指定四个字符的宽度。</font><font style="vertical-align: inherit;">在这种情况下，尽管有限制，但将打印所有值。</font><font style="vertical-align: inherit;">如果值中的字符数少于四个，则丢失的字符将以空格补充。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于此脚本是从stdin中读取的，因此您可以自己运行它以查看其行为。</font><font style="vertical-align: inherit;">这是一个例子：</font></font><br>
<br>
<pre><code class="java hljs">$ bash  livebar.sh
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">20</span>
<span class="hljs-number">201010</span>     <span class="hljs-number">1020</span> <span class="hljs-number">20</span>:####################
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">70</span>
                       **** rescaling: MAX=<span class="hljs-number">87</span>
<span class="hljs-number">201010</span>     <span class="hljs-number">1020</span> <span class="hljs-number">70</span>:################################################
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">75</span>
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">75</span>:###################################################<font></font>
^C</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此示例中，输入与输出混合在一起。</font><font style="vertical-align: inherit;">您还可以将输入放入文件中，然后将其重定向到脚本以仅查看输出：</font></font><br>
<br>
<pre><code class="java hljs">$ bash livebar.sh &lt; testdata.txt<font></font>
bash livebar.sh &lt; x.data<font></font>
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">20</span>:####################<font></font>
                 **** rescaling: MAX=<span class="hljs-number">87</span>
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">70</span>:################################################
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">75</span>:###################################################<font></font>
$</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»书上的更多信息上可以找到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版商的网站</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘录</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
的优惠券Khabrozhiteley 25％的折扣- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">巴什</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在缴付书的纸质版本，电子书是通过电子邮件发送。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN501516/index.html">让我们关闭真空吗？阿列克谢·列索夫斯基</a></li>
<li><a href="../zh-CN501520/index.html">C＃8，无效。我们如何生活</a></li>
<li><a href="../zh-CN501522/index.html">免费的Skillbox网络研讨会：用PHP，Unity和Unreal Engine编写游戏</a></li>
<li><a href="../zh-CN501524/index.html">同步地球和生物体电磁场的秘密</a></li>
<li><a href="../zh-CN501526/index.html">为什么加拿大英语被认为是“肮脏的”，基努·里维斯与它有什么关系？</a></li>
<li><a href="../zh-CN501534/index.html">现在使用COVID-19也会出现皮疹</a></li>
<li><a href="../zh-CN501536/index.html">定制：有关代码行如何变成千吨煤的故事</a></li>
<li><a href="../zh-CN501538/index.html">Python中的缩进-解决方案选项</a></li>
<li><a href="../zh-CN501544/index.html">完美的智能手机</a></li>
<li><a href="../zh-CN501546/index.html">“我为什么要经历这个？” -心理学家解释如何孤立地寻找意义</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>