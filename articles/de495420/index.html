<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§æüèΩ ü§µüèø ü§õüèª Sortieren nach n-Pyramide ü•ë üõå üïú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Sortieren in einem Haufen (es ist auch eine pyramidenf√∂rmige Sortierung) auf Habr√© wurde bereits mehr als ein- oder zweimal mit einem guten Wort i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sortieren nach n-Pyramide</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/495420/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img width="750" height="322" src="https://habrastorage.org/webt/jf/fj/_q/jffj_qzdbowiyg-ae0vt73ddewc.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Sortieren in einem Haufen (es ist auch eine pyramidenf√∂rmige Sortierung) auf Habr√© wurde bereits mehr als ein- oder zweimal mit einem guten Wort in Erinnerung gerufen, aber dies waren immer recht bekannte Informationen. Jeder kennt den √ºblichen bin√§ren Heap, aber die Theorie der Algorithmen hat auch: einen </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
n-Heap; ein Haufen Haufen basierend auf Leonardo-Zahlen; Deramid (eine Mischung aus Heap und bin√§rem Suchbaum); Turnier Mini-Haufen; Spiegelhaufen (umgekehrt); schwacher Haufen; Jungs Haufen; Binomialstapel; und Gott wei√ü, welche anderen Haufen ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und die kl√ºgsten Vertreter der Informatik in verschiedenen Jahren schlugen ihre Sortieralgorithmen unter Verwendung dieser Pyramidenstrukturen vor. Wen interessiert es, was sie getan haben? F√ºr diejenigen, die sich mit dem Sortieren anhand dieser Strukturen befassen, beginnen wir mit einer kleinen Reihe von Artikeln. Die Welt der Haufen ist vielf√§ltig - ich hoffe, Sie werden interessiert sein.</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel wurde mit Unterst√ºtzung von EDISON verfasst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir besch√§ftigen uns mit der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entwicklung mobiler Anwendungen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und bieten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Softwaretests an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir lieben die Theorie der Algorithmen! </font><font style="vertical-align: inherit;">;-);</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine solche Klasse von Algorithmen - Sortieren nach Wahl. </font><font style="vertical-align: inherit;">Die allgemeine Idee ist, dass der ungeordnete Teil des Arrays aufgrund der Tatsache reduziert wird, dass nach den maximalen Elementen gesucht wird, die von ihm in einen zunehmenden sortierten Bereich umgeordnet werden.</font></font><br>
<br>
<div style="text-align:center;"><img width="646" height="69" src="https://habrastorage.org/webt/ew/-y/d5/ew-yd57sbecvuebvverib0a80am.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Sortieren der √ºblichen Wahl ist Brute Force. </font><font style="vertical-align: inherit;">Wenn es auf der Suche nach Maxima einfach ist, linear durch das Array zu gehen, kann die zeitliche Komplexit√§t eines solchen Algorithmus O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></b><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">nicht √ºberschreiten </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein B√ºndel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der effizienteste Weg, um mit den H√∂hen im Array zu arbeiten, besteht darin, die Daten in einer speziellen Baumstruktur zu organisieren, die als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap bezeichnet wird</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies ist ein Baum, in dem alle √ºbergeordneten Knoten nicht weniger als untergeordnete Knoten sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andere Namen des Haufens - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Pyramide</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Sortierbaum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns an, wie einfach und fast kostenlos es sein kann, ein Array in Form eines Baumes darzustellen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen Sie das allererste Element des Arrays und betrachten Sie, dass dies die Wurzel des Baums ist - ein Knoten der 1. Ebene. </font><font style="vertical-align: inherit;">Die n√§chsten 2 Elemente sind Knoten der 2. Ebene, die rechten und linken Nachkommen des Wurzelelements. </font><font style="vertical-align: inherit;">Die n√§chsten 4 Elemente sind Knoten der 3. Ebene, die rechten / linken Nachkommen des zweiten / dritten Elements des Arrays. </font><font style="vertical-align: inherit;">Die n√§chsten 8 Elemente sind Knoten der 4. Ebene, Nachkommen von Elementen der 3. Ebene. </font><font style="vertical-align: inherit;">Usw. </font><font style="vertical-align: inherit;">In diesem Bild befinden sich die Knoten des Bin√§rbaums deutlich unterhalb der entsprechenden Elemente im Array:</font></font><br>
<br>
<div style="text-align:center;"><img width="627" height="340" src="https://habrastorage.org/webt/ut/e6/in/ute6inpfajr64j1tlpggpl5w8fo.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl die B√§ume in den Diagrammen bei einem solchen Scan h√§ufiger dargestellt werden: </font></font><br>
<br>
<div style="text-align:center;"><img width="571" height="244" src="https://habrastorage.org/webt/3l/pz/yi/3lpzyizc7eephsbmsc9viexmr2u.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie diesen Winkel betrachten, ist klar, warum das Sortieren nach einem B√ºndel als pyramidenf√∂rmiges Sortieren bezeichnet wird. Dies ist ungef√§hr so, als w√ºrde man einen Schachelefanten einen Offizier, einen Turm eine Tura und eine K√∂nigin eine K√∂nigin nennen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indizes f√ºr die Nachkommen des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ten Elements werden durch Elementar bestimmt (wenn der Index des ersten Elements des Arrays gleich 0 ist, wie es in den meisten Programmiersprachen √ºblich ist): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linker Nachkomme von 2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
rechtes Kind: 2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(ich bin in den Diagrammen und in Animationen beginnen die Indizes von Arrays traditionell mit 1, wobei die Formeln leicht unterschiedlich sind: linkes Kind: </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und rechtes Kind: </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber das sind schon kleine arithmetische Nuancen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die aus diesen Formeln resultierenden Nachkommen die Indizes √ºber das Array hinausgehen, bedeutet dies, dass das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> te Element keine untergeordneten Elemente hat. </font><font style="vertical-align: inherit;">Es kann auch vorkommen, dass das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> te Element ein linker Nachkomme ist (f√§llt auf das letzte Element des Arrays, in dem eine ungerade Anzahl von Elementen vorhanden ist), aber es gibt kein rechtes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So kann jedes Array leicht in Form eines Baums dargestellt werden. Dies ist jedoch noch kein Heap, da im Array einige untergeordnete Elemente m√∂glicherweise gr√∂√üer sind als ihre √ºbergeordneten Elemente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit unser Baum, der auf der Grundlage des Arrays erstellt wurde, zu einem Haufen wird, muss er ordnungsgem√§√ü gesiebt werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sichtung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Seele, einen Haufen zu sortieren, siebt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Sieben f√ºr ein Element ist, dass, wenn es kleiner als die Nachkommen ist, die in einer untrennbaren Kette zusammengefasst sind, dieses Element so niedrig wie m√∂glich verschoben werden muss und gr√∂√üere Nachkommen 1 Ebene h√∂her angehoben werden sollten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Bild zeigt den Siebpfad f√ºr das Objekt. Die blaue Farbe zeigt das Element an, f√ºr das gesiebt wird. Gr√ºn - gr√∂√üere Nachkommen den Ast hinunter. Sie werden eine Ebene h√∂her angehoben, da sie gr√∂√üer sind als der blaue Knoten, f√ºr den der Bildschirm gemacht ist. Das Element selbst vom obersten blauen Knoten wird an die Stelle des untersten Nachkommen der gr√ºnen Kette verschoben.</font></font><br>
<br>
<div style="text-align:center;"><img width="571" height="249" src="https://habrastorage.org/webt/rh/i5/p_/rhi5p_yzvebng8-pywu-zuli7h0.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Sieben ist erforderlich, um aus einem gew√∂hnlichen Baum einen Sortierbaum zu machen und den Baum in diesem (Sortier-) Zustand weiter zu unterst√ºtzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Bild werden die Elemente des Arrays so neu verteilt, dass es bereits in einem Heap angeordnet ist. </font><font style="vertical-align: inherit;">Obwohl das Array in einen Sortierbaum zerlegt wurde, wurde es noch nicht sortiert (entweder aufsteigend oder absteigend), obwohl alle Nachkommen im Baum kleiner als ihre √ºbergeordneten Knoten sind. </font><font style="vertical-align: inherit;">Aber dann ist das maximalste Element im Sortierbaum immer in der Hauptwurzel, was sehr wichtig ist.</font></font><br>
<br>
<div style="text-align:center;"><img width="571" height="244" src="https://habrastorage.org/webt/iz/yg/lk/izyglkygfz4sh7izbjkhhsbdsvk.png"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sort :: Heapsort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Algorithmus ist eigentlich einfach:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe 1. Wir bilden einen Sortierbaum aus dem gesamten Array. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu gehen wir von rechts nach links √ºber die Elemente (vom letzten zum ersten) und wenn das Element Nachkommen hat, machen wir ein Sieben daf√ºr.</font></font></li>
<li><b> 2.       .</b>             ,        .   (  )        .        , ..   .       ,      ‚Äî             .         ,             .</li>
</ul><br>
<br>
<div style="text-align:center;"><img width="646" height="303" src="https://habrastorage.org/webt/cr/ik/_t/crik_twwuqdjsiclj7t-mcdjx78.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python-Code f√ºr eine klassische pyramidenf√∂rmige Sortierimplementierung:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#    </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HeapSort</span>(<span class="hljs-params">data</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#    </span>
    <span class="hljs-comment">#   -   </span>
    <span class="hljs-comment"># (   )       </span>
    <span class="hljs-keyword">for</span> start <span class="hljs-keyword">in</span> range((len(data) - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):<font></font>
        HeapSift(data, start, len(data) - <span class="hljs-number">1</span>) <font></font>
<font></font>
    <span class="hljs-comment">#        </span>
    <span class="hljs-comment">#        .</span>
    <span class="hljs-keyword">for</span> end <span class="hljs-keyword">in</span> range(len(data) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>): 
        <span class="hljs-comment">#       </span>
        <span class="hljs-comment">#    </span>
        data[end], data[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>], data[end]
        <span class="hljs-comment">#        </span>
        <span class="hljs-comment">#   </span>
        <span class="hljs-comment">#     </span>
        HeapSift(data, <span class="hljs-number">0</span>, end - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> data<font></font>
<font></font>
<span class="hljs-comment">#   ,      </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HeapSift</span>(<span class="hljs-params">data, start, end</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#   - ,     </span><font></font>
    root = start <font></font>
    <font></font>
    <span class="hljs-comment">#      ,</span>
    <span class="hljs-comment">#   ,    </span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
<font></font>
        child = root * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> <span class="hljs-comment">#  </span>
        <span class="hljs-comment">#      -  </span>
        <span class="hljs-keyword">if</span> child &gt; end: <span class="hljs-keyword">break</span> <font></font>
<font></font>
        <span class="hljs-comment">#       ,</span>
        <span class="hljs-comment">#      </span>
        <span class="hljs-keyword">if</span> child + <span class="hljs-number">1</span> &lt;= end <span class="hljs-keyword">and</span> data[child] &lt; data[child + <span class="hljs-number">1</span>]:<font></font>
            child += <span class="hljs-number">1</span><font></font>
<font></font>
        <span class="hljs-comment">#     ,   </span>
        <span class="hljs-comment">#       , </span>
        <span class="hljs-comment">#       </span>
        <span class="hljs-keyword">if</span> data[root] &lt; data[child]:<font></font>
            data[root], data[child] = data[child], data[root]<font></font>
            root = child<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span></code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komplexit√§t des Algorithmus</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ein einfacher Heap gut ist - er muss im Gegensatz zu anderen Baumarten nicht separat gespeichert werden (z. B. muss vor der Verwendung ein bin√§rer Suchbaum erstellt werden, der auf einem Array basiert). Jedes Array ist bereits ein Baum, in dem Sie Eltern und Nachkommen sofort identifizieren k√∂nnen. Die Komplexit√§t des zus√§tzlichen Speichers ist O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), alles passiert sofort. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Komplexit√§t der Zeit h√§ngt vom Sieben ab. Ein einzelnes Sieben wird in </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> umgangen </font><font style="vertical-align: inherit;">. Zuerst werden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Elemente durchsucht, um den anf√§nglichen Heap aus dem Array zu erstellen. Dieser Schritt erfordert </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In der zweiten Phase, wenn wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n herausnehmen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit den aktuellen Maxima aus dem Heap wird der verbleibende unsortierte Teil, d. h. </font><font style="vertical-align: inherit;">Diese Phase kostet uns auch </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gesamtzeitkomplexit√§t: O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) + O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus hat die Pyramidensortierung weder entartete noch bessere F√§lle. </font><font style="vertical-align: inherit;">Jedes Array wird mit einer angemessenen Geschwindigkeit verarbeitet, es gibt jedoch keine Verschlechterung oder Aufzeichnungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Heap-Sortierung ist im Durchschnitt etwas langsamer als die schnelle Sortierung. </font><font style="vertical-align: inherit;">Aber f√ºr Quicksort k√∂nnen Sie ein Killer-Array ausw√§hlen, an dem der Computer h√§ngt, aber f√ºr Heapsort - nein.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th rowspan="2"></th>
<th colspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitliche Komplexit√§t</font></font></th>
</tr>
<tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am schlimmsten</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durchschnittlich</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das beste</font></font></th>
</tr>
<tr>
<th> </th>
<td colspan="3" align="center">O(<b>n</b> log <b>n</b>)</td>
</tr>
<tr>
<th> </th>
<td align="center">O(<b>n</b><sup>2</sup>)</td>
<td align="center">O(<b>n</b> log <b>n</b>)</td>
<td align="center">O(<b>n</b>)</td>
</tr>
</tbody></table></div><br>
<br>
<h2>   :: Ternary heapsort</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns den tern√§ren Haufen an. Sie werden es nicht von bin√§r glauben, es unterscheidet sich nur darin, dass die √ºbergeordneten Knoten maximal nicht zwei, sondern drei Nachkommen haben. Im tern√§ren Haufen f√ºr den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ten Elementcode werden drei Nachkommen √§hnlich berechnet (wenn der erste Elementindex = 0 ist): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der linke Nachkomme 3 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mittlerer Nachkomme 3 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
rechter Nachkomme 3 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 3 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(If Indizes beginnen mit 1, wie in den Animationen in diesem Artikel, dann m√ºssen Sie in diesen Formeln nur eine subtrahieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sortiervorgang:</font></font><br>
<br>
<div style="text-align:center;"><img width="646" height="251" src="https://habrastorage.org/webt/-g/8n/rn/-g8nrn8fbhvbv4wvceklzcw2rio.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einerseits ist die Anzahl der Ebenen im Baum im Vergleich zum bin√§ren Heap sp√ºrbar reduziert, was bedeutet, dass beim Sieben im Durchschnitt weniger Swaps stattfinden. </font><font style="vertical-align: inherit;">Um den minimalen Nachkommen zu finden, sind jedoch mehr Vergleiche erforderlich - da die Nachkommen jetzt nicht zwei, sondern drei sind. </font><font style="vertical-align: inherit;">Im Allgemeinen in Bezug auf die zeitliche Komplexit√§t - irgendwo finden wir, irgendwo verlieren wir, aber im Allgemeinen das Gleiche. </font><font style="vertical-align: inherit;">Die Daten im tern√§ren Heap sind etwas schneller sortiert als in der Bin√§rdatei, aber diese Beschleunigung ist sehr gering. </font><font style="vertical-align: inherit;">Bei allen Variationen der Pyramidensortierung bevorzugen die Entwickler der Algorithmen die bin√§re Option, da die Implementierung des Tern√§rs angeblich schwieriger ist (obwohl es "schwieriger" ist, dem Algorithmus ein paar oder drei zus√§tzliche Zeilen hinzuzuf√ºgen) und der Geschwindigkeitsgewinn minimal ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortieren nach n-Heap Heap :: N-Narny Heapsort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich k√∂nnen Sie hier nicht aufh√∂ren und die Sortierung nach einer Reihe f√ºr eine beliebige Anzahl von Nachkommen anpassen. Wenn Sie die Anzahl der Nachkommen weiter erh√∂hen, k√∂nnen Sie m√∂glicherweise die Geschwindigkeit des Prozesses erheblich erh√∂hen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> te Element der Array-Indizes (wenn die Anzahl Null ist) werden seine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachkommen sehr einfach berechnet: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Nachkomme: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Nachkomme: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. Nachkomme: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N-ter Nachkomme: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + N </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python-Code zum Sortieren nach einem N-Heap:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#      N </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NHeapSort</span>(<span class="hljs-params">data</span>):</span><font></font>
<font></font>
    n = <span class="hljs-number">3</span> <span class="hljs-comment">#    </span><font></font>
<font></font>
    <span class="hljs-comment">#    </span>
    <span class="hljs-comment">#   -   </span>
    <span class="hljs-comment"># (   )       </span>
    <span class="hljs-keyword">for</span> start <span class="hljs-keyword">in</span> range(len(data), <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):<font></font>
        NHeapSift(data, n, start, len(data) - <span class="hljs-number">1</span>) <font></font>
<font></font>
    <span class="hljs-comment">#        </span>
    <span class="hljs-comment">#        .</span>
    <span class="hljs-keyword">for</span> end <span class="hljs-keyword">in</span> range(len(data) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>): 
        <span class="hljs-comment">#       </span>
        <span class="hljs-comment">#    </span>
        data[end], data[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>], data[end]
        <span class="hljs-comment">#        </span>
        <span class="hljs-comment">#   </span>
        <span class="hljs-comment">#     </span>
        NHeapSift(data, n, <span class="hljs-number">0</span>, end - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> data<font></font>
    <font></font>
<span class="hljs-comment">#  -     N </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NHeapSift</span>(<span class="hljs-params">data, n, start, end</span>):</span><font></font>
    <font></font>
    <span class="hljs-comment">#   - ,     </span><font></font>
    root = start <font></font>
<font></font>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
        <font></font>
        <span class="hljs-comment">#   (    )</span>
        <span class="hljs-comment">#   </span>
        child = root * n + <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> child &gt; end: 
            <span class="hljs-keyword">break</span> <font></font>
<font></font>
        max = child<font></font>
        <font></font>
        <span class="hljs-comment">#    </span>
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<font></font>
            current = root * n + k<font></font>
            <span class="hljs-keyword">if</span> current &gt; end:
                <span class="hljs-keyword">break</span><font></font>
                <font></font>
            <span class="hljs-keyword">if</span> data[current] &gt; data[max]:<font></font>
                max = current<font></font>
        <font></font>
        <span class="hljs-comment">#     </span>
        <span class="hljs-comment">#        </span>
        <span class="hljs-comment">#  </span>
        <span class="hljs-keyword">if</span> data[root] &lt; data[max]:<font></font>
            data[root], data[max] = data[max], data[root]<font></font>
            root = max<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mehr hei√üt jedoch nicht besser. </font><font style="vertical-align: inherit;">Wenn Sie die Situation an ihre Grenzen bringen und N Nachkommen f√ºr ein Array von N Elementen verwenden, wird die Sortierung nach einer Gruppe zu einer Sortierung nach der √ºblichen Auswahl. </font><font style="vertical-align: inherit;">Dar√ºber hinaus wird es auch eine verschlechterte Version der Sortierung nach Auswahl geben, da sinnlose Gesten ausgef√ºhrt werden: Beim Sieben wird zuerst das Maximum an erster Stelle im Array gesetzt und dann das Maximum an das Ende gesendet (bei der Auswahlsortierung wird das Maximum sofort an das Ende gesendet). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der tern√§re Heap die Bin√§rdatei minimal √ºberholt, verliert das Vierfache bereits. </font><font style="vertical-align: inherit;">Das Finden des maximalen Nachkommen unter mehreren wird zu teuer.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trailer der n√§chsten Serie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hauptnachteil des bin√§ren / tern√§ren / n-Heaps ist also, dass die Unf√§higkeit, in seiner Komplexit√§t zu springen, h√∂her ist als </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Der Ausweg aus dem Deadlock besteht darin, beim Sortieren anspruchsvollere Haufensorten zu verwenden. </font><font style="vertical-align: inherit;">In einer Woche werden wir erfahren, was Edsger Dijkstra dar√ºber denkt.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img width="627" height="475" src="https://habrastorage.org/webt/qi/dn/w-/qidnw-xsewiihfsqbr8ajkj4jhi.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klicken Sie auf die Animation, um zum Artikel mit der folgenden Sortierung nach B√ºndeln zu gelangen</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haufen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyramide</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serienartikel:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel-Anwendung AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sorte austauschen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einf√ºgungssortierungen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Auswahl sortieren</font></font></a><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: N-Pyramiden</font></font></b></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Leonardo Numbers</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap-Sortierung: schwacher Heap</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B√ºndelsorten: Kartesischer Baum</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Heap-Sortierungen: Spiegelhaufen, Mini-Heap, Sieben von unten nach oben</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortierungen zusammenf√ºhren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Verteilung sortieren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybridsortierung</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AlgoLab-Anwendung hinzugef√ºgt Sortierung nach n-Heap. </font><font style="vertical-align: inherit;">Um die Anzahl der Nachkommen auszuw√§hlen, m√ºssen Sie im Kommentar zu der Zelle dieser Art eine Zahl f√ºr n angeben. </font><font style="vertical-align: inherit;">Der Bereich m√∂glicher Werte liegt zwischen 2 und 5 (dies ist nicht mehr sinnvoll, da f√ºr n&gt; = 6 nicht garantiert ist, dass Animationen mit drei Verschachtelungsebenen in einem normalen Ma√üstab auf den Bildschirm passen).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495408/index.html"># 02 - Und ein ganzes Byte reicht nicht ... | Das Kreuz der Ver√§nderungen</a></li>
<li><a href="../de495412/index.html">Norbert Wiener. Eine interessante Person. Kollegen, Feinde, k√§mpfen um Unabh√§ngigkeit</a></li>
<li><a href="../de495414/index.html">Folgen der Angst</a></li>
<li><a href="../de495416/index.html">Pipeplot - Interaktive Visualisierung des Datenstroms von Pipe in der Konsole</a></li>
<li><a href="../de495418/index.html">Blazor Client Side Online Store: Teil 4 - Artikel in den Warenkorb legen</a></li>
<li><a href="../de495422/index.html">Beruf: Mobiler Entwickler</a></li>
<li><a href="../de495432/index.html">Singleton mit Fallstricken</a></li>
<li><a href="../de495434/index.html">Was ist mit dem Transport in den letzten zwei Wochen passiert?</a></li>
<li><a href="../de495436/index.html">Wir er√∂ffnen den Zugang zum praktischen Kurs zur Arbeit mit dem DLP-System</a></li>
<li><a href="../de495438/index.html">R-Sprache f√ºr Excel-Benutzer (kostenloser Videokurs)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>