<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾🏽 🤵🏿 🤛🏻 Sortieren nach n-Pyramide 🥑 🛌 🕜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Sortieren in einem Haufen (es ist auch eine pyramidenförmige Sortierung) auf Habré wurde bereits mehr als ein- oder zweimal mit einem guten Wort i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sortieren nach n-Pyramide</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/495420/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img width="750" height="322" src="https://habrastorage.org/webt/jf/fj/_q/jffj_qzdbowiyg-ae0vt73ddewc.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Sortieren in einem Haufen (es ist auch eine pyramidenförmige Sortierung) auf Habré wurde bereits mehr als ein- oder zweimal mit einem guten Wort in Erinnerung gerufen, aber dies waren immer recht bekannte Informationen. Jeder kennt den üblichen binären Heap, aber die Theorie der Algorithmen hat auch: einen </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
n-Heap; ein Haufen Haufen basierend auf Leonardo-Zahlen; Deramid (eine Mischung aus Heap und binärem Suchbaum); Turnier Mini-Haufen; Spiegelhaufen (umgekehrt); schwacher Haufen; Jungs Haufen; Binomialstapel; und Gott weiß, welche anderen Haufen ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und die klügsten Vertreter der Informatik in verschiedenen Jahren schlugen ihre Sortieralgorithmen unter Verwendung dieser Pyramidenstrukturen vor. Wen interessiert es, was sie getan haben? Für diejenigen, die sich mit dem Sortieren anhand dieser Strukturen befassen, beginnen wir mit einer kleinen Reihe von Artikeln. Die Welt der Haufen ist vielfältig - ich hoffe, Sie werden interessiert sein.</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel wurde mit Unterstützung von EDISON verfasst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir beschäftigen uns mit der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entwicklung mobiler Anwendungen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und bieten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Softwaretests an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir lieben die Theorie der Algorithmen! </font><font style="vertical-align: inherit;">;-);</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine solche Klasse von Algorithmen - Sortieren nach Wahl. </font><font style="vertical-align: inherit;">Die allgemeine Idee ist, dass der ungeordnete Teil des Arrays aufgrund der Tatsache reduziert wird, dass nach den maximalen Elementen gesucht wird, die von ihm in einen zunehmenden sortierten Bereich umgeordnet werden.</font></font><br>
<br>
<div style="text-align:center;"><img width="646" height="69" src="https://habrastorage.org/webt/ew/-y/d5/ew-yd57sbecvuebvverib0a80am.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Sortieren der üblichen Wahl ist Brute Force. </font><font style="vertical-align: inherit;">Wenn es auf der Suche nach Maxima einfach ist, linear durch das Array zu gehen, kann die zeitliche Komplexität eines solchen Algorithmus O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></b><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">nicht überschreiten </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Bündel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der effizienteste Weg, um mit den Höhen im Array zu arbeiten, besteht darin, die Daten in einer speziellen Baumstruktur zu organisieren, die als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap bezeichnet wird</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies ist ein Baum, in dem alle übergeordneten Knoten nicht weniger als untergeordnete Knoten sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andere Namen des Haufens - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Pyramide</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Sortierbaum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns an, wie einfach und fast kostenlos es sein kann, ein Array in Form eines Baumes darzustellen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen Sie das allererste Element des Arrays und betrachten Sie, dass dies die Wurzel des Baums ist - ein Knoten der 1. Ebene. </font><font style="vertical-align: inherit;">Die nächsten 2 Elemente sind Knoten der 2. Ebene, die rechten und linken Nachkommen des Wurzelelements. </font><font style="vertical-align: inherit;">Die nächsten 4 Elemente sind Knoten der 3. Ebene, die rechten / linken Nachkommen des zweiten / dritten Elements des Arrays. </font><font style="vertical-align: inherit;">Die nächsten 8 Elemente sind Knoten der 4. Ebene, Nachkommen von Elementen der 3. Ebene. </font><font style="vertical-align: inherit;">Usw. </font><font style="vertical-align: inherit;">In diesem Bild befinden sich die Knoten des Binärbaums deutlich unterhalb der entsprechenden Elemente im Array:</font></font><br>
<br>
<div style="text-align:center;"><img width="627" height="340" src="https://habrastorage.org/webt/ut/e6/in/ute6inpfajr64j1tlpggpl5w8fo.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl die Bäume in den Diagrammen bei einem solchen Scan häufiger dargestellt werden: </font></font><br>
<br>
<div style="text-align:center;"><img width="571" height="244" src="https://habrastorage.org/webt/3l/pz/yi/3lpzyizc7eephsbmsc9viexmr2u.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie diesen Winkel betrachten, ist klar, warum das Sortieren nach einem Bündel als pyramidenförmiges Sortieren bezeichnet wird. Dies ist ungefähr so, als würde man einen Schachelefanten einen Offizier, einen Turm eine Tura und eine Königin eine Königin nennen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indizes für die Nachkommen des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ten Elements werden durch Elementar bestimmt (wenn der Index des ersten Elements des Arrays gleich 0 ist, wie es in den meisten Programmiersprachen üblich ist): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linker Nachkomme von 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
rechtes Kind: 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(ich bin in den Diagrammen und in Animationen beginnen die Indizes von Arrays traditionell mit 1, wobei die Formeln leicht unterschiedlich sind: linkes Kind: </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und rechtes Kind: </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber das sind schon kleine arithmetische Nuancen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die aus diesen Formeln resultierenden Nachkommen die Indizes über das Array hinausgehen, bedeutet dies, dass das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> te Element keine untergeordneten Elemente hat. </font><font style="vertical-align: inherit;">Es kann auch vorkommen, dass das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> te Element ein linker Nachkomme ist (fällt auf das letzte Element des Arrays, in dem eine ungerade Anzahl von Elementen vorhanden ist), aber es gibt kein rechtes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So kann jedes Array leicht in Form eines Baums dargestellt werden. Dies ist jedoch noch kein Heap, da im Array einige untergeordnete Elemente möglicherweise größer sind als ihre übergeordneten Elemente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit unser Baum, der auf der Grundlage des Arrays erstellt wurde, zu einem Haufen wird, muss er ordnungsgemäß gesiebt werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sichtung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Seele, einen Haufen zu sortieren, siebt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Sieben für ein Element ist, dass, wenn es kleiner als die Nachkommen ist, die in einer untrennbaren Kette zusammengefasst sind, dieses Element so niedrig wie möglich verschoben werden muss und größere Nachkommen 1 Ebene höher angehoben werden sollten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Bild zeigt den Siebpfad für das Objekt. Die blaue Farbe zeigt das Element an, für das gesiebt wird. Grün - größere Nachkommen den Ast hinunter. Sie werden eine Ebene höher angehoben, da sie größer sind als der blaue Knoten, für den der Bildschirm gemacht ist. Das Element selbst vom obersten blauen Knoten wird an die Stelle des untersten Nachkommen der grünen Kette verschoben.</font></font><br>
<br>
<div style="text-align:center;"><img width="571" height="249" src="https://habrastorage.org/webt/rh/i5/p_/rhi5p_yzvebng8-pywu-zuli7h0.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Sieben ist erforderlich, um aus einem gewöhnlichen Baum einen Sortierbaum zu machen und den Baum in diesem (Sortier-) Zustand weiter zu unterstützen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Bild werden die Elemente des Arrays so neu verteilt, dass es bereits in einem Heap angeordnet ist. </font><font style="vertical-align: inherit;">Obwohl das Array in einen Sortierbaum zerlegt wurde, wurde es noch nicht sortiert (entweder aufsteigend oder absteigend), obwohl alle Nachkommen im Baum kleiner als ihre übergeordneten Knoten sind. </font><font style="vertical-align: inherit;">Aber dann ist das maximalste Element im Sortierbaum immer in der Hauptwurzel, was sehr wichtig ist.</font></font><br>
<br>
<div style="text-align:center;"><img width="571" height="244" src="https://habrastorage.org/webt/iz/yg/lk/izyglkygfz4sh7izbjkhhsbdsvk.png"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sort :: Heapsort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Algorithmus ist eigentlich einfach:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe 1. Wir bilden einen Sortierbaum aus dem gesamten Array. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu gehen wir von rechts nach links über die Elemente (vom letzten zum ersten) und wenn das Element Nachkommen hat, machen wir ein Sieben dafür.</font></font></li>
<li><b> 2.       .</b>             ,        .   (  )        .        , ..   .       ,      —             .         ,             .</li>
</ul><br>
<br>
<div style="text-align:center;"><img width="646" height="303" src="https://habrastorage.org/webt/cr/ik/_t/crik_twwuqdjsiclj7t-mcdjx78.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python-Code für eine klassische pyramidenförmige Sortierimplementierung:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#    </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HeapSort</span>(<span class="hljs-params">data</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#    </span>
    <span class="hljs-comment">#   -   </span>
    <span class="hljs-comment"># (   )       </span>
    <span class="hljs-keyword">for</span> start <span class="hljs-keyword">in</span> range((len(data) - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):<font></font>
        HeapSift(data, start, len(data) - <span class="hljs-number">1</span>) <font></font>
<font></font>
    <span class="hljs-comment">#        </span>
    <span class="hljs-comment">#        .</span>
    <span class="hljs-keyword">for</span> end <span class="hljs-keyword">in</span> range(len(data) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>): 
        <span class="hljs-comment">#       </span>
        <span class="hljs-comment">#    </span>
        data[end], data[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>], data[end]
        <span class="hljs-comment">#        </span>
        <span class="hljs-comment">#   </span>
        <span class="hljs-comment">#     </span>
        HeapSift(data, <span class="hljs-number">0</span>, end - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> data<font></font>
<font></font>
<span class="hljs-comment">#   ,      </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HeapSift</span>(<span class="hljs-params">data, start, end</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#   - ,     </span><font></font>
    root = start <font></font>
    <font></font>
    <span class="hljs-comment">#      ,</span>
    <span class="hljs-comment">#   ,    </span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
<font></font>
        child = root * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> <span class="hljs-comment">#  </span>
        <span class="hljs-comment">#      -  </span>
        <span class="hljs-keyword">if</span> child &gt; end: <span class="hljs-keyword">break</span> <font></font>
<font></font>
        <span class="hljs-comment">#       ,</span>
        <span class="hljs-comment">#      </span>
        <span class="hljs-keyword">if</span> child + <span class="hljs-number">1</span> &lt;= end <span class="hljs-keyword">and</span> data[child] &lt; data[child + <span class="hljs-number">1</span>]:<font></font>
            child += <span class="hljs-number">1</span><font></font>
<font></font>
        <span class="hljs-comment">#     ,   </span>
        <span class="hljs-comment">#       , </span>
        <span class="hljs-comment">#       </span>
        <span class="hljs-keyword">if</span> data[root] &lt; data[child]:<font></font>
            data[root], data[child] = data[child], data[root]<font></font>
            root = child<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span></code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komplexität des Algorithmus</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ein einfacher Heap gut ist - er muss im Gegensatz zu anderen Baumarten nicht separat gespeichert werden (z. B. muss vor der Verwendung ein binärer Suchbaum erstellt werden, der auf einem Array basiert). Jedes Array ist bereits ein Baum, in dem Sie Eltern und Nachkommen sofort identifizieren können. Die Komplexität des zusätzlichen Speichers ist O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), alles passiert sofort. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Komplexität der Zeit hängt vom Sieben ab. Ein einzelnes Sieben wird in </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> umgangen </font><font style="vertical-align: inherit;">. Zuerst werden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Elemente durchsucht, um den anfänglichen Heap aus dem Array zu erstellen. Dieser Schritt erfordert </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In der zweiten Phase, wenn wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n herausnehmen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit den aktuellen Maxima aus dem Heap wird der verbleibende unsortierte Teil, d. h. </font><font style="vertical-align: inherit;">Diese Phase kostet uns auch </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gesamtzeitkomplexität: O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) + O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus hat die Pyramidensortierung weder entartete noch bessere Fälle. </font><font style="vertical-align: inherit;">Jedes Array wird mit einer angemessenen Geschwindigkeit verarbeitet, es gibt jedoch keine Verschlechterung oder Aufzeichnungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Heap-Sortierung ist im Durchschnitt etwas langsamer als die schnelle Sortierung. </font><font style="vertical-align: inherit;">Aber für Quicksort können Sie ein Killer-Array auswählen, an dem der Computer hängt, aber für Heapsort - nein.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th rowspan="2"></th>
<th colspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitliche Komplexität</font></font></th>
</tr>
<tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am schlimmsten</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durchschnittlich</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das beste</font></font></th>
</tr>
<tr>
<th> </th>
<td colspan="3" align="center">O(<b>n</b> log <b>n</b>)</td>
</tr>
<tr>
<th> </th>
<td align="center">O(<b>n</b><sup>2</sup>)</td>
<td align="center">O(<b>n</b> log <b>n</b>)</td>
<td align="center">O(<b>n</b>)</td>
</tr>
</tbody></table></div><br>
<br>
<h2>   :: Ternary heapsort</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns den ternären Haufen an. Sie werden es nicht von binär glauben, es unterscheidet sich nur darin, dass die übergeordneten Knoten maximal nicht zwei, sondern drei Nachkommen haben. Im ternären Haufen für den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ten Elementcode werden drei Nachkommen ähnlich berechnet (wenn der erste Elementindex = 0 ist): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der linke Nachkomme 3 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mittlerer Nachkomme 3 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
rechter Nachkomme 3 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 3 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(If Indizes beginnen mit 1, wie in den Animationen in diesem Artikel, dann müssen Sie in diesen Formeln nur eine subtrahieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sortiervorgang:</font></font><br>
<br>
<div style="text-align:center;"><img width="646" height="251" src="https://habrastorage.org/webt/-g/8n/rn/-g8nrn8fbhvbv4wvceklzcw2rio.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einerseits ist die Anzahl der Ebenen im Baum im Vergleich zum binären Heap spürbar reduziert, was bedeutet, dass beim Sieben im Durchschnitt weniger Swaps stattfinden. </font><font style="vertical-align: inherit;">Um den minimalen Nachkommen zu finden, sind jedoch mehr Vergleiche erforderlich - da die Nachkommen jetzt nicht zwei, sondern drei sind. </font><font style="vertical-align: inherit;">Im Allgemeinen in Bezug auf die zeitliche Komplexität - irgendwo finden wir, irgendwo verlieren wir, aber im Allgemeinen das Gleiche. </font><font style="vertical-align: inherit;">Die Daten im ternären Heap sind etwas schneller sortiert als in der Binärdatei, aber diese Beschleunigung ist sehr gering. </font><font style="vertical-align: inherit;">Bei allen Variationen der Pyramidensortierung bevorzugen die Entwickler der Algorithmen die binäre Option, da die Implementierung des Ternärs angeblich schwieriger ist (obwohl es "schwieriger" ist, dem Algorithmus ein paar oder drei zusätzliche Zeilen hinzuzufügen) und der Geschwindigkeitsgewinn minimal ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortieren nach n-Heap Heap :: N-Narny Heapsort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich können Sie hier nicht aufhören und die Sortierung nach einer Reihe für eine beliebige Anzahl von Nachkommen anpassen. Wenn Sie die Anzahl der Nachkommen weiter erhöhen, können Sie möglicherweise die Geschwindigkeit des Prozesses erheblich erhöhen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> te Element der Array-Indizes (wenn die Anzahl Null ist) werden seine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachkommen sehr einfach berechnet: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Nachkomme: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Nachkomme: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. Nachkomme: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N-ter Nachkomme: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + N </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python-Code zum Sortieren nach einem N-Heap:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#      N </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NHeapSort</span>(<span class="hljs-params">data</span>):</span><font></font>
<font></font>
    n = <span class="hljs-number">3</span> <span class="hljs-comment">#    </span><font></font>
<font></font>
    <span class="hljs-comment">#    </span>
    <span class="hljs-comment">#   -   </span>
    <span class="hljs-comment"># (   )       </span>
    <span class="hljs-keyword">for</span> start <span class="hljs-keyword">in</span> range(len(data), <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):<font></font>
        NHeapSift(data, n, start, len(data) - <span class="hljs-number">1</span>) <font></font>
<font></font>
    <span class="hljs-comment">#        </span>
    <span class="hljs-comment">#        .</span>
    <span class="hljs-keyword">for</span> end <span class="hljs-keyword">in</span> range(len(data) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>): 
        <span class="hljs-comment">#       </span>
        <span class="hljs-comment">#    </span>
        data[end], data[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>], data[end]
        <span class="hljs-comment">#        </span>
        <span class="hljs-comment">#   </span>
        <span class="hljs-comment">#     </span>
        NHeapSift(data, n, <span class="hljs-number">0</span>, end - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> data<font></font>
    <font></font>
<span class="hljs-comment">#  -     N </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NHeapSift</span>(<span class="hljs-params">data, n, start, end</span>):</span><font></font>
    <font></font>
    <span class="hljs-comment">#   - ,     </span><font></font>
    root = start <font></font>
<font></font>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
        <font></font>
        <span class="hljs-comment">#   (    )</span>
        <span class="hljs-comment">#   </span>
        child = root * n + <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> child &gt; end: 
            <span class="hljs-keyword">break</span> <font></font>
<font></font>
        max = child<font></font>
        <font></font>
        <span class="hljs-comment">#    </span>
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<font></font>
            current = root * n + k<font></font>
            <span class="hljs-keyword">if</span> current &gt; end:
                <span class="hljs-keyword">break</span><font></font>
                <font></font>
            <span class="hljs-keyword">if</span> data[current] &gt; data[max]:<font></font>
                max = current<font></font>
        <font></font>
        <span class="hljs-comment">#     </span>
        <span class="hljs-comment">#        </span>
        <span class="hljs-comment">#  </span>
        <span class="hljs-keyword">if</span> data[root] &lt; data[max]:<font></font>
            data[root], data[max] = data[max], data[root]<font></font>
            root = max<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mehr heißt jedoch nicht besser. </font><font style="vertical-align: inherit;">Wenn Sie die Situation an ihre Grenzen bringen und N Nachkommen für ein Array von N Elementen verwenden, wird die Sortierung nach einer Gruppe zu einer Sortierung nach der üblichen Auswahl. </font><font style="vertical-align: inherit;">Darüber hinaus wird es auch eine verschlechterte Version der Sortierung nach Auswahl geben, da sinnlose Gesten ausgeführt werden: Beim Sieben wird zuerst das Maximum an erster Stelle im Array gesetzt und dann das Maximum an das Ende gesendet (bei der Auswahlsortierung wird das Maximum sofort an das Ende gesendet). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der ternäre Heap die Binärdatei minimal überholt, verliert das Vierfache bereits. </font><font style="vertical-align: inherit;">Das Finden des maximalen Nachkommen unter mehreren wird zu teuer.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trailer der nächsten Serie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hauptnachteil des binären / ternären / n-Heaps ist also, dass die Unfähigkeit, in seiner Komplexität zu springen, höher ist als </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Der Ausweg aus dem Deadlock besteht darin, beim Sortieren anspruchsvollere Haufensorten zu verwenden. </font><font style="vertical-align: inherit;">In einer Woche werden wir erfahren, was Edsger Dijkstra darüber denkt.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img width="627" height="475" src="https://habrastorage.org/webt/qi/dn/w-/qidnw-xsewiihfsqbr8ajkj4jhi.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klicken Sie auf die Animation, um zum Artikel mit der folgenden Sortierung nach Bündeln zu gelangen</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haufen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyramide</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serienartikel:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel-Anwendung AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sorte austauschen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfügungssortierungen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Auswahl sortieren</font></font></a><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: N-Pyramiden</font></font></b></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Leonardo Numbers</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap-Sortierung: schwacher Heap</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bündelsorten: Kartesischer Baum</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Heap-Sortierungen: Spiegelhaufen, Mini-Heap, Sieben von unten nach oben</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortierungen zusammenführen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Verteilung sortieren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybridsortierung</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AlgoLab-Anwendung hinzugefügt Sortierung nach n-Heap. </font><font style="vertical-align: inherit;">Um die Anzahl der Nachkommen auszuwählen, müssen Sie im Kommentar zu der Zelle dieser Art eine Zahl für n angeben. </font><font style="vertical-align: inherit;">Der Bereich möglicher Werte liegt zwischen 2 und 5 (dies ist nicht mehr sinnvoll, da für n&gt; = 6 nicht garantiert ist, dass Animationen mit drei Verschachtelungsebenen in einem normalen Maßstab auf den Bildschirm passen).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495408/index.html"># 02 - Und ein ganzes Byte reicht nicht ... | Das Kreuz der Veränderungen</a></li>
<li><a href="../de495412/index.html">Norbert Wiener. Eine interessante Person. Kollegen, Feinde, kämpfen um Unabhängigkeit</a></li>
<li><a href="../de495414/index.html">Folgen der Angst</a></li>
<li><a href="../de495416/index.html">Pipeplot - Interaktive Visualisierung des Datenstroms von Pipe in der Konsole</a></li>
<li><a href="../de495418/index.html">Blazor Client Side Online Store: Teil 4 - Artikel in den Warenkorb legen</a></li>
<li><a href="../de495422/index.html">Beruf: Mobiler Entwickler</a></li>
<li><a href="../de495432/index.html">Singleton mit Fallstricken</a></li>
<li><a href="../de495434/index.html">Was ist mit dem Transport in den letzten zwei Wochen passiert?</a></li>
<li><a href="../de495436/index.html">Wir eröffnen den Zugang zum praktischen Kurs zur Arbeit mit dem DLP-System</a></li>
<li><a href="../de495438/index.html">R-Sprache für Excel-Benutzer (kostenloser Videokurs)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>