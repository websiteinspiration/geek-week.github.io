<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍💻 🤙🏻 💪🏽 Memprogram game untuk perangkat tertanam pada ESP32: drive, baterai, suara 🤘🏽 🙍🏾 😍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mulai: sistem perakitan, input, tampilan .
 
 Bagian 4: drive
 Odroid Go memiliki slot kartu microSD, yang akan berguna untuk mengunduh sumber daya (s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Memprogram game untuk perangkat tertanam pada ESP32: drive, baterai, suara</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503876/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/800/42e/44b80042e94aa2f2da9da2d2296461ad.jpg" alt="gambar"></div><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mulai: sistem perakitan, input, tampilan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian 4: drive</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go memiliki slot kartu microSD, yang akan berguna untuk mengunduh sumber daya (sprite, file suara, font), dan bahkan mungkin untuk menyelamatkan keadaan permainan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pembaca kartu terhubung melalui SPI, tetapi IDF membuatnya mudah untuk berinteraksi dengan kartu SD dengan mengabstraksi panggilan SPI dan menggunakan fungsi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POSIX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> standar </font><font style="vertical-align: inherit;">seperti </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fopen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fread</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fwrite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Semua ini didasarkan pada pustaka </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FatFs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sehingga kartu SD harus diformat dalam format FAT standar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini terhubung ke bus SPI yang sama dengan LCD, tetapi menggunakan jalur pemilihan chip yang berbeda. </font><font style="vertical-align: inherit;">Ketika kita perlu membaca atau menulis ke kartu SD (dan ini tidak sering terjadi), driver SPI akan mengalihkan sinyal CS dari layar ke pembaca kartu SD, dan kemudian melakukan operasi. </font><font style="vertical-align: inherit;">Ini berarti bahwa saat mengirim data ke layar, kami tidak dapat melakukan operasi apa pun dengan kartu SD, dan sebaliknya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat ini kami sedang melakukan semuanya dalam satu utas dan menggunakan transmisi pemblokiran melalui SPI ke layar, sehingga tidak ada transaksi simultan dengan kartu SD dan dengan layar LCD. </font><font style="vertical-align: inherit;">Bagaimanapun, ada kemungkinan besar bahwa kami akan memuat semua sumber daya pada saat peluncuran.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifikasi ESP-IDF</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kami mencoba menginisialisasi antarmuka kartu SD setelah inisialisasi tampilan, kami akan menghadapi masalah yang membuatnya tidak mungkin memuat Odroid Go. </font><font style="vertical-align: inherit;">ESP-IDF v4.0 tidak mendukung akses bersama ke bus SPI saat digunakan dengan kartu SD. </font><font style="vertical-align: inherit;">Baru-baru ini, pengembang telah menambahkan fungsi ini, tetapi belum dalam rilis yang stabil, jadi kami akan melakukan sedikit modifikasi pada IDF sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengomentari baris 303 </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp-idf / components / driver / sdspi_host.c</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Initialize SPI bus</span>
<span class="hljs-keyword">esp_err_t</span> ret = spi_bus_initialize((<span class="hljs-keyword">spi_host_device_t</span>)slot, &amp;buscfg,<font></font>
    slot_config-&gt;dma_channel);<font></font>
<span class="hljs-keyword">if</span> (ret != ESP_OK) {<font></font>
    ESP_LOGD(TAG, <span class="hljs-string">"spi_bus_initialize failed with rc=0x%x"</span>, ret);
    <span class="hljs-comment">//return ret;</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah melakukan perubahan ini, kami masih akan melihat kesalahan selama inisialisasi, tetapi itu tidak akan lagi menyebabkan ESP32 untuk memulai kembali, karena kode kesalahan tidak menyebar di atas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inisialisasi</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57f/4f8/b0f/57f4f8b0fcca66e243637eeb68b39ff7.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/554/eae/9ec/554eae9ec4a3e850eb44e817e8b7b181.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita perlu memberi tahu IDF pin ESP32 mana yang terhubung ke pembaca MicroSD sehingga mengkonfigurasi dengan benar driver SPI yang mendasarinya, yang sebenarnya berkomunikasi dengan pembaca. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Catatan umum </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VSPI.XXXX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lagi digunakan dalam </font><strong><font style="vertical-align: inherit;">diagram</font></strong><font style="vertical-align: inherit;"> , tetapi kita dapat melewatinya ke nomor kontak aktual pada ESP32. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inisialisasi mirip dengan inisialisasi LCD, tetapi alih-alih struktur konfigurasi SPI umum, kami menggunakan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdspi_slot_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang dirancang untuk kartu SD yang terhubung melalui bus SPI. Kami mengonfigurasi nomor kontak yang sesuai dan properti pemasangan kartu di sistem FatFS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dokumentasi IDF tidak merekomendasikan penggunaan fungsi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_vfs_fat_sdmmc_mount</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam kode program yang selesai. Ini adalah fungsi pembungkus yang melakukan banyak operasi untuk kita, tetapi sejauh ini berfungsi cukup normal, dan mungkin tidak ada yang akan berubah di masa depan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parameter </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"/ sdcard"</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari </font><font style="vertical-align: inherit;">fungsi ini menetapkan titik pemasangan virtual kartu SD, yang kemudian akan kita gunakan sebagai awalan saat bekerja dengan file. Jika kami memiliki file bernama "test.txt" pada kartu SD kami, jalur yang akan kami gunakan untuk menautkannya adalah "/sdcard/test.txt". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah inisialisasi antarmuka kartu SD, interaksi dengan file sepele: kita cukup menggunakan panggilan standar ke fungsi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POSIX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang sangat nyaman.</font></font><br>
<br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">   8.3</a>,              .    ,   <b>fopen</b>   .        <b>make menuconfig</b>,       ,     <b>8.3</b>.</blockquote><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/62f/94a/d9462f94aeec7fbdce989e34967e637d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya membuat </font><font style="vertical-align: inherit;">sprite 64x64 </font><font style="vertical-align: inherit;">dalam </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aseprite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (mengerikan) yang hanya menggunakan dua warna: benar-benar hitam (piksel dinonaktifkan) dan sepenuhnya putih (piksel diaktifkan). Aseprite tidak memiliki opsi untuk menyimpan warna RGB565 atau mengekspor sebagai bitmap mentah (mis. Tanpa header kompresi dan gambar), jadi saya mengekspor sprite ke format PNG sementara. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian, menggunakan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImageMagick, saya</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengkonversi data ke file PPM, yang mengubah gambar menjadi data mentah terkompresi dengan header sederhana. Selanjutnya, saya membuka gambar dalam hex editor, menghapus header dan mengubah warna 24-bit menjadi 16-bit, menghapus semua kejadian </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x000000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hingga </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan semua kejadian </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Urutan byte di sini bukan masalah, karena </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak berubah saat mengubah urutan byte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File mentah dapat diunduh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">FILE* spriteFile = fopen(<span class="hljs-string">"/sdcard/key"</span>, <span class="hljs-string">"r"</span>);<font></font>
assert(spriteFile);<font></font>
<font></font>
<span class="hljs-keyword">uint16_t</span>* sprite = (<span class="hljs-keyword">uint16_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">64</span> * <span class="hljs-number">64</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>));<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i)<font></font>
{<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; ++j)<font></font>
	{<font></font>
		fread(sprite, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>), <span class="hljs-number">64</span> * <span class="hljs-number">64</span>, spriteFile);<font></font>
	}<font></font>
}<font></font>
<font></font>
fclose(spriteFile);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, kita buka file </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kunci yang</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berisi byte mentah dan membacanya ke buffer. </font><font style="vertical-align: inherit;">Di masa depan, kami akan memuat sumber daya sprite secara berbeda, tetapi untuk demo ini cukup.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> spriteRow = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = y; row &lt; y + <span class="hljs-number">64</span>; ++row)<font></font>
{<font></font>
	spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = x; col &lt; x + <span class="hljs-number">64</span>; ++col)<font></font>
	{<font></font>
		<span class="hljs-keyword">uint16_t</span> pixelColor = sprite[<span class="hljs-number">64</span> * spriteRow + spriteCol];<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pixelColor != <span class="hljs-number">0</span>)<font></font>
		{<font></font>
			gFramebuffer[row * LCD_WIDTH + col] = color;<font></font>
		}<font></font>
<font></font>
		++spriteCol;<font></font>
	}<font></font>
<font></font>
	++spriteRow;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menggambar sprite, kami mengulangi isinya secara iteratif. </font><font style="vertical-align: inherit;">Jika pikselnya putih, maka kami menggambarnya dalam warna yang dipilih oleh tombol. </font><font style="vertical-align: inherit;">Jika berwarna hitam, maka kami menganggapnya sebagai latar belakang dan tidak menggambar.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Browser Anda tidak mendukung video HTML5.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_4/media/sprite_drawing.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kamera ponsel saya sangat mendistorsi warna. </font><font style="vertical-align: inherit;">Dan maaf karena mengguncangnya. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menguji perekaman gambar, kami akan memindahkan kunci ke suatu tempat di layar, mengubah warnanya, dan kemudian menulis buffer bingkai ke kartu SD sehingga dapat dilihat di komputer.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (input.menu)<font></font>
{<font></font>
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* snapFilename = <span class="hljs-string">"/sdcard/framebuf"</span>;<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Writing snapshot to %s"</span>, snapFilename);<font></font>
<font></font>
	FILE* snapFile = fopen(snapFilename, <span class="hljs-string">"wb"</span>);<font></font>
	assert(snapFile);<font></font>
<font></font>
		fwrite(gFramebuffer, <span class="hljs-keyword">sizeof</span>(gFramebuffer[<span class="hljs-number">0</span>]), LCD_WIDTH * LCD_HEIGHT, snapFile);<font></font>
	}<font></font>
<font></font>
	fclose(snapFile);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menekan tombol Menu menyimpan isi buffer bingkai ke file yang disebut </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">framebuf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini akan menjadi buffer bingkai mentah, sehingga piksel akan tetap dalam format RGB565 dengan urutan byte terbalik. </font><font style="vertical-align: inherit;">Kita dapat lagi menggunakan ImageMagick untuk mengonversi format ini ke PNG untuk melihatnya di komputer.</font></font><br>
<br>
<pre><code class="cpp hljs">convert -depth <span class="hljs-number">16</span> -size <span class="hljs-number">320</span>x240+<span class="hljs-number">0</span> -endian msb rgb565:FRAMEBUF snap.png</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, kita dapat menerapkan membaca / menulis ke format BMP / PNG dan menyingkirkan semua keributan ini dengan ImageMagick, tetapi ini hanya kode demo. </font><font style="vertical-align: inherit;">Sejauh ini saya belum memutuskan format file mana yang ingin saya gunakan untuk menyimpan sprite.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bd/09c/e66/0bd09ce669a61276676a87b01c15e6f2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini dia! </font><font style="vertical-align: inherit;">Buffer bingkai Odroid Go ditampilkan di komputer desktop.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referensi</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skema Odroid pergi</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentasi ESP-IDF: SDMMC</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian 5: baterai</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go memiliki baterai lithium-ion, sehingga kami dapat membuat game yang dapat Anda mainkan saat bepergian. </font><font style="vertical-align: inherit;">Ini adalah ide yang menggoda bagi seseorang yang memainkan Gameboy pertama sebagai seorang anak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, kita memerlukan cara untuk meminta tingkat baterai Odroid Go. </font><font style="vertical-align: inherit;">Baterai terhubung ke kontak pada ESP32, sehingga kita dapat membaca tegangan untuk mengetahui perkiraan waktu pengoperasian yang tersisa.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skema</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f2/ceb/13b/1f2ceb13bf408d8773f22047464e4e66.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diagram menunjukkan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terhubung ke </font><font style="vertical-align: inherit;">tegangan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setelah ditarik ke tanah melalui resistor. Dua resistor ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R21</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R23</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) membentuk pembagi tegangan yang serupa dengan yang digunakan pada salib gamepad; resistor sekali lagi memiliki resistansi yang sama sehingga tegangannya setengah dari aslinya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena pembagi tegangan, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan membaca tegangan sama dengan setengah </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini mungkin dilakukan karena kontak ADC pada ESP32 tidak dapat membaca tegangan tinggi baterai lithium-ion (4,2 V pada muatan maksimum). Bagaimanapun, ini berarti bahwa untuk mendapatkan tegangan yang benar, Anda perlu menggandakan tegangan membaca dari ADC (ADC).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat membaca nilai </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami mendapatkan nilai digital, tetapi kehilangan nilai analog yang diwakilinya. Kita membutuhkan cara untuk menginterpretasikan nilai digital dengan ADC dalam bentuk tegangan analog fisik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDF memungkinkan Anda untuk mengkalibrasi ADC, yang mencoba memberikan level tegangan berdasarkan tegangan referensi. Tegangan referensi ini ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vref</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) adalah 1100 mV secara default, tetapi karena karakteristik fisik, setiap perangkat sedikit berbeda. ESP32 di Odroid Go memiliki Vref yang ditentukan secara manual, "di-flash" di eFuse, yang dapat kita gunakan sebagai Vref yang lebih akurat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prosedurnya adalah sebagai berikut: pertama, kita akan mengkonfigurasi kalibrasi ADC, dan ketika kita ingin membaca voltase, kita akan mengambil sejumlah sampel tertentu (misalnya, 20) untuk menghitung rata-rata bacaan; maka kami menggunakan IDF untuk mengubah pembacaan ini menjadi tegangan. Perhitungan rata-rata menghilangkan kebisingan dan memberikan pembacaan yang lebih akurat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, tidak ada koneksi linear antara tegangan dan pengisian daya baterai. Ketika muatan berkurang, tegangan turun, ketika meningkat, itu naik, tetapi dengan cara yang tidak terduga. Semua itu dapat dikatakan: jika tegangan di bawah sekitar 3,6 V, maka baterai habis, tetapi sangat sulit untuk secara akurat mengubah tingkat tegangan menjadi persentase dari muatan baterai.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk proyek kami, ini tidak terlalu penting. </font><font style="vertical-align: inherit;">Kami dapat menerapkan perkiraan kasar untuk memberi tahu pemain tentang perlunya mengisi daya perangkat dengan cepat, tetapi kami tidak akan menderita, mencoba untuk mendapatkan persentase yang tepat.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status LED</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/0ad/2d6/b520ad2d63e2a4c59924debb6c3613bc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada panel depan di bawah layar Odroid Go ada LED biru (LED), yang dapat kita gunakan untuk tujuan apa pun. Anda dapat menunjukkan kepada mereka bahwa perangkat dihidupkan dan berfungsi, tetapi dalam kasus ini, saat bermain dalam gelap, LED biru cerah akan bersinar di wajah Anda. Oleh karena itu, kami akan menggunakannya untuk menunjukkan daya baterai rendah (meskipun saya lebih suka warna merah atau kuning untuk ini). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menggunakan LED, Anda perlu mengatur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebagai output, dan kemudian menerapkan sinyal tinggi atau rendah untuk menyalakan dan mematikan LED. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya pikir bahwa </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resistor</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2 kΩ ( </font><strong><font style="vertical-align: inherit;">resistor pembatas arus</font></strong><font style="vertical-align: inherit;"> ) akan cukup sehingga kita tidak membakar LED dan memasok terlalu banyak arus dari pin GPIO.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LED memiliki resistansi yang agak rendah, jadi jika 3.3 V diterapkan, maka kita akan membakarnya dengan mengubah arus. </font><font style="vertical-align: inherit;">Untuk melindungi dari ini, sebuah resistor biasanya dihubungkan secara seri dengan LED. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, resistor pembatas arus untuk LED biasanya jauh lebih kecil dari 2 kΩ, jadi saya tidak mengerti mengapa resistor </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah hambatan seperti itu.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inisialisasi</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> BATTERY_READ_PIN = ADC1_GPIO36_CHANNEL;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BATTERY_LED_PIN = GPIO_NUM_2;<font></font>
<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">esp_adc_cal_characteristics_t</span> gCharacteristics;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeBatteryReader</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-comment">// Configure LED</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; BATTERY_LED_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure ADC</span><font></font>
	{<font></font>
		adc1_config_width(ADC_WIDTH_BIT_12);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
<font></font>
    	<span class="hljs-keyword">esp_adc_cal_value_t</span> type = esp_adc_cal_characterize(<font></font>
    		ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_12, <span class="hljs-number">1100</span>, &amp;gCharacteristics);<font></font>
<font></font>
    	assert(type == ESP_ADC_CAL_VAL_EFUSE_VREF);<font></font>
    }<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Battery reader initialized"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama-tama kita mengatur LED GPIO sebagai output sehingga kita dapat mengubahnya jika perlu. </font><font style="vertical-align: inherit;">Kemudian kita mengkonfigurasi pin ADC, seperti yang kita lakukan dalam kasus cross - dengan lebar bit 12 dan atenuasi minimal. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_characterize</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> melakukan penghitungan bagi kita untuk mengkarakterisasi ADC sehingga kita nanti dapat mengubah pembacaan digital menjadi tekanan fisik.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baca Baterai</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">Odroid_ReadBatteryLevel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SAMPLE_COUNT = <span class="hljs-number">20</span>;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> raw = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sampleIndex = <span class="hljs-number">0</span>; sampleIndex &lt; SAMPLE_COUNT; ++sampleIndex)<font></font>
	{<font></font>
		raw += adc1_get_raw(BATTERY_READ_PIN);<font></font>
	}<font></font>
<font></font>
	raw /= SAMPLE_COUNT;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> voltage = <span class="hljs-number">2</span> * esp_adc_cal_raw_to_voltage(raw, &amp;gCharacteristics);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> voltage;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mengambil dua puluh sampel mentah ADC dari kontak ADC, dan kemudian membaginya untuk mendapatkan nilai rata-rata. Seperti disebutkan di atas, ini membantu mengurangi kebisingan bacaan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian kita menggunakan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_raw_to_voltage</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk mengkonversi nilai mentah ke tegangan nyata. Karena pembagi tegangan yang disebutkan di atas, kami menggandakan nilai kembali: nilai baca akan menjadi setengah dari tegangan baterai yang sebenarnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alih-alih menghasilkan cara-cara rumit untuk mengubah tegangan ini menjadi persentase daya baterai, kami akan mengembalikan tegangan sederhana. Biarkan fungsi panggilan memutuskan sendiri apa yang harus dilakukan dengan voltase - apakah mengubahnya menjadi persentase muatan, atau hanya menafsirkannya sebagai nilai tinggi atau rendah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nilai dikembalikan dalam milivolt, sehingga fungsi panggilan perlu melakukan konversi yang sesuai. </font><font style="vertical-align: inherit;">Ini mencegah float overflow.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengaturan LED</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_EnableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_DisableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua fungsi sederhana ini cukup menggunakan LED. </font><font style="vertical-align: inherit;">Kita bisa menyalakan atau mematikan lampu. </font><font style="vertical-align: inherit;">Biarkan fungsi panggilan memutuskan kapan melakukannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami dapat membuat tugas yang secara berkala akan memonitor tegangan baterai dan karenanya mengubah status LED, tetapi saya sebaiknya menginterogasi tegangan baterai dalam siklus utama kami, dan kemudian memutuskan cara mengatur tegangan baterai dari sana.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint32_t</span> batteryLevel = Odroid_ReadBatteryLevel();<font></font>
<font></font>
<span class="hljs-keyword">if</span> (batteryLevel &lt; <span class="hljs-number">3600</span>)<font></font>
{<font></font>
	Odroid_EnableBatteryLight();<font></font>
}<font></font>
<span class="hljs-keyword">else</span><font></font>
{<font></font>
	Odroid_DisableBatteryLight();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami hanya dapat meminta tingkat baterai dalam siklus utama, dan jika voltase di bawah nilai ambang batas, nyalakan LED, yang menunjukkan perlunya pengisian daya. </font><font style="vertical-align: inherit;">Berdasarkan bahan yang dipelajari, saya dapat mengatakan bahwa 3600 mV (3,6 V) adalah pertanda baik dari baterai lithium-ion yang rendah, tetapi baterainya sendiri kompleks.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referensi</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skema Odroid pergi</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentasi ESP-IDF: ADC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karakteristik baterai</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian 6: suara</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Langkah terakhir untuk mendapatkan antarmuka lengkap untuk semua perangkat keras Odroid Go adalah menulis lapisan suara. Setelah selesai dengan ini, kita bisa mulai bergerak ke arah pemrograman yang lebih umum dari gim, kurang terkait dengan pemrograman untuk Odroid. Semua interaksi dengan periferal akan dilakukan melalui fungsi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena kurangnya pengalaman saya dengan pemrograman suara dan kurangnya dokumentasi yang baik pada bagian IDF, ketika bekerja pada suatu proyek, implementasi suara mengambil paling banyak waktu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada akhirnya, tidak begitu banyak kode yang diperlukan untuk memutar suara. Sebagian besar waktu dihabiskan untuk bagaimana mengkonversi data audio ke ESP32 yang diinginkan dan cara mengkonfigurasi driver audio ESP32 agar sesuai dengan konfigurasi perangkat keras.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dasar-Dasar Suara Digital</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suara digital terdiri dari dua bagian: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perekaman</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pemutaran</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merekam</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk merekam suara pada komputer, pertama-tama kita perlu mengubahnya dari ruang sinyal kontinyu (analog) menjadi ruang sinyal diskrit (digital). </font><font style="vertical-align: inherit;">Tugas ini diselesaikan dengan menggunakan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konverter analog-ke-digital (ADC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (yang kami bicarakan ketika kami bekerja dengan salib di Bagian 2). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ADC menerima </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sampel</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gelombang yang masuk dan mendigitalkan nilainya, yang kemudian dapat disimpan ke file.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bermain</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File suara digital dapat dikembalikan dari ruang digital ke analog menggunakan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digital-to-Analog Converter (DAC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">DAC dapat mereproduksi nilai hanya dalam rentang tertentu. </font><font style="vertical-align: inherit;">Misalnya, DAC 8-bit dengan sumber 3,3 V dapat menampilkan tegangan analog dalam kisaran dari 0 hingga 3,3 mV dalam langkah 12,9 mV (3,3 V dibagi dengan 256). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DAC mengambil nilai digital dan mengubahnya kembali menjadi tegangan, yang dapat ditransmisikan ke amplifier, speaker, atau perangkat lain yang mampu menerima sinyal audio analog.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tingkat pengambilan sampel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat merekam suara analog melalui ADC, sampel diambil pada frekuensi tertentu, dan setiap sampel adalah "potret" sinyal suara pada suatu titik waktu. Parameter ini disebut </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frekuensi sampling</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan diukur dalam </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hertz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semakin tinggi frekuensi pengambilan sampel, semakin akurat kita menciptakan frekuensi sinyal asli. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teorema Nyquist-Shannon (Kotelnikov)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyatakan (secara sederhana) bahwa frekuensi sampling harus dua kali frekuensi sinyal tertinggi yang ingin kami rekam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Telinga manusia dapat mendengar kira-kira dalam kisaran </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari 20 Hz hingga 20 kHz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sehingga frekuensi pengambilan sampel </font><strong><font style="vertical-align: inherit;">44,1 kHz</font></strong><font style="vertical-align: inherit;"> paling sering digunakan untuk menciptakan kembali musik berkualitas tinggi.</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Yang sedikit lebih dari dua kali frekuensi maksimum yang dapat dikenali telinga manusia. Ini memastikan bahwa satu set lengkap frekuensi instrumen dan suara akan diciptakan kembali. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, setiap sampel membutuhkan ruang dalam file, jadi kami tidak dapat memilih tingkat pengambilan sampel maksimum. Namun, jika Anda tidak mengambil sampel dengan cukup cepat, Anda dapat kehilangan informasi penting. Frekuensi pengambilan sampel yang dipilih harus bergantung pada frekuensi yang ada dalam suara yang diciptakan kembali. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemutaran ulang harus dilakukan pada frekuensi pengambilan sampel yang sama dengan sumbernya, jika tidak suara dan durasinya akan berbeda.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan sepuluh detik suara direkam pada frekuensi sampling 16 kHz. </font><font style="vertical-align: inherit;">Jika Anda memainkannya dengan frekuensi 8 kHz, maka nadanya akan lebih rendah, dan durasinya akan menjadi dua puluh detik. </font><font style="vertical-align: inherit;">Jika Anda memainkannya dengan frekuensi sampling 32 kHz, maka nada yang terdengar akan lebih tinggi, dan suara itu sendiri akan bertahan lima detik. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video ini menunjukkan perbedaan dalam tingkat sampel dengan contoh.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedalaman bit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frekuensi pengambilan sampel hanya setengah dari persamaan. Suara juga memiliki </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kedalaman bit</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yaitu jumlah bit per sampel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika ADC menangkap sampel sinyal audio, ADC harus mengubah nilai analog ini menjadi digital, dan kisaran nilai yang ditangkap tergantung pada jumlah bit yang digunakan. 8 bit (nilai 256), 16 bit (nilai 65.526), ​​32 bit (4.294.967.296 nilai), dll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jumlah bit per sampel terkait dengan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rentang dinamis</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> suara, mis. dengan bagian paling keras dan paling tenang. Kedalaman bit yang paling umum untuk musik adalah 16 bit. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selama pemutaran, perlu untuk memberikan kedalaman bit yang sama dengan sumbernya, jika tidak suara dan durasinya akan berubah.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, Anda memiliki file audio dengan empat sampel disimpan sebagai 8 bit: [0x25, 0xAB, 0x34, 0x80]. </font><font style="vertical-align: inherit;">Jika Anda mencoba memainkannya seolah-olah 16-bit, Anda hanya akan mendapatkan dua sampel: [0x25AB, 0x3480]. </font><font style="vertical-align: inherit;">Ini tidak hanya akan menyebabkan nilai sampel suara yang salah, tetapi juga mengurangi separuh jumlah sampel, dan karenanya durasi suara. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penting juga untuk mengetahui format sampel. </font><font style="vertical-align: inherit;">8-bit unsigned, 8-bit unsigned, 16-bit unsigned, 16-bit unsigned, dll. </font><font style="vertical-align: inherit;">Biasanya 8-bit tidak ditandatangani, dan 16-bit ditandatangani. </font><font style="vertical-align: inherit;">Jika mereka bingung, suara akan sangat terdistorsi. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video ini menunjukkan perbedaan kedalaman bit dengan contoh.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">File WAV</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paling sering, data audio mentah pada komputer disimpan dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">format WAV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang memiliki header sederhana yang menggambarkan format suara (frekuensi sampling, kedalaman bit, ukuran, dll.), Diikuti oleh data audio itu sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suara tidak dikompresi sama sekali (tidak seperti format seperti MP3), jadi kita dapat dengan mudah memainkannya tanpa perlu perpustakaan codec. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah utama dengan file WAV adalah karena kurangnya kompresi, mereka bisa sangat besar. Ukuran file secara langsung terkait dengan durasi, laju sampling, dan kedalaman bit. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ukuran = Durasi (dalam detik) x Laju Pengambilan Sampel (sampel / s) x Kedalaman Bit (bit / sampel)</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frekuensi pengambilan sampel paling banyak memengaruhi ukuran file, sehingga cara termudah untuk menghemat ruang adalah dengan memilih nilai yang cukup rendah. </font><font style="vertical-align: inherit;">Kami akan membuat suara old-school, jadi frekuensi pengambilan sampel yang rendah cocok untuk kami.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I2S</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32 memiliki periferal, karena itu relatif sederhana untuk menyediakan antarmuka dengan peralatan audio: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inter-IC Sound (I2S)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Protokol I2S cukup sederhana dan hanya terdiri dari tiga sinyal: sinyal jam, pilihan saluran (kiri atau kanan), dan juga jalur data itu sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frekuensi jam tergantung pada frekuensi pengambilan sampel, kedalaman bit, dan jumlah saluran. Ketukan diganti untuk setiap bit data, oleh karena itu, untuk reproduksi suara yang tepat, Anda harus mengatur frekuensi jam yang sesuai. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frekuensi jam = Frekuensi pengambilan sampel (sampel / s) x Kedalaman bit (bit / sampel) x Jumlah saluran</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Driver I2S mikrokontroler ESP32 memiliki dua mode yang memungkinkan: dapat mengeluarkan data ke kontak yang terhubung ke penerima I2S eksternal, yang dapat men-decode protokol dan mentransfer data ke amplifier, atau dapat mentransfer data ke ESP32 DAC internal yang menghasilkan sinyal analog yang dapat ditransmisikan ke penguat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go tidak memiliki decoder I2S di papan tulis, jadi kita harus menggunakan ESP32 DAC 8-bit internal, yaitu, kita harus menggunakan suara 8-bit. </font><font style="vertical-align: inherit;">Perangkat ini memiliki dua DAC, satu terhubung ke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang lainnya ke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prosedurnya terlihat seperti ini:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mentransfer data audio ke driver I2S</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Driver I2S mengirimkan data audio ke DAC internal 8-bit</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DAC internal menghasilkan sinyal analog</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinyal analog ditransmisikan ke penguat suara</font></font></li>
<li>      </li>
<li>  </li>
</ol><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/d93/a8e/2d9d93a8ed6eceb35846c0f31e336ec9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita melihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sirkuit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> audio di </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">sirkuit Odroid Go</font></a><font style="vertical-align: inherit;"> , kita akan melihat dua pin GPIO ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) yang terhubung ke input penguat suara ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAM8304A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
juga terhubung ke sinyal </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> amplifier, yaitu kontak yang menghidupkan atau mematikan amplifier (sinyal rendah berarti shutdown). Keluaran amplifier terhubung ke satu speaker ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ingat bahwa </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah output dari 8-bit ESP32 DACs, yaitu, satu DAC terhubung ke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan yang lainnya ke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">input diferensial dari</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> penguat suara. Input diferensial digunakan untuk mengurangi noise yang disebabkan oleh </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interferensi elektromagnetik</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Setiap noise yang ada dalam satu sinyal juga akan hadir di yang lain. Satu sinyal dikurangi dari yang lain, yang menghilangkan noise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda melihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spesifikasi penguat suara</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , maka ia memiliki </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Khas Aplikasi Sirkuit</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang merupakan cara yang direkomendasikan pabrikan untuk menggunakan penguat.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/044/d2a/323/044d2a323366c5ddb3c3b87f918bf5f9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dia merekomendasikan menghubungkan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke ground, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke sinyal input, dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke sinyal on / off. Jika ada suara 0,005 V, maka dengan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- </font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0V + 0,005V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan dibaca </font><font style="vertical-align: inherit;">, dan dengan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN + 0,005V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sinyal input harus dikurangkan satu sama lain dan mendapatkan nilai sinyal yang sebenarnya ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) tanpa noise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, para perancang Odroid Go tidak menggunakan konfigurasi yang disarankan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekali lagi melihat sirkuit Odroid Go, kita melihat bahwa desainer menghubungkan output DAC ke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan bahwa output DAC yang sama terhubung ke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ini adalah sinyal penonaktifan dengan level rendah aktif, jadi agar amplifier bekerja, Anda perlu mengatur sinyal tinggi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini berarti bahwa untuk menggunakan amplifier, kita tidak boleh menggunakan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebagai DAC, tetapi sebagai keluaran GPIO dengan sinyal yang selalu tinggi. Namun, dalam kasus ini, sinyal tinggi diatur ke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang tidak direkomendasikan oleh spesifikasi amplifier (harus di-ground). Maka kita harus menggunakan DAC yang terhubung ke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena output I2S kita harus dimasukkan ke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini berarti bahwa kami tidak akan mencapai pengurangan kebisingan yang diperlukan, karena </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak terhubung ke ground. Suara lembut terus-menerus keluar dari speaker.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami perlu memastikan konfigurasi driver I2S yang benar, karena kami hanya ingin menggunakan DAC yang terhubung ke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jika kami menggunakan DAC yang terhubung ke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , itu akan terus-menerus mematikan sinyal amplifier, dan suaranya akan mengerikan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain keanehan ini, ketika menggunakan DAC internal 8-bit, driver I2S di ESP32 memerlukan sampel 16-bit untuk ditransmisikan ke sana, tetapi hanya mengirimkan byte tinggi ke DAC 8-bit. </font><font style="vertical-align: inherit;">Oleh karena itu, kita perlu mengambil suara 8-bit kami dan menempelkannya ke buffer dua kali lebih besar, sementara buffer akan menjadi setengah kosong. </font><font style="vertical-align: inherit;">Kemudian kami meneruskannya ke driver I2S dan melewati DAC byte tinggi dari setiap sampel. </font><font style="vertical-align: inherit;">Sayangnya, ini berarti bahwa kita harus "membayar" untuk 16 bit, tetapi kita hanya bisa menggunakan 8 bit.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multitasking</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, permainan tidak dapat bekerja pada satu inti, seperti yang saya inginkan, karena sepertinya ada bug pada driver I2S. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Driver I2S harus menggunakan DMA (seperti driver SPI), yaitu, kita bisa saja memulai transfer I2S, dan kemudian melanjutkan pekerjaan kita sementara driver I2S mentransmisikan data audio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi sebaliknya, CPU diblokir selama durasi suara, yang sama sekali tidak cocok untuk permainan. Bayangkan Anda menekan tombol lompat, dan kemudian sprite pemain menghentikan gerakannya selama 100 ms saat suara lompat diputar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengatasi masalah ini, kita dapat memanfaatkan fakta bahwa ada dua inti di papan ESP32. </font><font style="vertical-align: inherit;">Kita dapat membuat tugas (mis. Utas) di inti kedua, yang akan menangani reproduksi suara. </font><font style="vertical-align: inherit;">Berkat ini, kami dapat mentransfer pointer ke buffer suara dari tugas utama game ke tugas suara, dan tugas suara memulai transfer I2S dan diblokir selama durasi pemutaran suara. </font><font style="vertical-align: inherit;">Tetapi tugas utama pada inti pertama (dengan pemrosesan input dan rendering) akan terus dieksekusi tanpa memblokir.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inisialisasi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengetahui hal ini, kita dapat memulai driver I2S dengan benar. </font><font style="vertical-align: inherit;">Untuk melakukan ini, Anda hanya perlu beberapa baris kode, tetapi kesulitannya adalah untuk mengetahui parameter apa yang perlu Anda set untuk reproduksi suara yang tepat.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> AUDIO_AMP_SD_PIN = GPIO_NUM_25;<font></font>
<font></font>
<span class="hljs-keyword">static</span> QueueHandle_t gQueue;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlayTask</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span>
</span>{
	<span class="hljs-keyword">for</span>(;;)<font></font>
	{<font></font>
		QueueData data;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (xQueueReceive(gQueue, &amp;data, <span class="hljs-number">10</span>))<font></font>
		{<font></font>
			<span class="hljs-keyword">size_t</span> bytesWritten;<font></font>
			i2s_write(I2S_NUM_0, data.buffer, data.length, &amp;bytesWritten, portMAX_DELAY);<font></font>
			i2s_zero_dma_buffer(I2S_NUM_0);<font></font>
		}<font></font>
<font></font>
		vTaskDelay(<span class="hljs-number">1</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeAudio</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-comment">// Configure the amplifier shutdown signal</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; AUDIO_AMP_SD_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
<font></font>
		gpio_set_level(AUDIO_AMP_SD_PIN, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure the I2S driver</span><font></font>
	{<font></font>
		<span class="hljs-keyword">i2s_config_t</span> i2sConfig= {};<font></font>
<font></font>
		i2sConfig.mode = I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN;<font></font>
		i2sConfig.sample_rate = <span class="hljs-number">5012</span>;<font></font>
		i2sConfig.bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT;<font></font>
		i2sConfig.communication_format = I2S_COMM_FORMAT_I2S_MSB;<font></font>
		i2sConfig.channel_format = I2S_CHANNEL_FMT_ONLY_LEFT;<font></font>
		i2sConfig.dma_buf_count = <span class="hljs-number">8</span>;<font></font>
		i2sConfig.dma_buf_len = <span class="hljs-number">64</span>;<font></font>
<font></font>
		ESP_ERROR_CHECK(i2s_driver_install(I2S_NUM_0, &amp;i2sConfig, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>));<font></font>
		ESP_ERROR_CHECK(i2s_set_dac_mode(I2S_DAC_CHANNEL_LEFT_EN));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Create task for playing sounds so that our main task isn't blocked</span><font></font>
	{<font></font>
		gQueue = xQueueCreate(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(QueueData));<font></font>
		assert(gQueue);<font></font>
<font></font>
		BaseType_t result = xTaskCreatePinnedToCore(&amp;PlayTask, <span class="hljs-string">"I2S Task"</span>, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>);<font></font>
		assert(result == pdPASS);<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, kami mengonfigurasi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (yang terhubung ke sinyal turn-off amplifier) ​​sebagai output sehingga dapat mengontrol amplifier suara, dan menerapkan sinyal tinggi untuk mengaktifkan amplifier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, kita mengkonfigurasi dan menginstal driver I2S itu sendiri. </font><font style="vertical-align: inherit;">Saya akan menguraikan setiap bagian dari konfigurasi baris demi baris, karena masing-masing baris memerlukan penjelasan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mode</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami menetapkan driver sebagai master (mengendalikan bus), pemancar (karena kami mentransfer data ke penerima), dan mengkonfigurasinya untuk menggunakan DAC 8-bit bawaan (karena papan Odroid Go tidak memiliki DAC eksternal).</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sample_rate</font></font><ul>
<li>    5012,      ,   ,      .   ,      ,          .    -,           2500 .</li>
</ul></li>
<li>bits_per_sample<ul>
<li>  ,    ESP32  8-,   I2S ,      16    ,   8     .</li>
</ul></li>
<li>communication_format<ul>
<li>      ,   ,   -   ,   8-      16- .</li>
</ul></li>
<li>channel_format<ul>
<li> GPIO,    <strong>IN+</strong>   —  <strong>IO26</strong>,       «»   I2S.  ,  I2S      ,      <strong>IO25</strong>,      ,          .</li>
</ul></li>
<li>dma_buf_count  dma_buf_len<ul>
<li>  DMA-   ( )  ,        ,   ,        IDF.       ,     .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lalu kami membuat antrian - ini adalah cara FreeRTOS mengirim data di antara tugas-tugas. Kami menempatkan data dalam antrian satu tugas dan mengekstraknya dari antrian tugas lain. Buat struct yang disebut </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang menggabungkan pointer ke buffer suara dan panjang buffer ke dalam struktur tunggal yang dapat antri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, buat tugas yang berjalan di inti kedua. Kami menghubungkannya ke fungsi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang melakukan pemutaran suara. Tugas itu sendiri adalah loop tanpa akhir yang terus-menerus memeriksa untuk melihat apakah ada data dalam antrian. Jika ya, ia mengirimnya ke driver I2S agar dapat dimainkan. Ini akan memblokir panggilan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i2s_write</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan ini cocok untuk kami, karena tugas dilakukan pada kernel yang terpisah dari utas utama permainan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Panggilan ke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i2s_zero_dma_buffer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diperlukan sehingga setelah pemutaran selesai tidak ada suara yang tersisa dari speaker. </font><font style="vertical-align: inherit;">Saya tidak tahu apakah ini bug dari driver I2S atau perilaku yang diharapkan, tetapi tanpa itu, setelah buffer suara selesai diputar, speaker mengeluarkan sinyal sampah.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memainkan suara</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_PlayAudio</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span>* buffer, <span class="hljs-keyword">size_t</span> length)</span>
</span>{<font></font>
	QueueData data = {};<font></font>
<font></font>
	data.buffer = buffer;<font></font>
	data.length = length;<font></font>
<font></font>
	xQueueSendToBack(gQueue, &amp;data, portMAX_DELAY);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena fakta bahwa seluruh konfigurasi telah selesai, panggilan ke fungsi pemutaran buffer suara itu sendiri sangat sederhana, karena pekerjaan utama dilakukan pada tugas lain. </font><font style="vertical-align: inherit;">Kami menempatkan pointer ke buffer dan panjang buffer ke dalam struktur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan kemudian memasukkannya ke dalam antrian yang digunakan oleh fungsi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena pola operasi ini, satu buffer suara harus menyelesaikan pemutaran sebelum dapat memulai buffer kedua. </font><font style="vertical-align: inherit;">Oleh karena itu, jika lompatan dan pemotretan terjadi secara bersamaan, suara pertama akan dimainkan sebelum yang kedua, dan tidak bersamaan dengan itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemungkinan besar, di masa depan saya akan mencampur suara bingkai yang berbeda ke buffer suara yang ditransmisikan ke driver I2S. </font><font style="vertical-align: inherit;">Ini akan memungkinkan Anda untuk memutar beberapa suara sekaligus.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan menghasilkan efek suara kami sendiri menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsfxr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , alat yang dirancang khusus untuk menghasilkan jenis suara permainan yang kami butuhkan. </font><font style="vertical-align: inherit;">Kita dapat langsung mengatur frekuensi sampling dan kedalaman bit, dan kemudian menampilkan file WAV. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menciptakan efek suara lompatan sederhana yang menyerupai suara lompatan Mario. </font><font style="vertical-align: inherit;">Ini memiliki frekuensi sampling 5012 (seperti yang kami konfigurasikan selama inisialisasi) dan kedalaman 8 bit (karena DAC adalah 8-bit).</font></font><br>
<br>
<div class="oembed"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://austinmorlan.com/posts/embedded_game_programming_6/media/jump.wav</font></font></a></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alih-alih mengurai file WAV langsung dalam kode, kami akan melakukan sesuatu yang mirip dengan apa yang kami lakukan untuk memuat sprite dalam demo Bagian 4: kami akan menghapus header WAV dari file menggunakan hex editor. Berkat ini, file yang dibaca dari kartu SD hanya akan menjadi data mentah. Juga, kita tidak akan membaca durasi suara, kita akan menuliskannya dalam kode. Di masa depan, kami akan memuat sumber daya suara secara berbeda, tetapi ini sudah cukup untuk demo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File mentah dapat diunduh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Load sound effect</span>
<span class="hljs-keyword">uint16_t</span>* soundBuffer;
<span class="hljs-keyword">int</span> soundEffectLength = <span class="hljs-number">1441</span>;<font></font>
{<font></font>
	FILE* soundFile = fopen(<span class="hljs-string">"/sdcard/jump"</span>, <span class="hljs-string">"r"</span>);<font></font>
	assert(soundFile);<font></font>
<font></font>
	<span class="hljs-keyword">uint8_t</span>* soundEffect = <span class="hljs-built_in">malloc</span>(soundEffectLength);<font></font>
	assert(soundEffect);<font></font>
<font></font>
	soundBuffer = <span class="hljs-built_in">malloc</span>(soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	assert(soundBuffer);<font></font>
<font></font>
	fread(soundEffect, soundEffectLength, <span class="hljs-number">1</span>, soundFile);<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; soundEffectLength; ++i)<font></font>
    {<font></font>
        <span class="hljs-comment">// 16 bits required but only MSB is actually sent to the DAC</span>
        soundBuffer[i] = (soundEffect[i] &lt;&lt; <span class="hljs-number">8u</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memuat data 8-bit ke dalam buffer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soundEffect</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8-bit </font><font style="vertical-align: inherit;">, dan kemudian menyalin data ini ke buffer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soundBuffer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16-bit </font><font style="vertical-align: inherit;">, di mana data akan disimpan dalam delapan bit tinggi. </font><font style="vertical-align: inherit;">Saya ulangi - ini perlu karena fitur implementasi IDF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah membuat buffer 16-bit, kita dapat memutar suara klik tombol. </font><font style="vertical-align: inherit;">Adalah logis untuk menggunakan tombol volume untuk ini.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> lastState = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (;;)<font></font>
{<font></font>
	[...]<font></font>
<font></font>
	<span class="hljs-keyword">int</span> thisState = input.volume;<font></font>
<font></font>
	<span class="hljs-keyword">if</span> ((thisState == <span class="hljs-number">1</span>) &amp;&amp; (thisState != lastState))<font></font>
	{<font></font>
		Odroid_PlayAudio(soundBuffer, soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	}<font></font>
<font></font>
	lastState = thisState;<font></font>
<font></font>
	[...]<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memantau keadaan tombol sehingga secara tidak sengaja, dengan satu klik tombol, Anda tidak sengaja memanggil </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid_PlayAudio</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beberapa kali.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Browser Anda tidak mendukung video HTML5.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_6/media/demo.mp4" type="video/mp4"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua kode sumber ada di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referensi</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skema Odroid pergi</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembar Data Penguat Audio</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentasi ESP-IDF: DAC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentasi ESP-IDF: I2S</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Format File WAVE</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video: Penjelasan Kedalaman Bit</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video: Penjelasan Tingkat Sampel</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id503854/index.html">Gunakan SIL secara maksimal</a></li>
<li><a href="../id503858/index.html">Buku "Terraform: infrastruktur di tingkat kode"</a></li>
<li><a href="../id503860/index.html">Menyiapkan lingkungan jaringan saraf Mask R-CNN</a></li>
<li><a href="../id503864/index.html">Organisasi Flavours di Flutter</a></li>
<li><a href="../id503866/index.html">Menerbitkan Roadmap development Zextras Suite untuk 2020</a></li>
<li><a href="../id503880/index.html">Bagaimana saya belajar untuk tidak khawatir dan menyukai visi mesin</a></li>
<li><a href="../id503884/index.html">Cara belajar bekerja secara tidak sinkron</a></li>
<li><a href="../id503888/index.html">Algoritma AdaBoost</a></li>
<li><a href="../id503890/index.html">Kisah Bagaimana Saya Mengkonfigurasi Azure AD B2C pada Bereaksi dan Bereaksi Asli Bagian 1 (Tutorial)</a></li>
<li><a href="../id503892/index.html">Mitap: Karantina, Pergi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>