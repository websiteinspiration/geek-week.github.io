<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏾 ⚫️ 😡 フロントエンドテスト 👨🏼‍💼 👨🏿‍⚕️ 🧒🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="自動化されたコードテストの効果的な戦略は、Webプロジェクトのサポートと開発に関与するプログラマーチームの迅速かつ高品質な作業を保証するために非常に重要です。この記事の著者は、彼が働いているStackPathという会社では、テストですべてが正常に機能していると述べています。彼らはコードをチェックする...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>フロントエンドテスト</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/477278/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動化されたコードテストの効果的な戦略は、Webプロジェクトのサポートと開発に関与するプログラマーチームの迅速かつ高品質な作業を保証するために非常に重要です。この記事の著者は、</font><font style="vertical-align: inherit;">彼が働いている</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StackPath</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という会社で</font><font style="vertical-align: inherit;">は、テストですべてが</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">正常に機能</font></a><font style="vertical-align: inherit;">していると述べて</font><font style="vertical-align: inherit;">います。彼らはコードをチェックするための多くのツールを持っています。しかし、そのような多様性の中から、それぞれの場合に最適なものを選択する必要があります。これは別の問題です。そして、必要なツールを選択した後も、それらのツールの使用順序を決定する必要があります。</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/1bd/f09/0a3/1bdf090a307b28098ab0758186db9d2c.svg" alt="画像"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の著者は、StackPathは、適用されたテストシステムのおかげで達成されたコードの品質に対する信頼水準に満足していると述べています。</font><font style="vertical-align: inherit;">ここで彼は、会社が開発したテストの原則の説明を共有し、使用するツールについて話したいと考えています。</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストの原則</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のツールについて説明する前に、優れたテストとは何かという質問に対する答えについて考えることは価値があります。</font><font style="vertical-align: inherit;">クライアント向けの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポータル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">作業を開始する前</font><font style="vertical-align: inherit;">に、テストを作成する際に従うべき原則を策定し、書き留めました。</font><font style="vertical-align: inherit;">私たちが最初にやったことは、まさにツールの選択に私たちを助けたものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題の4つの原則は次のとおりです。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍原則番号1。</font><font style="vertical-align: inherit;">テストは最適化タスクとして理解する必要があります</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
効果的なテスト戦略は、特定の値（この場合、アプリケーションが正しく機能するという信頼レベル）を最大化し、特定のコスト（ここで「コスト」とは、テストのサポートと実行に必要な時間で表されます）を最小化するという問題を解決することです。</font><font style="vertical-align: inherit;">テストを書くとき、私たちはしばしば上記の原則に関連して以下の質問をします：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このテストでエラーが検出される可能性はどれくらいですか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このテストは私たちのテストシステムを改善しますか、それを作成するために必要なリソースのコストは、それから得られる利点に値しますか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストするエンティティに対して、作成、保守、実行がより簡単な別のテストを作成することで、このテストが与えるのと同じレベルの信頼を得ることができますか？</font></font></li>
</ul><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍原則2。</font><font style="vertical-align: inherit;">moxの使いすぎは避けてください。</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assert.js 2018カンファレンスの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレゼンテーションでは、</font><font style="vertical-align: inherit;">
「mok」という用語について私のお気に入りの説明の1つが</font><font style="vertical-align: inherit;">行われました。スピーカーは、ここで開くよりも深く質問を開きました。スピーチでは、モカの作成は「現実のパンチングホール」と比較されます。そして、これはモックを認識する非常に視覚的な方法だと思います。テストにはモカがありますが、テストの作成と実行のプロセスの簡素化によりモカが提供するテストの「コスト」の減少と、実際に別の穴を開けるテストの価値の減少とを比較します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は、プログラマーは記述された単体テストに大きく依存していたため、浅い</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">酵素</font></a><font style="vertical-align: inherit;">レンダリングAPIを使用して、すべての子の依存関係をmokaで置き換えていました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この方法でレンダリングされたエンティティは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jest</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スナップショットを使用してチェックされました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このようなテストはすべて、同様のパターンを使用して記述されています。</font></font><br>
<br>
<pre><code class="javascript hljs">it(<span class="hljs-string">'renders '</span>, () =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> wrapper = shallow();
&nbsp;&nbsp;<span class="hljs-comment">//  ,           </span><font></font>
&nbsp;&nbsp;expect(wrapper).toMatchSnapshot();<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのテストは、多くの場所で現実に満ちています。</font><font style="vertical-align: inherit;">このアプローチにより、テストで100％のコードカバレッジを簡単に達成できます。</font><font style="vertical-align: inherit;">そのようなテストを作成するときは、ほとんど何も考えなくてもかまいませんが、多数の統合ポイントをすべてチェックしなければ、そのようなテストは特に価値がありません。</font><font style="vertical-align: inherit;">すべてのテストは正常に完了することができますが、これはアプリケーションの操作性にあまり自信を与えません。</font><font style="vertical-align: inherit;">さらに悪いことに、すべてのmokaには、テストの作成後に支払う必要のある「価格」が隠されています。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍原則3。</font><font style="vertical-align: inherit;">テストはコードのリファクタリングを容易にし、複雑にするべきではない</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のようなテストでは、リファクタリングが複雑になります。プロジェクトの多くの場所でコードが重複していることがわかった場合、しばらくしてこのコードを個別のコンポーネントとしてフォーマットすると、この新しいコンポーネントを使用するコンポーネントのすべてのテストが失敗します。浅いレンダリング技術を使用して派生したコンポーネントは、すでに別のものです。以前はマークアップを繰り返していましたが、今は新しいコンポーネントがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のコンポーネントをプロジェクトに追加したり、他のコンポーネントを削除したりするなど、より複雑なリファクタリングはさらに混乱を招きます。実際には、システムに新しいテストを追加し、システムから不要なテストを削除する必要があります。スナップショットの再生成は簡単なタスクですが、そのようなテストの価値は何ですか？たとえ彼らが間違いを見つけられたとしても、彼らが一連のスナップショットの変更でそれを見逃し、あまり多くの時間を費やすことなく単に新しいスナップショットをチェックした方がいいでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、そのようなテストは特にリファクタリングを助けません。</font><font style="vertical-align: inherit;">理想的には、リファクタリングを実行してもテストは失敗しないはずです。その後、ユーザーに表示され、操作内容は変更されません。</font><font style="vertical-align: inherit;">逆もまた同様です。ユーザーが連絡する内容を変更した場合、少なくとも1つのテストが失敗するはずです。</font><font style="vertical-align: inherit;">テストがこれら2つのルールに従っている場合、それらは、リファクタリング中にユーザーが遭遇するものが変更されていないことを保証する優れたツールです。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍原則4。</font><font style="vertical-align: inherit;">テストでは、実際のユーザーがアプリケーションを操作する方法を再現する必要があります</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーが操作する何かが変更された場合にのみ、テストが失敗するようにします。</font><font style="vertical-align: inherit;">これは、ユーザーがアプリケーションを操作するのと同じ方法で、テストがアプリケーションで機能することを意味します。</font><font style="vertical-align: inherit;">たとえば、テストはフォーム要素と真に相互作用する必要があり、ユーザーと同様に、テキスト入力フィールドにテキストを入力する必要があります。</font><font style="vertical-align: inherit;">テストでは、コンポーネントにアクセスしたり、それらのライフサイクルのメソッドを個別に呼び出したり、コンポーネントの状態に何かを書き込んだり、複雑なコンポーネント実装に依存することを行ったりしてはなりません。</font><font style="vertical-align: inherit;">最終的には、ユーザーと接触しているシステムの部分をチェックしたいので、システムと対話するときのテストが、実際のユーザーのアクションをできる限り近く再現することを確認するよう努めることは論理的です。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストツール</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
達成したい目標を定義したので、これのためにどのツールを選択したかについて話しましょう。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍TypeScript</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのコードベースはTypeScriptを使用しています。</font><font style="vertical-align: inherit;">私たちのバックエンドサービスはGoで記述されており、gRPCを使用して相互にやり取りします。</font><font style="vertical-align: inherit;">これにより、GraphQLサーバーで使用するための型付きgRPCクライアントを生成できます。</font><font style="vertical-align: inherit;">GraphQLサーバーリゾルバーは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">graphql-code-generator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって生成された型を使用して型付けされ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">そして最後に、クエリ、ミューテーション、サブスクリプションコンポーネントとフックが完全に型指定されます。</font><font style="vertical-align: inherit;">型を含むコードベースを完全にカバーすることで、データフォームがプログラマーが期待するものではないという事実によって引き起こされるエラーのクラス全体が排除されます。</font><font style="vertical-align: inherit;">スキーマファイルとprotobufファイルからタイプを生成することで、使用するテクノロジーのスタックのすべての部分において、システム全体が均質なままになります。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍Jest（単体テスト）</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードテストのフレームワークとして、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jest</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@ testing-library / react</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用します</font><font style="vertical-align: inherit;">。これらのツールを使用して作成されたテストでは、機能やコンポーネントをシステムの他の部分から切り離してテストします。通常、アプリケーションで最も頻繁に使用される関数やコンポーネント、またはコードを実行する多くの方法があるものをテストします。このようなパスは、統合またはエンドツーエンド（E2E）テスト中に検証することが困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのユニットテストは小さな部品をテストする手段です。</font><font style="vertical-align: inherit;">統合テストとエンドツーエンドテストは、システムを大規模にチェックするという優れた機能を備えているため、アプリケーションの正常性の全体的なレベルをチェックできます。</font><font style="vertical-align: inherit;">しかし、細かい部分が機能することを確認する必要がある場合があり、コードの考えられるすべての使用法について統合テストを作成するのは非常にコストがかかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、ドロップダウンリストを操作するコンポーネントでキーボードナビゲーションが機能することを確認する必要があります。</font><font style="vertical-align: inherit;">しかし、同時に、アプリケーション全体をテストするときに、そのような動作の考えられるすべてのバリアントをチェックする必要はありません。</font><font style="vertical-align: inherit;">その結果、ナビゲーションを個別に注意深くテストし、適切なコンポーネントを使用してページをテストするときは、より高レベルの対話のチェックにのみ注意を払います。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストツール</font></font></font></h2><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍サイプレス（統合テスト）</font></font></font></h3><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイプレス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を使用して作成された統合テスト</font><font style="vertical-align: inherit;">は、当社のテストシステムの中核です。</font><font style="vertical-align: inherit;">StackPathポータルの作成を開始したとき、これらは最初に作成したテストでした。これは、それらを作成するためのオーバーヘッドがほとんどなく、非常に価値があるためです。</font><font style="vertical-align: inherit;">サイプレスはアプリケーション全体をブラウザに表示し、テストスクリプトを実行します。</font><font style="vertical-align: inherit;">フロントエンド全体は、ユーザーがフロントエンドを操作するときとまったく同じように機能します。</font><font style="vertical-align: inherit;">確かに、システムのネットワーク層はmokamiに置き換えられています。</font><font style="vertical-align: inherit;">通常、GraphQLサーバーに到達する各ネットワーククエリは、条件付きデータをアプリケーションに返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モックを使用してアプリケーションのネットワーク層をシミュレートすることには、多くの長所があります。</font></font><br>
<br>
<ul>
<li>  .       , ,      ,       ,   - .        ,   .</li>
<li>   .           ,            ,   .          ,   .</li>
<li>  ,     . ,       ,       .         ,       .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンド全体をmokで置き換えることは困難な作業のようですが、すべての条件付きデータは、アプリケーションで使用されるものと同じ生成されたTypeScriptタイプを使用して入力されます。つまり、このデータは、少なくとも構造上、通常のバックエンドが返すものと同等であることが保証されています。ほとんどのテスト中、実際のサーバー呼び出しの代わりにムックを使用することのマイナス面にかなり落ち着きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、プログラマーはサイプレスで作業できることを非常に嬉しく思います。サイプレステストランナーでテストが実行されます。テストの説明が左側に表示され、テストアプリケーションがメイン要素で実行されます</font></font><code>iframe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。テストを開始したら、その個々の段階を調べて、アプリケーションの動作を確認できます。テストを実行するためのツール自体がブラウザーで機能するため、開発者のブラウザーツールを使用してテストをデバッグできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロントエンドテストを作成する場合、テストの内容とテストの特定の時点でのDOMの状態を比較するのに長い時間がかかることがよくあります。開発者はテスト中のアプリケーションで発生するすべてのことを確認できるため、サイプレスはこのタスクを大幅に簡略化します。</font><font style="vertical-align: inherit;">これを示すビデオクリップを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのテストは、テストの原則を完全に示しています。</font><font style="vertical-align: inherit;">彼らの「価格」に対する彼らの価値の比率は私たちに合っています。</font><font style="vertical-align: inherit;">テストも同様に、アプリケーションを操作する実際のユーザーのアクションを再現します。</font><font style="vertical-align: inherit;">そして、プロジェクトのネットワーク層だけがmokamiに置き換えられました。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍サイプレス（エンドツーエンドのテスト）</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E2Eテストもサイプレスを使用して記述されていますが、プロジェクトのネットワークレベルのシミュレーションやその他のシミュレーションにはmokiを使用していません。</font><font style="vertical-align: inherit;">テストを実行すると、アプリケーションは実際のGraphQLサーバーにアクセスします。このサーバーは、バックエンドサービスの実際のインスタンスで動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンドツーエンドのテストは私たちにとって非常に価値があります。実際には、このようなテストの結果によって、何かが期待どおりに機能するか機能しないかがわかります。このようなテストではモックは使用されないため、アプリケーションは実際のクライアントが使用する場合とまったく同じように動作します。ただし、エンドツーエンドのテストは他のテストよりも「費用がかかる」ことに注意してください。それらは、実装中に短期的な障害が発生する可能性があるため、遅くなり、書くのが難しくなります。テストを実行する前に、システムを既知の状態に保つために、さらに作業が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストは通常​​、システムが既知の状態にあるときに実行する必要があります。テストが完了すると、システムは別の既知の状態に切り替わります。統合テストの場合、APIへの呼び出しがmokasに置き換えられ、その結果、各テストの実行は、プログラマーによって制御されている既知の条件で行われるため、システムのこの動作を実現することは難しくありません。ただし、E2Eテストの場合は、サーバーデータウェアハウスにテスト中に変更される可能性のある情報が含まれているため、これを行うのは既に困難です。その結果、開発者は、テストが開始したときにシステムが以前に既知の状態になっていることを確認する方法を見つける必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンドツーエンドのテスト実行の最初に、APIを直接呼び出すことにより、スタック、サイト、ワークロード、モニターなどを含む新しいアカウントを作成するスクリプトを実行します。各テストセッションは、そのようなアカウントの新しいインスタンスの使用を意味しますが、それ以外は時々変更されません。スクリプトは、必要なすべてのことを行った後、テストの実行に使用されるデータを含むファイルを形成します（通常、インスタンスの識別子とドメインに関する情報が含まれています）。その結果、スクリプトを使用すると、テストを実行する前にシステムを既知の状態にすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンドツーエンドのテストは他のタイプのテストよりも「費用がかかる」ため、統合テストと比較して、作成するエンドツーエンドのテストは少なくなります。</font><font style="vertical-align: inherit;">私たちは、テストが重要なアプリケーション機能をカバーするように努めています。</font><font style="vertical-align: inherit;">たとえば、これはユーザーとそのログインの登録、サイト/ワークロードの作成と設定などです。</font><font style="vertical-align: inherit;">広範な統合テストのおかげで、通常、フロントエンドは機能していることがわかります。</font><font style="vertical-align: inherit;">ただし、エンドツーエンドのテストは、フロントエンドをバックエンドに接続するときに、他のテストでは検出できない何かが発生しないことを確認するためにのみ必要です。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包括的なテスト戦略の短所</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストとアプリケーションの安定性には非常に満足していますが、私たちのような包括的なテスト戦略を使用することには不利な点もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、そのようなテスト戦略の適用は、すべてのチームメンバーが1つのツールだけでなく、多くのテストツールに精通している必要があることを意味します。誰もがJest、@ Testing-library / react、Cypressを知る必要があります。しかし同時に、開発者はこれらのツールを知る必要があるだけではありません。また、どの状況でどの状況を使用するかを決定できる必要もあります。エンドツーエンドテストを作成する新しい機会をテストする価値はありますか、それとも統合テストで十分ですか？エンドツーエンドまたは統合テストに加えて、この新機能の実装の細部を検証する単体テストを作成する必要がありますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
疑いなく、これは、いわば、私たちのプログラマーに「負担をかける」一方で、彼らがそのような負荷を経験しないであろう唯一のツールを使用しています。通常、最初に統合テストを行い、その後、調査中の機能が特に重要であり、プロジェクトのサーバー部分に強く依存していることがわかった場合は、適切なエンドツーエンドテストを追加します。または、単体テストから開始します。これは、単体テストで特定のメカニズムを実装する際のすべての機微を検証できないと思われる場合に行います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、どこから始めればよいかわからない状況に直面しています。しかし、テストに関して常に決断を下す必要があるため、一般的な状況の特定のパターンが現れ始めます。たとえば、通常はユニットテストを使用してフォーム検証システムをテストします。これは、テスト中にさまざまなシナリオを確認する必要があるためです。同時に、チームの全員がこれを知っており、フォーム検証システムをテストする必要があるときにテスト戦略の計画に時間を費やすことはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが使用するアプローチのもう1つの欠点は、テストによるコードカバレッジに関するデータの収集が複雑なことです。</font><font style="vertical-align: inherit;">これは可能ですが、プロジェクトのテストに使用される状況よりもはるかに複雑です。</font><font style="vertical-align: inherit;">テストによるコードカバレッジの美しい数の追求は、テストの品質の低下につながる可能性がありますが、そのような情報は、使用されたテストスイートで「穴」を見つけるという点で貴重です。</font><font style="vertical-align: inherit;">複数のテストツールを使用する際の問題は、コードのどの部分がテストされていないかを理解するために、コードカバレッジに関するレポートを、さまざまなシステムから受け取ったテストと組み合わせる必要があることです。</font><font style="vertical-align: inherit;">可能ですが、テストのために1つの方法で生成されたレポートを読むよりもはるかに困難です。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのテストツールを使用する場合、困難な作業に直面しました。しかし、これらのツールはそれぞれ独自の目的を果たします。最終的には、コードテストシステムにそれらを含めることで、正しいことを行ったと信じています。統合テスト-これは、新しいアプリケーションでの作業の最初に、または既存のプロジェクトのテストを装備するときに、テストシステムの作成を開始するのに最適な場所です。エンドツーエンドのテストをプロジェクトにできるだけ早く追加して、プロジェクトの最も重要な機能を確認することは有用です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストスイートにエンドツーエンドの統合テストがある場合、これにより、開発者はアプリケーションに変更が加えられたときに、アプリケーションの正常性についてある程度の信頼を得ることができます。プロジェクトの作業中にテストで検出されなかったエラーが表示され始めた場合、どのテストがこれらのエラーを検出できるか、およびエラーの発生がプロジェクトで使用されているテストシステム全体の欠陥を示しているかどうかを検討する価値があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、現在のテストシステムはすぐには利用できませんでした。さらに、プロジェクトが成長するにつれて、このシステムが発展することを期待しています。しかし今、私たちはテストへのアプローチが本当に好きです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読者の皆様！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロントエンドテストでは、どのような戦略を採用していますか？</font><font style="vertical-align: inherit;">どのフロントエンドテストツールを使用していますか？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></div></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja477266/index.html">先週のフロントエンドの世界からの新鮮な食材のダイジェストNo. 390（2019年11月18-24日）</a></li>
<li><a href="../ja477268/index.html">GitHubでの検索ソリューションの最適化</a></li>
<li><a href="../ja477272/index.html">AssemblyScriptの最初の紹介</a></li>
<li><a href="../ja477274/index.html">未使用のCSSコードをどのようにして取り除くのですか？パート1</a></li>
<li><a href="../ja477276/index.html">未使用のCSSコードをどのようにして取り除くのですか？パート2</a></li>
<li><a href="../ja477282/index.html">Goプロジェクトコードのプロファイリングとメモリ割り当ての問題の解決</a></li>
<li><a href="../ja477284/index.html">JavaScriptが厳密モードを必要とするのはなぜですか？</a></li>
<li><a href="../ja477286/index.html">AxiosまたはFetch：2019で何を使用するか？</a></li>
<li><a href="../ja477288/index.html">2018年の元に戻す老化会議でジョン・ルイス</a></li>
<li><a href="../ja477290/index.html">11月25日から12月1日までのモスクワでのデジタルイベント</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>