<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🔬 🧙🏾 👃🏻 测量膝盖上的内存带宽 📀 👨‍💻 🤸🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="几周前，在一次晚餐聚餐中，一位同事抱怨过程缓慢。他计算了生成的字节数，处理周期数以及最终的RAM量。一位同事说，内存带宽超过500 GB / s的现代GPU会耗尽其工作量，不会阻塞。
 
 在我看来，这是一种有趣的方法。我个人以前从未从这个角度评估过绩效目标。是的，我知道处理器和内存性能的差异。
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>测量膝盖上的内存带宽</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487898/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几周前，在一次晚餐聚餐中，一位同事抱怨过程缓慢。他计算了生成的字节数，处理周期数以及最终的RAM量。一位同事说，内存带宽超过500 GB / s的现代GPU会耗尽其工作量，不会阻塞。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我看来，这是一种有趣的方法。我个人以前从未从这个角度评估过绩效目标。是的，我知道处理器和内存性能的差异。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2de/d86/182/2ded861823d832e2e382d1e97e0ec147.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我知道如何编写大量使用缓存的代码。我知道大概的延迟数字。但这不足以立即评估内存带宽。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个思想实验。</font><font style="vertical-align: inherit;">想象一下内存中十亿个32位整数的连续数组。</font><font style="vertical-align: inherit;">这是4 GB。</font><font style="vertical-align: inherit;">遍历此数组并加总值需要多长时间？</font><font style="vertical-align: inherit;">CPU每秒可以从RAM读取多少字节？</font><font style="vertical-align: inherit;">连续数据？</font><font style="vertical-align: inherit;">随机访问？</font><font style="vertical-align: inherit;">这个过程可以并行化的程度如何？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您会说这些都是无用的问题。</font><font style="vertical-align: inherit;">真正的程序太复杂了，以至于无法成为如此幼稚的里程碑。</font><font style="vertical-align: inherit;">还有！</font><font style="vertical-align: inherit;">真正的答案是“取决于情况”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，我认为这个问题值得探讨。</font><font style="vertical-align: inherit;">我不是在寻找</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">答案</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是我认为我们可以定义一些上下边界，在中间定义一些有趣的点，并在此过程中学到一些东西。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个程序员都应该知道的数字</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您阅读编程博客，则可能会遇到“每个程序员都应该知道的数字”。</font><font style="vertical-align: inherit;">他们看起来像这样：</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接到L1缓存0.5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
错误的5 ns预测</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
链接到L2缓存7 ns 14x到L1缓存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mutex捕获/释放25 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
链接到主存储器100 ns 20x到L2高速缓存，200x到L1高速缓存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用Zippy 3000 ns 3μs压缩1000字节</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过1 Gbps网络发送1000字节10,000 ns 10μs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
带有SSD的随机读取4000 150,000 ns 150μs〜1GB / s SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从250,000 ns 250μs顺序读取1 MB</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据中心内部的往返数据包500,000 ns 500μs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 MB顺序读取SSD 1,000,000 ns 1,000μs1 ms〜1 GB / s SSD，4x内存</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
磁盘搜索10,000,000 ns 10,000μs10 ms 20x到数据中心</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从磁盘20,000,000 ns 20,000μs20 ms顺序读取1 MB 80x到内存，20x到SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
打包发送CA-&gt;荷兰-&gt; CA 150,000,000 ns 150,000μs150 ms</font></font></pre> <br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乔纳斯鲍纳</font></font></a></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
大名单。</font><font style="vertical-align: inherit;">他每年至少一次出现在HackerNews上。</font><font style="vertical-align: inherit;">每个程序员都应该知道这些数字。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是这些数字是关于其他的东西。</font><font style="vertical-align: inherit;">延迟和带宽不是一回事。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推迟到2020年</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该清单于2012年编制，而2020年的这篇文章已经改变了。</font><font style="vertical-align: inherit;">这是带有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StackOverflow的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intel i7的编号</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命中L1缓存，大约4个周期（2.1-1.2 ns）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命中L2缓存，大约10个周期（5.3-3.0 ns）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命中L3缓存，单核〜40个周期（21.4-12.0 ns）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命中L3高速缓存，一起使用另一个内核〜65个周期（34.8-19.5 ns）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命中L3高速缓存，并换另一个内核〜75个周期（40.2-22.5 ns）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本地RAM〜60 ns</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有趣！</font><font style="vertical-align: inherit;">发生了什么变化？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1变慢； </font></font><code>0,5 → 1,5 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L2更快； </font></font><code>7 → 4,2 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1和L2的比率大大降低；</font></font><code>2,5x  14</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（哇！）</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L3缓存现已成为标准配置； </font></font><code> 12  40 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM变得更快； </font></font><code>100 → 60 </code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们不会得出深远的结论。</font><font style="vertical-align: inherit;">尚不清楚原始数字是如何计算的。</font><font style="vertical-align: inherit;">我们不会将苹果与橙子进行比较。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是来自</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wikichip的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一些</font><font style="vertical-align: inherit;">有关我的处理器的带宽和缓存大小的数字。</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存带宽：每秒39.74 GB</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L1高速缓存：192 KB（每个内核32 KB）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L2缓存：1.5兆字节（每个内核256 KB）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L3高速缓存：12 MB（共享；每个内核2 MB）</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想知道的是：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM性能上限</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下限</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 / L2 / L3缓存限制</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">天真的基准测试</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们做一些测试。</font><font style="vertical-align: inherit;">为了测量带宽，我编写了一个简单的C ++程序。</font><font style="vertical-align: inherit;">她看起来很像这样。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Generate random elements</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; ++i) <span class="hljs-comment">// one billion ints</span>
    nums.push_back(rng() % <span class="hljs-number">1024</span>); <span class="hljs-comment">// small nums to prevent overflow</span><font></font>
<font></font>
<span class="hljs-comment">// Run test with 1 to 12 threads</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> thread_count = <span class="hljs-number">1</span>; thread_count &lt;= MAX_THREADS; ++thread_count) {
    <span class="hljs-keyword">auto</span> slice_len = nums.size() / thread_count;<font></font>
    <font></font>
    <span class="hljs-comment">// for-each thread</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> thread = <span class="hljs-number">0</span>; thread &lt; thread_count; ++thread) {<font></font>
        <font></font>
        <span class="hljs-comment">// partition data</span>
        <span class="hljs-keyword">auto</span> begin = nums.begin() + thread * slice_len;
        <span class="hljs-keyword">auto</span> end = (thread == thread_count - <span class="hljs-number">1</span>)<font></font>
            ? nums.end() : begin + slice_len;<font></font>
<font></font>
        <span class="hljs-comment">// spawn threads</span>
        futures.push_back(<span class="hljs-built_in">std</span>::async([begin, end] { <font></font>
            <font></font>
            <span class="hljs-comment">// sum ints sequentially</span>
            <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = begin; ptr &lt; end; ++ptr)<font></font>
                sum += *ptr;<font></font>
            <span class="hljs-keyword">return</span> sum;<font></font>
        }));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// combine results</span>
    <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; <span class="hljs-built_in">future</span> : futures)<font></font>
        sum += <span class="hljs-built_in">future</span>.get();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一些细节被省略。但是你明白这个主意。创建一个大的，连续的元素数组。将数组分成单独的片段。在单独的线程中处理每个片段。累积结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您还需要测量随机访问。这非常困难。我尝试了几种方法，最终决定混合使用预先计算的索引。每个索引仅存在一次。然后，内部循环遍历索引并进行计算</font></font><code>sum += nums[index]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt; indices = <span class="hljs-comment">/* shuffled */</span>;<font></font>
<font></font>
<span class="hljs-comment">// random access</span>
<span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = indices.begin(); ptr &lt; indices.end(); ++ptr) {
    <span class="hljs-keyword">auto</span> idx = *ptr;<font></font>
    sum += nums[idx];<font></font>
}<font></font>
<span class="hljs-keyword">return</span> sum;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在计算吞吐量时，我</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑索引数组的内存。</font><font style="vertical-align: inherit;">只计入有助于总数的字节</font></font><code>sum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我不对硬件进行基准测试，而是评估使用不同大小和不同访问方案的数据集的能力。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将使用以下三种数据类型进行测试：</font></font><br>
<br>
<code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-主32位整数</font></font><br>
<code>matri4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-包含</font></font><code>int[16]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">；</font><font style="vertical-align: inherit;">适合64字节的缓存行</font></font><br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-使用内置工具</font></font><code>__m256i</code><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大块</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我的第一个测试使用了很大的内存。 1 GB的</font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目</font><font style="vertical-align: inherit;">块将</font><font style="vertical-align: inherit;">突出显示并填充较小的随机值。一个简单的循环遍历数组N次，因此它以一定的容量访问内存</font></font><code>N </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以计算总和</font></font><code>int64_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。几个线程拆分了数组，每个线程都可以访问相同数量的元素。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d36/45d/2d1/d3645d2d119e28f1306945258d1b422b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
塔达！在此图中，我们将求和运算的平均执行时间取</font></font><code>runtime_in_nanoseconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><code>gigabytes_per_second</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
相当不错的结果。</font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以在单个流中顺序读取11 GB / s。它线性扩展，直到达到38 GB / s。测试</font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快，但其余针对同一天花板。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们每秒可以从RAM读取多少数据有一个明确而明显的上限。</font><font style="vertical-align: inherit;">在我的系统上，这大约为40 GB / s。</font><font style="vertical-align: inherit;">这符合上面列出的当前规格。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从底部的三个图表来看，随机访问速度很慢。</font><font style="vertical-align: inherit;">非常非常慢 </font><font style="vertical-align: inherit;">单线程性能</font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是可以忽略的0.46 GB / s。</font><font style="vertical-align: inherit;">这比11.03 GB / s的顺序堆叠慢24倍！</font><font style="vertical-align: inherit;">该测试</font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示最佳结果，因为它在完整的缓存行上运行。</font><font style="vertical-align: inherit;">但是它仍然比顺序访问慢四到七倍，并且峰值仅为8 GB / s。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小块：顺序读取</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我的系统上，每个流的L1 / L2 / L3高速缓存大小分别为32 KB，256 KB和2 MB。如果您将一个32 KB的元素块迭代125,000次，会发生什么？这是4 GB的内存，但是我们将始终进入缓存。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2bd/662/3dd/2bd6623dd63d0eae81548f4b5e6d4599.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
太棒了！单线程性能类似于读取大块，大约12 GB / s。除了这次，多线程突破了40 GB / s的上限。这说得通。数据保留在缓存中，因此不会出现RAM瓶颈。对于不适合L3缓存的数据，则适用大约38 GB / s的上限。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
测试</font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示出与电路相似的结果，但速度更快。单线程模式下为31 GB / s，多线程下为171 GB / s。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/929/9ab/ceb/9299abceb2e779406f598b76c00beba5.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在让我们看一下</font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。注意y轴。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f96/7b2/9c6/f967b29c6f839f0536667b9918fabd70.png"><br>
<br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行异常快。</font><font style="vertical-align: inherit;">比快10倍</font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在16 KB的块上，它甚至可以突破1000 GB / s！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
显然，这是表面合成测试。</font><font style="vertical-align: inherit;">大多数应用程序不会连续百万次对相同数据执行相同操作。</font><font style="vertical-align: inherit;">该测试未显示真实世界中的性能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，教训很明确。</font><font style="vertical-align: inherit;">在缓存内部，可以</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快速</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理数据</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用SIMD时具有很高的上限：单线程模式下超过100 GB / s，多线程下超过1000 GB / s。</font><font style="vertical-align: inherit;">将数据写入高速缓存速度很慢，并且硬限制约为40 GB / s。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小块：随机读取</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们做同样的事情，但是现在有了随机访问权限。</font><font style="vertical-align: inherit;">这是我最喜欢的文章。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/983/854/ef8/983854ef856e17e37493e9c8b928d318.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从RAM读取随机值很慢，只有0.46 GB / s。</font><font style="vertical-align: inherit;">从L1缓存读取随机值非常快：13 GB / s。</font><font style="vertical-align: inherit;">这比</font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从RAM </font><font style="vertical-align: inherit;">读取串行数据</font><font style="vertical-align: inherit;">（11 GB / s）</font><font style="vertical-align: inherit;">更快</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/59a/7bf/b72/59a7bfb728445b69a7947523ab9b0900.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
测试</font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示相同模板的结果相似，但速度约为的两倍</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d99/bc2/f70/d99bc2f70c2f7bda177f70ec166bd74a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
随机访问</font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常快。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随机访问结果</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从内存中进行免费读取很慢。</font><font style="vertical-align: inherit;">灾难性的缓慢。</font><font style="vertical-align: inherit;">两个测试用例均小于1 GB / s </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">同时，从缓存中随机读取的速度惊人地快。</font><font style="vertical-align: inherit;">这相当于</font><font style="vertical-align: inherit;">从RAM </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺序</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">读取。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dde/0a4/52b/dde0a452b8f293758c2efe1760115306.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它需要被消化。</font><font style="vertical-align: inherit;">随机访问高速缓存的速度与顺序访问RAM的速度相当。</font><font style="vertical-align: inherit;">从L1 16 KB到L2 256 KB的下降只有一半或更少。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为这将产生深远的影响。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接列表被认为是有害的</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追逐指针（跳指针）是不好的。</font><font style="vertical-align: inherit;">非常非常糟糕。</font><font style="vertical-align: inherit;">性能降低了多少？</font><font style="vertical-align: inherit;">你自己看。</font><font style="vertical-align: inherit;">我做了一个额外的测试，将其封装</font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了</font></font><code>std::unique_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">每次访问都通过一个指针。</font><font style="vertical-align: inherit;">这是一个可怕的灾难性后果。</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">     1个线程| </font><font style="vertical-align: inherit;">矩阵4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">差异|</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大块-Seq | </font><font style="vertical-align: inherit;">14.8 GB /秒| </font><font style="vertical-align: inherit;">0.8 GB /秒| </font><font style="vertical-align: inherit;">19倍|</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB-序列| </font><font style="vertical-align: inherit;">31.6 GB /秒| </font><font style="vertical-align: inherit;">2.2 GB /秒| </font><font style="vertical-align: inherit;">14倍|</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB-序列| </font><font style="vertical-align: inherit;">22.2 GB /秒| </font><font style="vertical-align: inherit;">1.9 GB /秒| </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大块-兰德| </font><font style="vertical-align: inherit;">2.2 GB /秒| </font><font style="vertical-align: inherit;">0.1 GB /秒| </font><font style="vertical-align: inherit;">22x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB-兰德| </font><font style="vertical-align: inherit;">23.2 GB /秒| </font><font style="vertical-align: inherit;">1.7 GB /秒| </font><font style="vertical-align: inherit;">14倍|</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB-兰德| </font><font style="vertical-align: inherit;">15.2 GB /秒| </font><font style="vertical-align: inherit;">0.8 GB /秒| </font><font style="vertical-align: inherit;">19倍|</font></font><font></font>
<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
     6个线程| </font><font style="vertical-align: inherit;">矩阵4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">差异|</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大块-Seq | </font><font style="vertical-align: inherit;">34.4 GB /秒| </font><font style="vertical-align: inherit;">2.5 GB /秒| </font><font style="vertical-align: inherit;">14倍|</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB-序列| </font><font style="vertical-align: inherit;">154.8 GB /秒| </font><font style="vertical-align: inherit;">8.0 GB /秒| </font><font style="vertical-align: inherit;">19倍|</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB-序列| </font><font style="vertical-align: inherit;">111.6 GB /秒| </font><font style="vertical-align: inherit;">5.7 GB /秒| </font><font style="vertical-align: inherit;">20倍|</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大块-兰德| </font><font style="vertical-align: inherit;">7.1 GB /秒| </font><font style="vertical-align: inherit;">0.4 GB /秒| </font><font style="vertical-align: inherit;">18x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB-兰德| </font><font style="vertical-align: inherit;">95.0 GB /秒| </font><font style="vertical-align: inherit;">7.8 GB /秒| </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB-兰德| </font><font style="vertical-align: inherit;">58.3 GB /秒| </font><font style="vertical-align: inherit;">1.6 GB /秒| </font><font style="vertical-align: inherit;">36倍|</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指针后面的值的顺序求和以小于1 GB / s的速度执行。</font><font style="vertical-align: inherit;">缓存的两次跳过的随机访问速度仅为0.1 GB / s。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追逐指针会使代码执行速度降低10-20倍。</font><font style="vertical-align: inherit;">不要让您的朋友使用链接列表。</font><font style="vertical-align: inherit;">请考虑一下缓存。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">框架预算估算</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
游戏开发人员通常会为CPU的负载和内存量设置一个限制（预算）。但是我从未见过带宽预算。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在现代游戏中，FPS持续增长。现在是60 FPS。 VR以90 Hz的频率运行。我有一台144 Hz游戏显示器。太棒了，所以60 FPS似乎很烂。我将永远不会回到旧的显示器。电竞和彩带Twitch监控240 Hz。今年，华硕在CES上推出了一款360 Hz的怪物。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我的处理器的上限大约为40 GB / s。这似乎是一个很大的数目！但是，在240 Hz的频率下，每帧仅获得167 MB。实际的应用程序可以以144 Hz的频率生成5 GB / s的流量，每帧只有69 MB。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个有几个数字的表。</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        | </font><font style="vertical-align: inherit;">1 | </font><font style="vertical-align: inherit;">10 | </font><font style="vertical-align: inherit;">30 | </font><font style="vertical-align: inherit;">60 | </font><font style="vertical-align: inherit;">90 | </font><font style="vertical-align: inherit;">144 | </font><font style="vertical-align: inherit;">240 | </font><font style="vertical-align: inherit;">360 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------- | ------- | -------- | -------- | -------- | ------ -| -------- | -------- | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
40 GB /秒| </font><font style="vertical-align: inherit;">40 GB | </font><font style="vertical-align: inherit;">4 GB | </font><font style="vertical-align: inherit;">1.3 GB | </font><font style="vertical-align: inherit;">667 MB | </font><font style="vertical-align: inherit;">444 MB | </font><font style="vertical-align: inherit;">278 MB | </font><font style="vertical-align: inherit;">167 MB | </font><font style="vertical-align: inherit;">111 MB |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 GB /秒| </font><font style="vertical-align: inherit;">10 GB | </font><font style="vertical-align: inherit;">1 GB | </font><font style="vertical-align: inherit;">333 MB | </font><font style="vertical-align: inherit;">166 MB | </font><font style="vertical-align: inherit;">111 MB | </font><font style="vertical-align: inherit;">69 MB | </font><font style="vertical-align: inherit;">42 MB | </font><font style="vertical-align: inherit;">28 MB |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 1 GB /秒| </font><font style="vertical-align: inherit;">1 GB | </font><font style="vertical-align: inherit;">100 MB | </font><font style="vertical-align: inherit;">33 MB | </font><font style="vertical-align: inherit;">17 MB | </font><font style="vertical-align: inherit;">11 MB | </font><font style="vertical-align: inherit;">7 MB | </font><font style="vertical-align: inherit;">4 MB | </font><font style="vertical-align: inherit;">3 MB |</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我看来，从这个角度评估问题很有用。</font><font style="vertical-align: inherit;">这清楚表明某些想法是不可行的。</font><font style="vertical-align: inherit;">达到240 Hz并不容易。</font><font style="vertical-align: inherit;">这本身不会发生。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个程序员都应该知道的数字（2020）</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先前的列表已过期。</font><font style="vertical-align: inherit;">现在需要对其进行更新，并在2020年之前实现合规性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是我家用电脑的一些号码。</font><font style="vertical-align: inherit;">这是AIDA64，Sandra和我的基准测试的混合。</font><font style="vertical-align: inherit;">这些图并没有提供完整的图片，仅是一个起点。</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">延迟L1：1 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L2延迟：2.5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
延迟L3：10 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAM延迟：50 ns</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（每个线程）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L1频段：210 GB /秒</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L2频段：80 GB /秒</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L3频段：60 GB /秒</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（整个系统）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAM带宽：45 GB /秒</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建一个小型，简单的开源基准测试会很不错。</font><font style="vertical-align: inherit;">可以在台式计算机，服务器，移动设备，控制台等上运行的一些C文件。但是我不是那种编写此类工具的人。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拒绝责任</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
测量内存带宽很困难。</font><font style="vertical-align: inherit;">非常困难。</font><font style="vertical-align: inherit;">我的代码中可能有错误。</font><font style="vertical-align: inherit;">许多无法解释的因素。</font><font style="vertical-align: inherit;">如果您对我的技术有所批评，那可能是对的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最终，我认为这很正常。</font><font style="vertical-align: inherit;">本文不是关于我的桌面的确切性能。</font><font style="vertical-align: inherit;">从某种角度来看，这是一个问题陈述。</font><font style="vertical-align: inherit;">关于如何学习如何进行一些粗略的数学计算。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一位同事与我分享了有关GPU内存带宽和应用程序性能的有趣观点。</font><font style="vertical-align: inherit;">这促使我研究现代计算机上的内存性能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了进行近似计算，以下是现代台式机的一些数字：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM性能</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大： </font></font><code>45 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平均而言： </font></font><code>5 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最低要求： </font></font><code>1 /</code></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 / L2 / L3缓存性能（每核）</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大值（c simd）：</font></font><code>210 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>80 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>60 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平均大约：</font></font><code>25 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>15 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>9 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最低：</font></font><code>13 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>8 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>3,5 /</code></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
样本评级与性能有关</font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">真实的代码永远不会如此简单。</font><font style="vertical-align: inherit;">但是对于餐巾纸的计算，这是一个合理的起点。</font><font style="vertical-align: inherit;">您需要根据程序中的内存访问模式，设备的特性和代码来调整此数字。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，最重要的是思考问题的新方法。</font><font style="vertical-align: inherit;">用每秒字节数或每帧字节数显示问题是另一个需要检查的问题。</font><font style="vertical-align: inherit;">这是一个有用的工具，以防万一。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
谢谢阅读。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源</font></font></h1><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基准C ++ </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python Graph </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data.json</font></font></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进一步的研究</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文仅涉及该主题。</font><font style="vertical-align: inherit;">我可能不会讲。</font><font style="vertical-align: inherit;">但是，如果他这样做了，那么他可以涵盖以下方面：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">录音效果</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虚假分享</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表现</font></font><code>std::atomic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（或缺乏</font><font style="vertical-align: inherit;">表现</font><font style="vertical-align: inherit;">）</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绩效柜台</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLB表现</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缓存协议</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统规格</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
测试是在我的家用PC上进行的。</font><font style="vertical-align: inherit;">仅库存设置，无超频。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作系统：Windows 10 v1903 build 18362</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理器：Intel i7-8700k @ 3.70 GHz</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存：2x16 GSkill Ripjaw DDR4-3200（16-18-18-38 @ 1600 MHz）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主板：华硕TUF Z370-Plus游戏</font></font></li>
</ul></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN487884/index.html">开发交流之前我想知道的5件事</a></li>
<li><a href="../zh-CN487888/index.html">Umbraco CMS的CSRF</a></li>
<li><a href="../zh-CN487890/index.html">使用语音框架在iOS上将语音转换为文本</a></li>
<li><a href="../zh-CN487894/index.html">BarsUP.AM：我们如何开发一种用于保护Web应用程序信息的工具</a></li>
<li><a href="../zh-CN487896/index.html">当死亡变成艺术时：用深刻的英语意思的名人墓志铭</a></li>
<li><a href="../zh-CN487900/index.html">pyqtdeploy，或者我们将python程序打包到exe'shnik中...很难</a></li>
<li><a href="../zh-CN487902/index.html">一场又一场大火：用于锂离子电池的难熔固态电解质</a></li>
<li><a href="../zh-CN487906/index.html">《计算机网络》一书。原理，技术，协议：周年纪念版»</a></li>
<li><a href="../zh-CN487908/index.html">工艺过程之战的开始：5 nm和3 nm</a></li>
<li><a href="../zh-CN487910/index.html">自然定律和优雅的数学：问题和解决方案</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>