<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚨 👨🏿‍🔧 🤸🏼 Cassandra. How not to die if you know only Oracle 👋🏽 🍹 👩‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr. 
 
 My name is Misha Butrimov, I would like to talk a little about Cassandra. My story will be useful to those who have never encountered...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Cassandra. How not to die if you know only Oracle</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qiwi/blog/486800/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My name is Misha Butrimov, I would like to talk a little about Cassandra. My story will be useful to those who have never encountered NoSQL databases - it has a lot of implementation features and pitfalls that you need to know about. And if, apart from Oracle or any other relational base, you have not seen anything, these things will save your life. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is good about Cassandra? This is a NoSQL database designed without a single point of failure, which scales well. If you need to add a couple terabytes for any base, you just add nodes to the ring. Extend it to another data center? Add nodes to the cluster. Increase processed RPS? Add nodes to the cluster. The other way also works.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/webt/4s/4m/jn/4s4mjnltsraqofl5-ey4g2fi9t0.png" width="700"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What else is she good at? </font><font style="vertical-align: inherit;">It is to handle a lot of requests. </font><font style="vertical-align: inherit;">But how much is how much? </font><font style="vertical-align: inherit;">10, 20, 30, 40 thousand requests per second - this is not much. </font><font style="vertical-align: inherit;">100 thousand requests per second for recording, too. </font><font style="vertical-align: inherit;">There are companies that said they hold 2 million requests per second. </font><font style="vertical-align: inherit;">Here they probably have to believe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And in principle, Cassandra has one big difference from relational data - it does not look like them at all. </font><font style="vertical-align: inherit;">And this is very important to remember.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not everything that looks the same works the same</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Once a colleague came to me and asked: “Here is the CQL Cassandra query language, and it has a select statement, it has where, it has and. I write letters and it doesn’t work. Why?". If you treat Cassandra as a relational database, then this is an ideal way to end your life by brutal suicide. And I do not advocate, it is prohibited in Russia. You are just designing something wrong.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, a customer comes to us and says: “Let's build a database for TV shows, or a database for a directory of recipes. We will have food dishes there or a list of series and actors in it. ” We say joyfully: "Come on!". These are two bytes to send, a couple of plates and everything is ready, everything will work very quickly, reliably. And everything is fine until the customers come and say that the housewives are also solving the inverse problem: they have a list of products and they want to know what dish they want to cook. You are dead. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's because Cassandra is a hybrid database: it is both key value and stores data in wide columns. Speaking in Java or Kotlin, it could be described like this:</font></font><br>
<br>
<code>Map&lt;RowKey, SortedMap&lt;ColumnKey, ColumnValue&gt;&gt;</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, a map, inside which there is also a sorted map. The first key to this map is the Row key or Partition key - the partition key. The second key, which is the key to the already sorted map, is the Clustering key. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To illustrate the distribution of the database, we draw three nodes. Now you need to understand how to decompose data into nodes. Because if we shove everything into one (by the way, there may be a thousand, two thousand, five - as many as you like), this is not really about distribution. Therefore, we need a mathematical function that will return a number. Just a number, a long int that will fall into some range. And we have one node will be responsible for one range, the second - for the second, n-th - for the n-th.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vl/xn/mn/vlxnmnvvigtwc_ho-wkjqy5r60e.png" width="900"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This number is taken using a hash function that applies just to what we call the Partition key. </font><font style="vertical-align: inherit;">This is the column that is specified in the Primary key directive, and this is the column that will be the first and most basic map key. </font><font style="vertical-align: inherit;">It determines which node gets which data. </font><font style="vertical-align: inherit;">A table is created in Cassandra with almost the same syntax as in SQL:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">users</span> (<font></font>
	user_id uu <span class="hljs-keyword">id</span>,
	<span class="hljs-keyword">name</span> <span class="hljs-built_in">text</span>,
	<span class="hljs-keyword">year</span> <span class="hljs-built_in">int</span>,<font></font>
	salary <span class="hljs-built_in">float</span>,<font></font>
	PRIMARY <span class="hljs-keyword">KEY</span>(user_id)<font></font>
<font></font>
)<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primary key in this case consists of one column, and it is also a partition key. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How will users fall with us? </font><font style="vertical-align: inherit;">Part will fall on one note, part on another, and part on a third. </font><font style="vertical-align: inherit;">It turns out an ordinary hash table, it’s also a map, it’s also a dictionary in Python, it’s also a simple Key value structure, from which we can read all values, read and write by key.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vp/3_/xa/vp3_xa1bupu1wawi77ytwk0pike.png" width="900"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Select: when allow filtering turns into full scan, or how not to do</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's write some statement The the select: </font></font><code>select * from users where, userid = </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It turns out, it seems, as in Oracle: we write select, we specify conditions and everything works, users get it. But if you select, for example, a user with a certain year of birth, Cassandra swears that she cannot fulfill the request. Because she does not know anything about how we distribute data on the year of birth - she has only one column specified as the key. Then she says: “Okay, I can still fulfill this request. Add allow filtering. " We add a directive, everything works. And at that moment a terrible thing happens.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When we drive on test data, everything is fine. And when you fulfill the request in production, where, for example, we have 4 million records, then everything is not very good with us. Because allow filtering is a directive that allows Cassandra to collect all the data from this table from all nodes, all data centers (if there is a lot of them in this cluster), and only then filter it. This is an analogue of Full Scan, and hardly anyone is delighted with it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we only needed users by identifiers, this would suit us. But sometimes we need to write other queries and impose other restrictions on the selection. Therefore, we recall: we all have a map, which has a partition key, but inside it is a sorted map.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And she also has a key, which we call the Clustering Key. This key, which, in turn, consists of the columns that we select, with which Cassandra understands how her data is physically sorted and will lie on each node. That is, for some Partition key, the Clustering key will tell you exactly how to push the data into this tree, what place they will take there. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is really a tree, a comparator is simply called there, into which we pass a certain set of columns in the form of an object, and it is also set in the form of a column listing.</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> users_by_year_salary_id (<font></font>
	user_id <span class="hljs-keyword">uuid</span>,
	<span class="hljs-keyword">name</span> <span class="hljs-built_in">text</span>,
	<span class="hljs-keyword">year</span> <span class="hljs-built_in">int</span>,<font></font>
	salary <span class="hljs-built_in">float</span>,<font></font>
	PRIMARY <span class="hljs-keyword">KEY</span>((<span class="hljs-keyword">year</span>), salary, user_id)
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pay attention to the Primary key directive, it has the first argument (in our case the year) is always the Partition key. </font><font style="vertical-align: inherit;">It can consist of one or several columns, it does not matter. </font><font style="vertical-align: inherit;">If there are several columns, you need to remove it again in parentheses so that the language preprocessor understands that this is the Primary key, and behind it all the other columns - the Clustering key. </font><font style="vertical-align: inherit;">In this case, they will be transmitted in the comparator in the order in which they go. </font><font style="vertical-align: inherit;">That is, the first column is more significant, the second is less significant and so on. </font><font style="vertical-align: inherit;">As we write for data classes, for example, equals fields: we list fields, and for them we write which ones are larger and which are smaller. </font><font style="vertical-align: inherit;">In Cassandra, this is, relatively speaking, the data class field to which the equals written for it will be applied.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We set the sort, impose restrictions</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It must be remembered that the sort order (decreasing, increasing, it doesn’t matter) is set at the same time that the key is created, and then you cannot change it later. It physically determines how the data will be sorted and how it will lie. If you need to change the Clustering key or the sort order, you will have to create a new table and pour data into it. With the existing one this will not work. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kg/qh/qt/kgqhqtjece2c4irbhyll0mxsl10.png" width="900"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We filled our table with users and saw that they went into a ring, first by year of birth, and then inside on each node by salary and by user ID. Now we can select, imposing restrictions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our working appears again</font></font><code>where, and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and users get to us, and everything is fine again. </font><font style="vertical-align: inherit;">But if we try to use only the Clustering key part, the less significant one, then Cassandra will swear right away that we can’t find in our map where this object has these fields for the comparator null, but this one that was just set - where it lies. </font><font style="vertical-align: inherit;">I will have to pick up all the data from this node again and filter it. </font><font style="vertical-align: inherit;">And this is an analogue of Full Scan within the node, this is bad.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In any incomprehensible situation, create a new table</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we want to be able to get users by ID or by age or by salary, what should we do? Nothing. Just use two tables. If you need to get users in three different ways - there will be three tables. Gone are the days when we saved space on the screw. This is the cheapest resource. It costs much less than response time, which can be fatal to the user. The user is much nicer to get something in a second than in 10 minutes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We exchange excessive space, denormalized data for the ability to scale well, work reliably. Indeed, in reality, a cluster that consists of three data centers, each of which has five nodes, with an acceptable level of data storage (when nothing is lost for sure), is able to survive the death of one data center completely. And two more nodes in each of the two remaining. And only after that the problems begin. This is a pretty good redundancy, it costs a couple of unnecessary ssd-drives and processors. Therefore, in order to use Cassandra, which is never SQL, in which there are no relationships, no foreign keys, you need to know simple rules.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We design everything from a request. The main thing is not the data, but how the application is going to work with them. If he needs to receive different data in different ways or the same data in different ways, we must put them in the way that will be convenient for the application. Otherwise, we will fail in Full Scan and Cassandra will not give us any advantage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denormalizing data is the norm. Forget about normal forms, we no longer have relational databases. We put something 100 times, it will lie 100 times. It’s cheaper than stopping it anyway.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We select the keys for partitioning so that they are normally distributed. </font><font style="vertical-align: inherit;">We do not need the hash from our keys to fall into one narrow range. </font><font style="vertical-align: inherit;">That is, the year of birth in the example above is a bad example. </font><font style="vertical-align: inherit;">Rather, it is good if our users are normally distributed by year of birth, and bad if we are talking about students of the 5th grade - it will not be very good to partition there. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sorting is selected once during the creation of the Clustering Key. </font><font style="vertical-align: inherit;">If you need to change it, you will have to overfill our table with a different key. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the most important: if we need to collect the same data in 100 different ways, then we will have 100 different tables.</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en486788/index.html">Webinar “Remote monitoring and equipment diagnostics. Winnum CNC Solution Case Studies »</a></li>
<li><a href="../en486790/index.html">And again Qbot - a new strain of banking Trojan</a></li>
<li><a href="../en486792/index.html">The robot’s path to the icy satellite of another planet begins in the depths of the Antarctic</a></li>
<li><a href="../en486794/index.html">The processes of human neurons showed unexpected ability to calculate</a></li>
<li><a href="../en486798/index.html">Is there a GameDev in Sakhalin? End</a></li>
<li><a href="../en486802/index.html">People meet recommender systems. Factorization</a></li>
<li><a href="../en486804/index.html">Global Health Informatics: Cloud Technologies</a></li>
<li><a href="../en486808/index.html">Electronic pregnancy test from a pharmacy: how it works</a></li>
<li><a href="../en486810/index.html">New Odnoklassniki frontend: launching React in Java. Part II</a></li>
<li><a href="../en486814/index.html">Zabbix: network topology is clear and automatic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>