<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏻 ♠️ 🤞🏿 顺利排序 🌙 📴 🍸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们继续沉浸在各种各样的事物中。
 
 今天，我们将分析一种优雅的排序方法，该方法使用基于Leonardo数的特殊堆。
 
 许多人都听说过这种排序，但是很少有人确切地知道它是如何工作的。今天，我们将看到其中没有什么复杂的内容。 该方法由传奇的Edsger Dijkstra发明。除了算法理论上最杰出...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>顺利排序</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/496852/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img align="left" width="350" height="350" src="https://habrastorage.org/webt/rn/rl/bg/rnrlbgzncwdiackzlubtakt02u0.jpeg"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们继续沉浸在各种各样的事物中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今天，我们将分析一种优雅的排序方法，该方法使用基于Leonardo数的特殊堆。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
许多人都听说过这种排序，但是很少有人确切地知道它是如何工作的。今天，我们将看到其中没有什么复杂的内容。</font><font style="vertical-align: inherit;">
该方法由传奇的Edsger Dijkstra发明。除了算法理论上最杰出的成就外，他还是这样机智的声明的作者：</font><i><font style="vertical-align: inherit;">“以前学习过Basic的学生，几乎不可能教好编程。作为潜在的程序员，他们经历了不可逆转的智力退化。”</font></i><font style="vertical-align: inherit;"> 
我希望不要轻信文章中的动画是使用VBA创建的:-)</font></font><br>
<br>
<img width="750" height="1" src="https://habrastorage.org/webt/63/4u/g_/634ug_fmfdzyhgeg6ta-ddcdpau.gif"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img align="right" width="195" height="280" src="https://habrastorage.org/webt/fq/vt/v1/fqvtv1xelqwwshwtuxa3frztsle.jpeg"></a><br clear="left"><font style="vertical-align: inherit;"></font><br>
<br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="EDISON软件-网络开发"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON软件-网络开发"></a><br clear="right">
     EDISON.<br>
<br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    </a>,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   Android  iOS</a>.<br>
<br>
    ! ;-)</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
堆排序本身非常好，因为</font><font style="vertical-align: inherit;">无论数据如何，</font><font style="vertical-align: inherit;">堆时间复杂度均为</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。为了不表示数组，堆排序的复杂性永远不会降低到</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></b><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这可能发生在例如快速排序中。硬币的另一面是不能加快二进制堆的排序，</font><font style="vertical-align: inherit;">也不能期望</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）的</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复杂性</font><font style="vertical-align: inherit;">（但是在某些条件下相同的快速排序可以实现此类指标）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总的来说，议程上存在一个问题：是否可以进行设计，以便一方面使按堆排序的时间复杂度不低于</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是在有利的情况下（特别是如果处理了几乎排序的数组）增加到</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Edsger Dijkstra亲自亲自解决了这个问题，他发现是的，有可能。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假定阅读本文的人通常了解按堆进行排序的方式，他们知道什么是分类树以及为什么需要进行筛选。</font><font style="vertical-align: inherit;">如果某人在此知识上有不足之处，那么在继续阅读之前，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建议您阅读上一篇文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二进制堆有什么问题</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下堆排序如何对几乎有序的数组进行排序，并了解为什么该算法不能更快地处理此类传入数据。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><div style="text-align:center;"><img width="646" height="303" src="https://habrastorage.org/webt/mr/x_/g9/mrx_g9exydmumk4rh-efffgvw_u.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单击动画以转至文章“通过n金字塔排序”</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
，引起您注意的第一件事是，在筛选时，最大值会不断推入堆的根，这与数组的第一个元素相对应。如果输入数组几乎是有序的，那么对于算法来说，这只会增加一点工作。较小的元素仍然会首先从树上掉下来，即靠近数组的末尾，而不是数组的开始。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个减慢因素（不是很明显）是标准二进制堆本身始终是平衡树。</font><font style="vertical-align: inherit;">对于最初订购的数据，这起着负面作用。</font><font style="vertical-align: inherit;">如果原始数组中有随机数据，则它们将均匀地分布在平衡树中，并且多次筛选会以大约相同的次数遍历所有分支。</font><font style="vertical-align: inherit;">对于几乎有序的数据，最好使用不平衡的树-在这种情况下，与树的较长分支相对应的数组部分数据的处理频率将比其他数据少。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">莱昂纳多数</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了解决这两个问题，Dijkstra建议使用基于Leonardo数的特殊二进制堆。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
莱昂纳多数几乎与斐波那契数类似，但只有更好。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
递归给出一系列莱昂纳多数：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前20个莱昂纳多数：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1、1、3、5、9、15、25、41、67 ，109，177，287，465，753，1219，1973，3193，5167，8361，13529 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
绝对可以将任何整数表示为具有不同序列号的莱昂纳多数字之和。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的案例中，这非常有用。</font><b><font style="vertical-align: inherit;">n的</font></b><font style="vertical-align: inherit;">数组</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素不能总是表示为Leonardo的单个堆（如果</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是Leonardo数）。</font><font style="vertical-align: inherit;">但是，然后，任何阵列都可以始终分为几个子阵列，分别对应于不同数量的莱昂纳多（Leonardo），即 </font><font style="vertical-align: inherit;">成为不同顺序的堆。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是第21个元素的数组的示例，该数组由三个Leonard堆组成。</font><font style="vertical-align: inherit;">在每个堆中，节点数对应于任何数量的莱昂纳多。</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="369" src="https://habrastorage.org/webt/-9/w7/1b/-9w71bwg0hst69nkbnewpiyku9m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要注意事项：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个Leonardov堆都是不平衡的二叉树。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个堆的根是对应子数组的最后一个（而不是第一个，如常规二进制堆中的第一个）元素。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有所有后代的任何节点也是较小顺序的伦纳德堆。</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建造和拆除堆</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在莱昂纳多数的递推公式中，</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对最后的单位非常满意。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是为什么。假设我们在数组中有两个相邻的子数组，它们对应于建立在两个相邻的莱昂纳多数上的堆。在这些子数组之后立即使用元素，可以将这些子数组组合为一个公共堆，该堆对应于下一个伦纳德数。</font></font><br>
<br>
<div style="text-align:center;"><img width="694" height="423" src="https://habrastorage.org/webt/ds/jv/5b/dsjv5bfc0ao4k9d-frevjzg3wee.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
遍历数组中的元素，我们构建了一堆伦纳德堆。如果使用元素，则可以合并前面的两个堆（只有当两个前面的堆对应于两个连续的莱昂纳多数时才有可能），然后合并。如果不可能合并（前两个堆不对应于两个连续的莱昂纳多数），那么当前元素将简单地形成一个新堆，其中一个元素与第一个（或第二个，如果使用第一个）Leonardo数相对应。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在算法的第二阶段，发生反向过程-我们解析堆。如果我们删除堆中的根，则将得到两个较小的堆，它们对应于前面的两个莱昂纳多数。可以这样做是因为：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -1 = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-2</font></font></sub></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在斐波那契数中没有这样的有用单位，因此我们不使用斐波那契堆。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平滑排序::平滑排序</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最终算法：</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.从数组创建一堆伦纳德堆，每个堆都是一棵排序树。</font></font></b><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.1。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从左到右遍历数组的元素。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们检查是否可以使用当前元素来合并伦纳德堆的现有堆中最左边的两个堆：</font></font><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1.a．</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果是，则将最左边的两个堆合并为一个，当前元素成为该堆的根，对合并的堆进行筛选。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1.b. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果不是，则将当前元素作为新堆（到目前为止，由一个节点组成）添加到Leonard堆的现有堆中。</font></font></li>
</ul></li>
</ul></li>
<li><b>II.      ,       :</b><ul>
<li><b>II.1.</b>     .          ,      .</li>
<li><b>II.2.</b>   (     )       (     ).</li>
<li><b>II.3.</b>    ,         .     .</li>
<li><b>II.4.</b>      (    ),          .</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.5。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将最大元素移到末尾后，数组的排序部分增加，而未排序部分减少。</font><font style="vertical-align: inherit;">对数组的其余未排序部分重复步骤II.1-II.4。</font></font></li>
</ul></li>
</ul><br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/wo/hc/ve/wohcve4fi78vdotmyfuw9pr2yyo.gif"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python实现示例</font></font></h3><br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> random<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">smoothsort</span>(<span class="hljs-params">lst</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#    </span><font></font>
    leo_nums = leonardo_numbers(len(lst))<font></font>
<font></font>
<font></font>
    <span class="hljs-comment">#       </span><font></font>
    heap = []<font></font>
<font></font>
    <span class="hljs-comment">#   </span>
    <span class="hljs-comment">#       </span>
    <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(lst)):
        <span class="hljs-keyword">if</span> len(heap) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> heap[<span class="hljs-number">-2</span>] == heap[<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>:<font></font>
            heap.pop()<font></font>
            heap[<span class="hljs-number">-1</span>] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> len(heap) &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> heap[<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>:<font></font>
                heap.append(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">else</span>:<font></font>
                heap.append(<span class="hljs-number">1</span>)<font></font>
        restore_heap(lst, i, heap, leo_nums)<font></font>
<font></font>
    <span class="hljs-comment">#  </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> reversed(range(len(lst))):
        <span class="hljs-keyword">if</span> heap[<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">2</span>:<font></font>
            heap.pop()<font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            k = heap.pop()<font></font>
            t_r, k_r, t_l, k_l = get_child_trees(i, k, leo_nums)<font></font>
            heap.append(k_l)<font></font>
            restore_heap(lst, t_l, heap, leo_nums)<font></font>
            heap.append(k_r)<font></font>
            restore_heap(lst, t_r, heap, leo_nums)<font></font>
<font></font>
<span class="hljs-comment">#   ,     </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leonardo_numbers</span>(<span class="hljs-params">hi</span>):</span><font></font>
<font></font>
    a, b = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><font></font>
    numbers = []<font></font>
    <span class="hljs-keyword">while</span> a &lt;= hi:<font></font>
        numbers.append(a)<font></font>
        a, b = b, a + b + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> numbers<font></font>
<font></font>
<span class="hljs-comment">#        </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restore_heap</span>(<span class="hljs-params">lst, i, heap, leo_nums</span>):</span><font></font>
    <font></font>
    <span class="hljs-comment">#      </span><font></font>
    <font></font>
    current = len(heap) - <span class="hljs-number">1</span><font></font>
    k = heap[current]<font></font>
<font></font>
    <span class="hljs-keyword">while</span> current &gt; <span class="hljs-number">0</span>:<font></font>
        j = i - leo_nums[k]<font></font>
        <span class="hljs-keyword">if</span> (lst[j] &gt; lst[i] <span class="hljs-keyword">and</span>
            (k &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> lst[j] &gt; lst[i<span class="hljs-number">-1</span>] <span class="hljs-keyword">and</span> lst[j] &gt; lst[i<span class="hljs-number">-2</span>])):<font></font>
            lst[i], lst[j] = lst[j], lst[i]<font></font>
            i = j<font></font>
            current -= <span class="hljs-number">1</span><font></font>
            k = heap[current]<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span><font></font>
<font></font>
    <span class="hljs-comment"># </span><font></font>
    <font></font>
    <span class="hljs-keyword">while</span> k &gt;= <span class="hljs-number">2</span>:<font></font>
        t_r, k_r, t_l, k_l = get_child_trees(i, k, leo_nums)<font></font>
        <span class="hljs-keyword">if</span> lst[i] &lt; lst[t_r] <span class="hljs-keyword">or</span> lst[i] &lt; lst[t_l]:
            <span class="hljs-keyword">if</span> lst[t_r] &gt; lst[t_l]:<font></font>
                lst[i], lst[t_r] = lst[t_r], lst[i]<font></font>
                i, k = t_r, k_r<font></font>
            <span class="hljs-keyword">else</span>:<font></font>
                lst[i], lst[t_l] = lst[t_l], lst[i]<font></font>
                i, k = t_l, k_l<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span><font></font>
<font></font>
<span class="hljs-comment">#         ,</span>
<span class="hljs-comment">#     </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_child_trees</span>(<span class="hljs-params">i, k, leo_nums</span>):</span><font></font>
<font></font>
    t_r, k_r = i - <span class="hljs-number">1</span>, k - <span class="hljs-number">2</span>
    t_l, k_l = t_r - leo_nums[k_r], k - <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> t_r, k_r, t_l, k_l<font></font>
<font></font>
<span class="hljs-comment">#  </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">n</span>):</span><font></font>
    lst = list(range(n))<font></font>
    random.shuffle(lst)<font></font>
    print(lst)<font></font>
    smoothsort(lst)<font></font>
    print(lst)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间复杂度</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们将几乎有序的数组作为输入，那么可视化效果将说明为什么处理这样一个数组要快得多的原因。</font></font><br>
<br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/x1/g1/kg/x1g1kglflod3zdnc2vuiqumjoyy.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
节省仅是由于筛分。在几乎有序的数据中，筛分沉入了树的浅层，包括在第二阶段逐渐解散堆之后。在最初的随机数据中，筛选更为昂贵，因为筛选通常会将其堆放到最后一层。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们估算总时间复杂度。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一阶段，我们遍历n个元素，将其添加到左侧已经存在的堆中。在O（1）中绕过添加到堆本身，但是对于堆，您需要进行筛选。在有序数据中，对于添加到堆中的一个元素，浅层筛选的成本通常为O（1）。在无序数据中，每个加法的筛分成本为</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，由于随机性的结果，筛选必须经常遍历树的最底层。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，在第一阶段，最佳时间复杂度是：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于几乎有序的数据-O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于随机数据-O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于第二阶段，情况类似。交换下一个最大值时，您再次需要在堆的根部筛选堆。而且有序和无序数据的筛选指标将有所不同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第二阶段，最佳时间复杂度与第一阶段相同：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于几乎有序的数据-O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于随机数据-O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一和第二阶段增加时间复杂度：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于几乎有序的数据-O（2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）= O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于随机数据-O（2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）= O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，平滑排序的最差时间和平均时间复杂度为O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dijkstra在他的计算中（我不会让您感到厌烦）证明，</font><font style="vertical-align: inherit;">与输入数据的排序顺序相比，</font><font style="vertical-align: inherit;">最佳复杂度</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平滑地</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">趋于</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，名称-平滑排序。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">额外的内存复杂性</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要将数据分解为一堆伦纳德堆，您只需要确切记住每一步涉及哪些伦纳多数即可。</font><font style="vertical-align: inherit;">知道了这些数字，堆本身就按照算法进行了对齐。</font><font style="vertical-align: inherit;">这个数列增长非常快，因此即使对于大型数组，您也将需要很少的伦纳德数集。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二项式堆排序::二项式堆排序</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一个与我们整理出来的树结构非常相似的树结构- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二项式堆</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这也是一堆大小不同的堆，每个堆中的节点数是2的幂。</font><font style="vertical-align: inherit;">可以将任何数量的元素的任何数组扩展到此堆中，因为任何自然数都可以分解为不同程度的二之和。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原则上，您可以基于二项式进行平滑排序：</font></font><br>
<br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/rw/p9/0y/rwp90yy_ub8vvvk2uczfoa4db8y.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
会更快吗？</font><font style="vertical-align: inherit;">几乎不。</font><font style="vertical-align: inherit;">二项式堆不是二进制的，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在上一篇文章中我们发现增加后代的数量并不会加速，但会降低屏幕速度</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此外，您会注意到二项式堆具有更长的分支，这就是为什么数组的相邻有序区域相互连接的速度会稍微慢一些的原因。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不知道Dijkstra二项式堆是否通常被认为是其算法的可能基础。</font><font style="vertical-align: inherit;">尽管如此，Leonardov堆可能更理想。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一个系列预告片</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，即使二项式堆不是平滑排序的最佳选择，也不应完全丢弃它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果对二项式树</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">稍加修改，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并使用完全不同的（非常大胆的）想法来绕过它，我们将得到一个具有其优势的原始有效算法。</font><font style="vertical-align: inherit;">下次我们要谈什么？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/1l/ay/j-/1layj-xmzm4dl7p5yv7_5iag5pa.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单击动画以转到具有下一个按堆排序的文章。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光滑</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光滑</font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">莱昂纳多数</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二项式堆</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二项式堆</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系列文章：</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel应用程序AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交换排序</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插入排序</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按选择排序</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序：N金字塔</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序：莱昂纳多数</font></font></b></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序：弱堆</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">束排序：笛卡尔树</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他堆排序：镜像堆，迷你堆，自下而上筛选</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序：Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合并排序</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按分布排序</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">混合排序</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今天的平滑排序已添加到AlgoLab应用中。</font><font style="vertical-align: inherit;">以及奖金-并按二项式排序。</font><font style="vertical-align: inherit;">所以谁想亲自驱动堆上的数据-用宏更新excel文件。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN496840/index.html">马斯克认为，1.2万颗卫星不会干扰天文学家。他的意见与模型不符</a></li>
<li><a href="../zh-CN496842/index.html">具有基本Python工具的简单流行模型</a></li>
<li><a href="../zh-CN496846/index.html">堆栈和指针的语言机制</a></li>
<li><a href="../zh-CN496848/index.html">＃340移动开发人员的有趣材料摘要（4月6日至12日）</a></li>
<li><a href="../zh-CN496850/index.html">Java 14的JPackage Maven插件</a></li>
<li><a href="../zh-CN496856/index.html">没有遥控器，但带有立方体的智能家居</a></li>
<li><a href="../zh-CN496858/index.html">FOSS新闻第11号-2020年4月6日至12日免费和开源软件回顾</a></li>
<li><a href="../zh-CN496860/index.html">第一个DI：第一个用于打字稿应用程序接口的DI</a></li>
<li><a href="../zh-CN496862/index.html">Arduino气泡显示</a></li>
<li><a href="../zh-CN496868/index.html">小空间交响曲</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>