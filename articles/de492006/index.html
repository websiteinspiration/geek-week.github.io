<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶 🚴🏿 🤳🏿 Die Leistung von PWA: Ein Videoüberwachungssystem mit einem JS-Code für ein neuronales Netzwerk mit 300 Leitungen 🤸🏿 🔦 👎🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 
 
 Webbrowser implementieren langsam, aber sicher die meisten Funktionen des Betriebssystems, und es gibt immer weniger Gründe, eine nati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Die Leistung von PWA: Ein Videoüberwachungssystem mit einem JS-Code für ein neuronales Netzwerk mit 300 Leitungen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492006/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webbrowser </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementieren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> langsam, aber sicher </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">die</font></a><font style="vertical-align: inherit;"> meisten Funktionen des Betriebssystems, und es gibt immer weniger Gründe, eine native Anwendung zu entwickeln, wenn Sie eine Webversion (PWA) schreiben können. Plattformübergreifende, umfangreiche API, hohe Entwicklungsgeschwindigkeit auf TS / JS und sogar die Leistung der V8-Engine - all dies ist ein Plus. Browser sind seit langem in der Lage, mit einem Videostream zu arbeiten und neuronale Netze zu betreiben. Das heißt, wir verfügen über alle Komponenten zur Erstellung eines Videoüberwachungssystems mit Objekterkennung. Inspiriert von diesem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel habe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ich beschlossen, die Demo auf das Niveau der praktischen Anwendung zu bringen, das ich teilen möchte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anwendung zeichnet Videos von der Kamera auf und sendet regelmäßig Bilder zur Erkennung in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COCO-SSD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn eine Person erkannt wird, werden Videofragmente in Teilen von 7 Sekunden über die Google Mail-API an die angegebene E-Mail gesendet. Wie in erwachsenen Systemen wird eine Voraufzeichnung durchgeführt, dh wir speichern ein Fragment bis zum Zeitpunkt der Erkennung, alle Fragmente mit Erkennung und eines danach. Wenn das Internet nicht verfügbar ist oder beim Senden ein Fehler auftritt, werden die Videos im lokalen Download-Ordner gespeichert. Wenn Sie die E-Mail verwenden, können Sie auf die Serverseite verzichten, den Eigentümer sofort benachrichtigen. Wenn ein Angreifer das Gerät in Besitz genommen und alle Kennwörter geknackt hat, kann er keine E-Mails vom Empfänger löschen. Von den Minuspunkten - Datenverkehr aufgrund von Base64 (obwohl dies für eine Kamera ausreicht) und die Notwendigkeit, die endgültige Videodatei aus vielen E-Mails zu sammeln. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Arbeitsdemo ist da</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Folgende Probleme treten auf:</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) Das neuronale Netzwerk lädt den Prozessor stark, und wenn Sie ihn im Hauptthread ausführen, werden in den Videos Verzögerungen angezeigt. Daher wird die Erkennung in einem separaten Thread (Worker) platziert, obwohl hier nicht alles glatt ist. Unter prähistorischem Dual-Core-Linux ist alles perfekt parallel, aber bei einigen ziemlich neuen 4-Core-Mobiltelefonen beginnt der Haupt-Thread zum Zeitpunkt der Erkennung (im Worker) ebenfalls zu verzögern, was sich in der Benutzeroberfläche bemerkbar macht. Glücklicherweise wirkt sich dies nicht auf die Qualität des Videos aus, obwohl es die Erkennungsfrequenz verringert (es passt sich automatisch an die Last an). Dieses Problem hängt wahrscheinlich damit zusammen, wie verschiedene Versionen von Android Threads auf Kernel verteilen, ob SIMD vorhanden ist, welche Grafikkartenfunktionen verfügbar sind usw. Ich kann es nicht alleine herausfinden, ich kenne die Innenseiten von TensorFlow nicht und werde für die Informationen dankbar sein.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) FireFox. </font><font style="vertical-align: inherit;">Die Anwendung funktioniert unter Chrome / Chromium / Edge einwandfrei. Die Erkennung in FireFox ist jedoch spürbar langsamer. Außerdem ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImageCapture</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> immer noch nicht implementiert </font><font style="vertical-align: inherit;">(dies kann natürlich umgangen werden, indem ein Frame aus &lt;video&gt; aufgenommen wird, aber es ist eine Schande für den Fuchs, da dies Standard ist API). </font><font style="vertical-align: inherit;">Im Allgemeinen gab es auch keine vollständige browserübergreifende Zugänglichkeit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also alles in Ordnung.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kamera und Mikrofon besorgen</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.video = <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'video'</span>)
<span class="hljs-keyword">this</span>.canvas = <span class="hljs-keyword">this</span>.querySelectorAll(<span class="hljs-string">'canvas'</span>)[<span class="hljs-number">0</span>]<font></font>
<font></font>
<span class="hljs-keyword">this</span>.stream = <span class="hljs-keyword">await</span> navigator.mediaDevices.getUserMedia(<font></font>
   {<span class="hljs-attr">video</span>: {<span class="hljs-attr">facingMode</span>: {<span class="hljs-attr">ideal</span>: <span class="hljs-string">"environment"</span>}}, <span class="hljs-attr">audio</span>: <span class="hljs-literal">true</span>}<font></font>
)<font></font>
<span class="hljs-keyword">this</span>.video.srcObject = <span class="hljs-keyword">this</span>.stream
<span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
   <span class="hljs-keyword">this</span>.video.onloadedmetadata = <span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> resolve()<font></font>
})<font></font>
<span class="hljs-keyword">this</span>.W = <span class="hljs-keyword">this</span>.bbox.width = <span class="hljs-keyword">this</span>.canvas.width = <span class="hljs-keyword">this</span>.video.videoWidth
<span class="hljs-keyword">this</span>.H = <span class="hljs-keyword">this</span>.bbox.height = <span class="hljs-keyword">this</span>.canvas.height = <span class="hljs-keyword">this</span>.video.videoHeight
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier wählen wir die Hauptkamera des Mobiltelefons / Tablets (oder die erste auf dem Computer / Laptop) aus, zeigen den Stream in einem Standard-Videoplayer an. Danach warten wir, bis die Metadaten geladen sind, und legen die Abmessungen des Servicebereichs fest. </font><font style="vertical-align: inherit;">Da die gesamte Anwendung im Stil von async / await geschrieben ist, müssen Sie Callback-APIs (und es gibt ziemlich viele davon) in Promise for Uniformity konvertieren.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Videoaufnahme</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt zwei Möglichkeiten, Videos aufzunehmen. </font><font style="vertical-align: inherit;">Die erste besteht darin, die Frames direkt aus dem eingehenden Stream zu lesen, sie auf der Zeichenfläche anzuzeigen, zu ändern (z. B. Geo- und Zeitstempel hinzuzufügen) und dann die Daten aus der Zeichenfläche zu übernehmen - für den Rekorder als ausgehenden Stream und für ein neuronales Netzwerk als separate Bilder. </font><font style="vertical-align: inherit;">In diesem Fall können Sie auf das &lt;video&gt; -Element verzichten.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.capture = <span class="hljs-keyword">new</span> ImageCapture(<span class="hljs-keyword">this</span>.stream.getVideoTracks()[<span class="hljs-number">0</span>])
<span class="hljs-keyword">this</span>.recorder = <span class="hljs-keyword">new</span> MediaRecorder(<span class="hljs-keyword">this</span>.canvas.captureStream(), {<span class="hljs-attr">mimeType</span> : <span class="hljs-string">"video/webm"</span>})<font></font>
<font></font>
grab_video()<font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grab_video</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">this</span>.canvas.drawImage(<span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.capture.grabFrame(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">const</span> img = <span class="hljs-keyword">this</span>.canvas.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.W, <span class="hljs-keyword">this</span>.H)<font></font>
	... <span class="hljs-comment">//    -   img</span>
	... <span class="hljs-comment">//   -    </span>
        <span class="hljs-built_in">window</span>.requestAnimationFrame(<span class="hljs-keyword">this</span>.grab_video.bind(<span class="hljs-keyword">this</span>))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite Möglichkeit (Arbeiten in FF) besteht darin, einen Standard-Videoplayer zum Aufnehmen zu verwenden. </font><font style="vertical-align: inherit;">Im Gegensatz zur Einzelbildanzeige auf Leinwand benötigt es übrigens weniger Prozessorzeit, aber wir können keine Beschriftung hinzufügen.</font></font><br>
<br>
<pre><code class="javascript hljs">...<font></font>
async <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grab_video</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">this</span>.canvas.drawImage(<span class="hljs-keyword">this</span>.video, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
	...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anwendung verwendet die erste Option, wodurch der Videoplayer während des Erkennungsprozesses ausgeschaltet werden kann. </font><font style="vertical-align: inherit;">Um den Prozessor zu sparen, wird die Aufzeichnung vom eingehenden Stream ausgeführt, und das Zeichnen von Frames auf Leinwand wird nur verwendet, um ein Array von Pixeln für das neuronale Netzwerk mit einer Frequenz zu erhalten, die von der Erkennungsgeschwindigkeit abhängt. </font><font style="vertical-align: inherit;">Wir zeichnen den Rahmen um die Person auf einer separaten Leinwand, die auf dem Player platziert ist.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden neuronaler Netze und Erkennung von Menschen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist alles unanständig einfach. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir starten den Worker</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nachdem wir das Modell (für eine ziemlich lange Zeit) geladen haben, senden wir eine leere Nachricht an den Haupt-Thread, wo wir im Ereignis onmessage die Startschaltfläche anzeigen, wonach der Worker bereit ist, Bilder zu empfangen. </font><font style="vertical-align: inherit;">Vollständiger Worker-Code:</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-keyword">async</span> () =&gt; {<font></font>
  self.importScripts(<span class="hljs-string">'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js'</span>)<font></font>
  self.importScripts(<span class="hljs-string">'https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd'</span>)<font></font>
<font></font>
  <span class="hljs-keyword">let</span> model = <span class="hljs-keyword">await</span> cocoSsd.load()<font></font>
  self.postMessage({})<font></font>
<font></font>
  self.onmessage = <span class="hljs-keyword">async</span> (ev) =&gt; {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> model.detect(ev.data)
    <span class="hljs-keyword">const</span> person = result.find(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.class === <span class="hljs-string">'person'</span>)
    <span class="hljs-keyword">if</span> (person) <font></font>
      self.postMessage({<span class="hljs-attr">ok</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bbox</span>: person.bbox})
    <span class="hljs-keyword">else</span>
      self.postMessage({<span class="hljs-attr">ok</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">bbox</span>: <span class="hljs-literal">null</span>})<font></font>
  }<font></font>
})()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Hauptthread </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">starten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">die</font></a><font style="vertical-align: inherit;"> Funktion </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">grab_video ()</font></a><font style="vertical-align: inherit;"> erst, nachdem </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">das vorherige Ergebnis vom Worker erhalten haben, </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">dh</font></a><font style="vertical-align: inherit;"> die Erkennungshäufigkeit hängt von der Systemlast ab.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Videoaufnahme</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.recorder.rec = <span class="hljs-keyword">new</span> MediaRecorder(<span class="hljs-keyword">this</span>.stream, {<span class="hljs-attr">mimeType</span> : <span class="hljs-string">"video/webm"</span>})
<span class="hljs-keyword">this</span>.recorder.rec.ondataavailable = <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> {
   <span class="hljs-keyword">this</span>.chunk = ev.data
   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.detected) {
      <span class="hljs-keyword">this</span>.send_chunk()<font></font>
   } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.recorder.num &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.send_chunk()
      <span class="hljs-keyword">this</span>.recorder.num--<font></font>
   }<font></font>
}<font></font>
...<font></font>
this.recorder.rec.start()<font></font>
<span class="hljs-keyword">this</span>.recorder.num = <span class="hljs-number">0</span>
<span class="hljs-keyword">this</span>.recorder.interval = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
   <span class="hljs-keyword">this</span>.recorder.rec.stop()
   <span class="hljs-keyword">this</span>.recorder.rec.start()<font></font>
}, CHUNK_DURATION)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei jedem Stopp des Rekorders (wir verwenden ein festes Intervall) wird das Ereignis ondataavailable ausgelöst, bei dem das aufgezeichnete Fragment im Blob-Format übertragen, in this.chunk gespeichert und asynchron gesendet wird. Ja, this.send_chunk () gibt ein Versprechen zurück, aber die Funktion dauert lange (Codierung in Base64, Senden einer E-Mail oder lokales Speichern der Datei), und wir warten nicht auf die Ausführung und verarbeiten das Ergebnis nicht - daher gibt es keine Wartezeit. Selbst wenn sich herausstellt, dass neue Videoclips häufiger erscheinen als gesendet werden können, ordnet die JS-Engine die Versprechungsreihe für den Entwickler transparent an, und alle Daten werden früher oder später gesendet / geschrieben. Das einzige, worauf Sie achten sollten, ist die Funktion </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">send_chunk ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vor dem ersten Warten müssen Sie den Blob mit der Slice () -Methode klonen, da der this.chunk-Link alle CHUNK_DURATION-Sekunden gerieben wird.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Mail-API</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wird zum Versenden von Briefen verwendet. </font><font style="vertical-align: inherit;">Die API ist ziemlich alt, teils aufgrund von Versprechungen, teils aufgrund von Rückrufen. Dokumentation und Beispiele sind nicht reichlich vorhanden, daher werde ich den vollständigen Code angeben. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autorisierung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir erhalten die Anwendungs- und Client-Schlüssel in der Google-Entwicklerkonsole. </font><font style="vertical-align: inherit;">In einem Popup-Autorisierungsfenster meldet Google, dass die Anwendung nicht überprüft wurde, und Sie müssen auf "Erweiterte Einstellungen" klicken, um sie einzugeben. </font><font style="vertical-align: inherit;">Das Überprüfen der Anwendung in Google stellte sich als nicht triviale Aufgabe heraus. Sie müssen den Besitz der Domain (die ich nicht habe) bestätigen und die Hauptseite korrekt anordnen, damit ich mich nicht darum kümmere.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'https://apis.google.com/js/api.js'</span>)<font></font>
gapi.load(<span class="hljs-string">'client:auth2'</span>, <span class="hljs-keyword">async</span> () =&gt; {
   <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> gapi.client.init({
         <span class="hljs-attr">apiKey</span>: API_KEY,
         <span class="hljs-attr">clientId</span>: CLIENT_ID,
         <span class="hljs-attr">discoveryDocs</span>: [<span class="hljs-string">'https://www.googleapis.com/discovery/v1/apis/gmail/v1/rest'</span>],
         <span class="hljs-attr">scope</span>: <span class="hljs-string">'https://www.googleapis.com/auth/gmail.send'</span><font></font>
      }) <font></font>
      <span class="hljs-keyword">if</span> (!gapi.auth2.getAuthInstance().isSignedIn.je) {
         <span class="hljs-keyword">await</span> gapi.auth2.getAuthInstance().signIn()<font></font>
      }<font></font>
      <span class="hljs-keyword">this</span>.msg.innerHTML = <span class="hljs-string">''</span>
      <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'nav'</span>).style.display = <span class="hljs-string">''</span>
   } <span class="hljs-keyword">catch</span>(e) {
      <span class="hljs-keyword">this</span>.msg.innerHTML = <span class="hljs-string">'Gmail authorization error: '</span> + <span class="hljs-built_in">JSON</span>.stringify(e, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>)<font></font>
   }<font></font>
})<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E-Mail senden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Base64-codierte Zeichenfolgen können nicht verkettet werden, was unpraktisch ist. </font><font style="vertical-align: inherit;">Wie man Videos im Binärformat sendet, habe ich immer noch nicht verstanden. </font><font style="vertical-align: inherit;">In den letzten Zeilen wandeln wir den Rückruf in ein Versprechen um. </font><font style="vertical-align: inherit;">Leider muss dies ziemlich oft gemacht werden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> send_mail(subject, mime_type, body) {
   <span class="hljs-keyword">const</span> headers = {
      <span class="hljs-string">'From'</span>: <span class="hljs-string">''</span>,
      <span class="hljs-string">'To'</span>: <span class="hljs-keyword">this</span>.email,
      <span class="hljs-string">'Subject'</span>: <span class="hljs-string">'Balajahe CCTV: '</span> + subject,
      <span class="hljs-string">'Content-Type'</span>: mime_type,
      <span class="hljs-string">'Content-transfer-encoding'</span>: <span class="hljs-string">'base64'</span><font></font>
   }<font></font>
   <span class="hljs-keyword">let</span> head = <span class="hljs-string">''</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(headers)) head += k + <span class="hljs-string">': '</span> + v + <span class="hljs-string">'\r\n'</span>
   <span class="hljs-keyword">const</span> request = gapi.client.gmail.users.messages.send({
      <span class="hljs-string">'userId'</span>: <span class="hljs-string">'me'</span>,
      <span class="hljs-string">'resource'</span>: { <span class="hljs-string">'raw'</span>: btoa(head + <span class="hljs-string">'\r\n'</span> + body) }<font></font>
   })<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<font></font>
      request.execute(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
         <span class="hljs-keyword">if</span> (!res.code) <font></font>
            resolve() <font></font>
         <span class="hljs-keyword">else</span> <font></font>
            reject(res)<font></font>
      })<font></font>
   })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Speichern eines Videoclips auf der Festplatte. </font><font style="vertical-align: inherit;">Wir verwenden einen versteckten Hyperlink.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'a'</span>)<font></font>
URL.revokeObjectURL(a.href)<font></font>
a.href = URL.createObjectURL(chunk)<font></font>
a.download = name<font></font>
a.click()</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State Management in der Welt der Webkomponenten</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich setzte die </font><font style="vertical-align: inherit;">
in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vorgestellte Idee fort </font><font style="vertical-align: inherit;">, brachte sie zur </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Absurdität des</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> logischen Endes (nur für den Lulz) und stellte die Kontrolle über den Staat auf den Kopf. </font><font style="vertical-align: inherit;">Wenn normalerweise JS-Variablen als Status betrachtet werden und das DOM nur die aktuelle Anzeige ist, ist in meinem Fall die Datenquelle das DOM selbst (da Webkomponenten die langlebigen DOM-Knoten sind), und für die Verwendung von Daten auf der JS-Seite stellen die Webkomponenten Getter / bereit Setter für jedes Formularfeld. </font><font style="vertical-align: inherit;">So werden beispielsweise anstelle unangenehmer Kontrollkästchen beim Stylen einfache &lt;Button&gt; verwendet, und der „Wert“ der Schaltfläche (true wird gedrückt, false wird gedrückt) ist der Wert des Klassenattributs, mit dem Sie es wie folgt formatieren können:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.true</span> {<span class="hljs-attribute">background-color</span>: red}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und erhalten Sie den Wert wie folgt:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">get</span> <span class="hljs-title">detecting</span>() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'#detecting'</span>).className === <span class="hljs-string">'true'</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich kann nicht raten, dies in der Produktion zu verwenden, da dies ein guter Weg ist, um die Produktivität zu senken. </font><font style="vertical-align: inherit;">Obwohl ... das virtuelle DOM auch nicht kostenlos ist und ich keine Benchmarks durchgeführt habe.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offline-Modus</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie abschließend eine kleine PWA hinzu, und installieren Sie einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Servicemitarbeiter,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der alle Netzwerkanforderungen zwischenspeichert und der Anwendung ermöglicht, ohne Internetzugang zu arbeiten. </font><font style="vertical-align: inherit;">Eine kleine Nuance - in Artikeln über Servicemitarbeiter geben sie normalerweise den folgenden Algorithmus an:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie im Installationsereignis eine neue Version des Caches und fügen Sie dem Cache alle erforderlichen Ressourcen hinzu.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Löschen Sie im Aktivierungsereignis alle Versionen des Caches mit Ausnahme der aktuellen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Abrufereignis versuchen wir zunächst, die Ressource aus dem Cache zu entnehmen. Wenn wir sie nicht gefunden haben, senden wir eine Netzwerkanforderung, deren Ergebnis dem Cache hinzugefügt wird.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Praxis ist ein solches Schema aus zwei Gründen unpraktisch. Erstens müssen Sie im Worker-Code eine aktuelle Liste aller erforderlichen Ressourcen haben und in großen Projekten, die Bibliotheken von Drittanbietern verwenden, versuchen, alle angehängten Importe (einschließlich dynamischer) zu verfolgen. Das zweite Problem: Wenn Sie eine Datei ändern, müssen Sie die Version des Service Workers erhöhen, was zur Installation eines neuen Workers und zur Ungültigmachung des vorherigen führt. Dies geschieht NUR, wenn der Browser geschlossen / geöffnet wird. Eine einfache Seitenaktualisierung hilft nicht - der alte Mitarbeiter mit dem alten Cache funktioniert. Und wo ist die Garantie, dass meine Kunden den Browser-Tab nicht für immer behalten? Daher fügen wir zuerst eine Netzwerkanforderung hinzu und fügen das Ergebnis asynchron zum Cache hinzu (ohne auf die Berechtigungsauflösung cache.put (ev.request, resp.clone ()) zu warten). Wenn das Netzwerk nicht verfügbar ist, erhalten wir es aus dem Cache. Besser einen Tag verlierendann in 5 Minuten fliegen ©.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ungelöste Probleme</font></font></h4><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei einigen Mobiltelefonen verlangsamt sich das neuronale Netzwerk. In meinem Fall ist COCO-SSD möglicherweise nicht die beste Wahl, aber ich bin kein ML-Experte, und ich habe die erste gewählt, die gehört wurde.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe kein Beispiel gefunden, wie man Videos über GAPI nicht im Base64-Format, sondern in der Original-Binärdatei sendet. </font><font style="vertical-align: inherit;">Dies würde sowohl Prozessorzeit als auch Netzwerkverkehr sparen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe die Sicherheit nicht verstanden. </font><font style="vertical-align: inherit;">Für lokale Debugging-Zwecke habe ich die localhost-Domain zur Google-Anwendung hinzugefügt. Wenn jedoch jemand die Anwendungsschlüssel zum Senden von Spam verwendet, blockiert Google die Schlüssel selbst oder das Konto des Absenders?</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für das Feedback wäre ich dankbar. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellen zu Github. </font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielen Dank für Ihre Aufmerksamkeit.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491994/index.html">Migration von Cocoapods zu Swift Package Manager</a></li>
<li><a href="../de491996/index.html">Weitere Informationen zu Coroutinen in C ++</a></li>
<li><a href="../de492000/index.html">Produkt zuerst. Ausbrennen</a></li>
<li><a href="../de492002/index.html">Lichtabsorbierende Flügel: Das Geheimnis der Super Black Butterflies</a></li>
<li><a href="../de492004/index.html">Wie man vom Programmierer zum Manager heranwächst („Ich möchte die Herrin des Meeres sein“)</a></li>
<li><a href="../de492008/index.html">Ergebnisse der IT-Motivationsforschung: Sind Entwickler mit ihrer Arbeit zufrieden?</a></li>
<li><a href="../de492010/index.html">Die dunkle Seite des Designsystems und was damit zu tun ist</a></li>
<li><a href="../de492012/index.html">Gyenno Stabilisierungskochgeschirr gleicht bis zu 80% Zittern aus</a></li>
<li><a href="../de492016/index.html">ABP und alles, alles, alles: automatische Reservenerfassung im Rechenzentrum</a></li>
<li><a href="../de492018/index.html">Geschwindigkeitsüberschreitung: Risiken und Schwachstellen im Bereich intelligenter Verkehrssysteme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>