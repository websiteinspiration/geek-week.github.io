<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛩️ ⛽️ 👉🏽 PEP 572 (Zuweisungsausdrücke in Python 3.8) 👰🏽 💆🏻 🚮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. Dieses Mal werden wir uns PEP 572 ansehen, in dem es um Zuweisungsausdrücke geht. Wenn Sie dem Operator ": =" immer noch skeptisch gegenüb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PEP 572 (Zuweisungsausdrücke in Python 3.8)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499666/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr. </font><font style="vertical-align: inherit;">Dieses Mal werden wir uns PEP 572 ansehen, in dem es um Zuweisungsausdrücke geht. </font><font style="vertical-align: inherit;">Wenn Sie dem Operator ": =" immer noch skeptisch gegenüberstehen oder die Regeln für seine Verwendung nicht vollständig verstehen, ist dieser Artikel genau das Richtige für Sie. </font><font style="vertical-align: inherit;">Hier finden Sie viele Beispiele und Antworten auf die Frage: "Warum ist das so?" </font><font style="vertical-align: inherit;">Dieser Artikel hat sich als so vollständig wie möglich herausgestellt. Wenn Sie wenig Zeit haben, schauen Sie sich den Abschnitt an, den ich geschrieben habe. </font><font style="vertical-align: inherit;">Zu Beginn werden die wichtigsten „Thesen“ für eine bequeme Arbeit mit Zuordnungsausdrücken gesammelt. </font><font style="vertical-align: inherit;">Verzeihen Sie mir im Voraus, wenn Sie Fehler finden (schreiben Sie mir darüber, ich werde es beheben). </font><font style="vertical-align: inherit;">Lasst uns beginnen:</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEP 572 - Zuweisungsausdrücke</font></font></h2><div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pep</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">572</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Titel:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuweisungsausdrücke</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autoren:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Angelico &lt;rosuav at gmail.com&gt;, Tim Peters &lt;tim.peters at gmail.com&gt;, Guido van Rossum &lt;guido at python.org&gt;</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diskussion:</font></font></b></td>
<td><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doc-sig bei python.org</font></font></a></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akzeptiert</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Art:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellt:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28.02.2018</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python-Version:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.8</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beitragsgeschichte:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28-Feb-2018, 02-Mar-2018, 23-Mar-2018, 04-Apr-2018, 17-Apr-2018, 25-Apr-2018, 09-Jul-2018, 05-Aug-2019</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erlaubnis zur Übernahme des Standards:</font></font></b></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mail.python.org/pipermail/python-dev/2018-July/154601.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (mit VPN für eine lange Zeit, aber es wird </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">geladen</font></a><font style="vertical-align: inherit;"> )</font></font></td>
</tr>
</tbody></table></div><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalt</font></font></b><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anmerkung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rechtfertigung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax und Semantik</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spezifikationsänderungen während der Implementierung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abgelehnte Alternativen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Häufige Einwände</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stilempfehlungen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang A: Schlussfolgerungen von Tim Peters</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang B: Ein Grobcode-Interpreter für Generatoren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang C: Keine Änderungen in der Umfangssemantik</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urheberrechte ©</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mein Teil</font></font></a></li>
</ul><br>
<a name="ann"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anmerkung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Konvention wird über die Möglichkeit der Zuweisung innerhalb von Ausdrücken unter Verwendung der neuen Notation NAME: = expr sprechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Rahmen der Innovationen wurde das Verfahren zur Berechnung der Wörterbuchgeneratoren (Wörterbuchverständnis) aktualisiert. Dadurch wird sichergestellt, dass der Schlüsselausdruck vor dem Wertausdruck ausgewertet wird (auf diese Weise können Sie den Schlüssel an eine Variable binden und die erstellte Variable dann für die Berechnung des dem Schlüssel entsprechenden Werts wiederverwenden). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während einer Diskussion dieses PEP wurde dieser Operator inoffiziell als Walross-Operator bekannt. Der formale Name des Konstrukts lautet "Zuweisungsausdruck" (gemäß der Überschrift PEP: Zuweisungsausdrücke), kann jedoch als "Benannte Ausdrücke" bezeichnet werden. Beispielsweise verwendet die Referenzimplementierung in CPython genau diesen Namen.</font></font><br>
<br>
<a name="oboc"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rechtfertigung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Benennung ist ein wichtiger Bestandteil der Programmierung, mit dem Sie anstelle eines längeren Ausdrucks einen „beschreibenden“ Namen verwenden und die Wiederverwendung von Werten vereinfachen können. </font><font style="vertical-align: inherit;">Derzeit kann dies nur in Form von Anweisungen erfolgen, wodurch diese Operation beim Generieren von Listen (Listenverständnis) sowie in anderen Ausdrücken nicht verfügbar ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus kann das Benennen von Teilen eines großen Ausdrucks beim interaktiven Debuggen hilfreich sein, indem Tools zum Anzeigen von Eingabeaufforderungen und Zwischenergebnissen bereitgestellt werden. </font><font style="vertical-align: inherit;">Ohne die Möglichkeit, die Ergebnisse verschachtelter Ausdrücke zu erfassen, müssen Sie den Quellcode ändern. Mit den Zuweisungsausdrücken müssen Sie jedoch nur einige "Marker" der Form "name: = expression" einfügen. </font><font style="vertical-align: inherit;">Dies eliminiert unnötiges Refactoring und verringert daher die Wahrscheinlichkeit unbeabsichtigter Codeänderungen während des Debuggens (eine häufige Ursache für Heisenbugs sind Fehler, die die Eigenschaften des Codes während des Debuggens ändern und möglicherweise unerwartet in der Produktion auftreten), und dieser Code ist für einen anderen verständlicher an den Programmierer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bedeutung von echtem Code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während der Entwicklung dieses PEP konzentrierten sich viele Menschen (sowohl Befürworter als auch Kritiker) zu sehr auf Spielzeugbeispiele einerseits und zu komplexe Beispiele andererseits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Gefahr von Spielzeugbeispielen besteht in zweierlei Hinsicht: Sie sind oft zu abstrakt, um jemanden sagen zu lassen: „Oh, das ist unwiderstehlich“, und sie werden auch leicht mit den Worten „Das würde ich niemals schreiben“ abgelehnt. Die Gefahr zu komplexer Beispiele besteht darin, dass sie Kritikern eine bequeme Umgebung bieten, in der vorgeschlagen wird, diese Funktionalität zu entfernen („Das ist zu verwirrend“, sagen solche Leute). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solche Beispiele sind jedoch sinnvoll: Sie helfen, die beabsichtigte Semantik zu verdeutlichen. Daher werden wir im Folgenden einige davon nennen. Um jedoch zu </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">überzeugen</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , müssen Beispiele auf basieren</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">echter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code, der geschrieben wurde, ohne über diesen PEP nachzudenken. Das heißt, der Code, der Teil einer wirklich nützlichen Anwendung ist (kein Unterschied: ob groß oder klein). Tim Peters hat uns sehr geholfen, indem er sich seine persönlichen Repositories angesehen und Beispiele für den von ihm geschriebenen Code ausgewählt hat, der (seiner Meinung nach) verständlicher wäre, wenn sie (ohne Fanatismus) mit Zuweisungsausdrücken umgeschrieben würden. Sein Fazit lautet: Die aktuellen Änderungen würden eine bescheidene, aber offensichtliche Verbesserung einiger Teile seines Codes bewirken. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Beispiel für echten Code ist die indirekte Beobachtung, wie Programmierer Kompaktheit schätzen. Guido van Rossum überprüfte die Dropbox-Codebasis und fand Hinweise darauf, dass Programmierer lieber weniger Codezeilen schreiben als ein paar kleine Ausdrücke.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel: Guido hat mehrere veranschaulichende Punkte gefunden, wenn ein Programmierer einen Unterausdruck wiederholt (wodurch das Programm verlangsamt wird), aber eine zusätzliche Codezeile speichert. </font><font style="vertical-align: inherit;">Zum Beispiel anstatt zu schreiben:</font></font><br>
<br>
<pre><code class="python hljs">match = re.match(data)<font></font>
group = match.group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> match <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Programmierer bevorzugten diese Option:</font></font><br>
<br>
<pre><code class="python hljs">group = re.match(data).group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> re.match(data) <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein weiteres Beispiel, das zeigt, dass Programmierer manchmal bereit sind, mehr Arbeit zu leisten, um die „vorherige Ebene“ der Einrückung beizubehalten:</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)<font></font>
match2 = pattern2.match(data)<font></font>
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">elif</span> match2:<font></font>
    result = match2.group(<span class="hljs-number">2</span>)
<span class="hljs-keyword">else</span>:<font></font>
    result = <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code berechnet Muster2, auch wenn Muster1 bereits übereinstimmt (in diesem Fall wird die zweite Unterbedingung niemals erfüllt). </font><font style="vertical-align: inherit;">Daher ist die folgende Lösung effektiver, aber weniger attraktiv:</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">else</span>:<font></font>
    match2 = pattern2.match(data)<font></font>
    <span class="hljs-keyword">if</span> match2:<font></font>
        result = match2.group(<span class="hljs-number">2</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        result = <span class="hljs-literal">None</span></code></pre><br>
<a name="sint"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax und Semantik</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten Fällen, in denen Python beliebige Ausdrücke verwendet, können Sie jetzt Zuweisungsausdrücke verwenden. </font><font style="vertical-align: inherit;">Sie haben die Form NAME: = Ausdruck, wobei Ausdruck ein beliebiger gültiger Python-Ausdruck ist, mit Ausnahme des nicht parenthesierten Tupels, und NAME der Bezeichner ist. </font><font style="vertical-align: inherit;">Der Wert eines solchen Ausdrucks stimmt mit dem Original überein, ein zusätzlicher Effekt ist jedoch die Zuweisung eines Werts zum Zielobjekt:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Handle a matched regex</span>
<span class="hljs-keyword">if</span> (match := pattern.search(data)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
    <span class="hljs-comment"># Do something with match</span><font></font>
<font></font>
<span class="hljs-comment"># A loop that can't be trivially rewritten using 2-arg iter()</span>
<span class="hljs-keyword">while</span> chunk := file.read(<span class="hljs-number">8192</span>):<font></font>
   process(chunk)<font></font>
<font></font>
<span class="hljs-comment"># Reuse a value that's expensive to compute</span>
[y := f(x), y**<span class="hljs-number">2</span>, y**<span class="hljs-number">3</span>]<font></font>
<font></font>
<span class="hljs-comment"># Share a subexpression between a comprehension filter clause and its output</span>
filtered_data = [y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data <span class="hljs-keyword">if</span> (y := f(x)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]</code></pre><br>
<a name="iskluch"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmefällen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt mehrere Stellen, an denen Zuweisungsausdrücke nicht zulässig sind, um Mehrdeutigkeiten oder Verwirrung unter den Benutzern zu vermeiden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuweisungsausdrücke, die nicht in Klammern stehen, sind auf der „oberen“ Ebene verboten:</font></font><br>
<br>
<pre><code class="python hljs">y := f(x)  <span class="hljs-comment"># </span>
(y := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Regel erleichtert dem Programmierer die Auswahl zwischen einem Zuweisungsoperator und einem Zuweisungsausdruck. Es gibt keine syntaktische Situation, in der beide Optionen gleichwertig sind.</font></font></li>
<li>           . :<br>
<br>
<pre><code class="python hljs">y0 = y1 := f(x)  <span class="hljs-comment"># </span>
y0 = (y1 := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br>
             . :<br>
<br>
<pre><code class="python hljs">foo(x = y := f(x))  <span class="hljs-comment"># </span>
foo(x=(y := f(x)))  <span class="hljs-comment"># ,     </span></code></pre><br>
 ,               .</li>
<li>           . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer = p := <span class="hljs-number">42</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer=(<span class="hljs-params">p := <span class="hljs-number">42</span></span>)</span>):</span>  <span class="hljs-comment"># Valid, though not great style</span>
    ...</code></pre><br>
        ,           (.    ,     «»     ).</li>
<li>           ,    . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: p := <span class="hljs-number">42</span> = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: (<span class="hljs-params">p := <span class="hljs-number">42</span></span>) = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># ,  </span>
    ...</code></pre><br>
       : ,     "="  ":="   .</li>
<li>        -. :<br>
<br>
<pre><code class="python hljs">(<span class="hljs-keyword">lambda</span>: x := <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span>: (x := <span class="hljs-number">1</span>) <span class="hljs-comment"># ,  </span>
(x := <span class="hljs-keyword">lambda</span>: <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span> line: (m := re.match(pattern, line)) <span class="hljs-keyword">and</span> m.group(<span class="hljs-number">1</span>) <span class="hljs-comment"># Valid</span></code></pre><br>
-    ,  ":=".       .  ,     ,    ()  ,         .</li>
<li>   f-  . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{(x:=<span class="hljs-number">10</span>)}</span>'</span>  <span class="hljs-comment"># ,  </span>
<span class="hljs-string">'10'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-number">10</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{x:=<span class="hljs-number">10</span>}</span>'</span>    <span class="hljs-comment"># ,  ,  '=10'</span>
<span class="hljs-string">'        10'</span></code></pre><br>
 ,    ,     f-,  .  f-   ":"    .    ,      f-      .     ,      .</li>
</ul><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Zuweisungsausdruck führt keinen neuen Bereich ein. In den meisten Fällen muss der Bereich, in dem die Variable erstellt wird, nicht erläutert werden: Sie ist aktuell. Wenn die Variable zuvor die nichtlokalen oder globalen Schlüsselwörter verwendet hat, berücksichtigt der Zuweisungsausdruck dies. Nur Lambda (eine anonyme Definition einer Funktion) wird für diese Zwecke als separater Bereich betrachtet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen Sonderfall: Ein Zuweisungsausdruck, der in Generatoren von Listen, Mengen, Wörterbüchern oder in den „Ausdrücken von Generatoren“ selbst (im Folgenden zusammenfassend als „Generatoren“ (Verständnis) bezeichnet) vorkommt, bindet die Variable unter Berücksichtigung des Globab-Modifikators an den Bereich, den der Generator enthält oder nicht global, falls vorhanden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für diesen Sonderfall gibt es zwei Gründe. </font><font style="vertical-align: inherit;">Erstens können wir das „Mitglied“ bequem in den Ausdrücken any () und all () erfassen, zum Beispiel:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> any((comment := line).startswith(<span class="hljs-string">'#'</span>) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"First comment:"</span>, comment)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"There are no comments"</span>)<font></font>
<font></font>
<span class="hljs-keyword">if</span> all((nonblank := line).strip() == <span class="hljs-string">''</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"All lines are blank"</span>)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"First non-blank line:"</span>, nonblank)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens bietet es eine kompakte Möglichkeit, eine Variable von einem Generator zu aktualisieren, zum Beispiel:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Compute partial sums in a list comprehension</span>
total = <span class="hljs-number">0</span>
partial_sums = [total := total + v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values]<font></font>
print(<span class="hljs-string">"Total:"</span>, total)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Name der Variablen aus dem Zuweisungsausdruck kann jedoch nicht mit dem Namen übereinstimmen, der bereits in Generatoren von der for-Schleife zum Iterieren verwendet wird. </font><font style="vertical-align: inherit;">Die Nachnamen sind lokal für den Generator, in dem sie erscheinen. </font><font style="vertical-align: inherit;">Es wäre inkonsistent, wenn sich die Zuweisungsausdrücke auch auf den Bereich innerhalb des Generators beziehen würden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel ist [i: = i + 1 für i in Bereich (5)] nicht gültig: Die for-Schleife bestimmt, dass i lokal für den Generator ist, aber der Teil „i: = i + 1“ besteht darauf, dass i eine Variable von außen ist Umfang </font><font style="vertical-align: inherit;">Aus dem gleichen Grund funktionieren die folgenden Beispiele nicht:</font></font><br>
<br>
<pre><code class="python hljs">
[[(j := j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># </span>
[i := <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]                       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (i := stuff)]                      <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl es technisch möglich ist, für solche Fälle eine konsistente Semantik zuzuweisen, ist es schwierig zu bestimmen, ob die Art und Weise, wie wir diese Semantik verstehen, in Ihrem realen Code funktioniert. Aus diesem Grund stellt die Referenzimplementierung sicher, dass solche Fälle SyntaxError auslösen und nicht mit undefiniertem Verhalten ausgeführt werden, abhängig von der jeweiligen Hardwareimplementierung. Diese Einschränkung gilt auch dann, wenn ein Zuweisungsausdruck niemals ausgeführt wird:</font></font><br>
<br>
<pre><code class="python hljs">[<span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> (i := <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]     <span class="hljs-comment"># </span>
[i <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff <span class="hljs-keyword">if</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> (j := <span class="hljs-number">1</span>)]  <span class="hljs-comment"># </span><font></font>
<font></font>
<span class="hljs-comment"># [.  . - ""   </span>
<span class="hljs-comment"># ,       </span>
<span class="hljs-comment"># ,    ,   ]</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für den Generatorkörper (den Teil vor dem ersten Schlüsselwort "für") und den Filterausdruck (den Teil nach dem "wenn" und vor einem verschachtelten "für") gilt diese Einschränkung ausschließlich für Variablennamen, die gleichzeitig als iterative Variablen verwendet werden. Wie bereits erwähnt, führen Lambda-Ausdrücke einen neuen expliziten Funktionsumfang ein und können daher ohne zusätzliche Einschränkungen in Ausdrücken von Generatoren verwendet werden. [ca. wieder, außer in solchen Fällen: [i für i im Bereich (2, (Lambda: (s: = 2) ())]]</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund von Designbeschränkungen in der Referenzimplementierung (der Symboltabellenanalysator kann nicht erkennen, ob die Namen aus dem linken Teil des Generators in dem verbleibenden Teil verwendet werden, in dem sich der iterierbare Ausdruck befindet), sind Zuweisungsausdrücke als Teil von iterable (in dem Teil nach jedem "in" und "vollständig verboten) vor jedem nachfolgenden Schlüsselwort "if" oder "for"). </font><font style="vertical-align: inherit;">Das heißt, alle diese Fälle sind inakzeptabel:</font></font><br>
<br>
<pre><code class="python hljs">[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (j := stuff)]                    <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]  <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [j <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]]       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-keyword">lambda</span>: (j := stuff))()]        <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere Ausnahme tritt auf, wenn ein Zuweisungsausdruck in Generatoren verwendet wird, die sich im Bereich einer Klasse befinden. </font><font style="vertical-align: inherit;">Wenn bei Verwendung der oben genannten Regeln eine im Bereich neu gemessene Klasse erstellt werden soll, ist ein solcher Zuweisungsausdruck ungültig und führt zu einem SyntaxError:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>:</span>
    [(j := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]  <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Der Grund für die letzte Ausnahme ist der implizite Umfang der vom Generator erstellten Funktion. Derzeit gibt es keinen Laufzeitmechanismus für Funktionen, die auf eine Variable im Bereich der Klasse verweisen, und wir möchten keinen solchen Mechanismus hinzufügen. Wenn dieses Problem jemals gelöst wird, In diesem Fall wird dieser Sonderfall (möglicherweise) aus der Spezifikation der Zuweisungsausdrücke entfernt. Beachten Sie, dass dieses Problem auch dann auftritt, wenn Sie eine Variable früher im Bereich der Klasse erstellt haben und versuchen, sie mit einem Zuweisungsausdruck aus dem Generator zu ändern.) Beispiele dazu finden </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie in Anhang B. In Generatoren gefundene Zuweisungsausdrücke werden in äquivalenten Code konvertiert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relative Priorität: =</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Operator: = wird nach Möglichkeit in allen syntaktischen Positionen stärker als das Komma gruppiert, aber schwächer als alle anderen Operatoren, einschließlich oder und und nicht, und bedingte Ausdrücke (A wenn C sonst B). Wie aus dem obigen Abschnitt „Ausnahmefälle“ hervorgeht, funktionieren Zuweisungsausdrücke niemals auf derselben „Ebene“ wie die klassische Zuweisung =. Wenn eine andere Reihenfolge der Operationen erforderlich ist, verwenden Sie Klammern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Operator: = kann direkt beim Aufrufen des Positionsarguments einer Funktion verwendet werden. Dies funktioniert jedoch nicht direkt im Argument. Einige Beispiele, die verdeutlichen, was technisch zulässig und was nicht möglich ist:</font></font><br>
<br>
<pre><code class="python hljs">x := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
(x := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
x = y := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
x = (y := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
len(lines := f.readlines()) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(x := <span class="hljs-number">3</span>, cat=<span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=category := <span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=(category := <span class="hljs-string">'vector'</span>)) <span class="hljs-comment">#  </span></code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die meisten der oben genannten „gültigen“ Beispiele werden für die Verwendung in der Praxis nicht empfohlen, da Personen, die Ihren Quellcode schnell scannen, dessen Bedeutung möglicherweise nicht richtig verstehen. </font><font style="vertical-align: inherit;">In einfachen Fällen ist dies jedoch zulässig:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Valid</span>
<span class="hljs-keyword">if</span> any(len(longline := line) &gt;= <span class="hljs-number">100</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"Extremely long line:"</span>, longline)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem PEP wird empfohlen, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unbedingt immer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leerzeichen um: = zu setzen, ähnlich der Empfehlung von PEP 8 für = für die klassische Zuweisung. </font><font style="vertical-align: inherit;">(Der Unterschied zur letzten Empfehlung besteht darin, dass Leerzeichen um = verboten werden, mit denen Schlüsselargumente an die Funktion übergeben werden.)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie die Reihenfolge der Berechnungen.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um eine genau definierte Semantik zu haben, erfordert diese Vereinbarung, dass das Bewertungsverfahren klar definiert ist. </font><font style="vertical-align: inherit;">Technisch ist dies keine neue Anforderung. </font><font style="vertical-align: inherit;">Python hat bereits die Regel, dass Unterausdrücke normalerweise von links nach rechts ausgewertet werden. </font><font style="vertical-align: inherit;">Zuweisungsausdrücke machen diese „Nebenwirkungen“ jedoch deutlicher, und wir schlagen eine Änderung in der aktuellen Berechnungsreihenfolge vor:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Wörterbuchgeneratoren {X: Y für ...} wird Y derzeit vor X ausgewertet. Wir empfehlen, dies so zu ändern, dass X vor Y berechnet wird. (In einem klassischen Dikt wie {X: Y} sowie in dikt ((X, Y) für ...) Dies wurde bereits implementiert. Daher müssen Wörterbuchgeneratoren diesen Mechanismus einhalten.)</font></font></li>
</ul><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschiede zwischen Zuweisungsausdrücken und Zuweisungsanweisungen.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am wichtigsten ist, dass ": =" ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausdruck ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was bedeutet, dass er in Fällen verwendet werden kann, in denen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anweisungen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ungültig sind, einschließlich Lambda-Funktionen und Generatoren. </font><font style="vertical-align: inherit;">Im Gegensatz dazu </font><font style="vertical-align: inherit;">Zuweisung </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausdrücke</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht unterstützen die erweiterte Funktionalität , </font><font style="vertical-align: inherit;">die in verwendet werden kann </font><font style="vertical-align: inherit;">Zuordnung </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anweisungen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die kaskadierende Zuweisung wird nicht direkt unterstützt</font></font><br>
<br>
<pre><code class="python hljs">x = y = z = <span class="hljs-number">0</span>  <span class="hljs-comment"># Equivalent: (z := (y := (x := 0)))</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separate "Ziele" werden mit Ausnahme des einfachen Variablennamens NAME nicht unterstützt:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># No equivalent</span><font></font>
a[i] = x<font></font>
self.rest = []</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionalität und Priorität "um" Kommas unterscheiden sich:</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>  <span class="hljs-comment"># Sets x to (1, 2)</span>
(x := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># Sets x to 1</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auspacken und Verpackungswerte haben keine „reine“ Äquivalenz oder werden überhaupt nicht unterstützt</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Equivalent needs extra parentheses</span>
loc = x, y  <span class="hljs-comment"># Use (loc := (x, y))</span>
info = name, phone, *rest  <span class="hljs-comment"># Use (info := (name, phone, *rest))</span><font></font>
<font></font>
<span class="hljs-comment"># No equivalent</span><font></font>
px, py, pz = position<font></font>
name, phone, email, *other_info = contact</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inline-Typanmerkungen werden nicht unterstützt:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Closest equivalent is "p: Optional[int]" as a separate declaration</span>
p: Optional[int] = <span class="hljs-literal">None</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keine verkürzte Form von Operationen:</font></font><br>
<br>
<pre><code class="python hljs">total += tax  <span class="hljs-comment"># Equivalent: (total := total + tax)</span></code></pre></li>
</ul><br>
<a name="cpec"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spezifikationsänderungen während der Implementierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden Änderungen wurden basierend auf unseren Erfahrungen und zusätzlichen Analysen nach dem ersten Schreiben dieses PEP und vor der Veröffentlichung von Python 3.8 vorgenommen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Konsistenz mit anderen ähnlichen Ausnahmen zu gewährleisten und keinen neuen Namen einzuführen, der für Endbenutzer möglicherweise nicht geeignet ist, wurde die ursprünglich vorgeschlagene Unterklasse von TargetScopeError for SyntaxError entfernt und auf den üblichen SyntaxError reduziert. </font><font style="vertical-align: inherit;">[3]</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund von Einschränkungen beim Parsen der CPython-Zeichentabelle löst die Referenzimplementierung des Zuweisungsausdrucks einen SyntaxError für alle Verwendungen innerhalb von Iteratoren aus. </font><font style="vertical-align: inherit;">Bisher trat diese Ausnahme nur auf, wenn der Name der zu erstellenden Variablen mit dem bereits im iterativen Ausdruck verwendeten übereinstimmte. </font><font style="vertical-align: inherit;">Dies kann überarbeitet werden, wenn ausreichend überzeugende Beispiele vorliegen, die zusätzliche Komplexität jedoch für rein „hypothetische“ Anwendungsfälle ungeeignet erscheint.</font></font></li>
</ul><br>
<a name="prim"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele für Python-Standardbibliotheken</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
env_base wird nur in einer Bedingung verwendet, daher kann die Zuweisung in if als "Header" eines logischen Blocks platziert werden.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktueller Code:</font></font><br>
<pre><code class="python hljs">env_base = os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>)
<span class="hljs-keyword">if</span> env_base:
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserter Code:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> env_base := os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>):
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_pydecimal.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können verschachtelte ifs vermeiden und dadurch eine Einrückungsstufe entfernen.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktueller Code:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special:<font></font>
    ans = self._check_nans(context=context)<font></font>
    <span class="hljs-keyword">if</span> ans:
        <span class="hljs-keyword">return</span> ans</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserter Code:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special <span class="hljs-keyword">and</span> (ans := self._check_nans(context=context)):
    <span class="hljs-keyword">return</span> ans</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copy.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code sieht klassischer aus und vermeidet auch das mehrfache Verschachteln von bedingten Anweisungen. </font><font style="vertical-align: inherit;">(Weitere Informationen zum Ursprung dieses Beispiels finden Sie in Anhang A.)</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktueller Code:</font></font><br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(
                <span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserter Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datetime.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tz wird nur für s + = tz verwendet. </font><font style="vertical-align: inherit;">Bewegen Sie es nach innen, wenn dies dazu beiträgt, den logischen Verwendungsbereich aufzuzeigen.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktueller Code:</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
tz = self._tzstr()<font></font>
<span class="hljs-keyword">if</span> tz:<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserter Code:</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
<span class="hljs-keyword">if</span> tz := self._tzstr():<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sysconfig.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Aufrufen von fp.readline () als "Bedingung" in der while-Schleife (sowie das Aufrufen der .match () -Methode) in der if-Bedingung macht den Code kompakter, ohne sein Verständnis zu erschweren.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktueller Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    line = fp.readline()<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:
        <span class="hljs-keyword">break</span><font></font>
    m = define_rx.match(line)<font></font>
    <span class="hljs-keyword">if</span> m:<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
        m = undef_rx.match(line)<font></font>
        <span class="hljs-keyword">if</span> m:<font></font>
            vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserter Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> line := fp.readline():
    <span class="hljs-keyword">if</span> m := define_rx.match(line):<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">elif</span> m := undef_rx.match(line):<font></font>
        vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vereinfachen Sie Listengeneratoren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt kann der Listengenerator effektiv gefiltert werden, indem die Bedingung "erfasst" wird:</font></font><br>
<br>
<pre><code class="python hljs">results = [(x, y, x/y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> input_data <span class="hljs-keyword">if</span> (y := f(x)) &gt; <span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danach kann die Variable in einem anderen Ausdruck wiederverwendet werden:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[y := f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie erneut, dass sich die Variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in beiden Fällen </font><font style="vertical-align: inherit;">im selben Bereich befindet wie das Ergebnis und die Daten der Variablen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werte in Bedingungen erfassen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuweisungsausdrücke können effektiv unter den Bedingungen einer if- oder while-Anweisung verwendet werden:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Loop-and-a-half</span>
<span class="hljs-keyword">while</span> (command := input(<span class="hljs-string">"&gt; "</span>)) != <span class="hljs-string">"quit"</span>:<font></font>
    print(<span class="hljs-string">"You entered:"</span>, command)<font></font>
<font></font>
<span class="hljs-comment"># Capturing regular expression match objects</span>
<span class="hljs-comment"># See, for instance, Lib/pydoc.py, which uses a multiline spelling</span>
<span class="hljs-comment"># of this effect</span>
<span class="hljs-keyword">if</span> match := re.search(pat, text):<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-comment"># The same syntax chains nicely into 'elif' statements, unlike the</span>
<span class="hljs-comment"># equivalent using assignment statements.</span>
<span class="hljs-keyword">elif</span> match := re.search(otherpat, text):<font></font>
    print(<span class="hljs-string">"Alternate found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-keyword">elif</span> match := re.search(third, text):<font></font>
    print(<span class="hljs-string">"Fallback found:"</span>, match.group(<span class="hljs-number">0</span>))<font></font>
<font></font>
<span class="hljs-comment"># Reading socket data until an empty string is returned</span>
<span class="hljs-keyword">while</span> data := sock.recv(<span class="hljs-number">8192</span>):<font></font>
    print(<span class="hljs-string">"Received data:"</span>, data)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insbesondere kann durch diesen Ansatz die Notwendigkeit beseitigt werden, eine Endlosschleife, Zuweisung und Bedingungsprüfung zu erstellen. </font><font style="vertical-align: inherit;">Außerdem können Sie eine glatte Parallele zwischen einem Zyklus zeichnen, der einen Funktionsaufruf als Bedingung verwendet, und einem Zyklus, der nicht nur die Bedingung überprüft, sondern auch den tatsächlichen Wert verwendet, den die Funktion in Zukunft zurückgibt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gabel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Beispiel aus der Low-Level-Welt von UNIX: [ca. </font><font style="vertical-align: inherit;">Fork () ist ein Systemaufruf unter Unix-ähnlichen Betriebssystemen, der einen neuen Unterprozess relativ zum übergeordneten Betriebssystem erstellt.]</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> pid := os.fork():
    <span class="hljs-comment"># Parent code</span>
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># Child code</span></code></pre><br>
<a name="otklon"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abgelehnte Alternativen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen sind ähnliche Vorschläge in der Python-Community weit verbreitet. </font><font style="vertical-align: inherit;">Im Folgenden finden Sie eine Reihe alternativer Syntaxen für Zuweisungsausdrücke, die zu spezifisch sind, um sie zu verstehen, und die zugunsten der oben genannten abgelehnt wurden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern des Bereichs für Generatoren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einer früheren Version dieses PEP wurde vorgeschlagen, die Bereichsregeln für Generatoren geringfügig zu ändern, um sie für die Verwendung im Klassenbereich besser geeignet zu machen. </font><font style="vertical-align: inherit;">Diese Vorschläge würden jedoch zu einer Inkompatibilität führen und wurden daher abgelehnt. </font><font style="vertical-align: inherit;">Daher konnte sich dieser PEP nur auf Zuweisungsausdrücke konzentrieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternative Schreibweisen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen haben die vorgeschlagenen Zuweisungsausdrücke dieselbe Semantik, sind jedoch unterschiedlich geschrieben.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPR als NAME:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[f(x) <span class="hljs-keyword">as</span> y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   EXPR as NAME       import, except  with,         (,       ).<br>
<br>
( ,  «with EXPR as VAR»     EXPR  VAR,   EXPR.__enter__()        VAR.)<br>
<br>
 ,   ":="   :<br>
<ul>
<li>  ,  <b>if f(x) as y</b>     ,    ​​   <b>if f x blah-blah</b>,        <b>if f(x) and y</b>.</li>
<li>   ,  <b>as</b> ,           ,     : <ul>
<li>import foo as bar</li>
<li>except Exc as var</li>
<li>with ctxmgr() as var</li>
</ul><br>
 , <b>as</b>     if  while     ,   <b>as</b>  « »   .</li>
<li>  «»  <ul>
<li>NAME = EXPR</li>
<li>if NAME := EXPR</li>
</ul><br>
     .</li>
</ul></li>
<li>EXPR -&gt; NAME<br>
<br>
<pre><code class="python hljs">stuff = [[f(x) -&gt; y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
     ,  R  Haskell,     . ( ,    - <b>y &lt; — f (x) </b>   Python,      -   .)       «as»   ,      import, except  with,      .             Python (    ),      ":=" (   Algol-58)     .</li>
<li>  «»    <br>
<br>
<pre><code class="python hljs">stuff = [[(f(x) <span class="hljs-keyword">as</span> .y), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with "as"</span>
stuff = [[(.y := f(x)), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with ":="</span></code></pre><br>
         .         Python,        ,   .</li>
<li> where:       :<br>
<br>
<pre><code class="python hljs">value = x**<span class="hljs-number">2</span> + <span class="hljs-number">2</span>*x where:<font></font>
    x = spam(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, q)</code></pre><br>
   (    ,     «»).      ,   «»  (  with:). . PEP 3150,      (    <i>given:</i> ).</li>
<li>TARGET from EXPR:<br>
<br>
<pre><code class="python hljs">stuff = [[y <span class="hljs-keyword">from</span> f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist weniger wahrscheinlich, dass diese Syntax mit anderen in Konflikt steht als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (es sei denn, Sie zählen die Erhöhung von Exc aus Exc-Konstrukten), sie ist jedoch ansonsten mit diesen vergleichbar. </font><font style="vertical-align: inherit;">Anstelle einer Parallele mit mit expr als Ziel: (was nützlich sein kann, aber auch verwirrend sein kann), weist diese Option überhaupt keine Parallelen zu irgendetwas auf, wird aber überraschenderweise besser in Erinnerung behalten.</font></font></li>
</ol><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sonderfälle in bedingten Aussagen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einer der häufigsten Anwendungsfälle für Zuweisungsausdrücke sind die if- und while-Anweisungen. </font><font style="vertical-align: inherit;">Anstelle einer allgemeineren Lösung </font><font style="vertical-align: inherit;">verbessert die </font><font style="vertical-align: inherit;">Verwendung von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Syntax dieser beiden Anweisungen, indem ein Mittel zum Erfassen des zu vergleichenden Werts hinzugefügt wird:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> re.search(pat, text) <span class="hljs-keyword">as</span> match:<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies funktioniert gut, aber </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUR,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn die gewünschte Bedingung auf der "Richtigkeit" des Rückgabewerts basiert. </font><font style="vertical-align: inherit;">Daher ist diese Methode in bestimmten Fällen wirksam (Überprüfung auf reguläre Ausdrücke, Lesen von Sockets, Rückgabe einer leeren Zeichenfolge am Ende der Ausführung) und in komplexeren Fällen (z. B. wenn die Bedingung f (x) &lt;0 ist und Sie möchten) völlig nutzlos Speichern Sie den Wert von f (x)). </font><font style="vertical-align: inherit;">Dies ist auch bei Listengeneratoren nicht sinnvoll. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorteile</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Keine syntaktischen Mehrdeutigkeiten. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachteile</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Auch wenn Sie es nur in if / while-Anweisungen verwenden, funktioniert es nur in einigen Fällen gut.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sonderfälle bei Generatoren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer häufiger Anwendungsfall für Zuweisungsausdrücke sind Generatoren (list / set / dict und genexps). </font><font style="vertical-align: inherit;">Wie oben wurden Vorschläge für spezifische Lösungen gemacht.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wo, lassen oder gegeben:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) where y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) let y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) given y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode führt zu einem Unterausdruck zwischen der for-Schleife und dem Hauptausdruck. </font><font style="vertical-align: inherit;">Außerdem wird ein zusätzliches Sprachschlüsselwort eingeführt, das zu Konflikten führen kann. </font><font style="vertical-align: inherit;">Von den drei Optionen, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die sauberste und lesbar, aber potenzielle Konflikte existieren nach wie vor (zum Beispiel SQLAlchemy und numpy ihre wo Methoden sowie tkinter.dnd.Icon in der Standardbibliothek).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit NAME = EXPR:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
  ,     ,     <b>with</b>.         .   ,           «»  for.    C,         ,    .   : «  «with NAME = EXPR:»       ,   ?»</li>
<li>with EXPR as NAME:<br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> f(x) <span class="hljs-keyword">as</span> y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   ,    <b>as</b>,    .       ,        for.      with          </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unabhängig von der gewählten Methode wird durch eine for-Schleife ein scharfer semantischer Unterschied zwischen Generatoren und ihren bereitgestellten Versionen eingeführt. </font><font style="vertical-align: inherit;">Es wäre unmöglich, den Zyklus in einen Generator zu packen, ohne die Phase der Erstellung der Variablen zu verarbeiten. </font><font style="vertical-align: inherit;">Das einzige Schlüsselwort, das für diese Aufgabe neu ausgerichtet werden könnte, ist das Wort </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies führt jedoch zu einer unterschiedlichen Semantik in verschiedenen Teilen des Codes. Dies bedeutet, dass Sie ein neues Schlüsselwort erstellen müssen. Dies ist jedoch mit hohen Kosten verbunden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Niedrigere Bedienerpriorität</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Operator: = hat zwei logische Prioritäten. Oder es sollte eine möglichst niedrige Priorität haben (auf dem Niveau des Zuweisungsoperators). Oder es sollte Vorrang vor Vergleichsoperatoren haben. Wenn Sie die Priorität zwischen Vergleichsoperatoren und arithmetischen Operationen platzieren (um genau zu sein: etwas niedriger als bitweises ODER), können Sie in den meisten Fällen während und während der Verwendung auf Klammern verzichten, da es wahrscheinlicher ist, dass Sie den Wert von etwas vorher beibehalten möchten wie der Vergleich darauf durchgeführt wird:</font></font><br>
<br>
<pre><code class="python hljs">pos = <span class="hljs-number">-1</span>
<span class="hljs-keyword">while</span> pos := buffer.find(search_term, pos + <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>:<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobald find () -1 zurückgibt, endet die Schleife. </font><font style="vertical-align: inherit;">Wenn: = die Operanden so frei wie = bindet, wird das Ergebnis von find () zuerst im Vergleichsoperator "erfasst" und gibt normalerweise True oder False zurück, was weniger nützlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl dieses Verhalten in der Praxis in vielen Situationen praktisch wäre, wäre es schwieriger zu erklären. </font><font style="vertical-align: inherit;">Und so können wir sagen, dass "der Operator: = sich genauso verhält wie der übliche Zuweisungsoperator". </font><font style="vertical-align: inherit;">Das heißt, die Priorität für: = wurde so nah wie möglich am Operator = gewählt (außer dass: = eine höhere Priorität als das Komma hat).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie geben rechts Kommas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Kritiker argumentieren, dass Zuweisungsausdrücke Tupel ohne zusätzliche Klammern erkennen sollten, damit die beiden Einträge gleichwertig sind:</font></font><br>
<br>
<pre><code class="python hljs">(point := (x, y))<font></font>
(point := x, y)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(In der aktuellen Version des Standards entspricht der letzte Datensatz dem Ausdruck ((Punkt: = x), y).) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist jedoch logisch, dass in dieser Situation der Zuweisungsausdruck im Funktionsaufruf auch eine niedrigere Priorität als das Komma hat wäre die folgende verwirrende Äquivalenz:</font></font><br>
<br>
<pre><code class="python hljs">foo (x: = <span class="hljs-number">1</span>, y)<font></font>
foo (x: = (<span class="hljs-number">1</span>, y))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wir bekommen den einzigen weniger verwirrenden Ausweg: Machen Sie den Operator: = zu einer niedrigeren Priorität als das Komma.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immer Klammern erforderlich</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurde immer vorgeschlagen, die Zuweisungsausdrücke in Klammern zu setzen. </font><font style="vertical-align: inherit;">Dies würde uns viele Unklarheiten ersparen. </font><font style="vertical-align: inherit;">In der Tat werden häufig Klammern benötigt, um den gewünschten Wert zu extrahieren. </font><font style="vertical-align: inherit;">In den folgenden Fällen erschien uns das Vorhandensein von Klammern jedoch eindeutig überflüssig:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Top level in if</span>
<span class="hljs-keyword">if</span> match := pattern.match(line):
    <span class="hljs-keyword">return</span> match.group(<span class="hljs-number">1</span>)<font></font>
<font></font>
<span class="hljs-comment"># Short call</span>
len(lines := f.readlines())</code></pre><br>
<a name="chast"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Häufige Einwände</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum nicht einfach die Zuweisungsanweisungen in Ausdrücke verwandeln?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C und ähnliche Sprachen definieren den Operator </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als Ausdruck und nicht als Anweisung, wie dies Python tut. </font><font style="vertical-align: inherit;">Dies ermöglicht die Zuweisung in vielen Situationen, einschließlich an Orten, an denen Variablen verglichen werden. </font><font style="vertical-align: inherit;">Die syntaktischen Ähnlichkeiten zwischen if (x == y) und if (x = y) widersprechen ihrer stark unterschiedlichen Semantik. </font><font style="vertical-align: inherit;">Daher führt dieser PEP den Operator ein: =, um ihre Unterschiede zu verdeutlichen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum mit Mühe </font><font style="vertical-align: inherit;">Zuweisung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausdrücke</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wenn </font><font style="vertical-align: inherit;">Zuordnung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anweisungen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> existieren </font><font style="vertical-align: inherit;">?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese beiden Formen haben unterschiedliche Flexibilität. </font><font style="vertical-align: inherit;">Der Operator: = kann in einem größeren Ausdruck verwendet werden, und im Operator = kann er von der "Familie der Mini-Operatoren" vom Typ "+ =" verwendet werden. </font><font style="vertical-align: inherit;">Mit = können Sie Werte nach Attributen und Indizes zuweisen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum nicht den lokalen Bereich nutzen und die Verschmutzung von Namespaces verhindern?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frühere Versionen dieses Standards enthielten einen realen lokalen Bereich (auf eine Anweisung beschränkt) für Zuweisungsausdrücke, um Namensverlust und Verschmutzung des Namespace zu verhindern. </font><font style="vertical-align: inherit;">Trotz der Tatsache, dass dies in einigen Situationen einen gewissen Vorteil brachte, erschwert es in vielen anderen die Aufgabe, und die Vorteile sind nicht durch die Vorteile des bestehenden Ansatzes gerechtfertigt. </font><font style="vertical-align: inherit;">Dies geschieht im Interesse der Einfachheit der Sprache. </font><font style="vertical-align: inherit;">Sie brauchen diese Variable nicht mehr? </font><font style="vertical-align: inherit;">Es gibt eine Lösung: Löschen Sie die Variable mit dem Schlüsselwort del oder fügen Sie ihrem Namen einen unteren Unterstrich hinzu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Der Autor möchte Guido van Rossum und Christophe Groth für ihre Vorschläge danken, den PEP-Standard in diese Richtung voranzutreiben. [2])</font></font><br>
<br>
<a name="rekom"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stilempfehlungen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da Zuweisungsausdrücke manchmal mit einem Zuweisungsoperator gleichwertig verwendet werden können, stellt sich die Frage, was noch bevorzugt wird. In Übereinstimmung mit anderen Stilkonventionen (wie PEP 8) gibt es zwei Empfehlungen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie beide Zuweisungsoptionen verwenden können, bevorzugen Sie Operatoren. </font><font style="vertical-align: inherit;">Sie drücken Ihre Absichten am deutlichsten aus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Verwendung von Zuweisungsausdrücken zu Mehrdeutigkeiten in der Ausführungsreihenfolge führt, schreiben Sie den Code mit dem klassischen Operator neu.</font></font></li>
</ol><br>
<a name="blag"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Autoren dieses Standards möchten Nick Coghlan und Steven D'Aprano für ihre bedeutenden Beiträge zu diesem PEP sowie den Mitgliedern der Python Core Mentorship für ihre Hilfe bei der Implementierung danken.</font></font><br>
<br>
<a name="prilA"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang A: Schlussfolgerungen von Tim Peters</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein kurzer Aufsatz, den Tim Peters zu diesem Thema geschrieben hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich mag den "verwirrten" Code nicht und mag es auch nicht, konzeptionell nicht verwandte Logik in eine Zeile zu setzen. </font><font style="vertical-align: inherit;">Also zum Beispiel anstelle von:</font></font><br>
<br>
<pre><code class="python hljs">i = j = count = nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich schreibe lieber:</font></font><br>
<br>
<pre><code class="python hljs">i = j = <span class="hljs-number">0</span>
count = <span class="hljs-number">0</span>
nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher denke ich, dass ich mehrere Stellen finden werde, an denen ich Zuweisungsausdrücke verwenden möchte. </font><font style="vertical-align: inherit;">Ich möchte nicht einmal über ihre Verwendung in Ausdrücken sprechen, die bereits auf die Hälfte des Bildschirms ausgedehnt sind. </font><font style="vertical-align: inherit;">In anderen Fällen kann Folgendes auftreten:</font></font><br>
<br>
<pre><code class="python hljs">mylast = mylast[<span class="hljs-number">1</span>]
<span class="hljs-keyword">yield</span> mylast[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deutlich besser als das:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">yield</span> (mylast := mylast[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese beiden Codes haben völlig unterschiedliche Konzepte und es wäre verrückt, sie zu mischen. </font><font style="vertical-align: inherit;">In anderen Fällen erschwert das Kombinieren logischer Ausdrücke das Verständnis des Codes. </font><font style="vertical-align: inherit;">Beispiel: Umschreiben:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    old = total<font></font>
    total += term<font></font>
    <span class="hljs-keyword">if</span> old == total:
        <span class="hljs-keyword">return</span> total<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einer kürzeren Form haben wir die „Logik“ verloren. </font><font style="vertical-align: inherit;">Sie müssen verstehen, wie dieser Code funktioniert. </font><font style="vertical-align: inherit;">Mein Gehirn will das nicht:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> total != (total := total + term):<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span>
<span class="hljs-keyword">return</span> total</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solche Fälle sind jedoch selten. </font><font style="vertical-align: inherit;">Die Aufgabe, das Ergebnis zu erhalten, ist sehr verbreitet, und „dünn ist besser als dicht“ bedeutet nicht, dass „fast leer ist besser als dünn“ [ca. </font><font style="vertical-align: inherit;">ein Verweis auf Zen Python]. </font><font style="vertical-align: inherit;">Zum Beispiel habe ich viele Funktionen, die None oder 0 zurückgeben, um zu sagen: "Ich habe nichts Nützliches, aber da dies häufig vorkommt, möchte ich Sie nicht mit Ausnahmen belästigen." </font><font style="vertical-align: inherit;">Tatsächlich wird dieser Mechanismus auch in regulären Ausdrücken verwendet, die None zurückgeben, wenn keine Übereinstimmungen vorhanden sind. </font><font style="vertical-align: inherit;">Daher in diesem Beispiel viel Code:</font></font><br>
<br>
<pre><code class="python hljs">result = solution(xs, n)
<span class="hljs-keyword">if</span> result:
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich finde die folgende Option verständlicher und natürlich lesbarer:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> result := solution(xs, n):
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anfangs legte ich nicht viel Wert darauf, aber eine so kurze Konstruktion erschien so oft, dass es mich bald ärgerte, dass ich sie nicht verwenden konnte. </font><font style="vertical-align: inherit;">Es überrascht mich! </font><font style="vertical-align: inherit;">[ca. </font><font style="vertical-align: inherit;">Anscheinend wurde dies geschrieben, bevor Python 3.8 offiziell veröffentlicht wurde.] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt andere Fälle, in denen Zuweisungsausdrücke wirklich "schießen". </font><font style="vertical-align: inherit;">Anstatt noch einmal in meinem Code zu stöbern, gab Kirill Balunov ein gutes Beispiel für die Funktion copy () aus der Standardbibliothek copy.py:</font></font><br>
<br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die immer größer werdende Einrückung ist irreführend: Immerhin ist die Logik flach: Der erste erfolgreiche Test „gewinnt“:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfache Verwendung von Zuweisungsausdrücken ermöglicht es der visuellen Struktur des Codes, die „Ebene“ der Logik hervorzuheben. </font><font style="vertical-align: inherit;">Aber die immer größer werdende Einrückung macht es implizit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein weiteres kleines Beispiel aus meinem Code, das mich sehr gefreut hat, weil ich die intern verknüpfte Logik in eine Zeile setzen und die lästige „künstliche“ Einrückungsstufe entfernen konnte. </font><font style="vertical-align: inherit;">Dies ist genau das, was ich von der if-Anweisung will und es erleichtert das Lesen. </font><font style="vertical-align: inherit;">Der folgende Code:</font></font><br>
<br>
<pre><code class="python hljs">diff = x - x_base
<span class="hljs-keyword">if</span> diff:<font></font>
    g = gcd(diff, n)<font></font>
    <span class="hljs-keyword">if</span> g &gt; <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wurde zu:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> (diff := x - x_base) <span class="hljs-keyword">and</span> (g := gcd(diff, n)) &gt; <span class="hljs-number">1</span>:
    <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten Zeilen, in denen Variablen zugewiesen werden, würde ich keine Zuweisungsausdrücke verwenden. </font><font style="vertical-align: inherit;">Aber dieses Design ist so häufig, dass es immer noch viele Orte gibt, an denen ich diese Gelegenheit nutzen würde. </font><font style="vertical-align: inherit;">In den letzten Fällen habe ich ein wenig gewonnen, wie sie oft erschienen sind. </font><font style="vertical-align: inherit;">Im verbleibenden Teil führte dies zu mittleren oder großen Verbesserungen. </font><font style="vertical-align: inherit;">Daher würde ich Zuweisungsausdrücke viel häufiger als ein Dreifach verwenden, aber viel seltener als eine erweiterte Zuweisung [ca. </font><font style="vertical-align: inherit;">kurze Optionen: * =, / =, + = usw.].</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numerisches Beispiel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe ein anderes Beispiel, das mich früher beeindruckt hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn alle Variablen positive ganze Zahlen sind und die Variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> größer als die n-te Wurzel von x ist, gibt dieser Algorithmus die "niedrigere" Rundung der n-ten Wurzel von x zurück (und verdoppelt ungefähr die Anzahl der exakten Bits pro Iteration):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> a &gt; (d := x // a**(n<span class="hljs-number">-1</span>)):<font></font>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist nicht klar warum, aber eine solche Variante des Algorithmus ist weniger offensichtlich als eine Endlosschleife mit einer bedingten Verzweigungsunterbrechung (eineinhalb Schleifen). Es ist auch schwierig, die Richtigkeit dieser Implementierung zu beweisen, ohne sich auf eine mathematische Aussage („arithmetisches Mittel - geometrische Mittelwertungleichung“) zu stützen und einige nicht triviale Dinge darüber zu wissen, wie sich die verschachtelten Rundungsfunktionen nach unten verhalten. Aber hier liegt das Problem bereits in der Mathematik und nicht in der Programmierung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wenn Sie das alles wissen, ist die Option mit Zuweisungsausdrücken sehr einfach zu lesen, wie ein einfacher Satz: "Überprüfen Sie die aktuelle" Vermutung "und wenn sie zu groß ist, reduzieren Sie sie", und die Bedingung ermöglicht es Ihnen, den Zwischenwert sofort aus der Schleifenbedingung zu speichern. Meiner Meinung nach ist die klassische Form schwerer zu verstehen:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    d = x // a**(n<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">if</span> a &lt;= d:
        <span class="hljs-keyword">break</span>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br>
<a name="prilB"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang B: Ein Grobcode-Interpreter für Generatoren</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Anhang wird versucht, die Regeln zu klären (obwohl nicht angegeben), nach denen eine Variable in Generatorausdrücken erstellt werden soll. </font><font style="vertical-align: inherit;">Für einige anschauliche Beispiele zeigen wir den Quellcode, bei dem der Generator durch eine äquivalente Funktion in Kombination mit einem „Gerüst“ ersetzt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da [x für ...] der Liste entspricht (x für ...), verlieren die Beispiele nicht ihre Allgemeingültigkeit. </font><font style="vertical-align: inherit;">Und da diese Beispiele nur zur Verdeutlichung der allgemeinen Regeln dienen sollen, erheben sie keinen Anspruch auf Realität.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis: Generatoren werden jetzt durch die Erstellung verschachtelter Generatorfunktionen implementiert (ähnlich den in diesem Anhang angegebenen). </font><font style="vertical-align: inherit;">Die Beispiele zeigen den neuen Teil, der die entsprechende Funktionalität für die Arbeit mit dem Bereich der Zuweisungsausdrücke hinzufügt (z. B., wenn die Zuweisung in einem Block ausgeführt wurde, der den externesten Generator enthält). </font><font style="vertical-align: inherit;">Um die „Typinferenz“ zu vereinfachen, berücksichtigen diese veranschaulichenden Beispiele nicht, dass Zuweisungsausdrücke optional sind (sie berücksichtigen jedoch den Umfang der im Generator erstellten Variablen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnern wir uns zunächst daran, welcher Code für Generatoren ohne Zuweisungsausdrücke „unter der Haube“ generiert wird:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellcode (EXPR verwendet am häufigsten die VAR-Variable):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der konvertierte Code (machen wir uns keine Sorgen um Namenskonflikte):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:
            <span class="hljs-keyword">yield</span> EXPR<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen wir einen einfachen Zuweisungsausdruck hinzu.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvertierter Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Dead code to ensure TARGET is a local variable</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen wir nun die globale TARGET-Anweisung zur Deklaration der Funktion f () hinzu.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET<font></font>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvertierter Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">global</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oder umgekehrt, fügen wir der Deklaration der Funktion f () nichtlokales ZIEL hinzu.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET<font></font>
        a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvertierter Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
                TARGET = EXPR<font></font>
                <span class="hljs-keyword">yield</span> TARGET<font></font>
        a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns zum Schluss zwei Generatoren einsetzen.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [[TARGET := i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>)]
    <span class="hljs-comment"># I.e., a = [[0, 1, 2], [0, 1, 2]]</span>
    print(TARGET)  <span class="hljs-comment"># prints 2</span>
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvertierter Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer_genexpr</span>(<span class="hljs-params">outer_iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner_generator</span>(<span class="hljs-params">inner_iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> inner_iterator:<font></font>
                TARGET = i<font></font>
                <span class="hljs-keyword">yield</span> i
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> outer_iterator:
            <span class="hljs-keyword">yield</span> list(inner_generator(range(<span class="hljs-number">3</span>)))<font></font>
    a = list(outer_genexpr(range(<span class="hljs-number">2</span>)))<font></font>
    print(TARGET)</code></pre></li>
</ul><br>
<a name="prilC"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang C: Keine Änderungen in der Umfangssemantik</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass sich die Umfangssemantik in Python nicht geändert hat. </font><font style="vertical-align: inherit;">Der Umfang lokaler Funktionen wird zur Kompilierungszeit noch festgelegt und hat zur Laufzeit einen unbegrenzten Zeitumfang (Closure). </font><font style="vertical-align: inherit;">Beispiel:</font></font><br>
<br>
<pre><code class="python hljs">a = <span class="hljs-number">42</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-comment"># `a` is local to `f`, but remains unbound</span>
    <span class="hljs-comment"># until the caller executes this genexp:</span>
    <span class="hljs-keyword">yield</span> ((a := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>))
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">lambda</span>: a + <span class="hljs-number">100</span>
    print(<span class="hljs-string">"done"</span>)
    <span class="hljs-keyword">try</span>:<font></font>
        print(<span class="hljs-string">f"`a` is bound to <span class="hljs-subst">{a}</span>"</span>)
        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">except</span> UnboundLocalError:<font></font>
        print(<span class="hljs-string">"`a` is not yet bound"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span>results = list(f()) <span class="hljs-comment"># [genexp, lambda]</span><font></font>
done<font></font>
`a` <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> yet bound
<span class="hljs-comment"># The execution frame for f no longer exists in CPython,</span>
<span class="hljs-comment"># but f's locals live so long as they can still be referenced.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>list(map(type, results))<font></font>
[&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">generator</span>'&gt;, &lt;<span class="hljs-title">class</span> '<span class="hljs-title">function</span>'&gt;]
&gt;&gt;&gt; <span class="hljs-title">list</span>(<span class="hljs-params">results[<span class="hljs-number">0</span>]</span>)
[0, 1, 2]
&gt;&gt;&gt; <span class="hljs-title">results</span>[1]()
102
&gt;&gt;&gt; <span class="hljs-title">a</span>
42</span></code></pre><br>
<a name="ssilki"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachweis der Konzeptumsetzung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diskussion der Semantik von Zuweisungsausdrücken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (VPN ist eng aber geladen)</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diskussion von TargetScopeError in PEP 572</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ähnlich wie im vorherigen geladen)</font></font></li>
</ol><br>
<a name="avtori"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urheberrechte ©</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Dokument wurde öffentlich zugänglich gemacht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/python/peps/blob/master/pep-0572.rst</font></font></a><br>
<br>
<a name="my"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mein Teil</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns zunächst zusammenfassen:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit die </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menschen nicht versuchen</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die semantische Dualität zu entfernen, gibt es an vielen „klassischen“ Stellen, an denen sowohl „=“ als auch „: =“ verwendet werden können, Einschränkungen. Daher sollte der Operator :: = häufig in Klammern gesetzt werden. </font><font style="vertical-align: inherit;">Diese Fälle müssen im Abschnitt </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">über die grundlegende Verwendung</font></a><font style="vertical-align: inherit;"> überprüft werden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Priorität von Zuweisungsausdrücken ist etwas höher als die eines Kommas. </font><font style="vertical-align: inherit;">Aus diesem Grund werden während der Zuweisung keine Tupel gebildet. </font><font style="vertical-align: inherit;">Es ermöglicht auch die Verwendung des Operators: =, wenn Argumente an eine Funktion übergeben werden.</font></font></li>
<li> ,   ,    ,    .       .    lambda    ,    «»  .</li>
<li>        :   ,     </li>
<li>      ,   .</li>
<li>          /  .</li>
<li>   ,      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende möchte ich sagen, dass mir der neue Operator gefallen hat. </font><font style="vertical-align: inherit;">Es ermöglicht Ihnen, flacheren Code unter Bedingungen zu schreiben, Listen zu filtern und (endlich) die gleiche, einsame Zeile zu entfernen, bevor if. </font><font style="vertical-align: inherit;">Wenn Benutzer Zuweisungsausdrücke für ihren beabsichtigten Zweck verwenden, ist dies ein sehr praktisches Werkzeug, das die Lesbarkeit und Schönheit des Codes verbessert (obwohl dies für jede funktionale Sprache gesagt werden kann ...).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499654/index.html">Wie implementiere ich CRM auf einem Remote-Standort und gewinne?</a></li>
<li><a href="../de499656/index.html">Simulation des PID-Temperaturreglers</a></li>
<li><a href="../de499658/index.html">Ein Arbeiter statt eines Testers? Lohnt es sich, 2020 Selen zu studieren?</a></li>
<li><a href="../de499662/index.html">Root-of-Trust für IoT und andere IoT-Sicherheitstrends</a></li>
<li><a href="../de499664/index.html">Portieren von APIs nach TypeScript als Problemlöser</a></li>
<li><a href="../de499668/index.html">Road to Hell JavaScript-Abhängigkeiten</a></li>
<li><a href="../de499670/index.html">Я перехожу на JavaScript</a></li>
<li><a href="../de499674/index.html">Ein weiterer Schritt zu optischen Computern</a></li>
<li><a href="../de499676/index.html">Über 90 nützliche Tools für Kubernetes: Bereitstellung, Verwaltung, Überwachung, Sicherheit und mehr</a></li>
<li><a href="../de499680/index.html">Kubernetes lernen: Basic 14.-16. Mai, Advanced 18.-20. Mai</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>