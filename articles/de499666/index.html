<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õ©Ô∏è ‚õΩÔ∏è üëâüèΩ PEP 572 (Zuweisungsausdr√ºcke in Python 3.8) üë∞üèΩ üíÜüèª üöÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. Dieses Mal werden wir uns PEP 572 ansehen, in dem es um Zuweisungsausdr√ºcke geht. Wenn Sie dem Operator ": =" immer noch skeptisch gegen√ºb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PEP 572 (Zuweisungsausdr√ºcke in Python 3.8)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499666/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr. </font><font style="vertical-align: inherit;">Dieses Mal werden wir uns PEP 572 ansehen, in dem es um Zuweisungsausdr√ºcke geht. </font><font style="vertical-align: inherit;">Wenn Sie dem Operator ": =" immer noch skeptisch gegen√ºberstehen oder die Regeln f√ºr seine Verwendung nicht vollst√§ndig verstehen, ist dieser Artikel genau das Richtige f√ºr Sie. </font><font style="vertical-align: inherit;">Hier finden Sie viele Beispiele und Antworten auf die Frage: "Warum ist das so?" </font><font style="vertical-align: inherit;">Dieser Artikel hat sich als so vollst√§ndig wie m√∂glich herausgestellt. Wenn Sie wenig Zeit haben, schauen Sie sich den Abschnitt an, den ich geschrieben habe. </font><font style="vertical-align: inherit;">Zu Beginn werden die wichtigsten ‚ÄûThesen‚Äú f√ºr eine bequeme Arbeit mit Zuordnungsausdr√ºcken gesammelt. </font><font style="vertical-align: inherit;">Verzeihen Sie mir im Voraus, wenn Sie Fehler finden (schreiben Sie mir dar√ºber, ich werde es beheben). </font><font style="vertical-align: inherit;">Lasst uns beginnen:</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEP 572 - Zuweisungsausdr√ºcke</font></font></h2><div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pep</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">572</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Titel:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuweisungsausdr√ºcke</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autoren:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Angelico &lt;rosuav at gmail.com&gt;, Tim Peters &lt;tim.peters at gmail.com&gt;, Guido van Rossum &lt;guido at python.org&gt;</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diskussion:</font></font></b></td>
<td><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doc-sig bei python.org</font></font></a></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akzeptiert</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Art:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellt:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28.02.2018</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python-Version:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.8</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beitragsgeschichte:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28-Feb-2018, 02-Mar-2018, 23-Mar-2018, 04-Apr-2018, 17-Apr-2018, 25-Apr-2018, 09-Jul-2018, 05-Aug-2019</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erlaubnis zur √úbernahme des Standards:</font></font></b></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mail.python.org/pipermail/python-dev/2018-July/154601.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (mit VPN f√ºr eine lange Zeit, aber es wird </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">geladen</font></a><font style="vertical-align: inherit;"> )</font></font></td>
</tr>
</tbody></table></div><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalt</font></font></b><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anmerkung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rechtfertigung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax und Semantik</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spezifikations√§nderungen w√§hrend der Implementierung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abgelehnte Alternativen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√§ufige Einw√§nde</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stilempfehlungen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang A: Schlussfolgerungen von Tim Peters</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang B: Ein Grobcode-Interpreter f√ºr Generatoren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang C: Keine √Ñnderungen in der Umfangssemantik</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urheberrechte ¬©</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mein Teil</font></font></a></li>
</ul><br>
<a name="ann"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anmerkung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Konvention wird √ºber die M√∂glichkeit der Zuweisung innerhalb von Ausdr√ºcken unter Verwendung der neuen Notation NAME: = expr sprechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Rahmen der Innovationen wurde das Verfahren zur Berechnung der W√∂rterbuchgeneratoren (W√∂rterbuchverst√§ndnis) aktualisiert. Dadurch wird sichergestellt, dass der Schl√ºsselausdruck vor dem Wertausdruck ausgewertet wird (auf diese Weise k√∂nnen Sie den Schl√ºssel an eine Variable binden und die erstellte Variable dann f√ºr die Berechnung des dem Schl√ºssel entsprechenden Werts wiederverwenden). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend einer Diskussion dieses PEP wurde dieser Operator inoffiziell als Walross-Operator bekannt. Der formale Name des Konstrukts lautet "Zuweisungsausdruck" (gem√§√ü der √úberschrift PEP: Zuweisungsausdr√ºcke), kann jedoch als "Benannte Ausdr√ºcke" bezeichnet werden. Beispielsweise verwendet die Referenzimplementierung in CPython genau diesen Namen.</font></font><br>
<br>
<a name="oboc"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rechtfertigung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Benennung ist ein wichtiger Bestandteil der Programmierung, mit dem Sie anstelle eines l√§ngeren Ausdrucks einen ‚Äûbeschreibenden‚Äú Namen verwenden und die Wiederverwendung von Werten vereinfachen k√∂nnen. </font><font style="vertical-align: inherit;">Derzeit kann dies nur in Form von Anweisungen erfolgen, wodurch diese Operation beim Generieren von Listen (Listenverst√§ndnis) sowie in anderen Ausdr√ºcken nicht verf√ºgbar ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus kann das Benennen von Teilen eines gro√üen Ausdrucks beim interaktiven Debuggen hilfreich sein, indem Tools zum Anzeigen von Eingabeaufforderungen und Zwischenergebnissen bereitgestellt werden. </font><font style="vertical-align: inherit;">Ohne die M√∂glichkeit, die Ergebnisse verschachtelter Ausdr√ºcke zu erfassen, m√ºssen Sie den Quellcode √§ndern. Mit den Zuweisungsausdr√ºcken m√ºssen Sie jedoch nur einige "Marker" der Form "name: = expression" einf√ºgen. </font><font style="vertical-align: inherit;">Dies eliminiert unn√∂tiges Refactoring und verringert daher die Wahrscheinlichkeit unbeabsichtigter Code√§nderungen w√§hrend des Debuggens (eine h√§ufige Ursache f√ºr Heisenbugs sind Fehler, die die Eigenschaften des Codes w√§hrend des Debuggens √§ndern und m√∂glicherweise unerwartet in der Produktion auftreten), und dieser Code ist f√ºr einen anderen verst√§ndlicher an den Programmierer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bedeutung von echtem Code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend der Entwicklung dieses PEP konzentrierten sich viele Menschen (sowohl Bef√ºrworter als auch Kritiker) zu sehr auf Spielzeugbeispiele einerseits und zu komplexe Beispiele andererseits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Gefahr von Spielzeugbeispielen besteht in zweierlei Hinsicht: Sie sind oft zu abstrakt, um jemanden sagen zu lassen: ‚ÄûOh, das ist unwiderstehlich‚Äú, und sie werden auch leicht mit den Worten ‚ÄûDas w√ºrde ich niemals schreiben‚Äú abgelehnt. Die Gefahr zu komplexer Beispiele besteht darin, dass sie Kritikern eine bequeme Umgebung bieten, in der vorgeschlagen wird, diese Funktionalit√§t zu entfernen (‚ÄûDas ist zu verwirrend‚Äú, sagen solche Leute). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solche Beispiele sind jedoch sinnvoll: Sie helfen, die beabsichtigte Semantik zu verdeutlichen. Daher werden wir im Folgenden einige davon nennen. Um jedoch zu </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºberzeugen</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , m√ºssen Beispiele auf basieren</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">echter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code, der geschrieben wurde, ohne √ºber diesen PEP nachzudenken. Das hei√üt, der Code, der Teil einer wirklich n√ºtzlichen Anwendung ist (kein Unterschied: ob gro√ü oder klein). Tim Peters hat uns sehr geholfen, indem er sich seine pers√∂nlichen Repositories angesehen und Beispiele f√ºr den von ihm geschriebenen Code ausgew√§hlt hat, der (seiner Meinung nach) verst√§ndlicher w√§re, wenn sie (ohne Fanatismus) mit Zuweisungsausdr√ºcken umgeschrieben w√ºrden. Sein Fazit lautet: Die aktuellen √Ñnderungen w√ºrden eine bescheidene, aber offensichtliche Verbesserung einiger Teile seines Codes bewirken. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Beispiel f√ºr echten Code ist die indirekte Beobachtung, wie Programmierer Kompaktheit sch√§tzen. Guido van Rossum √ºberpr√ºfte die Dropbox-Codebasis und fand Hinweise darauf, dass Programmierer lieber weniger Codezeilen schreiben als ein paar kleine Ausdr√ºcke.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel: Guido hat mehrere veranschaulichende Punkte gefunden, wenn ein Programmierer einen Unterausdruck wiederholt (wodurch das Programm verlangsamt wird), aber eine zus√§tzliche Codezeile speichert. </font><font style="vertical-align: inherit;">Zum Beispiel anstatt zu schreiben:</font></font><br>
<br>
<pre><code class="python hljs">match = re.match(data)<font></font>
group = match.group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> match <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Programmierer bevorzugten diese Option:</font></font><br>
<br>
<pre><code class="python hljs">group = re.match(data).group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> re.match(data) <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein weiteres Beispiel, das zeigt, dass Programmierer manchmal bereit sind, mehr Arbeit zu leisten, um die ‚Äûvorherige Ebene‚Äú der Einr√ºckung beizubehalten:</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)<font></font>
match2 = pattern2.match(data)<font></font>
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">elif</span> match2:<font></font>
    result = match2.group(<span class="hljs-number">2</span>)
<span class="hljs-keyword">else</span>:<font></font>
    result = <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code berechnet Muster2, auch wenn Muster1 bereits √ºbereinstimmt (in diesem Fall wird die zweite Unterbedingung niemals erf√ºllt). </font><font style="vertical-align: inherit;">Daher ist die folgende L√∂sung effektiver, aber weniger attraktiv:</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">else</span>:<font></font>
    match2 = pattern2.match(data)<font></font>
    <span class="hljs-keyword">if</span> match2:<font></font>
        result = match2.group(<span class="hljs-number">2</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        result = <span class="hljs-literal">None</span></code></pre><br>
<a name="sint"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax und Semantik</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten F√§llen, in denen Python beliebige Ausdr√ºcke verwendet, k√∂nnen Sie jetzt Zuweisungsausdr√ºcke verwenden. </font><font style="vertical-align: inherit;">Sie haben die Form NAME: = Ausdruck, wobei Ausdruck ein beliebiger g√ºltiger Python-Ausdruck ist, mit Ausnahme des nicht parenthesierten Tupels, und NAME der Bezeichner ist. </font><font style="vertical-align: inherit;">Der Wert eines solchen Ausdrucks stimmt mit dem Original √ºberein, ein zus√§tzlicher Effekt ist jedoch die Zuweisung eines Werts zum Zielobjekt:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Handle a matched regex</span>
<span class="hljs-keyword">if</span> (match := pattern.search(data)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
    <span class="hljs-comment"># Do something with match</span><font></font>
<font></font>
<span class="hljs-comment"># A loop that can't be trivially rewritten using 2-arg iter()</span>
<span class="hljs-keyword">while</span> chunk := file.read(<span class="hljs-number">8192</span>):<font></font>
   process(chunk)<font></font>
<font></font>
<span class="hljs-comment"># Reuse a value that's expensive to compute</span>
[y := f(x), y**<span class="hljs-number">2</span>, y**<span class="hljs-number">3</span>]<font></font>
<font></font>
<span class="hljs-comment"># Share a subexpression between a comprehension filter clause and its output</span>
filtered_data = [y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data <span class="hljs-keyword">if</span> (y := f(x)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]</code></pre><br>
<a name="iskluch"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmef√§llen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt mehrere Stellen, an denen Zuweisungsausdr√ºcke nicht zul√§ssig sind, um Mehrdeutigkeiten oder Verwirrung unter den Benutzern zu vermeiden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuweisungsausdr√ºcke, die nicht in Klammern stehen, sind auf der ‚Äûoberen‚Äú Ebene verboten:</font></font><br>
<br>
<pre><code class="python hljs">y := f(x)  <span class="hljs-comment"># </span>
(y := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Regel erleichtert dem Programmierer die Auswahl zwischen einem Zuweisungsoperator und einem Zuweisungsausdruck. Es gibt keine syntaktische Situation, in der beide Optionen gleichwertig sind.</font></font></li>
<li>           . :<br>
<br>
<pre><code class="python hljs">y0 = y1 := f(x)  <span class="hljs-comment"># </span>
y0 = (y1 := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br>
             . :<br>
<br>
<pre><code class="python hljs">foo(x = y := f(x))  <span class="hljs-comment"># </span>
foo(x=(y := f(x)))  <span class="hljs-comment"># ,     </span></code></pre><br>
 ,               .</li>
<li>           . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer = p := <span class="hljs-number">42</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer=(<span class="hljs-params">p := <span class="hljs-number">42</span></span>)</span>):</span>  <span class="hljs-comment"># Valid, though not great style</span>
    ...</code></pre><br>
        ,           (.    ,     ¬´¬ª     ).</li>
<li>           ,    . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: p := <span class="hljs-number">42</span> = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: (<span class="hljs-params">p := <span class="hljs-number">42</span></span>) = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># ,  </span>
    ...</code></pre><br>
       : ,     "="  ":="   .</li>
<li>        -. :<br>
<br>
<pre><code class="python hljs">(<span class="hljs-keyword">lambda</span>: x := <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span>: (x := <span class="hljs-number">1</span>) <span class="hljs-comment"># ,  </span>
(x := <span class="hljs-keyword">lambda</span>: <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span> line: (m := re.match(pattern, line)) <span class="hljs-keyword">and</span> m.group(<span class="hljs-number">1</span>) <span class="hljs-comment"># Valid</span></code></pre><br>
-    ,  ":=".       .  ,     ,    ()  ,         .</li>
<li>   f-  . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{(x:=<span class="hljs-number">10</span>)}</span>'</span>  <span class="hljs-comment"># ,  </span>
<span class="hljs-string">'10'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-number">10</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{x:=<span class="hljs-number">10</span>}</span>'</span>    <span class="hljs-comment"># ,  ,  '=10'</span>
<span class="hljs-string">'        10'</span></code></pre><br>
 ,    ,     f-,  .  f-   ":"    .    ,      f-      .     ,      .</li>
</ul><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Zuweisungsausdruck f√ºhrt keinen neuen Bereich ein. In den meisten F√§llen muss der Bereich, in dem die Variable erstellt wird, nicht erl√§utert werden: Sie ist aktuell. Wenn die Variable zuvor die nichtlokalen oder globalen Schl√ºsselw√∂rter verwendet hat, ber√ºcksichtigt der Zuweisungsausdruck dies. Nur Lambda (eine anonyme Definition einer Funktion) wird f√ºr diese Zwecke als separater Bereich betrachtet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen Sonderfall: Ein Zuweisungsausdruck, der in Generatoren von Listen, Mengen, W√∂rterb√ºchern oder in den ‚ÄûAusdr√ºcken von Generatoren‚Äú selbst (im Folgenden zusammenfassend als ‚ÄûGeneratoren‚Äú (Verst√§ndnis) bezeichnet) vorkommt, bindet die Variable unter Ber√ºcksichtigung des Globab-Modifikators an den Bereich, den der Generator enth√§lt oder nicht global, falls vorhanden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr diesen Sonderfall gibt es zwei Gr√ºnde. </font><font style="vertical-align: inherit;">Erstens k√∂nnen wir das ‚ÄûMitglied‚Äú bequem in den Ausdr√ºcken any () und all () erfassen, zum Beispiel:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> any((comment := line).startswith(<span class="hljs-string">'#'</span>) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"First comment:"</span>, comment)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"There are no comments"</span>)<font></font>
<font></font>
<span class="hljs-keyword">if</span> all((nonblank := line).strip() == <span class="hljs-string">''</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"All lines are blank"</span>)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"First non-blank line:"</span>, nonblank)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens bietet es eine kompakte M√∂glichkeit, eine Variable von einem Generator zu aktualisieren, zum Beispiel:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Compute partial sums in a list comprehension</span>
total = <span class="hljs-number">0</span>
partial_sums = [total := total + v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values]<font></font>
print(<span class="hljs-string">"Total:"</span>, total)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Name der Variablen aus dem Zuweisungsausdruck kann jedoch nicht mit dem Namen √ºbereinstimmen, der bereits in Generatoren von der for-Schleife zum Iterieren verwendet wird. </font><font style="vertical-align: inherit;">Die Nachnamen sind lokal f√ºr den Generator, in dem sie erscheinen. </font><font style="vertical-align: inherit;">Es w√§re inkonsistent, wenn sich die Zuweisungsausdr√ºcke auch auf den Bereich innerhalb des Generators beziehen w√ºrden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel ist [i: = i + 1 f√ºr i in Bereich (5)] nicht g√ºltig: Die for-Schleife bestimmt, dass i lokal f√ºr den Generator ist, aber der Teil ‚Äûi: = i + 1‚Äú besteht darauf, dass i eine Variable von au√üen ist Umfang </font><font style="vertical-align: inherit;">Aus dem gleichen Grund funktionieren die folgenden Beispiele nicht:</font></font><br>
<br>
<pre><code class="python hljs">
[[(j := j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># </span>
[i := <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]                       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (i := stuff)]                      <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl es technisch m√∂glich ist, f√ºr solche F√§lle eine konsistente Semantik zuzuweisen, ist es schwierig zu bestimmen, ob die Art und Weise, wie wir diese Semantik verstehen, in Ihrem realen Code funktioniert. Aus diesem Grund stellt die Referenzimplementierung sicher, dass solche F√§lle SyntaxError ausl√∂sen und nicht mit undefiniertem Verhalten ausgef√ºhrt werden, abh√§ngig von der jeweiligen Hardwareimplementierung. Diese Einschr√§nkung gilt auch dann, wenn ein Zuweisungsausdruck niemals ausgef√ºhrt wird:</font></font><br>
<br>
<pre><code class="python hljs">[<span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> (i := <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]     <span class="hljs-comment"># </span>
[i <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff <span class="hljs-keyword">if</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> (j := <span class="hljs-number">1</span>)]  <span class="hljs-comment"># </span><font></font>
<font></font>
<span class="hljs-comment"># [.  . - ""   </span>
<span class="hljs-comment"># ,       </span>
<span class="hljs-comment"># ,    ,   ]</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr den Generatork√∂rper (den Teil vor dem ersten Schl√ºsselwort "f√ºr") und den Filterausdruck (den Teil nach dem "wenn" und vor einem verschachtelten "f√ºr") gilt diese Einschr√§nkung ausschlie√ülich f√ºr Variablennamen, die gleichzeitig als iterative Variablen verwendet werden. Wie bereits erw√§hnt, f√ºhren Lambda-Ausdr√ºcke einen neuen expliziten Funktionsumfang ein und k√∂nnen daher ohne zus√§tzliche Einschr√§nkungen in Ausdr√ºcken von Generatoren verwendet werden. [ca. wieder, au√üer in solchen F√§llen: [i f√ºr i im Bereich (2, (Lambda: (s: = 2) ())]]</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund von Designbeschr√§nkungen in der Referenzimplementierung (der Symboltabellenanalysator kann nicht erkennen, ob die Namen aus dem linken Teil des Generators in dem verbleibenden Teil verwendet werden, in dem sich der iterierbare Ausdruck befindet), sind Zuweisungsausdr√ºcke als Teil von iterable (in dem Teil nach jedem "in" und "vollst√§ndig verboten) vor jedem nachfolgenden Schl√ºsselwort "if" oder "for"). </font><font style="vertical-align: inherit;">Das hei√üt, alle diese F√§lle sind inakzeptabel:</font></font><br>
<br>
<pre><code class="python hljs">[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (j := stuff)]                    <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]  <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [j <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]]       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-keyword">lambda</span>: (j := stuff))()]        <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere Ausnahme tritt auf, wenn ein Zuweisungsausdruck in Generatoren verwendet wird, die sich im Bereich einer Klasse befinden. </font><font style="vertical-align: inherit;">Wenn bei Verwendung der oben genannten Regeln eine im Bereich neu gemessene Klasse erstellt werden soll, ist ein solcher Zuweisungsausdruck ung√ºltig und f√ºhrt zu einem SyntaxError:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>:</span>
    [(j := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]  <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Der Grund f√ºr die letzte Ausnahme ist der implizite Umfang der vom Generator erstellten Funktion. Derzeit gibt es keinen Laufzeitmechanismus f√ºr Funktionen, die auf eine Variable im Bereich der Klasse verweisen, und wir m√∂chten keinen solchen Mechanismus hinzuf√ºgen. Wenn dieses Problem jemals gel√∂st wird, In diesem Fall wird dieser Sonderfall (m√∂glicherweise) aus der Spezifikation der Zuweisungsausdr√ºcke entfernt. Beachten Sie, dass dieses Problem auch dann auftritt, wenn Sie eine Variable fr√ºher im Bereich der Klasse erstellt haben und versuchen, sie mit einem Zuweisungsausdruck aus dem Generator zu √§ndern.) Beispiele dazu finden </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie in Anhang B. In Generatoren gefundene Zuweisungsausdr√ºcke werden in √§quivalenten Code konvertiert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relative Priorit√§t: =</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Operator: = wird nach M√∂glichkeit in allen syntaktischen Positionen st√§rker als das Komma gruppiert, aber schw√§cher als alle anderen Operatoren, einschlie√ülich oder und und nicht, und bedingte Ausdr√ºcke (A wenn C sonst B). Wie aus dem obigen Abschnitt ‚ÄûAusnahmef√§lle‚Äú hervorgeht, funktionieren Zuweisungsausdr√ºcke niemals auf derselben ‚ÄûEbene‚Äú wie die klassische Zuweisung =. Wenn eine andere Reihenfolge der Operationen erforderlich ist, verwenden Sie Klammern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Operator: = kann direkt beim Aufrufen des Positionsarguments einer Funktion verwendet werden. Dies funktioniert jedoch nicht direkt im Argument. Einige Beispiele, die verdeutlichen, was technisch zul√§ssig und was nicht m√∂glich ist:</font></font><br>
<br>
<pre><code class="python hljs">x := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
(x := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
x = y := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
x = (y := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
len(lines := f.readlines()) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(x := <span class="hljs-number">3</span>, cat=<span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=category := <span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=(category := <span class="hljs-string">'vector'</span>)) <span class="hljs-comment">#  </span></code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die meisten der oben genannten ‚Äûg√ºltigen‚Äú Beispiele werden f√ºr die Verwendung in der Praxis nicht empfohlen, da Personen, die Ihren Quellcode schnell scannen, dessen Bedeutung m√∂glicherweise nicht richtig verstehen. </font><font style="vertical-align: inherit;">In einfachen F√§llen ist dies jedoch zul√§ssig:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Valid</span>
<span class="hljs-keyword">if</span> any(len(longline := line) &gt;= <span class="hljs-number">100</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"Extremely long line:"</span>, longline)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem PEP wird empfohlen, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unbedingt immer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leerzeichen um: = zu setzen, √§hnlich der Empfehlung von PEP 8 f√ºr = f√ºr die klassische Zuweisung. </font><font style="vertical-align: inherit;">(Der Unterschied zur letzten Empfehlung besteht darin, dass Leerzeichen um = verboten werden, mit denen Schl√ºsselargumente an die Funktion √ºbergeben werden.)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie die Reihenfolge der Berechnungen.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um eine genau definierte Semantik zu haben, erfordert diese Vereinbarung, dass das Bewertungsverfahren klar definiert ist. </font><font style="vertical-align: inherit;">Technisch ist dies keine neue Anforderung. </font><font style="vertical-align: inherit;">Python hat bereits die Regel, dass Unterausdr√ºcke normalerweise von links nach rechts ausgewertet werden. </font><font style="vertical-align: inherit;">Zuweisungsausdr√ºcke machen diese ‚ÄûNebenwirkungen‚Äú jedoch deutlicher, und wir schlagen eine √Ñnderung in der aktuellen Berechnungsreihenfolge vor:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In W√∂rterbuchgeneratoren {X: Y f√ºr ...} wird Y derzeit vor X ausgewertet. Wir empfehlen, dies so zu √§ndern, dass X vor Y berechnet wird. (In einem klassischen Dikt wie {X: Y} sowie in dikt ((X, Y) f√ºr ...) Dies wurde bereits implementiert. Daher m√ºssen W√∂rterbuchgeneratoren diesen Mechanismus einhalten.)</font></font></li>
</ul><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschiede zwischen Zuweisungsausdr√ºcken und Zuweisungsanweisungen.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am wichtigsten ist, dass ": =" ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausdruck ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was bedeutet, dass er in F√§llen verwendet werden kann, in denen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anweisungen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ung√ºltig sind, einschlie√ülich Lambda-Funktionen und Generatoren. </font><font style="vertical-align: inherit;">Im Gegensatz dazu </font><font style="vertical-align: inherit;">Zuweisung </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausdr√ºcke</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht unterst√ºtzen die erweiterte Funktionalit√§t , </font><font style="vertical-align: inherit;">die in verwendet werden kann </font><font style="vertical-align: inherit;">Zuordnung </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anweisungen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die kaskadierende Zuweisung wird nicht direkt unterst√ºtzt</font></font><br>
<br>
<pre><code class="python hljs">x = y = z = <span class="hljs-number">0</span>  <span class="hljs-comment"># Equivalent: (z := (y := (x := 0)))</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separate "Ziele" werden mit Ausnahme des einfachen Variablennamens NAME nicht unterst√ºtzt:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># No equivalent</span><font></font>
a[i] = x<font></font>
self.rest = []</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionalit√§t und Priorit√§t "um" Kommas unterscheiden sich:</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>  <span class="hljs-comment"># Sets x to (1, 2)</span>
(x := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># Sets x to 1</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auspacken und Verpackungswerte haben keine ‚Äûreine‚Äú √Ñquivalenz oder werden √ºberhaupt nicht unterst√ºtzt</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Equivalent needs extra parentheses</span>
loc = x, y  <span class="hljs-comment"># Use (loc := (x, y))</span>
info = name, phone, *rest  <span class="hljs-comment"># Use (info := (name, phone, *rest))</span><font></font>
<font></font>
<span class="hljs-comment"># No equivalent</span><font></font>
px, py, pz = position<font></font>
name, phone, email, *other_info = contact</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inline-Typanmerkungen werden nicht unterst√ºtzt:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Closest equivalent is "p: Optional[int]" as a separate declaration</span>
p: Optional[int] = <span class="hljs-literal">None</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keine verk√ºrzte Form von Operationen:</font></font><br>
<br>
<pre><code class="python hljs">total += tax  <span class="hljs-comment"># Equivalent: (total := total + tax)</span></code></pre></li>
</ul><br>
<a name="cpec"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spezifikations√§nderungen w√§hrend der Implementierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden √Ñnderungen wurden basierend auf unseren Erfahrungen und zus√§tzlichen Analysen nach dem ersten Schreiben dieses PEP und vor der Ver√∂ffentlichung von Python 3.8 vorgenommen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Konsistenz mit anderen √§hnlichen Ausnahmen zu gew√§hrleisten und keinen neuen Namen einzuf√ºhren, der f√ºr Endbenutzer m√∂glicherweise nicht geeignet ist, wurde die urspr√ºnglich vorgeschlagene Unterklasse von TargetScopeError for SyntaxError entfernt und auf den √ºblichen SyntaxError reduziert. </font><font style="vertical-align: inherit;">[3]</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund von Einschr√§nkungen beim Parsen der CPython-Zeichentabelle l√∂st die Referenzimplementierung des Zuweisungsausdrucks einen SyntaxError f√ºr alle Verwendungen innerhalb von Iteratoren aus. </font><font style="vertical-align: inherit;">Bisher trat diese Ausnahme nur auf, wenn der Name der zu erstellenden Variablen mit dem bereits im iterativen Ausdruck verwendeten √ºbereinstimmte. </font><font style="vertical-align: inherit;">Dies kann √ºberarbeitet werden, wenn ausreichend √ºberzeugende Beispiele vorliegen, die zus√§tzliche Komplexit√§t jedoch f√ºr rein ‚Äûhypothetische‚Äú Anwendungsf√§lle ungeeignet erscheint.</font></font></li>
</ul><br>
<a name="prim"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele f√ºr Python-Standardbibliotheken</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
env_base wird nur in einer Bedingung verwendet, daher kann die Zuweisung in if als "Header" eines logischen Blocks platziert werden.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktueller Code:</font></font><br>
<pre><code class="python hljs">env_base = os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>)
<span class="hljs-keyword">if</span> env_base:
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserter Code:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> env_base := os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>):
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_pydecimal.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen verschachtelte ifs vermeiden und dadurch eine Einr√ºckungsstufe entfernen.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktueller Code:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special:<font></font>
    ans = self._check_nans(context=context)<font></font>
    <span class="hljs-keyword">if</span> ans:
        <span class="hljs-keyword">return</span> ans</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserter Code:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special <span class="hljs-keyword">and</span> (ans := self._check_nans(context=context)):
    <span class="hljs-keyword">return</span> ans</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copy.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code sieht klassischer aus und vermeidet auch das mehrfache Verschachteln von bedingten Anweisungen. </font><font style="vertical-align: inherit;">(Weitere Informationen zum Ursprung dieses Beispiels finden Sie in Anhang A.)</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktueller Code:</font></font><br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(
                <span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserter Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datetime.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tz wird nur f√ºr s + = tz verwendet. </font><font style="vertical-align: inherit;">Bewegen Sie es nach innen, wenn dies dazu beitr√§gt, den logischen Verwendungsbereich aufzuzeigen.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktueller Code:</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
tz = self._tzstr()<font></font>
<span class="hljs-keyword">if</span> tz:<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserter Code:</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
<span class="hljs-keyword">if</span> tz := self._tzstr():<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sysconfig.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Aufrufen von fp.readline () als "Bedingung" in der while-Schleife (sowie das Aufrufen der .match () -Methode) in der if-Bedingung macht den Code kompakter, ohne sein Verst√§ndnis zu erschweren.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktueller Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    line = fp.readline()<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:
        <span class="hljs-keyword">break</span><font></font>
    m = define_rx.match(line)<font></font>
    <span class="hljs-keyword">if</span> m:<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
        m = undef_rx.match(line)<font></font>
        <span class="hljs-keyword">if</span> m:<font></font>
            vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserter Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> line := fp.readline():
    <span class="hljs-keyword">if</span> m := define_rx.match(line):<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">elif</span> m := undef_rx.match(line):<font></font>
        vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vereinfachen Sie Listengeneratoren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt kann der Listengenerator effektiv gefiltert werden, indem die Bedingung "erfasst" wird:</font></font><br>
<br>
<pre><code class="python hljs">results = [(x, y, x/y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> input_data <span class="hljs-keyword">if</span> (y := f(x)) &gt; <span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danach kann die Variable in einem anderen Ausdruck wiederverwendet werden:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[y := f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie erneut, dass sich die Variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in beiden F√§llen </font><font style="vertical-align: inherit;">im selben Bereich befindet wie das Ergebnis und die Daten der Variablen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werte in Bedingungen erfassen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuweisungsausdr√ºcke k√∂nnen effektiv unter den Bedingungen einer if- oder while-Anweisung verwendet werden:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Loop-and-a-half</span>
<span class="hljs-keyword">while</span> (command := input(<span class="hljs-string">"&gt; "</span>)) != <span class="hljs-string">"quit"</span>:<font></font>
    print(<span class="hljs-string">"You entered:"</span>, command)<font></font>
<font></font>
<span class="hljs-comment"># Capturing regular expression match objects</span>
<span class="hljs-comment"># See, for instance, Lib/pydoc.py, which uses a multiline spelling</span>
<span class="hljs-comment"># of this effect</span>
<span class="hljs-keyword">if</span> match := re.search(pat, text):<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-comment"># The same syntax chains nicely into 'elif' statements, unlike the</span>
<span class="hljs-comment"># equivalent using assignment statements.</span>
<span class="hljs-keyword">elif</span> match := re.search(otherpat, text):<font></font>
    print(<span class="hljs-string">"Alternate found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-keyword">elif</span> match := re.search(third, text):<font></font>
    print(<span class="hljs-string">"Fallback found:"</span>, match.group(<span class="hljs-number">0</span>))<font></font>
<font></font>
<span class="hljs-comment"># Reading socket data until an empty string is returned</span>
<span class="hljs-keyword">while</span> data := sock.recv(<span class="hljs-number">8192</span>):<font></font>
    print(<span class="hljs-string">"Received data:"</span>, data)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insbesondere kann durch diesen Ansatz die Notwendigkeit beseitigt werden, eine Endlosschleife, Zuweisung und Bedingungspr√ºfung zu erstellen. </font><font style="vertical-align: inherit;">Au√üerdem k√∂nnen Sie eine glatte Parallele zwischen einem Zyklus zeichnen, der einen Funktionsaufruf als Bedingung verwendet, und einem Zyklus, der nicht nur die Bedingung √ºberpr√ºft, sondern auch den tats√§chlichen Wert verwendet, den die Funktion in Zukunft zur√ºckgibt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gabel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Beispiel aus der Low-Level-Welt von UNIX: [ca. </font><font style="vertical-align: inherit;">Fork () ist ein Systemaufruf unter Unix-√§hnlichen Betriebssystemen, der einen neuen Unterprozess relativ zum √ºbergeordneten Betriebssystem erstellt.]</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> pid := os.fork():
    <span class="hljs-comment"># Parent code</span>
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># Child code</span></code></pre><br>
<a name="otklon"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abgelehnte Alternativen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen sind √§hnliche Vorschl√§ge in der Python-Community weit verbreitet. </font><font style="vertical-align: inherit;">Im Folgenden finden Sie eine Reihe alternativer Syntaxen f√ºr Zuweisungsausdr√ºcke, die zu spezifisch sind, um sie zu verstehen, und die zugunsten der oben genannten abgelehnt wurden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern des Bereichs f√ºr Generatoren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einer fr√ºheren Version dieses PEP wurde vorgeschlagen, die Bereichsregeln f√ºr Generatoren geringf√ºgig zu √§ndern, um sie f√ºr die Verwendung im Klassenbereich besser geeignet zu machen. </font><font style="vertical-align: inherit;">Diese Vorschl√§ge w√ºrden jedoch zu einer Inkompatibilit√§t f√ºhren und wurden daher abgelehnt. </font><font style="vertical-align: inherit;">Daher konnte sich dieser PEP nur auf Zuweisungsausdr√ºcke konzentrieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternative Schreibweisen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen haben die vorgeschlagenen Zuweisungsausdr√ºcke dieselbe Semantik, sind jedoch unterschiedlich geschrieben.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPR als NAME:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[f(x) <span class="hljs-keyword">as</span> y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   EXPR as NAME       import, except  with,         (,       ).<br>
<br>
( ,  ¬´with EXPR as VAR¬ª     EXPR  VAR,   EXPR.__enter__()        VAR.)<br>
<br>
 ,   ":="   :<br>
<ul>
<li>  ,  <b>if f(x) as y</b>     ,    ‚Äã‚Äã   <b>if f x blah-blah</b>,        <b>if f(x) and y</b>.</li>
<li>   ,  <b>as</b> ,           ,     : <ul>
<li>import foo as bar</li>
<li>except Exc as var</li>
<li>with ctxmgr() as var</li>
</ul><br>
 , <b>as</b>     if  while     ,   <b>as</b>  ¬´ ¬ª   .</li>
<li>  ¬´¬ª  <ul>
<li>NAME = EXPR</li>
<li>if NAME := EXPR</li>
</ul><br>
     .</li>
</ul></li>
<li>EXPR -&gt; NAME<br>
<br>
<pre><code class="python hljs">stuff = [[f(x) -&gt; y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
     ,  R  Haskell,     . ( ,    - <b>y &lt; ‚Äî f (x) </b>   Python,      -   .)       ¬´as¬ª   ,      import, except  with,      .             Python (    ),      ":=" (   Algol-58)     .</li>
<li>  ¬´¬ª    <br>
<br>
<pre><code class="python hljs">stuff = [[(f(x) <span class="hljs-keyword">as</span> .y), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with "as"</span>
stuff = [[(.y := f(x)), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with ":="</span></code></pre><br>
         .         Python,        ,   .</li>
<li> where:       :<br>
<br>
<pre><code class="python hljs">value = x**<span class="hljs-number">2</span> + <span class="hljs-number">2</span>*x where:<font></font>
    x = spam(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, q)</code></pre><br>
   (    ,     ¬´¬ª).      ,   ¬´¬ª  (  with:). . PEP 3150,      (    <i>given:</i> ).</li>
<li>TARGET from EXPR:<br>
<br>
<pre><code class="python hljs">stuff = [[y <span class="hljs-keyword">from</span> f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist weniger wahrscheinlich, dass diese Syntax mit anderen in Konflikt steht als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (es sei denn, Sie z√§hlen die Erh√∂hung von Exc aus Exc-Konstrukten), sie ist jedoch ansonsten mit diesen vergleichbar. </font><font style="vertical-align: inherit;">Anstelle einer Parallele mit mit expr als Ziel: (was n√ºtzlich sein kann, aber auch verwirrend sein kann), weist diese Option √ºberhaupt keine Parallelen zu irgendetwas auf, wird aber √ºberraschenderweise besser in Erinnerung behalten.</font></font></li>
</ol><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sonderf√§lle in bedingten Aussagen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einer der h√§ufigsten Anwendungsf√§lle f√ºr Zuweisungsausdr√ºcke sind die if- und while-Anweisungen. </font><font style="vertical-align: inherit;">Anstelle einer allgemeineren L√∂sung </font><font style="vertical-align: inherit;">verbessert die </font><font style="vertical-align: inherit;">Verwendung von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Syntax dieser beiden Anweisungen, indem ein Mittel zum Erfassen des zu vergleichenden Werts hinzugef√ºgt wird:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> re.search(pat, text) <span class="hljs-keyword">as</span> match:<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies funktioniert gut, aber </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUR,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn die gew√ºnschte Bedingung auf der "Richtigkeit" des R√ºckgabewerts basiert. </font><font style="vertical-align: inherit;">Daher ist diese Methode in bestimmten F√§llen wirksam (√úberpr√ºfung auf regul√§re Ausdr√ºcke, Lesen von Sockets, R√ºckgabe einer leeren Zeichenfolge am Ende der Ausf√ºhrung) und in komplexeren F√§llen (z. B. wenn die Bedingung f (x) &lt;0 ist und Sie m√∂chten) v√∂llig nutzlos Speichern Sie den Wert von f (x)). </font><font style="vertical-align: inherit;">Dies ist auch bei Listengeneratoren nicht sinnvoll. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorteile</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Keine syntaktischen Mehrdeutigkeiten. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachteile</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Auch wenn Sie es nur in if / while-Anweisungen verwenden, funktioniert es nur in einigen F√§llen gut.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sonderf√§lle bei Generatoren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer h√§ufiger Anwendungsfall f√ºr Zuweisungsausdr√ºcke sind Generatoren (list / set / dict und genexps). </font><font style="vertical-align: inherit;">Wie oben wurden Vorschl√§ge f√ºr spezifische L√∂sungen gemacht.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wo, lassen oder gegeben:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) where y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) let y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) given y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode f√ºhrt zu einem Unterausdruck zwischen der for-Schleife und dem Hauptausdruck. </font><font style="vertical-align: inherit;">Au√üerdem wird ein zus√§tzliches Sprachschl√ºsselwort eingef√ºhrt, das zu Konflikten f√ºhren kann. </font><font style="vertical-align: inherit;">Von den drei Optionen, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die sauberste und lesbar, aber potenzielle Konflikte existieren nach wie vor (zum Beispiel SQLAlchemy und numpy ihre wo Methoden sowie tkinter.dnd.Icon in der Standardbibliothek).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit NAME = EXPR:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
  ,     ,     <b>with</b>.         .   ,           ¬´¬ª  for.    C,         ,    .   : ¬´  ¬´with NAME = EXPR:¬ª       ,   ?¬ª</li>
<li>with EXPR as NAME:<br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> f(x) <span class="hljs-keyword">as</span> y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   ,    <b>as</b>,    .       ,        for.      with          </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unabh√§ngig von der gew√§hlten Methode wird durch eine for-Schleife ein scharfer semantischer Unterschied zwischen Generatoren und ihren bereitgestellten Versionen eingef√ºhrt. </font><font style="vertical-align: inherit;">Es w√§re unm√∂glich, den Zyklus in einen Generator zu packen, ohne die Phase der Erstellung der Variablen zu verarbeiten. </font><font style="vertical-align: inherit;">Das einzige Schl√ºsselwort, das f√ºr diese Aufgabe neu ausgerichtet werden k√∂nnte, ist das Wort </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies f√ºhrt jedoch zu einer unterschiedlichen Semantik in verschiedenen Teilen des Codes. Dies bedeutet, dass Sie ein neues Schl√ºsselwort erstellen m√ºssen. Dies ist jedoch mit hohen Kosten verbunden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Niedrigere Bedienerpriorit√§t</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Operator: = hat zwei logische Priorit√§ten. Oder es sollte eine m√∂glichst niedrige Priorit√§t haben (auf dem Niveau des Zuweisungsoperators). Oder es sollte Vorrang vor Vergleichsoperatoren haben. Wenn Sie die Priorit√§t zwischen Vergleichsoperatoren und arithmetischen Operationen platzieren (um genau zu sein: etwas niedriger als bitweises ODER), k√∂nnen Sie in den meisten F√§llen w√§hrend und w√§hrend der Verwendung auf Klammern verzichten, da es wahrscheinlicher ist, dass Sie den Wert von etwas vorher beibehalten m√∂chten wie der Vergleich darauf durchgef√ºhrt wird:</font></font><br>
<br>
<pre><code class="python hljs">pos = <span class="hljs-number">-1</span>
<span class="hljs-keyword">while</span> pos := buffer.find(search_term, pos + <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>:<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobald find () -1 zur√ºckgibt, endet die Schleife. </font><font style="vertical-align: inherit;">Wenn: = die Operanden so frei wie = bindet, wird das Ergebnis von find () zuerst im Vergleichsoperator "erfasst" und gibt normalerweise True oder False zur√ºck, was weniger n√ºtzlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl dieses Verhalten in der Praxis in vielen Situationen praktisch w√§re, w√§re es schwieriger zu erkl√§ren. </font><font style="vertical-align: inherit;">Und so k√∂nnen wir sagen, dass "der Operator: = sich genauso verh√§lt wie der √ºbliche Zuweisungsoperator". </font><font style="vertical-align: inherit;">Das hei√üt, die Priorit√§t f√ºr: = wurde so nah wie m√∂glich am Operator = gew√§hlt (au√üer dass: = eine h√∂here Priorit√§t als das Komma hat).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie geben rechts Kommas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Kritiker argumentieren, dass Zuweisungsausdr√ºcke Tupel ohne zus√§tzliche Klammern erkennen sollten, damit die beiden Eintr√§ge gleichwertig sind:</font></font><br>
<br>
<pre><code class="python hljs">(point := (x, y))<font></font>
(point := x, y)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(In der aktuellen Version des Standards entspricht der letzte Datensatz dem Ausdruck ((Punkt: = x), y).) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist jedoch logisch, dass in dieser Situation der Zuweisungsausdruck im Funktionsaufruf auch eine niedrigere Priorit√§t als das Komma hat w√§re die folgende verwirrende √Ñquivalenz:</font></font><br>
<br>
<pre><code class="python hljs">foo (x: = <span class="hljs-number">1</span>, y)<font></font>
foo (x: = (<span class="hljs-number">1</span>, y))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wir bekommen den einzigen weniger verwirrenden Ausweg: Machen Sie den Operator: = zu einer niedrigeren Priorit√§t als das Komma.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immer Klammern erforderlich</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurde immer vorgeschlagen, die Zuweisungsausdr√ºcke in Klammern zu setzen. </font><font style="vertical-align: inherit;">Dies w√ºrde uns viele Unklarheiten ersparen. </font><font style="vertical-align: inherit;">In der Tat werden h√§ufig Klammern ben√∂tigt, um den gew√ºnschten Wert zu extrahieren. </font><font style="vertical-align: inherit;">In den folgenden F√§llen erschien uns das Vorhandensein von Klammern jedoch eindeutig √ºberfl√ºssig:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Top level in if</span>
<span class="hljs-keyword">if</span> match := pattern.match(line):
    <span class="hljs-keyword">return</span> match.group(<span class="hljs-number">1</span>)<font></font>
<font></font>
<span class="hljs-comment"># Short call</span>
len(lines := f.readlines())</code></pre><br>
<a name="chast"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√§ufige Einw√§nde</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum nicht einfach die Zuweisungsanweisungen in Ausdr√ºcke verwandeln?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C und √§hnliche Sprachen definieren den Operator </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als Ausdruck und nicht als Anweisung, wie dies Python tut. </font><font style="vertical-align: inherit;">Dies erm√∂glicht die Zuweisung in vielen Situationen, einschlie√ülich an Orten, an denen Variablen verglichen werden. </font><font style="vertical-align: inherit;">Die syntaktischen √Ñhnlichkeiten zwischen if (x == y) und if (x = y) widersprechen ihrer stark unterschiedlichen Semantik. </font><font style="vertical-align: inherit;">Daher f√ºhrt dieser PEP den Operator ein: =, um ihre Unterschiede zu verdeutlichen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum mit M√ºhe </font><font style="vertical-align: inherit;">Zuweisung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausdr√ºcke</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wenn </font><font style="vertical-align: inherit;">Zuordnung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anweisungen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> existieren </font><font style="vertical-align: inherit;">?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese beiden Formen haben unterschiedliche Flexibilit√§t. </font><font style="vertical-align: inherit;">Der Operator: = kann in einem gr√∂√üeren Ausdruck verwendet werden, und im Operator = kann er von der "Familie der Mini-Operatoren" vom Typ "+ =" verwendet werden. </font><font style="vertical-align: inherit;">Mit = k√∂nnen Sie Werte nach Attributen und Indizes zuweisen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum nicht den lokalen Bereich nutzen und die Verschmutzung von Namespaces verhindern?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fr√ºhere Versionen dieses Standards enthielten einen realen lokalen Bereich (auf eine Anweisung beschr√§nkt) f√ºr Zuweisungsausdr√ºcke, um Namensverlust und Verschmutzung des Namespace zu verhindern. </font><font style="vertical-align: inherit;">Trotz der Tatsache, dass dies in einigen Situationen einen gewissen Vorteil brachte, erschwert es in vielen anderen die Aufgabe, und die Vorteile sind nicht durch die Vorteile des bestehenden Ansatzes gerechtfertigt. </font><font style="vertical-align: inherit;">Dies geschieht im Interesse der Einfachheit der Sprache. </font><font style="vertical-align: inherit;">Sie brauchen diese Variable nicht mehr? </font><font style="vertical-align: inherit;">Es gibt eine L√∂sung: L√∂schen Sie die Variable mit dem Schl√ºsselwort del oder f√ºgen Sie ihrem Namen einen unteren Unterstrich hinzu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Der Autor m√∂chte Guido van Rossum und Christophe Groth f√ºr ihre Vorschl√§ge danken, den PEP-Standard in diese Richtung voranzutreiben. [2])</font></font><br>
<br>
<a name="rekom"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stilempfehlungen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da Zuweisungsausdr√ºcke manchmal mit einem Zuweisungsoperator gleichwertig verwendet werden k√∂nnen, stellt sich die Frage, was noch bevorzugt wird. In √úbereinstimmung mit anderen Stilkonventionen (wie PEP 8) gibt es zwei Empfehlungen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie beide Zuweisungsoptionen verwenden k√∂nnen, bevorzugen Sie Operatoren. </font><font style="vertical-align: inherit;">Sie dr√ºcken Ihre Absichten am deutlichsten aus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Verwendung von Zuweisungsausdr√ºcken zu Mehrdeutigkeiten in der Ausf√ºhrungsreihenfolge f√ºhrt, schreiben Sie den Code mit dem klassischen Operator neu.</font></font></li>
</ol><br>
<a name="blag"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Autoren dieses Standards m√∂chten Nick Coghlan und Steven D'Aprano f√ºr ihre bedeutenden Beitr√§ge zu diesem PEP sowie den Mitgliedern der Python Core Mentorship f√ºr ihre Hilfe bei der Implementierung danken.</font></font><br>
<br>
<a name="prilA"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang A: Schlussfolgerungen von Tim Peters</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein kurzer Aufsatz, den Tim Peters zu diesem Thema geschrieben hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich mag den "verwirrten" Code nicht und mag es auch nicht, konzeptionell nicht verwandte Logik in eine Zeile zu setzen. </font><font style="vertical-align: inherit;">Also zum Beispiel anstelle von:</font></font><br>
<br>
<pre><code class="python hljs">i = j = count = nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich schreibe lieber:</font></font><br>
<br>
<pre><code class="python hljs">i = j = <span class="hljs-number">0</span>
count = <span class="hljs-number">0</span>
nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher denke ich, dass ich mehrere Stellen finden werde, an denen ich Zuweisungsausdr√ºcke verwenden m√∂chte. </font><font style="vertical-align: inherit;">Ich m√∂chte nicht einmal √ºber ihre Verwendung in Ausdr√ºcken sprechen, die bereits auf die H√§lfte des Bildschirms ausgedehnt sind. </font><font style="vertical-align: inherit;">In anderen F√§llen kann Folgendes auftreten:</font></font><br>
<br>
<pre><code class="python hljs">mylast = mylast[<span class="hljs-number">1</span>]
<span class="hljs-keyword">yield</span> mylast[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deutlich besser als das:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">yield</span> (mylast := mylast[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese beiden Codes haben v√∂llig unterschiedliche Konzepte und es w√§re verr√ºckt, sie zu mischen. </font><font style="vertical-align: inherit;">In anderen F√§llen erschwert das Kombinieren logischer Ausdr√ºcke das Verst√§ndnis des Codes. </font><font style="vertical-align: inherit;">Beispiel: Umschreiben:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    old = total<font></font>
    total += term<font></font>
    <span class="hljs-keyword">if</span> old == total:
        <span class="hljs-keyword">return</span> total<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einer k√ºrzeren Form haben wir die ‚ÄûLogik‚Äú verloren. </font><font style="vertical-align: inherit;">Sie m√ºssen verstehen, wie dieser Code funktioniert. </font><font style="vertical-align: inherit;">Mein Gehirn will das nicht:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> total != (total := total + term):<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span>
<span class="hljs-keyword">return</span> total</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solche F√§lle sind jedoch selten. </font><font style="vertical-align: inherit;">Die Aufgabe, das Ergebnis zu erhalten, ist sehr verbreitet, und ‚Äûd√ºnn ist besser als dicht‚Äú bedeutet nicht, dass ‚Äûfast leer ist besser als d√ºnn‚Äú [ca. </font><font style="vertical-align: inherit;">ein Verweis auf Zen Python]. </font><font style="vertical-align: inherit;">Zum Beispiel habe ich viele Funktionen, die None oder 0 zur√ºckgeben, um zu sagen: "Ich habe nichts N√ºtzliches, aber da dies h√§ufig vorkommt, m√∂chte ich Sie nicht mit Ausnahmen bel√§stigen." </font><font style="vertical-align: inherit;">Tats√§chlich wird dieser Mechanismus auch in regul√§ren Ausdr√ºcken verwendet, die None zur√ºckgeben, wenn keine √úbereinstimmungen vorhanden sind. </font><font style="vertical-align: inherit;">Daher in diesem Beispiel viel Code:</font></font><br>
<br>
<pre><code class="python hljs">result = solution(xs, n)
<span class="hljs-keyword">if</span> result:
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich finde die folgende Option verst√§ndlicher und nat√ºrlich lesbarer:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> result := solution(xs, n):
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anfangs legte ich nicht viel Wert darauf, aber eine so kurze Konstruktion erschien so oft, dass es mich bald √§rgerte, dass ich sie nicht verwenden konnte. </font><font style="vertical-align: inherit;">Es √ºberrascht mich! </font><font style="vertical-align: inherit;">[ca. </font><font style="vertical-align: inherit;">Anscheinend wurde dies geschrieben, bevor Python 3.8 offiziell ver√∂ffentlicht wurde.] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt andere F√§lle, in denen Zuweisungsausdr√ºcke wirklich "schie√üen". </font><font style="vertical-align: inherit;">Anstatt noch einmal in meinem Code zu st√∂bern, gab Kirill Balunov ein gutes Beispiel f√ºr die Funktion copy () aus der Standardbibliothek copy.py:</font></font><br>
<br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die immer gr√∂√üer werdende Einr√ºckung ist irref√ºhrend: Immerhin ist die Logik flach: Der erste erfolgreiche Test ‚Äûgewinnt‚Äú:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfache Verwendung von Zuweisungsausdr√ºcken erm√∂glicht es der visuellen Struktur des Codes, die ‚ÄûEbene‚Äú der Logik hervorzuheben. </font><font style="vertical-align: inherit;">Aber die immer gr√∂√üer werdende Einr√ºckung macht es implizit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein weiteres kleines Beispiel aus meinem Code, das mich sehr gefreut hat, weil ich die intern verkn√ºpfte Logik in eine Zeile setzen und die l√§stige ‚Äûk√ºnstliche‚Äú Einr√ºckungsstufe entfernen konnte. </font><font style="vertical-align: inherit;">Dies ist genau das, was ich von der if-Anweisung will und es erleichtert das Lesen. </font><font style="vertical-align: inherit;">Der folgende Code:</font></font><br>
<br>
<pre><code class="python hljs">diff = x - x_base
<span class="hljs-keyword">if</span> diff:<font></font>
    g = gcd(diff, n)<font></font>
    <span class="hljs-keyword">if</span> g &gt; <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wurde zu:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> (diff := x - x_base) <span class="hljs-keyword">and</span> (g := gcd(diff, n)) &gt; <span class="hljs-number">1</span>:
    <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten Zeilen, in denen Variablen zugewiesen werden, w√ºrde ich keine Zuweisungsausdr√ºcke verwenden. </font><font style="vertical-align: inherit;">Aber dieses Design ist so h√§ufig, dass es immer noch viele Orte gibt, an denen ich diese Gelegenheit nutzen w√ºrde. </font><font style="vertical-align: inherit;">In den letzten F√§llen habe ich ein wenig gewonnen, wie sie oft erschienen sind. </font><font style="vertical-align: inherit;">Im verbleibenden Teil f√ºhrte dies zu mittleren oder gro√üen Verbesserungen. </font><font style="vertical-align: inherit;">Daher w√ºrde ich Zuweisungsausdr√ºcke viel h√§ufiger als ein Dreifach verwenden, aber viel seltener als eine erweiterte Zuweisung [ca. </font><font style="vertical-align: inherit;">kurze Optionen: * =, / =, + = usw.].</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numerisches Beispiel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe ein anderes Beispiel, das mich fr√ºher beeindruckt hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn alle Variablen positive ganze Zahlen sind und die Variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gr√∂√üer als die n-te Wurzel von x ist, gibt dieser Algorithmus die "niedrigere" Rundung der n-ten Wurzel von x zur√ºck (und verdoppelt ungef√§hr die Anzahl der exakten Bits pro Iteration):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> a &gt; (d := x // a**(n<span class="hljs-number">-1</span>)):<font></font>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist nicht klar warum, aber eine solche Variante des Algorithmus ist weniger offensichtlich als eine Endlosschleife mit einer bedingten Verzweigungsunterbrechung (eineinhalb Schleifen). Es ist auch schwierig, die Richtigkeit dieser Implementierung zu beweisen, ohne sich auf eine mathematische Aussage (‚Äûarithmetisches Mittel - geometrische Mittelwertungleichung‚Äú) zu st√ºtzen und einige nicht triviale Dinge dar√ºber zu wissen, wie sich die verschachtelten Rundungsfunktionen nach unten verhalten. Aber hier liegt das Problem bereits in der Mathematik und nicht in der Programmierung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wenn Sie das alles wissen, ist die Option mit Zuweisungsausdr√ºcken sehr einfach zu lesen, wie ein einfacher Satz: "√úberpr√ºfen Sie die aktuelle" Vermutung "und wenn sie zu gro√ü ist, reduzieren Sie sie", und die Bedingung erm√∂glicht es Ihnen, den Zwischenwert sofort aus der Schleifenbedingung zu speichern. Meiner Meinung nach ist die klassische Form schwerer zu verstehen:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    d = x // a**(n<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">if</span> a &lt;= d:
        <span class="hljs-keyword">break</span>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br>
<a name="prilB"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang B: Ein Grobcode-Interpreter f√ºr Generatoren</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Anhang wird versucht, die Regeln zu kl√§ren (obwohl nicht angegeben), nach denen eine Variable in Generatorausdr√ºcken erstellt werden soll. </font><font style="vertical-align: inherit;">F√ºr einige anschauliche Beispiele zeigen wir den Quellcode, bei dem der Generator durch eine √§quivalente Funktion in Kombination mit einem ‚ÄûGer√ºst‚Äú ersetzt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da [x f√ºr ...] der Liste entspricht (x f√ºr ...), verlieren die Beispiele nicht ihre Allgemeing√ºltigkeit. </font><font style="vertical-align: inherit;">Und da diese Beispiele nur zur Verdeutlichung der allgemeinen Regeln dienen sollen, erheben sie keinen Anspruch auf Realit√§t.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis: Generatoren werden jetzt durch die Erstellung verschachtelter Generatorfunktionen implementiert (√§hnlich den in diesem Anhang angegebenen). </font><font style="vertical-align: inherit;">Die Beispiele zeigen den neuen Teil, der die entsprechende Funktionalit√§t f√ºr die Arbeit mit dem Bereich der Zuweisungsausdr√ºcke hinzuf√ºgt (z. B., wenn die Zuweisung in einem Block ausgef√ºhrt wurde, der den externesten Generator enth√§lt). </font><font style="vertical-align: inherit;">Um die ‚ÄûTypinferenz‚Äú zu vereinfachen, ber√ºcksichtigen diese veranschaulichenden Beispiele nicht, dass Zuweisungsausdr√ºcke optional sind (sie ber√ºcksichtigen jedoch den Umfang der im Generator erstellten Variablen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnern wir uns zun√§chst daran, welcher Code f√ºr Generatoren ohne Zuweisungsausdr√ºcke ‚Äûunter der Haube‚Äú generiert wird:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellcode (EXPR verwendet am h√§ufigsten die VAR-Variable):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der konvertierte Code (machen wir uns keine Sorgen um Namenskonflikte):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:
            <span class="hljs-keyword">yield</span> EXPR<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen wir einen einfachen Zuweisungsausdruck hinzu.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvertierter Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Dead code to ensure TARGET is a local variable</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen wir nun die globale TARGET-Anweisung zur Deklaration der Funktion f () hinzu.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET<font></font>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvertierter Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">global</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oder umgekehrt, f√ºgen wir der Deklaration der Funktion f () nichtlokales ZIEL hinzu.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET<font></font>
        a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvertierter Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
                TARGET = EXPR<font></font>
                <span class="hljs-keyword">yield</span> TARGET<font></font>
        a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns zum Schluss zwei Generatoren einsetzen.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [[TARGET := i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>)]
    <span class="hljs-comment"># I.e., a = [[0, 1, 2], [0, 1, 2]]</span>
    print(TARGET)  <span class="hljs-comment"># prints 2</span>
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvertierter Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer_genexpr</span>(<span class="hljs-params">outer_iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner_generator</span>(<span class="hljs-params">inner_iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> inner_iterator:<font></font>
                TARGET = i<font></font>
                <span class="hljs-keyword">yield</span> i
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> outer_iterator:
            <span class="hljs-keyword">yield</span> list(inner_generator(range(<span class="hljs-number">3</span>)))<font></font>
    a = list(outer_genexpr(range(<span class="hljs-number">2</span>)))<font></font>
    print(TARGET)</code></pre></li>
</ul><br>
<a name="prilC"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anhang C: Keine √Ñnderungen in der Umfangssemantik</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass sich die Umfangssemantik in Python nicht ge√§ndert hat. </font><font style="vertical-align: inherit;">Der Umfang lokaler Funktionen wird zur Kompilierungszeit noch festgelegt und hat zur Laufzeit einen unbegrenzten Zeitumfang (Closure). </font><font style="vertical-align: inherit;">Beispiel:</font></font><br>
<br>
<pre><code class="python hljs">a = <span class="hljs-number">42</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-comment"># `a` is local to `f`, but remains unbound</span>
    <span class="hljs-comment"># until the caller executes this genexp:</span>
    <span class="hljs-keyword">yield</span> ((a := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>))
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">lambda</span>: a + <span class="hljs-number">100</span>
    print(<span class="hljs-string">"done"</span>)
    <span class="hljs-keyword">try</span>:<font></font>
        print(<span class="hljs-string">f"`a` is bound to <span class="hljs-subst">{a}</span>"</span>)
        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">except</span> UnboundLocalError:<font></font>
        print(<span class="hljs-string">"`a` is not yet bound"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span>results = list(f()) <span class="hljs-comment"># [genexp, lambda]</span><font></font>
done<font></font>
`a` <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> yet bound
<span class="hljs-comment"># The execution frame for f no longer exists in CPython,</span>
<span class="hljs-comment"># but f's locals live so long as they can still be referenced.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>list(map(type, results))<font></font>
[&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">generator</span>'&gt;, &lt;<span class="hljs-title">class</span> '<span class="hljs-title">function</span>'&gt;]
&gt;&gt;&gt; <span class="hljs-title">list</span>(<span class="hljs-params">results[<span class="hljs-number">0</span>]</span>)
[0, 1, 2]
&gt;&gt;&gt; <span class="hljs-title">results</span>[1]()
102
&gt;&gt;&gt; <span class="hljs-title">a</span>
42</span></code></pre><br>
<a name="ssilki"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachweis der Konzeptumsetzung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diskussion der Semantik von Zuweisungsausdr√ºcken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (VPN ist eng aber geladen)</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diskussion von TargetScopeError in PEP 572</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (√§hnlich wie im vorherigen geladen)</font></font></li>
</ol><br>
<a name="avtori"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urheberrechte ¬©</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Dokument wurde √∂ffentlich zug√§nglich gemacht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/python/peps/blob/master/pep-0572.rst</font></font></a><br>
<br>
<a name="my"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mein Teil</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns zun√§chst zusammenfassen:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit die </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menschen nicht versuchen</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die semantische Dualit√§t zu entfernen, gibt es an vielen ‚Äûklassischen‚Äú Stellen, an denen sowohl ‚Äû=‚Äú als auch ‚Äû: =‚Äú verwendet werden k√∂nnen, Einschr√§nkungen. Daher sollte der Operator :: = h√§ufig in Klammern gesetzt werden. </font><font style="vertical-align: inherit;">Diese F√§lle m√ºssen im Abschnitt </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">√ºber die grundlegende Verwendung</font></a><font style="vertical-align: inherit;"> √ºberpr√ºft werden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Priorit√§t von Zuweisungsausdr√ºcken ist etwas h√∂her als die eines Kommas. </font><font style="vertical-align: inherit;">Aus diesem Grund werden w√§hrend der Zuweisung keine Tupel gebildet. </font><font style="vertical-align: inherit;">Es erm√∂glicht auch die Verwendung des Operators: =, wenn Argumente an eine Funktion √ºbergeben werden.</font></font></li>
<li> ,   ,    ,    .       .    lambda    ,    ¬´¬ª  .</li>
<li>        :   ,     </li>
<li>      ,   .</li>
<li>          /  .</li>
<li>   ,      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende m√∂chte ich sagen, dass mir der neue Operator gefallen hat. </font><font style="vertical-align: inherit;">Es erm√∂glicht Ihnen, flacheren Code unter Bedingungen zu schreiben, Listen zu filtern und (endlich) die gleiche, einsame Zeile zu entfernen, bevor if. </font><font style="vertical-align: inherit;">Wenn Benutzer Zuweisungsausdr√ºcke f√ºr ihren beabsichtigten Zweck verwenden, ist dies ein sehr praktisches Werkzeug, das die Lesbarkeit und Sch√∂nheit des Codes verbessert (obwohl dies f√ºr jede funktionale Sprache gesagt werden kann ...).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499654/index.html">Wie implementiere ich CRM auf einem Remote-Standort und gewinne?</a></li>
<li><a href="../de499656/index.html">Simulation des PID-Temperaturreglers</a></li>
<li><a href="../de499658/index.html">Ein Arbeiter statt eines Testers? Lohnt es sich, 2020 Selen zu studieren?</a></li>
<li><a href="../de499662/index.html">Root-of-Trust f√ºr IoT und andere IoT-Sicherheitstrends</a></li>
<li><a href="../de499664/index.html">Portieren von APIs nach TypeScript als Probleml√∂ser</a></li>
<li><a href="../de499668/index.html">Road to Hell JavaScript-Abh√§ngigkeiten</a></li>
<li><a href="../de499670/index.html">–Ø –ø–µ—Ä–µ—Ö–æ–∂—É –Ω–∞ JavaScript</a></li>
<li><a href="../de499674/index.html">Ein weiterer Schritt zu optischen Computern</a></li>
<li><a href="../de499676/index.html">√úber 90 n√ºtzliche Tools f√ºr Kubernetes: Bereitstellung, Verwaltung, √úberwachung, Sicherheit und mehr</a></li>
<li><a href="../de499680/index.html">Kubernetes lernen: Basic 14.-16. Mai, Advanced 18.-20. Mai</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>