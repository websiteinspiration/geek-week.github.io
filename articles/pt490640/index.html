<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈹 👩🏿‍🤝‍👩🏽 🥒 Sobrecarga em C ++. Parte III Sobrecarregando novas instruções / exclusão 💪🏻 🏥 👩🏿‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos a série "C ++, cavando em profundidade". O objetivo desta série é informar o máximo possível sobre os vários recursos do idioma, possivelm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sobrecarga em C ++. Parte III Sobrecarregando novas instruções / exclusão</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490640/"><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuamos a série "C ++, cavando em profundidade". </font><font style="vertical-align: inherit;">O objetivo desta série é informar o máximo possível sobre os vários recursos do idioma, possivelmente bastante especiais. </font><font style="vertical-align: inherit;">Este artigo é sobre sobrecarga do operador </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este é o terceiro artigo da série, o primeiro dedicado a funções e modelos de sobrecarga, localizado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o segundo dedicado a operadores de sobrecarga, localizado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este artigo conclui uma série de três artigos sobre sobrecarga em C ++.</font></font><br>
<hr><a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Índice</font></font></h1><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Índice</font></font></b><div class="spoiler_text">&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.    new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.1.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.3.     </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.1.     </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2.1.      new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2.2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2.3.  </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2.4. </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2.5.    operator delete()</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.   new/delete</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.    </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5. -  </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a><br>
</div></div><br>
<a name="id-1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Formulários padrão de operadores novos / excluídos</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ suporta várias opções de operador </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eles podem ser divididos em padrão básico, padrão adicional e personalizado. </font><font style="vertical-align: inherit;">Esta seção e a seção 2 discutem formulários padrão; os formulários personalizados serão discutidos na seção 3.</font></font><br>
<br>
<a name="id-1-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1 </font><font style="vertical-align: inherit;">Formulários padrão básicos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As principais formas padrão de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usadas ao criar e excluir um objeto e uma matriz do tipo são </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as seguintes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span> T[<span class="hljs-comment">/*   */</span>]
<span class="hljs-keyword">delete</span> ptr;
<span class="hljs-keyword">delete</span>[] ptr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O trabalho deles pode ser descrito da seguinte forma. Quando o operador é chamado </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a memória é alocada primeiro para o objeto. Se a seleção for bem sucedida, o construtor é chamado. Se o construtor lança uma exceção, a memória alocada é liberada. Quando o operador é chamado, </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tudo acontece na ordem inversa: primeiro, o destruidor é chamado e a memória é liberada. O destruidor não deve lançar exceções. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando o operador</font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usada para criar uma matriz de objetos, a memória é alocada primeiro para toda a matriz. Se a seleção for bem-sucedida, o construtor padrão (ou outro construtor, se houver um inicializador) será chamado para cada elemento da matriz começando do zero. Se algum construtor lança uma exceção, para todos os elementos da matriz criados, o destruidor é chamado na ordem inversa da chamada do construtor, a memória alocada é liberada. Para excluir uma matriz, você deve chamar o operador </font></font><code>delete[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, para todos os elementos da matriz, o destruidor é chamado na ordem inversa do construtor e a memória alocada é liberada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atenção! É necessário chamar a forma correta do operador</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dependendo se um único objeto ou matriz é excluído. Essa regra deve ser observada rigorosamente, caso contrário, você poderá obter um comportamento indefinido, ou seja, tudo pode acontecer: vazamento de memória, falha etc. Veja [Meyers1] para detalhes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na descrição acima, é necessário um esclarecimento. Para os chamados tipos triviais (tipos internos, estruturas no estilo C), o construtor padrão não pode ser chamado e o destruidor não faz nada em nenhum caso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As funções de alocação de memória padrão, quando não é possível atender à solicitação, lançam uma exceção de tipo </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mas essa exceção pode ser detectada; para isso, você precisa instalar o interceptador global chamando a função </font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para obter mais detalhes, consulte [Meyers1]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qualquer forma de operador</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aplique com segurança ao ponteiro nulo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao criar uma matriz com um operador, o </font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamanho pode ser definido como zero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambas as formas do operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permitem o uso de inicializadores entre chaves.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>{<span class="hljs-number">42</span>}
<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>]{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}</code></pre><br>
<a name="id-1-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2 </font><font style="vertical-align: inherit;">Formulários padrão adicionais</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao conectar o arquivo de cabeçalho </font></font><code>&lt;new&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais 4 formulários de operador padrão ficam disponíveis </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(ptr) T(<span class="hljs-comment">/*  */</span>);
<span class="hljs-keyword">new</span>(ptr) T[<span class="hljs-comment">/*   */</span>];
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T(<span class="hljs-comment">/*   */</span>);
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T[<span class="hljs-comment">/*   */</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os dois primeiros são chamados </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de posicionamento sem alocação </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Um argumento </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é um ponteiro para uma região da memória que é grande o suficiente para armazenar uma instância ou matriz. Além disso, a área de memória deve ter um alinhamento apropriado. Esta versão do operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não aloca memória; fornece apenas uma chamada ao construtor. Portanto, esta opção permite separar as fases de alocação de memória e inicialização de objetos. Esse recurso é usado ativamente em contêineres padrão. O operador </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para objetos criados dessa maneira não pode, é claro, ser chamado. Para excluir um objeto, você deve chamar diretamente o destruidor e liberar a memória de uma maneira que dependa do método de alocação de memória.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As duas segundas opções são chamadas de operador não lançando exceções </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(nothrow </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e diferem no fato de que, se for impossível atender à solicitação, elas retornam </font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas não lançam uma exceção de tipo </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A exclusão de um objeto ocorre usando o operador principal </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Essas opções são consideradas obsoletas e não recomendadas para uso.</font></font><br>
<br>
<a name="id-1-3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3 </font><font style="vertical-align: inherit;">Alocação de memória e funções livres</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Formas padrão de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usam as seguintes funções de alocação e desalocação:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas funções são definidas no espaço para nome global. </font><font style="vertical-align: inherit;">As funções de alocação de memória para as instruções </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do </font><font style="vertical-align: inherit;">host não </font><font style="vertical-align: inherit;">fazem nada e simplesmente retornam </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O C ++ 17 suportava formas adicionais de funções de alocação e desalocação de memória, indicando alinhamento. </font><font style="vertical-align: inherit;">Aqui estão alguns deles:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esses formulários não são diretamente acessíveis ao usuário, eles são usados ​​pelo compilador para objetos cujos requisitos de alinhamento são superiores </font></font><code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; portanto, o principal problema é que o usuário não os oculta acidentalmente (consulte a seção 2.2.1). </font><font style="vertical-align: inherit;">Lembre-se de que no C ++ 11 tornou-se possível definir explicitamente o alinhamento dos tipos de usuário.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct <span class="hljs-title">alignas</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span> X </span>{ <span class="hljs-comment">/* ... */</span> };</code></pre><br>
<a name="id-2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Sobrecarregando os formulários padrão dos operadores new / delete</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A sobrecarga das formas padrão de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consiste na definição de funções definidas pelo usuário para alocar e liberar memória cujas assinaturas coincidem com as padrão. </font><font style="vertical-align: inherit;">Essas funções podem ser definidas no espaço para nome global ou em uma classe, mas não em um espaço para nome que não seja global. </font><font style="vertical-align: inherit;">A função de alocação de memória para uma instrução de host padrão </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não pode ser definida no espaço para nome global. </font><font style="vertical-align: inherit;">Após essa definição, os operadores correspondentes </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">os usarão, não os padrão.</font></font><br>
<br>
<a name="id-2-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1 </font><font style="vertical-align: inherit;">Sobrecarga no espaço de nomes global</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha, por exemplo, em um módulo em um espaço para nome global que funções definidas pelo usuário sejam definidas:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
</span>{
<span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, haverá realmente uma substituição (substituição) das funções padrão para alocar e liberar memória para todas as chamadas do operador </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para quaisquer classes (incluindo as padrão) em todo o módulo. Isso pode levar ao caos completo. Observe que o mecanismo de substituição descrito é um mecanismo especial implementado apenas para este caso, e não um mecanismo geral do C ++. Nesse caso, ao implementar as funções do usuário para alocar e liberar memória, torna-se impossível chamar as funções padrão correspondentes, elas ficam completamente ocultas (o operador </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não ajuda) e, quando você tenta chamá-las, ocorre uma chamada recursiva à função do usuário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Função definida pelo espaço de nomes global</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele também substituirá o padrão, mas haverá menos problemas em potencial, porque o operador que não lança exceções </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é raramente usado. </font><font style="vertical-align: inherit;">Mas o formulário padrão também não está disponível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A mesma situação com funções para matrizes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A sobrecarga de instruções </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no namespace global é altamente desencorajada.</font></font><br>
<br>
<a name="id-2-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2 </font><font style="vertical-align: inherit;">Sobrecarga de classe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A sobrecarga de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em uma classe é desprovida das desvantagens descritas acima. </font><font style="vertical-align: inherit;">A sobrecarga é efetiva apenas ao criar e excluir instâncias da classe correspondente, independentemente do contexto de chamada de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ao implementar funções definidas pelo usuário para alocar e liberar memória usando o operador, </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">você pode acessar as funções padrão correspondentes. </font><font style="vertical-align: inherit;">Considere um exemplo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span>
{</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete\n"</span>;<font></font>
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new[]\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete[]\n"</span>;<font></font>
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](ptr);<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste exemplo, o rastreamento é simplesmente adicionado às operações padrão. </font><font style="vertical-align: inherit;">Agora, em termos </font></font><code>new X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>new X[N]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usará essas funções para alocar e liberar memória. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas funções são formalmente estáticas e podem ser declaradas como </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas, essencialmente, são instâncias, com a chamada da função </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a criação da instância começa e a chamada da função </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">completa sua exclusão. </font><font style="vertical-align: inherit;">Essas funções nunca são chamadas para outras tarefas. </font><font style="vertical-align: inherit;">Além disso, como será mostrado abaixo, a função </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é essencialmente virtual. </font><font style="vertical-align: inherit;">Portanto, é mais correto declará-los sem </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1 </font><font style="vertical-align: inherit;">Acesso a formulários padrão de operadores novos / excluídos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podem ser usados ​​com um operador de resolução de escopo adicional, por exemplo </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nesse caso, a função </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definida na classe será ignorada e o padrão correspondente será usado. </font><font style="vertical-align: inherit;">Da mesma maneira, você pode usar o operador </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2 </font><font style="vertical-align: inherit;">Ocultando outras formas de operadores new / delete</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se agora, para a classe </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tentamos usar ou não exceções </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, obtemos um erro. </font><font style="vertical-align: inherit;">O fato é que a função </font></font><code>operator new(std::size_t size)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oculta outras formas </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O problema pode ser resolvido de duas maneiras. </font><font style="vertical-align: inherit;">No primeiro, você precisa adicionar as opções apropriadas à classe (essas opções devem simplesmente delegar a operação da função padrão). </font><font style="vertical-align: inherit;">No segundo, você precisa usar um operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com um operador de resolução de escopo, por exemplo </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3 </font><font style="vertical-align: inherit;">Recipientes padrão</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se tentarmos colocar as instâncias </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em algum contêiner padrão, por exemplo </font></font><code>std::vector&lt;X&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, veremos que nossas funções não são usadas para alocar e liberar memória. </font><font style="vertical-align: inherit;">O fato é que todos os contêineres padrão têm seu próprio mecanismo para alocar e liberar memória (uma classe de alocador especial, que é um parâmetro de modelo do contêiner) e usam um operador de posicionamento para inicializar os elementos </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.4 </font><font style="vertical-align: inherit;">Herança</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funções para alocar e liberar memória são herdadas. Se essas funções forem definidas na classe base, mas não na classe derivada, os operadores serão sobrecarregados para a classe derivada </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e as funções definidas e alocadas na classe base serão usadas para alocar e liberar memória. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora considere uma hierarquia de classes polimórfica, em que cada classe sobrecarrega os operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Agora, deixe a instância da classe derivada ser excluída usando o operador </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">através de um ponteiro para a classe base. Se o destruidor da classe base for virtual, o padrão garantirá que o destruidor dessa classe derivada seja chamado. Nesse caso </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a </font><font style="vertical-align: inherit;">chamada de função </font><font style="vertical-align: inherit;">definida para esta classe derivada </font><font style="vertical-align: inherit;">também é garantida </font><font style="vertical-align: inherit;">. Assim, a função é </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente virtual.</font></font><br>
<br>
<a name="id-2-2-5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.5 </font><font style="vertical-align: inherit;">Forma alternativa da função delete () do operador</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em uma classe (especialmente quando a herança é usada), às vezes é conveniente usar uma forma alternativa da função para liberar memória:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O parâmetro </font></font><code>size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define o tamanho do elemento (mesmo na versão da matriz). </font><font style="vertical-align: inherit;">Este formulário permite usar funções diferentes para alocar e liberar memória, dependendo da classe derivada específica.</font></font><br>
<br>
<a name="id-3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Operadores de usuários novos / excluídos</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O C ++ pode oferecer suporte a formulários personalizados do operador, do </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seguinte formato:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T[<span class="hljs-comment">/*   */</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que esses formulários sejam suportados, é necessário determinar as funções apropriadas para alocar e liberar memória:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>);
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A lista de parâmetros adicionais das funções de alocação de memória não deve estar vazia e não deve consistir em uma </font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>const std::nothrow_t&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">ou </font><font style="vertical-align: inherit;">seja, sua assinatura não deve coincidir com uma das padrão. Lista de parâmetros adicionais </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve corresponder. Os argumentos passados ​​para o operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devem corresponder a parâmetros adicionais das funções de alocação de memória. Uma função personalizada </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">também pode estar no formulário com um parâmetro de tamanho opcional.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas funções podem ser definidas no espaço para nome global ou em uma classe, mas não em um espaço para nome que não seja global. Se eles são definidos no espaço de nomes global, eles não substituem, mas sobrecarregam, as funções padrão de alocação e liberação de memória; portanto, seu uso é previsível e seguro, e as funções padrão estão sempre disponíveis. Se eles são definidos na classe, ocultam os formulários padrão, mas o acesso aos formulários padrão pode ser obtido usando o operador </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, isso é descrito em detalhes na seção 2.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os formulários de operador </font><font style="vertical-align: inherit;">definidos pelo usuário </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">são chamados </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de posicionamento definido pelo usuário </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Eles não devem ser confundidos com o operador de posicionamento padrão (não alocado) </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descrito na seção 1.2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O formulário do operador correspondente </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não existe. </font><font style="vertical-align: inherit;">Existem </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duas maneiras de </font><font style="vertical-align: inherit;">excluir um objeto criado usando um operador definido pelo usuário </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se uma função definida pelo usuário </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delegar uma operação de alocação de memória para funções de alocação de memória padrão, um operador padrão poderá ser usado </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Caso contrário, você precisará chamar explicitamente o destruidor e, em seguida, a função definida pelo usuário </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O compilador chama a função definida pelo usuário em </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas um caso: quando o </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">construtor lança uma exceção </font><font style="vertical-align: inherit;">durante a operação do operador definido pelo usuário </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está um exemplo (no escopo global).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"new "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"delete "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;<font></font>
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span><span class="hljs-comment">/* ... */</span>};<font></font>
X* p = <span class="hljs-keyword">new</span>(<span class="hljs-number">42</span>, <span class="hljs-string">"meow"</span>) X(); <span class="hljs-comment">// : new 42 + meow</span>
<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//   ::operator delete()</span></code></pre><br>
<a name="id-4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Definição de funções de alocação de memória</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nestes exemplos, funções de usuário </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operação delegada correspondentes às funções padrão. Às vezes, essa opção é útil, mas o principal objetivo da sobrecarga </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é criar um novo mecanismo para alocar / liberar memória. A tarefa não é simples e, antes de realizá-la, é preciso pensar cuidadosamente em tudo. Scott Meyers [Meyers1] discute possíveis motivos para tomar tal decisão (é claro, o principal é a eficiência). Ele também discute os principais problemas técnicos associados à implementação correta de funções definidas pelo usuário para alocar e liberar memória (usando a função</font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sincronização multithread, alinhamento). </font><font style="vertical-align: inherit;">Guntheroth fornece um exemplo da implementação de funções de alocação e desalocação de memória definidas pelo usuário relativamente simples. </font><font style="vertical-align: inherit;">Antes de criar sua própria versão, você deve procurar soluções prontas, como exemplo, você pode trazer a biblioteca Pool do projeto Boost.</font></font><br>
<br>
<a name="id-5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Classes de alocadores de contêineres padrão</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como mencionado acima, os contêineres padrão usam classes especiais de alocador para alocar e liberar memória. </font><font style="vertical-align: inherit;">Essas classes são parâmetros de modelo de contêineres e o usuário pode definir sua versão dessa classe. </font><font style="vertical-align: inherit;">Os motivos para tal solução são aproximadamente os mesmos que para sobrecarregar os operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Guntheroth] descreve como criar essas classes.</font></font><br>
<br>
<a name="id-refs"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliografia</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Guntheroth] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gunteroth, Kurt. </font><font style="vertical-align: inherit;">Otimização de programas em C ++. </font><font style="vertical-align: inherit;">Métodos comprovados para aumentar a produtividade. </font><font style="vertical-align: inherit;">do inglês </font><font style="vertical-align: inherit;">- SPb.: Alpha-book LLC, 2017. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Meyers1] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meyers, Scott. </font><font style="vertical-align: inherit;">Uso efetivo de C ++. </font><font style="vertical-align: inherit;">55 maneiras seguras de melhorar a estrutura e o código dos seus programas. </font><font style="vertical-align: inherit;">do inglês </font><font style="vertical-align: inherit;">- M .: DMK Press, 2014.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt490626/index.html">Um guia completo para dados- * atributos HTML</a></li>
<li><a href="../pt490628/index.html">O que fazer quando o CSS bloqueia a análise de página?</a></li>
<li><a href="../pt490630/index.html">Carregando matrizes NumPy do disco: Comparando memmap () e Zarr / HDF5</a></li>
<li><a href="../pt490634/index.html">Eventos digitais em Moscou de 2 a 8 de março</a></li>
<li><a href="../pt490636/index.html">Eventos digitais em São Petersburgo, de 2 a 8 de março</a></li>
<li><a href="../pt490642/index.html">Plug-in para monitorar aplicativos K8s DevOpsProdigy KubeGraf v1.3.0: nova versão e novos recursos</a></li>
<li><a href="../pt490644/index.html">Repositório rpm simples usando Inotify e webdav</a></li>
<li><a href="../pt490648/index.html">Usando recipientes Kata no Kubernetes</a></li>
<li><a href="../pt490650/index.html">Os principais erros na compilação de um currículo de especialistas iniciantes em TI</a></li>
<li><a href="../pt490652/index.html">Logística. Introdução Quase complicado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>