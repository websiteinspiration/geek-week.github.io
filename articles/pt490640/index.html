<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàπ üë©üèø‚Äçü§ù‚Äçüë©üèΩ ü•í Sobrecarga em C ++. Parte III Sobrecarregando novas instru√ß√µes / exclus√£o üí™üèª üè• üë©üèø‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos a s√©rie "C ++, cavando em profundidade". O objetivo desta s√©rie √© informar o m√°ximo poss√≠vel sobre os v√°rios recursos do idioma, possivelm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sobrecarga em C ++. Parte III Sobrecarregando novas instru√ß√µes / exclus√£o</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490640/"><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuamos a s√©rie "C ++, cavando em profundidade". </font><font style="vertical-align: inherit;">O objetivo desta s√©rie √© informar o m√°ximo poss√≠vel sobre os v√°rios recursos do idioma, possivelmente bastante especiais. </font><font style="vertical-align: inherit;">Este artigo √© sobre sobrecarga do operador </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este √© o terceiro artigo da s√©rie, o primeiro dedicado a fun√ß√µes e modelos de sobrecarga, localizado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o segundo dedicado a operadores de sobrecarga, localizado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este artigo conclui uma s√©rie de tr√™s artigos sobre sobrecarga em C ++.</font></font><br>
<hr><a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√çndice</font></font></h1><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√çndice</font></font></b><div class="spoiler_text">&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.    new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.1.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.3.     </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.1.     </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2.1.      new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2.2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2.3.  </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2.4. </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2.5.    operator delete()</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.   new/delete</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.    </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5. -  </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a><br>
</div></div><br>
<a name="id-1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Formul√°rios padr√£o de operadores novos / exclu√≠dos</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ suporta v√°rias op√ß√µes de operador </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eles podem ser divididos em padr√£o b√°sico, padr√£o adicional e personalizado. </font><font style="vertical-align: inherit;">Esta se√ß√£o e a se√ß√£o 2 discutem formul√°rios padr√£o; os formul√°rios personalizados ser√£o discutidos na se√ß√£o 3.</font></font><br>
<br>
<a name="id-1-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1 </font><font style="vertical-align: inherit;">Formul√°rios padr√£o b√°sicos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As principais formas padr√£o de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usadas ao criar e excluir um objeto e uma matriz do tipo s√£o </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as seguintes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span> T[<span class="hljs-comment">/*   */</span>]
<span class="hljs-keyword">delete</span> ptr;
<span class="hljs-keyword">delete</span>[] ptr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O trabalho deles pode ser descrito da seguinte forma. Quando o operador √© chamado </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a mem√≥ria √© alocada primeiro para o objeto. Se a sele√ß√£o for bem sucedida, o construtor √© chamado. Se o construtor lan√ßa uma exce√ß√£o, a mem√≥ria alocada √© liberada. Quando o operador √© chamado, </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tudo acontece na ordem inversa: primeiro, o destruidor √© chamado e a mem√≥ria √© liberada. O destruidor n√£o deve lan√ßar exce√ß√µes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando o operador</font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usada para criar uma matriz de objetos, a mem√≥ria √© alocada primeiro para toda a matriz. Se a sele√ß√£o for bem-sucedida, o construtor padr√£o (ou outro construtor, se houver um inicializador) ser√° chamado para cada elemento da matriz come√ßando do zero. Se algum construtor lan√ßa uma exce√ß√£o, para todos os elementos da matriz criados, o destruidor √© chamado na ordem inversa da chamada do construtor, a mem√≥ria alocada √© liberada. Para excluir uma matriz, voc√™ deve chamar o operador </font></font><code>delete[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, para todos os elementos da matriz, o destruidor √© chamado na ordem inversa do construtor e a mem√≥ria alocada √© liberada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aten√ß√£o! √â necess√°rio chamar a forma correta do operador</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dependendo se um √∫nico objeto ou matriz √© exclu√≠do. Essa regra deve ser observada rigorosamente, caso contr√°rio, voc√™ poder√° obter um comportamento indefinido, ou seja, tudo pode acontecer: vazamento de mem√≥ria, falha etc. Veja [Meyers1] para detalhes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na descri√ß√£o acima, √© necess√°rio um esclarecimento. Para os chamados tipos triviais (tipos internos, estruturas no estilo C), o construtor padr√£o n√£o pode ser chamado e o destruidor n√£o faz nada em nenhum caso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As fun√ß√µes de aloca√ß√£o de mem√≥ria padr√£o, quando n√£o √© poss√≠vel atender √† solicita√ß√£o, lan√ßam uma exce√ß√£o de tipo </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mas essa exce√ß√£o pode ser detectada; para isso, voc√™ precisa instalar o interceptador global chamando a fun√ß√£o </font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para obter mais detalhes, consulte [Meyers1]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qualquer forma de operador</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aplique com seguran√ßa ao ponteiro nulo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao criar uma matriz com um operador, o </font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamanho pode ser definido como zero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambas as formas do operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permitem o uso de inicializadores entre chaves.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>{<span class="hljs-number">42</span>}
<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>]{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}</code></pre><br>
<a name="id-1-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2 </font><font style="vertical-align: inherit;">Formul√°rios padr√£o adicionais</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao conectar o arquivo de cabe√ßalho </font></font><code>&lt;new&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais 4 formul√°rios de operador padr√£o ficam dispon√≠veis </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(ptr) T(<span class="hljs-comment">/*  */</span>);
<span class="hljs-keyword">new</span>(ptr) T[<span class="hljs-comment">/*   */</span>];
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T(<span class="hljs-comment">/*   */</span>);
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T[<span class="hljs-comment">/*   */</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os dois primeiros s√£o chamados </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de posicionamento sem aloca√ß√£o </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Um argumento </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© um ponteiro para uma regi√£o da mem√≥ria que √© grande o suficiente para armazenar uma inst√¢ncia ou matriz. Al√©m disso, a √°rea de mem√≥ria deve ter um alinhamento apropriado. Esta vers√£o do operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o aloca mem√≥ria; fornece apenas uma chamada ao construtor. Portanto, esta op√ß√£o permite separar as fases de aloca√ß√£o de mem√≥ria e inicializa√ß√£o de objetos. Esse recurso √© usado ativamente em cont√™ineres padr√£o. O operador </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para objetos criados dessa maneira n√£o pode, √© claro, ser chamado. Para excluir um objeto, voc√™ deve chamar diretamente o destruidor e liberar a mem√≥ria de uma maneira que dependa do m√©todo de aloca√ß√£o de mem√≥ria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As duas segundas op√ß√µes s√£o chamadas de operador n√£o lan√ßando exce√ß√µes </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(nothrow </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e diferem no fato de que, se for imposs√≠vel atender √† solicita√ß√£o, elas retornam </font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas n√£o lan√ßam uma exce√ß√£o de tipo </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A exclus√£o de um objeto ocorre usando o operador principal </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Essas op√ß√µes s√£o consideradas obsoletas e n√£o recomendadas para uso.</font></font><br>
<br>
<a name="id-1-3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3 </font><font style="vertical-align: inherit;">Aloca√ß√£o de mem√≥ria e fun√ß√µes livres</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Formas padr√£o de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usam as seguintes fun√ß√µes de aloca√ß√£o e desaloca√ß√£o:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas fun√ß√µes s√£o definidas no espa√ßo para nome global. </font><font style="vertical-align: inherit;">As fun√ß√µes de aloca√ß√£o de mem√≥ria para as instru√ß√µes </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do </font><font style="vertical-align: inherit;">host n√£o </font><font style="vertical-align: inherit;">fazem nada e simplesmente retornam </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O C ++ 17 suportava formas adicionais de fun√ß√µes de aloca√ß√£o e desaloca√ß√£o de mem√≥ria, indicando alinhamento. </font><font style="vertical-align: inherit;">Aqui est√£o alguns deles:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esses formul√°rios n√£o s√£o diretamente acess√≠veis ao usu√°rio, eles s√£o usados ‚Äã‚Äãpelo compilador para objetos cujos requisitos de alinhamento s√£o superiores </font></font><code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; portanto, o principal problema √© que o usu√°rio n√£o os oculta acidentalmente (consulte a se√ß√£o 2.2.1). </font><font style="vertical-align: inherit;">Lembre-se de que no C ++ 11 tornou-se poss√≠vel definir explicitamente o alinhamento dos tipos de usu√°rio.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct <span class="hljs-title">alignas</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span> X </span>{ <span class="hljs-comment">/* ... */</span> };</code></pre><br>
<a name="id-2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Sobrecarregando os formul√°rios padr√£o dos operadores new / delete</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A sobrecarga das formas padr√£o de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consiste na defini√ß√£o de fun√ß√µes definidas pelo usu√°rio para alocar e liberar mem√≥ria cujas assinaturas coincidem com as padr√£o. </font><font style="vertical-align: inherit;">Essas fun√ß√µes podem ser definidas no espa√ßo para nome global ou em uma classe, mas n√£o em um espa√ßo para nome que n√£o seja global. </font><font style="vertical-align: inherit;">A fun√ß√£o de aloca√ß√£o de mem√≥ria para uma instru√ß√£o de host padr√£o </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o pode ser definida no espa√ßo para nome global. </font><font style="vertical-align: inherit;">Ap√≥s essa defini√ß√£o, os operadores correspondentes </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">os usar√£o, n√£o os padr√£o.</font></font><br>
<br>
<a name="id-2-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1 </font><font style="vertical-align: inherit;">Sobrecarga no espa√ßo de nomes global</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha, por exemplo, em um m√≥dulo em um espa√ßo para nome global que fun√ß√µes definidas pelo usu√°rio sejam definidas:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
</span>{
<span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, haver√° realmente uma substitui√ß√£o (substitui√ß√£o) das fun√ß√µes padr√£o para alocar e liberar mem√≥ria para todas as chamadas do operador </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para quaisquer classes (incluindo as padr√£o) em todo o m√≥dulo. Isso pode levar ao caos completo. Observe que o mecanismo de substitui√ß√£o descrito √© um mecanismo especial implementado apenas para este caso, e n√£o um mecanismo geral do C ++. Nesse caso, ao implementar as fun√ß√µes do usu√°rio para alocar e liberar mem√≥ria, torna-se imposs√≠vel chamar as fun√ß√µes padr√£o correspondentes, elas ficam completamente ocultas (o operador </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o ajuda) e, quando voc√™ tenta cham√°-las, ocorre uma chamada recursiva √† fun√ß√£o do usu√°rio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fun√ß√£o definida pelo espa√ßo de nomes global</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele tamb√©m substituir√° o padr√£o, mas haver√° menos problemas em potencial, porque o operador que n√£o lan√ßa exce√ß√µes </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© raramente usado. </font><font style="vertical-align: inherit;">Mas o formul√°rio padr√£o tamb√©m n√£o est√° dispon√≠vel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A mesma situa√ß√£o com fun√ß√µes para matrizes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A sobrecarga de instru√ß√µes </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no namespace global √© altamente desencorajada.</font></font><br>
<br>
<a name="id-2-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2 </font><font style="vertical-align: inherit;">Sobrecarga de classe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A sobrecarga de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em uma classe √© desprovida das desvantagens descritas acima. </font><font style="vertical-align: inherit;">A sobrecarga √© efetiva apenas ao criar e excluir inst√¢ncias da classe correspondente, independentemente do contexto de chamada de operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ao implementar fun√ß√µes definidas pelo usu√°rio para alocar e liberar mem√≥ria usando o operador, </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voc√™ pode acessar as fun√ß√µes padr√£o correspondentes. </font><font style="vertical-align: inherit;">Considere um exemplo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span>
{</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete\n"</span>;<font></font>
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new[]\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete[]\n"</span>;<font></font>
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](ptr);<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste exemplo, o rastreamento √© simplesmente adicionado √†s opera√ß√µes padr√£o. </font><font style="vertical-align: inherit;">Agora, em termos </font></font><code>new X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>new X[N]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usar√° essas fun√ß√µes para alocar e liberar mem√≥ria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas fun√ß√µes s√£o formalmente est√°ticas e podem ser declaradas como </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas, essencialmente, s√£o inst√¢ncias, com a chamada da fun√ß√£o </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a cria√ß√£o da inst√¢ncia come√ßa e a chamada da fun√ß√£o </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">completa sua exclus√£o. </font><font style="vertical-align: inherit;">Essas fun√ß√µes nunca s√£o chamadas para outras tarefas. </font><font style="vertical-align: inherit;">Al√©m disso, como ser√° mostrado abaixo, a fun√ß√£o </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© essencialmente virtual. </font><font style="vertical-align: inherit;">Portanto, √© mais correto declar√°-los sem </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1 </font><font style="vertical-align: inherit;">Acesso a formul√°rios padr√£o de operadores novos / exclu√≠dos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podem ser usados ‚Äã‚Äãcom um operador de resolu√ß√£o de escopo adicional, por exemplo </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nesse caso, a fun√ß√£o </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definida na classe ser√° ignorada e o padr√£o correspondente ser√° usado. </font><font style="vertical-align: inherit;">Da mesma maneira, voc√™ pode usar o operador </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2 </font><font style="vertical-align: inherit;">Ocultando outras formas de operadores new / delete</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se agora, para a classe </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tentamos usar ou n√£o exce√ß√µes </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, obtemos um erro. </font><font style="vertical-align: inherit;">O fato √© que a fun√ß√£o </font></font><code>operator new(std::size_t size)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oculta outras formas </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O problema pode ser resolvido de duas maneiras. </font><font style="vertical-align: inherit;">No primeiro, voc√™ precisa adicionar as op√ß√µes apropriadas √† classe (essas op√ß√µes devem simplesmente delegar a opera√ß√£o da fun√ß√£o padr√£o). </font><font style="vertical-align: inherit;">No segundo, voc√™ precisa usar um operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com um operador de resolu√ß√£o de escopo, por exemplo </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3 </font><font style="vertical-align: inherit;">Recipientes padr√£o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se tentarmos colocar as inst√¢ncias </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em algum cont√™iner padr√£o, por exemplo </font></font><code>std::vector&lt;X&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, veremos que nossas fun√ß√µes n√£o s√£o usadas para alocar e liberar mem√≥ria. </font><font style="vertical-align: inherit;">O fato √© que todos os cont√™ineres padr√£o t√™m seu pr√≥prio mecanismo para alocar e liberar mem√≥ria (uma classe de alocador especial, que √© um par√¢metro de modelo do cont√™iner) e usam um operador de posicionamento para inicializar os elementos </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.4 </font><font style="vertical-align: inherit;">Heran√ßa</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fun√ß√µes para alocar e liberar mem√≥ria s√£o herdadas. Se essas fun√ß√µes forem definidas na classe base, mas n√£o na classe derivada, os operadores ser√£o sobrecarregados para a classe derivada </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e as fun√ß√µes definidas e alocadas na classe base ser√£o usadas para alocar e liberar mem√≥ria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora considere uma hierarquia de classes polim√≥rfica, em que cada classe sobrecarrega os operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Agora, deixe a inst√¢ncia da classe derivada ser exclu√≠da usando o operador </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atrav√©s de um ponteiro para a classe base. Se o destruidor da classe base for virtual, o padr√£o garantir√° que o destruidor dessa classe derivada seja chamado. Nesse caso </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a </font><font style="vertical-align: inherit;">chamada de fun√ß√£o </font><font style="vertical-align: inherit;">definida para esta classe derivada </font><font style="vertical-align: inherit;">tamb√©m √© garantida </font><font style="vertical-align: inherit;">. Assim, a fun√ß√£o √© </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente virtual.</font></font><br>
<br>
<a name="id-2-2-5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.5 </font><font style="vertical-align: inherit;">Forma alternativa da fun√ß√£o delete () do operador</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em uma classe (especialmente quando a heran√ßa √© usada), √†s vezes √© conveniente usar uma forma alternativa da fun√ß√£o para liberar mem√≥ria:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O par√¢metro </font></font><code>size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define o tamanho do elemento (mesmo na vers√£o da matriz). </font><font style="vertical-align: inherit;">Este formul√°rio permite usar fun√ß√µes diferentes para alocar e liberar mem√≥ria, dependendo da classe derivada espec√≠fica.</font></font><br>
<br>
<a name="id-3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Operadores de usu√°rios novos / exclu√≠dos</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O C ++ pode oferecer suporte a formul√°rios personalizados do operador, do </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seguinte formato:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T[<span class="hljs-comment">/*   */</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que esses formul√°rios sejam suportados, √© necess√°rio determinar as fun√ß√µes apropriadas para alocar e liberar mem√≥ria:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>);
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A lista de par√¢metros adicionais das fun√ß√µes de aloca√ß√£o de mem√≥ria n√£o deve estar vazia e n√£o deve consistir em uma </font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>const std::nothrow_t&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">ou </font><font style="vertical-align: inherit;">seja, sua assinatura n√£o deve coincidir com uma das padr√£o. Lista de par√¢metros adicionais </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve corresponder. Os argumentos passados ‚Äã‚Äãpara o operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devem corresponder a par√¢metros adicionais das fun√ß√µes de aloca√ß√£o de mem√≥ria. Uma fun√ß√£o personalizada </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamb√©m pode estar no formul√°rio com um par√¢metro de tamanho opcional.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas fun√ß√µes podem ser definidas no espa√ßo para nome global ou em uma classe, mas n√£o em um espa√ßo para nome que n√£o seja global. Se eles s√£o definidos no espa√ßo de nomes global, eles n√£o substituem, mas sobrecarregam, as fun√ß√µes padr√£o de aloca√ß√£o e libera√ß√£o de mem√≥ria; portanto, seu uso √© previs√≠vel e seguro, e as fun√ß√µes padr√£o est√£o sempre dispon√≠veis. Se eles s√£o definidos na classe, ocultam os formul√°rios padr√£o, mas o acesso aos formul√°rios padr√£o pode ser obtido usando o operador </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, isso √© descrito em detalhes na se√ß√£o 2.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os formul√°rios de operador </font><font style="vertical-align: inherit;">definidos pelo usu√°rio </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√£o chamados </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de posicionamento definido pelo usu√°rio </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Eles n√£o devem ser confundidos com o operador de posicionamento padr√£o (n√£o alocado) </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descrito na se√ß√£o 1.2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O formul√°rio do operador correspondente </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o existe. </font><font style="vertical-align: inherit;">Existem </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duas maneiras de </font><font style="vertical-align: inherit;">excluir um objeto criado usando um operador definido pelo usu√°rio </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se uma fun√ß√£o definida pelo usu√°rio </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delegar uma opera√ß√£o de aloca√ß√£o de mem√≥ria para fun√ß√µes de aloca√ß√£o de mem√≥ria padr√£o, um operador padr√£o poder√° ser usado </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Caso contr√°rio, voc√™ precisar√° chamar explicitamente o destruidor e, em seguida, a fun√ß√£o definida pelo usu√°rio </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O compilador chama a fun√ß√£o definida pelo usu√°rio em </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas um caso: quando o </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">construtor lan√ßa uma exce√ß√£o </font><font style="vertical-align: inherit;">durante a opera√ß√£o do operador definido pelo usu√°rio </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° um exemplo (no escopo global).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"new "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"delete "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;<font></font>
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span><span class="hljs-comment">/* ... */</span>};<font></font>
X* p = <span class="hljs-keyword">new</span>(<span class="hljs-number">42</span>, <span class="hljs-string">"meow"</span>) X(); <span class="hljs-comment">// : new 42 + meow</span>
<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//   ::operator delete()</span></code></pre><br>
<a name="id-4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Defini√ß√£o de fun√ß√µes de aloca√ß√£o de mem√≥ria</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nestes exemplos, fun√ß√µes de usu√°rio </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opera√ß√£o delegada correspondentes √†s fun√ß√µes padr√£o. √Äs vezes, essa op√ß√£o √© √∫til, mas o principal objetivo da sobrecarga </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© criar um novo mecanismo para alocar / liberar mem√≥ria. A tarefa n√£o √© simples e, antes de realiz√°-la, √© preciso pensar cuidadosamente em tudo. Scott Meyers [Meyers1] discute poss√≠veis motivos para tomar tal decis√£o (√© claro, o principal √© a efici√™ncia). Ele tamb√©m discute os principais problemas t√©cnicos associados √† implementa√ß√£o correta de fun√ß√µes definidas pelo usu√°rio para alocar e liberar mem√≥ria (usando a fun√ß√£o</font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sincroniza√ß√£o multithread, alinhamento). </font><font style="vertical-align: inherit;">Guntheroth fornece um exemplo da implementa√ß√£o de fun√ß√µes de aloca√ß√£o e desaloca√ß√£o de mem√≥ria definidas pelo usu√°rio relativamente simples. </font><font style="vertical-align: inherit;">Antes de criar sua pr√≥pria vers√£o, voc√™ deve procurar solu√ß√µes prontas, como exemplo, voc√™ pode trazer a biblioteca Pool do projeto Boost.</font></font><br>
<br>
<a name="id-5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Classes de alocadores de cont√™ineres padr√£o</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como mencionado acima, os cont√™ineres padr√£o usam classes especiais de alocador para alocar e liberar mem√≥ria. </font><font style="vertical-align: inherit;">Essas classes s√£o par√¢metros de modelo de cont√™ineres e o usu√°rio pode definir sua vers√£o dessa classe. </font><font style="vertical-align: inherit;">Os motivos para tal solu√ß√£o s√£o aproximadamente os mesmos que para sobrecarregar os operadores </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Guntheroth] descreve como criar essas classes.</font></font><br>
<br>
<a name="id-refs"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliografia</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Guntheroth] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gunteroth, Kurt. </font><font style="vertical-align: inherit;">Otimiza√ß√£o de programas em C ++. </font><font style="vertical-align: inherit;">M√©todos comprovados para aumentar a produtividade. </font><font style="vertical-align: inherit;">do ingl√™s </font><font style="vertical-align: inherit;">- SPb.: Alpha-book LLC, 2017. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Meyers1] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meyers, Scott. </font><font style="vertical-align: inherit;">Uso efetivo de C ++. </font><font style="vertical-align: inherit;">55 maneiras seguras de melhorar a estrutura e o c√≥digo dos seus programas. </font><font style="vertical-align: inherit;">do ingl√™s </font><font style="vertical-align: inherit;">- M .: DMK Press, 2014.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt490626/index.html">Um guia completo para dados- * atributos HTML</a></li>
<li><a href="../pt490628/index.html">O que fazer quando o CSS bloqueia a an√°lise de p√°gina?</a></li>
<li><a href="../pt490630/index.html">Carregando matrizes NumPy do disco: Comparando memmap () e Zarr / HDF5</a></li>
<li><a href="../pt490634/index.html">Eventos digitais em Moscou de 2 a 8 de mar√ßo</a></li>
<li><a href="../pt490636/index.html">Eventos digitais em S√£o Petersburgo, de 2 a 8 de mar√ßo</a></li>
<li><a href="../pt490642/index.html">Plug-in para monitorar aplicativos K8s DevOpsProdigy KubeGraf v1.3.0: nova vers√£o e novos recursos</a></li>
<li><a href="../pt490644/index.html">Reposit√≥rio rpm simples usando Inotify e webdav</a></li>
<li><a href="../pt490648/index.html">Usando recipientes Kata no Kubernetes</a></li>
<li><a href="../pt490650/index.html">Os principais erros na compila√ß√£o de um curr√≠culo de especialistas iniciantes em TI</a></li>
<li><a href="../pt490652/index.html">Log√≠stica. Introdu√ß√£o Quase complicado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>