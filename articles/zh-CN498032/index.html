<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛷 👩‍🚒 🅿️ 在C＃中从Excel快速计算公式 🎏 🦔 🍂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您多久收到一次客户听到他们将数据发送到Excel或要求您以Excel兼容格式导入或上传的信息？我确信在大多数领域，Excel是最流行，功能最强大且同时又简单便捷的工具之一。但是，最棘手的问题总是将此类数据与各种自动化系统集成在一起。我们的团队被要求考虑使用自定义Excel文件中的设置执行数据计算的可...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>在C＃中从Excel快速计算公式</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/arcadia/blog/498032/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您多久收到一次客户听到他们将数据发送到Excel或要求您以Excel兼容格式导入或上传的信息？</font><font style="vertical-align: inherit;">我确信在大多数领域，Excel是最流行，功能最强大且同时又简单便捷的工具之一。</font><font style="vertical-align: inherit;">但是，最棘手的问题总是将此类数据与各种自动化系统集成在一起。</font><font style="vertical-align: inherit;">我们的团队被要求考虑使用自定义Excel文件中的设置执行数据计算的可能性。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/8g/to/wx/8gtowxbs0dnpmjvr59epns8b0sq.jpeg" alt="在C＃中从Excel快速计算公式"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您需要选择一种用于处理Excel文件的高效库，或者正在寻找一种使用方便的工具来管理和可视化公式的复杂财务（不仅是）数据计算解决方案，欢迎使用。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在研究公司新项目的需求时，我们发现了一个非常有趣的观点：“开发的解决方案应该能够在更改配置时计算产品（即阳台）的成本，并在界面上立即显示新成本。必须具有下载具有所有计算功能和组件价格清单的Excel文件的能力。”客户需要开发一个门户网站，以根据尺寸，形状，玻璃和所用材料的类型，紧固件的类型以及许多其他相关参数（用于计算确切的生产成本和可靠性指标）来设计阳台的配置。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们对输入要求进行了形式化处理，以便更轻松地了解在何种情况下需要解决此问题：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改阳台参数时，可以在界面上快速计算价格；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快速计算设计数据，包括许多不同的阳台配置和单独的要约，由单独的计算文件提供；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从长远来看-使用各种消耗资源的操作（优化参数的任务等）进行功能开发</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有这些都在通过API输出的远程服务器上，因为 </font><font style="vertical-align: inherit;">所有公式都是客户的知识产权，第三方不应看到；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">峰值输入数据流：用户可以根据自己的需求频繁，快速地更改参数以选择产品配置。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
听起来很不寻常，而且很诱人，让我们开始吧！</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交钥匙解决方案和数据准备</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解决复杂问题的任何研究都始于在StackOverflow，GitHub和许多寻求现成解决方案的论坛上冲浪。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
选择了几种现成的解决方案，这些解决方案支持从Excel文件读取数据，并能够基于库中指定的公式执行计算。</font><font style="vertical-align: inherit;">这些库中有完全免费的解决方案和商业开发。&nbsp;</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图书馆</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文献资料</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执照</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EPPlus 4</font></font></strong></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/JanKallman/EPPlus</font></font></a></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/JanKallman/EPPlus/wiki</font></font></a></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU图书馆通用公共许可证&nbsp;</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EPPlus 5</font></font></strong></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/EPPlusSoftware/EPPlus</font></font></a></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/EPPlusSoftware/EPPlus/wiki</font></font></a></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polyform非商业许可证1.0.0（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.epplussoftware.com/LicenseOverview</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）&nbsp;</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非营利组织</font></font></strong></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/tonyqus/npoi</font></font></a></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/tonyqus/npoi/wiki</font></font></a></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache许可2.0</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尖塔</font></font></strong></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.e-iceblue.com/Introduce/excel-for-net-introduce.html</a></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.e-iceblue.com/Tutorials/Spire.XLS/Spire.XLS-Program-Guide/Spire.XLS-Program-Guide-Content.html</a></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.e-iceblue.com/Tutorials/Licensing/License-Agreement.html</a>&nbsp;</td>
</tr>
<tr>
<td><strong>Excel Interop</strong><i>(Microsoft.Office.Interop.Excel)</i></td>
<td>n/a</td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.microsoft.com/ru-ru/dotnet/api/microsoft.office.interop.excel._workbook?view=excel-pia</a></td>
<td><i>  Excel     </i></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一步是编写负载测试并测量每个库的运行时间。为此，请准备测试数据。我们创建一个新的Excel文件，为输入参数定义10个单元格，并定义</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公式</font><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记住这一刻</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）以获得使用所有输入参数的结果。在公式中，我们尝试使用各种计算复杂性的所有可能的数学函数，并以棘手的方式将它们组合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因为这也与金钱（产品的成本）有关，重要的是要看结果的准确性。在这种情况下，我们将使用</font><strong><font style="vertical-align: inherit;">Excel Interop</font></strong><font style="vertical-align: inherit;">作为参考获得的结果值</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因为以这种方式获得的数据是通过Excel核心计算的，等于客户在开发公式和手动计算成本时看到的值。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为参考运行时，我们将使用纯C＃手动编写的本机代码来显示用Excel编写的相同公式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
翻译的初始测试公式：</font></font><br>
<br>
<pre><code class="plaintext hljs">public double Execute(double[] p)<font></font>
{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return Math.Pow(p[0] * p[8] / p[4] * Math.Sin(p[5]) * Math.Cos(p[2]) +<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Math.Abs(p[1] - (p[2] + p[3] + p[4] + p[5] + p[6] + p[7] + p[8]))<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Math.Sqrt(p[0] * p[0] + p[1] * p[1]) / 2.0 * Math.PI, p[9]);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们形成N次迭代的随机输入数据流（在这种情况下，我们使用10,000个向量）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们开始对整个流上输入参数的每个向量进行计算，获取结果并测量库初始化和常规计算的时间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了比较结果的准确性，我们使用两个指标-标准偏差和具有一定精度步长ε的匹配值的百分比。如果您随机生成一个输入值列表，小数点后有一个浮点数，则必须确定输入参数的准确性-这将使您获得正确的结果。否则，随机数可能具有数量级的较大差异-这会极大地影响结果的准确性并影响结果误差的估计。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因为最初，我们假设需要以材料成本的恒定值以及来自不同知识领域的一些常数进行操作，我们可以接受所有输入参数的值都将精确到小数点后三位。理想情况下，您需要为每个参数指定一个有效的值范围，并仅使用它们来生成随机值，但是由于测试公式是在没有任何数学和物理依据的情况下随机编译的，因此不可能在合理的时间内为所有10个参数计算出如此范围的值。因此，在计算中有时可能会获得计算误差。在计算准确性指标时，我们已经排除了此类输入数据向量，但是我们会将此类错误视为单独的特征。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试架构&nbsp;</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于每一个单独的库，它自己的类已经创建实现接口</font></font><code>ITestExecutor </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其包括3种方法- </font></font><code>SetUp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>Execute </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>TearDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">public interface ITestExecutor<font></font>
{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;//      <font></font>
&nbsp;&nbsp;&nbsp;&nbsp;void SetUp();<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;//   ,           <font></font>
&nbsp;&nbsp;&nbsp;&nbsp;double Execute(double[] p);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;//    ,      <font></font>
&nbsp;&nbsp;&nbsp;&nbsp;void TearDown();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方法</font></font><code>SetUp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>TearDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在测试库的过程中仅使用一次，并且在对整个输入数据集进行时间计算时不考虑这些方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，测试算法归结为以下内容：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据准备（我们形成给定精度的输入向量流）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为结果数据分配内存（每个库一个结果数组，一个包含错误数量的数组）；&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库的初始化；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过将结果保存在预先准备好的数组中并记录执行时间来获取每个库的计算结果；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用库代码完成工作；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据分析：</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该算法的图形表示如下。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/yg/e0/slyge0dloc1dednqql-hgga6um4.png" alt="Excel支持库的性能和准确性测试的流程图"></div><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一次迭代的结果</font></font></h1><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指数</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本机</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EPPlus 4</font></font></strong><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EPPlus 5</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非营利组织</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尖塔</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel互操作</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化时间（毫秒）</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">257</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">266</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">632</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1653</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">星期三 </font><font style="vertical-align: inherit;">1次通过的时间（毫秒）</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,0002</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.4086</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.6847</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.9782</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">38.8423</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平均 </font><font style="vertical-align: inherit;">偏差</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,000394</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,000395</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,000237</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,000631</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不适用</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准确性</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">99.99％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">99.92％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">99.97％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">99.84％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不适用</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">失误</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,0％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.94％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.94％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.52％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.94％</font></font></td>
</tr>
</tbody></table></div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么将EPPlus 5和EPPlus 4的结果结合起来？</font></font></b>
                        <div class="spoiler_text">      EPPlus      .    ,       ,         .    ,         .     EPPlus 5     ,       .          ,      EPPlus,    .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
测试的第一次迭代显示出良好的结果，其中库中的领导立即可见。</font><font style="vertical-align: inherit;">从以上数据可以看出，这种情况下的绝对领先者是EPPlus库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与本地代码相比，结果并不令人印象深刻，但是您可以生活。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本来可以停止的，但是在与客户交谈之后，最初的疑虑逐渐蔓延：结果太好了。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zp/7s/ry/zp7sryxdmhkg5rp8xfhwf537kti.jpeg"></div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用Spire库的功能</font></font></b>
                        <div class="spoiler_text">     Spire  ,             InvalidCastException.      ,          Excel-    ,     ,      ,     .                    try...catch.       ,         .<br>
</div>
                    </div><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一次测试重复</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上面，我请您提请注意在取得结果中起重要作用的一点。我们怀疑客户的真实Excel文件中使用的公式与原始数据相差很远，内部存在许多依赖性，但是我们并不怀疑这会严重影响指标。但是，最初，在编译测试数据时，我没有预见到这一点，并且来自客户的数据（至少在最终文件中使用了至少120个输入参数的信息）暗示我们需要考虑并添加具有单元格之间依存关系的公式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们开始为下一次测试迭代准备新数据。</font><font style="vertical-align: inherit;">让我们详细介绍10个输入参数并添加仅依赖于参数和1个聚合公式的另外4个新公式，该公式基于这四个具有公式的单元格，并且还将依赖于输入数据的值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用于后续测试的新公式：</font></font><br>
<br>
<pre><code class="plaintext hljs">public double Execute(double[] p)<font></font>
{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var price1 = Math.Pow(p[0] * p[8] / p[4] * Math.Sin(p[5]) * Math.Cos(p[2]) +<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Math.Abs(p[1] - (p[2] + p[3] + p[4] + p[5] + p[6] + p[7] + p[8]))<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Math.Sqrt(p[0] * p[0] + p[1] * p[1]) / 2.0 * Math.PI, p[9]);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var price2 = p[4] * p[5] * p[2] / Math.Max(1, Math.Abs(p[7]));<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var price3 = Math.Abs(p[7] - p[3]) * p[2];<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var price4 = Math.Sqrt(Math.Abs(p[1] * p[2] + p[3] * p[4] + p[5] * p[6]) + 1.0);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var price5 = p[0] * Math.Cos(p[1]) + p[2] * Math.Sin(p[1]);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var sum = p[0] + p[1] + p[2] + p[3] + p[4] + p[5] + p[6] + p[7] + p[8] + p[9];<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var price6 = sum / Math.Max(1, Math.Abs((p[0] + p[1] + p[2] + p[3]) / 4.0))<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ sum / Math.Max(1, Math.Abs((p[4] + p[5] + p[6] + p[7] + p[8] + p[9]) / 6.0));<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var pricingAverage = (price1 + price2 + price3 + price4 + price5 + price6) / 6.0;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return pricingAverage / Math.Max(1, Math.Abs(price1 + price2 + price3 + price4 + price5 + price6));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，结果公式变得更加复杂，这自然会影响结果-并非更好。</font><font style="vertical-align: inherit;">结果表如下：</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指数</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本机</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EPPlus 4 </font></font></strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EPPlus 5</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非营利组织</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尖塔</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel互操作</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化时间（毫秒）</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">241</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">368</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">722</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1640</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">星期三 </font><font style="vertical-align: inherit;">1次通过的时间（毫秒）</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,0004</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.9174 </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（+ 124％）</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.8996 </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（+ 177％）</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.7647 </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（+ 11％）</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50.7194 </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（+ 30％）</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平均 </font><font style="vertical-align: inherit;">偏差</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,035884</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.000000</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.000000</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.000000</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不适用</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准确性</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">98.79％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100.00％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100.00％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100.00％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不适用</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">失误</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,0％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.3％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.3％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.28％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.3％</font></font></td>
</tr>
</tbody></table></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/xg/l5/ye/xgl5yefp3_meak1f4qzj1mctjsm.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：因为 </font><font style="vertical-align: inherit;">Excel Interop太大，必须从图表中排除。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从结果可以看出，这种情况已完全不适合在生产中使用。</font><font style="vertical-align: inherit;">有点难过，储备咖啡，然后深入研究-直接进入代码生成。&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/d_/kh/nvd_khyfluufkuwh64vikgafdpe.jpeg"></div><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码生成</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您突然从未遇到过类似的任务，那么我们将进行一次简短的游览。&nbsp;</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码生成</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一种通过基于输入数据动态生成源代码并随后进行编译和执行来解决问题的方法。</font><font style="vertical-align: inherit;">在项目的构建过程中会发生静态代码生成（例如，我可以引用T4MVC的示例，T4MVC基于编写主应用程序代码时可以使用的模板和元数据创建新代码），以及在运行时运行的动态代码。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的任务是根据源数据（来自Excel的公式）形成一个新函数，该函数根据输入值的向量接收结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，您必须：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从文件中读取公式；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收集所有依赖项；</font></font></li>
<li>       C#;</li>
<li>     ;</li>
<li>            ;</li>
<li>     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所提供的所有库均适合阅读公式，但是事实证明，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EPPlus</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库是此类功能最方便的接口</font><font style="vertical-align: inherit;">。在对该库的源代码进行了一些翻阅之后，我发现了用于形成标记列表并将其进一步转换为表达式树的公共类。宾果，我想！现成的表达式树是理想的选择，只需遍历它并形成我们的C＃代码即可。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，当我开始研究生成的表达式树的节点时，一大麻烦在等着我。某些节点（尤其是对Excel函数的调用）封装了有关所使用的函数及其输入参数的信息，并且未提供对此数据的任何开放式访问。因此，必须推迟使用完成的表达式树。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们往下走了一层，尝试使用令牌列表。这里的一切都非常简单：我们拥有具有类型和值的令牌。因为我们得到一个函数，我们需要形成一个函数，那么我们可以将树标记转换为C＃中的等效标记。这种方法的主要目的是组织兼容的功能。大多数数学函数已经兼容-例如计算余弦，正弦，求根，求幂。但是聚合函数（例如最大值，最小值，数量）需要完成。主要区别在于，在Excel中，这些函数使用一定范围的值。为了简化原型，我们将创建将参数列表作为输入的函数，然后将值的范围扩展为线性列表。这样，我们就可以从Excel语法正确地兼容转换为C＃语法。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是将令牌列表从Excel公式转换为有效C＃代码的主要代码。</font></font><br>
<br>
<pre><code class="plaintext hljs">private string TransformToSharpCode(string formula, ParsingContext parsingContext)<font></font>
{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// Initialize basic compile components, e.g. lexer<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var lexer = new Lexer(parsingContext.Configuration.FunctionRepository, parsingContext.NameValueProvider);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// List of dependency variables that can be filled during formula transformation<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var variables = new Dictionary&lt;string, string&gt;();<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;using (var scope = parsingContext.Scopes.NewScope(RangeAddress.Empty))<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Take resulting code line<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var compiledResultCode = TransformToSharpCode(formula, parsingContext, scope, lexer, variables);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var output = new StringBuilder();<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Define dependency variables in reverse order.<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach (var variableDefinition in variables.Reverse())<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.AppendLine($"var {variableDefinition.Key} = {variableDefinition.Value};");<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Take the result<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.AppendLine($"return {compiledResultCode};");<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return output.ToString();<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
private string TransformToSharpCode(ICollection&lt;Token&gt; tokens, ParsingContext parsingContext, ParsingScope scope, ILexer lexer, Dictionary&lt;string, string&gt; variables)<font></font>
{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var output = new StringBuilder();<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;foreach (Token token in tokens)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (token.TokenType)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case TokenType.Function:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.Append(BuildFunctionName(token.Value));<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case TokenType.OpeningParenthesis:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.Append("(");<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case TokenType.ClosingParenthesis:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.Append(")");<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case TokenType.Comma:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.Append(", ");<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case TokenType.ExcelAddress:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var address = token.Value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.Append(TransformAddressToSharpCode(address, parsingContext, scope, lexer, variables));<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case TokenType.Decimal:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case TokenType.Integer:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case TokenType.Boolean:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.Append(token.Value);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case TokenType.Operator:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.Append(token.Value);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return output.ToString();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
转换中的下一个细微差别是使用Excel常量-它们是函数，因此在C＃中，它们也必须包装在函数中。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
剩下的只是解决一个问题：将单元格引用转换为参数。在令牌包含有关该单元格的信息的情况下，我们首先确定该单元格中存储了什么。如果这是一个公式，则递归扩展它。如果用C＃-analog链接替换常量，形式为</font></font><code>p[row, column]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">则常量</font></font><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以是二维数组或用于正确数据映射的索引访问类。对于一定范围的单元格，我们执行相同的操作，只是将范围预先扩展为单个单元格并分别进行处理。因此，我们在翻译Excel函数时涵盖了主要功能。&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gw/kk/hz/gwkkhzpfeudqdzcbfsgsdzdtolo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是将链接到Excel电子表格单元格的代码转换为有效的C＃代码的代码：</font></font><br>
<br>
<pre><code class="plaintext hljs">private string TransformAddressToSharpCode(string excelAddress, ParsingContext parsingContext, ParsingScope scope, ILexer lexer, Dictionary&lt;string, string&gt; variables)<font></font>
{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// Try to parse excel range of addresses<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// Currently, reference to another worksheet in address string is not supported<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var rangeParts = excelAddress.Split(':');<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;if (rangeParts.Length == 1)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Unpack single excel address<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return UnpackExcelAddress(excelAddress, parsingContext, scope, lexer, variables);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// Parse excel range address<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;ParseAddressToIndexes(rangeParts[0], out int startRowIndex, out int startColumnIndex);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;ParseAddressToIndexes(rangeParts[1], out int endRowIndex, out int endColumnIndex);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var rowDelta = endRowIndex - startRowIndex;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var columnDelta = endColumnIndex - startColumnIndex;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var allAccessors = new List&lt;string&gt;(Math.Abs(rowDelta * columnDelta));<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// TODO This part of code doesn't support reverse-ordered range address<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;for (var rowIndex = startRowIndex; rowIndex &lt;= endRowIndex; rowIndex++)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (var columnIndex = startColumnIndex; columnIndex &lt;= endColumnIndex; columnIndex++)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Unpack single excel address<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allAccessors.Add(UnpackExcelAddress(rowIndex, columnIndex, parsingContext, scope, lexer, variables));<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return string.Join(", ", allAccessors);<font></font>
}<font></font>
<font></font>
private string UnpackExcelAddress(string excelAddress, ParsingContext parsingContext, ParsingScope scope, ILexer lexer, Dictionary&lt;string, string&gt; variables)<font></font>
{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;ParseAddressToIndexes(excelAddress, out int rowIndex, out int columnIndex);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return UnpackExcelAddress(rowIndex, columnIndex, parsingContext, scope, lexer, variables);<font></font>
}<font></font>
<font></font>
private string UnpackExcelAddress(int rowIndex, int columnIndex, ParsingContext parsingContext, ParsingScope scope, ILexer lexer, Dictionary&lt;string, string&gt; variables)<font></font>
{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var formula = parsingContext.ExcelDataProvider.GetRangeFormula(_worksheet.Name, rowIndex, columnIndex);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;if (string.IsNullOrWhiteSpace(formula))<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// When excel address doesn't contain information about any excel formula, we should just use external input data parameter provider.<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return $"p[{rowIndex},{columnIndex}]";<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// When formula is provided, try to identify that variable is not defined yet<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// TODO Worksheet name is not included in variable name, potentially that can cause conflicts<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// Extracting and reusing calculations via local variables improves performance for 0.0045ms<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var cellVariableId = $"C{rowIndex}R{columnIndex}";<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;if (variables.ContainsKey(cellVariableId))<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cellVariableId;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// When variable does not exist, transform new formula and register that to variable scope<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;variables.Add(cellVariableId, TransformToSharpCode(formula, parsingContext, scope, lexer, variables));<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return cellVariableId;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
剩下的只是将产生的转换后的代码包装到静态函数中，将程序集与兼容性函数链接，然后编译动态程序集。</font><font style="vertical-align: inherit;">将其加载到内存中，获得指向我们函数的链接-您可以使用它。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们编写用于测试的包装器类，并使用时间测量来运行测试。&nbsp;</font></font><br>
<br>
<pre><code class="plaintext hljs">public void SetUp()<font></font>
{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// Initialize excel package by EPPlus library<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;_package = new ExcelPackage(new FileInfo(_fileName));<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;_workbook = _package.Workbook;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;_worksheet = _workbook.Worksheets[1];<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;_inputRange = new ExcelRange[10];<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;for (int rowIndex = 0; rowIndex &lt; 10; rowIndex++)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_inputRange[rowIndex] = _worksheet.Cells[rowIndex + 1, 2];<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// Access to result cell and extract formula string<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;_resultRange = _worksheet.Cells[11, 2];<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var formula = _resultRange.Formula;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// Initialize parsing context and setup data provider<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var parsingContext = ParsingContext.Create();<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;parsingContext.ExcelDataProvider = new EpplusExcelDataProvider(_package);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// Transform Excel formula to CSharp code<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;var sourceCode = TransformToSharpCode(formula, parsingContext);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// Compile CSharp code to IL dynamic assembly via helper wrappers<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;_code = CodeGenerator.CreateCode&lt;double&gt;(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceCode,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new string[]<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// List of used namespaces<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"System", // Required for Math functions<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"ExcelCalculations.PerformanceTests" // Required for Excel function wrappers stored at ExcelCompiledFunctions static class<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new string[]<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add reference to current compiled assembly, that is required to use Excel function wrappers located at ExcelCompiledFunctions static class<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"....\\bin\\Debug\\ExcelCalculations.PerformanceTests.exe"<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Notify that this source code should use parameter;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Use abstract p parameter - interface for values accessing.<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new CodeParameter("p", typeof(IExcelValueProvider))<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，我们有了此解决方案的原型，并将其标记为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EPPlusCompiled Mark-I</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。运行测试后，我们得到了期待已久的结果。加速度几乎是300倍。已经不错，但是生成的代码仍然比本地代码慢16倍。会更好吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的你可以！由于我们将用变量公式替换指向其他单元格的所有链接，因此尝试改善结果。我们的测试在公式中使用了依赖单元格，因此在翻译器的第一个版本中，我们收到了对相同数据的多次计算。因此，决定在计算中使用中间变量。使用生成的因变量扩展代码后，性能提高了2倍。这种改进称为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EPPlus已编译，Mark-II</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">比较表如下所示：</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图书馆</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">星期三 </font><font style="vertical-align: inherit;">时间（毫秒）</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coef。</font><font style="vertical-align: inherit;">减速</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本机</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.00004</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EPPlus编译，Mark-II</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.003</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EPPlus编译，Mark-I</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.0061</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十六</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EPPlus</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,2089</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3023</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这些条件下以及为任务分配的时间限制下，我们得到的结果使我们更接近本地代码的性能-与原始版本相比有8倍的滞后-3028倍的几个数量级的滞后。</font><font style="vertical-align: inherit;">但是，如果您删除时间限制，那么有可能改善结果并尽可能接近本机代码吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我的答案是肯定的，但是不幸的是，我不再有时间实现这些技术。</font><font style="vertical-align: inherit;">也许我将为此主题专门撰写一篇文章。</font><font style="vertical-align: inherit;">目前，我只能谈论主要思想和选项，以简短摘要的形式编写它们，这些摘要已通过反向转换进行了验证。</font><font style="vertical-align: inherit;">反向转换是指在生成代码的方向上手工编写的本机代码的降级。</font><font style="vertical-align: inherit;">这种方法使您可以足够快地检查某些问题，而无需在代码中进行重大更改。</font><font style="vertical-align: inherit;">它还允许您回答在某些情况下本机代码的性能将如何下降的问题，这意味着，如果在相反的方向上自动改进了生成的代码，则可以在相似系数的情况下获得性能上的改进。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></h2><br>
<ol>
<li>  ,                     ;</li>
<li>           inline      ;</li>
<li> -     Sum, Max, Min   ;</li>
<li>  Sum  inline     ;</li>
<li>   (         )    .</li>
</ol><br>
<h1></h1><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong></strong></td>
<td><strong>Native</strong></td>
<td><strong>EPPlus Compiled, Mark-II</strong></td>
<td><strong>EPPlus 4</strong><strong>EPPlus 5</strong></td>
<td><strong>NPOI</strong></td>
<td><strong>Spire</strong></td>
<td><strong>Excel Interop</strong></td>
</tr>
<tr>
<td><strong>  ()</strong></td>
<td>0</td>
<td>239</td>
<td>241</td>
<td>368</td>
<td>722</td>
<td>1640</td>
</tr>
<tr>
<td><strong>.   1  ()</strong></td>
<td>0,0004</td>
<td>0,003</td>
<td>0,9174</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,8996</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7,7647</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50,7194</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平均 </font><font style="vertical-align: inherit;">偏差</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,035884</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不适用</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准确性</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">98.79％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100.0％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100.0％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100.0％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100.0％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不适用</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">失误</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,0％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,0％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.3％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.3％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.28％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.3％</font></font></td>
</tr>
</tbody></table></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/kd/py/vy/kdpyvy0-qfqtfbwgtvbwjo28coo.png" alt="在C＃中从Excel快速计算公式"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总结这些步骤，我们提供了一种将公式直接从自定义Excel文档转换为服务器上工作代码的机制。</font><font style="vertical-align: inherit;">这使您可以使用将Excel与任何业务解决方案集成的非凡灵活性，而不会失去大量用户习惯使用的强大用户界面。</font><font style="vertical-align: inherit;">在如此短的开发周期内，是否可以使用与Excel中相同的用于分析和可视化数据的工具集来开发这种便捷的界面？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与您必须实现的Excel文档最不寻常，最有趣的集成是什么？</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN498022/index.html">＃341移动开发人员的有趣材料摘要（4月13日至19日）</a></li>
<li><a href="../zh-CN498024/index.html">使用Houdini和Python单击鼠标即可构建城市</a></li>
<li><a href="../zh-CN498026/index.html">FOSS新闻第12号-2020年4月13日至19日免费和开源新闻的回顾</a></li>
<li><a href="../zh-CN498028/index.html">Python COVID-19大流行模拟</a></li>
<li><a href="../zh-CN498030/index.html">备份：在哪里，如何以及为什么？</a></li>
<li><a href="../zh-CN498034/index.html">现代设计飞机的防御能力比您想象的要好，可抵御生物威胁（COVID-19）</a></li>
<li><a href="../zh-CN498036/index.html">马克·安德里森（Mark Andriessen）：现在是时候为自己创造（是时候建造）</a></li>
<li><a href="../zh-CN498038/index.html">上周第411期（2020年4月13日至19日）来自前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN498042/index.html">解析，不验证</a></li>
<li><a href="../zh-CN498046/index.html">研究人员正在开发一种减少计算机视觉数据集中偏差的方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>