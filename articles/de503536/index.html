<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏽 😲 🕵🏾 Bereinigungsattribut 🤚🏿 🐑 🎇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zitat aus der GCC-Dokumentation [1]: 
 
 Das Bereinigungsattribut wird verwendet, um eine Funktion auszuführen, wenn eine Variable den Gültigkeitsbere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Bereinigungsattribut</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503536/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zitat aus der GCC-Dokumentation [1]: </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Bereinigungsattribut wird verwendet, um eine Funktion auszuführen, wenn eine Variable den Gültigkeitsbereich verlässt. Dieses Attribut kann nur auf automatische Variablen angewendet werden und kann nicht mit Parametern oder statischen Variablen verwendet werden. Die Funktion muss einen Parameter annehmen, einen Zeiger auf einen mit der Variablen kompatiblen Typ. Der Rückgabewert der Funktion, falls vorhanden, wird ignoriert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Option -fexceptions aktiviert ist, wird die Funktion cleanup_function gestartet, wenn der Stapel abgewickelt wird, während die Ausnahme verarbeitet wird. Beachten Sie, dass das Bereinigungsattribut keine Ausnahmen abfängt, sondern nur eine Aktion ausführt. Wenn die Bereinigungsfunktion nicht normal zurückkehrt, ist das Verhalten undefiniert.</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/qi/dr/gz/qidrgzjppagqdyrqn7c4ykxa2a4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Das Bereinigungsattribut wird von den Compilern gcc und clang unterstützt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werde ich verschiedene Optionen für die praktische Verwendung des Bereinigungsattributs beschreiben und die interne Struktur der Bibliothek berücksichtigen, die die Bereinigung verwendet, um die Analoga std :: unique_ptr und std :: shared_ptr in C zu implementieren.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir, die Speicherfreigabe zu bereinigen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **ptr)</span> 
</span>{
    <span class="hljs-built_in">free</span>(*ptr); 
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"cleanup done\n"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
    __attribute__((cleanup(free_int))) <span class="hljs-keyword">int</span> *ptr_one = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-comment">// do something here</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir starten, das Programm druckt "Bereinigung erledigt". </font><font style="vertical-align: inherit;">Alles funktioniert, Prost. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Nachteil wird jedoch sofort deutlich: Wir können nicht einfach schreiben</font></font><br>
<br>
<pre><code class="cpp hljs">__attribute__((cleanup(free_int)))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die vom Bereinigungsattribut aufgerufene Funktion einen Zeiger auf die freigegebene Variable als Argument verwenden muss und wir einen Zeiger auf den zugewiesenen Speicherbereich haben, benötigen wir definitiv eine Funktion, die einen Doppelzeiger verwendet. </font><font style="vertical-align: inherit;">Dazu benötigen wir eine zusätzliche Wrapper-Funktion:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **ptr)</span> 
</span>{
    <span class="hljs-built_in">free</span>(*ptr); <font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus können wir keine universelle Funktion verwenden, um Variablen freizugeben, da für sie unterschiedliche Arten von Argumenten erforderlich sind. </font><font style="vertical-align: inherit;">Daher schreiben wir die Funktion wie folgt um:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _free(<span class="hljs-keyword">void</span> *p) {
    <span class="hljs-built_in">free</span>(*(<span class="hljs-keyword">void</span>**) p);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"cleanup done\n"</span>);  <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt kann sie alle Hinweise akzeptieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein weiteres nützliches Makro (aus der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">systemd-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Codebasis </font><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFINE_TRIVIAL_CLEANUP_FUNC(type, func)                 \
        static inline void func##p(type *p) {                   \
                <span class="hljs-meta-keyword">if</span> (*p)                                         \
                        func(*p);                               \
        }                                                       \
        struct __useless_struct_to_allow_trailing_semicolon__</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
die später so verwendet werden kann:</font></font><br>
<br>
<pre><code class="cpp hljs">DEFINE_TRIVIAL_CLEANUP_FUNC(FILE*, pclose);
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _cleanup_pclose_ __attribute__((cleanup(pclosep)))</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber das ist nicht alles. </font><font style="vertical-align: inherit;">Es gibt eine Bibliothek, die Analoga der Pluszeichen unique_ptr und shared_ptr mithilfe dieses Attributs implementiert: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/Snaipe/libcsptr</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Verwendungsbeispiel (entnommen aus [2]):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;csptr/smart_ptr.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;csptr/array.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_int</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">void</span> *meta)</span> </span>{<font></font>
    (<span class="hljs-keyword">void</span>) meta;
    <span class="hljs-comment">// ptr points to the current element</span>
    <span class="hljs-comment">// meta points to the array metadata (global to the array), if any.</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, *(<span class="hljs-keyword">int</span>*) ptr);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-comment">// Destructors for array types are run on every element of the</span>
    <span class="hljs-comment">// array before destruction.</span>
    smart <span class="hljs-keyword">int</span> *ints = <span class="hljs-built_in">unique_ptr</span>(<span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>], {<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>}, print_int);
    <span class="hljs-comment">// ints == {5, 4, 3, 2, 1}</span><font></font>
<font></font>
    <span class="hljs-comment">// Smart arrays are length-aware</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; array_length(ints); ++i) {<font></font>
        ints[i] = i + <span class="hljs-number">1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// ints == {1, 2, 3, 4, 5}</span><font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles funktioniert wunderbar! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und mal sehen, was in dieser Magie steckt. </font><font style="vertical-align: inherit;">Beginnen wir mit unique_ptr (und shared_ptr gleichzeitig):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> shared_ptr(Type, ...) smart_ptr(SHARED, Type, __VA_ARGS__)</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> unique_ptr(Type, ...) smart_ptr(UNIQUE, Type, __VA_ARGS__)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns sehen, wie tief das Kaninchenloch ist:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> smart_arr(Kind, Type, Length, ...)                                 \
    ({                                                                      \
        struct s_tmp {                                                      \
            CSPTR_SENTINEL_DEC                                              \
            __typeof__(__typeof__(Type)[Length]) value;                     \
            f_destructor dtor;                                              \
            struct {                                                        \
                const void *ptr;                                            \
                size_t size;                                                \
            } meta;                                                         \
        } args = {                                                          \
            CSPTR_SENTINEL                                                  \
            __VA_ARGS__                                                     \
        };                                                                  \
        void *var = smalloc(sizeof (Type), Length, Kind, ARGS_);            \
        <span class="hljs-meta-keyword">if</span> (var != NULL)                                                    \
            memcpy(var, &amp;args.value, sizeof (Type));                        \
        var;                                                                \
    })</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisher hat die Klarheit nicht zugenommen, bevor wir ein Durcheinander von Makros in den besten Traditionen dieser Sprache haben. </font><font style="vertical-align: inherit;">Aber wir sind es nicht gewohnt, uns zurückzuziehen. </font><font style="vertical-align: inherit;">Löse das Gewirr:</font></font><br>
<br>
<pre><code class="cpp hljs">define CSPTR_SENTINEL        .sentinel_ = <span class="hljs-number">0</span>,<font></font>
define CSPTR_SENTINEL_DEC <span class="hljs-keyword">int</span> sentinel_;<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*f_destructor)</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">void</span> *)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Führen Sie die Ersetzung durch:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> smart_arr(Kind, Type, Length, ...)                                 \
    ({                                                                      \
        struct s_tmp {                                                      \
            int sentinel_;                                                  \
            __typeof__(__typeof__(Type)[Length]) value;                     \
            void (*)(void *, void *) dtor;                                  \
            struct {                                                        \
                const void *ptr;                                            \
                size_t size;                                                \
            } meta;                                                         \
        } args = {                                                          \
            .sentinel_ = 0,                                                 \
            __VA_ARGS__                                                     \
        };                                                                  \
        void *var = smalloc(sizeof (Type), Length, Kind, ARGS_);            \
        <span class="hljs-meta-keyword">if</span> (var != NULL)                                                    \
            memcpy(var, &amp;args.value, sizeof (Type));                        \
        var;                                                                \
    })</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und versuchen zu verstehen, was hier passiert. </font><font style="vertical-align: inherit;">Wir haben eine bestimmte Struktur, bestehend aus der Variablen sentinel_, einem bestimmten Array (Typ) [Länge], einem Zeiger auf eine Destruktorfunktion, die im zusätzlichen (...) Teil der Makroargumente übergeben wird, und einer Metastruktur, die ebenfalls mit zusätzlichen Argumenten gefüllt ist. </font><font style="vertical-align: inherit;">Als nächstes kommt ein Anruf</font></font><br>
<br>
<pre><code class="cpp hljs">smalloc(<span class="hljs-keyword">sizeof</span> (Type), Length, Kind, ARGS_);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist Smalloc? </font><font style="vertical-align: inherit;">Wir finden etwas mehr Vorlagenmagie (ich habe hier bereits einige Ersetzungen vorgenommen):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">enum</span> pointer_kind {<font></font>
    UNIQUE,<font></font>
    SHARED,<font></font>
    ARRAY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span><font></font>
};<font></font>
<span class="hljs-comment">//..</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span><font></font>
    CSPTR_SENTINEL_DEC<font></font>
    <span class="hljs-keyword">size_t</span> size;
    <span class="hljs-keyword">size_t</span> nmemb;
    <span class="hljs-keyword">enum</span> pointer_kind kind;<font></font>
    f_destructor dtor;<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data;
        <span class="hljs-keyword">size_t</span> size;<font></font>
    } meta;<font></font>
} s_smalloc_args;<font></font>
<span class="hljs-comment">//...</span>
__attribute__ ((<span class="hljs-built_in">malloc</span>)) <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">smalloc</span><span class="hljs-params">(s_smalloc_args *args)</span></span>;
<span class="hljs-comment">//...</span>
<span class="hljs-meta">#  <span class="hljs-meta-keyword">define</span> smalloc(...) \
    smalloc(&amp;(s_smalloc_args) { CSPTR_SENTINEL __VA_ARGS__ })</span></code></pre><br><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">Deshalb</font></i><font style="vertical-align: inherit;"> 
lieben wir C. Es gibt auch Dokumentation in der Bibliothek (Heilige, ich empfehle jedem, ein Beispiel daraus zu ziehen): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smalloc ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ruft den </font><i><font style="vertical-align: inherit;">Allokator (</font></i><font style="vertical-align: inherit;"> standardmäßig malloc (3)) auf, der zurückgegebene Zeiger ist ein „intelligenter“ Zeiger. </font><font style="vertical-align: inherit;">&lt;...&gt; Wenn die Größe 0 ist, wird NULL zurückgegeben. </font><font style="vertical-align: inherit;">Wenn nmemb 0 ist, gibt smalloc einen intelligenten Zeiger auf einen Speicherblock mit mindestens Bytes und einen intelligenten Skalarzeiger zurück. Wenn nmemb nicht gleich 0 ist, wird ein Zeiger auf einen Speicherblock mit mindestens Größe * nmemb zurückgegeben, und der Zeiger ist vom Typ Array.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Original</font></font></b>
                        <div class="spoiler_text">«The <b>smalloc</b>() function calls an allocator (<b>malloc</b> (3) by default), such that the returned pointer is a smart pointer. &lt;...&gt; If <b>size</b> is 0, then <b>smalloc</b>() returns NULL. If <b>nmemb</b> is 0, then <b>smalloc</b> shall return a smart pointer to a memory block of at least <b>size</b> bytes, and the smart pointer is a scalar. Otherwise, it shall return a memory block to at least <b>size * nmemb</b> bytes, and the smart pointer is an array.»<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist die Quelle von smalloc:</font></font><br>
<br>
<pre><code class="cpp hljs">__attribute__ ((<span class="hljs-built_in">malloc</span>)) <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">smalloc</span><span class="hljs-params">(s_smalloc_args *args)</span> </span>{
    <span class="hljs-keyword">return</span> (args-&gt;nmemb == <span class="hljs-number">0</span> ? smalloc_impl : smalloc_array)(args);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns den Code smalloc_impl an, der Objekte skalaren Typs zuweist. </font><font style="vertical-align: inherit;">Um die Lautstärke zu verringern, habe ich den mit gemeinsam genutzten Zeigern verknüpften Code gelöscht und Inline- und Makrosubstitutionen vorgenommen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">smalloc_impl</span><span class="hljs-params">(s_smalloc_args *args)</span> </span>{
    <span class="hljs-keyword">if</span> (!args-&gt;size)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
    <span class="hljs-comment">// align the sizes to the size of a word</span>
    <span class="hljs-keyword">size_t</span> aligned_metasize = align(args-&gt;meta.size);
    <span class="hljs-keyword">size_t</span> size = align(args-&gt;size);<font></font>
<font></font>
    <span class="hljs-keyword">size_t</span> head_size = <span class="hljs-keyword">sizeof</span> (s_meta);<font></font>
    s_meta_shared *ptr = <span class="hljs-built_in">malloc</span>(head_size + size + aligned_metasize + <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">size_t</span>));<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
    <span class="hljs-keyword">char</span> *shifted = (<span class="hljs-keyword">char</span> *) ptr + head_size;
    <span class="hljs-keyword">if</span> (args-&gt;meta.size &amp;&amp; args-&gt;meta.data)
        <span class="hljs-built_in">memcpy</span>(shifted, args-&gt;meta.data, args-&gt;meta.size);<font></font>
<font></font>
    <span class="hljs-keyword">size_t</span> *sz = (<span class="hljs-keyword">size_t</span> *) (shifted + aligned_metasize);<font></font>
    *sz = head_size + aligned_metasize;<font></font>
<font></font>
    *(s_meta*) ptr = (s_meta) {<font></font>
        .kind = args-&gt;kind,<font></font>
        .dtor = args-&gt;dtor,<font></font>
        .ptr = sz + <span class="hljs-number">1</span><font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">return</span> sz + <span class="hljs-number">1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sehen wir, dass der Speicher für die Variable zugewiesen wird, plus einem bestimmten Header vom Typ s_meta plus einem Metadatenbereich der Größe args-&gt; meta.size, der an der Größe des Wortes ausgerichtet ist, plus einem weiteren Wort (sizeof (size_t)). </font><font style="vertical-align: inherit;">Die Funktion gibt einen Zeiger auf den Speicher der Variablen zurück: ptr + head_size + align_metasize + 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ordnen Sie eine Variable vom Typ int zu, die mit dem Wert 42 initialisiert ist:</font></font><br>
<br>
<pre><code class="cpp hljs">smart <span class="hljs-keyword">void</span> *ptr = <span class="hljs-built_in">unique_ptr</span>(<span class="hljs-keyword">int</span>, <span class="hljs-number">42</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist smart ein Makro:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> smart __attribute__ ((cleanup(sfree_stack)))</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Zeiger den Gültigkeitsbereich verlässt, wird sfree_stack aufgerufen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">CSPTR_INLINE <span class="hljs-keyword">void</span> <span class="hljs-title">sfree_stack</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span> </span>{
    <span class="hljs-keyword">union</span> {
        <span class="hljs-keyword">void</span> **real_ptr;
        <span class="hljs-keyword">void</span> *ptr;<font></font>
    } conv;<font></font>
    conv.ptr = ptr;<font></font>
    sfree(*conv.real_ptr);<font></font>
    *conv.real_ptr = <span class="hljs-literal">NULL</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sfree-Funktion (abgekürzt):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sfree</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span> </span>{<font></font>
    s_meta *meta = get_meta(ptr);<font></font>
    dealloc_entry(meta, ptr);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion dealloc_entry ruft im Grunde genommen einen benutzerdefinierten Destruktor auf, wenn wir ihn in den Argumenten unique_ptr angegeben haben und der Zeiger darauf in den Metadaten gespeichert ist. </font><font style="vertical-align: inherit;">Wenn nicht, wird nur free (meta) ausgeführt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Liste der Quellen: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[1] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allgemeine Variablenattribute</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[2] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine gute und idiomatische Möglichkeit, GCC und Clang __attribute __ ((Bereinigung)) und Zeigerdeklarationen zu verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[3] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden des Variablenattributs __cleanup__ in GCC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de503522/index.html">Welt nach 2020 (Aufsatz)</a></li>
<li><a href="../de503524/index.html">Als Domain-Registrar übergibt P01 Registrar seine Kunden</a></li>
<li><a href="../de503526/index.html">Django ORM für Anfänger | Wir optimieren Anfragen</a></li>
<li><a href="../de503530/index.html">Ihr beruflicher Niedergang wird (viel) früher kommen als Sie denken</a></li>
<li><a href="../de503532/index.html">Wie sich das Online-Shopping in den USA aufgrund des Coronavirus verändert hat</a></li>
<li><a href="../de503540/index.html">Gehen Sie nach dem Dekret zum Frontend, werden Sie Unterzeichner in Gitlab und Mitglied des Kernteams Vue.js</a></li>
<li><a href="../de503542/index.html">Erfahrung mit dem Kalman-Filter am Beispiel von NMEA-Daten</a></li>
<li><a href="../de503544/index.html">Podcast: AR im Stadion, reale Prozessmodellierung und multidisziplinärer Spielentwickler</a></li>
<li><a href="../de503546/index.html">Ein einfaches Beispiel für eine Clusteranalyse der Alkoholpräferenzen nach Ländern für R.</a></li>
<li><a href="../de503552/index.html">DIT Moskau erhält bei der Überprüfung des Passes die Erlaubnis, Werbung für die nächsten 10 Jahre zu versenden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>