<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🏫 👏🏻 🍎 3D-Grafik auf dem STM32F103 👨🏻 👛 👡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine kurze Geschichte darüber, wie man die nicht bearbeitbaren und dreidimensionalen Echtzeitgrafiken mit einem Controller anzeigt, der weder Geschwin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>3D-Grafik auf dem STM32F103</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496046/"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/cf8/e1c/7e5cf8e1c0fbc2ee47c87c71d72e865f.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine kurze Geschichte darüber, wie man die nicht bearbeitbaren und dreidimensionalen Echtzeitgrafiken mit einem Controller anzeigt, der weder Geschwindigkeit noch Speicher dafür hat.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bereits 2017 (gemessen am Änderungsdatum der Datei) habe ich beschlossen, von AVR-Controllern auf leistungsstärkere STM32 umzusteigen. Der erste Controller war natürlich der weit verbreitete F103. Es ist nicht weniger selbstverständlich, dass die Verwendung von Standard-Debug-Boards zugunsten der Herstellung eines von Grund auf neu gemäß seinen Anforderungen abgelehnt wurde. Seltsamerweise gab es fast keine Pfosten (außer dass UART1 an einen normalen Stecker angeschlossen und nicht an der Verkabelung gekratzt werden sollte).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Vergleich zu AVR sind die Eigenschaften des Steins recht anständig: 72-MHz-Takt (in der Praxis können Sie auf 100 MHz oder sogar mehr übertakten, jedoch nur auf eigene Gefahr und Gefahr!), 20 kB RAM und 64 kB Flash. Eine Tonne Peripheriegeräte, bei denen das Hauptproblem darin besteht, keine Angst vor dieser Fülle zu haben und zu erkennen, dass Sie nicht alle zehn Register schaufeln müssen, um zu starten, reicht es aus, drei Bits in die richtigen zu setzen. Zumindest bis du etwas Seltsames willst.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als die erste Euphorie aus dem Besitz einer solchen Macht vorüberging, entstand der Wunsch, ihre Grenzen zu erforschen. Als effektives Beispiel habe ich die Berechnung dreidimensionaler Grafiken mit all diesen Matrizen, Beleuchtung, polygonalen Modellen und einem Z-Puffer mit einem 320x240-Display auf dem ili9341-Controller gewählt. Die zwei offensichtlichsten zu lösenden Probleme sind Geschwindigkeit und Lautstärke. Eine Bildschirmgröße von 320 x 240 bei 16 Bit pro Farbe ergibt 150 kB pro Bild. Der gesamte Arbeitsspeicher beträgt jedoch nur 20 KB ... Und diese 150 KB müssen mindestens 10 Mal pro Sekunde auf das Display übertragen werden, dh der Wechselkurs sollte mindestens 1,5 MB / s oder 12 MB / s betragen, was bereits eine erhebliche Belastung des Kerns darstellt. Glücklicherweise gibt es in diesem Controller ein RAP-Modul (direkter Zugriff auf den Speicher, auch bekannt als Direct Memory Access, DMA), mit dem Sie den Kernel nicht mit Transfusionsvorgängen von leer nach leer laden können.Das heißt, Sie können einen Puffer vorbereiten, dem Modul mitteilen, dass Sie hier den Datenpuffer haben, arbeiten!, Und zu diesem Zeitpunkt die Daten für die nächste Übertragung vorbereiten. Unter Berücksichtigung der Fähigkeit der Anzeige, Daten in einem Stream zu empfangen, ergibt sich der folgende Algorithmus: Der vordere Puffer wird hervorgehoben, von dem der DMA Daten an die Anzeige überträgt, der hintere Puffer, in den das Rendern erfolgt, und der Z-Puffer, der zum Schneiden in die Tiefe verwendet wird. Puffer sind eine einzelne Zeile (oder Spalte, was auch immer) der Anzeige. Und statt 150 kB benötigen wir nur 1920 Bytes (320 Pixel pro Zeile * 3 Puffer * 2 Bytes pro Punkt), was perfekt in den Speicher passt. Der zweite Hack basiert auf der Tatsache, dass die Berechnung von Transformationsmatrizen und Scheitelpunktkoordinaten nicht für jede Zeile durchgeführt werden kann, da sonst das Bild auf bizarrste Weise verzerrt wird und die Geschwindigkeit nachteilig ist. Stattdessen "externe" Berechnungen,Das heißt, die Multiplikation von Transformationsmatrizen und ihre Anwendung auf die Scheitelpunkte werden in jedem Frame neu berechnet und dann in eine Zwischendarstellung konvertiert, die für das Rendern in einem 320x1-Bild optimiert ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Hooligan-Gründen ähnelt die Bibliothek von außen OpenGL. Wie in der ursprünglichen OpenGL beginnt das Rendern mit der Bildung der Transformationsmatrix. Durch Löschen von glLoadIdentity () wird die aktuelle Matrixeinheit erstellt, dann wird eine Reihe von Transformationen glRotateXY (...), glTranslate (...) erstellt, die jeweils mit der aktuellen Matrix multipliziert werden. Da diese Berechnungen nur einmal pro Frame durchgeführt werden, gibt es keine besonderen Anforderungen an die Geschwindigkeit. Sie können mit einfachen Floats ohne Perversionen mit Festkommazahlen arbeiten. Die Matrix selbst ist ein Array von float [4] [4], das einem eindimensionalen Array von float [16] zugeordnet ist. Tatsächlich wird diese Methode normalerweise für dynamische Arrays verwendet, aber Sie können auch ein wenig von statischen Arrays profitieren. Ein weiterer Standard-Hack: Anstatt ständig Sinus und Cosinus zu berechnen, die in den Rotationsmatrizen häufig vorkommen,Zählen Sie sie im Voraus und schreiben Sie sie auf das Tablet. Teilen Sie dazu den vollen Kreis in 256 Teile, berechnen Sie den Sinuswert für jeden und geben Sie ihn in das Array sin_table [] ein. Nun, jeder aus der Schule kann den Kosinus vom Sinus bekommen. Es ist zu beachten, dass die Rotationsfunktionen nach Reduzierung auf den Bereich [0 ... 255] keinen Winkel im Bogenmaß, sondern in Bruchteilen einer vollen Umdrehung einnehmen. Es wurden jedoch "ehrliche" Funktionen implementiert, die die Umwandlung von Winkel zu Lappen unter der Haube durchführen.Durchführung der Umwandlung von Winkel zu Lappen unter der Haube.Durchführung der Umwandlung von Winkel zu Lappen unter der Haube.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Matrix fertig ist, können Sie mit dem Zeichnen der Grundelemente beginnen. Im Allgemeinen gibt es in dreidimensionalen Grafiken drei Arten von Grundelementen - einen Punkt, eine Linie und ein Dreieck. Wenn wir uns jedoch für polygonale Modelle interessieren, sollte nur das Dreieck berücksichtigt werden. Sein "Rendern" erfolgt in der Funktion glDrawTriangle () oder glDrawTriangleV (). Das Wort "Rendern" wird in Anführungszeichen gesetzt, da zu diesem Zeitpunkt kein Rendern erfolgt. Wir multiplizieren einfach alle Punkte des Grundelements mit der Transformationsmatrix und extrahieren daraus die analytischen Formeln der Kanten y = ky * x + mit, die es uns ermöglichen, die Schnittpunkte aller drei Kanten des Dreiecks mit der aktuellen Ausgangslinie zu finden. Wir verwerfen einen von ihnen, da er nicht auf dem Intervall zwischen den Eckpunkten liegt, sondern auf seiner Fortsetzung.Das heißt, um einen Rahmen zu zeichnen, müssen Sie nur alle Linien durchgehen und für jede Farbe den Bereich zwischen den Schnittpunkten zeichnen. Wenn Sie diesen Algorithmus jedoch "frontal" anwenden, überlappt jedes Grundelement die zuvor gezeichneten. Wir müssen die Z-Koordinate (Tiefe) berücksichtigen, damit sich die Dreiecke schön schneiden. Anstatt einfach Punkt für Punkt zu drucken, betrachten wir die Z-Koordinate und geben sie im Vergleich zu der im Tiefenpuffer gespeicherten Z-Koordinate entweder aus (aktualisieren den Z-Puffer) oder ignorieren sie. Und um die Z-Koordinate jedes Punktes der für uns interessanten Linie zu berechnen, verwenden wir dieselbe Geradenformel z = kz * y + bz, die durch dieselben zwei Schnittpunkte mit Kanten berechnet wird. Infolgedessen besteht das Objekt der "halbfertigen" Dreiecksstruktur glTriangle aus drei X-Koordinaten der Eckpunkte (es macht keinen Sinn, die Y- und Z-Koordinaten zu speichern, sie werden berechnet) und k,b direkte Koeffizienten, na ja, Farbe zum Haufen. Hier ist im Gegensatz zur Berechnung von Transformationsmatrizen die Geschwindigkeit kritisch, so dass wir bereits Festkommazahlen verwenden. Wenn außerdem für den Term b die gleiche Genauigkeit wie für die Koordinaten (2 Bytes) ausreicht, ist die Genauigkeit des Faktors k umso größer, je besser, also nehmen wir 4 Bytes. Aber kein Float, da die Arbeit mit ganzen Zahlen auch bei gleicher Größe noch schneller ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Aufrufen einer Reihe von glDrawTriangle () haben wir eine Reihe von halbfertigen Dreiecken vorbereitet. In meiner Implementierung werden Dreiecke einzeln durch explizite Funktionsaufrufe abgeleitet. In der Tat wäre es logisch, eine Reihe von Dreiecken mit den Adressen der Eckpunkte zu haben, aber hier habe ich beschlossen, nicht zu komplizieren. Wie auch immer, die Rendering-Funktion wird von Robotern geschrieben, und es spielt für sie keine Rolle, ob sie ein konstantes Array ausfüllen oder dreihundert identische Aufrufe schreiben. Es ist Zeit, die Halbzeuge der Dreiecke in ein schönes Bild auf dem Bildschirm zu übersetzen. Dazu wird die Funktion glSwapBuffers () aufgerufen. Wie oben beschrieben, geht es durch die Linien der Anzeige, sucht nach jedem Schnittpunkt mit allen Dreiecken und zeichnet Segmente gemäß der Filterung nach Tiefe. Nach dem Rendern jeder Zeile müssen Sie diese Zeile an die Anzeige senden. Zu diesem Zweck wird DMA gestartet, das die Adresse der Zeichenfolge und ihre Größe angibt.In der Zwischenzeit funktioniert DMA. Sie können zu einem anderen Puffer wechseln und die nächste Zeile rendern. Die Hauptsache ist, nicht zu vergessen, auf das Ende der Übertragung zu warten, wenn Sie das Rendern plötzlich früher beendet haben. Um das Verhältnis der Geschwindigkeiten zu visualisieren, habe ich nach dem Ende des Renderns eine rote LED hinzugefügt und nach Abschluss der DMA-Wartezeit ausgeschaltet. Es stellt sich so etwas wie PWM heraus, das die Helligkeit abhängig von der Latenz anpasst. Theoretisch könnten anstelle eines „dummen“ Wartens DMA-Interrupts verwendet werden, aber dann könnte ich sie nicht verwenden, und der Algorithmus wäre viel komplizierter geworden. Für ein Demo-Programm ist dies redundant.Um das Verhältnis der Geschwindigkeiten zu visualisieren, habe ich nach dem Ende des Renderns eine rote LED hinzugefügt und nach Abschluss der DMA-Wartezeit ausgeschaltet. Es stellt sich so etwas wie PWM heraus, das die Helligkeit abhängig von der Latenz anpasst. Theoretisch könnten anstelle eines "dummen" Wartens DMA-Interrupts verwendet werden, aber dann könnte ich sie nicht verwenden, und der Algorithmus wäre viel komplizierter geworden. Für ein Demo-Programm ist dies redundant.Um das Verhältnis der Geschwindigkeiten zu visualisieren, habe ich nach dem Ende des Renderns eine rote LED hinzugefügt und nach Abschluss der DMA-Wartezeit ausgeschaltet. Es stellt sich so etwas wie PWM heraus, das die Helligkeit abhängig von der Latenz anpasst. Theoretisch könnten anstelle eines „dummen“ Wartens DMA-Interrupts verwendet werden, aber dann könnte ich sie nicht verwenden, und der Algorithmus wäre viel komplizierter geworden. Für ein Demo-Programm ist dies redundant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis der obigen Verfahren war ein rotierendes Bild von drei sich kreuzenden Ebenen unterschiedlicher Farben und mit einer recht anständigen Geschwindigkeit: Die Helligkeit der roten LED ist ziemlich hoch, was auf einen großen Spielraum bei der Kernelleistung hinweist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Kern im Leerlauf ist, müssen Sie ihn laden. Und wir werden es mit besseren Modellen laden. Vergessen Sie jedoch nicht, dass der Speicher immer noch sehr begrenzt ist, damit der Controller nicht zu viele Polygone physisch zieht. Die einfachste Berechnung ergab, dass nach Subtrahieren des Speichers auf dem Zeilenpuffer und dergleichen ein Platz für 378 Dreiecke vorhanden war. Wie die Praxis gezeigt hat, sind Modelle aus dem alten, aber interessanten Gothic-Spiel perfekt für diese Größe. Tatsächlich wurden die Modelle einer Schlange und einer Blutfliege von dort herausgezogen (und bereits zum Zeitpunkt des Schreibens dieses Artikels und eines Glocoor, der auf KDPV zur Schau gestellt wurde), wonach dem Controller der Flash-Speicher ausgegangen war. Spielmodelle sind jedoch nicht für die Verwendung durch einen Mikrocontroller vorgesehen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, sie enthalten Animationen, Texturen und dergleichen, was für uns nicht nützlich ist und nicht in den Speicher passt. Glücklicherweise können Sie mit Blender nicht nur in * .obj speichern, was für das Parsen besser geeignet ist, sondern bei Bedarf auch die Anzahl der Polygone reduzieren. Mit Hilfe eines einfachen selbstgeschriebenen Programms obj2arr * .obj werden die Dateien in Koordinaten sortiert, aus denen anschließend eine * .h-Datei zur direkten Aufnahme in die Firmware gebildet wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber im Moment sehen die Modelle genauso aus wie einfache lockige Flecken. Beim Testmodell hat uns das nicht gestört, da alle Gesichter in ihren eigenen Farben gemalt wurden, aber nicht jedem Polygon des Modells die gleichen Farben vorschreiben. Nein, Sie können natürlich eine Fliege in zufälligen Farben malen, aber sie wird aus heiterem Himmel hübsch aussehen, habe ich überprüft. Vor allem, wenn sich die Farben auch bei jedem Frame ändern ... Wenden Sie stattdessen einen weiteren Tropfen Vektormagie an und fügen Sie Beleuchtung hinzu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Berechnung der Beleuchtung in ihrer primitiven Version besteht aus der Berechnung des Skalarprodukts der Normalen und der Richtung zur Lichtquelle, gefolgt von der Multiplikation mit der „nativen“ Gesichtsfarbe.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben jetzt drei Modelle - zwei aus dem Spiel und einen Test, von dem wir ausgegangen sind. Um sie zu wechseln, verwenden wir eine der beiden auf der Platine gelöteten Tasten. Gleichzeitig können Sie die Kontrolle über den Prozessor hinzufügen. Wir haben bereits eine Steuerung - eine rote LED, die mit der DMA-Latenz verbunden ist. Und die zweite grüne LED blinkt bei jedem Frame-Update - damit wir die Framerate abschätzen können. Für das bloße Auge waren es ungefähr 15 fps.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/afyTgpuA6sc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen bin ich mit dem Ergebnis zufrieden: Es ist schön, etwas zu implementieren, das grundsätzlich nicht direkt zu lösen ist. </font><font style="vertical-align: inherit;">Natürlich gibt es noch viel zu optimieren und zu verbessern, aber das hat wenig Sinn. </font><font style="vertical-align: inherit;">Objektiv gesehen ist der Controller für dreidimensionale Grafiken schwach und es geht nicht einmal um Geschwindigkeit, sondern um RAM. </font><font style="vertical-align: inherit;">Wie jede Demoszenenprobe ist dieses Projekt jedoch nicht durch das Ergebnis, sondern durch den Prozess wertvoll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn jemand plötzlich interessiert, ist der Quellcode verfügbar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496036/index.html">Open Source: CI / CD- und Avito-Testinfrastruktur für Android</a></li>
<li><a href="../de496038/index.html">Bilirubin - das Molekül, das für Gelbsucht verantwortlich ist</a></li>
<li><a href="../de496040/index.html">10 Zen Lifehacks</a></li>
<li><a href="../de496042/index.html">Habr, ich werde Sie nicht über Fehler auf Ihrer Website informieren</a></li>
<li><a href="../de496044/index.html">Start von Raumfahrzeugen und ... Wetter in den Regionen</a></li>
<li><a href="../de496050/index.html">Tiger und Löwen bekommen in New York Coronavirus</a></li>
<li><a href="../de496052/index.html">Wie kann ein Dienstleistungsunternehmen Bußgelder von Kunden vermeiden? Einige offensichtliche Vorteile der Prozessautomatisierung</a></li>
<li><a href="../de496056/index.html">Digital: Wie Zahlen und Begriffe uns täuschen</a></li>
<li><a href="../de496058/index.html">Warum es notwendig ist, landwirtschaftliche Mähdrescher zu roboterisieren, was sind die Schwierigkeiten und wie wir es in zwei Jahren gemacht haben</a></li>
<li><a href="../de496080/index.html">Erstellen einfacher KI-Interaktionen mit Umgebungsobjekten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>