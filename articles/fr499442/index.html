<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💏 👨🏼‍🏫 🎰 Création d'un jeu de course pseudo-3D: mise en œuvre des collines et finition du jeu 🏇🏼 👩🏿‍🏫 🦔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partie 3. Collines
 
 Dans la partie précédente, nous avons créé un jeu de course pseudo-tridimensionnel simple , réalisant des routes droites et des ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Création d'un jeu de course pseudo-3D: mise en œuvre des collines et finition du jeu</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499442/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 3. Collines</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/892/231/4e8/8922314e8acebdd3ae14fba511d17294.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la partie précédente, nous avons créé un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jeu de course</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pseudo-tridimensionnel simple </font><font style="vertical-align: inherit;">, réalisant des routes droites et des courbes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fois, nous prendrons soin des collines; </font><font style="vertical-align: inherit;">heureusement, ce sera beaucoup plus facile que de créer des routes courbes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la première partie, nous avons utilisé la loi des triangles similaires pour créer une projection en perspective tridimensionnelle:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/949/0ab/47b/9490ab47bb570b61218e46e5913c18bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... ce qui nous a amenés à obtenir les équations de projection des coordonnées du monde 3D dans les coordonnées de l'écran 2D.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/246/e18/edb246e187e7fe0eb027b53c58790c34.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... mais depuis lors, nous n'avons travaillé qu'avec des routes droites, les coordonnées mondiales n'avaient besoin que de la composante </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , car </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> étaient égaux à zéro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela nous convient bien, car pour ajouter des collines, il nous suffit de donner aux segments de route la coordonnée </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> non nulle correspondante </font><font style="vertical-align: inherit;">, après quoi la fonction existante fonctionnera comme </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par magie.</font></font><a name="habracut"></a><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ede/dc6/295/ededc629516e6f0d2c7f1ca6b111e17d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, c'est suffisant pour obtenir les collines. </font><font style="vertical-align: inherit;">Ajoutez simplement la composante </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aux coordonnées mondiales de chaque segment de route </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changements dans la géométrie de la route</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons modifier la méthode existante </font></font><code>addSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin que la fonction qui l'appelle puisse passer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2.world.y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1.world.y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correspondrait à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2.world.y du</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segment précédent:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params">curve, y</span>) </span>{
  <span class="hljs-keyword">var</span> n = segments.length;<font></font>
  segments.push({<font></font>
     <span class="hljs-attr">index</span>: n,
        <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">y</span>: lastY(), <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
        <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">y</span>: y,       <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
     <span class="hljs-attr">curve</span>: curve,
     <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
  });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastY</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (segments.length == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : segments[segments.length<span class="hljs-number">-1</span>].p2.world.y;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ajoutez des constantes pour indiquer les </font><font style="vertical-align: inherit;">collines </font><font style="vertical-align: inherit;">basses ( </font></font><code>LOW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), moyennes ( </font></font><code>MEDIUM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et hautes ( </font></font><code>HIGH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> ROAD = {
  <span class="hljs-attr">LENGTH</span>: { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">SHORT</span>:  <span class="hljs-number">25</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">50</span>, <span class="hljs-attr">LONG</span>:  <span class="hljs-number">100</span> },
  <span class="hljs-attr">HILL</span>:   { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">LOW</span>:    <span class="hljs-number">20</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">40</span>, <span class="hljs-attr">HIGH</span>:   <span class="hljs-number">60</span> },
  <span class="hljs-attr">CURVE</span>:  { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">EASY</span>:    <span class="hljs-number">2</span>, <span class="hljs-attr">MEDIUM</span>:   <span class="hljs-number">4</span>, <span class="hljs-attr">HARD</span>:    <span class="hljs-number">6</span> }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modifiez la méthode existante </font></font><code>addRoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'elle reçoive l'argument </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui sera utilisé avec les fonctions de lissage pour la montée et la descente progressive de la colline:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoad</span>(<span class="hljs-params">enter, hold, leave, curve, y</span>) </span>{
  <span class="hljs-keyword">var</span> startY   = lastY();
  <span class="hljs-keyword">var</span> endY     = startY + (Util.toInt(y, <span class="hljs-number">0</span>) * segmentLength);
  <span class="hljs-keyword">var</span> n, total = enter + hold + leave;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; enter ; n++)<font></font>
    addSegment(Util.easeIn(<span class="hljs-number">0</span>, curve, n/enter), Util.easeInOut(startY, endY, n/total));
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; hold  ; n++)<font></font>
    addSegment(curve, Util.easeInOut(startY, endY, (enter+n)/total));<font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; leave ; n++)<font></font>
    addSegment(Util.easeInOut(curve, <span class="hljs-number">0</span>, n/leave), Util.easeInOut(startY, endY, (enter+hold+n)/total));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, à l'instar de ce que nous avons fait dans la partie 2 s </font></font><code>addSCurves()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous pouvons imposer toutes les méthodes dont nous avons besoin pour construire la géométrie, par exemple:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addLowRollingHills</span>(<span class="hljs-params">num, height</span>) </span>{<font></font>
  num    = num    || ROAD.LENGTH.SHORT;<font></font>
  height = height || ROAD.HILL.LOW;<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height/<span class="hljs-number">2</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>, -height);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height/<span class="hljs-number">2</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>);<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifications de la méthode de mise à jour</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le jeu d'arcade que nous créons, nous ne chercherons pas à simuler la réalité, donc les collines n'affectent en rien le joueur ou le monde du jeu, ce qui signifie que des </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changements ne sont pas nécessaires </font><font style="vertical-align: inherit;">dans la méthode </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu des collines</font></font></h2><br><font style="vertical-align: inherit;"></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aucun changement n'est requis </font><font style="vertical-align: inherit;">
dans la méthode </font><font style="vertical-align: inherit;">non plus, car les équations de projection ont été écrites à l'origine de manière à projeter correctement les segments de route avec des coordonnées </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> non nulles </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fond de défilement de parallaxe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus d'ajouter des coordonnées </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> à tous les segments de route </font><font style="vertical-align: inherit;">, le seul changement sera la mise en œuvre du déplacement vertical des couches d'arrière-plan avec les collines (tout comme elles se déplacent horizontalement avec les courbes). </font><font style="vertical-align: inherit;">Nous implémentons cela avec un autre argument de la fonction d'assistance </font></font><code>Render.background</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le mécanisme le plus simple sera le déplacement de fond habituel par rapport à la position </font></font><code>playerY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(qui doit être interpolé à partir des positions mondiales </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y du</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segment de joueur actuel). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce n'est pas le comportement le plus réaliste, car cela vaut probablement la peine de considérer la pente du segment actuel de la route du joueur, mais cet effet est simple et fonctionne assez bien pour une démo simple.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout, maintenant nous pouvons compléter les fausses courbes avec de vraies collines:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/892/231/4e8/8922314e8acebdd3ae14fba511d17294.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le travail que nous avons fait dans la première partie, y compris l'infrastructure pour ajouter de vraies collines 3D projetées, je ne vous en ai pas parlé avant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la dernière partie de l'article, nous ajouterons des sprites, ainsi que des arbres et des panneaux d'affichage le long des bords de la route. </font><font style="vertical-align: inherit;">Nous ajouterons également d'autres voitures contre lesquelles il sera possible de concourir, la reconnaissance des collisions et la fixation du «record du cercle» du joueur.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 4. Version prête</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/103/563/0d1/1035630d19106de2f85edebb24d0421f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cette partie, nous ajouterons:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panneaux d'affichage et arbres</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autres voitures</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reconnaissance de collision</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IA rudimentaire des voitures</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface avec chronomètre et record de tour</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... et cela nous fournira un niveau d'interactivité suffisant pour enfin appeler notre projet un "jeu".</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque sur la structure du code</font></font></h2><br>
<blockquote><em>     ,            /,         Javascript.</em></blockquote><br>
<blockquote><em>                .     () ,             ...</em></blockquote><br>
<blockquote><em>…      ,       ,           ,  ,         .</em></blockquote><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6f/111/acc/f6f111accbba448459e25c6fe761ff05.png"></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la partie 1, avant le début du cycle de jeu, nous avons téléchargé une feuille de sprite contenant toutes les voitures, les arbres et les panneaux d'affichage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez créer manuellement une feuille de sprite dans n'importe quel éditeur d'images, mais il est préférable de confier le stockage des images et le calcul des coordonnées à un outil automatisé. </font><font style="vertical-align: inherit;">Dans mon cas, la feuille de sprite a été générée par une petite tâche de râteau à l'aide de l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usine de sprites Ruby Gem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette tâche génère des feuilles de sprites combinées à partir de fichiers images séparés et calcule également les coordonnées x, y, w, h, qui seront stockées dans une constante </font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> SPRITES = {
  <span class="hljs-attr">PALM_TREE</span>:   { <span class="hljs-attr">x</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">w</span>:  <span class="hljs-number">215</span>, <span class="hljs-attr">h</span>:  <span class="hljs-number">540</span> },
  <span class="hljs-attr">BILLBOARD08</span>: { <span class="hljs-attr">x</span>:  <span class="hljs-number">230</span>, <span class="hljs-attr">y</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">w</span>:  <span class="hljs-number">385</span>, <span class="hljs-attr">h</span>:  <span class="hljs-number">265</span> },<font></font>
<font></font>
  <span class="hljs-comment">// ... etc</span><font></font>
<font></font>
  <span class="hljs-attr">CAR04</span>:       { <span class="hljs-attr">x</span>: <span class="hljs-number">1383</span>, <span class="hljs-attr">y</span>:  <span class="hljs-number">894</span>, <span class="hljs-attr">w</span>:   <span class="hljs-number">80</span>, <span class="hljs-attr">h</span>:   <span class="hljs-number">57</span> },
  <span class="hljs-attr">CAR01</span>:       { <span class="hljs-attr">x</span>: <span class="hljs-number">1205</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1018</span>, <span class="hljs-attr">w</span>:   <span class="hljs-number">80</span>, <span class="hljs-attr">h</span>:   <span class="hljs-number">56</span> },<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajout de panneaux d'affichage et d'arbres</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ajoutez à chaque segment de la route un tableau qui contiendra des sprites d'objets le long des bords de la route. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque sprite est constitué de </font></font><code>source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la collection </font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, avec un décalage horizontal </font></font><code>offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui est normalisé de sorte que -1 indique le bord gauche de la route et +1 signifie le bord droit, ce qui nous permet de ne pas dépendre de la valeur </font></font><code>roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains sprites sont placés intentionnellement, d'autres sont randomisés.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments.push({<font></font>
    ...<font></font>
    sprites: [],<font></font>
    ...<font></font>
  });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSprite</span>(<span class="hljs-params">n, sprite, offset</span>) </span>{<font></font>
  segments[n].sprites.push({ <span class="hljs-attr">source</span>: sprite, <span class="hljs-attr">offset</span>: offset });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetSprites</span>(<span class="hljs-params"></span>) </span>{<font></font>
<font></font>
  addSprite(<span class="hljs-number">20</span>,  SPRITES.BILLBOARD07, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">40</span>,  SPRITES.BILLBOARD06, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">60</span>,  SPRITES.BILLBOARD08, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">80</span>,  SPRITES.BILLBOARD09, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">100</span>, SPRITES.BILLBOARD01, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">120</span>, SPRITES.BILLBOARD02, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">140</span>, SPRITES.BILLBOARD03, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">160</span>, SPRITES.BILLBOARD04, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">180</span>, SPRITES.BILLBOARD05, <span class="hljs-number">-1</span>);<font></font>
<font></font>
  addSprite(<span class="hljs-number">240</span>, SPRITES.BILLBOARD07, <span class="hljs-number">-1.2</span>);<font></font>
  addSprite(<span class="hljs-number">240</span>, SPRITES.BILLBOARD06,  <span class="hljs-number">1.2</span>);<font></font>
<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">250</span> ; n &lt; <span class="hljs-number">1000</span> ; n += <span class="hljs-number">5</span>) {<font></font>
    addSprite(n, SPRITES.COLUMN, <span class="hljs-number">1.1</span>);<font></font>
    addSprite(n + Util.randomInt(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>), SPRITES.TREE1, <span class="hljs-number">-1</span> - (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>));<font></font>
    addSprite(n + Util.randomInt(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>), SPRITES.TREE2, <span class="hljs-number">-1</span> - (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>));<font></font>
  }<font></font>
<font></font>
  ...<font></font>
}</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque: si nous créions un vrai jeu, nous pourrions écrire un éditeur de route pour créer visuellement une carte avec des collines et des courbes, ainsi que d'ajouter un mécanisme pour organiser les sprites le long de la route ... mais pour nos tâches, nous pouvons simplement le faire par programme </font></font><code>addSprite()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajout de machines</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus des sprites d'objets au bord de la route, nous ajouterons une collection de voitures qui occupera chaque segment ainsi qu'une collection séparée de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toutes les</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> voitures sur l'autoroute.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> cars      = [];  <span class="hljs-comment">// array of cars on the road</span>
<span class="hljs-keyword">var</span> totalCars = <span class="hljs-number">200</span>; <span class="hljs-comment">// total number of cars on the road</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments.push({<font></font>
    ...<font></font>
    cars: [], <span class="hljs-comment">// array of cars within this segment</span><font></font>
    ...<font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le stockage de deux structures de données automobiles nous permet de faire le tour itératif de toutes les voitures d'une méthode </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en les déplaçant d'un segment à l'autre si nécessaire; </font><font style="vertical-align: inherit;">en même temps, cela nous permet d'exécuter </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uniquement des machines sur des segments visibles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque machine reçoit un décalage horizontal aléatoire, une position z, une source de sprite et une vitesse:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetCars</span>(<span class="hljs-params"></span>) </span>{<font></font>
  cars = [];<font></font>
  <span class="hljs-keyword">var</span> n, car, segment, offset, z, sprite, speed;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span> ; n &lt; totalCars ; n++) {<font></font>
    offset = <span class="hljs-built_in">Math</span>.random() * Util.randomChoice([<span class="hljs-number">-0.8</span>, <span class="hljs-number">0.8</span>]);<font></font>
    z      = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * segments.length) * segmentLength;<font></font>
    sprite = Util.randomChoice(SPRITES.CARS);<font></font>
    speed  = maxSpeed/<span class="hljs-number">4</span> + <span class="hljs-built_in">Math</span>.random() * maxSpeed/(sprite == SPRITES.SEMI ? <span class="hljs-number">4</span> : <span class="hljs-number">2</span>);<font></font>
    car = { <span class="hljs-attr">offset</span>: offset, <span class="hljs-attr">z</span>: z, <span class="hljs-attr">sprite</span>: sprite, <span class="hljs-attr">speed</span>: speed };<font></font>
    segment = findSegment(car.z);<font></font>
    segment.cars.push(car);<font></font>
    cars.push(car);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu des collines (retour)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les parties précédentes, j'ai parlé du rendu des segments de la route, y compris les courbes et les collines, mais il y avait quelques lignes de code que je n'ai pas prises en compte. Ils concernaient une variable </font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partant du bas de l'écran, mais diminuant lors du rendu de chaque segment pour déterminer quelle partie de l'écran nous avions déjà rendue:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
  ...<font></font>
<font></font>
  if ((segment.p1.camera.z &lt;= cameraDepth) || <span class="hljs-comment">// behind us</span>
      (segment.p2.screen.y &gt;= maxy))          <span class="hljs-comment">// clip by (already rendered) segment</span>
    <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
  ...<font></font>
<font></font>
  maxy = segment.p2.screen.y;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela nous permettra de recadrer des segments qui seront couverts par des collines déjà rendues. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'algorithme</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> traditionnel de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">l'artiste, le</font></a><font style="vertical-align: inherit;"> rendu se produit généralement de l'arrière vers l'avant, tandis que les segments les plus proches chevauchent les plus éloignés. </font><font style="vertical-align: inherit;">Cependant, nous ne pouvons pas passer du temps à rendre des polygones, qui seront éventuellement remplacés, il devient donc plus facile de rendre d'avant en arrière et de recadrer des segments distants qui sont fermés par des segments proches déjà rendus si leurs coordonnées projetées sont plus petites </font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu des panneaux d'affichage, des arbres et des voitures</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, la traversée itérative des segments de route d'avant en arrière ne fonctionnera pas lors du rendu des sprites, car ils se chevauchent souvent et doivent donc être rendus à l'aide de l'algorithme de l'artiste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela complique notre méthode </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et nous oblige à contourner les segments de route en deux étapes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'avant en arrière pour le rendu routier</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en arrière pour le rendu des sprites</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8db/7d3/347/8db7d3347ac49621e67b7bbe2028fc6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus des sprites qui se chevauchent partiellement, nous devons traiter des sprites qui «dépassent légèrement» en raison de l'horizon au sommet de la colline. Si le sprite est suffisamment haut, alors nous devrions voir sa partie supérieure, même si le segment de la route sur lequel il se trouve est à l'arrière de la colline, et n'est donc pas rendu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons résoudre le dernier problème en enregistrant la valeur de </font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaque segment sous forme de ligne </font></font><code>clip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à l'étape 1. Ensuite, nous pouvons recadrer les sprites de ce segment le long de la ligne </font></font><code>clip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à l'étape 2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le reste de la logique de rendu détermine comment mettre à l'échelle et positionner le sprite en fonction du coefficient </font></font><code>scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et des coordonnées </font></font><code>screen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des segments de route (calculé sur étape 1), en raison de laquelle, à la deuxième étape de la méthode, </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous avons environ les éléments suivants:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// back to front painters algorithm</span>
<span class="hljs-keyword">for</span>(n = (drawDistance<span class="hljs-number">-1</span>) ; n &gt; <span class="hljs-number">0</span> ; n--) {<font></font>
  segment = segments[(baseSegment.index + n) % segments.length];<font></font>
<font></font>
  <span class="hljs-comment">// render roadside sprites</span>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span> ; i &lt; segment.sprites.length ; i++) {<font></font>
    sprite      = segment.sprites[i];<font></font>
    spriteScale = segment.p1.screen.scale;<font></font>
    spriteX     = segment.p1.screen.x + (spriteScale * sprite.offset * roadWidth * width/<span class="hljs-number">2</span>);<font></font>
    spriteY     = segment.p1.screen.y;<font></font>
    Render.sprite(ctx, width, height, resolution, roadWidth, sprites, sprite.source, spriteScale, spriteX, spriteY, (sprite.offset &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, segment.clip);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// render other cars</span>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span> ; i &lt; segment.cars.length ; i++) {<font></font>
    car         = segment.cars[i];<font></font>
    sprite      = car.sprite;<font></font>
    spriteScale = Util.interpolate(segment.p1.screen.scale, segment.p2.screen.scale, car.percent);<font></font>
    spriteX     = Util.interpolate(segment.p1.screen.x,     segment.p2.screen.x,     car.percent) + (spriteScale * car.offset * roadWidth * width/<span class="hljs-number">2</span>);<font></font>
    spriteY     = Util.interpolate(segment.p1.screen.y,     segment.p2.screen.y,     car.percent);<font></font>
    Render.sprite(ctx, width, height, resolution, roadWidth, sprites, car.sprite, spriteScale, spriteX, spriteY, <span class="hljs-number">-0.5</span>, <span class="hljs-number">-1</span>, segment.clip);<font></font>
  }<font></font>
<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Collisions avec des panneaux d'affichage et des arbres</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que nous pouvons ajouter et rendre des sprites d'objets le long des bords de la route, nous devons changer la méthode </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour déterminer si le joueur a rencontré l'un de ces sprites dans son segment actuel: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nous utilisons une méthode auxiliaire </font></font><code>Util.overlap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour implémenter la reconnaissance généralisée de l'intersection des rectangles. </font><font style="vertical-align: inherit;">Si une intersection est détectée, nous arrêtons la voiture:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">if</span> ((playerX &lt; <span class="hljs-number">-1</span>) || (playerX &gt; <span class="hljs-number">1</span>)) {
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; playerSegment.sprites.length ; n++) {<font></font>
    sprite  = playerSegment.sprites[n];<font></font>
    spriteW = sprite.source.w * SPRITES.SCALE;<font></font>
    <span class="hljs-keyword">if</span> (Util.overlap(playerX, playerW, sprite.offset + spriteW/<span class="hljs-number">2</span> * (sprite.offset &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>), spriteW)) {
      <span class="hljs-comment">// stop the car</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque: si vous étudiez le vrai code, vous verrez qu'en fait, nous n'arrêtons pas la voiture, car elle ne pourra pas se déplacer latéralement pour éviter les obstacles; </font><font style="vertical-align: inherit;">comme un simple hack, nous fixons leur position et permettons à la voiture de «glisser» sur les côtés autour du sprite.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Collisions avec des voitures</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus des collisions avec des sprites le long des bords de la route, nous devons reconnaître les collisions avec d'autres voitures, et si une intersection est détectée, nous ralentissons le joueur en le «repoussant» derrière la machine avec laquelle il est entré en collision:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; playerSegment.cars.length ; n++) {<font></font>
  car  = playerSegment.cars[n];<font></font>
  carW = car.sprite.w * SPRITES.SCALE;<font></font>
  <span class="hljs-keyword">if</span> (speed &gt; car.speed) {
    <span class="hljs-keyword">if</span> (Util.overlap(playerX, playerW, car.offset, carW, <span class="hljs-number">0.8</span>)) {
      <span class="hljs-comment">// slow the car</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mise à jour de la machine</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour que d'autres voitures se déplacent le long de la route, nous leur donnerons l'IA la plus simple:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rouler à vitesse constante</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contourner automatiquement le joueur en cas de dépassement</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contourner automatiquement les autres voitures en cas de dépassement</font></font></li>
</ul><br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque: nous n'avons pas à nous soucier de faire tourner d'autres voitures le long d'une courbe sur la route, car les courbes ne sont pas réelles. </font><font style="vertical-align: inherit;">Si nous faisons simplement rouler les voitures le long des segments de la route, elles passeront automatiquement le long des courbes.</font></font></em></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout cela se produit pendant le cycle de jeu </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lors d'un appel </font></font><code>updateCars()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans lequel nous avançons chaque voiture à une vitesse constante et passons d'un segment au suivant si elles se sont déplacées sur une distance suffisante pendant cette image.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCars</span>(<span class="hljs-params">dt, playerSegment, playerW</span>) </span>{
  <span class="hljs-keyword">var</span> n, car, oldSegment, newSegment;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; cars.length ; n++) {<font></font>
    car         = cars[n];<font></font>
    oldSegment  = findSegment(car.z);<font></font>
    car.offset  = car.offset + updateCarOffset(car, oldSegment, playerSegment, playerW);<font></font>
    car.z       = Util.increase(car.z, dt * car.speed, trackLength);<font></font>
    car.percent = Util.percentRemaining(car.z, segmentLength); <span class="hljs-comment">// useful for interpolation during rendering phase</span><font></font>
    newSegment  = findSegment(car.z);<font></font>
    <span class="hljs-keyword">if</span> (oldSegment != newSegment) {<font></font>
      index = oldSegment.cars.indexOf(car);<font></font>
      oldSegment.cars.splice(index, <span class="hljs-number">1</span>);<font></font>
      newSegment.cars.push(car);<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le procédé </font></font><code>updateCarOffset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permet la mise en œuvre de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"l'intelligence artificielle"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , permettant à la machine de contourner le joueur ou d'autres machines. </font><font style="vertical-align: inherit;">C'est l'une des méthodes les plus complexes de la base de code, et dans un vrai jeu, elle devrait être beaucoup plus complexe pour que les machines semblent beaucoup plus réalistes que dans une simple démo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre projet, nous utilisons une force brute d'IA naïve, forçant chaque machine:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hâte de 20 segments</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si elle trouve une voiture plus lente devant elle qui croise son chemin, alors contournez-la</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tourner à droite des obstacles sur le côté gauche de la route</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tourner à gauche des obstacles sur le côté droit de la route</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tourner suffisamment pour éviter les obstacles à venir dans la distance restante</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons également tricher avec ces voitures qui sont invisibles pour le joueur, leur permettant simplement de ne pas se contourner et de passer. </font><font style="vertical-align: inherit;">Ils ne devraient paraître «intelligents» que dans la visibilité du joueur.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCarOffset</span>(<span class="hljs-params">car, carSegment, playerSegment, playerW</span>) </span>{<font></font>
<font></font>
  <span class="hljs-keyword">var</span> i, j, dir, segment, otherCar, otherCarW, lookahead = <span class="hljs-number">20</span>, carW = car.sprite.w * SPRITES.SCALE;<font></font>
<font></font>
  <span class="hljs-comment">// optimization, dont bother steering around other cars when 'out of sight' of the player</span>
  <span class="hljs-keyword">if</span> ((carSegment.index - playerSegment.index) &gt; drawDistance)
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span> ; i &lt; lookahead ; i++) {<font></font>
    segment = segments[(carSegment.index+i)%segments.length];<font></font>
<font></font>
    <span class="hljs-keyword">if</span> ((segment === playerSegment) &amp;&amp; (car.speed &gt; speed) &amp;&amp; (Util.overlap(playerX, playerW, car.offset, carW, <span class="hljs-number">1.2</span>))) {
      <span class="hljs-keyword">if</span> (playerX &gt; <span class="hljs-number">0.5</span>)<font></font>
        dir = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (playerX &lt; <span class="hljs-number">-0.5</span>)<font></font>
        dir = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">else</span>
        dir = (car.offset &gt; playerX) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">return</span> dir * <span class="hljs-number">1</span>/i * (car.speed-speed)/maxSpeed; <span class="hljs-comment">// the closer the cars (smaller i) and the greater the speed ratio, the larger the offset</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span> ; j &lt; segment.cars.length ; j++) {<font></font>
      otherCar  = segment.cars[j];<font></font>
      otherCarW = otherCar.sprite.w * SPRITES.SCALE;<font></font>
      <span class="hljs-keyword">if</span> ((car.speed &gt; otherCar.speed) &amp;&amp; Util.overlap(car.offset, carW, otherCar.offset, otherCarW, <span class="hljs-number">1.2</span>)) {
        <span class="hljs-keyword">if</span> (otherCar.offset &gt; <span class="hljs-number">0.5</span>)<font></font>
          dir = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (otherCar.offset &lt; <span class="hljs-number">-0.5</span>)<font></font>
          dir = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>
          dir = (car.offset &gt; otherCar.offset) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">return</span> dir * <span class="hljs-number">1</span>/i * (car.speed-otherCar.speed)/maxSpeed;<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la plupart des cas, cet algorithme fonctionne assez bien, mais avec une grande foule de voitures devant, nous pouvons remarquer que les voitures se déplacent de gauche à droite et en arrière, essayant de se faufiler dans l'écart entre les deux autres machines. </font><font style="vertical-align: inherit;">Il existe de nombreuses façons d'améliorer la fiabilité de l'IA, par exemple, vous pouvez permettre aux voitures de ralentir si elles voient qu'il n'y a pas assez d'espace pour éviter les obstacles.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, nous allons créer une interface HTML rudimentaire:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;div id = "hud"&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "speed" class = "hud"&gt; &lt;span id = "speed_value" class = "value"&gt; 0 &lt;/span&gt; mph &lt;/span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "current_lap_time" class = "hud"&gt; Heure: &lt;span id = "current_lap_time_value" class = "value"&gt; 0.0 &lt;/span&gt; &lt;/span&gt; </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "last_lap_time" class = "hud"&gt; Dernier tour: &lt;span id = "last_lap_time_value" class = "value"&gt; 0.0 &lt;/span&gt; &lt;/span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "fast_lap_time" class = "hud"&gt; Tour le plus rapide: &lt;span id = "fast_lap_time_value" class = "value"&gt; 0.0 &lt;/span&gt; &lt;/span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;/div&gt;</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... et y ajouter du style CSS</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-id">#hud</span>                   { <span class="hljs-attribute">position</span>: absolute; <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>; <span class="hljs-attribute">width</span>: <span class="hljs-number">640px</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span> <span class="hljs-number">0</span>; <span class="hljs-attribute">font-family</span>: Verdana, Geneva, sans-serif; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.8em</span>; <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.4</span>); <span class="hljs-attribute">color</span>: black; <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">2px</span> solid black; <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-attribute">-moz-box-sizing</span>: border-box; <span class="hljs-attribute">-webkit-box-sizing</span>: border-box; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.hud</span>              { <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0.6</span>); <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>; <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">5px</span>; <span class="hljs-attribute">transition-property</span>: background-color; <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">2s</span>; <span class="hljs-attribute">-webkit-transition-property</span>: background-color; <span class="hljs-attribute">-webkit-transition-duration</span>: <span class="hljs-number">2s</span>; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#speed</span>            { <span class="hljs-attribute">float</span>: right; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#current_lap_time</span> { <span class="hljs-attribute">float</span>: left;  }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#last_lap_time</span>    { <span class="hljs-attribute">float</span>: left; <span class="hljs-attribute">display</span>: none;  }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#fast_lap_time</span>    { <span class="hljs-attribute">display</span>: block; <span class="hljs-attribute">width</span>: <span class="hljs-number">12em</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto; <span class="hljs-attribute">text-align</span>: center; <span class="hljs-attribute">transition-property</span>: background-color; <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">2s</span>; <span class="hljs-attribute">-webkit-transition-property</span>: background-color; <span class="hljs-attribute">-webkit-transition-duration</span>: <span class="hljs-number">2s</span>; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.value</span>            { <span class="hljs-attribute">color</span>: black; <span class="hljs-attribute">font-weight</span>: bold; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.fastest</span>          { <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">215</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>); }</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... et nous exécuterons sa mise à jour () pendant le cycle de jeu:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">if</span> (position &gt; playerZ) {
  <span class="hljs-keyword">if</span> (currentLapTime &amp;&amp; (startPosition &lt; playerZ)) {<font></font>
    lastLapTime    = currentLapTime;<font></font>
    currentLapTime = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (lastLapTime &lt;= Util.toFloat(Dom.storage.fast_lap_time)) {<font></font>
      Dom.storage.fast_lap_time = lastLapTime;<font></font>
      updateHud(<span class="hljs-string">'fast_lap_time'</span>, formatTime(lastLapTime));<font></font>
      Dom.addClassName(<span class="hljs-string">'fast_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
      Dom.addClassName(<span class="hljs-string">'last_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span> {<font></font>
      Dom.removeClassName(<span class="hljs-string">'fast_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
      Dom.removeClassName(<span class="hljs-string">'last_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
    }<font></font>
    updateHud(<span class="hljs-string">'last_lap_time'</span>, formatTime(lastLapTime));<font></font>
    Dom.show(<span class="hljs-string">'last_lap_time'</span>);<font></font>
  }<font></font>
  <span class="hljs-keyword">else</span> {<font></font>
    currentLapTime += dt;<font></font>
  }<font></font>
}<font></font>
<font></font>
updateHud(<span class="hljs-string">'speed'</span>,            <span class="hljs-number">5</span> * <span class="hljs-built_in">Math</span>.round(speed/<span class="hljs-number">500</span>));<font></font>
updateHud(<span class="hljs-string">'current_lap_time'</span>, formatTime(currentLapTime));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode d'assistance </font></font><code>updateHud()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous permet de mettre à jour les éléments DOM uniquement lorsque les valeurs changent, car une telle mise à jour peut être un processus lent et nous ne devrions pas le faire à 60 images par seconde si les valeurs elles-mêmes ne changent pas.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHud</span>(<span class="hljs-params">key, value</span>) </span>{ <span class="hljs-comment">// accessing DOM can be slow, so only do it if value has changed</span>
  <span class="hljs-keyword">if</span> (hud[key].value !== value) {<font></font>
    hud[key].value = value;<font></font>
    Dom.set(hud[key].dom, value);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/103/563/0d1/1035630d19106de2f85edebb24d0421f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fuh! </font><font style="vertical-align: inherit;">La dernière partie était longue, mais nous avons quand même terminé, et la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">version finie a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atteint le stade où elle peut être appelée un jeu. </font><font style="vertical-align: inherit;">Elle est encore loin du </font><font style="vertical-align: inherit;">match </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminé</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais c'est toujours un match. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est incroyable que nous ayons vraiment réussi à créer un jeu, bien que si simple. </font><font style="vertical-align: inherit;">Je ne prévois pas de mener à bien ce projet. </font><font style="vertical-align: inherit;">Il doit être considéré simplement comme une </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au sujet des jeux de course pseudo-tridimensionnels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est publié par github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et vous pouvez essayer de le transformer en un jeu de course plus avancé. </font><font style="vertical-align: inherit;">Vous pouvez également essayer:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajouter des effets sonores aux voitures</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">améliorer la synchronisation de la musique</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implémenter le plein écran</font></font></li>
<li>   (   , ,    ,  ..)</li>
<li>    </li>
<li>   (,   ..)</li>
<li>       </li>
<li> ,     </li>
<li> ,          -</li>
<li> ,     </li>
<li>   (   ,     ..)</li>
<li>    drawDistance</li>
<li>         x,y</li>
<li>     </li>
<li>      (   ,  )</li>
<li> </li>
<li> </li>
<li>     </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connexions à la fourche et à la route</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le changement de nuit et de jour</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conditions météorologiques</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tunnels, ponts, nuages, murs, bâtiments</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ville, désert, océan</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez Seattle et Space Needle aux arrière-plans</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Méchants» - ajoutez des concurrents pour rivaliser avec</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modes de jeu - le tour le plus rapide, une course contre une (ramasser des pièces?, tirer sur les méchants?)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des tonnes d'options de personnalisation du gameplay</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etc.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc terminé. </font><font style="vertical-align: inherit;">Un autre «projet de week-end» qui a pris beaucoup plus de temps que prévu, mais au final le résultat a été plutôt bon.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Références</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Début d'une série d'articles, routes droites et courbes</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pseudo 3d de Lou</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La source</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Liens vers des démos jouables:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">démo route droite</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">démo avec courbes</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">démo des collines</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">version terminée</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr499432/index.html">Autonomie des tests unitaires dans PHPUnit</a></li>
<li><a href="../fr499434/index.html">Comment mettre en œuvre la gestion des connaissances: bénéficiez de «poches», de «fines perroquets» et de la réflexion sur les clips</a></li>
<li><a href="../fr499436/index.html">Une enzyme télécommandée accélérera le traitement des accidents vasculaires cérébraux et des blessures à la colonne vertébrale</a></li>
<li><a href="../fr499438/index.html">Stream pour les testeurs et pas seulement</a></li>
<li><a href="../fr499440/index.html">Alors que nous écrivions le pilote automatique le plus cool du monde pour une locomotive de manœuvre</a></li>
<li><a href="../fr499444/index.html">Postgres: ballonnement, pg_repack et contraintes différées</a></li>
<li><a href="../fr499446/index.html">Test des chargeurs de démarrage au format STEP pour VR</a></li>
<li><a href="../fr499448/index.html">Implémentation d'une architecture SOLIDE et en couches dans Node.js avec TypeScript et InversifyJS</a></li>
<li><a href="../fr499450/index.html">Choisir l'équipement pour un jeu persan utilisant la génétique / évolution en Python</a></li>
<li><a href="../fr499452/index.html">La vie quotidienne d'un ophtalmologiste à la clinique: quand les médecins ne suffisent pas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>