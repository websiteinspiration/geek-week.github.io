<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😥 👩🏽‍🤝‍👩🏼 🤟🏻 ブロックチェーンのスケーラビリティトリレンマの解決策としてのプラズマキャッシュチェーン 👩🏼‍⚕️ 🏬 🔞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、読者の皆様！
 
 この記事はプラズマキャッシュチェーンに関するもので、次のトピックに光を当てています。
 
 

- スケーラビリティトリレンマとその解決方法。
- 子チェーンのデータ構造とルートチェーンでのそれらの表示。 
- ルートチェーンへの入力の実装。
- ルートチェーンからの...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ブロックチェーンのスケーラビリティトリレンマの解決策としてのプラズマキャッシュチェーン</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457518/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、読者の皆様！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事はプラズマキャッシュチェーンに関するもので、次のトピックに光を当てています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケーラビリティトリレンマとその解決方法。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子チェーンのデータ構造とルートチェーンでのそれらの表示。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルートチェーンへの入力の実装。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルートチェーンからの撤退の実装。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opportyは、Javascriptプログラミング言語を使用して子チェーンとルートチェーンのSolidityを実装しました。</font><font style="vertical-align: inherit;">これらの言語でコード例が提供されています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qd/nd/dv/qdnddvdk76wf5sy2ajwn38jp9w0.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロックチェーンと分散化により、インターネットと情報技術が使用されているほとんどすべての生活圏の仕事を最適化および改善することが可能になります。</font><font style="vertical-align: inherit;">信頼性と経済効率を高め、実物と商品のデジタル化を促進します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スマートコントラクトは、分散型ネットワークにビジネスロジックをもたらします。</font><font style="vertical-align: inherit;">これにより、新しいDAPPアプリケーションを構築できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スマートコントラクトの実行と、分散データベースを使用したアプリケーションの高速操作は、スケーラビリティの条件が満たされた場合にのみ可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現代の分散型ブロックチェーンにはいくつかの欠点があります。</font><font style="vertical-align: inherit;">主なものはスケーラビリティです。</font><font style="vertical-align: inherit;">イーサリアムは約20 tx / sを処理します。</font><font style="vertical-align: inherit;">これは現代の金融現実では十分ではありません。</font><font style="vertical-align: inherit;">同時に、Ethereumは、ハッキングやネットワークの破壊に対する可能な限り最高の保護を備えています。</font><font style="vertical-align: inherit;">ブロックチェーン上に構築された他の暗号通貨とシステムは、それほど高度な分散化を持たないため、ネットワークへの信頼が低下します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケーラビリティトリレンマ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つのコンポーネントを含むブロックチェーンスケーラビリティトリレンマがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地方分権;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全性; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケーラビリティ。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トリレンマの分権化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用語の意味するように、分散化は、ブロックチェーン内のアクティビティの所有権の多様化の度合い、およびブロックの作成と新しい元帳エントリの生成の多様化の度合いを反映しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明確にするために、最も集中化された組織について話す必要があります。通常、ブロックチェーンの代わりに単純なデータベースが使用されます。このような組織は、特別な管理者によって運営されています。すべてのトランザクションは、手動の介入によりキャンセルできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全に分散されたネットワークでは、各ユーザーがネットワークの構築に参加できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
地方分権化の最も重要な結果は、価値のほとんどがブロックチェーンの作成に関与しているコミュニティに提供されることです。</font><font style="vertical-align: inherit;">ネットワーク構造自体を生成するマネージャーではなく、すべてのメリットを享受するマネージャーの中間チームはありません。</font><font style="vertical-align: inherit;">実際、ほとんどの暗号化プロジェクトは、創設者ではなく、その貢献者またはユーザーが完全に所有しています。</font><font style="vertical-align: inherit;">これは明らかに、創設者ではない人々にとってより魅力的なモデルです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トリレンマの安全</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ブロックチェーンが外部ソースからの攻撃に耐え、システムを変更されない状態に保つ能力に関するものです。ほとんどのブロックチェーンは、多くの潜在的なセキュリティ脅威の影響を受けます。最も一般的な攻撃ベクトルと防御オプションについて知ることが不可欠です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、分権化とセキュリティは密接に関連しています。ノードが多いほど、ネットワークが中央側に依存することが少なくなるため、中央の障害点が発生するリスクが低くなります。ただし、分散ネットワークに危険をもたらす他の多くの攻撃ベクトルがあります。次のようなものがあります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50％攻撃</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -未払いトークンの総数の50％を超えるオブジェクトが実際にネットワークを所有しています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シビル攻撃</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-ネットワーク内の所有権や意思決定の重要な共有を効果的に制御するために、ユーザーはシステムで多くの識別子を生成できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DDoS-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分散型サービス拒否（DDoS）攻撃は、ネットワーク上のトラフィックを妨害してネットワークを悪意のあるトランザクションで満たす意図がある場合に発生します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共謀攻撃-1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つ以上のオブジェクト（またはノード）が団結して、ネットワーク上で悪意のある操作を実行することを決定します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トリレンマのスケーラビリティ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スケーラビリティの度合いは、最終的なスループット、つまりネットワークサイズの上限を決定するため、重要です。</font><font style="vertical-align: inherit;">ネットワークを評価するときに尋ねる最も重要な質問は、「このシステムは何人のユーザーに耐えられるか」です。</font><font style="vertical-align: inherit;">ビットコインは現在、290万から580万のウォレットホルダーを持っています。</font><font style="vertical-align: inherit;">EOSには数千のメンバーがいます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スケーラビリティと分散化は共存できますが、セキュリティは低下します。</font><font style="vertical-align: inherit;">開発者は、ニーズに最適なプラットフォームを選択します。</font><font style="vertical-align: inherit;">ユーザーも同じことを行います。</font><font style="vertical-align: inherit;">双方の意見は時々異なります。</font><font style="vertical-align: inherit;">一部のユーザーは、スケーラビリティのためにセキュリティを犠牲にして喜んでいますが、他のユーザーは、セキュリティのためにスケーラビリティを犠牲にして喜んでいますが、バランスをとるのははるかに困難です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロックチェーン技術の「聖杯」</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定義により、ブロックチェーンには次の3つのプロパティのうち2つしかありません。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分散化</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（各参加者はO©リソース、つまり通常のラップトップまたは小さなVPSにのみアクセスできます）;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケーラビリティー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（トランザクションを処理する能力O（n）&gt; O©）;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セキュリティ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（O（n）リソースを使用した侵入者からの保護）。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/ek/zg/zr/ekzgzredr00odj5mwae4f549hzs.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
緑：3つの条件のバランスの取れた状態。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
赤：強力なセキュリティを備えていますが、分散とスケーラビリティが制限されています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
青：効率は高いですが、セキュリティと分散化は制限されています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
黒：分散化は高いですが、スケーラビリティとセキュリティの側面はありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
灰色：セキュリティとスケーラビリティの品質が最小限または欠けている完全な分散化。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイオレット：セキュリティとスケーラビリティの平等なバランス、分散の拒否。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロックチェーン技術の「聖杯」とは、3つの側面すべてを組み合わせることを意味します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗号通貨を扱う現在のほとんどのプロジェクトでは、分散化とセキュリティという2つの基本的な特性が実現されています。スケーラビリティが低下します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トリレンマの有望な解決策</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">賭けの証明（PoS）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proof of Stake（PoS）は、潜在的なスケーラビリティの強化を提供します。</font><font style="vertical-align: inherit;">POSは、Proof of Work（PoW）システムに基づく暗号通貨マイニングに代わるものです。</font><font style="vertical-align: inherit;">バリデーターの選択は、決定論的な方法で非常に高速です。</font><font style="vertical-align: inherit;">同時に、電気代もかからず、環境にも配慮しています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイドチェーン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 イーサリアム仮想ネットワークでは、プロジェクトが個々のトランザクションを処理して、最初と最後の結果のみをイーサリアムネットワークに記録できるサイドネットワークを作成する可能性があります。</font><font style="vertical-align: inherit;">これにより、EVMの負荷は軽減されますが、サイドチェーンの管理に信頼性が高まります。</font><font style="vertical-align: inherit;">したがって、第三者への信頼は分散化を減らします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャーディング </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シャーディングは、トランザクションをより小さなデータに分割します。</font><font style="vertical-align: inherit;">トランザクション全体を処理するネットワーク内の個々のノードの代わりに、ノードはグループに分割され、これらのノードのグループは特定のデータを処理します。</font><font style="vertical-align: inherit;">その後、処理中に、これらのデータがブロックチェーンに永続的に保存するために再同化されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロックサイズを大きくする</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライトコインとビットコインキャッシュ（BCH）は、ビットコインブロックチェーンの「フォーク」です。</font><font style="vertical-align: inherit;">フォークは基本的に1つのブロックチェーンをコピーします。</font><font style="vertical-align: inherit;">分岐後、変更を加えることができます。</font><font style="vertical-align: inherit;">LTCとBCHの両方で各ブロックのサイズが大きくなり、ブロックごとにより多くのトランザクションを格納できるようになり、トランザクション処理の速度が向上しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 雷ネットワーク</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のサイドチェーンソリューションは非常に便利でした。 Lightning Networkの主な考え方は、ネットワークに負荷がかかるため、すべてのトランザクションをブロックチェーンに記録する必要はないということです。ユーザーが互いに何度も資金を送金する場合、各送金の登録はオプションです。一種の支払いチャネルを開いて、ブロックチェーンにそのチャネルに関するデータを書き留めるだけで十分です。このチャネルは必要に応じて開いたままになります。クローズする必要がある場合、このチャネルで行われたすべてのトランザクションの結果は、単にブロックチェーンに書き込まれます。このアイデアに従って、支払いチャネル全体のネットワークを作成できます。そうすると、ブロックチェーン上のトランザクションが使用される頻度が大幅に減ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
支払いチャネルは、いくつかのトランザクションの単なる組み合わせです。</font><font style="vertical-align: inherit;">チャネルは、そのメンバーのいずれかによって閉じることができます。</font><font style="vertical-align: inherit;">このアクションは金庫を開くようなもので、参加者が所有する資金を受け取り、ブロックチェーンへの送金に関するデータを書き留めることができます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この技術は、いくつかの同様のチャネルがThe Lightning Networkと呼ばれるネットワークに結合されると、非常に強力になります。</font><font style="vertical-align: inherit;">このネットワークは、ビットコイン用に特別に構築されています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 雷電ネットワーク</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イーサリアムにとって、ライトニングの最もよく知られている相手は雷電ネットワークです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、メインブロックチェーンの外でスケーリングするためのソリューションです。</font><font style="vertical-align: inherit;">双方向支払いチャネルでのERC-20トークンの転送と互換性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その基本的なアーキテクチャは複雑ですが、雷電との相互作用は、雷電でスケーラブルなアプリケーションを作成するために開発者がAPIと相互作用することのみを必要とします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
雷電は、即時支払いと低コミッションを提供し、取引の機密性とマイクロペイメントを向上させるように設計されています。</font><font style="vertical-align: inherit;">ほとんどの支払いチャネルはネットワークの外部に存在し、ルートチェーン内でトランザクションを形成することがまれにあるため、子チェーンのスループットが大幅に低下します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適なソリューション</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
稲妻思想家は、ブロックチェーンの速度の問題を解決する新しいチャイルドチェーンのコンセプトを作成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opportyは、PlasmaおよびPlasma Cashの概念を実際に実装します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラズマは、Ethereumルートチェーンの上で実行される一連のスマートコントラクトであり、階層ツリー構造でルートチェーンに接続された子チェーンのネットワークで構成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、Ethereumルートチェーンのセキュリティは、スケーラビリティを最適化するために使用されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> プラズマキャッシュ：機会オプション</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opportyは、最初のバージョンでプラズマキャッシュの実装を使用します。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモデルは、スケーラビリティの点で最も効果的なプラズマ実装です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラズマキャッシュは、プラズマチェーンの各トークンに一意の識別子を使用するシステムです。</font><font style="vertical-align: inherit;">つまり、NFTが適用され、ネットワーク内のトークンが一意のシリアル番号を受け取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラズマキャッシュの特徴：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアント側でのシャーディング検証-トークンを取得するには、プラズマチェーンを監視するだけです。</font><font style="vertical-align: inherit;">つまり、個々のユーザーの負荷を増やすことなく、トランザクションのスループットを向上させることができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大量の出口の簡素化-泥棒が盗むトークンごとに出口トランザクションを送信する必要があるため、大量の出口はネットワークに対する脅威が少なくなります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双方向確認の欠如-トランザクションは2段階の送信と確認を必要としなくなりました。</font><font style="vertical-align: inherit;">代わりに、トランザクションは、メインチェーンに含まれるとすぐに使用できます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短所：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大きなトークンの種類-各トークンにはシリアル番号を割り当てる必要があるため、任意の小さなトークンを作成することはできません。</font><font style="vertical-align: inherit;">これは、ある時点で、トークンを購入するコストがトークン自体のコストよりも高くなるためです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opporty Plasma Cashのトランザクション構造</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpportyはJavascriptを使用して子チェーンを実装しました。</font><font style="vertical-align: inherit;">Opporty Plasma Cashの各トランザクションは同様の構造です：</font></font><br>
<br>
<pre><code class="plaintext hljs">const transactionFields = [<font></font>
{name: 'prevHash'},<font></font>
{name: 'prevBlock', int: true, default: 0},<font></font>
{name: 'tokenId', isDecimal: true},<font></font>
{name: 'newOwner'},<font></font>
{name: 'type'},<font></font>
{name: 'signature'},<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここの主な要素は、前のprevBlockブロック（ブロックチェーン内を移動するために必要）、tokenIdトークン識別子（一意である必要があります）、およびトークンの最後の所有者であるnewOwnerへのリンクです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、ブロックを組み立ててルートチェーンハッシュを取得するために、特殊なタイプのパトリシアマークルトライツリーが使用されます。同じツリーがイーサリアムでも使用されています。圧縮された外観です。同時に、ブロックにトランザクションが含まれているかどうかの証明を受け取ることもできます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
署名は楕円曲線の署名です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指定されたtokenIdのトークンを使用するトランザクションは、トークンがトークンIDの位置にあるマークルツリーに含まれている場合にのみ有効です。この形式を使用すると、ユーザーはプラズマチェーンの完全な履歴を確認したり、特定のトークンの所有権を証明したり、反証したりできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トークンを使用するには、チェーンを検証し、欠落しているブロックを確認してから、履歴全体とともにトランザクションに再署名する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロックは次のとおりです。</font></font><br>
 <br>
<pre><code class="plaintext hljs">const blockFields = [<font></font>
{name: 'prevHash'},<font></font>
{name: 'blockNum', isDecimal: true},<font></font>
{name: 'transactions'},<font></font>
{name: 'merkleRoot'},<font></font>
{name: 'time'}<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的なレベルでは、ブロックチェーンは、前のブロックへのリンクを持つブロックのチェーンです。</font><font style="vertical-align: inherit;">このような構成により、履歴を書き換えないという不変性の特性を得ることができる。</font><font style="vertical-align: inherit;">merkleRootを使用すると、ルートチェーンにチェックポイントを書き込むことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルートチェーンでは、スマートコントラクトレベルでは、次のようになります（Solidity言語）。</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
* Block structure (represents one block in a chain)<font></font>
*/<font></font>
struct Block {<font></font>
uint block_num;<font></font>
bytes32 merkle_root;<font></font>
uint time;<font></font>
    <font></font>
 <font></font>
/*<font></font>
* Transaction structure (decoded from RLP form)<font></font>
*/<font></font>
struct Transaction {<font></font>
bytes32 prevhash;<font></font>
uint prev_block;<font></font>
uint token_id;<font></font>
address new_owner;<font></font>
}<font></font>
 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンコーディングは、エンコーディング/デコーディング-RLPシリアライゼーション/デシリアライゼーション機能を使用して実行されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラズマキャッシュを入力する方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰でも簡単にスマートコントラクトにイーサを送金するだけでプラズマキャッシュに資金を入金できます。</font><font style="vertical-align: inherit;">その結果、OPPトークンは特定のtokenId位置で受信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下はSolidityの実装です。</font></font><br>
<br>
<pre><code class="plaintext hljs">function deposit() public payable {<font></font>
uint token_id = uint(keccak256(msg.sender, msg.value, deposit_blk));<font></font>
// token.index = deposit_blk;<font></font>
tokens[token_id] = msg.value;<font></font>
deposit_blk += 1;<font></font>
emit DepositAdded(msg.sender, msg.value, token_id, current_blk);<font></font>
} </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、tokenIdは乱数（ハッシュ）として生成されます。</font><font style="vertical-align: inherit;">次に、子チェーンでスキャンされるイベントが生成されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> プラズマキャッシュに出金する方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ユーザーは、トークンの所有履歴にある最後の2つのトランザクションを提供することにより、トークンを引き出すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルートチェーンからの出口の実装：</font></font><br>
 <br>
<pre><code class="plaintext hljs">function startExit(uint block_num, bytes tx1, bytes tx0, bytes proof1, bytes proof0) public returns (uint exit_id) {<font></font>
require(checkPatriciaProof(keccak256(tx1), childChain[block_num].merkle_root, proof1));<font></font>
 <font></font>
bytes32 prev_hash;<font></font>
uint prev_blk;<font></font>
uint token_id;<font></font>
address new_owner;<font></font>
(prev_hash, prev_blk, token_id, new_owner,) = getTransactionFromRLP(tx1);<font></font>
    <font></font>
require(msg.sender == new_owner);<font></font>
        <font></font>
require(tokens[token_id] &gt; 0);<font></font>
bytes32 hashPrevTx = keccak256(tx0);<font></font>
require(checkPatriciaProof(hashPrevTx, childChain[prev_blk].merkle_root, proof0));<font></font>
require(prev_hash == hashPrevTx);<font></font>
 <font></font>
Exit storage record = exitRecords[token_id];<font></font>
require(record.block_num == 0);<font></font>
 <font></font>
record.block_num = block_num;<font></font>
record.new_owner = msg.sender;<font></font>
record.prev_block = prev_blk;<font></font>
 <font></font>
if (childChain[block_num].time &gt; block.timestamp - week)<font></font>
record.priority = childChain[block_num].time;<font></font>
else<font></font>
record.priority = block.timestamp - week;<font></font>
 <font></font>
exits.add(record.priority);<font></font>
exit_ids[record.priority].push(token_id);<font></font>
 <font></font>
emit ExitAdded(msg.sender, record.priority, token_id);<font></font>
return token_id;<font></font>
}<font></font>
 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、2つのトランザクションがチェックされます。</font><font style="vertical-align: inherit;">現在のユーザーがトランザクションの所有者である場合、その出力を構造に追加し、2週間、出力に挑戦する機会を残します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論には3つの方法で異議を申し立てることができます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランザクションに対する支出の確認を提供します。</font></font></li>
</ul><br>
 <pre><code class="plaintext hljs">function challengeSpent(uint exit_id, uint blk_num, bytes tx1, bytes proof) public { <font></font>
require(checkPatriciaProof(keccak256(tx1), childChain[blk_num].merkle_root, proof));<font></font>
 <font></font>
Exit memory record = exitRecords[exit_id];<font></font>
require(record.block_num &gt; 0);<font></font>
uint prev_block;<font></font>
uint token_id;<font></font>
(, prev_block , token_id, ) = getTransactionFromRLP(tx1);<font></font>
require(tokens[token_id] &gt; 0);<font></font>
require(prev_block == record.block_num &amp;&amp; record.block_num &lt; blk_num);<font></font>
require(token_id == exit_id);<font></font>
 <font></font>
exit_ids[record.priority].remove(exit_id);<font></font>
delete exitRecords[exit_id];<font></font>
emit ExitChallengedEvent(exit_id);<font></font>
}    <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表示されたトークンをすでに使用しているトランザクションがある場合、そのような引き出しはキャンセルされます！</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前回の取引の経費証明：</font></font></li>
</ul><br>
<pre><code class="plaintext hljs">/*<font></font>
* Challenge exit by providing<font></font>
* a proof of a transaction spending P(C) that appears before C<font></font>
*/<font></font>
function challengeDoubleSpend(uint exit_id, uint blk_num, bytes tx1, bytes proof) public { <font></font>
require(checkPatriciaProof(keccak256(tx1), childChain[blk_num].merkle_root, proof));<font></font>
Exit memory record = exitRecords[exit_id];<font></font>
require(record.block_num &gt; 0);<font></font>
// bytes32 prev_hash; <font></font>
uint prev_block;<font></font>
uint token_id; <font></font>
(, prev_block , token_id, ) = getTransactionFromRLP(tx1);<font></font>
require(tokens[token_id] &gt; 0);<font></font>
// check if token double spent<font></font>
require(prev_block == record.prev_block &amp;&amp; blk_num &lt; record.block_num);<font></font>
// require(token_id == exit_id);<font></font>
exit_ids[record.priority].remove(exit_id);<font></font>
delete exitRecords[exit_id];<font></font>
emit ExitChallengedEvent(exit_id);<font></font>
}   <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、引き出しの前にトークンが消費された場合と同じチェックです。</font><font style="vertical-align: inherit;">最初に、ルートハッシュのトランザクションを確認します。</font><font style="vertical-align: inherit;">次に、すでに消費されている場合は、出力を削除します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その前のトークンのトランザクション履歴にトランザクションを提供する。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは間違っている可能性があるため、子トランザクションで確認する必要があります。 </font></font><br>
<br>
<pre><code class="plaintext hljs">//  */<font></font>
function challengeInvalidHistory(uint exit_id, uint blk_num, bytes tx0, bytes proof) public { <font></font>
// check if proof is valid<font></font>
require(checkPatriciaProof(keccak256(tx0), childChain[blk_num].merkle_root, proof));<font></font>
        <font></font>
Exit memory record = exitRecords[exit_id];<font></font>
require(record.block_num &gt; 0);<font></font>
 <font></font>
bytes32 prev_hash; <font></font>
uint token_id; <font></font>
(prev_hash, , token_id, ) = getTransactionFromRLP(tx0);<font></font>
 <font></font>
//require(exit_id == token_id);<font></font>
require(tokens[token_id] &gt; 0);<font></font>
 <font></font>
// transaction should be before exit tx in history<font></font>
require(blk_num &lt; record.block_num - 1);<font></font>
 <font></font>
challenged[exit_id] = blk_num;<font></font>
emit ChallengedInvalidHistory(exit_id, token_id);<font></font>
}<font></font>
 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初と2番目のスクリプトを呼び出すと、出力がすぐにブロックされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目のシナリオへの呼び出しは、直接の子孫を提供することによって応答できます。</font><font style="vertical-align: inherit;">親トランザクションと同じか、それより前である必要があります。</font></font><br>
<br>
<pre><code class="plaintext hljs">/*<font></font>
* Respond to invalid history challenge by providing<font></font>
* the direct child of C*, which must be either equal to or before P( C )<font></font>
*/<font></font>
function respondChallenge(uint exit_id, uint blk_num, bytes childtx, bytes proof) public {<font></font>
require(challenged[exit_id] &gt; 0);<font></font>
Exit memory record = exitRecords[exit_id];<font></font>
require(record.block_num &gt; 0);<font></font>
require(checkPatriciaProof(keccak256(childtx), childChain[blk_num].merkle_root, proof));<font></font>
// get transaction from rlpencoded form<font></font>
bytes32 prev_hash; <font></font>
uint prev_block;<font></font>
uint token_id; <font></font>
(prev_hash, prev_block, token_id, ) = getTransactionFromRLP(childtx);<font></font>
// if direct child<font></font>
if (prev_block == challenged[exit_id] ) {<font></font>
if (blk_num &lt;= record.prev_block &amp;&amp; token_id == exit_id ) {<font></font>
delete challenged[exit_id];<font></font>
emit ExitRespondedEvent(exit_id);<font></font>
} else {<font></font>
exit_ids[record.priority].remove(exit_id);<font></font>
delete exitRecords[exit_id];<font></font>
emit ExitChallengedEvent(exit_id);<font></font>
}<font></font>
}<font></font>
} <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、正しい子トランザクションが受信された場合、出力は係争され、キューに残ります！</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opporty Plasmaキャッシュプロトコルの一部を構築した後、次の結論が出されました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロトコルは、Ethereumルートチェーンを通じてセキュリティを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルートチェーンと状態圧縮（トランザクションブロック）からの入力と出力の手順を複雑にすることで、ルートチェーンへの出力と入力のすべての方法が検討され、基本的なデータ構造であるトランザクションとブロックが調査されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ethereumネットワークに基づくサイドチェーンを使用すると、トランザクションを大幅に高速化できます。 Opportyは</font><font style="vertical-align: inherit;">、単一のオペレーターで毎秒</font><font style="vertical-align: inherit;">最大</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">300,000</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランザクションを</font><font style="vertical-align: inherit;">受け取りました</font><font style="vertical-align: inherit;">。これは、現在の支払いシステムが提供できるものをはるかに超えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データの可用性に関するいくつかの問題にもかかわらず、オペレーターはブロックチェーンの高レベルの安定性を提供し、効果的な国際ビジネストランザクションを可能にします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラズマキャッシュにより、スケーラビリティが大幅に向上します。</font><font style="vertical-align: inherit;">したがって、OpportyはPoEプロトコルの一部としてプラズマを使用します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つリンク</font></font></h3><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ホワイトペーパープラズマ</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gitハブ</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用例とアーキテクチャの説明</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライトニングネットワークペーパー</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457508/index.html">子育てvs機械学習：若い母親を比較する</a></li>
<li><a href="../ja457510/index.html">mcrouterを使用してmemcachedを水平方向にスケーリングする</a></li>
<li><a href="../ja457512/index.html">PostgreSQLのバージョン間の論理レプリケーション</a></li>
<li><a href="../ja457514/index.html">ネバンゲル</a></li>
<li><a href="../ja457516/index.html">脅威モデルの作成</a></li>
<li><a href="../ja457522/index.html">メーリングリストサービスを向上させるか、既成のソリューションを使用しますか？UniSenderで5年間に学んだこと</a></li>
<li><a href="../ja457524/index.html">深度カメラ-サイレント革命（ロボットが見るとき）パート1</a></li>
<li><a href="../ja457526/index.html">バザーとしてのテクニカルメディア</a></li>
<li><a href="../ja457534/index.html">認定バージョン-私たちが選択したレーキ</a></li>
<li><a href="../ja457538/index.html">中断されたYandex.Cloud仮想マシンを使用して、大規模な問題を解決する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>