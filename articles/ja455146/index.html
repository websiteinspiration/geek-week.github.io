<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏽 👽 🕌 Tarantool DBMSでの高レベルのレプリケーション 👍🏽 🧝🏼 🥛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、私はTarantool DBMSのアプリケーションを開発しています。これは、高性能DBMSとLuaのアプリケーションサーバーを組み合わせたMail.ru Groupによって開発されたプラットフォームです。 Tarantoolベースのソリューションの高速化は、特に、インメモリDBMSモード...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Tarantool DBMSでの高レベルのレプリケーション</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/455146/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarantool</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DBMSのアプリケーションを開発しています。</font><font style="vertical-align: inherit;">これは、高性能DBMSとLuaのアプリケーションサーバーを組み合わせたMail.ru Groupによって開発されたプラットフォームです。 Tarantoolベースのソリューションの高速化は、特に、インメモリDBMSモードと、データを含む単一のアドレス空間でアプリケーションビジネスロジックを実行する機能をサポートすることで実現されます。これにより、ACIDトランザクションを使用してデータの永続性が保証されます（WALログはディスクに保持されます）。 Tarantoolには、レプリケーションとシャーディングのサポートが組み込まれています。バージョン2.1以降、SQLクエリがサポートされています。 Tarantoolはオープンソースで、Simplified BSDの下でライセンスされています。商用のEnterpriseバージョンもあります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4aa/22f/d04/4aa22fd046775dd3b44af444ddcde28d.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">力を感じます！ （...別名、パフォーマンスを楽しむ）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
上記のすべてにより、Tarantoolは高負荷のデータベースアプリケーションを作成するための魅力的なプラットフォームになります。このようなアプリケーションでは、データの複製が必要になることがよくあります。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のように、Tarantoolには組み込みのデータレプリケーションがあります。その動作の原理は、ウィザードログ（WAL）に含まれるすべてのトランザクションのレプリカでの順次実行です。通常、このようなレプリケーション（以下では</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低レベル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼びます</font><font style="vertical-align: inherit;">）は、アプリケーションのフォールトトレランスを提供したり、クラスターのノード間で読み取りの負荷を分散したりするために使用されます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d1c/31b/83b/d1c31b83b1c71220a514deebb7d49952.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 1.クラスター内での複製</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
代替シナリオの例は、あるデータベースで作成されたデータを、処理/監視のために別のデータベースに転送することです。後者の場合、</font><i><font style="vertical-align: inherit;">より高いレベルの</font></i><font style="vertical-align: inherit;">使用がより便利な解決策になる場合があります。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レプリケーション-アプリケーションのビジネスロジックレベルでのデータレプリケーション。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">DBMSに組み込まれている既成のソリューションは使用しませんが、開発しているアプリケーション内にレプリケーションを実装します。</font><font style="vertical-align: inherit;">このアプローチには、利点と欠点の両方があります。</font><font style="vertical-align: inherit;">利点を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.トラフィックを節約：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのデータを転送するのではなく、その一部のみを転送できます（たとえば、特定の基準を満たす一部のテーブル、一部の列またはレコードのみを転送できます）。</font></font><br>
</li>
<li>    ,      (    Tarantool — 1.10)   (     Tarantool) ,      (..      —   ,     ,        ..);<br>
</li>
<li>    ,       (    ,         ,   ).<br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.リモートデータベースを同期できるHTTPを介した交換の実装に問題はありません。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/551/551/7aa/5515517aaa739f6260023c5e8ff30bf0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">2. HTTP経由のレプリケーション</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
3.データが送信されるデータベース構造は同じである必要はありません（さらに、一般的なケースでは、異なるDBMS、プログラミング言語、プラットフォームなどを使用することも可能です）。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/830/85a/64b/83085a64b69ff5dba2431db97213fa82.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">3.異機種システムでのレプリケーション</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
欠点は、プログラミングが平均して構成よりも複雑/高価であり、組み込み機能をセットアップする代わりに、独自の機能を実装する必要があることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の利点が決定的な役割を果たす（または必要な条件である）場合、高レベルのレプリケーションを使用することは理にかなっています。</font><font style="vertical-align: inherit;">Tarantool DBMSに高レベルのデータ複製を実装するいくつかの方法を考えてみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トラフィックの最小化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、高レベルのレプリケーションの利点の1つはトラフィックを節約することです。</font><font style="vertical-align: inherit;">この利点を十分に発揮させるには、各交換セッション中に送信されるデータの量を最小限に抑える必要があります。</font><font style="vertical-align: inherit;">もちろん、セッションの最後にデータレシーバーをソースと同期する必要があることを忘れないでください（少なくともレプリケーションに関係するデータの一部について）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高レベルのレプリケーション中に転送されるデータの量を最小限に抑えるにはどうすればよいですか？</font><font style="vertical-align: inherit;">「額の」解決策は、日時によるデータの選択かもしれません。</font><font style="vertical-align: inherit;">これを行うには、テーブルに既に存在する日時フィールドを使用できます（ある場合）。</font><font style="vertical-align: inherit;">たとえば、「注文」というドキュメントには、「注文実行に必要な時間」というフィールドがあります。</font></font><code>delivery_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このソリューションの問題は、このフィールドの値が注文の作成に対応する順序である必要がないことです。したがって、</font></font><code>delivery_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前回の交換セッション中に送信され</font><font style="vertical-align: inherit;">た最大フィールド値を覚えておくことはできず</font><font style="vertical-align: inherit;">、次の交換セッション中に、より高いフィールド値を持つすべてのレコードを選択します</font></font><code>delivery_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。交換セッション間のインターバルで、フィールド値の小さいレコードを追加できます</font></font><code>delivery_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。また、注文は変更される可能性がありますが、フィールドには影響しませんでした</font></font><code>delivery_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。どちらの場合も、変更はソースからレシーバーに送信されません。これらの問題を解決するには、データを「オーバーラップ」で送信する必要があります。それら。各交換セッション中に、フィールド値を含むすべてのデータを転送します</font></font><code>delivery_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">過去のある瞬間を超える（たとえば、現在の瞬間からN時間）。ただし、大規模なシステムの場合、このアプローチは非常に冗長であり、私たちが目指しているトラフィックの節約を減らすことができることは明らかです。さらに、送信されたテーブルには日時フィールドがない場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装の点でより複雑な別のソリューションは、データの受信を確認することです。この場合、各交換セッションで、すべてのデータが送信されますが、受信者はその受信を確認しません。実装するには、ソーステーブルにブール列を追加する必要があります（たとえば、</font></font><code>is_transferred</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。受信者がレコードの受信を確認すると、対応するフィールドに値が入ります</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後、レコードは交換に関与しなくなります。この実装オプションには、次の欠点があります。まず、転送されたレコードごとに、確認を生成して送信する必要があります。大まかに言えば、これは転送されるデータ量を2倍にし、往復回数を2倍にすることに相当します。第2に、同じレコードを複数の受信者に送信する可能性はありません（最初の受信者が自分自身と他のすべての人の受信を確認します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法には、上記の欠点がないため、送信されるテーブルに列を追加して、その行の変更を追跡します。このような列は、日時タイプである可能性があり、レコードを追加/変更するたびに（アトミックに追加/変更して）、現在の時間に対してアプリケーションによって設定/更新される必要があります。例として、列を呼び出してみましょう</font></font><code>update_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。転送されたレコードのこの列の最大フィールド値を保存したら、この値から次の交換セッションを開始できます（</font></font><code>update_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前に保存した値を超える</font><font style="vertical-align: inherit;">フィールド値</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">持つレコードを選択し</font><font style="vertical-align: inherit;">ます）。後者のアプローチの問題は、データ変更がバッチモードで発生する可能性があることです。その結果、列のフィールド値</font></font><code>update_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一意ではない可能性があります。したがって、この列はバッチ（ページ）データ出力には使用できません。ページごとのデータ出力の場合、効率が非常に低い可能性のある追加のメカニズムを作成する必要があります（たとえば、</font></font><code>update_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定され</font><font style="vertical-align: inherit;">た値</font><font style="vertical-align: inherit;">よりも高い</font><font style="vertical-align: inherit;">値を持つすべてのレコードをデータベースから抽出し</font><font style="vertical-align: inherit;">、サンプルの開始からの特定のオフセットから開始して、特定の数のレコードを発行します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前のアプローチを少し改善することで、データ転送の効率を上げることができます。これを行うには、変更を追跡するための列フィールド値として整数型（長整数）を使用します。列に名前を付ける</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この列のフィールド値は、レコードが作成/変更されるたびに設定/更新する必要があります。</font><font style="vertical-align: inherit;">ただし、この場合、フィールドには現在の日時ではなく、一部のカウンターの値が1ずつ増加します。</font><font style="vertical-align: inherit;">その結果、列</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には一意の値が含まれ</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">「デルタ」データ（前の交換セッションの終了後に追加/変更されたデータ）を出力するだけでなく、単純で効果的なページ分割にも使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高レベルのレプリケーションのフレームワークで送信されるデータの量を最小限に抑えるために最後に提案された方法は、私にとって最も最適で普遍的なもののようです。</font><font style="vertical-align: inherit;">もっと詳しく見てみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行バージョンカウンターを使用したデータ転送</font></font></h2><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバー/マスターの実装</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MS SQL Serverでは、このアプローチを実装するために、特別な列タイプ-があり</font></font><code>rowversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。各データベースにはカウンターがあり、タイプ列を持つテーブルでレコードを追加/変更するたびに1ずつ増加します</font></font><code>rowversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このカウンターの値は、追加/変更されたレコードのこの列のフィールドに自動的に割り当てられます。 Tarantool DBMSには、同様の組み込みメカニズムはありません。ただし、Tarantoolでは、手動で実装することは難しくありません。これがどのように行われるかを検討してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、いくつかの用語：Tarantoolのテーブルはスペースと呼ばれ、レコードはタプルと呼ばれます。</font><font style="vertical-align: inherit;">Tarantoolでは、シーケンスを作成できます。</font><font style="vertical-align: inherit;">シーケンスは、整数の順序付けされた値の名前付きジェネレータにすぎません。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">これが目的に必要なものです。</font><font style="vertical-align: inherit;">以下では、そのようなシーケンスを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantoolでデータベース操作を実行する前に、次のコマンドを実行する必要があります。</font></font><br>
<br>
<pre><code class="lua hljs">box.cfg{}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、Tarantoolはスナップショットとトランザクションログを現在のディレクトリに書き込み始めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーケンスを作成します</font></font><code>row_version</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="lua hljs">box.schema.sequence.<span class="hljs-built_in">create</span>(<span class="hljs-string">'row_version'</span>,<font></font>
    { if_not_exists = <span class="hljs-literal">true</span> })</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このオプションを</font></font><code>if_not_exists</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用すると、作成スクリプトを複数回実行できます。オブジェクトが存在する場合、Tarantoolはそれを再作成しようとしません。</font><font style="vertical-align: inherit;">このオプションは、後続のすべてのDDLコマンドで使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例としてスペースを作成してみましょう。</font></font><br>
<br>
<pre><code class="lua hljs">box.schema.space.<span class="hljs-built_in">create</span>(<span class="hljs-string">'goods'</span>, {
    <span class="hljs-built_in">format</span> = {<font></font>
        {<font></font>
            name = <span class="hljs-string">'id'</span>,
            <span class="hljs-built_in">type</span> = <span class="hljs-string">'unsigned'</span><font></font>
<font></font>
        },<font></font>
        {<font></font>
            name = <span class="hljs-string">'name'</span>,
            <span class="hljs-built_in">type</span> = <span class="hljs-string">'string'</span><font></font>
<font></font>
        },<font></font>
        {<font></font>
            name = <span class="hljs-string">'code'</span>,
            <span class="hljs-built_in">type</span> = <span class="hljs-string">'unsigned'</span><font></font>
<font></font>
        },<font></font>
        {<font></font>
            name = <span class="hljs-string">'row_ver'</span>,
            <span class="hljs-built_in">type</span> = <span class="hljs-string">'unsigned'</span><font></font>
<font></font>
        }<font></font>
    },<font></font>
    if_not_exists = <span class="hljs-literal">true</span>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、スペース</font></font><code>goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の名前</font><font style="vertical-align: inherit;">（</font><font style="vertical-align: inherit;">）、フィールドの名前、およびそれらのタイプを設定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantoolの自動インクリメントフィールドもシーケンスを使用して作成されます。</font><font style="vertical-align: inherit;">フィールドに自動増分主キーを作成します</font></font><code>id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="lua hljs">box.schema.sequence.<span class="hljs-built_in">create</span>(<span class="hljs-string">'goods_id'</span>,<font></font>
    { if_not_exists = <span class="hljs-literal">true</span> })<font></font>
box.space.goods:create_index(<span class="hljs-string">'primary'</span>, {<font></font>
    parts = { <span class="hljs-string">'id'</span> },<font></font>
    sequence = <span class="hljs-string">'goods_id'</span>,<font></font>
    unique = <span class="hljs-literal">true</span>,
    <span class="hljs-built_in">type</span> = <span class="hljs-string">'HASH'</span>,<font></font>
    if_not_exists = <span class="hljs-literal">true</span>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantoolは、いくつかのタイプのインデックスをサポートしています。ほとんどの場合、TREEおよびHASHタイプのインデックスが使用されます。これらは、名前に対応する構造に基づいています。 TREEは最も用途の広いインデックスタイプです。順序付けられた方法でデータを取得できます。しかし、同等性の選択にはHASHの方が適しています。したがって、主キーにはHASHを使用することをお勧めします（これを行いました）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列を使用して</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更されたデータを送信するには、シーケンス値をこの列のフィールドにバインドする必要があります</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ただし、主キーとは異なり、列フィールドの値は、</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいレコードを追加するときだけでなく、既存のレコードを変更するときにも1ずつ増える必要があります。これを行うには、トリガーを使用できます。 Tarantoolには2種類のスペーストリガーがあります。</font></font><code>before_replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>on_replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">スペース内のデータが変更されるたびにトリガーがトリガーされます（変更の影響を受けるタプルごとに、トリガー関数がトリガーされます）。</font><font style="vertical-align: inherit;">対照的に</font></font><code>on_replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>before_replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-triggersを使用すると、トリガーが実行されるタプルのデータを変更できます。</font><font style="vertical-align: inherit;">したがって、最後のタイプのトリガーが適しています。</font></font><br>
<br>
<pre><code class="lua hljs">box.space.goods:before_replace(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(old, new)</span></span>
    <span class="hljs-keyword">return</span> box.tuple.new({new[<span class="hljs-number">1</span>], new[<span class="hljs-number">2</span>], new[<span class="hljs-number">3</span>],<font></font>
        box.sequence.row_version:<span class="hljs-built_in">next</span>()})
<span class="hljs-keyword">end</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指定されたトリガーは、</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格納されているタプルの</font><font style="vertical-align: inherit;">フィールド値を</font><font style="vertical-align: inherit;">次のシーケンス値に</font><font style="vertical-align: inherit;">置き換え</font><font style="vertical-align: inherit;">ます</font></font><code>row_version</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">列</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
のスペースからデータを取得できるように</font><font style="vertical-align: inherit;">するには、インデックスを作成します。</font></font><code>goods</code><font style="vertical-align: inherit;"></font><code>row_ver</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="lua hljs">box.space.goods:create_index(<span class="hljs-string">'row_ver'</span>, {<font></font>
    parts = { <span class="hljs-string">'row_ver'</span> },<font></font>
    unique = <span class="hljs-literal">true</span>,
    <span class="hljs-built_in">type</span> = <span class="hljs-string">'TREE'</span>,<font></font>
    if_not_exists = <span class="hljs-literal">true</span>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インデックスタイプはツリー（</font></font><code>TREE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）です。</font><font style="vertical-align: inherit;">列の値の昇順でデータを取得する必要があります</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スペースにデータを追加します。</font></font><br>
<br>
<pre><code class="lua hljs">box.space.goods:<span class="hljs-built_in">insert</span>{<span class="hljs-literal">nil</span>, <span class="hljs-string">'pen'</span>, <span class="hljs-number">123</span>}<font></font>
box.space.goods:<span class="hljs-built_in">insert</span>{<span class="hljs-literal">nil</span>, <span class="hljs-string">'pencil'</span>, <span class="hljs-number">321</span>}<font></font>
box.space.goods:<span class="hljs-built_in">insert</span>{<span class="hljs-literal">nil</span>, <span class="hljs-string">'brush'</span>, <span class="hljs-number">100</span>}<font></font>
box.space.goods:<span class="hljs-built_in">insert</span>{<span class="hljs-literal">nil</span>, <span class="hljs-string">'watercolour'</span>, <span class="hljs-number">456</span>}<font></font>
box.space.goods:<span class="hljs-built_in">insert</span>{<span class="hljs-literal">nil</span>, <span class="hljs-string">'album'</span>, <span class="hljs-number">101</span>}<font></font>
box.space.goods:<span class="hljs-built_in">insert</span>{<span class="hljs-literal">nil</span>, <span class="hljs-string">'notebook'</span>, <span class="hljs-number">800</span>}<font></font>
box.space.goods:<span class="hljs-built_in">insert</span>{<span class="hljs-literal">nil</span>, <span class="hljs-string">'rubber'</span>, <span class="hljs-number">531</span>}<font></font>
box.space.goods:<span class="hljs-built_in">insert</span>{<span class="hljs-literal">nil</span>, <span class="hljs-string">'ruler'</span>, <span class="hljs-number">135</span>}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜなら </font><font style="vertical-align: inherit;">最初のフィールドは自動インクリメントカウンターです。代わりにnilを渡します。</font><font style="vertical-align: inherit;">Tarantoolは自動的に次の値を置き換えます。</font><font style="vertical-align: inherit;">同様に、列フィールドの値として</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nil </font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">渡すことも、値をまったく指定しないこともできます。</font><font style="vertical-align: inherit;">この列は、スペースの最後の位置になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
挿入の結果を確認します。</font></font><br>
<br>
<pre><code class="lua hljs">tarantool&gt; box.space.goods:<span class="hljs-built_in">select</span>()
<span class="hljs-comment">---</span>
- - [<span class="hljs-number">1</span>, <span class="hljs-string">'pen'</span>, <span class="hljs-number">123</span>, <span class="hljs-number">1</span>]<font></font>
  - [<span class="hljs-number">2</span>, <span class="hljs-string">'pencil'</span>, <span class="hljs-number">321</span>, <span class="hljs-number">2</span>]<font></font>
  - [<span class="hljs-number">3</span>, <span class="hljs-string">'brush'</span>, <span class="hljs-number">100</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">4</span>, <span class="hljs-string">'watercolour'</span>, <span class="hljs-number">456</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">5</span>, <span class="hljs-string">'album'</span>, <span class="hljs-number">101</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">6</span>, <span class="hljs-string">'notebook'</span>, <span class="hljs-number">800</span>, <span class="hljs-number">6</span>]<font></font>
  - [<span class="hljs-number">7</span>, <span class="hljs-string">'rubber'</span>, <span class="hljs-number">531</span>, <span class="hljs-number">7</span>]<font></font>
  - [<span class="hljs-number">8</span>, <span class="hljs-string">'ruler'</span>, <span class="hljs-number">135</span>, <span class="hljs-number">8</span>]<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、最初と最後のフィールドは自動的に入力されています。</font><font style="vertical-align: inherit;">これで、ページングスペースの変更のための関数を簡単に記述できます</font></font><code>goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">local</span> page_size = <span class="hljs-number">5</span>
<span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_goods</span><span class="hljs-params">(row_ver)</span></span>
    <span class="hljs-keyword">local</span> index = box.space.goods.index.row_ver
    <span class="hljs-keyword">local</span> goods = {}
    <span class="hljs-keyword">local</span> counter = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> _, tuple <span class="hljs-keyword">in</span> index:<span class="hljs-built_in">pairs</span>(row_ver, { iterator = <span class="hljs-string">'GT'</span> }) <span class="hljs-keyword">do</span>
        <span class="hljs-keyword">local</span> obj = tuple:tomap({ names_only = <span class="hljs-literal">true</span> })
        <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(goods, obj)<font></font>
        counter = counter + <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> counter &gt;= page_size <span class="hljs-keyword">then</span>
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> goods
<span class="hljs-keyword">end</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数は、</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後に受け取ったレコードの</font><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">（最初の呼び出しでは0）を</font><font style="vertical-align: inherit;">パラメーターとして</font><font style="vertical-align: inherit;">受け取り、変更されたデータの次のバッチを返します（ある場合は空の配列）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantoolでのデータ検索は、インデックスを介して行われます。この関数</font></font><code>get_goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、インデックスイテレータ</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して、変更されたデータを取得します。イテレーターのタイプはGT（より大、より大）です。これは、イテレーターが、渡されたキーの後の次の値から順にインデックス値をトラバースすることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イテレータはタプルを返します。その後HTTP経由でデータを転送できるようにするには、タプルを後続のシリアル化に便利な構造に変換する必要があります。この例では、標準関数を使用しています。</font></font><code>tomap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。使用する代わりに</font></font><code>tomap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、独自の関数を作成できます。たとえば</font></font><code>name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、フィールド</font></font><code>code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">渡してフィールド</font><font style="vertical-align: inherit;">を追加するの</font><font style="vertical-align: inherit;">ではなく</font><font style="vertical-align: inherit;">、フィールドの名前を変更したい</font><font style="vertical-align: inherit;">場合が</font><font style="vertical-align: inherit;">あります</font></font><code>comment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unflatten_goods</span><span class="hljs-params">(tuple)</span></span>
    <span class="hljs-keyword">local</span> obj = {}<font></font>
    obj.id = tuple.id<font></font>
    obj.goods_name = tuple.name<font></font>
    obj.comment = <span class="hljs-string">'some comment'</span><font></font>
    obj.row_ver = tuple.row_ver<font></font>
    <span class="hljs-keyword">return</span> obj
<span class="hljs-keyword">end</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力データのページサイズ（1つの部分のレコード数）は、変数によって決定されます</font></font><code>page_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この例では、値</font></font><code>page_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は5です。実際のプログラムでは、通常、ページサイズの方が重要です。スペースタプルの平均サイズによって異なります。データ転送時間を測定することで、経験的に最適なページサイズを選択できます。ページが大きいほど、送信側と受信側の間の往復回数は少なくなります。したがって、変更をアップロードするための合計時間を短縮できます。ただし、ページサイズが大きすぎる場合、サーバーが選択をシリアル化するのに時間がかかりすぎます。その結果、サーバーに送信された他の要求の処理に遅延が生じる可能性があります。パラメータ</font></font><code>page_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成ファイルからダウンロードできます。</font><font style="vertical-align: inherit;">送信されたスペースごとに、独自の値を設定できます。</font><font style="vertical-align: inherit;">ただし、ほとんどのスペースでは、デフォルト値（たとえば、100）が適切な場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数</font></font><code>get_goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をモジュールに</font><font style="vertical-align: inherit;">入れ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">変数</font></font><code>page_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と関数の</font><font style="vertical-align: inherit;">説明を含むrepl.luaファイルを作成します</font></font><code>get_goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ファイルの最後に、エクスポート関数を追加します。</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">return</span> {<font></font>
    get_goods = get_goods<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールをロードするには、次を実行：</font></font><br>
<br>
<pre><code class="lua hljs">tarantool&gt; repl = <span class="hljs-built_in">require</span>(<span class="hljs-string">'repl'</span>)
<span class="hljs-comment">---</span><font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数を実行してみましょう</font></font><code>get_goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number">0</span>)
<span class="hljs-comment">---</span>
- - row_ver: <span class="hljs-number">1</span>
    code: <span class="hljs-number">123</span><font></font>
    name: pen<font></font>
    id: <span class="hljs-number">1</span>
  - row_ver: <span class="hljs-number">2</span>
    code: <span class="hljs-number">321</span><font></font>
    name: pencil<font></font>
    id: <span class="hljs-number">2</span>
  - row_ver: <span class="hljs-number">3</span>
    code: <span class="hljs-number">100</span><font></font>
    name: brush<font></font>
    id: <span class="hljs-number">3</span>
  - row_ver: <span class="hljs-number">4</span>
    code: <span class="hljs-number">456</span><font></font>
    name: watercolour<font></font>
    id: <span class="hljs-number">4</span>
  - row_ver: <span class="hljs-number">5</span>
    code: <span class="hljs-number">101</span><font></font>
    name: album<font></font>
    id: <span class="hljs-number">5</span>
...</code></pre><br><font style="vertical-align: inherit;"></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後の行から</font><font style="vertical-align: inherit;">
フィールド値を取得</font><font style="vertical-align: inherit;">して、関数を再度呼び出します。</font></font><br>
<br>
<pre><code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number">5</span>)
<span class="hljs-comment">---</span>
- - row_ver: <span class="hljs-number">6</span>
    code: <span class="hljs-number">800</span><font></font>
    name: notebook<font></font>
    id: <span class="hljs-number">6</span>
  - row_ver: <span class="hljs-number">7</span>
    code: <span class="hljs-number">531</span><font></font>
    name: rubber<font></font>
    id: <span class="hljs-number">7</span>
  - row_ver: <span class="hljs-number">8</span>
    code: <span class="hljs-number">135</span><font></font>
    name: ruler<font></font>
    id: <span class="hljs-number">8</span>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度：</font></font><br>
<br>
<pre><code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number">8</span>)
<span class="hljs-comment">---</span><font></font>
- []<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、この使用法では、関数page-by-pageはすべてのスペースレコードを返します</font></font><code>goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最後のページの後には空の選択が続きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スペースを変更します。</font></font><br>
<br>
<pre><code class="lua hljs">box.space.goods:update(<span class="hljs-number">4</span>, {{<span class="hljs-string">'='</span>, <span class="hljs-number">6</span>, <span class="hljs-string">'copybook'</span>}})<font></font>
box.space.goods:<span class="hljs-built_in">insert</span>{<span class="hljs-literal">nil</span>, <span class="hljs-string">'clip'</span>, <span class="hljs-number">234</span>}<font></font>
box.space.goods:<span class="hljs-built_in">insert</span>{<span class="hljs-literal">nil</span>, <span class="hljs-string">'folder'</span>, <span class="hljs-number">432</span>}</code></pre><br><font style="vertical-align: inherit;"></font><code>name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのレコードの</font><font style="vertical-align: inherit;">
フィールド値を変更し、</font><font style="vertical-align: inherit;">2つの新しいレコードを追加しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後の関数呼び出しを繰り返します。</font></font><br>
<br>
<pre><code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number">8</span>)
<span class="hljs-comment">---</span>
- - row_ver: <span class="hljs-number">9</span>
    code: <span class="hljs-number">800</span><font></font>
    name: copybook<font></font>
    id: <span class="hljs-number">6</span>
  - row_ver: <span class="hljs-number">10</span>
    code: <span class="hljs-number">234</span><font></font>
    name: clip<font></font>
    id: <span class="hljs-number">9</span>
  - row_ver: <span class="hljs-number">11</span>
    code: <span class="hljs-number">432</span><font></font>
    name: folder<font></font>
    id: <span class="hljs-number">10</span>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は、変更および追加されたレコードを返しました。</font><font style="vertical-align: inherit;">したがって、この関数を</font></font><code>get_goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用すると、検討中のレプリケーション方式の基礎である、最後の呼び出し以降に変更されたデータを受信できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の範囲を超えて、HTTP経由の結果の出力をJSON形式で残してみましょう。</font><font style="vertical-align: inherit;">あなたはそれについてここで読むことができます：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">https</font></a><font style="vertical-align: inherit;">：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//habr.com/ru/company/mailru/blog/272141/</font></font></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアント/スレーブ部分の実装</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
受信側の実装がどのように見えるかを検討してください。</font><font style="vertical-align: inherit;">受信側に、ダウンロードしたデータを保存するスペースを作成します。</font></font><br>
<br>
<pre><code class="lua hljs">box.schema.space.<span class="hljs-built_in">create</span>(<span class="hljs-string">'goods'</span>, {
    <span class="hljs-built_in">format</span> = {<font></font>
        {<font></font>
            name = <span class="hljs-string">'id'</span>,
            <span class="hljs-built_in">type</span> = <span class="hljs-string">'unsigned'</span><font></font>
<font></font>
        },<font></font>
        {<font></font>
            name = <span class="hljs-string">'name'</span>,
            <span class="hljs-built_in">type</span> = <span class="hljs-string">'string'</span><font></font>
<font></font>
        },<font></font>
        {<font></font>
            name = <span class="hljs-string">'code'</span>,
            <span class="hljs-built_in">type</span> = <span class="hljs-string">'unsigned'</span><font></font>
<font></font>
        }<font></font>
    },<font></font>
    if_not_exists = <span class="hljs-literal">true</span><font></font>
})<font></font>
<font></font>
box.space.goods:create_index(<span class="hljs-string">'primary'</span>, {<font></font>
    parts = { <span class="hljs-string">'id'</span> },<font></font>
    sequence = <span class="hljs-string">'goods_id'</span>,<font></font>
    unique = <span class="hljs-literal">true</span>,
    <span class="hljs-built_in">type</span> = <span class="hljs-string">'HASH'</span>,<font></font>
    if_not_exists = <span class="hljs-literal">true</span>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スペースの構造は、ソース内のスペースの構造に似ています。</font><font style="vertical-align: inherit;">ただし、受信したデータを他の場所に転送することはない</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、受信者のスペース</font><font style="vertical-align: inherit;">には列がありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">フィールド</font></font><code>id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にはソースの識別子が含まれます。</font><font style="vertical-align: inherit;">したがって、受信側では、自動インクリメントする必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、値を保存するためのスペースが必要です</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="lua hljs">box.schema.space.<span class="hljs-built_in">create</span>(<span class="hljs-string">'row_ver'</span>, {
    <span class="hljs-built_in">format</span> = {<font></font>
        {<font></font>
            name = <span class="hljs-string">'space_name'</span>,
            <span class="hljs-built_in">type</span> = <span class="hljs-string">'string'</span><font></font>
<font></font>
        },<font></font>
        {<font></font>
            name = <span class="hljs-string">'value'</span>,
            <span class="hljs-built_in">type</span> = <span class="hljs-string">'string'</span><font></font>
<font></font>
        }<font></font>
    },<font></font>
    if_not_exists = <span class="hljs-literal">true</span><font></font>
})<font></font>
<font></font>
box.space.row_ver:create_index(<span class="hljs-string">'primary'</span>, {<font></font>
    parts = { <span class="hljs-string">'space_name'</span> },<font></font>
    unique = <span class="hljs-literal">true</span>,
    <span class="hljs-built_in">type</span> = <span class="hljs-string">'HASH'</span>,<font></font>
    if_not_exists = <span class="hljs-literal">true</span>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロードされたスペース（フィールド</font></font><code>space_name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">ごとに</font><font style="vertical-align: inherit;">、最後にロードされた値</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（フィールド</font></font><code>value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">ここに保存します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">列は主キーとして機能します</font></font><code>space_name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">HTTP経由で</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スペースデータ</font></font><code>goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">ロードするための関数を作成してみましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これを行うには、HTTPクライアントを実装するライブラリが必要です。</font><font style="vertical-align: inherit;">次の行はライブラリをロードし、HTTPクライアントをインスタンス化します。</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">local</span> http_client = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http.client'</span>).new()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
jsonの逆シリアル化用のライブラリも必要です。</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">local</span> json = <span class="hljs-built_in">require</span>(<span class="hljs-string">'json'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、データ読み込み関数を作成するのに十分です：</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load_data</span><span class="hljs-params">(url, row_ver)</span></span>
    <span class="hljs-keyword">local</span> url = (<span class="hljs-string">'%s?rowVer=%s'</span>):<span class="hljs-built_in">format</span>(url,
        <span class="hljs-built_in">tostring</span>(row_ver))
    <span class="hljs-keyword">local</span> body = <span class="hljs-literal">nil</span>
    <span class="hljs-keyword">local</span> data = http_client:request(<span class="hljs-string">'GET'</span>, url, body, {<font></font>
        keepalive_idle =  <span class="hljs-number">1</span>,<font></font>
        keepalive_interval = <span class="hljs-number">1</span><font></font>
    })<font></font>
    <span class="hljs-keyword">return</span> json.decode(data.body)
<span class="hljs-keyword">end</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数はurlでHTTPリクエストを実行し、それ</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をパラメーターとして</font><font style="vertical-align: inherit;">渡し</font><font style="vertical-align: inherit;">、リクエストのデシリアライズされた結果を返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
受信したデータを保存する機能は次のとおりです。</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save_goods</span><span class="hljs-params">(goods)</span></span>
    <span class="hljs-keyword">local</span> n = #goods<font></font>
    box.atomic(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n <span class="hljs-keyword">do</span>
            <span class="hljs-keyword">local</span> obj = goods[i]<font></font>
            box.space.goods:put(<font></font>
                obj.id, obj.name, obj.code)<font></font>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スペースにデータを格納するサイクルは</font></font><code>goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、トランザクションに配置され（このために関数が使用されます</font></font><code>box.atomic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、ディスク操作の数を減らします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、ローカル空間</font></font><code>goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とソース</font><font style="vertical-align: inherit;">の同期機能は、</font><font style="vertical-align: inherit;">次のように実装できます。</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sync_goods</span><span class="hljs-params">()</span></span>
    <span class="hljs-keyword">local</span> tuple = box.space.row_ver:get(<span class="hljs-string">'goods'</span>)
    <span class="hljs-keyword">local</span> row_ver = tuple <span class="hljs-keyword">and</span> tuple.value <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><font></font>
<font></font>
    <span class="hljs-comment">-- set your url here:</span>
    <span class="hljs-keyword">local</span> url = <span class="hljs-string">'http://127.0.0.1:81/test/goods/list'</span><font></font>
<font></font>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span>
        <span class="hljs-keyword">local</span> goods = load_goods(url, row_ver)<font></font>
<font></font>
        <span class="hljs-keyword">local</span> count = #goods
        <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">end</span><font></font>
<font></font>
        save_goods(goods)<font></font>
<font></font>
        row_ver = goods[count].rowVer<font></font>
        box.space.row_ver:put({<span class="hljs-string">'goods'</span>, row_ver})
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、以前に保存</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したスペースの</font><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">読み取り</font><font style="vertical-align: inherit;">ます</font></font><code>goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。存在しない場合（最初の交換セッション）は、</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゼロ</font><font style="vertical-align: inherit;">と見なされ</font><font style="vertical-align: inherit;">ます。次に、ループで、変更されたデータをソースから指定されたURLにページ分割します。各反復で、受信したデータを対応するローカルスペースに保存し、値を更新します</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（スペース内</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および変数内</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）- </font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロードされたデータの最後の行から</font><font style="vertical-align: inherit;">値を取得します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
偶発的なループ（プログラムでエラーが発生した場合）から保護するために、サイクル</font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を次のように置き換えることができます</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">for</span> _ = <span class="hljs-number">1</span>, max_req <span class="hljs-keyword">do</span> ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の実行の結果として、</font><font style="vertical-align: inherit;">レシーバー</font><font style="vertical-align: inherit;">の</font></font><code>sync_goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スペース</font></font><code>goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には</font></font><code>goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ソースの</font><font style="vertical-align: inherit;">すべてのスペースレコードの最新バージョンが含まれます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、この方法でデータ削除をブロードキャストすることはできません。そのような必要がある場合は、削除マークを使用できます。</font></font><code>goods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブールフィールド</font><font style="vertical-align: inherit;">をスペースに追加し</font></font><code>is_deleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、レコードを物理的に削除する代わりに、論理削除を使用して、フィールドの</font></font><code>is_deleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値をvalueに</font><font style="vertical-align: inherit;">設定</font><font style="vertical-align: inherit;">します</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ブールフィールドの代わり</font><font style="vertical-align: inherit;">に、レコードの論理削除の日時を格納</font></font><code>is_deleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するフィールドを使用する方が便利な場合があります</font></font><code>deleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。論理的な削除を実行した後、削除のマークが付けられたレコードがソースからレシーバーに転送されます（前述のロジックに従って）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーケンス</font></font><code>row_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他のスペースからデータを転送するために使用できます。送信されたスペースごとに個別のシーケンスを作成する必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantool DBMSを使用するアプリケーションでの高レベルのデータ複製の効果的な方法を検討しました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarantool DBMSは、負荷の高いアプリケーションを作成するための魅力的で有望な製品です。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高レベルのレプリケーションは、低レベルのレプリケーションと比較して、データ転送により柔軟なアプローチを提供します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事で説明した高レベルの複製方法では、最後の交換セッション以降に変更されたレコードのみを転送することにより、転送されるデータの量を最小限に抑えることができます。</font></font><br>
</li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja455132/index.html">骨董品：Philips Velo 1、テクノロジーマニアの悪夢</a></li>
<li><a href="../ja455134/index.html">過去のハイゼンバグで何が記憶され、次に何が起こるのでしょうか？</a></li>
<li><a href="../ja455136/index.html">コーディングをポンピングするだけでは開発者が良くならない理由</a></li>
<li><a href="../ja455138/index.html">ジェットブレインズナイトモスクワ：いかがでしたか</a></li>
<li><a href="../ja455144/index.html">2020年の準備：知っておく必要がある8つのJavaScriptクライアント開発トレンド</a></li>
<li><a href="../ja455148/index.html">データに基づく意思決定タスクを解決します</a></li>
<li><a href="../ja455156/index.html">国内シーケンスのタスク（2019年6月）</a></li>
<li><a href="../ja455158/index.html">会計手法の驚異：減価償却基金</a></li>
<li><a href="../ja455160/index.html">LINQによる全文検索を備えたEntity Framework 6</a></li>
<li><a href="../ja455164/index.html">Elena Balashova：「私たちのGISポータルのデータはOpenStreetMapに開かれているべきだという疑問を提起しました」</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>