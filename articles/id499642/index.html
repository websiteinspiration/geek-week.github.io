<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚 ♟️ 👨🏼‍🏭 Pixockets: bagaimana kami menulis perpustakaan jaringan kami sendiri untuk server game 🎧 👴🏽 💝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo! Connected Stanislav Yablonsky, Pengembang Server Utama Pixonic. 
 
 Ketika saya pertama kali datang ke Pixonic, server permainan kami adalah apl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pixockets: bagaimana kami menulis perpustakaan jaringan kami sendiri untuk server game</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/499642/"><img src="https://habrastorage.org/webt/1m/i0/kx/1mi0kx5zzmixsjdadghss9rpeic.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Halo! Connected Stanislav Yablonsky, Pengembang Server Utama Pixonic. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika saya pertama kali datang ke Pixonic, server permainan kami adalah aplikasi yang didasarkan pada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Photon Realtime SDK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : kerangka kerja multifungsi namun sangat berat. Tampaknya solusi ini adalah menyederhanakan pekerjaan dengan server. Jadi - sampai titik tertentu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Photon Realtime mengikat kami pada dirinya sendiri dengan harus menggunakannya untuk bertukar data antara pemain dan server - dan juga mengikatnya ke Windows, karena itu hanya dapat bekerja di atasnya. Ini memberlakukan batasan pada kami berdua dari sudut pandang runtime (runtime): tidak mungkin untuk mengubah banyak pengaturan penting dari mesin virtual .NET, dan sistem operasi. Kami terbiasa bekerja dengan server Linux, bukan Windows. Selain itu, harganya lebih murah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juga, penggunaan kinerja hit Photon baik di server dan di klien, dan ketika profil, beban yang layak pada pengumpul sampah dan sejumlah besar tinju / unboxing terbentuk.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Singkatnya, solusi dengan Photon Realtime jauh dari optimal bagi kami, dan untuk waktu yang lama diperlukan untuk melakukan sesuatu dengan itu - tetapi selalu ada tugas yang lebih mendesak, dan tangan tidak mencapai solusi masalah dengan server. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena menarik bagi saya tidak hanya untuk menyelesaikan masalah, tetapi juga untuk lebih memahami jaringan, saya memutuskan untuk mengambil inisiatif di tangan saya sendiri dan mencoba menulis perpustakaan sendiri. </font><font style="vertical-align: inherit;">Tetapi, Anda mengerti, di rumah - di rumah, di tempat kerja - di tempat kerja, akibatnya, waktu untuk mengembangkan perpustakaan hanya dalam transportasi. </font><font style="vertical-align: inherit;">Namun, ini tidak menghentikan gagasan untuk membuahkan hasil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang terjadi - baca terus.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ideologi perpustakaan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena kami mengembangkan game online, sangat penting bagi kami untuk bekerja tanpa jeda, sehingga biaya rendah telah menjadi persyaratan utama bagi perpustakaan. Bagi kami, ini adalah, pertama-tama, beban rendah pada pengumpul sampah. Untuk mencapainya, saya mencoba menghindari alokasi, dan dalam kasus di mana sulit untuk mencapai atau tidak berhasil sama sekali, kami membuat kumpulan (untuk buffer byte, status koneksi, header, dll.).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk kesederhanaan dan kenyamanan dukungan dan perakitan, kami mulai menggunakan hanya C # dan soket sistem. Selain itu, penting untuk menyesuaikan dengan anggaran waktu per frame, karena data dari server seharusnya tiba tepat waktu. Oleh karena itu, saya mencoba untuk mengurangi waktu eksekusi, bahkan dengan biaya beberapa ketidak-optimalan: yaitu, di beberapa tempat layak untuk mengganti algoritma yang cepat dan sebagian lebih kompleks dan struktur data dengan yang lebih sederhana dan lebih dapat diprediksi. Misalnya, kami tidak menggunakan antrian bebas kunci, karena mereka membuat beban pada pengumpul sampah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biasanya untuk penembak multipemain, data kami dikirim melalui UDP. Masih di atasnya ditambahkan fragmentasi dan perakitan paket untuk mengirim data dengan ukuran lebih besar dari ukuran bingkai, serta pengiriman yang andal karena meneruskan dan membangun koneksi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bingkai UDP di perpustakaan kami secara default adalah 1200 byte. </font><font style="vertical-align: inherit;">Paket dengan ukuran ini harus ditransmisikan dalam jaringan modern dengan risiko fragmentasi yang cukup rendah, karena MTU di sebagian besar jaringan modern lebih tinggi dari nilai ini. </font><font style="vertical-align: inherit;">Pada saat yang sama, biasanya jumlah ini cukup untuk menyesuaikan dengan perubahan yang perlu dikirim ke pemain setelah centang berikutnya (pembaruan status) dalam permainan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arsitektur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di perpustakaan kami, kami menggunakan soket dua lapis:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lapisan pertama bertanggung jawab untuk bekerja dengan panggilan sistem dan menyediakan API yang lebih nyaman untuk tingkat selanjutnya;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lapisan kedua bekerja langsung dengan sesi, fragmentasi / perakitan paket, penerusannya, dll.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/r_/na/zq/r_nazqva4twkyhnouvkr6dhowek.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas untuk bekerja dengan koneksi, pada gilirannya, juga dibagi menjadi dua tingkatan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level bawah (SockBase) bertanggung jawab untuk mengirim dan menerima data melalui UDP. </font><font style="vertical-align: inherit;">Ini adalah pembungkus tipis di atas objek sistem soket.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level Atas (SmartSock) menyediakan fungsionalitas tambahan di atas UDP. </font><font style="vertical-align: inherit;">Memotong dan menempelkan paket, meneruskan data yang belum mencapai, penolakan duplikat - semua ini adalah bidang tanggung jawabnya.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Level yang lebih rendah dibagi menjadi dua kelas: BareSock dan ThreadSock.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BareSock bekerja di utas yang sama tempat panggilan berasal, mengirim dan menerima data dalam mode non-pemblokiran. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadSock menempatkan paket dalam antrian dan karenanya membuat utas terpisah untuk mengirim dan menerima data. </font><font style="vertical-align: inherit;">Saat mengaksesnya, hanya ada satu operasi: menambah atau menghapus data dari antrian.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BareSock sering digunakan untuk bekerja dengan klien, ThreadSock - dengan server.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur pekerjaan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya juga menulis dua jenis soket tingkat rendah:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang pertama adalah single-threaded sinkron. </font><font style="vertical-align: inherit;">Di dalamnya, kita mendapatkan overhead minimum untuk memori dan prosesor, tetapi pada saat yang sama panggilan sistem terjadi secara langsung ketika mengakses soket. </font><font style="vertical-align: inherit;">Ini meminimalkan overhead secara umum (tidak perlu menggunakan antrian dan buffer tambahan), tetapi panggilan itu sendiri mungkin memakan waktu lebih lama daripada mengambil item dari antrian.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang kedua adalah asinkron dengan utas terpisah untuk membaca dan menulis. </font><font style="vertical-align: inherit;">Dalam hal ini, kami mendapatkan overhead tambahan untuk antrian, sinkronisasi, dan waktu pengiriman / penerimaan (dalam beberapa milidetik), karena pada saat akses ke soket, utas baca atau tulis dijeda.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami juga mencoba menggunakan SocketAsyncEventArgs - mungkin API jaringan paling canggih di .NET yang saya ketahui. Tapi ternyata itu mungkin tidak berfungsi untuk UDP: TCP stack berfungsi dengan baik, tetapi UDP memberikan kesalahan tentang mendapatkan bingkai yang terpotong aneh dan bahkan menabrak. NET - seolah-olah memori di bagian asli mesin virtual rusak. Saya tidak menemukan contoh pengoperasian skema semacam itu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fitur penting lainnya dari perpustakaan kami adalah mengurangi kehilangan data. Kami mendapat kesan bahwa untuk menghilangkan duplikat, banyak perpustakaan membuang paket data lama, seperti yang kemudian kita lihat dari pengalaman kami sendiri. Tentu saja, implementasi seperti itu jauh lebih sederhana, karena dalam kasusnya satu penghitung dengan jumlah frame terakhir tiba sudah cukup, tetapi itu tidak cocok untuk kita. Oleh karena itu, Pixockets menggunakan buffer melingkar dari jumlah frame terakhir untuk memfilter duplikat: angka yang baru tiba ditimpa alih-alih yang lama, dan duplikat dicari di antara frame yang terakhir diterima.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2y/cb/di/2ycbdijeldlgssku0tq5p3e5dmc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, jika suatu paket dikirim sebelum frame saat ini, tetapi datang setelahnya, ia masih akan mencapai tujuan. </font><font style="vertical-align: inherit;">Ini dapat sangat membantu, misalnya, dalam kasus interpolasi posisi. </font><font style="vertical-align: inherit;">Dalam hal ini, kita akan memiliki cerita yang lebih lengkap.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur paket data</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Data di perpustakaan ditransmisikan sebagai berikut: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hw/gc/1j/hwgc1jlbxz5s4ng9h1vrenehqui.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di awal paket adalah header:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dimulai dengan ukuran paket, yang pada gilirannya terbatas pada 64 kilobyte. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ukurannya diikuti oleh byte dengan bendera. </font><font style="vertical-align: inherit;">Interpretasi dari sisa judul tergantung pada ketersediaannya.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikutnya adalah pengidentifikasi untuk sesi atau koneksi. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan bendera yang sesuai, maka kita dapatkan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika bendera dengan nomor paket pada gilirannya diatur, nomor paket ditransmisikan setelah pengidentifikasi sesi. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengikutinya - juga dalam hal set bendera - jumlah paket yang dikonfirmasi dan jumlahnya.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di akhir tajuk terdapat informasi tentang fragmen: </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengidentifikasi urutan fragmen, yang diperlukan untuk membedakan fragmen pesan yang berbeda; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nomor urut fragmen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">total jumlah fragmen dalam pesan. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Informasi tentang fragmen juga memerlukan pengaturan bendera yang sesuai.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perpustakaan ditulis. </font><font style="vertical-align: inherit;">Apa berikutnya?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mendapatkan informasi koneksi sinkron yang lebih akurat, kami kemudian mengatur koneksi eksplisit. Ini membantu kami untuk memahami dengan jelas situasi ketika satu pihak berpikir bahwa koneksi dibuat dan tidak terputus, dan yang lain - bahwa itu terputus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam versi pertama Pixockets, ini bukan: klien tidak perlu memanggil metode Connect (host, port) - itu baru mulai mengirim data ke alamat dan port yang dikenal. Kemudian server memanggil metode Listen (port) dan mulai menerima data dari alamat tertentu. Data sesi diinisialisasi setelah menerima / mengirim paket. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, untuk membuat koneksi, "jabat tangan" telah menjadi penting - pertukaran paket yang dibentuk secara khusus - dan klien harus memanggil Connect.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, salah satu rekan saya bercabang di perpustakaan, lebih memperhatikan keamanan jaringan, dan juga menambahkan beberapa fitur, seperti kemampuan untuk terhubung kembali langsung di dalam soket: misalnya, ketika beralih antara Wi-Fi dan 4G, koneksi sekarang dipulihkan secara otomatis. </font><font style="vertical-align: inherit;">Tapi kita akan membicarakannya nanti.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengujian</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, kami menulis unit test untuk perpustakaan: mereka memeriksa semua cara utama untuk membangun koneksi, mengirim dan menerima data, fragmentasi dan perakitan paket, berbagai anomali dalam mengirim dan menerima data - seperti duplikasi, kehilangan, ketidakcocokan dalam urutan pengiriman dan penerimaan. Untuk pemeriksaan kinerja awal, saya menulis aplikasi pengujian khusus untuk pengujian integrasi: klien ping, server ping dan aplikasi yang menyinkronkan posisi, warna, dan jumlah lingkaran berwarna pada layar melalui jaringan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah aplikasi pengujian membuktikan fungsionalitas perpustakaan kami, kami mulai membandingkannya dengan perpustakaan lain: dengan Photon Realtime lama kami dan dengan perpustakaan UDP LiteNetLib 0.7.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menguji versi sederhana dari server permainan yang hanya mengumpulkan input dari pemain dan mengirimkan kembali hasil "terpaku". Kami mengambil 500 pemain di kamar 6 orang, kecepatan refresh adalah 30 kali per detik. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/e-/1e/fy/e-1efyiufgmkgsifktigenhbil0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beban pada pengumpul sampah dan konsumsi prosesor ternyata lebih rendah dalam kasus Pixockets, serta persentase paket yang hilang - tampaknya karena kenyataan bahwa, tidak seperti versi UDP lainnya, kami tidak mengabaikan paket yang terlambat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah kami menerima konfirmasi tentang keunggulan solusi kami dalam tes sintetis, langkah selanjutnya adalah menjalankan perpustakaan pada proyek nyata.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada saat itu, dalam proyek yang kami pilih, klien dan server game disinkronkan melalui Server Photon. </font><font style="vertical-align: inherit;">Saya menambahkan dukungan Pixockets ke klien dan server, sehingga memungkinkan untuk mengontrol pilihan protokol dari server perjodohan - yang mana klien mengirim permintaan untuk memasuki permainan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk beberapa periode, klien bermain secara bersamaan pada kedua protokol, dan pada saat itu kami mengumpulkan statistik tentang bagaimana mereka melakukannya. </font><font style="vertical-align: inherit;">Pada akhir pengumpulan statistik, ternyata hasilnya tidak berbeda dengan tes sintetik: beban pada pengumpul sampah dan prosesor mengalami penurunan, paket juga hilang. </font><font style="vertical-align: inherit;">Pada saat yang sama, ping menjadi sedikit lebih rendah. </font><font style="vertical-align: inherit;">Oleh karena itu, versi berikutnya dari permainan telah dirilis sepenuhnya pada Pixockets tanpa menggunakan Photon Realtime SDK.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hr/gz/gs/hrgzgsslampwgbbr_u2puvpbhmq.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rencana masa depan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kami ingin mengimplementasikan fitur-fitur berikut di perpustakaan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koneksi yang disederhanakan: sekarang tidak berfungsi secara optimal, dan setelah memanggil Sambungkan pada klien, Anda perlu memanggil Baca sampai status koneksi berubah;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shutdown eksplisit: saat ini, shutdown di sisi lain hanya terjadi oleh timer;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ping bawaan untuk menjaga konektivitas;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penentuan otomatis ukuran frame optimal (sekarang hanya konstanta yang digunakan).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat melihat dan berpartisipasi dalam pengembangan Pixockets lebih lanjut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di alamat repositori.</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id499628/index.html">Wawancara pengembangan: pilih teman</a></li>
<li><a href="../id499630/index.html">Berdebar. Pembaruan Musim Semi 2020</a></li>
<li><a href="../id499632/index.html">Meningkatkan Kualitas Audio Google Duo dengan WaveNetEQ</a></li>
<li><a href="../id499634/index.html">TypeScript Lanjutan</a></li>
<li><a href="../id499636/index.html">Bereaksi Asli untuk anak kecil. Pengalaman Pengembangan Seluler</a></li>
<li><a href="../id499644/index.html">Pembuatan Robot (RPA) dengan Alat AutoTest</a></li>
<li><a href="../id499646/index.html">5 aturan untuk mengintegrasikan UX dalam Agile dan Scrum</a></li>
<li><a href="../id499648/index.html">“Seorang desainer game selalu seorang gamer”: apa yang dilakukan spesialis, keterampilan apa yang penting</a></li>
<li><a href="../id499652/index.html">Apakah ada kehidupan dalam pengembangan setelah dekrit?</a></li>
<li><a href="../id499654/index.html">Bagaimana menerapkan CRM di situs jarak jauh dan menang?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>