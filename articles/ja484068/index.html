<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗺️ 💲 🎻 サービス間通信プロトコルとしてのgRPC。Yandexレポート 🌖 🧙🏼 👱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="gRPCは、リモートプロシージャコール用のオープンソースフレームワークです。 Yandex.Marketでは、gRPCがRESTのより便利な代替手段として使用されています。マーケットパートナー向けのツール開発サービスを運営しているセルゲイフェドセンコフは、JavaとC ++サービス間の統合を構築する...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>サービス間通信プロトコルとしてのgRPC。Yandexレポート</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/484068/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPCは、リモートプロシージャコール用のオープンソースフレームワークです。 Yandex.Marketでは、gRPCがRESTのより便利な代替手段として使用されています。マーケットパートナー向けのツール開発サービスを運営しているセルゲイフェドセンコフは、JavaとC ++サービス間の統合を構築するためのプロトコルとしてgRPCを使用した経験を共有しました。レポートから、RESTの後にgRPCの使用を開始した場合の一般的な問題を回避する方法、エラーを返す方法、トレースを実装する方法、クエリをデバッグする方法、およびクライアント呼び出しをテストする方法を学びます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、レポートの非公式の記録があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-最初に、Yandex.Marketに関するいくつかの事実を紹介します。これらはレポートの一部として役立ちます。最初の事実：私たちはさまざまな言語でサービスを作成します。これは、サービスに対する顧客の要件を課します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、Javaでサービスを提供している場合、彼のクライアントも、たとえばプラスまたは小さいクライアントであるとよいでしょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fk/km/ek/fkkmekzj1zv6uobtlxcypvjb5bq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが持っているすべてのサービスは独立しており、市場全体の計画的な大規模なリリースはありません。マイクロサービスは独立してリリースされ、下位互換性は私たちにとって重要であり、プロトコルはそれをサポートしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目の事実：同期と非同期の両方の統合があります。レポートでは、主に同期について話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何を使用しましたか？もちろん、今回の統合の基礎は、HTTP 1.1を介してXML / JSONを交換するRESTまたはRESTのようなサービスです。 XML-RPCもあります。主にPythonコードと統合するときに使用します。つまり、PythonにはXML-RPCサーバーが組み込まれています。そこにデプロイするのはとても便利で、私たちはそれをサポートしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かつてCORBAがありました。幸い、私たちはそれを拒否しました。現在は主にRESTおよびXML / JSON over HTTPです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mw/we/q6/mwweq653dwqkzn9afcvtqt3temm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同期統合には、既存のプロトコルに関する問題があります。私たちはそのような問題に遭遇し、それらをgRPCで処理しようとします。これらの問題は何ですか？私が言ったように、私は異なる言語で顧客を持ちたいです。彼らがまだ自分で書く必要はないことをお勧めします。そして、一般に、クライアントがサービスのユーザーの目標に応じて、同期と非同期の両方になることができればすばらしいでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、下位互換性を十分にサポートするために使用するプロトコルも必要です。これは、独立した同時リリースでは非常に重要です。すべてのリリースは下位互換性があり、フィードバックを壊すことはありません。破損した場合、これはバグであり、できるだけ早く修正する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラー処理への何らかのバランスのとれたアプローチも必要です。RESTサービスを作成した人なら誰でも、HTTPステータスだけでは使用できないことを知っています。彼らは通常、問題の詳細な説明を許可していません、あなたはそれらのステータスのいくつか、それらの詳細を入力する必要があります。 RESTサービスでは、この方法で作業を変える必要があるたびに、誰もがこれらのエラーの独自の実装を紹介します。これは常に便利なわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、クライアント側でタイムアウトを管理したいと考えています。</font><font style="vertical-align: inherit;">繰り返しますが、HTTPを使用する人は、クライアント側でタイムアウトを設定してタイムアウトになると、クライアントはリクエストが完了するのを待つのを停止しますが、サーバーはそれについて何も知らず、実行し続けることを理解しています。</font><font style="vertical-align: inherit;">さらに、中央には、グローバルタイムアウトを設定するさまざまなプロキシがあります。</font><font style="vertical-align: inherit;">そして、クライアントは単にそれらについて何も知らないかもしれず、それらを構成することは必ずしも簡単ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、ドキュメントの問題です。</font><font style="vertical-align: inherit;">RESTリソースまたは一部のメソッドのドキュメントをどこで取得するか、それらが受け入れるパラメーター、転送できる本文、およびこのドキュメントをサービスのコンシューマーと通信する方法は必ずしも明確ではありません。</font><font style="vertical-align: inherit;">Swaggerがあることは明らかですが、それでも、すべてが簡単なわけではありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPC </font><font style="vertical-align: inherit;">理論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gRPCの理論的な部分についてお話ししたいと思います。そして、練習に移ります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4t/ly/cn/4tlycnzym8eeecxp8_-j2fwedwe.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、gRPCは抽象的な仕様です。抽象RPC（リモートプロシージャコール）、つまり、特定のプロパティを持つリモートプロシージャコールについて説明します。次に、それらをリストします。最初のプロパティは、シングルコールとストリーミングの両方をサポートすることです。つまり、この仕様を実装するすべてのサービスが両方のオプションをサポートします。次の項目は、メタデータの可用性です。つまり、ペイロードとともに、ある種のメタデータ（条件付きでヘッダー）を渡すことができます。そして-要求をキャンセルするためのサポートとデフォルトのタイムアウト。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、メッセージおよびサービス自体の説明は、特定のインターフェイス定義言語（IDL）を介して実行されることを前提としています。この仕様では、HTTP / 2を介したワイヤープロトコルについても説明しています。つまり、gRPCはHTTP / 2を介してのみ機能すると想定しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/e0/s9/5n/e0s95ncgptmoczazqnei0yns3b4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合に使用される典型的なgRPC実装があります。私達もそれを使用し、今それを見るでしょう。 IDLとしてproto形式が使用されます。プロトコンパイラのgRPCプラグインを使用すると、プロト記述から生成されたサービスのソースを取得できます。そして、さまざまな言語のランタイムライブラリがあります-Java、C ++、Python。一般的に、ほとんどすべての一般的な言語がサポートされており、ランタイムライブラリが存在します。そして、サービス間で交換されるメッセージとして、protobufスキームに従って様式化されたメッセージであるprotoメッセージが使用されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wy/zp/bh/wyzpbhu3uhozqntsux32nyvpejw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の機能について少し詳しく説明します。どうぞ。強い型付け、つまりプロトメッセージは、強く型付けされたメッセージです。かつてprotobufを使用したことがある人は、メッセージのフィールドを型で記述できることを知っています。タイプには、プリミティブと文字列の両方のバイト配列があります。それらはスカラーでも、ベクトルでもかまいません。実際、メッセージにはフィールドとして他のメッセージを含めることができます。これは非常に便利です。一般に、任意のモデルを表すことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/29/oz/e6/29oze6gv_s9vazqemxztvqyrrbs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下位互換性について。プロトIDLは、下位互換性が箱から出された形式であること、つまり、下位互換性のバックログが考案された形式であり、Googleはproto3のバージョンをリリースしました。これにより、proto2と比較して、下位互換性がさらに向上します。加えて、いくつかの重要な場合に下位互換性が維持されるように、あらゆる種類の仕様、変更方法、変更内容があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルト値の可能性があり、新しいフィールドを追加でき、ユーザーは何も変更する必要がありません。 proto3のすべてのフィールドはオプションであり、たとえば削除することができ、リモートフィールドにアクセスしてもクライアントでエラーが発生することはありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dl/ws/kh/dlwskhpcodspqbqkwe-q1ihxaas.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つのgRPC機能は、クライアントとサーバーがプロトコンパイラーとプロト記述に基づくgRPCプラグインを使用して生成されることです。コードの作成時に、使用するクライアントを選択する可能性があります。つまり、記述するコードの種類に応じて、非同期または同期のクライアントを選択します。たとえば、非同期クライアントはリアクティブコードに非常に適しています。そして、この機会はあらゆる言語のためのものです。つまり、プロトタイプの記述を作成すると、その後、任意の言語のクライアントを生成でき、何らかの方法でそれらを個別に開発する必要がなくなります。サービスのインターフェイスは、プロトタイプの形で簡単に配布できます。すべての消費者が自分用のクライアントを生成できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ny/at/qr/nyatqr7l4jcnnxrzwudubg0u_wc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエストのキャンセルと締め切りについて、リクエストはサーバー上でもクライアント上でもキャンセルできることにご注意ください。すべてがわかっている場合は、リクエストをさらに処理する必要はなく、キャンセルできます。リクエストに応じてタイムアウトを設定することが可能です。 gRPCでは、ほとんどのランタイムライブラリは、タイムアウトの概念として期限を使用します。しかし、実際には同じです。つまり、これは要求が完了する必要がある時間です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、最も興味深いのは、サーバーがリクエストのキャンセルとタイムアウトの期限切れの両方を検出し、その側でリクエストの実行を停止できることです。これはすごくかっこいいです。他にはほとんどないようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドキュメントについては、gRPCのIDLでproto形式が使用されているため、これは通常のコードであることに注意したいと思います。</font><font style="vertical-align: inherit;">そこでは、非常に詳細なコメントを含むコメントを書くことができます。</font><font style="vertical-align: inherit;">そして、あなたはあなたのサービスと統合するために、あなたのユーザーが彼らの家にこのプロトフォーマットを持っている必要があることを理解する必要があります。</font><font style="vertical-align: inherit;">とても快適です。</font><font style="vertical-align: inherit;">そして、この説明を拡張することができます。つまり、ドキュメントがコードの隣に来るという便利な機能であり、javadocまたはその他のコメントの形式でメソッドの隣に置くことができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPC単項呼び出し。</font><font style="vertical-align: inherit;">練習</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少し練習してみましょう。そして、gRPCを使用する最も基本的な例は、いわゆる単項呼び出しまたは単一呼び出しです。これは古典的なスキームです-サーバーにリクエストを送信し、サーバーから1つの応答を取得します。これがHTTPでどのように機能するかを示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dd/lh/kd/ddlhkdqueihh4_s65obi4t9qxns.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが行っているエコーサービスの例を考えてみましょう。サーバーはプラスで、クライアントはJavaで記述されます。ここでは古典的な平衡回路が使用されました。つまり、クライアントはバランサーをアドレス指定し、バランサーは要求を処理するための特定のバックエンドをすでに選択しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意を払いたかった-gRPCはHTTP / 2で動作するため、1つのTCP接続が使用されます。さらに、さまざまなストリームが通過します。ここで、クライアントとバランサー間の接続が一度確立され、永続的なままであることがわかります。その後、バランサーは各呼び出しの異なるバックエンドの負荷を分散します。見てみると、こういうふうに、メッセージが配信されているとこうなります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yc/tn/fe/yctnfe9-06tb1-en3lvbxlmqbsu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがprotoファイルのサンプルコードです。最初にメッセージについて説明しています。つまり、EchoRequestとEchoResponseがあります。メッセージを格納する文字列フィールドは1つだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のステップでは、手順を説明します。入力プロシージャはEchoRequestを受け入れ、結果としてEchoResponseを返します。すべては非常に簡単です。これは、追跡されるgRPCサービスとメッセージの説明です。</font></font><br>
 <br>
 <br>
<img src="https://habrastorage.org/webt/yo/ti/mi/yotimiyugzrzit8vy2xdfn-yely.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、プラスの場合にこれがどのように行われるかを見てみましょう。 3段階で組み立てられます。最初の段階では、メッセージソースを生成します。ここでは、このチームでこれを行っています。 protoコンパイラを呼び出し、proto-fileを入力に渡し、出力ファイルを配置する場所を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のチーム。また、同じ方法でサービスを生成します。前のコマンドとの唯一の違いは、プラグインを渡し、プロトフォーマットの説明に基づいてサービスを生成することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目のステップ-サーバーを起動できるように、これらすべてを1つのバイナリに収集します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追加のフラグがここでリンカーに渡されます。これはgrpc ++ _リフレクションと呼ばれます。注意したいのですが、gRPCサーバーには、サーバーリフレクションという機能があります。これにより、サービスの種類、RPC呼び出し、サービスのメッセージを調べることができます。デフォルトではオフになっており、手元にあるプロトフォーマットでのみサービスにアクセスできます。しかし、たとえば、デバッグの場合、プロトフォーマットを用意せずに、リフレクション機能を備えたサーバーをオンにして情報をすぐに受信するだけで非常に便利です。</font></font><br>
 <br>
 <br>
<img src="https://habrastorage.org/webt/yl/h-/fw/ylh-fw1j3sykaipf5_4c3zvvhgi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、実装を見てみましょう。実装も最小限です。つまり、主なタスクは、生成されたエコーサービスを実装することです。 getEchoメソッドが1つあります。メッセージを生成して送り返すだけです。ステータスOK-成功ステータス。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ServerBuilderを作成し、その中にサービスを登録します。</font></font><br>
 <br>
 <br>
<img src="https://habrastorage.org/webt/u8/6l/yz/u86lyzlselt_gi1khgl7l5umzw8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、リクエストを開始して待機するだけです。</font></font><br>
 <br>
 <br>
<img src="https://habrastorage.org/webt/bd/v9/bl/bdv9blqsyc3gbw-atarolnny0ha.jpeg"><br>
 <br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Javaでクライアントを見てみましょう。グラドルを回収します。私たちの仕事は、最初にprotobufプラグインを接続することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービスのためにドラッグする必要がある依存関係の基本的なセットがあり、それらはコンパイル段階で必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ランタイムライブラリがあることにも注意してください。 Javaの場合、サーバーおよびクライアントとしてnettyを使用し、HTTP / 2をサポートし、非常に便利で高性能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、protoコンパイラーを構成します。 Javaの場合、コンパイラー自体をローカルにインストールする必要はなく、アーティファクトから取得できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラグインでも同じことが言えます。ローカルのJavaの場合は必要ありません。アーティファクトをドラッグできます。また、すべてのショックに対してスタブが生成されるように呼び出されるように、単純に構成することが重要です。</font></font><br>
 <br>
 <br>
<img src="https://habrastorage.org/webt/iu/n7/v6/iun7v66-lubn0f1qrwb1napvw6s.jpeg"><br>
 <br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaコードに移りましょう。ここでは、最初にサービスのスタブを作成します。それは、Javaがチャネルを提供するという私たちの仕事です。ランタイムライブラリには、このチャネルを構築できるChannelBuilderがあります。ここでは簡単にするためにプレーンテキストを手動でオンにしていますが、HTTP2とgRPCはデフォルトですべてを暗号化し、TLSを使用しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントのスタブがあり、同期クライアントがここで生成されます。同様に、非同期クライアントを生成できます。他のオプションがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、protobuffリクエストを作成します。つまり、protobuffメッセージを作成します。</font></font><br>
 <br>
 <br>
<img src="https://habrastorage.org/webt/kn/qo/1u/knqo1uengqboh-vagqyfyipqvrs.jpeg"><br>
 <br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで完了です。クライアントでgetEchoを呼び出して結果を出力します。</font><font style="vertical-align: inherit;">すべてが簡単です。</font><font style="vertical-align: inherit;">ご覧のとおり、かなりのコードが必要で、統合が構築されています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPCストリーミング。</font><font style="vertical-align: inherit;">練習</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、より高度なものを見てみましょう。これはストリーミングです。</font><font style="vertical-align: inherit;">それがどのように機能するかを後で説明し、後でそれを使用する方法を説明します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ly/pu/15/lypu157vtebmx4q8sw11d70gemo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリーミングクライアントサーバーのアーキテクチャは似ています。つまり、クライアントとバランサーの間には永続的な接続があります。次に、違いが始まります。ストリーミングの本質は、クライアントが最終的なバックエンドに接続され、接続が保存されることです。つまり、このようになります。など。ここで、バランサーの使用はストリーミングでは一般的ではないことに注意してください。つまり、ストリーミングリクエストは非常に長持ちする可能性があることを理解する必要があります。つまり、それらを開いてメッセージを長期間交換することができます。そして、これらのメッセージはバランサーを通過しますが、実際には、常に同じバックエンドに送信されます。そして、なぜそれが必要なのかははっきりしていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的な方法は、たとえば、サービスが純粋にストリーミングしている場合、または主にストリーミングしている場合に、サービス検出が使用されます。 GRPCには、サービスディスカバリを埋め込むことができる拡張ポイントがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dm/5f/lq/dm5flqilbfrmpdwlz-xi-0dn9nw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリーミングサービスを実装するには何が必要ですか？同じプロトフォーマットがあります。別のRPCを追加しています。ここでは、リクエストの前とレスポンスの前に2つのキーワードが追加されています。したがって、EchoRequestおよびEchoResponseストリームを宣言します。</font></font><br>
 <br>
<br>
<img src="https://habrastorage.org/webt/y7/ji/8i/y7ji8idykqbfsumuuj91t1fwwde.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より興味深いものが始まります。ストリーミングサービスが実行するために、コンパイルは変更されません。次のタスクは、ストリームで動作するEchoサービスの新しいメソッドをオーバーライドすることです。サーバーの場合、これはすべてやや簡単です。つまり、常にストリームから読み取ることができ、何かに答えることができます。非同期で応答できます。つまり、これらは独立しており、書き込みストリームと読み取りストリームであり、ここではすべてが単純なシナリオでは単純です。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/vv/ih/as/vvihasd7g8s9s8jfxte2lgdkae0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが今の読みです、これが録音です。</font></font><br>
 <br>
<br>
<img src="https://habrastorage.org/webt/v_/rb/l_/v_rbl_m4pyxndxrkveev_ibze2q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaクライアントでは、物事はもう少し複雑です。そこで同期APIを使用することはできません。つまり、ストリームでは機能しません。そして非同期APIが使用されます。つまり、私たちの仕事はObserverパターンを実装することです。 StreamObserverインターフェイスがあります。これには、onNext、onCompleted、onErrorの3つのメソッドが含まれています。ここでは、簡単にするために、onNextのみを実装しました。サーバーから答えが来たときだけ、それはけいれんします。</font></font><br>
 <br>
<br>
<img src="https://habrastorage.org/webt/o5/ma/2r/o5ma2rsuawum-empf1enylvayos.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、スレッド間のメッセージングのキューに入れます。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/wt/pu/zd/wtpuzdzh5dlmkgdxqpkieddlegg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
違いは何ですか？ blockingStubの代わりに、単にnewStubを作成します。これは、Observerでのみ機能する非同期実装です。実際、オブザーバーで単項呼び出しを行うことができますが、それほど便利ではありません。少なくとも、それほど積極的には使用していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、オブザーバーを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、RPC呼び出しを行います。 ResponseObserverを入力に渡し、出力でRequestObserverを発行します。さらに、RequestObserverを呼び出して、サーバーにメッセージを送信できます。そして、ResponseObserverはメッセージをひねって処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここに例があります。ただ電話をしているだけです。 onNextを呼び出し、リクエストをそこに渡します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キューからさらに、サーバーが応答して印刷するのを待ちます。</font></font><br>
 <br>
 <br>
<img src="https://habrastorage.org/webt/bg/ta/hq/bgtahqaqbyqbzp72lhix4tzsmii.jpeg"><br>
 <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの私たちのタスクは、ストリーミングの実装を担当する人々として、このRequestObserverのクローズを正しく処理することであるという事実に注目したいと思います。つまり、エラーが発生した場合は、onErrorメソッドを呼び出す必要があります。正常に完了した場合は、ストリームを閉じることができると思われる場合は、onCompletedメソッドを呼び出す必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/js/4a/ze/js4aze1vr9sb4t9clbpq0obdywy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先に進みます。ストリーミングアプリケーションとは何ですか？これはより高度なものであり、すべての人に直接役立つわけではありませんが、使用されることがあります。つまり、1つ目は、大量のデータをダウンロードしてアップロードすることです。サーバーまたはクライアントは、一部のデータを生成できます。これらの部分はすでに何らかの形でクライアントまたはサーバーにグループ化されている場合があります。つまり、ここですでに追加の最適化を行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ストリーミングスキームはサーバープッシュに適しています。双方向ストリーミングがある場合、私が最も極端なオプションを検討したことを理解する必要があります。そして多分一方向にストリーミングします。たとえば、クライアントからサーバーへ、またはサーバーからクライアントへ。サーバーからクライアントへの場合、サーバーに接続することができ、それは私たちにプッシュを送信します。これのために定期的にポーリングする必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリーミングの次の利点は、1台のマシンにバインドすることです。すでに述べたように、ストリーム内のすべてのメッセージに対して1つのエンドツーエンド接続が確立され、この接続は1つのマシンに結び付けられ、どこにも切り替わりません。したがって、まず、何か、ある種のサーバー間同期を単純化することが可能です。さらに、トランザクション処理を行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、私が示した例の1つである双方向ストリーミングは、ある種の独自のプロトコルを構築する機能です。</font><font style="vertical-align: inherit;">十分興味深いものです。</font><font style="vertical-align: inherit;">Yandexには、双方向ストリーミングのみを使用する内部キューがあります。</font><font style="vertical-align: inherit;">そして、突然誰かがそのような仕事をしているなら、それを使う十分な機会です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私も注目したいのですが、メタデータについては前に話しました。</font><font style="vertical-align: inherit;">また、ストリーミングでは、メタデータはストリームの最初と最後にのみ送信されます。</font><font style="vertical-align: inherit;">つまり、各メッセージの前と各メッセージの後には送信されません。</font><font style="vertical-align: inherit;">したがって、各メッセージで飛ぶメタデータに関するタスクがある場合は、すでに自分で解決する必要があります。</font><font style="vertical-align: inherit;">しかし、これらは単なるプロトコルです。</font><font style="vertical-align: inherit;">ここでは、gRPCをトランスポートとして使用できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">典型的なタスク</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gRPCで典型的なタスクがどのように解決されるかを見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wl/un/lo/wlunloh9hz1t6cklr4zaqzketmm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラー処理について、問題があると言いました。なんとかして統一したいです。そして、gRPCには統一へのアプローチがあります。もちろん課せられているわけではありませんが、一般的には使うのがいいでしょう。まず、ランタイムライブラリの応答コードは標準です。こちらがステータスで、使用可能です。これらのステータスには、OKステータスなどの一連の定数があり、これらは非常にうまく機能し、ランタイムライブラリでサポートされています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、Javaの場合、誤ったステータスの場合にエラーがスローされます。プラスの場合、ステータスは単に関数呼び出しを行った結果であり、それに応じて確認して動作を続けることができます。 google.rpc.Statusには、応答コード、メッセージ、詳細の3つのフィールドがあります。使用できる応答コードの標準セットがあります。メッセージフィールドでは、ローカライズされていないメッセージを記述するだけで問題に対処できます。詳細は、バイナリオブジェクトを含むカスタムオブジェクトを転送できるベクトルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、使用できる既製のエラーの詳細のセットがあり、それらはすでに解決されています。落とし穴があります。たとえば、内部デバイス（スタックトレースなど）がこれらの内部の詳細に表示されないようにします。何をどのように使用するかについての推奨事項があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは理にかなった質問です-コードがあり、HTTPにもコードがありますが、それらはどのように違うのですか実際、それらはそれほど違いはありません。同様に、BadRequestなどがあります。ただし、コードを送信する必要のある特定のエラーの詳細にマップする方法が明確に推奨されていることを理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストレートテーブルがあります。条件付きで、BadRequestまたは何か他のもの（コードのセット全体が存在する）を返す場合は、そのようなエラー詳細を使用してください。そして、このテーブルを自分で印刷し、吊るして、その都度ホイールを作り直すのではなく、標準的なものを採用することができます。そして誰もが誰が何を使うかを理解するでしょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dk/dn/zl/dkdnzlcnav_kpnc7e29mv7j5hqa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的なタスクには、クエリのトレースが含まれます。問題について説明します。たとえば、マイクロサービスアーキテクチャでは、フロントコールが行われると、数十のサービスが呼び出されることがよくあります。そして、どこかで問題が発生した場合、または何かが減速した場合、何が起こっているのかを理解するのはそれほど速くありません。そして、これらの問題を解決するための痕跡があります。 Zipkinなどのオープンソースソリューション。そしてもちろん、HTTPでは、ヘッダーを介して、ここではメタデータを介してサポートされます。これは、トレース属性をトレースおよび格納するのに適した場所です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メタデータの属性は、文字列またはバイナリのいずれかです。トレースの場合は、文字列を使用する方が簡単です。デバッグに使用するクライアントに突然入った場合は、追加でバイナリを逆シリアル化するよりも、行を読み取る方が簡単だからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ランタイムライブラリでのインターセプターのサポート、つまりインターセプターを介してこのメ​​タデータを透過的にビジネスロジックに埋め込む機能は、非常に便利です。 Javaの場合、これらはClientInterceptorおよびServerInterceptorです。プラスについては、長い名前があります、私は読みません。プロのための唯一のことは、それらがまだ実験的な機能にあることに注意したいのですが、それらがいつか切り取られるとは思いません。おそらくAPIが多少変更されるでしょう。そして実際は、トレースに加えて、インターセプターはもちろん、ある種の認証に使用されます。つまり、gRPCには組み込みの認証がありますが、それはすべての人に適しているわけではありません。そして、インターセプターなしでそれを行う方法はないので、それがどういうわけか切り取られて、おそらく開発される可能性は低いです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fy/8u/iz/fy8uiztm6gwxntcvzc8m0qdcply.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単体テストについても個別に話したかった。単体テストには十分なサポートがあります。 Javaの例を書きました。チャネルとサーバーのスタブを作成することは可能であり、それらに基づいて、すでにサービスを生成しています。つまり、単体テストでは、すべてが問題ありません。他に何も発明する必要はありません。既製のソリューションがすでにあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sb/zx/th/sbzxthmnnf_fh8iyxl9ghv02s4y.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
典型的な質問。 gRPCはバイナリプロトコルのようです。 HTTP / 2および一般的に。どういうわけかそれをデバッグして何が起こっているのか理解できますか？同じ典型的な答え：はい、できます。すでにいくつかのツールがあります。まず、gRPCの提供に伴い、curlに類似したgrpc_cliツールが登場します。非常にシンプルですが、あらゆる課題に挑戦できます。私の意見では、ストリーミングも可能です。そして、最も便利なことに、ローカルマシンにgRPCをインストールした場合、箱から出してすぐに使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エヴァンスのようなより魅力的なものがあります。私は試してみましたが、これはそのようなインタラクティブなCLIです。プロトバフメッセージを入力するとヒントが表示され、すぐにどのフィールドに書き込むかがわかります。一般的に、よりインタラクティブです。一部のスクリプトには適していない可能性がありますが、私はそれを使用できます。悪くはありません。試してみました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえばPostmanに使用されているUIが必要な場合は、BloomRPCがあります。視覚的にはPostmanとよく似ています。しかし、もちろん、ポストマンはもっとクールです、彼はずっと長く発達しました。それにもかかわらず、BloomRPCは悪くない、それは基本的な機能を実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは私が試したいくつかの基本的なツールです。もちろん、実際には、主にgrpc_cliを使用します。レポートの準備のためにすでに試した他の2つのツール。しかし、一般的にはもっとたくさんあります。見てみたいという方にも是非お勧めです。次に、既知のすべての顧客のリストを表示できるページへのリンクがあります。たぶん誰かがより良いものを見つけるでしょう。あなたがより良いと思うなら-書いてください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7y/oe/w3/7yoew3fwgydkvdgiaxm1acueyki.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、業界は止まっておらず、gRPCに代わるものがあります。これらの代替案について詳しくお話ししたいと思います。それらのいくつかを試しましたが、いくつかは準備中に見つけました。短剣があります。おそらく、HTTP / 1の場合が最も成熟したものです。 OpenAPI形式でプロトコルを記述し、それに基づいて、同じ方法でクライアントを生成することができます。クライアントは、さまざまな言語用に生成することもできます。インフラストラクチャがまだHTTP / 2に対応していない場合は、Swaggerが最適なソリューションのようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WSDLは古典的です。それも使用されます。彼女は彼女のアイデアにおいてSwaggerに非常に似ていますが、それほど誇大宣伝ではなく、それほど流行りではありません。しかし、一般的に使用されます。私はかつて使用していました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、異なる言語間でサービスを構築する必要がない人のために、Javaでうまく機能するJAX-RSがあります。使用することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Twirpについては別途触れておきます。それは何ですか？ドキュメントから理解できるように、これはGo専用です。私はそれを使用したことがありません。 Goを書いている人がgRPCからTwirpに切り替えたことを知っています。アイデアは何ですか？ gRPCは、たとえばどのIDLを使用するかを指定しない、かなり抽象的なものだと私は言いました。同様に、proto形式では、gRPCサービスのみを生成できることを指定していません。 protoc用の独自のプラグインを記述して、任意の言語、任意のテクノロジーでサービスを生成し、任意の方法で交換することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてTwirpはこのアイデアを使用しています。それらはプロトフォーマットを取り、それに基づいて、HTTP / 1.1で動作し、バイナリとJSONの両方を交換するサービスを生成します。このアイデアは新しいものではなく、TwirpがGoのオープンソースに取り入れただけです。そして私たちにもそのようなアイデアがあり、JavaがJettyに基づいてそのようなクライアントを生成するプラグインの実装があります。正常に動作するようですが、制限があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fn/p3/bi/fnp3bihwdt68ttten4_mpx7qal4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのような結論を導きたいですか？ gRPCは、RESTに代わる新しいサービスです。インフラストラクチャが許可する場合は、管理者に、たとえば、HTTP / 2バランサーを使用することに同意できます。または、使用できるサービス検出があります。 gRPCは良いです、それはかなり古いです。私たちはアップグレードを生き延びました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gRPCデバッグツールに関しては、インフラストラクチャは若いですが、準備ができています。 CLIとUIの両方があります。コミュニティの成長に伴って改善されることは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、gRPCの使用を開始する方法の良い例があります。これはプロセス間通信です。たとえば、サイドカーパターン。これは、ロジックの一部を別のアプリケーションに取り込むアプローチです。同じマシンで実行されますが、別のプロセスで実行されます。たとえば、これらはさまざまな監視エージェントです。メトリックを外部システムに送信して、これらのメトリックをアプリケーションからこのシステムに直接書き込まないようにする場合は、モニタリングエージェントに書き込みます。そのアルゴリズムによれば、それらを非同期にグループ化し、外部システムに送信できます。たとえば、ログがファイルシステム上にない場合でも、ログはまったく同じアプローチですが、キューにプルされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、このエージェントとのコミュニケーションのタスクが発生します。また、gRPCは非常に優れたツールです。まず、持続的な接続。ストリーミングコールと単項コールの両方を使用できます。会社にそのようなタスクがある場合は、このプロトコルを試すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここに有用なリソースがあります：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">-gRPC自体</font></a></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウェブサイト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -多くのチュートリアル、入門があります。あなたが始めることができ、読むことができる便利なサイト、さまざまな言語の例があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">素晴らしいgRPC-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまなリソースへのリンクのコレクションを含むGitHubのカブ。すべてのクライアントの説明、さまざまな言語へのアプローチ、一連の外部レポート、スライドがあります。クール。あなたがそれを使いたいなら、私はそれを強くお勧めします、私はそれが好きでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数枚のスライドで、インターネット上の他の多くのリソースを見つけることができます。</font><font style="vertical-align: inherit;">しかし、私はこれらが最も好きでした。</font><font style="vertical-align: inherit;">プレゼンテーションから少し変更されたコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">感謝！</font></font><br>
<br>
<a name="video1"></a><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非公式レポートの記録</font></font></b><div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/AciUs4Yq7oU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja484050/index.html">PVS-StudioアナライザーによるEmbyソースコード分析</a></li>
<li><a href="../ja484052/index.html">月面基地のタスク</a></li>
<li><a href="../ja484056/index.html">プロジェクトのテストが本当に必要ですか？</a></li>
<li><a href="../ja484062/index.html">MEMASICSによる英語学習</a></li>
<li><a href="../ja484066/index.html">お金対チーム。起業家、創設者、投資家の関係の最も明白な側面ではありません</a></li>
<li><a href="../ja484070/index.html">不正防止システムを4つの手と3つの頭でどのように記述したか</a></li>
<li><a href="../ja484072/index.html">5. Fortinet Getting Started v6.0。NAT</a></li>
<li><a href="../ja484076/index.html">暗号通貨を保管する場所：さまざまな国での暗号通貨の課税</a></li>
<li><a href="../ja484084/index.html">1C-Bitrixとその導入の試み</a></li>
<li><a href="../ja484088/index.html">パスワードヒットパレード（リークからの50億までのパスワードの分析）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>