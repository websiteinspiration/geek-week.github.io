<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❕ 🤔 👨‍👦‍👦 PWA的力量：具有300行神经网络JS代码的视频监视系统 🚣🏿 🏹 👴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！
 
 Web浏览器缓慢但确实实现了操作系统的大多数功能，如果您可以编写Web版本（PWA），则开发本机应用程序的理由就越来越少。跨平台，丰富的API，在TS / JS上的高开发速度以及V8引擎的性能都是加号。浏览器长期以来一直能够处理视频流并运行神经网络，也就是说，我们拥有用于创建具有对象...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PWA的力量：具有300行神经网络JS代码的视频监视系统</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492006/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈Ha！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Web浏览器缓慢但确实</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了操作系统的大多数功能，如果您可以编写Web版本（PWA），则开发本机应用程序的理由就越来越少。跨平台，丰富的API，在TS / JS上的高开发速度以及V8引擎的性能都是加号。浏览器长期以来一直能够处理视频流并运行神经网络，也就是说，我们拥有用于创建具有对象识别功能的视频监视系统的所有组件。受</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启发</font><font style="vertical-align: inherit;">，我决定将演示带到实际应用中，我想分享一下。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该应用程序记录来自摄像机的视频，并定期发送帧以在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">COCO-SSD中</font></a><font style="vertical-align: inherit;">进行识别</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果检测到人，则视频片段将在7秒内开始通过Gmail-API发送到指定的电子邮件。与成人系统一样，将执行预记录，也就是说，我们保存一个片段直到检测到，所有片段都被检测到，再保存一个。如果Internet不可用，或者发送时发生错误，则视频将保存在本地的Downloads文件夹中。使用电子邮件使您无需服务器端即可完成操作，立即通知所有者，如果攻击者拥有了该设备并破解了所有密码，它将无法从收件人那里删除邮件。缺点-由于Base64而导致流量超支（尽管对于一台摄像机来说已经足够了），并且需要从许多电子邮件中收集最终的视频文件。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作演示在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
遇到的问题如下：</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1）神经网络给处理器带来了沉重的负担，如果您在主线程中运行它，视频中会出现延迟。因此，尽管这里并不是所有事情都很顺利，但是识别是放在单独的线程（工作人员）中的。在双核史前Linux上，一切都是完全并行的，但是在一些相当新的4核移动电话上-在识别的瞬间（在工作环境中），主线程也开始滞后，这在用户界面中很明显。幸运的是，尽管它降低了识别频率（它会自动适应负载），但不会影响视频质量。此问题可能与不同版本的Android如何按核心分配线程，SIMD的存在，可用的视频卡功能等有关。我自己无法解决问题，我不了解TensorFlow的内幕，我将不胜感激。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2）FireFox。</font><font style="vertical-align: inherit;">该应用程序在Chrome / Chromium / Edge下可以正常运行，但是，在FireFox中的识别速度明显慢，此外，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImageCapture</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仍未实现</font><font style="vertical-align: inherit;">（当然，可以通过捕获&lt;video&gt;的帧来绕过它，但这</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">对于Fox</font></a><font style="vertical-align: inherit;">来说</font><font style="vertical-align: inherit;">很遗憾，因为它是标准的API）。</font><font style="vertical-align: inherit;">通常，也没有完全的跨浏览器可访问性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，一切都井井有条。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取相机和麦克风</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.video = <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'video'</span>)
<span class="hljs-keyword">this</span>.canvas = <span class="hljs-keyword">this</span>.querySelectorAll(<span class="hljs-string">'canvas'</span>)[<span class="hljs-number">0</span>]<font></font>
<font></font>
<span class="hljs-keyword">this</span>.stream = <span class="hljs-keyword">await</span> navigator.mediaDevices.getUserMedia(<font></font>
   {<span class="hljs-attr">video</span>: {<span class="hljs-attr">facingMode</span>: {<span class="hljs-attr">ideal</span>: <span class="hljs-string">"environment"</span>}}, <span class="hljs-attr">audio</span>: <span class="hljs-literal">true</span>}<font></font>
)<font></font>
<span class="hljs-keyword">this</span>.video.srcObject = <span class="hljs-keyword">this</span>.stream
<span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
   <span class="hljs-keyword">this</span>.video.onloadedmetadata = <span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> resolve()<font></font>
})<font></font>
<span class="hljs-keyword">this</span>.W = <span class="hljs-keyword">this</span>.bbox.width = <span class="hljs-keyword">this</span>.canvas.width = <span class="hljs-keyword">this</span>.video.videoWidth
<span class="hljs-keyword">this</span>.H = <span class="hljs-keyword">this</span>.bbox.height = <span class="hljs-keyword">this</span>.canvas.height = <span class="hljs-keyword">this</span>.video.videoHeight
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们选择手机/平板电脑（或计算机/笔记本电脑上的第一个）的主摄像头，在标准视频播放器中显示流，然后等待元数据加载并设置服务画布的尺寸。</font><font style="vertical-align: inherit;">由于整个应用程序都是以async / await的方式编写的，因此您必须将回调API（并且有很多）转换为Promise以获得一致性。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频截取</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有两种捕获视频的方法。</font><font style="vertical-align: inherit;">第一种是直接从传入流中读取帧，将其显示在画布上，对其进行修改（例如，添加地理和时间戳记），然后从画布中获取数据-将记录器作为传出流，将神经网络作为单独的图像。</font><font style="vertical-align: inherit;">在这种情况下，您可以不使用&lt;video&gt;元素。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.capture = <span class="hljs-keyword">new</span> ImageCapture(<span class="hljs-keyword">this</span>.stream.getVideoTracks()[<span class="hljs-number">0</span>])
<span class="hljs-keyword">this</span>.recorder = <span class="hljs-keyword">new</span> MediaRecorder(<span class="hljs-keyword">this</span>.canvas.captureStream(), {<span class="hljs-attr">mimeType</span> : <span class="hljs-string">"video/webm"</span>})<font></font>
<font></font>
grab_video()<font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grab_video</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">this</span>.canvas.drawImage(<span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.capture.grabFrame(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">const</span> img = <span class="hljs-keyword">this</span>.canvas.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.W, <span class="hljs-keyword">this</span>.H)<font></font>
	... <span class="hljs-comment">//    -   img</span>
	... <span class="hljs-comment">//   -    </span>
        <span class="hljs-built_in">window</span>.requestAnimationFrame(<span class="hljs-keyword">this</span>.grab_video.bind(<span class="hljs-keyword">this</span>))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二种方法（在FF中工作）是使用标准视频播放器进行捕获。</font><font style="vertical-align: inherit;">顺便说一下，与在画布上逐帧显示不同，它消耗的处理器时间更少，但是我们无法添加题词。</font></font><br>
<br>
<pre><code class="javascript hljs">...<font></font>
async <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grab_video</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">this</span>.canvas.drawImage(<span class="hljs-keyword">this</span>.video, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
	...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该应用程序使用第一个选项，因此可以在识别过程中关闭视频播放器。</font><font style="vertical-align: inherit;">为了节省处理器，从输入流中进行记录，并且画布上的绘图帧仅用于获得神经网络的像素阵列，其频率取决于识别速度。</font><font style="vertical-align: inherit;">我们在放置在播放器上的单独画布上围绕人物绘制框架。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神经网络加载和人工检测</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切都很简单。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们启动工作程序</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在加载模型（相当长的时间）后，向主线程发送一条空消息，在onmessage事件中，我们显示启动按钮，此后工作程序准备好接收图像。</font><font style="vertical-align: inherit;">完整的工作人员代码：</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-keyword">async</span> () =&gt; {<font></font>
  self.importScripts(<span class="hljs-string">'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js'</span>)<font></font>
  self.importScripts(<span class="hljs-string">'https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd'</span>)<font></font>
<font></font>
  <span class="hljs-keyword">let</span> model = <span class="hljs-keyword">await</span> cocoSsd.load()<font></font>
  self.postMessage({})<font></font>
<font></font>
  self.onmessage = <span class="hljs-keyword">async</span> (ev) =&gt; {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> model.detect(ev.data)
    <span class="hljs-keyword">const</span> person = result.find(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.class === <span class="hljs-string">'person'</span>)
    <span class="hljs-keyword">if</span> (person) <font></font>
      self.postMessage({<span class="hljs-attr">ok</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bbox</span>: person.bbox})
    <span class="hljs-keyword">else</span>
      self.postMessage({<span class="hljs-attr">ok</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">bbox</span>: <span class="hljs-literal">null</span>})<font></font>
  }<font></font>
})()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在主线程中，</font><font style="vertical-align: inherit;">仅在从工作程序接收到先前的结果后</font><font style="vertical-align: inherit;">，我们才</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动grab_video（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">，即，检测频率将取决于系统负载。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频录制</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.recorder.rec = <span class="hljs-keyword">new</span> MediaRecorder(<span class="hljs-keyword">this</span>.stream, {<span class="hljs-attr">mimeType</span> : <span class="hljs-string">"video/webm"</span>})
<span class="hljs-keyword">this</span>.recorder.rec.ondataavailable = <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> {
   <span class="hljs-keyword">this</span>.chunk = ev.data
   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.detected) {
      <span class="hljs-keyword">this</span>.send_chunk()<font></font>
   } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.recorder.num &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.send_chunk()
      <span class="hljs-keyword">this</span>.recorder.num--<font></font>
   }<font></font>
}<font></font>
...<font></font>
this.recorder.rec.start()<font></font>
<span class="hljs-keyword">this</span>.recorder.num = <span class="hljs-number">0</span>
<span class="hljs-keyword">this</span>.recorder.interval = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
   <span class="hljs-keyword">this</span>.recorder.rec.stop()
   <span class="hljs-keyword">this</span>.recorder.rec.start()<font></font>
}, CHUNK_DURATION)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在记录器的每个停止位置（我们使用固定的时间间隔），都会引发ondataavailable事件，该事件将以Blob格式记录的片段被传输，保存在this.chunk中并异步发送。是的，this.send_chunk（）返回一个promise，但是该函数花费很长时间（在Base64中编码，发送电子邮件或在本地保存文件），我们不等待它执行也不处理结果-因此没有等待。即使事实证明新的视频剪辑出现的次数多于发送的次数，JS引擎也会为开发人员透明地排列承诺的范围，迟早所有数据都将被发送/记录。唯一需要注意的是在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">send_chunk（）</font></a><font style="vertical-align: inherit;">函数内部</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在第一次等待之前，您需要使用slice（）方法克隆Blob，因为this.chunk链接每CHUNK_DURATION秒都会被摩擦一次。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gmail API</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用于发送信件。</font><font style="vertical-align: inherit;">该API已经很老了，部分是基于Promise，部分是关于回调，文档和示例的，因此该API并不完整。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">授权</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们会在Google开发者控制台中获取应用程序和客户端密钥。</font><font style="vertical-align: inherit;">在弹出的授权窗口中，Google报告该应用程序尚未通过验证，您必须单击“高级设置”以输入。</font><font style="vertical-align: inherit;">检查Google中的应用程序是一项艰巨的任务，您需要确认域的所有权（我没有），正确排列主页，所以我决定不打扰。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'https://apis.google.com/js/api.js'</span>)<font></font>
gapi.load(<span class="hljs-string">'client:auth2'</span>, <span class="hljs-keyword">async</span> () =&gt; {
   <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> gapi.client.init({
         <span class="hljs-attr">apiKey</span>: API_KEY,
         <span class="hljs-attr">clientId</span>: CLIENT_ID,
         <span class="hljs-attr">discoveryDocs</span>: [<span class="hljs-string">'https://www.googleapis.com/discovery/v1/apis/gmail/v1/rest'</span>],
         <span class="hljs-attr">scope</span>: <span class="hljs-string">'https://www.googleapis.com/auth/gmail.send'</span><font></font>
      }) <font></font>
      <span class="hljs-keyword">if</span> (!gapi.auth2.getAuthInstance().isSignedIn.je) {
         <span class="hljs-keyword">await</span> gapi.auth2.getAuthInstance().signIn()<font></font>
      }<font></font>
      <span class="hljs-keyword">this</span>.msg.innerHTML = <span class="hljs-string">''</span>
      <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'nav'</span>).style.display = <span class="hljs-string">''</span>
   } <span class="hljs-keyword">catch</span>(e) {
      <span class="hljs-keyword">this</span>.msg.innerHTML = <span class="hljs-string">'Gmail authorization error: '</span> + <span class="hljs-built_in">JSON</span>.stringify(e, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>)<font></font>
   }<font></font>
})<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电子邮件发送</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">无法连接Base64编码的字符串，这很不方便。</font><font style="vertical-align: inherit;">如何以二进制格式发送视频，我仍然不明白。</font><font style="vertical-align: inherit;">在最后几行中，我们将回调转换为Promise。</font><font style="vertical-align: inherit;">不幸的是，这必须经常进行。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> send_mail(subject, mime_type, body) {
   <span class="hljs-keyword">const</span> headers = {
      <span class="hljs-string">'From'</span>: <span class="hljs-string">''</span>,
      <span class="hljs-string">'To'</span>: <span class="hljs-keyword">this</span>.email,
      <span class="hljs-string">'Subject'</span>: <span class="hljs-string">'Balajahe CCTV: '</span> + subject,
      <span class="hljs-string">'Content-Type'</span>: mime_type,
      <span class="hljs-string">'Content-transfer-encoding'</span>: <span class="hljs-string">'base64'</span><font></font>
   }<font></font>
   <span class="hljs-keyword">let</span> head = <span class="hljs-string">''</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(headers)) head += k + <span class="hljs-string">': '</span> + v + <span class="hljs-string">'\r\n'</span>
   <span class="hljs-keyword">const</span> request = gapi.client.gmail.users.messages.send({
      <span class="hljs-string">'userId'</span>: <span class="hljs-string">'me'</span>,
      <span class="hljs-string">'resource'</span>: { <span class="hljs-string">'raw'</span>: btoa(head + <span class="hljs-string">'\r\n'</span> + body) }<font></font>
   })<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<font></font>
      request.execute(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
         <span class="hljs-keyword">if</span> (!res.code) <font></font>
            resolve() <font></font>
         <span class="hljs-keyword">else</span> <font></font>
            reject(res)<font></font>
      })<font></font>
   })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将视频剪辑保存到磁盘。</font><font style="vertical-align: inherit;">我们使用隐藏的超链接。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'a'</span>)<font></font>
URL.revokeObjectURL(a.href)<font></font>
a.href = URL.createObjectURL(chunk)<font></font>
a.download = name<font></font>
a.click()</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Web组件世界中的状态管理</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
继续</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提出的想法</font><font style="vertical-align: inherit;">，我将其带到</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑端</font><font style="vertical-align: inherit;">的</font><s><font style="vertical-align: inherit;">荒谬之</font></s><font style="vertical-align: inherit;">处（仅适用于lulz），并将对状态的控制颠倒了。</font><font style="vertical-align: inherit;">如果通常将JS变量视为状态，并且DOM仅是当前显示，那么在我的情况下，数据源是DOM本身（因为Web组件是寿命很长的DOM节点），并且对于在JS端使用数据，Web组件提供了getters /每个表单字段的设置器。</font><font style="vertical-align: inherit;">因此，例如，使用简单的&lt;button&gt;代替了样式中令人讨厌的复选框，并且按钮的“ value”（按下true，按下false）是class属性的值，可让您使用以下方式对其进行样式设置：</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.true</span> {<span class="hljs-attribute">background-color</span>: red}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并得到这样的值：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">get</span> <span class="hljs-title">detecting</span>() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'#detecting'</span>).className === <span class="hljs-string">'true'</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我不建议在生产中使用它，因为这是降低生产率的好方法。</font><font style="vertical-align: inherit;">尽管...虚拟DOM也不免费，我也没有做基准测试。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">离线模式</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，添加一些PWA，即安装</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务人员</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">服务人员</font></a><font style="vertical-align: inherit;">将缓存所有网络请求，并允许应用程序在不访问Internet的情况下工作。</font><font style="vertical-align: inherit;">细微差别-在有关服务人员的文章中，他们通常提供以下算法：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在安装事件中-创建高速缓存的新版本，并将所有必需的资源添加到高速缓存中。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Activate事件中-删除除当前版本以外的所有版本的缓存。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在fetch事件中-首先，我们尝试从缓存中获取资源，如果找不到资源，我们将发送网络请求，并将其结果添加到缓存中。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，由于两个原因，这种方案是不方便的。首先，在工作人员的代码中，您需要具有所有必要资源的最新列表，在使用第三方库的大型项目中，请尝试跟踪所有附加的导入（包括动态导入）。第二个问题-更改任何文件时，您需要增加service worker的版本，这将导致安装新的worker并使先前的worker无效，并且仅在关闭/打开浏览器时才会发生。简单的页面刷新将无济于事-具有旧缓存的旧工作线程将起作用。哪里可以保证我的客户永远不会保留浏览器标签？因此，首先我们发出一个网络请求，我们将结果异步添加到缓存中（无需等待权限解析cache.put（ev.request，resp.clone（））），如果网络不可用，则从缓存中获取它。最好输掉一天然后在5分钟内©飞行。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尚未解决的问题</font></font></h4><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在某些手机上，神经网络速度变慢，也许就我而言，COCO-SSD不是最佳选择，但我不是ML专家，因此我采用了第一个听到的声音。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我没有找到一个示例，说明如何通过GAPI发送的视频不是Base64格式，而是原始二进制文件。</font><font style="vertical-align: inherit;">这将节省处理器时间和网络流量。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不了解安全性。</font><font style="vertical-align: inherit;">为了进行本地调试，我将localhost域添加到了Google应用程序中，但是如果有人开始使用应用程序密钥发送垃圾邮件-Google会自行阻止密钥还是发送者的帐户？</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
谢谢您的反馈。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github上的资源。</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
谢谢您的关注。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN491994/index.html">从Cocoapods迁移到Swift Package Manager</a></li>
<li><a href="../zh-CN491996/index.html">有关C ++中协程的更多信息</a></li>
<li><a href="../zh-CN492000/index.html">产品第一。燃尽</a></li>
<li><a href="../zh-CN492002/index.html">吸光翼：超级黑蝴蝶的秘密</a></li>
<li><a href="../zh-CN492004/index.html">如何从程序员成长为经理（“我想成为大海的情妇”）</a></li>
<li><a href="../zh-CN492008/index.html">IT动机研究的结果：开发人员对他们的工作满意吗？</a></li>
<li><a href="../zh-CN492010/index.html">设计系统的阴暗面以及如何处理</a></li>
<li><a href="../zh-CN492012/index.html">Gyenno稳定炊具可补偿高达80％的震颤</a></li>
<li><a href="../zh-CN492016/index.html">ABP和所有，所有，所有内容：数据中心中的自动储备金录入</a></li>
<li><a href="../zh-CN492018/index.html">超速：智能交通系统领域的风险与脆弱性</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>