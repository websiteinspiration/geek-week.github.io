<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥üèø ‚ùå üïé Polimorfismo basado en conceptos C ++ en c√≥digo de producto: PassManager en LLVM üê≤ üõåüèΩ üññ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy vamos a hablar sobre un modismo interesante presentado por Sean Parent (Adobe), una figura conocida en la comunidad de C ++. A menudo hace present...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Polimorfismo basado en conceptos C ++ en c√≥digo de producto: PassManager en LLVM</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/samsung/blog/505850/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hoy vamos a hablar sobre un modismo interesante presentado por Sean Parent (Adobe), una figura conocida en la comunidad de C ++. </font><font style="vertical-align: inherit;">A menudo hace presentaciones y publica una serie de art√≠culos de Better Code. </font><font style="vertical-align: inherit;">Una de sus ideas que utiliza Photoshop es el polimorfismo basado en conceptos. </font><font style="vertical-align: inherit;">Esto es cuando implementamos el polimorfismo no a trav√©s de la herencia expl√≠cita, sino usando una t√©cnica que incluye programaci√≥n generalizada, y como resultado obtenemos algunas ventajas adicionales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El art√≠culo est√° organizado de la siguiente manera:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© es el polimorfismo basado en conceptos y por qu√© es necesario?</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un poco sobre LLVM y su dispositivo</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo de polimorfismo basado en conceptos en LLVM PassManager</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ventajas del enfoque</font></font><br>
</li>
</ol><br>
<br>
<img src="https://habrastorage.org/webt/hg/ru/az/hgruazi6vbztkex50vkgdcfgknw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una imagen que ilustra la tesis "La herencia es malvada". </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente</font></font></a></i><br>
<a name="habracut"></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© es el polimorfismo basado en conceptos y por qu√© es necesario?</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En C ++, el polimorfismo din√°mico se implementa usando funciones virtuales y herencia, y el polimorfismo est√°tico usando patrones. </font><font style="vertical-align: inherit;">Aqu√≠ combinamos estos dos enfoques y tomamos lo mejor de ellos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El uso expl√≠cito de la herencia a menudo conduce a una conectividad de c√≥digo excesiva y a la violaci√≥n del principio de separaci√≥n de interfaz ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">¬øC√≥mo implementar el polimorfismo din√°mico sin estas desventajas? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sean Parent propuso un idioma llamado Polimorfismo basado en conceptos, donde la herencia est√° impl√≠cita y oculta para el usuario. </font><font style="vertical-align: inherit;">Puede obtener m√°s informaci√≥n sobre esto en su informe La </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">herencia es la clase b√°sica del mal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donde muestra toda la idea usando Photoshop e historial de acci√≥n como ejemplo, aprender√° c√≥mo funciona realmente el "pincel hist√≥rico".</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un poco sobre LLVM y su dispositivo</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me gustar√≠a mostrar las ventajas de este idioma usando el ejemplo de LLVM. </font><font style="vertical-align: inherit;">Qui√©n no sabe, LLVM es una infraestructura para desarrollar compiladores. </font><font style="vertical-align: inherit;">A continuaci√≥n se muestra una arquitectura LLVM de muy alto nivel, que cubre solo aquellas entidades que se utilizan m√°s adelante en el art√≠culo. </font><font style="vertical-align: inherit;">Para m√°s informaci√≥n, consulte la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oficial </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eu/zw/wa/euzwwalazlbmv9kqy8mzbrv95hw.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta es la arquitectura de LLVM y, en principio, de cualquier compilador moderno.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Las partes principales son las siguientes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Front End toma el c√≥digo fuente del programa y lo convierte en una representaci√≥n intermedia (IR). </font><font style="vertical-align: inherit;">Esto simplifica el trabajo del resto del compilador para que no trate con c√≥digo C ++ complejo.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Middle End: un conjunto de optimizaciones, an√°lisis y transformaciones. </font><font style="vertical-align: inherit;">En su forma m√°s general, es un conjunto de pases (Pases). </font><font style="vertical-align: inherit;">Todos los pases son registrados y lanzados por un componente especial llamado PassManager.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back End genera directamente el c√≥digo de destino.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El compilador presenta el programa en forma de varias entidades b√°sicas. </font><font style="vertical-align: inherit;">Este es un m√≥dulo (condicionalmente archivo .cpp), una funci√≥n, una unidad base que contiene un conjunto de instrucciones. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ig/vi/0i/igvi0icjbjtgmhbfvdwvvtbyy0c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVM ahora tiene dos versiones de PassManager:&nbsp;</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LegacyPassManager, utiliza el cl√°sico polimorfismo basado en herencia en tiempo de ejecuci√≥n. </font><font style="vertical-align: inherit;">La jerarqu√≠a de herencia incluye pases ejecutados en un m√≥dulo, funci√≥n, bucle, etc.&nbsp;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PassManager: una nueva versi√≥n, basada √∫nicamente en el polimorfismo basado en conceptos, se propone reemplazar a LegacyPassManager. </font><font style="vertical-align: inherit;">Ambas versiones existen en paralelo y se desarrollan de forma independiente.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea del art√≠culo es demostrar el concepto en c√≥digo de producto real, que se implementa de dos maneras diferentes, y mostrar las ventajas de este √∫ltimo enfoque.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo de polimorfismo basado en conceptos en LLVM PassManager</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementado en Legacy</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, c√≥mo se organiza todo de manera cl√°sica, en el LegacyPassManager. </font><font style="vertical-align: inherit;">Digamos que tenemos un PassManager de clase y hay un Pase de clase: un pase. </font><font style="vertical-align: inherit;">Tenemos tal jerarqu√≠a: ModulePass, de la cual nuestra clase hereda, por ejemplo, Propagaci√≥n constante. </font><font style="vertical-align: inherit;">Hay un m√©todo runOnModule, aqu√≠ es virtual. </font><font style="vertical-align: inherit;">Entonces tenemos el polimorfismo de tiempo de ejecuci√≥n habitual:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/// ModulePass class - This class is used to implement unstructured</span>
<span class="hljs-comment">/// interprocedural optimizations and analyses. ModulePasses may do anything</span>
<span class="hljs-comment">/// they want to the program.</span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModulePass</span> :</span> <span class="hljs-keyword">public</span> Pass {<font></font>
...<font></font>
<span class="hljs-comment">/// runOnModule - Virtual method overriden by subclasses to process the module</span>
<span class="hljs-comment">/// being operated on.</span>
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/// IPCP - The interprocedural constant propagation pass</span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IPCP</span> :</span> <span class="hljs-keyword">public</span> ModulePass {<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">runOnModule</span><span class="hljs-params">(Module &amp;M)</span> <span class="hljs-keyword">override</span></span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Miremos el c√≥digo, ¬øcu√°l es el problema aqu√≠? Vemos que en esta jerarqu√≠a, los m√©todos para comenzar un pasaje son diferentes dependiendo de lo que se debe realizar (en una funci√≥n - runOnFunction, un m√≥dulo - runOnModule, un ciclo - runOnLoop, etc.). A su vez, esto hace que sea imposible procesar la colecci√≥n de pases que funcionan con diferentes entidades IR de una sola manera (en realidad, aplicar el polimorfismo). Parecer√≠a, obviamente, c√≥mo hacerlo bien: necesita un m√©todo de ejecuci√≥n virtual, que se redefinir√° en los herederos. Pero entonces surge un problema: los m√©todos de ejecuci√≥n en las clases sucesoras tendr√°n una firma diferente, porque el par√°metro siempre se pasa de su tipo: funci√≥n, m√≥dulo, etc. Por lo tanto, debe crear una clase base ficticia para M√≥dulo, Funci√≥n, etc., pasar un puntero a esta clase en ejecuci√≥n y realizar una conversi√≥n descendente dentro del m√©todo,dependiendo de qu√© tipo de objeto se encuentre en este puntero. Y algo extra√±o comienza: cuando aparece una nueva entidad subordinada, ahora nos vemos obligados a reescribir el c√≥digo superior cada vez, lo que contradice todos los principios de dise√±o.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede escribir manualmente una clase de adaptador para cada caso. </font><font style="vertical-align: inherit;">Pero esta es una idea larga y poco interesante, y de hecho una idea extra√±a para escribir clases de contenedor para la operaci√≥n conveniente de solo servir componentes. </font><font style="vertical-align: inherit;">Ser√≠a mejor generar este c√≥digo autom√°ticamente usando plantillas. </font><font style="vertical-align: inherit;">Esto es exactamente lo que se propone abordar en el enfoque en discusi√≥n. </font><font style="vertical-align: inherit;">Adem√°s, como ver√° m√°s adelante, obtendremos algunas consecuencias m√°s √∫tiles.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como se sugiere en la nueva versi√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo siguiente sucede en el nuevo PassManager. </font><font style="vertical-align: inherit;">El concepto de un objeto polim√≥rfico se generaliza de la siguiente manera. </font><font style="vertical-align: inherit;">Decimos que si un objeto implementa alg√∫n m√©todo, entonces introducimos un conjunto de m√©todos que queremos que sean polim√≥rficos, y decimos que todas las clases que implementan este m√©todo son polim√≥rficos, es decir, podemos usarlos en contextos intercambiables en Este es PassManager. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere la clase PassManager en LLVM. </font><font style="vertical-align: inherit;">Aqu√≠ hay una versi√≥n simplificada, y la completa se puede encontrar en llvm / include / llvm / IR / PassManager.h. </font><font style="vertical-align: inherit;">El par√°metro de plantilla IR se especializa directamente en la entidad por la que estamos pasando (la funci√≥n de ejecuci√≥n). </font><font style="vertical-align: inherit;">Puede ser un m√≥dulo, funci√≥n o ciclo. </font><font style="vertical-align: inherit;">Nos fijamos en el c√≥digo, m√°s explicaciones ser√°n:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassManager</span> {</span>
<span class="hljs-keyword">public</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; Pass : Passes) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pass-&gt;run(graph, args...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PassT&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addPass</span><span class="hljs-params">(PassT Pass)</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passes.emplace_back(<span class="hljs-keyword">new</span> detail::PassModel&lt;IR, PassT, ArgTs...&gt;(<span class="hljs-built_in">std</span>::move(Pass)));<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;detail::PassConcept&lt;IR, ArgTs...&gt;&gt;&gt; Passes;<font></font>
<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos las siguientes entidades b√°sicas:</font></font><br>
<br>
<ul>
<li> run     ,        run<br>
</li>
<li> addPass     (      )    PassT<br>
</li>
<li> Passes ‚Äî ,      .         ,       ,        type erasure,     <br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ¬øqu√© tipo de tipo deber√≠a ser? </font><font style="vertical-align: inherit;">¬øQu√© se almacena en el vector Pases? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, veamos qu√© son PassModel y PassConcept. </font><font style="vertical-align: inherit;">Estas son clases auxiliares internas de PassManager. </font><font style="vertical-align: inherit;">Ambos est√°n en el espacio de nombres de detalle. </font><font style="vertical-align: inherit;">Primero, veamos c√≥mo se ve la clase PassConcept. </font><font style="vertical-align: inherit;">Contiene el mismo m√©todo de ejecuci√≥n nuevamente, aqu√≠ es un m√©todo puramente virtual.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> detail {<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassConcept</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">virtual</span> ~PassConcept() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> </span>= <span class="hljs-number">0</span>;<font></font>
<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La segunda clase, PassModel, tambi√©n es repetitiva. </font><font style="vertical-align: inherit;">Se hereda de PassConcept.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> IR, <span class="hljs-keyword">typename</span> PassT, <span class="hljs-keyword">typename</span>... ArgTs&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassModel</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> PassConcept&lt;IR, ArgTs...&gt; {
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">PassModel</span><span class="hljs-params">(PassT Pass)</span> : <span class="hljs-title">pass_</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::move(pass))</span> </span>{}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(IR&amp; ir, ArgTs... args)</span> <span class="hljs-keyword">final</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass_.run(ir, args...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PassT pass_;<font></font>
<font></font>
};<font></font>
<font></font>
} <span class="hljs-comment">// end namespace detail</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qu√© contiene:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pass_ privado campo de tipo PassT</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un constructor que acepta un objeto de tipo PassT como entrada. </font><font style="vertical-align: inherit;">No hace nada intrigante, solo inicializa pass_ usando la sem√°ntica del movimiento</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m√©todo de ejecuci√≥n, que simplemente llama al m√©todo de ejecuci√≥n al pasar. </font><font style="vertical-align: inherit;">Pasar, respectivamente, todos los argumentos que puedan estar all√≠.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recordamos ahora d√≥nde empezamos. A su vez, PassManager almacena todos estos pasajes. En vector Pases de elementos de tipo PassConcept. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, el panorama general. Creado por PassManager. Usando AddPass, registra esos pases que queremos hacer sobre el m√≥dulo, la funci√≥n, el bucle, etc. Por ejemplo, en l√≠nea, propagaci√≥n constante, desenrollado de bucles, etc. Ellos mismos no son heredados de nadie, solo deben tener un m√©todo de ejecuci√≥n. Y solo todo este concepto lo proporciona. ¬øC√≥mo?&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que tenemos optimizaci√≥n en l√≠nea. Agregamos un objeto de tipo Inline a addPass. En consecuencia, en Passes, en el vector, colocamos este Inline, ya en forma de PassConcept. ¬øC√≥mo podemos hacer esto? Inline no se hereda de la clase PassConcept. ¬øC√≥mo ponemos un elemento en un vector? No podemos hacer la conversi√≥n al tipo base (upcasting) porque no hay herencia, y aqu√≠ se hace tal truco. Tenemos esta clase auxiliar PassConcept que define la interfaz. √âl dice que todos sus descendientes deben implementar el m√©todo de ejecuci√≥n. Tenemos PassModel, que a su vez es repetitivo. Entonces, cuando ponemos Inline, este PassModel se instancia con este tipo Inline, este objeto se compila dentro de esta clase. PassModel mismo redefine la ejecuci√≥n, que por s√≠ misma ya llama ejecutar para este pasaje,es decir, ejecutar desde la clase Inline. Todo esto se resuelve en tiempo de compilaci√≥n: si Inline no define el m√©todo de ejecuci√≥n, tendremos un error en tiempo de compilaci√≥n.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, este polimorfismo se logra sin herencia. Puede surgir la pregunta: ¬øc√≥mo no es herencia, porque aqu√≠ est√°, PassModel se hereda de PassConcept? Respuesta: hay herencia, pero es interna, no sobresale, el usuario no sabe nada al respecto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hablamos a nivel conceptual. Aqu√≠ tenemos un usuario, √©l quiere anular un cierto m√©todo. Al mismo tiempo, √©l no quiere ser heredado, para no extraer dependencias adicionales de s√≠ mismo. ¬øC√≥mo hacerlo? Dentro de nosotros mismos, a trav√©s de PassConcept, PassModel, hacemos polimorfismo de tiempo de ejecuci√≥n, a trav√©s de la herencia, pero el usuario no lo sabe: estos son todos los interiores de estas dos clases, est√°n definidos en su espacio de nombres.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez m√°s, ¬øc√≥mo se logra esto? </font><font style="vertical-align: inherit;">Tengo una clase, llam√©mosla, que sea Inline, en t√©rminos del compilador. </font><font style="vertical-align: inherit;">Agregamos Inline al vector, respectivamente, creamos el objeto PassModel. </font><font style="vertical-align: inherit;">Tiene un constructor que toma el objeto de este par√°metro de plantilla. </font><font style="vertical-align: inherit;">Y as√≠, cuando llamamos al m√©todo de ejecuci√≥n en PassManager, ejecuta todos los pasajes, en este caso solo tenemos un pase, tiene el tipo Inline. </font><font style="vertical-align: inherit;">Llama al m√©todo runC de PassConcept. </font><font style="vertical-align: inherit;">El mismo m√©todo de ejecuci√≥n que se encuentra dentro de PassModel, que se instancia mediante el tipo Inline. </font><font style="vertical-align: inherit;">Y ya este m√©todo llama al m√©todo run en el pasaje registrado, en este caso, Inline, y como resultado, se ejecuta run on Inline.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ventajas del enfoque</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As√≠ es como hicimos un comportamiento diferente sin usar expl√≠citamente la herencia. Ahora no tenemos la dependencia expl√≠cita que ten√≠a antes en el LegacyPassManager.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qu√© cosa recursiva inusual resulta. Podemos usar polimorfismo para cualquier objeto que anule el m√©todo de ejecuci√≥n. Dado que el m√©todo de ejecuci√≥n anula el PassManager, puede registrarse, es decir, incrustarse en el vector de Passes y volver a llamarse.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resulta que podemos mezclar todo. El antiguo PassManager, que es Legacy, tiene una clara separaci√≥n. Existe una optimizaci√≥n modular, que se realiza en el m√≥dulo; Hay optimizaci√≥n que sucede en la funci√≥n. Y aqu√≠ todo sucede sin problemas. Hacemos PassManager, lo instanciamos con el tipo "M√≥dulo", ponemos Inline en √©l, algo m√°s, algunas otras optimizaciones modulares. Luego, el segundo PassManager, lo instanciamos con el tipo "Funci√≥n", ponemos optimizaciones en la funci√≥n. Y luego, en el PassManager, que es instanciado por el m√≥dulo, puede poner otro PassManager, que es instanciado por la funci√≥n, a trav√©s de este vector Passes.&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs">PassManager&lt;Module&gt; MPM;
<span class="hljs-comment">// ... register passes on module</span><font></font>
MPM.addPass(GlobalDCEPass())<font></font>
MPM.addPass(PGOInstrumentationGen());<font></font>
<span class="hljs-comment">//... register passes on function</span><font></font>
PassManager&lt;Function&gt; FPM;&nbsp;<font></font>
FPM.addPass(CallSiteSplittingPass());<font></font>
<span class="hljs-comment">//... register all registered passes on function in module pass manager MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øTienes tiempo para seguir? Tenemos dos PassManagers. Uno con m√≥dulo de tipo IR, el otro con funci√≥n de tipo IR. Digamos que en el que tiene el m√≥dulo, ya pusimos algunos pases. Ahora queremos mezclarlos con pases que se ejecutan en una funci√≥n. ¬øQue estamos haciendo? Llamamos addPass y pasamos PassManager como Pass, que se instancia con el tipo IR "Funci√≥n" (en c√≥digo real, no es PassManager en s√≠ lo que se coloca all√≠, sino una clase especial que lo envuelve, pero a nivel conceptual no importa).&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, podemos mezclar diferentes niveles de optimizaci√≥n: gracias a la anidaci√≥n de PassManagers, ejecutar alternativamente pases al m√≥dulo, funci√≥n, ciclo, etc. </font><font style="vertical-align: inherit;">En Legacy PassManager, esto es m√°s complicado, hay una clase separada para m√≥dulos que tiene una funci√≥n virtual runOnModule, una clase separada para funciones con un m√©todo virtual runOnFunction, etc. </font><font style="vertical-align: inherit;">Ambas clases se heredan del ancestro com√∫n de Pass, pero son independientes entre s√≠ y tienen una interfaz diferente, lo que hace que el uso del LegacyPassManager sea inconveniente para invocar pases en diferentes entidades IR (m√≥dulo, funci√≥n, bucle) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Materiales de lectura adicionales:</font></font><br>
&nbsp;<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM para estudiantes de posgrado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : una introducci√≥n simple a LLVM</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presentaci√≥n de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chandler Carrut sobre c√≥mo se organizan los pases LLVM</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presentaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chandler Carruth sobre detalles de implementaci√≥n PassManager</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un hilo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la lista de correo que discute la diferencia entre LegacyPassManager y PassManager</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autores: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/73/et/tp/73ettpg9jylifuwfvohspok-nv4.png" align="left"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roman Rusyaev, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ingeniero experto </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Equipo de compilaci√≥n de inteligencia artificial </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instituto de Investigaci√≥n y Desarrollo de Samsung, Rusia </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pronto Roman hablar√° en la conferencia C ++ Rusia 2020 Mosc√∫ con Anton Polukhin: all√≠ hablar√°n sobre la copia de la elisi√≥n actual y futura: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace al informe</font></font></a><br>
<br clear="all">
<img src="https://habrastorage.org/webt/ay/fa/a2/ayfaa2i4aukgor-uh5ija7gstie.png" align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tatyana Volkova, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Especialista Principal de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Negocios Equipo de desarrollo </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Samsung R&amp;D Institute, Rusia</font></font></i><br>
<br clear="all"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es505824/index.html">Gu√≠a: su propia VPN L2TP</a></li>
<li><a href="../es505826/index.html">C√≥mo obtener una visi√≥n del 100% y a√∫n m√°s</a></li>
<li><a href="../es505834/index.html">Muestras medianas. Intervalos de confianza y comparaci√≥n</a></li>
<li><a href="../es505838/index.html">Tecnolog√≠a FPGA para miles de aplicaciones.</a></li>
<li><a href="../es505846/index.html">¬øCu√°les son los verdaderos problemas matem√°ticos al desarrollar vacunas a partir de COVID-19?</a></li>
<li><a href="../es505856/index.html">De la fuerza bruta al intento de privacidad: lo que enfrentan los proveedores de SaaS</a></li>
<li><a href="../es505860/index.html">Spring Boot, Hibernate y Kotlin para principiantes paso a paso</a></li>
<li><a href="../es505870/index.html">C√≥mo promover juegos y aplicaciones m√≥viles en Jap√≥n, Corea y China</a></li>
<li><a href="../es505872/index.html">Historia de veh√≠culos no tripulados.</a></li>
<li><a href="../es505880/index.html">C√≥mo escribir su √≠ndice en Tarantool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>